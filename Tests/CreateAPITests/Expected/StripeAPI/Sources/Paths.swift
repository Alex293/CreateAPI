// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var _3dSecure: __3dSecure {
        __3dSecure(path: "/v1/3d_secure")
    }

    public struct __3dSecure {
        /// Path: `/v1/3d_secure`
        public let path: String

        /// <p>Initiate 3D Secure authentication.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.ThreeDSecure> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Amount of the charge that you will create when authentication completes.
            public var amount: Int
            /// The ID of a card token, or the ID of a card belonging to the given customer.
            public var card: String?
            /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
            public var currency: String
            /// The customer associated with this 3D secure authentication.
            public var customer: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The URL that the cardholder's browser will be returned to when authentication completes.
            public var returnURL: String

            public init(amount: Int, card: String? = nil, currency: String, customer: String? = nil, expand: [String]? = nil, returnURL: String) {
                self.amount = amount
                self.card = card
                self.currency = currency
                self.customer = customer
                self.expand = expand
                self.returnURL = returnURL
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(card, forKey: "card")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(returnURL, forKey: "return_url")
                return encoder.items
            }
        }
    }
}

extension Paths.__3dSecure {
    public func threeDSecure(_ threeDSecure: String) -> WithThreeDSecure {
        WithThreeDSecure(path: "\(path)/\(threeDSecure)")
    }

    public struct WithThreeDSecure {
        /// Path: `/v1/3d_secure/{three_d_secure}`
        public let path: String

        /// <p>Retrieves a 3D Secure object.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.ThreeDSecure> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths {
    public static var account: Account {
        Account(path: "/v1/account")
    }

    public struct Account {
        /// Path: `/v1/account`
        public let path: String

        /// <p>Retrieves the details of an account.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Account> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates a <a href="/docs/connect/accounts">connected account</a> by setting the values of the parameters passed. Any parameters not provided are left unchanged. Most parameters can be changed only for Custom accounts. (These are marked <strong>Custom Only</strong> below.) Parameters marked <strong>Custom and Express</strong> are not supported for Standard accounts.</p>
        /// 
        /// <p>To update your own account, use the <a href="https://dashboard.stripe.com/account">Dashboard</a>. Refer to our <a href="/docs/connect/updating-accounts">Connect</a> documentation to learn more about updating accounts.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Account> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// An [account token](https://stripe.com/docs/api#create_account_token), used to securely provide details to the account.
            public var accountToken: String?
            /// Either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details.
            public var bankAccount: BankAccount?
            /// Business_profile_specs
            ///
            /// Business information about the account.
            public var businessProfile: BusinessProfile?
            /// The business type.
            public var businessType: BusinessType?
            /// Capabilities_param
            ///
            /// Each key of the dictionary represents a capability, and each capability maps to its settings (e.g. whether it has been requested or not). Each capability will be inactive until you have provided its specific requirements and Stripe has verified them. An account may have some of its requested capabilities be active and some be inactive.
            public var capabilities: Capabilities?
            /// Company_specs
            ///
            /// Information about the company or business. This field is available for any `business_type`.
            public var company: Company?
            /// Three-letter ISO currency code representing the default currency for the account. This must be a currency that [Stripe supports in the account's country](https://stripe.com/docs/payouts).
            public var defaultCurrency: String?
            /// Documents_specs
            ///
            /// Documents that may be submitted to satisfy various informational requests.
            public var documents: Documents?
            /// The email address of the account holder. This is only to make the account easier to identify to you. Stripe only emails Custom accounts with your consent.
            public var email: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// A card or bank account to attach to the account for receiving [payouts](https://stripe.com/docs/connect/bank-debit-card-payouts) (you won’t be able to use it for top-ups). You can provide either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary, as documented in the `external_account` parameter for [bank account](https://stripe.com/docs/api#account_create_bank_account) creation. <br><br>By default, providing an external account sets it as the new default external account for its currency, and deletes the old default if one exists. To add additional external accounts without replacing the existing default for the currency, use the bank account or card creation API.
            public var externalAccount: String?
            /// Individual_specs
            ///
            /// Information about the person represented by the account. This field is null unless `business_type` is set to `individual`.
            public var individual: Individual?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// Settings_specs_update
            ///
            /// Options for customizing how the account functions within Stripe.
            public var settings: Settings?
            /// Tos_acceptance_specs
            ///
            /// Details on the account's acceptance of the [Stripe Services Agreement](https://stripe.com/docs/connect/updating-accounts#tos-acceptance).
            public var tosAcceptance: TosAcceptance?

            /// Either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details.
            public struct BankAccount: Encodable {
                /// External_account_payout_bank_account
                public var object: Object?
                public var string: String?

                /// External_account_payout_bank_account
                public struct Object: Encodable {
                    public var accountHolderName: String?
                    public var accountHolderType: AccountHolderType?
                    public var accountNumber: String
                    public var accountType: AccountType?
                    public var country: String
                    public var currency: String?
                    public var object: Object?
                    public var routingNumber: String?

                    public enum AccountHolderType: String, Codable, CaseIterable {
                        case company
                        case individual
                    }

                    public enum AccountType: String, Codable, CaseIterable {
                        case checking
                        case futsu
                        case savings
                        case toza
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case bankAccount = "bank_account"
                    }

                    public init(accountHolderName: String? = nil, accountHolderType: AccountHolderType? = nil, accountNumber: String, accountType: AccountType? = nil, country: String, currency: String? = nil, object: Object? = nil, routingNumber: String? = nil) {
                        self.accountHolderName = accountHolderName
                        self.accountHolderType = accountHolderType
                        self.accountNumber = accountNumber
                        self.accountType = accountType
                        self.country = country
                        self.currency = currency
                        self.object = object
                        self.routingNumber = routingNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountHolderName, forKey: "account_holder_name")
                        encoder.encode(accountHolderType, forKey: "account_holder_type")
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(accountType, forKey: "account_type")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(object, forKey: "object")
                        encoder.encode(routingNumber, forKey: "routing_number")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, string: String? = nil) {
                    self.object = object
                    self.string = string
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(string, forKey: "string")
                    return encoder.items
                }
            }

            /// Business_profile_specs
            ///
            /// Business information about the account.
            public struct BusinessProfile: Encodable {
                public var mcc: String?
                public var name: String?
                public var productDescription: String?
                /// Address_specs
                public var supportAddress: SupportAddress?
                public var supportEmail: String?
                public var supportPhone: String?
                public var supportURL: SupportURL?
                public var url: String?

                /// Address_specs
                public struct SupportAddress: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                public struct SupportURL: Encodable {
                    public var string: String?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(string: String? = nil, object: Object? = nil) {
                        self.string = string
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(string, forKey: "string")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(mcc: String? = nil, name: String? = nil, productDescription: String? = nil, supportAddress: SupportAddress? = nil, supportEmail: String? = nil, supportPhone: String? = nil, supportURL: SupportURL? = nil, url: String? = nil) {
                    self.mcc = mcc
                    self.name = name
                    self.productDescription = productDescription
                    self.supportAddress = supportAddress
                    self.supportEmail = supportEmail
                    self.supportPhone = supportPhone
                    self.supportURL = supportURL
                    self.url = url
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(mcc, forKey: "mcc")
                    encoder.encode(name, forKey: "name")
                    encoder.encode(productDescription, forKey: "product_description")
                    encoder.encode(supportAddress, forKey: "support_address")
                    encoder.encode(supportEmail, forKey: "support_email")
                    encoder.encode(supportPhone, forKey: "support_phone")
                    encoder.encode(supportURL, forKey: "support_url")
                    encoder.encode(url, forKey: "url")
                    return encoder.items
                }
            }

            /// The business type.
            public enum BusinessType: String, Codable, CaseIterable {
                case company
                case governmentEntity = "government_entity"
                case individual
                case nonProfit = "non_profit"
            }

            /// Capabilities_param
            ///
            /// Each key of the dictionary represents a capability, and each capability maps to its settings (e.g. whether it has been requested or not). Each capability will be inactive until you have provided its specific requirements and Stripe has verified them. An account may have some of its requested capabilities be active and some be inactive.
            public struct Capabilities: Encodable {
                /// Capability_param
                public var acssDebitPayments: AcssDebitPayments?
                /// Capability_param
                public var afterpayClearpayPayments: AfterpayClearpayPayments?
                /// Capability_param
                public var auBecsDebitPayments: AuBecsDebitPayments?
                /// Capability_param
                public var bacsDebitPayments: BacsDebitPayments?
                /// Capability_param
                public var bancontactPayments: BancontactPayments?
                /// Capability_param
                public var boletoPayments: BoletoPayments?
                /// Capability_param
                public var cardIssuing: CardIssuing?
                /// Capability_param
                public var cardPayments: CardPayments?
                /// Capability_param
                public var cartesBancairesPayments: CartesBancairesPayments?
                /// Capability_param
                public var epsPayments: EpsPayments?
                /// Capability_param
                public var fpxPayments: FpxPayments?
                /// Capability_param
                public var giropayPayments: GiropayPayments?
                /// Capability_param
                public var grabpayPayments: GrabpayPayments?
                /// Capability_param
                public var idealPayments: IdealPayments?
                /// Capability_param
                public var jcbPayments: JcbPayments?
                /// Capability_param
                public var klarnaPayments: KlarnaPayments?
                /// Capability_param
                public var legacyPayments: LegacyPayments?
                /// Capability_param
                public var oxxoPayments: OxxoPayments?
                /// Capability_param
                public var p24Payments: P24Payments?
                /// Capability_param
                public var sepaDebitPayments: SepaDebitPayments?
                /// Capability_param
                public var sofortPayments: SofortPayments?
                /// Capability_param
                public var taxReportingUs1099K: TaxReportingUs1099K?
                /// Capability_param
                public var taxReportingUs1099Misc: TaxReportingUs1099Misc?
                /// Capability_param
                public var transfers: Transfers?

                /// Capability_param
                public struct AcssDebitPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct AfterpayClearpayPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct AuBecsDebitPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct BacsDebitPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct BancontactPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct BoletoPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct CardIssuing: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct CardPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct CartesBancairesPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct EpsPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct FpxPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct GiropayPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct GrabpayPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct IdealPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct JcbPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct KlarnaPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct LegacyPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct OxxoPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct P24Payments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct SepaDebitPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct SofortPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct TaxReportingUs1099K: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct TaxReportingUs1099Misc: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct Transfers: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                public init(acssDebitPayments: AcssDebitPayments? = nil, afterpayClearpayPayments: AfterpayClearpayPayments? = nil, auBecsDebitPayments: AuBecsDebitPayments? = nil, bacsDebitPayments: BacsDebitPayments? = nil, bancontactPayments: BancontactPayments? = nil, boletoPayments: BoletoPayments? = nil, cardIssuing: CardIssuing? = nil, cardPayments: CardPayments? = nil, cartesBancairesPayments: CartesBancairesPayments? = nil, epsPayments: EpsPayments? = nil, fpxPayments: FpxPayments? = nil, giropayPayments: GiropayPayments? = nil, grabpayPayments: GrabpayPayments? = nil, idealPayments: IdealPayments? = nil, jcbPayments: JcbPayments? = nil, klarnaPayments: KlarnaPayments? = nil, legacyPayments: LegacyPayments? = nil, oxxoPayments: OxxoPayments? = nil, p24Payments: P24Payments? = nil, sepaDebitPayments: SepaDebitPayments? = nil, sofortPayments: SofortPayments? = nil, taxReportingUs1099K: TaxReportingUs1099K? = nil, taxReportingUs1099Misc: TaxReportingUs1099Misc? = nil, transfers: Transfers? = nil) {
                    self.acssDebitPayments = acssDebitPayments
                    self.afterpayClearpayPayments = afterpayClearpayPayments
                    self.auBecsDebitPayments = auBecsDebitPayments
                    self.bacsDebitPayments = bacsDebitPayments
                    self.bancontactPayments = bancontactPayments
                    self.boletoPayments = boletoPayments
                    self.cardIssuing = cardIssuing
                    self.cardPayments = cardPayments
                    self.cartesBancairesPayments = cartesBancairesPayments
                    self.epsPayments = epsPayments
                    self.fpxPayments = fpxPayments
                    self.giropayPayments = giropayPayments
                    self.grabpayPayments = grabpayPayments
                    self.idealPayments = idealPayments
                    self.jcbPayments = jcbPayments
                    self.klarnaPayments = klarnaPayments
                    self.legacyPayments = legacyPayments
                    self.oxxoPayments = oxxoPayments
                    self.p24Payments = p24Payments
                    self.sepaDebitPayments = sepaDebitPayments
                    self.sofortPayments = sofortPayments
                    self.taxReportingUs1099K = taxReportingUs1099K
                    self.taxReportingUs1099Misc = taxReportingUs1099Misc
                    self.transfers = transfers
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(acssDebitPayments, forKey: "acss_debit_payments")
                    encoder.encode(afterpayClearpayPayments, forKey: "afterpay_clearpay_payments")
                    encoder.encode(auBecsDebitPayments, forKey: "au_becs_debit_payments")
                    encoder.encode(bacsDebitPayments, forKey: "bacs_debit_payments")
                    encoder.encode(bancontactPayments, forKey: "bancontact_payments")
                    encoder.encode(boletoPayments, forKey: "boleto_payments")
                    encoder.encode(cardIssuing, forKey: "card_issuing")
                    encoder.encode(cardPayments, forKey: "card_payments")
                    encoder.encode(cartesBancairesPayments, forKey: "cartes_bancaires_payments")
                    encoder.encode(epsPayments, forKey: "eps_payments")
                    encoder.encode(fpxPayments, forKey: "fpx_payments")
                    encoder.encode(giropayPayments, forKey: "giropay_payments")
                    encoder.encode(grabpayPayments, forKey: "grabpay_payments")
                    encoder.encode(idealPayments, forKey: "ideal_payments")
                    encoder.encode(jcbPayments, forKey: "jcb_payments")
                    encoder.encode(klarnaPayments, forKey: "klarna_payments")
                    encoder.encode(legacyPayments, forKey: "legacy_payments")
                    encoder.encode(oxxoPayments, forKey: "oxxo_payments")
                    encoder.encode(p24Payments, forKey: "p24_payments")
                    encoder.encode(sepaDebitPayments, forKey: "sepa_debit_payments")
                    encoder.encode(sofortPayments, forKey: "sofort_payments")
                    encoder.encode(taxReportingUs1099K, forKey: "tax_reporting_us_1099_k")
                    encoder.encode(taxReportingUs1099Misc, forKey: "tax_reporting_us_1099_misc")
                    encoder.encode(transfers, forKey: "transfers")
                    return encoder.items
                }
            }

            /// Company_specs
            ///
            /// Information about the company or business. This field is available for any `business_type`.
            public struct Company: Encodable {
                /// Address_specs
                public var address: Address?
                /// Japan_address_kana_specs
                public var addressKana: AddressKana?
                /// Japan_address_kanji_specs
                public var addressKanji: AddressKanji?
                public var isDirectorsProvided: Bool?
                public var isExecutivesProvided: Bool?
                public var name: String?
                public var nameKana: String?
                public var nameKanji: String?
                public var isOwnersProvided: Bool?
                /// Company_ownership_declaration
                public var ownershipDeclaration: OwnershipDeclaration?
                public var phone: String?
                public var registrationNumber: String?
                public var structure: Structure?
                public var taxID: String?
                public var taxIDRegistrar: String?
                public var vatID: String?
                /// Verification_specs
                public var verification: Verification?

                /// Address_specs
                public struct Address: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                /// Japan_address_kana_specs
                public struct AddressKana: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?
                    public var town: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                        self.town = town
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        encoder.encode(town, forKey: "town")
                        return encoder.items
                    }
                }

                /// Japan_address_kanji_specs
                public struct AddressKanji: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?
                    public var town: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                        self.town = town
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        encoder.encode(town, forKey: "town")
                        return encoder.items
                    }
                }

                /// Company_ownership_declaration
                public struct OwnershipDeclaration: Encodable {
                    public var date: Int?
                    public var ip: String?
                    public var userAgent: String?

                    public init(date: Int? = nil, ip: String? = nil, userAgent: String? = nil) {
                        self.date = date
                        self.ip = ip
                        self.userAgent = userAgent
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(date, forKey: "date")
                        encoder.encode(ip, forKey: "ip")
                        encoder.encode(userAgent, forKey: "user_agent")
                        return encoder.items
                    }
                }

                public enum Structure: String, Codable, CaseIterable {
                    case empty = ""
                    case freeZoneEstablishment = "free_zone_establishment"
                    case freeZoneLlc = "free_zone_llc"
                    case governmentInstrumentality = "government_instrumentality"
                    case governmentalUnit = "governmental_unit"
                    case incorporatedNonProfit = "incorporated_non_profit"
                    case limitedLiabilityPartnership = "limited_liability_partnership"
                    case llc
                    case multiMemberLlc = "multi_member_llc"
                    case privateCompany = "private_company"
                    case privateCorporation = "private_corporation"
                    case privatePartnership = "private_partnership"
                    case publicCompany = "public_company"
                    case publicCorporation = "public_corporation"
                    case publicPartnership = "public_partnership"
                    case singleMemberLlc = "single_member_llc"
                    case soleEstablishment = "sole_establishment"
                    case soleProprietorship = "sole_proprietorship"
                    case taxExemptGovernmentInstrumentality = "tax_exempt_government_instrumentality"
                    case unincorporatedAssociation = "unincorporated_association"
                    case unincorporatedNonProfit = "unincorporated_non_profit"
                }

                /// Verification_specs
                public struct Verification: Encodable {
                    /// Verification_document_specs
                    public var document: Document?

                    /// Verification_document_specs
                    public struct Document: Encodable {
                        public var back: String?
                        public var front: String?

                        public init(back: String? = nil, front: String? = nil) {
                            self.back = back
                            self.front = front
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(back, forKey: "back")
                            encoder.encode(front, forKey: "front")
                            return encoder.items
                        }
                    }

                    public init(document: Document? = nil) {
                        self.document = document
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(document, forKey: "document")
                        return encoder.items
                    }
                }

                public init(address: Address? = nil, addressKana: AddressKana? = nil, addressKanji: AddressKanji? = nil, isDirectorsProvided: Bool? = nil, isExecutivesProvided: Bool? = nil, name: String? = nil, nameKana: String? = nil, nameKanji: String? = nil, isOwnersProvided: Bool? = nil, ownershipDeclaration: OwnershipDeclaration? = nil, phone: String? = nil, registrationNumber: String? = nil, structure: Structure? = nil, taxID: String? = nil, taxIDRegistrar: String? = nil, vatID: String? = nil, verification: Verification? = nil) {
                    self.address = address
                    self.addressKana = addressKana
                    self.addressKanji = addressKanji
                    self.isDirectorsProvided = isDirectorsProvided
                    self.isExecutivesProvided = isExecutivesProvided
                    self.name = name
                    self.nameKana = nameKana
                    self.nameKanji = nameKanji
                    self.isOwnersProvided = isOwnersProvided
                    self.ownershipDeclaration = ownershipDeclaration
                    self.phone = phone
                    self.registrationNumber = registrationNumber
                    self.structure = structure
                    self.taxID = taxID
                    self.taxIDRegistrar = taxIDRegistrar
                    self.vatID = vatID
                    self.verification = verification
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(addressKana, forKey: "address_kana")
                    encoder.encode(addressKanji, forKey: "address_kanji")
                    encoder.encode(isDirectorsProvided, forKey: "directors_provided")
                    encoder.encode(isExecutivesProvided, forKey: "executives_provided")
                    encoder.encode(name, forKey: "name")
                    encoder.encode(nameKana, forKey: "name_kana")
                    encoder.encode(nameKanji, forKey: "name_kanji")
                    encoder.encode(isOwnersProvided, forKey: "owners_provided")
                    encoder.encode(ownershipDeclaration, forKey: "ownership_declaration")
                    encoder.encode(phone, forKey: "phone")
                    encoder.encode(registrationNumber, forKey: "registration_number")
                    encoder.encode(structure, forKey: "structure")
                    encoder.encode(taxID, forKey: "tax_id")
                    encoder.encode(taxIDRegistrar, forKey: "tax_id_registrar")
                    encoder.encode(vatID, forKey: "vat_id")
                    encoder.encode(verification, forKey: "verification")
                    return encoder.items
                }
            }

            /// Documents_specs
            ///
            /// Documents that may be submitted to satisfy various informational requests.
            public struct Documents: Encodable {
                /// Documents_param
                public var bankAccountOwnershipVerification: BankAccountOwnershipVerification?
                /// Documents_param
                public var companyLicense: CompanyLicense?
                /// Documents_param
                public var companyMemorandumOfAssociation: CompanyMemorandumOfAssociation?
                /// Documents_param
                public var companyMinisterialDecree: CompanyMinisterialDecree?
                /// Documents_param
                public var companyRegistrationVerification: CompanyRegistrationVerification?
                /// Documents_param
                public var companyTaxIDVerification: CompanyTaxIDVerification?
                /// Documents_param
                public var proofOfRegistration: ProofOfRegistration?

                /// Documents_param
                public struct BankAccountOwnershipVerification: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct CompanyLicense: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct CompanyMemorandumOfAssociation: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct CompanyMinisterialDecree: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct CompanyRegistrationVerification: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct CompanyTaxIDVerification: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct ProofOfRegistration: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                public init(bankAccountOwnershipVerification: BankAccountOwnershipVerification? = nil, companyLicense: CompanyLicense? = nil, companyMemorandumOfAssociation: CompanyMemorandumOfAssociation? = nil, companyMinisterialDecree: CompanyMinisterialDecree? = nil, companyRegistrationVerification: CompanyRegistrationVerification? = nil, companyTaxIDVerification: CompanyTaxIDVerification? = nil, proofOfRegistration: ProofOfRegistration? = nil) {
                    self.bankAccountOwnershipVerification = bankAccountOwnershipVerification
                    self.companyLicense = companyLicense
                    self.companyMemorandumOfAssociation = companyMemorandumOfAssociation
                    self.companyMinisterialDecree = companyMinisterialDecree
                    self.companyRegistrationVerification = companyRegistrationVerification
                    self.companyTaxIDVerification = companyTaxIDVerification
                    self.proofOfRegistration = proofOfRegistration
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(bankAccountOwnershipVerification, forKey: "bank_account_ownership_verification")
                    encoder.encode(companyLicense, forKey: "company_license")
                    encoder.encode(companyMemorandumOfAssociation, forKey: "company_memorandum_of_association")
                    encoder.encode(companyMinisterialDecree, forKey: "company_ministerial_decree")
                    encoder.encode(companyRegistrationVerification, forKey: "company_registration_verification")
                    encoder.encode(companyTaxIDVerification, forKey: "company_tax_id_verification")
                    encoder.encode(proofOfRegistration, forKey: "proof_of_registration")
                    return encoder.items
                }
            }

            /// Individual_specs
            ///
            /// Information about the person represented by the account. This field is null unless `business_type` is set to `individual`.
            public struct Individual: Encodable {
                /// Address_specs
                public var address: Address?
                /// Japan_address_kana_specs
                public var addressKana: AddressKana?
                /// Japan_address_kanji_specs
                public var addressKanji: AddressKanji?
                public var dob: Dob?
                public var email: String?
                public var firstName: String?
                public var firstNameKana: String?
                public var firstNameKanji: String?
                public var fullNameAliases: FullNameAliases?
                public var gender: String?
                public var idNumber: String?
                public var lastName: String?
                public var lastNameKana: String?
                public var lastNameKanji: String?
                public var maidenName: String?
                public var metadata: Metadata?
                public var phone: String?
                public var politicalExposure: PoliticalExposure?
                public var ssnLast4: String?
                /// Person_verification_specs
                public var verification: Verification?

                /// Address_specs
                public struct Address: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                /// Japan_address_kana_specs
                public struct AddressKana: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?
                    public var town: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                        self.town = town
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        encoder.encode(town, forKey: "town")
                        return encoder.items
                    }
                }

                /// Japan_address_kanji_specs
                public struct AddressKanji: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?
                    public var town: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                        self.town = town
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        encoder.encode(town, forKey: "town")
                        return encoder.items
                    }
                }

                public struct Dob: Encodable {
                    /// Date_of_birth_specs
                    public var a: A?
                    public var b: B?

                    /// Date_of_birth_specs
                    public struct A: Encodable {
                        public var day: Int
                        public var month: Int
                        public var year: Int

                        public init(day: Int, month: Int, year: Int) {
                            self.day = day
                            self.month = month
                            self.year = year
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(day, forKey: "day")
                            encoder.encode(month, forKey: "month")
                            encoder.encode(year, forKey: "year")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct FullNameAliases: Encodable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public struct Metadata: Encodable {
                    public var stringString: [String: String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(stringString: [String: String]? = nil, object: Object? = nil) {
                        self.stringString = stringString
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(stringString, forKey: "stringString")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public enum PoliticalExposure: String, Codable, CaseIterable {
                    case existing
                    case `none`
                }

                /// Person_verification_specs
                public struct Verification: Encodable {
                    /// Person_verification_document_specs
                    public var additionalDocument: AdditionalDocument?
                    /// Person_verification_document_specs
                    public var document: Document?

                    /// Person_verification_document_specs
                    public struct AdditionalDocument: Encodable {
                        public var back: String?
                        public var front: String?

                        public init(back: String? = nil, front: String? = nil) {
                            self.back = back
                            self.front = front
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(back, forKey: "back")
                            encoder.encode(front, forKey: "front")
                            return encoder.items
                        }
                    }

                    /// Person_verification_document_specs
                    public struct Document: Encodable {
                        public var back: String?
                        public var front: String?

                        public init(back: String? = nil, front: String? = nil) {
                            self.back = back
                            self.front = front
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(back, forKey: "back")
                            encoder.encode(front, forKey: "front")
                            return encoder.items
                        }
                    }

                    public init(additionalDocument: AdditionalDocument? = nil, document: Document? = nil) {
                        self.additionalDocument = additionalDocument
                        self.document = document
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(additionalDocument, forKey: "additional_document")
                        encoder.encode(document, forKey: "document")
                        return encoder.items
                    }
                }

                public init(address: Address? = nil, addressKana: AddressKana? = nil, addressKanji: AddressKanji? = nil, dob: Dob? = nil, email: String? = nil, firstName: String? = nil, firstNameKana: String? = nil, firstNameKanji: String? = nil, fullNameAliases: FullNameAliases? = nil, gender: String? = nil, idNumber: String? = nil, lastName: String? = nil, lastNameKana: String? = nil, lastNameKanji: String? = nil, maidenName: String? = nil, metadata: Metadata? = nil, phone: String? = nil, politicalExposure: PoliticalExposure? = nil, ssnLast4: String? = nil, verification: Verification? = nil) {
                    self.address = address
                    self.addressKana = addressKana
                    self.addressKanji = addressKanji
                    self.dob = dob
                    self.email = email
                    self.firstName = firstName
                    self.firstNameKana = firstNameKana
                    self.firstNameKanji = firstNameKanji
                    self.fullNameAliases = fullNameAliases
                    self.gender = gender
                    self.idNumber = idNumber
                    self.lastName = lastName
                    self.lastNameKana = lastNameKana
                    self.lastNameKanji = lastNameKanji
                    self.maidenName = maidenName
                    self.metadata = metadata
                    self.phone = phone
                    self.politicalExposure = politicalExposure
                    self.ssnLast4 = ssnLast4
                    self.verification = verification
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(addressKana, forKey: "address_kana")
                    encoder.encode(addressKanji, forKey: "address_kanji")
                    encoder.encode(dob, forKey: "dob")
                    encoder.encode(email, forKey: "email")
                    encoder.encode(firstName, forKey: "first_name")
                    encoder.encode(firstNameKana, forKey: "first_name_kana")
                    encoder.encode(firstNameKanji, forKey: "first_name_kanji")
                    encoder.encode(fullNameAliases, forKey: "full_name_aliases")
                    encoder.encode(gender, forKey: "gender")
                    encoder.encode(idNumber, forKey: "id_number")
                    encoder.encode(lastName, forKey: "last_name")
                    encoder.encode(lastNameKana, forKey: "last_name_kana")
                    encoder.encode(lastNameKanji, forKey: "last_name_kanji")
                    encoder.encode(maidenName, forKey: "maiden_name")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(phone, forKey: "phone")
                    encoder.encode(politicalExposure, forKey: "political_exposure")
                    encoder.encode(ssnLast4, forKey: "ssn_last_4")
                    encoder.encode(verification, forKey: "verification")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Settings_specs_update
            ///
            /// Options for customizing how the account functions within Stripe.
            public struct Settings: Encodable {
                /// Branding_settings_specs
                public var branding: Branding?
                /// Card_issuing_settings_specs
                public var cardIssuing: CardIssuing?
                /// Card_payments_settings_specs
                public var cardPayments: CardPayments?
                /// Payments_settings_specs
                public var payments: Payments?
                /// Payout_settings_specs
                public var payouts: Payouts?

                /// Branding_settings_specs
                public struct Branding: Encodable {
                    public var icon: String?
                    public var logo: String?
                    public var primaryColor: String?
                    public var secondaryColor: String?

                    public init(icon: String? = nil, logo: String? = nil, primaryColor: String? = nil, secondaryColor: String? = nil) {
                        self.icon = icon
                        self.logo = logo
                        self.primaryColor = primaryColor
                        self.secondaryColor = secondaryColor
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(icon, forKey: "icon")
                        encoder.encode(logo, forKey: "logo")
                        encoder.encode(primaryColor, forKey: "primary_color")
                        encoder.encode(secondaryColor, forKey: "secondary_color")
                        return encoder.items
                    }
                }

                /// Card_issuing_settings_specs
                public struct CardIssuing: Encodable {
                    /// Settings_terms_of_service_specs
                    public var tosAcceptance: TosAcceptance?

                    /// Settings_terms_of_service_specs
                    public struct TosAcceptance: Encodable {
                        public var date: Int?
                        public var ip: String?
                        public var userAgent: String?

                        public init(date: Int? = nil, ip: String? = nil, userAgent: String? = nil) {
                            self.date = date
                            self.ip = ip
                            self.userAgent = userAgent
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(date, forKey: "date")
                            encoder.encode(ip, forKey: "ip")
                            encoder.encode(userAgent, forKey: "user_agent")
                            return encoder.items
                        }
                    }

                    public init(tosAcceptance: TosAcceptance? = nil) {
                        self.tosAcceptance = tosAcceptance
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(tosAcceptance, forKey: "tos_acceptance")
                        return encoder.items
                    }
                }

                /// Card_payments_settings_specs
                public struct CardPayments: Encodable {
                    /// Decline_charge_on_specs
                    public var declineOn: DeclineOn?
                    public var statementDescriptorPrefix: String?

                    /// Decline_charge_on_specs
                    public struct DeclineOn: Encodable {
                        public var isAvsFailure: Bool?
                        public var isCvcFailure: Bool?

                        public init(isAvsFailure: Bool? = nil, isCvcFailure: Bool? = nil) {
                            self.isAvsFailure = isAvsFailure
                            self.isCvcFailure = isCvcFailure
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(isAvsFailure, forKey: "avs_failure")
                            encoder.encode(isCvcFailure, forKey: "cvc_failure")
                            return encoder.items
                        }
                    }

                    public init(declineOn: DeclineOn? = nil, statementDescriptorPrefix: String? = nil) {
                        self.declineOn = declineOn
                        self.statementDescriptorPrefix = statementDescriptorPrefix
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(declineOn, forKey: "decline_on")
                        encoder.encode(statementDescriptorPrefix, forKey: "statement_descriptor_prefix")
                        return encoder.items
                    }
                }

                /// Payments_settings_specs
                public struct Payments: Encodable {
                    public var statementDescriptor: String?
                    public var statementDescriptorKana: String?
                    public var statementDescriptorKanji: String?

                    public init(statementDescriptor: String? = nil, statementDescriptorKana: String? = nil, statementDescriptorKanji: String? = nil) {
                        self.statementDescriptor = statementDescriptor
                        self.statementDescriptorKana = statementDescriptorKana
                        self.statementDescriptorKanji = statementDescriptorKanji
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                        encoder.encode(statementDescriptorKana, forKey: "statement_descriptor_kana")
                        encoder.encode(statementDescriptorKanji, forKey: "statement_descriptor_kanji")
                        return encoder.items
                    }
                }

                /// Payout_settings_specs
                public struct Payouts: Encodable {
                    public var isDebitNegativeBalances: Bool?
                    /// Transfer_schedule_specs
                    public var schedule: Schedule?
                    public var statementDescriptor: String?

                    /// Transfer_schedule_specs
                    public struct Schedule: Encodable {
                        public var delayDays: DelayDays?
                        public var interval: Interval?
                        public var monthlyAnchor: Int?
                        public var weeklyAnchor: WeeklyAnchor?

                        public struct DelayDays: Encodable {
                            public var object: Object?
                            public var int: Int?

                            public enum Object: String, Codable, CaseIterable {
                                case minimum
                            }

                            public init(object: Object? = nil, int: Int? = nil) {
                                self.object = object
                                self.int = int
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(object, forKey: "object")
                                encoder.encode(int, forKey: "int")
                                return encoder.items
                            }
                        }

                        public enum Interval: String, Codable, CaseIterable {
                            case daily
                            case manual
                            case monthly
                            case weekly
                        }

                        public enum WeeklyAnchor: String, Codable, CaseIterable {
                            case friday
                            case monday
                            case saturday
                            case sunday
                            case thursday
                            case tuesday
                            case wednesday
                        }

                        public init(delayDays: DelayDays? = nil, interval: Interval? = nil, monthlyAnchor: Int? = nil, weeklyAnchor: WeeklyAnchor? = nil) {
                            self.delayDays = delayDays
                            self.interval = interval
                            self.monthlyAnchor = monthlyAnchor
                            self.weeklyAnchor = weeklyAnchor
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(delayDays, forKey: "delay_days")
                            encoder.encode(interval, forKey: "interval")
                            encoder.encode(monthlyAnchor, forKey: "monthly_anchor")
                            encoder.encode(weeklyAnchor, forKey: "weekly_anchor")
                            return encoder.items
                        }
                    }

                    public init(isDebitNegativeBalances: Bool? = nil, schedule: Schedule? = nil, statementDescriptor: String? = nil) {
                        self.isDebitNegativeBalances = isDebitNegativeBalances
                        self.schedule = schedule
                        self.statementDescriptor = statementDescriptor
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isDebitNegativeBalances, forKey: "debit_negative_balances")
                        encoder.encode(schedule, forKey: "schedule")
                        encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                        return encoder.items
                    }
                }

                public init(branding: Branding? = nil, cardIssuing: CardIssuing? = nil, cardPayments: CardPayments? = nil, payments: Payments? = nil, payouts: Payouts? = nil) {
                    self.branding = branding
                    self.cardIssuing = cardIssuing
                    self.cardPayments = cardPayments
                    self.payments = payments
                    self.payouts = payouts
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(branding, forKey: "branding")
                    encoder.encode(cardIssuing, forKey: "card_issuing")
                    encoder.encode(cardPayments, forKey: "card_payments")
                    encoder.encode(payments, forKey: "payments")
                    encoder.encode(payouts, forKey: "payouts")
                    return encoder.items
                }
            }

            /// Tos_acceptance_specs
            ///
            /// Details on the account's acceptance of the [Stripe Services Agreement](https://stripe.com/docs/connect/updating-accounts#tos-acceptance).
            public struct TosAcceptance: Encodable {
                public var date: Int?
                public var ip: String?
                public var serviceAgreement: String?
                public var userAgent: String?

                public init(date: Int? = nil, ip: String? = nil, serviceAgreement: String? = nil, userAgent: String? = nil) {
                    self.date = date
                    self.ip = ip
                    self.serviceAgreement = serviceAgreement
                    self.userAgent = userAgent
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(date, forKey: "date")
                    encoder.encode(ip, forKey: "ip")
                    encoder.encode(serviceAgreement, forKey: "service_agreement")
                    encoder.encode(userAgent, forKey: "user_agent")
                    return encoder.items
                }
            }

            public init(accountToken: String? = nil, bankAccount: BankAccount? = nil, businessProfile: BusinessProfile? = nil, businessType: BusinessType? = nil, capabilities: Capabilities? = nil, company: Company? = nil, defaultCurrency: String? = nil, documents: Documents? = nil, email: String? = nil, expand: [String]? = nil, externalAccount: String? = nil, individual: Individual? = nil, metadata: Metadata? = nil, settings: Settings? = nil, tosAcceptance: TosAcceptance? = nil) {
                self.accountToken = accountToken
                self.bankAccount = bankAccount
                self.businessProfile = businessProfile
                self.businessType = businessType
                self.capabilities = capabilities
                self.company = company
                self.defaultCurrency = defaultCurrency
                self.documents = documents
                self.email = email
                self.expand = expand
                self.externalAccount = externalAccount
                self.individual = individual
                self.metadata = metadata
                self.settings = settings
                self.tosAcceptance = tosAcceptance
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(accountToken, forKey: "account_token")
                encoder.encode(bankAccount, forKey: "bank_account")
                encoder.encode(businessProfile, forKey: "business_profile")
                encoder.encode(businessType, forKey: "business_type")
                encoder.encode(capabilities, forKey: "capabilities")
                encoder.encode(company, forKey: "company")
                encoder.encode(defaultCurrency, forKey: "default_currency")
                encoder.encode(documents, forKey: "documents")
                encoder.encode(email, forKey: "email")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(externalAccount, forKey: "external_account")
                encoder.encode(individual, forKey: "individual")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(settings, forKey: "settings")
                encoder.encode(tosAcceptance, forKey: "tos_acceptance")
                return encoder.items
            }
        }

        /// <p>With <a href="/docs/connect">Connect</a>, you can delete accounts you manage.</p>
        /// 
        /// <p>Accounts created using test-mode keys can be deleted at any time. Custom or Express accounts created using live-mode keys can only be deleted once all balances are zero.</p>
        /// 
        /// <p>If you want to delete your own account, use the <a href="https://dashboard.stripe.com/account">account information tab in your account settings</a> instead.</p>
        public func delete(_ body: DeleteRequest? = nil) -> Request<StripeAPI.DeletedAccount> {
            .delete(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct DeleteRequest: Encodable {
            public var account: String?

            public init(account: String? = nil) {
                self.account = account
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(account, forKey: "account")
                return encoder.items
            }
        }
    }
}

extension Paths.Account {
    public var bankAccounts: BankAccounts {
        BankAccounts(path: path + "/bank_accounts")
    }

    public struct BankAccounts {
        /// Path: `/v1/account/bank_accounts`
        public let path: String

        /// <p>Create an external account for a given account.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.ExternalAccount> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details.
            public var bankAccount: BankAccount?
            /// When set to true, or if this is the first external account added in this currency, this account becomes the default external account for its currency.
            public var isDefaultForCurrency: Bool?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Please refer to full [documentation](https://stripe.com/docs/api) instead.
            public var externalAccount: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?

            /// Either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details.
            public struct BankAccount: Encodable {
                /// External_account_payout_bank_account
                public var object: Object?
                public var string: String?

                /// External_account_payout_bank_account
                public struct Object: Encodable {
                    public var accountHolderName: String?
                    public var accountHolderType: AccountHolderType?
                    public var accountNumber: String
                    public var accountType: AccountType?
                    public var country: String
                    public var currency: String?
                    public var object: Object?
                    public var routingNumber: String?

                    public enum AccountHolderType: String, Codable, CaseIterable {
                        case company
                        case individual
                    }

                    public enum AccountType: String, Codable, CaseIterable {
                        case checking
                        case futsu
                        case savings
                        case toza
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case bankAccount = "bank_account"
                    }

                    public init(accountHolderName: String? = nil, accountHolderType: AccountHolderType? = nil, accountNumber: String, accountType: AccountType? = nil, country: String, currency: String? = nil, object: Object? = nil, routingNumber: String? = nil) {
                        self.accountHolderName = accountHolderName
                        self.accountHolderType = accountHolderType
                        self.accountNumber = accountNumber
                        self.accountType = accountType
                        self.country = country
                        self.currency = currency
                        self.object = object
                        self.routingNumber = routingNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountHolderName, forKey: "account_holder_name")
                        encoder.encode(accountHolderType, forKey: "account_holder_type")
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(accountType, forKey: "account_type")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(object, forKey: "object")
                        encoder.encode(routingNumber, forKey: "routing_number")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, string: String? = nil) {
                    self.object = object
                    self.string = string
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(string, forKey: "string")
                    return encoder.items
                }
            }

            public init(bankAccount: BankAccount? = nil, isDefaultForCurrency: Bool? = nil, expand: [String]? = nil, externalAccount: String? = nil, metadata: [String: String]? = nil) {
                self.bankAccount = bankAccount
                self.isDefaultForCurrency = isDefaultForCurrency
                self.expand = expand
                self.externalAccount = externalAccount
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(bankAccount, forKey: "bank_account")
                encoder.encode(isDefaultForCurrency, forKey: "default_for_currency")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(externalAccount, forKey: "external_account")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths.Account.BankAccounts {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/account/bank_accounts/{id}`
        public let path: String

        /// <p>Retrieve a specified external account for a given account.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.ExternalAccount> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the metadata, account holder name, account holder type of a bank account belonging to a <a href="/docs/connect/custom-accounts">Custom account</a>, and optionally sets it as the default for its currency. Other bank account details are not editable by design.</p>
        /// 
        /// <p>You can re-enable a disabled bank account by performing an update call without providing any arguments or changes.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.ExternalAccount> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The name of the person or business that owns the bank account.
            public var accountHolderName: String?
            /// The type of entity that holds the account. This can be either `individual` or `company`.
            public var accountHolderType: AccountHolderType?
            /// The bank account type. This can only be `checking` or `savings` in most countries. In Japan, this can only be `futsu` or `toza`.
            public var accountType: AccountType?
            /// City/District/Suburb/Town/Village.
            public var addressCity: String?
            /// Billing address country, if provided when creating card.
            public var addressCountry: String?
            /// Address line 1 (Street address/PO Box/Company name).
            public var addressLine1: String?
            /// Address line 2 (Apartment/Suite/Unit/Building).
            public var addressLine2: String?
            /// State/County/Province/Region.
            public var addressState: String?
            /// ZIP or postal code.
            public var addressZip: String?
            /// When set to true, this becomes the default external account for its currency.
            public var isDefaultForCurrency: Bool?
            /// Two digit number representing the card’s expiration month.
            public var expMonth: String?
            /// Four digit number representing the card’s expiration year.
            public var expYear: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// Cardholder name.
            public var name: String?

            /// The type of entity that holds the account. This can be either `individual` or `company`.
            public enum AccountHolderType: String, Codable, CaseIterable {
                case empty = ""
                case company
                case individual
            }

            /// The bank account type. This can only be `checking` or `savings` in most countries. In Japan, this can only be `futsu` or `toza`.
            public enum AccountType: String, Codable, CaseIterable {
                case checking
                case futsu
                case savings
                case toza
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(accountHolderName: String? = nil, accountHolderType: AccountHolderType? = nil, accountType: AccountType? = nil, addressCity: String? = nil, addressCountry: String? = nil, addressLine1: String? = nil, addressLine2: String? = nil, addressState: String? = nil, addressZip: String? = nil, isDefaultForCurrency: Bool? = nil, expMonth: String? = nil, expYear: String? = nil, expand: [String]? = nil, metadata: Metadata? = nil, name: String? = nil) {
                self.accountHolderName = accountHolderName
                self.accountHolderType = accountHolderType
                self.accountType = accountType
                self.addressCity = addressCity
                self.addressCountry = addressCountry
                self.addressLine1 = addressLine1
                self.addressLine2 = addressLine2
                self.addressState = addressState
                self.addressZip = addressZip
                self.isDefaultForCurrency = isDefaultForCurrency
                self.expMonth = expMonth
                self.expYear = expYear
                self.expand = expand
                self.metadata = metadata
                self.name = name
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(accountHolderName, forKey: "account_holder_name")
                encoder.encode(accountHolderType, forKey: "account_holder_type")
                encoder.encode(accountType, forKey: "account_type")
                encoder.encode(addressCity, forKey: "address_city")
                encoder.encode(addressCountry, forKey: "address_country")
                encoder.encode(addressLine1, forKey: "address_line1")
                encoder.encode(addressLine2, forKey: "address_line2")
                encoder.encode(addressState, forKey: "address_state")
                encoder.encode(addressZip, forKey: "address_zip")
                encoder.encode(isDefaultForCurrency, forKey: "default_for_currency")
                encoder.encode(expMonth, forKey: "exp_month")
                encoder.encode(expYear, forKey: "exp_year")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(name, forKey: "name")
                return encoder.items
            }
        }

        /// <p>Delete a specified external account for a given account.</p>
        public var delete: Request<StripeAPI.DeletedExternalAccount> {
            .delete(path)
        }
    }
}

extension Paths.Account {
    public var capabilities: Capabilities {
        Capabilities(path: path + "/capabilities")
    }

    public struct Capabilities {
        /// Path: `/v1/account/capabilities`
        public let path: String

        /// <p>Returns a list of capabilities associated with the account. The capabilities are returned sorted by creation date, with the most recent capability appearing first.</p>
        public func get(expand: [String]? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        /// ListAccountCapability
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Capability]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Capability], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths.Account.Capabilities {
    public func capability(_ capability: String) -> WithCapability {
        WithCapability(path: "\(path)/\(capability)")
    }

    public struct WithCapability {
        /// Path: `/v1/account/capabilities/{capability}`
        public let path: String

        /// <p>Retrieves information about the specified Account Capability.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Capability> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates an existing Account Capability.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Capability> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Passing true requests the capability for the account, if it is not already requested. A requested capability may not immediately become active. Any requirements to activate the capability are returned in the `requirements` arrays.
            public var isRequested: Bool?

            public init(expand: [String]? = nil, isRequested: Bool? = nil) {
                self.expand = expand
                self.isRequested = isRequested
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(isRequested, forKey: "requested")
                return encoder.items
            }
        }
    }
}

extension Paths.Account {
    public var externalAccounts: ExternalAccounts {
        ExternalAccounts(path: path + "/external_accounts")
    }

    public struct ExternalAccounts {
        /// Path: `/v1/account/external_accounts`
        public let path: String

        /// <p>List external accounts for an account.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// ExternalAccountList
        public struct GetResponse: Decodable {
            /// The list contains all external accounts that have been attached to the Stripe account. These may be bank accounts or cards.
            public var data: [Datum]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// Polymorphic
            public struct Datum: Decodable {
                public var bankAccount: StripeAPI.BankAccount?
                public var card: StripeAPI.Card?

                public init(bankAccount: StripeAPI.BankAccount? = nil, card: StripeAPI.Card? = nil) {
                    self.bankAccount = bankAccount
                    self.card = card
                }

                public init(from decoder: Decoder) throws {
                    let container = try decoder.singleValueContainer()
                    self.bankAccount = try? container.decode(StripeAPI.BankAccount.self)
                    self.card = try? container.decode(StripeAPI.Card.self)
                }
            }

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [Datum], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Create an external account for a given account.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.ExternalAccount> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details.
            public var bankAccount: BankAccount?
            /// When set to true, or if this is the first external account added in this currency, this account becomes the default external account for its currency.
            public var isDefaultForCurrency: Bool?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Please refer to full [documentation](https://stripe.com/docs/api) instead.
            public var externalAccount: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?

            /// Either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details.
            public struct BankAccount: Encodable {
                /// External_account_payout_bank_account
                public var object: Object?
                public var string: String?

                /// External_account_payout_bank_account
                public struct Object: Encodable {
                    public var accountHolderName: String?
                    public var accountHolderType: AccountHolderType?
                    public var accountNumber: String
                    public var accountType: AccountType?
                    public var country: String
                    public var currency: String?
                    public var object: Object?
                    public var routingNumber: String?

                    public enum AccountHolderType: String, Codable, CaseIterable {
                        case company
                        case individual
                    }

                    public enum AccountType: String, Codable, CaseIterable {
                        case checking
                        case futsu
                        case savings
                        case toza
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case bankAccount = "bank_account"
                    }

                    public init(accountHolderName: String? = nil, accountHolderType: AccountHolderType? = nil, accountNumber: String, accountType: AccountType? = nil, country: String, currency: String? = nil, object: Object? = nil, routingNumber: String? = nil) {
                        self.accountHolderName = accountHolderName
                        self.accountHolderType = accountHolderType
                        self.accountNumber = accountNumber
                        self.accountType = accountType
                        self.country = country
                        self.currency = currency
                        self.object = object
                        self.routingNumber = routingNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountHolderName, forKey: "account_holder_name")
                        encoder.encode(accountHolderType, forKey: "account_holder_type")
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(accountType, forKey: "account_type")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(object, forKey: "object")
                        encoder.encode(routingNumber, forKey: "routing_number")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, string: String? = nil) {
                    self.object = object
                    self.string = string
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(string, forKey: "string")
                    return encoder.items
                }
            }

            public init(bankAccount: BankAccount? = nil, isDefaultForCurrency: Bool? = nil, expand: [String]? = nil, externalAccount: String? = nil, metadata: [String: String]? = nil) {
                self.bankAccount = bankAccount
                self.isDefaultForCurrency = isDefaultForCurrency
                self.expand = expand
                self.externalAccount = externalAccount
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(bankAccount, forKey: "bank_account")
                encoder.encode(isDefaultForCurrency, forKey: "default_for_currency")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(externalAccount, forKey: "external_account")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths.Account.ExternalAccounts {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/account/external_accounts/{id}`
        public let path: String

        /// <p>Retrieve a specified external account for a given account.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.ExternalAccount> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the metadata, account holder name, account holder type of a bank account belonging to a <a href="/docs/connect/custom-accounts">Custom account</a>, and optionally sets it as the default for its currency. Other bank account details are not editable by design.</p>
        /// 
        /// <p>You can re-enable a disabled bank account by performing an update call without providing any arguments or changes.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.ExternalAccount> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The name of the person or business that owns the bank account.
            public var accountHolderName: String?
            /// The type of entity that holds the account. This can be either `individual` or `company`.
            public var accountHolderType: AccountHolderType?
            /// The bank account type. This can only be `checking` or `savings` in most countries. In Japan, this can only be `futsu` or `toza`.
            public var accountType: AccountType?
            /// City/District/Suburb/Town/Village.
            public var addressCity: String?
            /// Billing address country, if provided when creating card.
            public var addressCountry: String?
            /// Address line 1 (Street address/PO Box/Company name).
            public var addressLine1: String?
            /// Address line 2 (Apartment/Suite/Unit/Building).
            public var addressLine2: String?
            /// State/County/Province/Region.
            public var addressState: String?
            /// ZIP or postal code.
            public var addressZip: String?
            /// When set to true, this becomes the default external account for its currency.
            public var isDefaultForCurrency: Bool?
            /// Two digit number representing the card’s expiration month.
            public var expMonth: String?
            /// Four digit number representing the card’s expiration year.
            public var expYear: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// Cardholder name.
            public var name: String?

            /// The type of entity that holds the account. This can be either `individual` or `company`.
            public enum AccountHolderType: String, Codable, CaseIterable {
                case empty = ""
                case company
                case individual
            }

            /// The bank account type. This can only be `checking` or `savings` in most countries. In Japan, this can only be `futsu` or `toza`.
            public enum AccountType: String, Codable, CaseIterable {
                case checking
                case futsu
                case savings
                case toza
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(accountHolderName: String? = nil, accountHolderType: AccountHolderType? = nil, accountType: AccountType? = nil, addressCity: String? = nil, addressCountry: String? = nil, addressLine1: String? = nil, addressLine2: String? = nil, addressState: String? = nil, addressZip: String? = nil, isDefaultForCurrency: Bool? = nil, expMonth: String? = nil, expYear: String? = nil, expand: [String]? = nil, metadata: Metadata? = nil, name: String? = nil) {
                self.accountHolderName = accountHolderName
                self.accountHolderType = accountHolderType
                self.accountType = accountType
                self.addressCity = addressCity
                self.addressCountry = addressCountry
                self.addressLine1 = addressLine1
                self.addressLine2 = addressLine2
                self.addressState = addressState
                self.addressZip = addressZip
                self.isDefaultForCurrency = isDefaultForCurrency
                self.expMonth = expMonth
                self.expYear = expYear
                self.expand = expand
                self.metadata = metadata
                self.name = name
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(accountHolderName, forKey: "account_holder_name")
                encoder.encode(accountHolderType, forKey: "account_holder_type")
                encoder.encode(accountType, forKey: "account_type")
                encoder.encode(addressCity, forKey: "address_city")
                encoder.encode(addressCountry, forKey: "address_country")
                encoder.encode(addressLine1, forKey: "address_line1")
                encoder.encode(addressLine2, forKey: "address_line2")
                encoder.encode(addressState, forKey: "address_state")
                encoder.encode(addressZip, forKey: "address_zip")
                encoder.encode(isDefaultForCurrency, forKey: "default_for_currency")
                encoder.encode(expMonth, forKey: "exp_month")
                encoder.encode(expYear, forKey: "exp_year")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(name, forKey: "name")
                return encoder.items
            }
        }

        /// <p>Delete a specified external account for a given account.</p>
        public var delete: Request<StripeAPI.DeletedExternalAccount> {
            .delete(path)
        }
    }
}

extension Paths.Account {
    public var loginLinks: LoginLinks {
        LoginLinks(path: path + "/login_links")
    }

    public struct LoginLinks {
        /// Path: `/v1/account/login_links`
        public let path: String

        /// <p>Creates a single-use login link for an Express account to access their Stripe dashboard.</p>
        /// 
        /// <p><strong>You may only create login links for <a href="/docs/connect/express-accounts">Express accounts</a> connected to your platform</strong>.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.LoginLink> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            public var account: String
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Where to redirect the user after they log out of their dashboard.
            public var redirectURL: String?

            public init(account: String, expand: [String]? = nil, redirectURL: String? = nil) {
                self.account = account
                self.expand = expand
                self.redirectURL = redirectURL
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(account, forKey: "account")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(redirectURL, forKey: "redirect_url")
                return encoder.items
            }
        }
    }
}

extension Paths.Account {
    public var people: People {
        People(path: path + "/people")
    }

    public struct People {
        /// Path: `/v1/account/people`
        public let path: String

        /// <p>Returns a list of people associated with the account’s legal entity. The people are returned sorted by creation date, with the most recent people appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Person]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Person], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            /// All_people_relationship_specs
            public var relationship: Relationship?
            public var startingAfter: String?

            /// All_people_relationship_specs
            public struct Relationship: Codable {
                public var isDirector: Bool?
                public var isExecutive: Bool?
                public var isOwner: Bool?
                public var isRepresentative: Bool?

                public init(isDirector: Bool? = nil, isExecutive: Bool? = nil, isOwner: Bool? = nil, isRepresentative: Bool? = nil) {
                    self.isDirector = isDirector
                    self.isExecutive = isExecutive
                    self.isOwner = isOwner
                    self.isRepresentative = isRepresentative
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isDirector, forKey: "director")
                    encoder.encode(isExecutive, forKey: "executive")
                    encoder.encode(isOwner, forKey: "owner")
                    encoder.encode(isRepresentative, forKey: "representative")
                    return encoder.items
                }
            }

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, relationship: Relationship? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.relationship = relationship
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(relationship, forKey: "relationship", isDeepObject: true)
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates a new person.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Person> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            public var account: String?
            /// Address_specs
            ///
            /// The person's address.
            public var address: Address?
            /// Japan_address_kana_specs
            ///
            /// The Kana variation of the person's address (Japan only).
            public var addressKana: AddressKana?
            /// Japan_address_kanji_specs
            ///
            /// The Kanji variation of the person's address (Japan only).
            public var addressKanji: AddressKanji?
            /// The person's date of birth.
            public var dob: Dob?
            /// Person_documents_specs
            ///
            /// Documents that may be submitted to satisfy various informational requests.
            public var documents: Documents?
            /// The person's email address.
            public var email: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The person's first name.
            public var firstName: String?
            /// The Kana variation of the person's first name (Japan only).
            public var firstNameKana: String?
            /// The Kanji variation of the person's first name (Japan only).
            public var firstNameKanji: String?
            /// A list of alternate names or aliases that the person is known by.
            public var fullNameAliases: FullNameAliases?
            /// The person's gender (International regulations require either "male" or "female").
            public var gender: String?
            /// The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
            public var idNumber: String?
            /// The person's last name.
            public var lastName: String?
            /// The Kana variation of the person's last name (Japan only).
            public var lastNameKana: String?
            /// The Kanji variation of the person's last name (Japan only).
            public var lastNameKanji: String?
            /// The person's maiden name.
            public var maidenName: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or "XX" if unavailable.
            public var nationality: String?
            /// A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
            public var personToken: String?
            /// The person's phone number.
            public var phone: String?
            /// Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
            public var politicalExposure: String?
            /// Relationship_specs
            ///
            /// The relationship that this person has with the account's legal entity.
            public var relationship: Relationship?
            /// The last four digits of the person's Social Security number (U.S. only).
            public var ssnLast4: String?
            /// Person_verification_specs
            ///
            /// The person's verification status.
            public var verification: Verification?

            /// Address_specs
            ///
            /// The person's address.
            public struct Address: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    return encoder.items
                }
            }

            /// Japan_address_kana_specs
            ///
            /// The Kana variation of the person's address (Japan only).
            public struct AddressKana: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?
                public var town: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                    self.town = town
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    encoder.encode(town, forKey: "town")
                    return encoder.items
                }
            }

            /// Japan_address_kanji_specs
            ///
            /// The Kanji variation of the person's address (Japan only).
            public struct AddressKanji: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?
                public var town: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                    self.town = town
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    encoder.encode(town, forKey: "town")
                    return encoder.items
                }
            }

            /// The person's date of birth.
            public struct Dob: Encodable {
                /// Date_of_birth_specs
                public var a: A?
                public var b: B?

                /// Date_of_birth_specs
                public struct A: Encodable {
                    public var day: Int
                    public var month: Int
                    public var year: Int

                    public init(day: Int, month: Int, year: Int) {
                        self.day = day
                        self.month = month
                        self.year = year
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(day, forKey: "day")
                        encoder.encode(month, forKey: "month")
                        encoder.encode(year, forKey: "year")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Person_documents_specs
            ///
            /// Documents that may be submitted to satisfy various informational requests.
            public struct Documents: Encodable {
                /// Documents_param
                public var companyAuthorization: CompanyAuthorization?
                /// Documents_param
                public var passport: Passport?
                /// Documents_param
                public var visa: Visa?

                /// Documents_param
                public struct CompanyAuthorization: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct Passport: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct Visa: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                public init(companyAuthorization: CompanyAuthorization? = nil, passport: Passport? = nil, visa: Visa? = nil) {
                    self.companyAuthorization = companyAuthorization
                    self.passport = passport
                    self.visa = visa
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(companyAuthorization, forKey: "company_authorization")
                    encoder.encode(passport, forKey: "passport")
                    encoder.encode(visa, forKey: "visa")
                    return encoder.items
                }
            }

            /// A list of alternate names or aliases that the person is known by.
            public struct FullNameAliases: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Relationship_specs
            ///
            /// The relationship that this person has with the account's legal entity.
            public struct Relationship: Encodable {
                public var isDirector: Bool?
                public var isExecutive: Bool?
                public var isOwner: Bool?
                public var percentOwnership: PercentOwnership?
                public var isRepresentative: Bool?
                public var title: String?

                public struct PercentOwnership: Encodable {
                    public var double: Double?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(double: Double? = nil, object: Object? = nil) {
                        self.double = double
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(double, forKey: "double")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(isDirector: Bool? = nil, isExecutive: Bool? = nil, isOwner: Bool? = nil, percentOwnership: PercentOwnership? = nil, isRepresentative: Bool? = nil, title: String? = nil) {
                    self.isDirector = isDirector
                    self.isExecutive = isExecutive
                    self.isOwner = isOwner
                    self.percentOwnership = percentOwnership
                    self.isRepresentative = isRepresentative
                    self.title = title
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isDirector, forKey: "director")
                    encoder.encode(isExecutive, forKey: "executive")
                    encoder.encode(isOwner, forKey: "owner")
                    encoder.encode(percentOwnership, forKey: "percent_ownership")
                    encoder.encode(isRepresentative, forKey: "representative")
                    encoder.encode(title, forKey: "title")
                    return encoder.items
                }
            }

            /// Person_verification_specs
            ///
            /// The person's verification status.
            public struct Verification: Encodable {
                /// Person_verification_document_specs
                public var additionalDocument: AdditionalDocument?
                /// Person_verification_document_specs
                public var document: Document?

                /// Person_verification_document_specs
                public struct AdditionalDocument: Encodable {
                    public var back: String?
                    public var front: String?

                    public init(back: String? = nil, front: String? = nil) {
                        self.back = back
                        self.front = front
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(back, forKey: "back")
                        encoder.encode(front, forKey: "front")
                        return encoder.items
                    }
                }

                /// Person_verification_document_specs
                public struct Document: Encodable {
                    public var back: String?
                    public var front: String?

                    public init(back: String? = nil, front: String? = nil) {
                        self.back = back
                        self.front = front
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(back, forKey: "back")
                        encoder.encode(front, forKey: "front")
                        return encoder.items
                    }
                }

                public init(additionalDocument: AdditionalDocument? = nil, document: Document? = nil) {
                    self.additionalDocument = additionalDocument
                    self.document = document
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(additionalDocument, forKey: "additional_document")
                    encoder.encode(document, forKey: "document")
                    return encoder.items
                }
            }

            public init(account: String? = nil, address: Address? = nil, addressKana: AddressKana? = nil, addressKanji: AddressKanji? = nil, dob: Dob? = nil, documents: Documents? = nil, email: String? = nil, expand: [String]? = nil, firstName: String? = nil, firstNameKana: String? = nil, firstNameKanji: String? = nil, fullNameAliases: FullNameAliases? = nil, gender: String? = nil, idNumber: String? = nil, lastName: String? = nil, lastNameKana: String? = nil, lastNameKanji: String? = nil, maidenName: String? = nil, metadata: Metadata? = nil, nationality: String? = nil, personToken: String? = nil, phone: String? = nil, politicalExposure: String? = nil, relationship: Relationship? = nil, ssnLast4: String? = nil, verification: Verification? = nil) {
                self.account = account
                self.address = address
                self.addressKana = addressKana
                self.addressKanji = addressKanji
                self.dob = dob
                self.documents = documents
                self.email = email
                self.expand = expand
                self.firstName = firstName
                self.firstNameKana = firstNameKana
                self.firstNameKanji = firstNameKanji
                self.fullNameAliases = fullNameAliases
                self.gender = gender
                self.idNumber = idNumber
                self.lastName = lastName
                self.lastNameKana = lastNameKana
                self.lastNameKanji = lastNameKanji
                self.maidenName = maidenName
                self.metadata = metadata
                self.nationality = nationality
                self.personToken = personToken
                self.phone = phone
                self.politicalExposure = politicalExposure
                self.relationship = relationship
                self.ssnLast4 = ssnLast4
                self.verification = verification
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(account, forKey: "account")
                encoder.encode(address, forKey: "address")
                encoder.encode(addressKana, forKey: "address_kana")
                encoder.encode(addressKanji, forKey: "address_kanji")
                encoder.encode(dob, forKey: "dob")
                encoder.encode(documents, forKey: "documents")
                encoder.encode(email, forKey: "email")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(firstName, forKey: "first_name")
                encoder.encode(firstNameKana, forKey: "first_name_kana")
                encoder.encode(firstNameKanji, forKey: "first_name_kanji")
                encoder.encode(fullNameAliases, forKey: "full_name_aliases")
                encoder.encode(gender, forKey: "gender")
                encoder.encode(idNumber, forKey: "id_number")
                encoder.encode(lastName, forKey: "last_name")
                encoder.encode(lastNameKana, forKey: "last_name_kana")
                encoder.encode(lastNameKanji, forKey: "last_name_kanji")
                encoder.encode(maidenName, forKey: "maiden_name")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(nationality, forKey: "nationality")
                encoder.encode(personToken, forKey: "person_token")
                encoder.encode(phone, forKey: "phone")
                encoder.encode(politicalExposure, forKey: "political_exposure")
                encoder.encode(relationship, forKey: "relationship")
                encoder.encode(ssnLast4, forKey: "ssn_last_4")
                encoder.encode(verification, forKey: "verification")
                return encoder.items
            }
        }
    }
}

extension Paths.Account.People {
    public func person(_ person: String) -> WithPerson {
        WithPerson(path: "\(path)/\(person)")
    }

    public struct WithPerson {
        /// Path: `/v1/account/people/{person}`
        public let path: String

        /// <p>Retrieves an existing person.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Person> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates an existing person.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Person> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            public var account: String?
            /// Address_specs
            ///
            /// The person's address.
            public var address: Address?
            /// Japan_address_kana_specs
            ///
            /// The Kana variation of the person's address (Japan only).
            public var addressKana: AddressKana?
            /// Japan_address_kanji_specs
            ///
            /// The Kanji variation of the person's address (Japan only).
            public var addressKanji: AddressKanji?
            /// The person's date of birth.
            public var dob: Dob?
            /// Person_documents_specs
            ///
            /// Documents that may be submitted to satisfy various informational requests.
            public var documents: Documents?
            /// The person's email address.
            public var email: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The person's first name.
            public var firstName: String?
            /// The Kana variation of the person's first name (Japan only).
            public var firstNameKana: String?
            /// The Kanji variation of the person's first name (Japan only).
            public var firstNameKanji: String?
            /// A list of alternate names or aliases that the person is known by.
            public var fullNameAliases: FullNameAliases?
            /// The person's gender (International regulations require either "male" or "female").
            public var gender: String?
            /// The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
            public var idNumber: String?
            /// The person's last name.
            public var lastName: String?
            /// The Kana variation of the person's last name (Japan only).
            public var lastNameKana: String?
            /// The Kanji variation of the person's last name (Japan only).
            public var lastNameKanji: String?
            /// The person's maiden name.
            public var maidenName: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or "XX" if unavailable.
            public var nationality: String?
            /// A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
            public var personToken: String?
            /// The person's phone number.
            public var phone: String?
            /// Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
            public var politicalExposure: String?
            /// Relationship_specs
            ///
            /// The relationship that this person has with the account's legal entity.
            public var relationship: Relationship?
            /// The last four digits of the person's Social Security number (U.S. only).
            public var ssnLast4: String?
            /// Person_verification_specs
            ///
            /// The person's verification status.
            public var verification: Verification?

            /// Address_specs
            ///
            /// The person's address.
            public struct Address: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    return encoder.items
                }
            }

            /// Japan_address_kana_specs
            ///
            /// The Kana variation of the person's address (Japan only).
            public struct AddressKana: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?
                public var town: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                    self.town = town
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    encoder.encode(town, forKey: "town")
                    return encoder.items
                }
            }

            /// Japan_address_kanji_specs
            ///
            /// The Kanji variation of the person's address (Japan only).
            public struct AddressKanji: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?
                public var town: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                    self.town = town
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    encoder.encode(town, forKey: "town")
                    return encoder.items
                }
            }

            /// The person's date of birth.
            public struct Dob: Encodable {
                /// Date_of_birth_specs
                public var a: A?
                public var b: B?

                /// Date_of_birth_specs
                public struct A: Encodable {
                    public var day: Int
                    public var month: Int
                    public var year: Int

                    public init(day: Int, month: Int, year: Int) {
                        self.day = day
                        self.month = month
                        self.year = year
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(day, forKey: "day")
                        encoder.encode(month, forKey: "month")
                        encoder.encode(year, forKey: "year")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Person_documents_specs
            ///
            /// Documents that may be submitted to satisfy various informational requests.
            public struct Documents: Encodable {
                /// Documents_param
                public var companyAuthorization: CompanyAuthorization?
                /// Documents_param
                public var passport: Passport?
                /// Documents_param
                public var visa: Visa?

                /// Documents_param
                public struct CompanyAuthorization: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct Passport: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct Visa: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                public init(companyAuthorization: CompanyAuthorization? = nil, passport: Passport? = nil, visa: Visa? = nil) {
                    self.companyAuthorization = companyAuthorization
                    self.passport = passport
                    self.visa = visa
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(companyAuthorization, forKey: "company_authorization")
                    encoder.encode(passport, forKey: "passport")
                    encoder.encode(visa, forKey: "visa")
                    return encoder.items
                }
            }

            /// A list of alternate names or aliases that the person is known by.
            public struct FullNameAliases: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Relationship_specs
            ///
            /// The relationship that this person has with the account's legal entity.
            public struct Relationship: Encodable {
                public var isDirector: Bool?
                public var isExecutive: Bool?
                public var isOwner: Bool?
                public var percentOwnership: PercentOwnership?
                public var isRepresentative: Bool?
                public var title: String?

                public struct PercentOwnership: Encodable {
                    public var double: Double?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(double: Double? = nil, object: Object? = nil) {
                        self.double = double
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(double, forKey: "double")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(isDirector: Bool? = nil, isExecutive: Bool? = nil, isOwner: Bool? = nil, percentOwnership: PercentOwnership? = nil, isRepresentative: Bool? = nil, title: String? = nil) {
                    self.isDirector = isDirector
                    self.isExecutive = isExecutive
                    self.isOwner = isOwner
                    self.percentOwnership = percentOwnership
                    self.isRepresentative = isRepresentative
                    self.title = title
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isDirector, forKey: "director")
                    encoder.encode(isExecutive, forKey: "executive")
                    encoder.encode(isOwner, forKey: "owner")
                    encoder.encode(percentOwnership, forKey: "percent_ownership")
                    encoder.encode(isRepresentative, forKey: "representative")
                    encoder.encode(title, forKey: "title")
                    return encoder.items
                }
            }

            /// Person_verification_specs
            ///
            /// The person's verification status.
            public struct Verification: Encodable {
                /// Person_verification_document_specs
                public var additionalDocument: AdditionalDocument?
                /// Person_verification_document_specs
                public var document: Document?

                /// Person_verification_document_specs
                public struct AdditionalDocument: Encodable {
                    public var back: String?
                    public var front: String?

                    public init(back: String? = nil, front: String? = nil) {
                        self.back = back
                        self.front = front
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(back, forKey: "back")
                        encoder.encode(front, forKey: "front")
                        return encoder.items
                    }
                }

                /// Person_verification_document_specs
                public struct Document: Encodable {
                    public var back: String?
                    public var front: String?

                    public init(back: String? = nil, front: String? = nil) {
                        self.back = back
                        self.front = front
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(back, forKey: "back")
                        encoder.encode(front, forKey: "front")
                        return encoder.items
                    }
                }

                public init(additionalDocument: AdditionalDocument? = nil, document: Document? = nil) {
                    self.additionalDocument = additionalDocument
                    self.document = document
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(additionalDocument, forKey: "additional_document")
                    encoder.encode(document, forKey: "document")
                    return encoder.items
                }
            }

            public init(account: String? = nil, address: Address? = nil, addressKana: AddressKana? = nil, addressKanji: AddressKanji? = nil, dob: Dob? = nil, documents: Documents? = nil, email: String? = nil, expand: [String]? = nil, firstName: String? = nil, firstNameKana: String? = nil, firstNameKanji: String? = nil, fullNameAliases: FullNameAliases? = nil, gender: String? = nil, idNumber: String? = nil, lastName: String? = nil, lastNameKana: String? = nil, lastNameKanji: String? = nil, maidenName: String? = nil, metadata: Metadata? = nil, nationality: String? = nil, personToken: String? = nil, phone: String? = nil, politicalExposure: String? = nil, relationship: Relationship? = nil, ssnLast4: String? = nil, verification: Verification? = nil) {
                self.account = account
                self.address = address
                self.addressKana = addressKana
                self.addressKanji = addressKanji
                self.dob = dob
                self.documents = documents
                self.email = email
                self.expand = expand
                self.firstName = firstName
                self.firstNameKana = firstNameKana
                self.firstNameKanji = firstNameKanji
                self.fullNameAliases = fullNameAliases
                self.gender = gender
                self.idNumber = idNumber
                self.lastName = lastName
                self.lastNameKana = lastNameKana
                self.lastNameKanji = lastNameKanji
                self.maidenName = maidenName
                self.metadata = metadata
                self.nationality = nationality
                self.personToken = personToken
                self.phone = phone
                self.politicalExposure = politicalExposure
                self.relationship = relationship
                self.ssnLast4 = ssnLast4
                self.verification = verification
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(account, forKey: "account")
                encoder.encode(address, forKey: "address")
                encoder.encode(addressKana, forKey: "address_kana")
                encoder.encode(addressKanji, forKey: "address_kanji")
                encoder.encode(dob, forKey: "dob")
                encoder.encode(documents, forKey: "documents")
                encoder.encode(email, forKey: "email")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(firstName, forKey: "first_name")
                encoder.encode(firstNameKana, forKey: "first_name_kana")
                encoder.encode(firstNameKanji, forKey: "first_name_kanji")
                encoder.encode(fullNameAliases, forKey: "full_name_aliases")
                encoder.encode(gender, forKey: "gender")
                encoder.encode(idNumber, forKey: "id_number")
                encoder.encode(lastName, forKey: "last_name")
                encoder.encode(lastNameKana, forKey: "last_name_kana")
                encoder.encode(lastNameKanji, forKey: "last_name_kanji")
                encoder.encode(maidenName, forKey: "maiden_name")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(nationality, forKey: "nationality")
                encoder.encode(personToken, forKey: "person_token")
                encoder.encode(phone, forKey: "phone")
                encoder.encode(politicalExposure, forKey: "political_exposure")
                encoder.encode(relationship, forKey: "relationship")
                encoder.encode(ssnLast4, forKey: "ssn_last_4")
                encoder.encode(verification, forKey: "verification")
                return encoder.items
            }
        }

        /// <p>Deletes an existing person’s relationship to the account’s legal entity. Any person with a relationship for an account can be deleted through the API, except if the person is the <code>account_opener</code>. If your integration is using the <code>executive</code> parameter, you cannot delete the only verified <code>executive</code> on file.</p>
        public var delete: Request<StripeAPI.DeletedPerson> {
            .delete(path)
        }
    }
}

extension Paths.Account {
    public var persons: Persons {
        Persons(path: path + "/persons")
    }

    public struct Persons {
        /// Path: `/v1/account/persons`
        public let path: String

        /// <p>Returns a list of people associated with the account’s legal entity. The people are returned sorted by creation date, with the most recent people appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Person]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Person], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            /// All_people_relationship_specs
            public var relationship: Relationship?
            public var startingAfter: String?

            /// All_people_relationship_specs
            public struct Relationship: Codable {
                public var isDirector: Bool?
                public var isExecutive: Bool?
                public var isOwner: Bool?
                public var isRepresentative: Bool?

                public init(isDirector: Bool? = nil, isExecutive: Bool? = nil, isOwner: Bool? = nil, isRepresentative: Bool? = nil) {
                    self.isDirector = isDirector
                    self.isExecutive = isExecutive
                    self.isOwner = isOwner
                    self.isRepresentative = isRepresentative
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isDirector, forKey: "director")
                    encoder.encode(isExecutive, forKey: "executive")
                    encoder.encode(isOwner, forKey: "owner")
                    encoder.encode(isRepresentative, forKey: "representative")
                    return encoder.items
                }
            }

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, relationship: Relationship? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.relationship = relationship
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(relationship, forKey: "relationship", isDeepObject: true)
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates a new person.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Person> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            public var account: String?
            /// Address_specs
            ///
            /// The person's address.
            public var address: Address?
            /// Japan_address_kana_specs
            ///
            /// The Kana variation of the person's address (Japan only).
            public var addressKana: AddressKana?
            /// Japan_address_kanji_specs
            ///
            /// The Kanji variation of the person's address (Japan only).
            public var addressKanji: AddressKanji?
            /// The person's date of birth.
            public var dob: Dob?
            /// Person_documents_specs
            ///
            /// Documents that may be submitted to satisfy various informational requests.
            public var documents: Documents?
            /// The person's email address.
            public var email: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The person's first name.
            public var firstName: String?
            /// The Kana variation of the person's first name (Japan only).
            public var firstNameKana: String?
            /// The Kanji variation of the person's first name (Japan only).
            public var firstNameKanji: String?
            /// A list of alternate names or aliases that the person is known by.
            public var fullNameAliases: FullNameAliases?
            /// The person's gender (International regulations require either "male" or "female").
            public var gender: String?
            /// The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
            public var idNumber: String?
            /// The person's last name.
            public var lastName: String?
            /// The Kana variation of the person's last name (Japan only).
            public var lastNameKana: String?
            /// The Kanji variation of the person's last name (Japan only).
            public var lastNameKanji: String?
            /// The person's maiden name.
            public var maidenName: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or "XX" if unavailable.
            public var nationality: String?
            /// A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
            public var personToken: String?
            /// The person's phone number.
            public var phone: String?
            /// Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
            public var politicalExposure: String?
            /// Relationship_specs
            ///
            /// The relationship that this person has with the account's legal entity.
            public var relationship: Relationship?
            /// The last four digits of the person's Social Security number (U.S. only).
            public var ssnLast4: String?
            /// Person_verification_specs
            ///
            /// The person's verification status.
            public var verification: Verification?

            /// Address_specs
            ///
            /// The person's address.
            public struct Address: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    return encoder.items
                }
            }

            /// Japan_address_kana_specs
            ///
            /// The Kana variation of the person's address (Japan only).
            public struct AddressKana: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?
                public var town: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                    self.town = town
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    encoder.encode(town, forKey: "town")
                    return encoder.items
                }
            }

            /// Japan_address_kanji_specs
            ///
            /// The Kanji variation of the person's address (Japan only).
            public struct AddressKanji: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?
                public var town: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                    self.town = town
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    encoder.encode(town, forKey: "town")
                    return encoder.items
                }
            }

            /// The person's date of birth.
            public struct Dob: Encodable {
                /// Date_of_birth_specs
                public var a: A?
                public var b: B?

                /// Date_of_birth_specs
                public struct A: Encodable {
                    public var day: Int
                    public var month: Int
                    public var year: Int

                    public init(day: Int, month: Int, year: Int) {
                        self.day = day
                        self.month = month
                        self.year = year
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(day, forKey: "day")
                        encoder.encode(month, forKey: "month")
                        encoder.encode(year, forKey: "year")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Person_documents_specs
            ///
            /// Documents that may be submitted to satisfy various informational requests.
            public struct Documents: Encodable {
                /// Documents_param
                public var companyAuthorization: CompanyAuthorization?
                /// Documents_param
                public var passport: Passport?
                /// Documents_param
                public var visa: Visa?

                /// Documents_param
                public struct CompanyAuthorization: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct Passport: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct Visa: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                public init(companyAuthorization: CompanyAuthorization? = nil, passport: Passport? = nil, visa: Visa? = nil) {
                    self.companyAuthorization = companyAuthorization
                    self.passport = passport
                    self.visa = visa
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(companyAuthorization, forKey: "company_authorization")
                    encoder.encode(passport, forKey: "passport")
                    encoder.encode(visa, forKey: "visa")
                    return encoder.items
                }
            }

            /// A list of alternate names or aliases that the person is known by.
            public struct FullNameAliases: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Relationship_specs
            ///
            /// The relationship that this person has with the account's legal entity.
            public struct Relationship: Encodable {
                public var isDirector: Bool?
                public var isExecutive: Bool?
                public var isOwner: Bool?
                public var percentOwnership: PercentOwnership?
                public var isRepresentative: Bool?
                public var title: String?

                public struct PercentOwnership: Encodable {
                    public var double: Double?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(double: Double? = nil, object: Object? = nil) {
                        self.double = double
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(double, forKey: "double")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(isDirector: Bool? = nil, isExecutive: Bool? = nil, isOwner: Bool? = nil, percentOwnership: PercentOwnership? = nil, isRepresentative: Bool? = nil, title: String? = nil) {
                    self.isDirector = isDirector
                    self.isExecutive = isExecutive
                    self.isOwner = isOwner
                    self.percentOwnership = percentOwnership
                    self.isRepresentative = isRepresentative
                    self.title = title
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isDirector, forKey: "director")
                    encoder.encode(isExecutive, forKey: "executive")
                    encoder.encode(isOwner, forKey: "owner")
                    encoder.encode(percentOwnership, forKey: "percent_ownership")
                    encoder.encode(isRepresentative, forKey: "representative")
                    encoder.encode(title, forKey: "title")
                    return encoder.items
                }
            }

            /// Person_verification_specs
            ///
            /// The person's verification status.
            public struct Verification: Encodable {
                /// Person_verification_document_specs
                public var additionalDocument: AdditionalDocument?
                /// Person_verification_document_specs
                public var document: Document?

                /// Person_verification_document_specs
                public struct AdditionalDocument: Encodable {
                    public var back: String?
                    public var front: String?

                    public init(back: String? = nil, front: String? = nil) {
                        self.back = back
                        self.front = front
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(back, forKey: "back")
                        encoder.encode(front, forKey: "front")
                        return encoder.items
                    }
                }

                /// Person_verification_document_specs
                public struct Document: Encodable {
                    public var back: String?
                    public var front: String?

                    public init(back: String? = nil, front: String? = nil) {
                        self.back = back
                        self.front = front
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(back, forKey: "back")
                        encoder.encode(front, forKey: "front")
                        return encoder.items
                    }
                }

                public init(additionalDocument: AdditionalDocument? = nil, document: Document? = nil) {
                    self.additionalDocument = additionalDocument
                    self.document = document
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(additionalDocument, forKey: "additional_document")
                    encoder.encode(document, forKey: "document")
                    return encoder.items
                }
            }

            public init(account: String? = nil, address: Address? = nil, addressKana: AddressKana? = nil, addressKanji: AddressKanji? = nil, dob: Dob? = nil, documents: Documents? = nil, email: String? = nil, expand: [String]? = nil, firstName: String? = nil, firstNameKana: String? = nil, firstNameKanji: String? = nil, fullNameAliases: FullNameAliases? = nil, gender: String? = nil, idNumber: String? = nil, lastName: String? = nil, lastNameKana: String? = nil, lastNameKanji: String? = nil, maidenName: String? = nil, metadata: Metadata? = nil, nationality: String? = nil, personToken: String? = nil, phone: String? = nil, politicalExposure: String? = nil, relationship: Relationship? = nil, ssnLast4: String? = nil, verification: Verification? = nil) {
                self.account = account
                self.address = address
                self.addressKana = addressKana
                self.addressKanji = addressKanji
                self.dob = dob
                self.documents = documents
                self.email = email
                self.expand = expand
                self.firstName = firstName
                self.firstNameKana = firstNameKana
                self.firstNameKanji = firstNameKanji
                self.fullNameAliases = fullNameAliases
                self.gender = gender
                self.idNumber = idNumber
                self.lastName = lastName
                self.lastNameKana = lastNameKana
                self.lastNameKanji = lastNameKanji
                self.maidenName = maidenName
                self.metadata = metadata
                self.nationality = nationality
                self.personToken = personToken
                self.phone = phone
                self.politicalExposure = politicalExposure
                self.relationship = relationship
                self.ssnLast4 = ssnLast4
                self.verification = verification
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(account, forKey: "account")
                encoder.encode(address, forKey: "address")
                encoder.encode(addressKana, forKey: "address_kana")
                encoder.encode(addressKanji, forKey: "address_kanji")
                encoder.encode(dob, forKey: "dob")
                encoder.encode(documents, forKey: "documents")
                encoder.encode(email, forKey: "email")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(firstName, forKey: "first_name")
                encoder.encode(firstNameKana, forKey: "first_name_kana")
                encoder.encode(firstNameKanji, forKey: "first_name_kanji")
                encoder.encode(fullNameAliases, forKey: "full_name_aliases")
                encoder.encode(gender, forKey: "gender")
                encoder.encode(idNumber, forKey: "id_number")
                encoder.encode(lastName, forKey: "last_name")
                encoder.encode(lastNameKana, forKey: "last_name_kana")
                encoder.encode(lastNameKanji, forKey: "last_name_kanji")
                encoder.encode(maidenName, forKey: "maiden_name")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(nationality, forKey: "nationality")
                encoder.encode(personToken, forKey: "person_token")
                encoder.encode(phone, forKey: "phone")
                encoder.encode(politicalExposure, forKey: "political_exposure")
                encoder.encode(relationship, forKey: "relationship")
                encoder.encode(ssnLast4, forKey: "ssn_last_4")
                encoder.encode(verification, forKey: "verification")
                return encoder.items
            }
        }
    }
}

extension Paths.Account.Persons {
    public func person(_ person: String) -> WithPerson {
        WithPerson(path: "\(path)/\(person)")
    }

    public struct WithPerson {
        /// Path: `/v1/account/persons/{person}`
        public let path: String

        /// <p>Retrieves an existing person.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Person> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates an existing person.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Person> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            public var account: String?
            /// Address_specs
            ///
            /// The person's address.
            public var address: Address?
            /// Japan_address_kana_specs
            ///
            /// The Kana variation of the person's address (Japan only).
            public var addressKana: AddressKana?
            /// Japan_address_kanji_specs
            ///
            /// The Kanji variation of the person's address (Japan only).
            public var addressKanji: AddressKanji?
            /// The person's date of birth.
            public var dob: Dob?
            /// Person_documents_specs
            ///
            /// Documents that may be submitted to satisfy various informational requests.
            public var documents: Documents?
            /// The person's email address.
            public var email: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The person's first name.
            public var firstName: String?
            /// The Kana variation of the person's first name (Japan only).
            public var firstNameKana: String?
            /// The Kanji variation of the person's first name (Japan only).
            public var firstNameKanji: String?
            /// A list of alternate names or aliases that the person is known by.
            public var fullNameAliases: FullNameAliases?
            /// The person's gender (International regulations require either "male" or "female").
            public var gender: String?
            /// The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
            public var idNumber: String?
            /// The person's last name.
            public var lastName: String?
            /// The Kana variation of the person's last name (Japan only).
            public var lastNameKana: String?
            /// The Kanji variation of the person's last name (Japan only).
            public var lastNameKanji: String?
            /// The person's maiden name.
            public var maidenName: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or "XX" if unavailable.
            public var nationality: String?
            /// A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
            public var personToken: String?
            /// The person's phone number.
            public var phone: String?
            /// Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
            public var politicalExposure: String?
            /// Relationship_specs
            ///
            /// The relationship that this person has with the account's legal entity.
            public var relationship: Relationship?
            /// The last four digits of the person's Social Security number (U.S. only).
            public var ssnLast4: String?
            /// Person_verification_specs
            ///
            /// The person's verification status.
            public var verification: Verification?

            /// Address_specs
            ///
            /// The person's address.
            public struct Address: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    return encoder.items
                }
            }

            /// Japan_address_kana_specs
            ///
            /// The Kana variation of the person's address (Japan only).
            public struct AddressKana: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?
                public var town: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                    self.town = town
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    encoder.encode(town, forKey: "town")
                    return encoder.items
                }
            }

            /// Japan_address_kanji_specs
            ///
            /// The Kanji variation of the person's address (Japan only).
            public struct AddressKanji: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?
                public var town: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                    self.town = town
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    encoder.encode(town, forKey: "town")
                    return encoder.items
                }
            }

            /// The person's date of birth.
            public struct Dob: Encodable {
                /// Date_of_birth_specs
                public var a: A?
                public var b: B?

                /// Date_of_birth_specs
                public struct A: Encodable {
                    public var day: Int
                    public var month: Int
                    public var year: Int

                    public init(day: Int, month: Int, year: Int) {
                        self.day = day
                        self.month = month
                        self.year = year
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(day, forKey: "day")
                        encoder.encode(month, forKey: "month")
                        encoder.encode(year, forKey: "year")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Person_documents_specs
            ///
            /// Documents that may be submitted to satisfy various informational requests.
            public struct Documents: Encodable {
                /// Documents_param
                public var companyAuthorization: CompanyAuthorization?
                /// Documents_param
                public var passport: Passport?
                /// Documents_param
                public var visa: Visa?

                /// Documents_param
                public struct CompanyAuthorization: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct Passport: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct Visa: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                public init(companyAuthorization: CompanyAuthorization? = nil, passport: Passport? = nil, visa: Visa? = nil) {
                    self.companyAuthorization = companyAuthorization
                    self.passport = passport
                    self.visa = visa
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(companyAuthorization, forKey: "company_authorization")
                    encoder.encode(passport, forKey: "passport")
                    encoder.encode(visa, forKey: "visa")
                    return encoder.items
                }
            }

            /// A list of alternate names or aliases that the person is known by.
            public struct FullNameAliases: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Relationship_specs
            ///
            /// The relationship that this person has with the account's legal entity.
            public struct Relationship: Encodable {
                public var isDirector: Bool?
                public var isExecutive: Bool?
                public var isOwner: Bool?
                public var percentOwnership: PercentOwnership?
                public var isRepresentative: Bool?
                public var title: String?

                public struct PercentOwnership: Encodable {
                    public var double: Double?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(double: Double? = nil, object: Object? = nil) {
                        self.double = double
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(double, forKey: "double")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(isDirector: Bool? = nil, isExecutive: Bool? = nil, isOwner: Bool? = nil, percentOwnership: PercentOwnership? = nil, isRepresentative: Bool? = nil, title: String? = nil) {
                    self.isDirector = isDirector
                    self.isExecutive = isExecutive
                    self.isOwner = isOwner
                    self.percentOwnership = percentOwnership
                    self.isRepresentative = isRepresentative
                    self.title = title
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isDirector, forKey: "director")
                    encoder.encode(isExecutive, forKey: "executive")
                    encoder.encode(isOwner, forKey: "owner")
                    encoder.encode(percentOwnership, forKey: "percent_ownership")
                    encoder.encode(isRepresentative, forKey: "representative")
                    encoder.encode(title, forKey: "title")
                    return encoder.items
                }
            }

            /// Person_verification_specs
            ///
            /// The person's verification status.
            public struct Verification: Encodable {
                /// Person_verification_document_specs
                public var additionalDocument: AdditionalDocument?
                /// Person_verification_document_specs
                public var document: Document?

                /// Person_verification_document_specs
                public struct AdditionalDocument: Encodable {
                    public var back: String?
                    public var front: String?

                    public init(back: String? = nil, front: String? = nil) {
                        self.back = back
                        self.front = front
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(back, forKey: "back")
                        encoder.encode(front, forKey: "front")
                        return encoder.items
                    }
                }

                /// Person_verification_document_specs
                public struct Document: Encodable {
                    public var back: String?
                    public var front: String?

                    public init(back: String? = nil, front: String? = nil) {
                        self.back = back
                        self.front = front
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(back, forKey: "back")
                        encoder.encode(front, forKey: "front")
                        return encoder.items
                    }
                }

                public init(additionalDocument: AdditionalDocument? = nil, document: Document? = nil) {
                    self.additionalDocument = additionalDocument
                    self.document = document
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(additionalDocument, forKey: "additional_document")
                    encoder.encode(document, forKey: "document")
                    return encoder.items
                }
            }

            public init(account: String? = nil, address: Address? = nil, addressKana: AddressKana? = nil, addressKanji: AddressKanji? = nil, dob: Dob? = nil, documents: Documents? = nil, email: String? = nil, expand: [String]? = nil, firstName: String? = nil, firstNameKana: String? = nil, firstNameKanji: String? = nil, fullNameAliases: FullNameAliases? = nil, gender: String? = nil, idNumber: String? = nil, lastName: String? = nil, lastNameKana: String? = nil, lastNameKanji: String? = nil, maidenName: String? = nil, metadata: Metadata? = nil, nationality: String? = nil, personToken: String? = nil, phone: String? = nil, politicalExposure: String? = nil, relationship: Relationship? = nil, ssnLast4: String? = nil, verification: Verification? = nil) {
                self.account = account
                self.address = address
                self.addressKana = addressKana
                self.addressKanji = addressKanji
                self.dob = dob
                self.documents = documents
                self.email = email
                self.expand = expand
                self.firstName = firstName
                self.firstNameKana = firstNameKana
                self.firstNameKanji = firstNameKanji
                self.fullNameAliases = fullNameAliases
                self.gender = gender
                self.idNumber = idNumber
                self.lastName = lastName
                self.lastNameKana = lastNameKana
                self.lastNameKanji = lastNameKanji
                self.maidenName = maidenName
                self.metadata = metadata
                self.nationality = nationality
                self.personToken = personToken
                self.phone = phone
                self.politicalExposure = politicalExposure
                self.relationship = relationship
                self.ssnLast4 = ssnLast4
                self.verification = verification
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(account, forKey: "account")
                encoder.encode(address, forKey: "address")
                encoder.encode(addressKana, forKey: "address_kana")
                encoder.encode(addressKanji, forKey: "address_kanji")
                encoder.encode(dob, forKey: "dob")
                encoder.encode(documents, forKey: "documents")
                encoder.encode(email, forKey: "email")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(firstName, forKey: "first_name")
                encoder.encode(firstNameKana, forKey: "first_name_kana")
                encoder.encode(firstNameKanji, forKey: "first_name_kanji")
                encoder.encode(fullNameAliases, forKey: "full_name_aliases")
                encoder.encode(gender, forKey: "gender")
                encoder.encode(idNumber, forKey: "id_number")
                encoder.encode(lastName, forKey: "last_name")
                encoder.encode(lastNameKana, forKey: "last_name_kana")
                encoder.encode(lastNameKanji, forKey: "last_name_kanji")
                encoder.encode(maidenName, forKey: "maiden_name")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(nationality, forKey: "nationality")
                encoder.encode(personToken, forKey: "person_token")
                encoder.encode(phone, forKey: "phone")
                encoder.encode(politicalExposure, forKey: "political_exposure")
                encoder.encode(relationship, forKey: "relationship")
                encoder.encode(ssnLast4, forKey: "ssn_last_4")
                encoder.encode(verification, forKey: "verification")
                return encoder.items
            }
        }

        /// <p>Deletes an existing person’s relationship to the account’s legal entity. Any person with a relationship for an account can be deleted through the API, except if the person is the <code>account_opener</code>. If your integration is using the <code>executive</code> parameter, you cannot delete the only verified <code>executive</code> on file.</p>
        public var delete: Request<StripeAPI.DeletedPerson> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var accountLinks: AccountLinks {
        AccountLinks(path: "/v1/account_links")
    }

    public struct AccountLinks {
        /// Path: `/v1/account_links`
        public let path: String

        /// <p>Creates an AccountLink object that includes a single-use Stripe URL that the platform can redirect their user to in order to take them through the Connect Onboarding flow.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.AccountLink> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The identifier of the account to create an account link for.
            public var account: String
            /// Which information the platform needs to collect from the user. One of `currently_due` or `eventually_due`. Default is `currently_due`.
            public var collect: Collect?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The URL the user will be redirected to if the account link is expired, has been previously-visited, or is otherwise invalid. The URL you specify should attempt to generate a new account link with the same parameters used to create the original account link, then redirect the user to the new account link's URL so they can continue with Connect Onboarding. If a new account link cannot be generated or the redirect fails you should display a useful error to the user.
            public var refreshURL: String?
            /// The URL that the user will be redirected to upon leaving or completing the linked flow.
            public var returnURL: String?
            /// The type of account link the user is requesting. Possible values are `account_onboarding` or `account_update`.
            public var type: `Type`

            /// Which information the platform needs to collect from the user. One of `currently_due` or `eventually_due`. Default is `currently_due`.
            public enum Collect: String, Codable, CaseIterable {
                case currentlyDue = "currently_due"
                case eventuallyDue = "eventually_due"
            }

            /// The type of account link the user is requesting. Possible values are `account_onboarding` or `account_update`.
            public enum `Type`: String, Codable, CaseIterable {
                case accountOnboarding = "account_onboarding"
                case accountUpdate = "account_update"
            }

            public init(account: String, collect: Collect? = nil, expand: [String]? = nil, refreshURL: String? = nil, returnURL: String? = nil, type: `Type`) {
                self.account = account
                self.collect = collect
                self.expand = expand
                self.refreshURL = refreshURL
                self.returnURL = returnURL
                self.type = type
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(account, forKey: "account")
                encoder.encode(collect, forKey: "collect")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(refreshURL, forKey: "refresh_url")
                encoder.encode(returnURL, forKey: "return_url")
                encoder.encode(type, forKey: "type")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var accounts: Accounts {
        Accounts(path: "/v1/accounts")
    }

    public struct Accounts {
        /// Path: `/v1/accounts`
        public let path: String

        /// <p>Returns a list of accounts connected to your platform via <a href="/docs/connect">Connect</a>. If you’re not a platform, the list is empty.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Account]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Account], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>With <a href="/docs/connect">Connect</a>, you can create Stripe accounts for your users.
        /// To do this, you’ll first need to <a href="https://dashboard.stripe.com/account/applications/settings">register your platform</a>.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Account> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// An [account token](https://stripe.com/docs/api#create_account_token), used to securely provide details to the account.
            public var accountToken: String?
            /// Either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details.
            public var bankAccount: BankAccount?
            /// Business_profile_specs
            ///
            /// Business information about the account.
            public var businessProfile: BusinessProfile?
            /// The business type.
            public var businessType: BusinessType?
            /// Capabilities_param
            ///
            /// Each key of the dictionary represents a capability, and each capability maps to its settings (e.g. whether it has been requested or not). Each capability will be inactive until you have provided its specific requirements and Stripe has verified them. An account may have some of its requested capabilities be active and some be inactive.
            public var capabilities: Capabilities?
            /// Company_specs
            ///
            /// Information about the company or business. This field is available for any `business_type`.
            public var company: Company?
            /// The country in which the account holder resides, or in which the business is legally established. This should be an ISO 3166-1 alpha-2 country code. For example, if you are in the United States and the business for which you're creating an account is legally represented in Canada, you would use `CA` as the country for the account being created.
            public var country: String?
            /// Three-letter ISO currency code representing the default currency for the account. This must be a currency that [Stripe supports in the account's country](https://stripe.com/docs/payouts).
            public var defaultCurrency: String?
            /// Documents_specs
            ///
            /// Documents that may be submitted to satisfy various informational requests.
            public var documents: Documents?
            /// The email address of the account holder. This is only to make the account easier to identify to you. Stripe only emails Custom accounts with your consent.
            public var email: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// A card or bank account to attach to the account for receiving [payouts](https://stripe.com/docs/connect/bank-debit-card-payouts) (you won’t be able to use it for top-ups). You can provide either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary, as documented in the `external_account` parameter for [bank account](https://stripe.com/docs/api#account_create_bank_account) creation. <br><br>By default, providing an external account sets it as the new default external account for its currency, and deletes the old default if one exists. To add additional external accounts without replacing the existing default for the currency, use the bank account or card creation API.
            public var externalAccount: String?
            /// Individual_specs
            ///
            /// Information about the person represented by the account. This field is null unless `business_type` is set to `individual`.
            public var individual: Individual?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// Settings_specs
            ///
            /// Options for customizing how the account functions within Stripe.
            public var settings: Settings?
            /// Tos_acceptance_specs
            ///
            /// Details on the account's acceptance of the [Stripe Services Agreement](https://stripe.com/docs/connect/updating-accounts#tos-acceptance).
            public var tosAcceptance: TosAcceptance?
            /// The type of Stripe account to create. May be one of `custom`, `express` or `standard`.
            public var type: `Type`?

            /// Either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details.
            public struct BankAccount: Encodable {
                /// External_account_payout_bank_account
                public var object: Object?
                public var string: String?

                /// External_account_payout_bank_account
                public struct Object: Encodable {
                    public var accountHolderName: String?
                    public var accountHolderType: AccountHolderType?
                    public var accountNumber: String
                    public var accountType: AccountType?
                    public var country: String
                    public var currency: String?
                    public var object: Object?
                    public var routingNumber: String?

                    public enum AccountHolderType: String, Codable, CaseIterable {
                        case company
                        case individual
                    }

                    public enum AccountType: String, Codable, CaseIterable {
                        case checking
                        case futsu
                        case savings
                        case toza
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case bankAccount = "bank_account"
                    }

                    public init(accountHolderName: String? = nil, accountHolderType: AccountHolderType? = nil, accountNumber: String, accountType: AccountType? = nil, country: String, currency: String? = nil, object: Object? = nil, routingNumber: String? = nil) {
                        self.accountHolderName = accountHolderName
                        self.accountHolderType = accountHolderType
                        self.accountNumber = accountNumber
                        self.accountType = accountType
                        self.country = country
                        self.currency = currency
                        self.object = object
                        self.routingNumber = routingNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountHolderName, forKey: "account_holder_name")
                        encoder.encode(accountHolderType, forKey: "account_holder_type")
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(accountType, forKey: "account_type")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(object, forKey: "object")
                        encoder.encode(routingNumber, forKey: "routing_number")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, string: String? = nil) {
                    self.object = object
                    self.string = string
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(string, forKey: "string")
                    return encoder.items
                }
            }

            /// Business_profile_specs
            ///
            /// Business information about the account.
            public struct BusinessProfile: Encodable {
                public var mcc: String?
                public var name: String?
                public var productDescription: String?
                /// Address_specs
                public var supportAddress: SupportAddress?
                public var supportEmail: String?
                public var supportPhone: String?
                public var supportURL: SupportURL?
                public var url: String?

                /// Address_specs
                public struct SupportAddress: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                public struct SupportURL: Encodable {
                    public var string: String?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(string: String? = nil, object: Object? = nil) {
                        self.string = string
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(string, forKey: "string")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(mcc: String? = nil, name: String? = nil, productDescription: String? = nil, supportAddress: SupportAddress? = nil, supportEmail: String? = nil, supportPhone: String? = nil, supportURL: SupportURL? = nil, url: String? = nil) {
                    self.mcc = mcc
                    self.name = name
                    self.productDescription = productDescription
                    self.supportAddress = supportAddress
                    self.supportEmail = supportEmail
                    self.supportPhone = supportPhone
                    self.supportURL = supportURL
                    self.url = url
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(mcc, forKey: "mcc")
                    encoder.encode(name, forKey: "name")
                    encoder.encode(productDescription, forKey: "product_description")
                    encoder.encode(supportAddress, forKey: "support_address")
                    encoder.encode(supportEmail, forKey: "support_email")
                    encoder.encode(supportPhone, forKey: "support_phone")
                    encoder.encode(supportURL, forKey: "support_url")
                    encoder.encode(url, forKey: "url")
                    return encoder.items
                }
            }

            /// The business type.
            public enum BusinessType: String, Codable, CaseIterable {
                case company
                case governmentEntity = "government_entity"
                case individual
                case nonProfit = "non_profit"
            }

            /// Capabilities_param
            ///
            /// Each key of the dictionary represents a capability, and each capability maps to its settings (e.g. whether it has been requested or not). Each capability will be inactive until you have provided its specific requirements and Stripe has verified them. An account may have some of its requested capabilities be active and some be inactive.
            public struct Capabilities: Encodable {
                /// Capability_param
                public var acssDebitPayments: AcssDebitPayments?
                /// Capability_param
                public var afterpayClearpayPayments: AfterpayClearpayPayments?
                /// Capability_param
                public var auBecsDebitPayments: AuBecsDebitPayments?
                /// Capability_param
                public var bacsDebitPayments: BacsDebitPayments?
                /// Capability_param
                public var bancontactPayments: BancontactPayments?
                /// Capability_param
                public var boletoPayments: BoletoPayments?
                /// Capability_param
                public var cardIssuing: CardIssuing?
                /// Capability_param
                public var cardPayments: CardPayments?
                /// Capability_param
                public var cartesBancairesPayments: CartesBancairesPayments?
                /// Capability_param
                public var epsPayments: EpsPayments?
                /// Capability_param
                public var fpxPayments: FpxPayments?
                /// Capability_param
                public var giropayPayments: GiropayPayments?
                /// Capability_param
                public var grabpayPayments: GrabpayPayments?
                /// Capability_param
                public var idealPayments: IdealPayments?
                /// Capability_param
                public var jcbPayments: JcbPayments?
                /// Capability_param
                public var klarnaPayments: KlarnaPayments?
                /// Capability_param
                public var legacyPayments: LegacyPayments?
                /// Capability_param
                public var oxxoPayments: OxxoPayments?
                /// Capability_param
                public var p24Payments: P24Payments?
                /// Capability_param
                public var sepaDebitPayments: SepaDebitPayments?
                /// Capability_param
                public var sofortPayments: SofortPayments?
                /// Capability_param
                public var taxReportingUs1099K: TaxReportingUs1099K?
                /// Capability_param
                public var taxReportingUs1099Misc: TaxReportingUs1099Misc?
                /// Capability_param
                public var transfers: Transfers?

                /// Capability_param
                public struct AcssDebitPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct AfterpayClearpayPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct AuBecsDebitPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct BacsDebitPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct BancontactPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct BoletoPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct CardIssuing: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct CardPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct CartesBancairesPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct EpsPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct FpxPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct GiropayPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct GrabpayPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct IdealPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct JcbPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct KlarnaPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct LegacyPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct OxxoPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct P24Payments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct SepaDebitPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct SofortPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct TaxReportingUs1099K: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct TaxReportingUs1099Misc: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct Transfers: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                public init(acssDebitPayments: AcssDebitPayments? = nil, afterpayClearpayPayments: AfterpayClearpayPayments? = nil, auBecsDebitPayments: AuBecsDebitPayments? = nil, bacsDebitPayments: BacsDebitPayments? = nil, bancontactPayments: BancontactPayments? = nil, boletoPayments: BoletoPayments? = nil, cardIssuing: CardIssuing? = nil, cardPayments: CardPayments? = nil, cartesBancairesPayments: CartesBancairesPayments? = nil, epsPayments: EpsPayments? = nil, fpxPayments: FpxPayments? = nil, giropayPayments: GiropayPayments? = nil, grabpayPayments: GrabpayPayments? = nil, idealPayments: IdealPayments? = nil, jcbPayments: JcbPayments? = nil, klarnaPayments: KlarnaPayments? = nil, legacyPayments: LegacyPayments? = nil, oxxoPayments: OxxoPayments? = nil, p24Payments: P24Payments? = nil, sepaDebitPayments: SepaDebitPayments? = nil, sofortPayments: SofortPayments? = nil, taxReportingUs1099K: TaxReportingUs1099K? = nil, taxReportingUs1099Misc: TaxReportingUs1099Misc? = nil, transfers: Transfers? = nil) {
                    self.acssDebitPayments = acssDebitPayments
                    self.afterpayClearpayPayments = afterpayClearpayPayments
                    self.auBecsDebitPayments = auBecsDebitPayments
                    self.bacsDebitPayments = bacsDebitPayments
                    self.bancontactPayments = bancontactPayments
                    self.boletoPayments = boletoPayments
                    self.cardIssuing = cardIssuing
                    self.cardPayments = cardPayments
                    self.cartesBancairesPayments = cartesBancairesPayments
                    self.epsPayments = epsPayments
                    self.fpxPayments = fpxPayments
                    self.giropayPayments = giropayPayments
                    self.grabpayPayments = grabpayPayments
                    self.idealPayments = idealPayments
                    self.jcbPayments = jcbPayments
                    self.klarnaPayments = klarnaPayments
                    self.legacyPayments = legacyPayments
                    self.oxxoPayments = oxxoPayments
                    self.p24Payments = p24Payments
                    self.sepaDebitPayments = sepaDebitPayments
                    self.sofortPayments = sofortPayments
                    self.taxReportingUs1099K = taxReportingUs1099K
                    self.taxReportingUs1099Misc = taxReportingUs1099Misc
                    self.transfers = transfers
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(acssDebitPayments, forKey: "acss_debit_payments")
                    encoder.encode(afterpayClearpayPayments, forKey: "afterpay_clearpay_payments")
                    encoder.encode(auBecsDebitPayments, forKey: "au_becs_debit_payments")
                    encoder.encode(bacsDebitPayments, forKey: "bacs_debit_payments")
                    encoder.encode(bancontactPayments, forKey: "bancontact_payments")
                    encoder.encode(boletoPayments, forKey: "boleto_payments")
                    encoder.encode(cardIssuing, forKey: "card_issuing")
                    encoder.encode(cardPayments, forKey: "card_payments")
                    encoder.encode(cartesBancairesPayments, forKey: "cartes_bancaires_payments")
                    encoder.encode(epsPayments, forKey: "eps_payments")
                    encoder.encode(fpxPayments, forKey: "fpx_payments")
                    encoder.encode(giropayPayments, forKey: "giropay_payments")
                    encoder.encode(grabpayPayments, forKey: "grabpay_payments")
                    encoder.encode(idealPayments, forKey: "ideal_payments")
                    encoder.encode(jcbPayments, forKey: "jcb_payments")
                    encoder.encode(klarnaPayments, forKey: "klarna_payments")
                    encoder.encode(legacyPayments, forKey: "legacy_payments")
                    encoder.encode(oxxoPayments, forKey: "oxxo_payments")
                    encoder.encode(p24Payments, forKey: "p24_payments")
                    encoder.encode(sepaDebitPayments, forKey: "sepa_debit_payments")
                    encoder.encode(sofortPayments, forKey: "sofort_payments")
                    encoder.encode(taxReportingUs1099K, forKey: "tax_reporting_us_1099_k")
                    encoder.encode(taxReportingUs1099Misc, forKey: "tax_reporting_us_1099_misc")
                    encoder.encode(transfers, forKey: "transfers")
                    return encoder.items
                }
            }

            /// Company_specs
            ///
            /// Information about the company or business. This field is available for any `business_type`.
            public struct Company: Encodable {
                /// Address_specs
                public var address: Address?
                /// Japan_address_kana_specs
                public var addressKana: AddressKana?
                /// Japan_address_kanji_specs
                public var addressKanji: AddressKanji?
                public var isDirectorsProvided: Bool?
                public var isExecutivesProvided: Bool?
                public var name: String?
                public var nameKana: String?
                public var nameKanji: String?
                public var isOwnersProvided: Bool?
                /// Company_ownership_declaration
                public var ownershipDeclaration: OwnershipDeclaration?
                public var phone: String?
                public var registrationNumber: String?
                public var structure: Structure?
                public var taxID: String?
                public var taxIDRegistrar: String?
                public var vatID: String?
                /// Verification_specs
                public var verification: Verification?

                /// Address_specs
                public struct Address: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                /// Japan_address_kana_specs
                public struct AddressKana: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?
                    public var town: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                        self.town = town
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        encoder.encode(town, forKey: "town")
                        return encoder.items
                    }
                }

                /// Japan_address_kanji_specs
                public struct AddressKanji: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?
                    public var town: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                        self.town = town
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        encoder.encode(town, forKey: "town")
                        return encoder.items
                    }
                }

                /// Company_ownership_declaration
                public struct OwnershipDeclaration: Encodable {
                    public var date: Int?
                    public var ip: String?
                    public var userAgent: String?

                    public init(date: Int? = nil, ip: String? = nil, userAgent: String? = nil) {
                        self.date = date
                        self.ip = ip
                        self.userAgent = userAgent
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(date, forKey: "date")
                        encoder.encode(ip, forKey: "ip")
                        encoder.encode(userAgent, forKey: "user_agent")
                        return encoder.items
                    }
                }

                public enum Structure: String, Codable, CaseIterable {
                    case empty = ""
                    case freeZoneEstablishment = "free_zone_establishment"
                    case freeZoneLlc = "free_zone_llc"
                    case governmentInstrumentality = "government_instrumentality"
                    case governmentalUnit = "governmental_unit"
                    case incorporatedNonProfit = "incorporated_non_profit"
                    case limitedLiabilityPartnership = "limited_liability_partnership"
                    case llc
                    case multiMemberLlc = "multi_member_llc"
                    case privateCompany = "private_company"
                    case privateCorporation = "private_corporation"
                    case privatePartnership = "private_partnership"
                    case publicCompany = "public_company"
                    case publicCorporation = "public_corporation"
                    case publicPartnership = "public_partnership"
                    case singleMemberLlc = "single_member_llc"
                    case soleEstablishment = "sole_establishment"
                    case soleProprietorship = "sole_proprietorship"
                    case taxExemptGovernmentInstrumentality = "tax_exempt_government_instrumentality"
                    case unincorporatedAssociation = "unincorporated_association"
                    case unincorporatedNonProfit = "unincorporated_non_profit"
                }

                /// Verification_specs
                public struct Verification: Encodable {
                    /// Verification_document_specs
                    public var document: Document?

                    /// Verification_document_specs
                    public struct Document: Encodable {
                        public var back: String?
                        public var front: String?

                        public init(back: String? = nil, front: String? = nil) {
                            self.back = back
                            self.front = front
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(back, forKey: "back")
                            encoder.encode(front, forKey: "front")
                            return encoder.items
                        }
                    }

                    public init(document: Document? = nil) {
                        self.document = document
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(document, forKey: "document")
                        return encoder.items
                    }
                }

                public init(address: Address? = nil, addressKana: AddressKana? = nil, addressKanji: AddressKanji? = nil, isDirectorsProvided: Bool? = nil, isExecutivesProvided: Bool? = nil, name: String? = nil, nameKana: String? = nil, nameKanji: String? = nil, isOwnersProvided: Bool? = nil, ownershipDeclaration: OwnershipDeclaration? = nil, phone: String? = nil, registrationNumber: String? = nil, structure: Structure? = nil, taxID: String? = nil, taxIDRegistrar: String? = nil, vatID: String? = nil, verification: Verification? = nil) {
                    self.address = address
                    self.addressKana = addressKana
                    self.addressKanji = addressKanji
                    self.isDirectorsProvided = isDirectorsProvided
                    self.isExecutivesProvided = isExecutivesProvided
                    self.name = name
                    self.nameKana = nameKana
                    self.nameKanji = nameKanji
                    self.isOwnersProvided = isOwnersProvided
                    self.ownershipDeclaration = ownershipDeclaration
                    self.phone = phone
                    self.registrationNumber = registrationNumber
                    self.structure = structure
                    self.taxID = taxID
                    self.taxIDRegistrar = taxIDRegistrar
                    self.vatID = vatID
                    self.verification = verification
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(addressKana, forKey: "address_kana")
                    encoder.encode(addressKanji, forKey: "address_kanji")
                    encoder.encode(isDirectorsProvided, forKey: "directors_provided")
                    encoder.encode(isExecutivesProvided, forKey: "executives_provided")
                    encoder.encode(name, forKey: "name")
                    encoder.encode(nameKana, forKey: "name_kana")
                    encoder.encode(nameKanji, forKey: "name_kanji")
                    encoder.encode(isOwnersProvided, forKey: "owners_provided")
                    encoder.encode(ownershipDeclaration, forKey: "ownership_declaration")
                    encoder.encode(phone, forKey: "phone")
                    encoder.encode(registrationNumber, forKey: "registration_number")
                    encoder.encode(structure, forKey: "structure")
                    encoder.encode(taxID, forKey: "tax_id")
                    encoder.encode(taxIDRegistrar, forKey: "tax_id_registrar")
                    encoder.encode(vatID, forKey: "vat_id")
                    encoder.encode(verification, forKey: "verification")
                    return encoder.items
                }
            }

            /// Documents_specs
            ///
            /// Documents that may be submitted to satisfy various informational requests.
            public struct Documents: Encodable {
                /// Documents_param
                public var bankAccountOwnershipVerification: BankAccountOwnershipVerification?
                /// Documents_param
                public var companyLicense: CompanyLicense?
                /// Documents_param
                public var companyMemorandumOfAssociation: CompanyMemorandumOfAssociation?
                /// Documents_param
                public var companyMinisterialDecree: CompanyMinisterialDecree?
                /// Documents_param
                public var companyRegistrationVerification: CompanyRegistrationVerification?
                /// Documents_param
                public var companyTaxIDVerification: CompanyTaxIDVerification?
                /// Documents_param
                public var proofOfRegistration: ProofOfRegistration?

                /// Documents_param
                public struct BankAccountOwnershipVerification: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct CompanyLicense: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct CompanyMemorandumOfAssociation: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct CompanyMinisterialDecree: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct CompanyRegistrationVerification: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct CompanyTaxIDVerification: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct ProofOfRegistration: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                public init(bankAccountOwnershipVerification: BankAccountOwnershipVerification? = nil, companyLicense: CompanyLicense? = nil, companyMemorandumOfAssociation: CompanyMemorandumOfAssociation? = nil, companyMinisterialDecree: CompanyMinisterialDecree? = nil, companyRegistrationVerification: CompanyRegistrationVerification? = nil, companyTaxIDVerification: CompanyTaxIDVerification? = nil, proofOfRegistration: ProofOfRegistration? = nil) {
                    self.bankAccountOwnershipVerification = bankAccountOwnershipVerification
                    self.companyLicense = companyLicense
                    self.companyMemorandumOfAssociation = companyMemorandumOfAssociation
                    self.companyMinisterialDecree = companyMinisterialDecree
                    self.companyRegistrationVerification = companyRegistrationVerification
                    self.companyTaxIDVerification = companyTaxIDVerification
                    self.proofOfRegistration = proofOfRegistration
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(bankAccountOwnershipVerification, forKey: "bank_account_ownership_verification")
                    encoder.encode(companyLicense, forKey: "company_license")
                    encoder.encode(companyMemorandumOfAssociation, forKey: "company_memorandum_of_association")
                    encoder.encode(companyMinisterialDecree, forKey: "company_ministerial_decree")
                    encoder.encode(companyRegistrationVerification, forKey: "company_registration_verification")
                    encoder.encode(companyTaxIDVerification, forKey: "company_tax_id_verification")
                    encoder.encode(proofOfRegistration, forKey: "proof_of_registration")
                    return encoder.items
                }
            }

            /// Individual_specs
            ///
            /// Information about the person represented by the account. This field is null unless `business_type` is set to `individual`.
            public struct Individual: Encodable {
                /// Address_specs
                public var address: Address?
                /// Japan_address_kana_specs
                public var addressKana: AddressKana?
                /// Japan_address_kanji_specs
                public var addressKanji: AddressKanji?
                public var dob: Dob?
                public var email: String?
                public var firstName: String?
                public var firstNameKana: String?
                public var firstNameKanji: String?
                public var fullNameAliases: FullNameAliases?
                public var gender: String?
                public var idNumber: String?
                public var lastName: String?
                public var lastNameKana: String?
                public var lastNameKanji: String?
                public var maidenName: String?
                public var metadata: Metadata?
                public var phone: String?
                public var politicalExposure: PoliticalExposure?
                public var ssnLast4: String?
                /// Person_verification_specs
                public var verification: Verification?

                /// Address_specs
                public struct Address: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                /// Japan_address_kana_specs
                public struct AddressKana: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?
                    public var town: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                        self.town = town
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        encoder.encode(town, forKey: "town")
                        return encoder.items
                    }
                }

                /// Japan_address_kanji_specs
                public struct AddressKanji: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?
                    public var town: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                        self.town = town
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        encoder.encode(town, forKey: "town")
                        return encoder.items
                    }
                }

                public struct Dob: Encodable {
                    /// Date_of_birth_specs
                    public var a: A?
                    public var b: B?

                    /// Date_of_birth_specs
                    public struct A: Encodable {
                        public var day: Int
                        public var month: Int
                        public var year: Int

                        public init(day: Int, month: Int, year: Int) {
                            self.day = day
                            self.month = month
                            self.year = year
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(day, forKey: "day")
                            encoder.encode(month, forKey: "month")
                            encoder.encode(year, forKey: "year")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct FullNameAliases: Encodable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public struct Metadata: Encodable {
                    public var stringString: [String: String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(stringString: [String: String]? = nil, object: Object? = nil) {
                        self.stringString = stringString
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(stringString, forKey: "stringString")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public enum PoliticalExposure: String, Codable, CaseIterable {
                    case existing
                    case `none`
                }

                /// Person_verification_specs
                public struct Verification: Encodable {
                    /// Person_verification_document_specs
                    public var additionalDocument: AdditionalDocument?
                    /// Person_verification_document_specs
                    public var document: Document?

                    /// Person_verification_document_specs
                    public struct AdditionalDocument: Encodable {
                        public var back: String?
                        public var front: String?

                        public init(back: String? = nil, front: String? = nil) {
                            self.back = back
                            self.front = front
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(back, forKey: "back")
                            encoder.encode(front, forKey: "front")
                            return encoder.items
                        }
                    }

                    /// Person_verification_document_specs
                    public struct Document: Encodable {
                        public var back: String?
                        public var front: String?

                        public init(back: String? = nil, front: String? = nil) {
                            self.back = back
                            self.front = front
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(back, forKey: "back")
                            encoder.encode(front, forKey: "front")
                            return encoder.items
                        }
                    }

                    public init(additionalDocument: AdditionalDocument? = nil, document: Document? = nil) {
                        self.additionalDocument = additionalDocument
                        self.document = document
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(additionalDocument, forKey: "additional_document")
                        encoder.encode(document, forKey: "document")
                        return encoder.items
                    }
                }

                public init(address: Address? = nil, addressKana: AddressKana? = nil, addressKanji: AddressKanji? = nil, dob: Dob? = nil, email: String? = nil, firstName: String? = nil, firstNameKana: String? = nil, firstNameKanji: String? = nil, fullNameAliases: FullNameAliases? = nil, gender: String? = nil, idNumber: String? = nil, lastName: String? = nil, lastNameKana: String? = nil, lastNameKanji: String? = nil, maidenName: String? = nil, metadata: Metadata? = nil, phone: String? = nil, politicalExposure: PoliticalExposure? = nil, ssnLast4: String? = nil, verification: Verification? = nil) {
                    self.address = address
                    self.addressKana = addressKana
                    self.addressKanji = addressKanji
                    self.dob = dob
                    self.email = email
                    self.firstName = firstName
                    self.firstNameKana = firstNameKana
                    self.firstNameKanji = firstNameKanji
                    self.fullNameAliases = fullNameAliases
                    self.gender = gender
                    self.idNumber = idNumber
                    self.lastName = lastName
                    self.lastNameKana = lastNameKana
                    self.lastNameKanji = lastNameKanji
                    self.maidenName = maidenName
                    self.metadata = metadata
                    self.phone = phone
                    self.politicalExposure = politicalExposure
                    self.ssnLast4 = ssnLast4
                    self.verification = verification
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(addressKana, forKey: "address_kana")
                    encoder.encode(addressKanji, forKey: "address_kanji")
                    encoder.encode(dob, forKey: "dob")
                    encoder.encode(email, forKey: "email")
                    encoder.encode(firstName, forKey: "first_name")
                    encoder.encode(firstNameKana, forKey: "first_name_kana")
                    encoder.encode(firstNameKanji, forKey: "first_name_kanji")
                    encoder.encode(fullNameAliases, forKey: "full_name_aliases")
                    encoder.encode(gender, forKey: "gender")
                    encoder.encode(idNumber, forKey: "id_number")
                    encoder.encode(lastName, forKey: "last_name")
                    encoder.encode(lastNameKana, forKey: "last_name_kana")
                    encoder.encode(lastNameKanji, forKey: "last_name_kanji")
                    encoder.encode(maidenName, forKey: "maiden_name")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(phone, forKey: "phone")
                    encoder.encode(politicalExposure, forKey: "political_exposure")
                    encoder.encode(ssnLast4, forKey: "ssn_last_4")
                    encoder.encode(verification, forKey: "verification")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Settings_specs
            ///
            /// Options for customizing how the account functions within Stripe.
            public struct Settings: Encodable {
                /// Branding_settings_specs
                public var branding: Branding?
                /// Card_issuing_settings_specs
                public var cardIssuing: CardIssuing?
                /// Card_payments_settings_specs
                public var cardPayments: CardPayments?
                /// Payments_settings_specs
                public var payments: Payments?
                /// Payout_settings_specs
                public var payouts: Payouts?

                /// Branding_settings_specs
                public struct Branding: Encodable {
                    public var icon: String?
                    public var logo: String?
                    public var primaryColor: String?
                    public var secondaryColor: String?

                    public init(icon: String? = nil, logo: String? = nil, primaryColor: String? = nil, secondaryColor: String? = nil) {
                        self.icon = icon
                        self.logo = logo
                        self.primaryColor = primaryColor
                        self.secondaryColor = secondaryColor
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(icon, forKey: "icon")
                        encoder.encode(logo, forKey: "logo")
                        encoder.encode(primaryColor, forKey: "primary_color")
                        encoder.encode(secondaryColor, forKey: "secondary_color")
                        return encoder.items
                    }
                }

                /// Card_issuing_settings_specs
                public struct CardIssuing: Encodable {
                    /// Settings_terms_of_service_specs
                    public var tosAcceptance: TosAcceptance?

                    /// Settings_terms_of_service_specs
                    public struct TosAcceptance: Encodable {
                        public var date: Int?
                        public var ip: String?
                        public var userAgent: String?

                        public init(date: Int? = nil, ip: String? = nil, userAgent: String? = nil) {
                            self.date = date
                            self.ip = ip
                            self.userAgent = userAgent
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(date, forKey: "date")
                            encoder.encode(ip, forKey: "ip")
                            encoder.encode(userAgent, forKey: "user_agent")
                            return encoder.items
                        }
                    }

                    public init(tosAcceptance: TosAcceptance? = nil) {
                        self.tosAcceptance = tosAcceptance
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(tosAcceptance, forKey: "tos_acceptance")
                        return encoder.items
                    }
                }

                /// Card_payments_settings_specs
                public struct CardPayments: Encodable {
                    /// Decline_charge_on_specs
                    public var declineOn: DeclineOn?
                    public var statementDescriptorPrefix: String?

                    /// Decline_charge_on_specs
                    public struct DeclineOn: Encodable {
                        public var isAvsFailure: Bool?
                        public var isCvcFailure: Bool?

                        public init(isAvsFailure: Bool? = nil, isCvcFailure: Bool? = nil) {
                            self.isAvsFailure = isAvsFailure
                            self.isCvcFailure = isCvcFailure
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(isAvsFailure, forKey: "avs_failure")
                            encoder.encode(isCvcFailure, forKey: "cvc_failure")
                            return encoder.items
                        }
                    }

                    public init(declineOn: DeclineOn? = nil, statementDescriptorPrefix: String? = nil) {
                        self.declineOn = declineOn
                        self.statementDescriptorPrefix = statementDescriptorPrefix
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(declineOn, forKey: "decline_on")
                        encoder.encode(statementDescriptorPrefix, forKey: "statement_descriptor_prefix")
                        return encoder.items
                    }
                }

                /// Payments_settings_specs
                public struct Payments: Encodable {
                    public var statementDescriptor: String?
                    public var statementDescriptorKana: String?
                    public var statementDescriptorKanji: String?

                    public init(statementDescriptor: String? = nil, statementDescriptorKana: String? = nil, statementDescriptorKanji: String? = nil) {
                        self.statementDescriptor = statementDescriptor
                        self.statementDescriptorKana = statementDescriptorKana
                        self.statementDescriptorKanji = statementDescriptorKanji
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                        encoder.encode(statementDescriptorKana, forKey: "statement_descriptor_kana")
                        encoder.encode(statementDescriptorKanji, forKey: "statement_descriptor_kanji")
                        return encoder.items
                    }
                }

                /// Payout_settings_specs
                public struct Payouts: Encodable {
                    public var isDebitNegativeBalances: Bool?
                    /// Transfer_schedule_specs
                    public var schedule: Schedule?
                    public var statementDescriptor: String?

                    /// Transfer_schedule_specs
                    public struct Schedule: Encodable {
                        public var delayDays: DelayDays?
                        public var interval: Interval?
                        public var monthlyAnchor: Int?
                        public var weeklyAnchor: WeeklyAnchor?

                        public struct DelayDays: Encodable {
                            public var object: Object?
                            public var int: Int?

                            public enum Object: String, Codable, CaseIterable {
                                case minimum
                            }

                            public init(object: Object? = nil, int: Int? = nil) {
                                self.object = object
                                self.int = int
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(object, forKey: "object")
                                encoder.encode(int, forKey: "int")
                                return encoder.items
                            }
                        }

                        public enum Interval: String, Codable, CaseIterable {
                            case daily
                            case manual
                            case monthly
                            case weekly
                        }

                        public enum WeeklyAnchor: String, Codable, CaseIterable {
                            case friday
                            case monday
                            case saturday
                            case sunday
                            case thursday
                            case tuesday
                            case wednesday
                        }

                        public init(delayDays: DelayDays? = nil, interval: Interval? = nil, monthlyAnchor: Int? = nil, weeklyAnchor: WeeklyAnchor? = nil) {
                            self.delayDays = delayDays
                            self.interval = interval
                            self.monthlyAnchor = monthlyAnchor
                            self.weeklyAnchor = weeklyAnchor
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(delayDays, forKey: "delay_days")
                            encoder.encode(interval, forKey: "interval")
                            encoder.encode(monthlyAnchor, forKey: "monthly_anchor")
                            encoder.encode(weeklyAnchor, forKey: "weekly_anchor")
                            return encoder.items
                        }
                    }

                    public init(isDebitNegativeBalances: Bool? = nil, schedule: Schedule? = nil, statementDescriptor: String? = nil) {
                        self.isDebitNegativeBalances = isDebitNegativeBalances
                        self.schedule = schedule
                        self.statementDescriptor = statementDescriptor
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isDebitNegativeBalances, forKey: "debit_negative_balances")
                        encoder.encode(schedule, forKey: "schedule")
                        encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                        return encoder.items
                    }
                }

                public init(branding: Branding? = nil, cardIssuing: CardIssuing? = nil, cardPayments: CardPayments? = nil, payments: Payments? = nil, payouts: Payouts? = nil) {
                    self.branding = branding
                    self.cardIssuing = cardIssuing
                    self.cardPayments = cardPayments
                    self.payments = payments
                    self.payouts = payouts
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(branding, forKey: "branding")
                    encoder.encode(cardIssuing, forKey: "card_issuing")
                    encoder.encode(cardPayments, forKey: "card_payments")
                    encoder.encode(payments, forKey: "payments")
                    encoder.encode(payouts, forKey: "payouts")
                    return encoder.items
                }
            }

            /// Tos_acceptance_specs
            ///
            /// Details on the account's acceptance of the [Stripe Services Agreement](https://stripe.com/docs/connect/updating-accounts#tos-acceptance).
            public struct TosAcceptance: Encodable {
                public var date: Int?
                public var ip: String?
                public var serviceAgreement: String?
                public var userAgent: String?

                public init(date: Int? = nil, ip: String? = nil, serviceAgreement: String? = nil, userAgent: String? = nil) {
                    self.date = date
                    self.ip = ip
                    self.serviceAgreement = serviceAgreement
                    self.userAgent = userAgent
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(date, forKey: "date")
                    encoder.encode(ip, forKey: "ip")
                    encoder.encode(serviceAgreement, forKey: "service_agreement")
                    encoder.encode(userAgent, forKey: "user_agent")
                    return encoder.items
                }
            }

            /// The type of Stripe account to create. May be one of `custom`, `express` or `standard`.
            public enum `Type`: String, Codable, CaseIterable {
                case custom
                case express
                case standard
            }

            public init(accountToken: String? = nil, bankAccount: BankAccount? = nil, businessProfile: BusinessProfile? = nil, businessType: BusinessType? = nil, capabilities: Capabilities? = nil, company: Company? = nil, country: String? = nil, defaultCurrency: String? = nil, documents: Documents? = nil, email: String? = nil, expand: [String]? = nil, externalAccount: String? = nil, individual: Individual? = nil, metadata: Metadata? = nil, settings: Settings? = nil, tosAcceptance: TosAcceptance? = nil, type: `Type`? = nil) {
                self.accountToken = accountToken
                self.bankAccount = bankAccount
                self.businessProfile = businessProfile
                self.businessType = businessType
                self.capabilities = capabilities
                self.company = company
                self.country = country
                self.defaultCurrency = defaultCurrency
                self.documents = documents
                self.email = email
                self.expand = expand
                self.externalAccount = externalAccount
                self.individual = individual
                self.metadata = metadata
                self.settings = settings
                self.tosAcceptance = tosAcceptance
                self.type = type
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(accountToken, forKey: "account_token")
                encoder.encode(bankAccount, forKey: "bank_account")
                encoder.encode(businessProfile, forKey: "business_profile")
                encoder.encode(businessType, forKey: "business_type")
                encoder.encode(capabilities, forKey: "capabilities")
                encoder.encode(company, forKey: "company")
                encoder.encode(country, forKey: "country")
                encoder.encode(defaultCurrency, forKey: "default_currency")
                encoder.encode(documents, forKey: "documents")
                encoder.encode(email, forKey: "email")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(externalAccount, forKey: "external_account")
                encoder.encode(individual, forKey: "individual")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(settings, forKey: "settings")
                encoder.encode(tosAcceptance, forKey: "tos_acceptance")
                encoder.encode(type, forKey: "type")
                return encoder.items
            }
        }
    }
}

extension Paths.Accounts {
    public func account(_ account: String) -> WithAccount {
        WithAccount(path: "\(path)/\(account)")
    }

    public struct WithAccount {
        /// Path: `/v1/accounts/{account}`
        public let path: String

        /// <p>Retrieves the details of an account.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Account> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates a <a href="/docs/connect/accounts">connected account</a> by setting the values of the parameters passed. Any parameters not provided are left unchanged. Most parameters can be changed only for Custom accounts. (These are marked <strong>Custom Only</strong> below.) Parameters marked <strong>Custom and Express</strong> are not supported for Standard accounts.</p>
        /// 
        /// <p>To update your own account, use the <a href="https://dashboard.stripe.com/account">Dashboard</a>. Refer to our <a href="/docs/connect/updating-accounts">Connect</a> documentation to learn more about updating accounts.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Account> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// An [account token](https://stripe.com/docs/api#create_account_token), used to securely provide details to the account.
            public var accountToken: String?
            /// Either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details.
            public var bankAccount: BankAccount?
            /// Business_profile_specs
            ///
            /// Business information about the account.
            public var businessProfile: BusinessProfile?
            /// The business type.
            public var businessType: BusinessType?
            /// Capabilities_param
            ///
            /// Each key of the dictionary represents a capability, and each capability maps to its settings (e.g. whether it has been requested or not). Each capability will be inactive until you have provided its specific requirements and Stripe has verified them. An account may have some of its requested capabilities be active and some be inactive.
            public var capabilities: Capabilities?
            /// Company_specs
            ///
            /// Information about the company or business. This field is available for any `business_type`.
            public var company: Company?
            /// Three-letter ISO currency code representing the default currency for the account. This must be a currency that [Stripe supports in the account's country](https://stripe.com/docs/payouts).
            public var defaultCurrency: String?
            /// Documents_specs
            ///
            /// Documents that may be submitted to satisfy various informational requests.
            public var documents: Documents?
            /// The email address of the account holder. This is only to make the account easier to identify to you. Stripe only emails Custom accounts with your consent.
            public var email: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// A card or bank account to attach to the account for receiving [payouts](https://stripe.com/docs/connect/bank-debit-card-payouts) (you won’t be able to use it for top-ups). You can provide either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary, as documented in the `external_account` parameter for [bank account](https://stripe.com/docs/api#account_create_bank_account) creation. <br><br>By default, providing an external account sets it as the new default external account for its currency, and deletes the old default if one exists. To add additional external accounts without replacing the existing default for the currency, use the bank account or card creation API.
            public var externalAccount: String?
            /// Individual_specs
            ///
            /// Information about the person represented by the account. This field is null unless `business_type` is set to `individual`.
            public var individual: Individual?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// Settings_specs_update
            ///
            /// Options for customizing how the account functions within Stripe.
            public var settings: Settings?
            /// Tos_acceptance_specs
            ///
            /// Details on the account's acceptance of the [Stripe Services Agreement](https://stripe.com/docs/connect/updating-accounts#tos-acceptance).
            public var tosAcceptance: TosAcceptance?

            /// Either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details.
            public struct BankAccount: Encodable {
                /// External_account_payout_bank_account
                public var object: Object?
                public var string: String?

                /// External_account_payout_bank_account
                public struct Object: Encodable {
                    public var accountHolderName: String?
                    public var accountHolderType: AccountHolderType?
                    public var accountNumber: String
                    public var accountType: AccountType?
                    public var country: String
                    public var currency: String?
                    public var object: Object?
                    public var routingNumber: String?

                    public enum AccountHolderType: String, Codable, CaseIterable {
                        case company
                        case individual
                    }

                    public enum AccountType: String, Codable, CaseIterable {
                        case checking
                        case futsu
                        case savings
                        case toza
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case bankAccount = "bank_account"
                    }

                    public init(accountHolderName: String? = nil, accountHolderType: AccountHolderType? = nil, accountNumber: String, accountType: AccountType? = nil, country: String, currency: String? = nil, object: Object? = nil, routingNumber: String? = nil) {
                        self.accountHolderName = accountHolderName
                        self.accountHolderType = accountHolderType
                        self.accountNumber = accountNumber
                        self.accountType = accountType
                        self.country = country
                        self.currency = currency
                        self.object = object
                        self.routingNumber = routingNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountHolderName, forKey: "account_holder_name")
                        encoder.encode(accountHolderType, forKey: "account_holder_type")
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(accountType, forKey: "account_type")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(object, forKey: "object")
                        encoder.encode(routingNumber, forKey: "routing_number")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, string: String? = nil) {
                    self.object = object
                    self.string = string
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(string, forKey: "string")
                    return encoder.items
                }
            }

            /// Business_profile_specs
            ///
            /// Business information about the account.
            public struct BusinessProfile: Encodable {
                public var mcc: String?
                public var name: String?
                public var productDescription: String?
                /// Address_specs
                public var supportAddress: SupportAddress?
                public var supportEmail: String?
                public var supportPhone: String?
                public var supportURL: SupportURL?
                public var url: String?

                /// Address_specs
                public struct SupportAddress: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                public struct SupportURL: Encodable {
                    public var string: String?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(string: String? = nil, object: Object? = nil) {
                        self.string = string
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(string, forKey: "string")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(mcc: String? = nil, name: String? = nil, productDescription: String? = nil, supportAddress: SupportAddress? = nil, supportEmail: String? = nil, supportPhone: String? = nil, supportURL: SupportURL? = nil, url: String? = nil) {
                    self.mcc = mcc
                    self.name = name
                    self.productDescription = productDescription
                    self.supportAddress = supportAddress
                    self.supportEmail = supportEmail
                    self.supportPhone = supportPhone
                    self.supportURL = supportURL
                    self.url = url
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(mcc, forKey: "mcc")
                    encoder.encode(name, forKey: "name")
                    encoder.encode(productDescription, forKey: "product_description")
                    encoder.encode(supportAddress, forKey: "support_address")
                    encoder.encode(supportEmail, forKey: "support_email")
                    encoder.encode(supportPhone, forKey: "support_phone")
                    encoder.encode(supportURL, forKey: "support_url")
                    encoder.encode(url, forKey: "url")
                    return encoder.items
                }
            }

            /// The business type.
            public enum BusinessType: String, Codable, CaseIterable {
                case company
                case governmentEntity = "government_entity"
                case individual
                case nonProfit = "non_profit"
            }

            /// Capabilities_param
            ///
            /// Each key of the dictionary represents a capability, and each capability maps to its settings (e.g. whether it has been requested or not). Each capability will be inactive until you have provided its specific requirements and Stripe has verified them. An account may have some of its requested capabilities be active and some be inactive.
            public struct Capabilities: Encodable {
                /// Capability_param
                public var acssDebitPayments: AcssDebitPayments?
                /// Capability_param
                public var afterpayClearpayPayments: AfterpayClearpayPayments?
                /// Capability_param
                public var auBecsDebitPayments: AuBecsDebitPayments?
                /// Capability_param
                public var bacsDebitPayments: BacsDebitPayments?
                /// Capability_param
                public var bancontactPayments: BancontactPayments?
                /// Capability_param
                public var boletoPayments: BoletoPayments?
                /// Capability_param
                public var cardIssuing: CardIssuing?
                /// Capability_param
                public var cardPayments: CardPayments?
                /// Capability_param
                public var cartesBancairesPayments: CartesBancairesPayments?
                /// Capability_param
                public var epsPayments: EpsPayments?
                /// Capability_param
                public var fpxPayments: FpxPayments?
                /// Capability_param
                public var giropayPayments: GiropayPayments?
                /// Capability_param
                public var grabpayPayments: GrabpayPayments?
                /// Capability_param
                public var idealPayments: IdealPayments?
                /// Capability_param
                public var jcbPayments: JcbPayments?
                /// Capability_param
                public var klarnaPayments: KlarnaPayments?
                /// Capability_param
                public var legacyPayments: LegacyPayments?
                /// Capability_param
                public var oxxoPayments: OxxoPayments?
                /// Capability_param
                public var p24Payments: P24Payments?
                /// Capability_param
                public var sepaDebitPayments: SepaDebitPayments?
                /// Capability_param
                public var sofortPayments: SofortPayments?
                /// Capability_param
                public var taxReportingUs1099K: TaxReportingUs1099K?
                /// Capability_param
                public var taxReportingUs1099Misc: TaxReportingUs1099Misc?
                /// Capability_param
                public var transfers: Transfers?

                /// Capability_param
                public struct AcssDebitPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct AfterpayClearpayPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct AuBecsDebitPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct BacsDebitPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct BancontactPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct BoletoPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct CardIssuing: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct CardPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct CartesBancairesPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct EpsPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct FpxPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct GiropayPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct GrabpayPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct IdealPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct JcbPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct KlarnaPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct LegacyPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct OxxoPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct P24Payments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct SepaDebitPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct SofortPayments: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct TaxReportingUs1099K: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct TaxReportingUs1099Misc: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                /// Capability_param
                public struct Transfers: Encodable {
                    public var isRequested: Bool?

                    public init(isRequested: Bool? = nil) {
                        self.isRequested = isRequested
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isRequested, forKey: "requested")
                        return encoder.items
                    }
                }

                public init(acssDebitPayments: AcssDebitPayments? = nil, afterpayClearpayPayments: AfterpayClearpayPayments? = nil, auBecsDebitPayments: AuBecsDebitPayments? = nil, bacsDebitPayments: BacsDebitPayments? = nil, bancontactPayments: BancontactPayments? = nil, boletoPayments: BoletoPayments? = nil, cardIssuing: CardIssuing? = nil, cardPayments: CardPayments? = nil, cartesBancairesPayments: CartesBancairesPayments? = nil, epsPayments: EpsPayments? = nil, fpxPayments: FpxPayments? = nil, giropayPayments: GiropayPayments? = nil, grabpayPayments: GrabpayPayments? = nil, idealPayments: IdealPayments? = nil, jcbPayments: JcbPayments? = nil, klarnaPayments: KlarnaPayments? = nil, legacyPayments: LegacyPayments? = nil, oxxoPayments: OxxoPayments? = nil, p24Payments: P24Payments? = nil, sepaDebitPayments: SepaDebitPayments? = nil, sofortPayments: SofortPayments? = nil, taxReportingUs1099K: TaxReportingUs1099K? = nil, taxReportingUs1099Misc: TaxReportingUs1099Misc? = nil, transfers: Transfers? = nil) {
                    self.acssDebitPayments = acssDebitPayments
                    self.afterpayClearpayPayments = afterpayClearpayPayments
                    self.auBecsDebitPayments = auBecsDebitPayments
                    self.bacsDebitPayments = bacsDebitPayments
                    self.bancontactPayments = bancontactPayments
                    self.boletoPayments = boletoPayments
                    self.cardIssuing = cardIssuing
                    self.cardPayments = cardPayments
                    self.cartesBancairesPayments = cartesBancairesPayments
                    self.epsPayments = epsPayments
                    self.fpxPayments = fpxPayments
                    self.giropayPayments = giropayPayments
                    self.grabpayPayments = grabpayPayments
                    self.idealPayments = idealPayments
                    self.jcbPayments = jcbPayments
                    self.klarnaPayments = klarnaPayments
                    self.legacyPayments = legacyPayments
                    self.oxxoPayments = oxxoPayments
                    self.p24Payments = p24Payments
                    self.sepaDebitPayments = sepaDebitPayments
                    self.sofortPayments = sofortPayments
                    self.taxReportingUs1099K = taxReportingUs1099K
                    self.taxReportingUs1099Misc = taxReportingUs1099Misc
                    self.transfers = transfers
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(acssDebitPayments, forKey: "acss_debit_payments")
                    encoder.encode(afterpayClearpayPayments, forKey: "afterpay_clearpay_payments")
                    encoder.encode(auBecsDebitPayments, forKey: "au_becs_debit_payments")
                    encoder.encode(bacsDebitPayments, forKey: "bacs_debit_payments")
                    encoder.encode(bancontactPayments, forKey: "bancontact_payments")
                    encoder.encode(boletoPayments, forKey: "boleto_payments")
                    encoder.encode(cardIssuing, forKey: "card_issuing")
                    encoder.encode(cardPayments, forKey: "card_payments")
                    encoder.encode(cartesBancairesPayments, forKey: "cartes_bancaires_payments")
                    encoder.encode(epsPayments, forKey: "eps_payments")
                    encoder.encode(fpxPayments, forKey: "fpx_payments")
                    encoder.encode(giropayPayments, forKey: "giropay_payments")
                    encoder.encode(grabpayPayments, forKey: "grabpay_payments")
                    encoder.encode(idealPayments, forKey: "ideal_payments")
                    encoder.encode(jcbPayments, forKey: "jcb_payments")
                    encoder.encode(klarnaPayments, forKey: "klarna_payments")
                    encoder.encode(legacyPayments, forKey: "legacy_payments")
                    encoder.encode(oxxoPayments, forKey: "oxxo_payments")
                    encoder.encode(p24Payments, forKey: "p24_payments")
                    encoder.encode(sepaDebitPayments, forKey: "sepa_debit_payments")
                    encoder.encode(sofortPayments, forKey: "sofort_payments")
                    encoder.encode(taxReportingUs1099K, forKey: "tax_reporting_us_1099_k")
                    encoder.encode(taxReportingUs1099Misc, forKey: "tax_reporting_us_1099_misc")
                    encoder.encode(transfers, forKey: "transfers")
                    return encoder.items
                }
            }

            /// Company_specs
            ///
            /// Information about the company or business. This field is available for any `business_type`.
            public struct Company: Encodable {
                /// Address_specs
                public var address: Address?
                /// Japan_address_kana_specs
                public var addressKana: AddressKana?
                /// Japan_address_kanji_specs
                public var addressKanji: AddressKanji?
                public var isDirectorsProvided: Bool?
                public var isExecutivesProvided: Bool?
                public var name: String?
                public var nameKana: String?
                public var nameKanji: String?
                public var isOwnersProvided: Bool?
                /// Company_ownership_declaration
                public var ownershipDeclaration: OwnershipDeclaration?
                public var phone: String?
                public var registrationNumber: String?
                public var structure: Structure?
                public var taxID: String?
                public var taxIDRegistrar: String?
                public var vatID: String?
                /// Verification_specs
                public var verification: Verification?

                /// Address_specs
                public struct Address: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                /// Japan_address_kana_specs
                public struct AddressKana: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?
                    public var town: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                        self.town = town
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        encoder.encode(town, forKey: "town")
                        return encoder.items
                    }
                }

                /// Japan_address_kanji_specs
                public struct AddressKanji: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?
                    public var town: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                        self.town = town
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        encoder.encode(town, forKey: "town")
                        return encoder.items
                    }
                }

                /// Company_ownership_declaration
                public struct OwnershipDeclaration: Encodable {
                    public var date: Int?
                    public var ip: String?
                    public var userAgent: String?

                    public init(date: Int? = nil, ip: String? = nil, userAgent: String? = nil) {
                        self.date = date
                        self.ip = ip
                        self.userAgent = userAgent
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(date, forKey: "date")
                        encoder.encode(ip, forKey: "ip")
                        encoder.encode(userAgent, forKey: "user_agent")
                        return encoder.items
                    }
                }

                public enum Structure: String, Codable, CaseIterable {
                    case empty = ""
                    case freeZoneEstablishment = "free_zone_establishment"
                    case freeZoneLlc = "free_zone_llc"
                    case governmentInstrumentality = "government_instrumentality"
                    case governmentalUnit = "governmental_unit"
                    case incorporatedNonProfit = "incorporated_non_profit"
                    case limitedLiabilityPartnership = "limited_liability_partnership"
                    case llc
                    case multiMemberLlc = "multi_member_llc"
                    case privateCompany = "private_company"
                    case privateCorporation = "private_corporation"
                    case privatePartnership = "private_partnership"
                    case publicCompany = "public_company"
                    case publicCorporation = "public_corporation"
                    case publicPartnership = "public_partnership"
                    case singleMemberLlc = "single_member_llc"
                    case soleEstablishment = "sole_establishment"
                    case soleProprietorship = "sole_proprietorship"
                    case taxExemptGovernmentInstrumentality = "tax_exempt_government_instrumentality"
                    case unincorporatedAssociation = "unincorporated_association"
                    case unincorporatedNonProfit = "unincorporated_non_profit"
                }

                /// Verification_specs
                public struct Verification: Encodable {
                    /// Verification_document_specs
                    public var document: Document?

                    /// Verification_document_specs
                    public struct Document: Encodable {
                        public var back: String?
                        public var front: String?

                        public init(back: String? = nil, front: String? = nil) {
                            self.back = back
                            self.front = front
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(back, forKey: "back")
                            encoder.encode(front, forKey: "front")
                            return encoder.items
                        }
                    }

                    public init(document: Document? = nil) {
                        self.document = document
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(document, forKey: "document")
                        return encoder.items
                    }
                }

                public init(address: Address? = nil, addressKana: AddressKana? = nil, addressKanji: AddressKanji? = nil, isDirectorsProvided: Bool? = nil, isExecutivesProvided: Bool? = nil, name: String? = nil, nameKana: String? = nil, nameKanji: String? = nil, isOwnersProvided: Bool? = nil, ownershipDeclaration: OwnershipDeclaration? = nil, phone: String? = nil, registrationNumber: String? = nil, structure: Structure? = nil, taxID: String? = nil, taxIDRegistrar: String? = nil, vatID: String? = nil, verification: Verification? = nil) {
                    self.address = address
                    self.addressKana = addressKana
                    self.addressKanji = addressKanji
                    self.isDirectorsProvided = isDirectorsProvided
                    self.isExecutivesProvided = isExecutivesProvided
                    self.name = name
                    self.nameKana = nameKana
                    self.nameKanji = nameKanji
                    self.isOwnersProvided = isOwnersProvided
                    self.ownershipDeclaration = ownershipDeclaration
                    self.phone = phone
                    self.registrationNumber = registrationNumber
                    self.structure = structure
                    self.taxID = taxID
                    self.taxIDRegistrar = taxIDRegistrar
                    self.vatID = vatID
                    self.verification = verification
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(addressKana, forKey: "address_kana")
                    encoder.encode(addressKanji, forKey: "address_kanji")
                    encoder.encode(isDirectorsProvided, forKey: "directors_provided")
                    encoder.encode(isExecutivesProvided, forKey: "executives_provided")
                    encoder.encode(name, forKey: "name")
                    encoder.encode(nameKana, forKey: "name_kana")
                    encoder.encode(nameKanji, forKey: "name_kanji")
                    encoder.encode(isOwnersProvided, forKey: "owners_provided")
                    encoder.encode(ownershipDeclaration, forKey: "ownership_declaration")
                    encoder.encode(phone, forKey: "phone")
                    encoder.encode(registrationNumber, forKey: "registration_number")
                    encoder.encode(structure, forKey: "structure")
                    encoder.encode(taxID, forKey: "tax_id")
                    encoder.encode(taxIDRegistrar, forKey: "tax_id_registrar")
                    encoder.encode(vatID, forKey: "vat_id")
                    encoder.encode(verification, forKey: "verification")
                    return encoder.items
                }
            }

            /// Documents_specs
            ///
            /// Documents that may be submitted to satisfy various informational requests.
            public struct Documents: Encodable {
                /// Documents_param
                public var bankAccountOwnershipVerification: BankAccountOwnershipVerification?
                /// Documents_param
                public var companyLicense: CompanyLicense?
                /// Documents_param
                public var companyMemorandumOfAssociation: CompanyMemorandumOfAssociation?
                /// Documents_param
                public var companyMinisterialDecree: CompanyMinisterialDecree?
                /// Documents_param
                public var companyRegistrationVerification: CompanyRegistrationVerification?
                /// Documents_param
                public var companyTaxIDVerification: CompanyTaxIDVerification?
                /// Documents_param
                public var proofOfRegistration: ProofOfRegistration?

                /// Documents_param
                public struct BankAccountOwnershipVerification: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct CompanyLicense: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct CompanyMemorandumOfAssociation: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct CompanyMinisterialDecree: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct CompanyRegistrationVerification: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct CompanyTaxIDVerification: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct ProofOfRegistration: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                public init(bankAccountOwnershipVerification: BankAccountOwnershipVerification? = nil, companyLicense: CompanyLicense? = nil, companyMemorandumOfAssociation: CompanyMemorandumOfAssociation? = nil, companyMinisterialDecree: CompanyMinisterialDecree? = nil, companyRegistrationVerification: CompanyRegistrationVerification? = nil, companyTaxIDVerification: CompanyTaxIDVerification? = nil, proofOfRegistration: ProofOfRegistration? = nil) {
                    self.bankAccountOwnershipVerification = bankAccountOwnershipVerification
                    self.companyLicense = companyLicense
                    self.companyMemorandumOfAssociation = companyMemorandumOfAssociation
                    self.companyMinisterialDecree = companyMinisterialDecree
                    self.companyRegistrationVerification = companyRegistrationVerification
                    self.companyTaxIDVerification = companyTaxIDVerification
                    self.proofOfRegistration = proofOfRegistration
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(bankAccountOwnershipVerification, forKey: "bank_account_ownership_verification")
                    encoder.encode(companyLicense, forKey: "company_license")
                    encoder.encode(companyMemorandumOfAssociation, forKey: "company_memorandum_of_association")
                    encoder.encode(companyMinisterialDecree, forKey: "company_ministerial_decree")
                    encoder.encode(companyRegistrationVerification, forKey: "company_registration_verification")
                    encoder.encode(companyTaxIDVerification, forKey: "company_tax_id_verification")
                    encoder.encode(proofOfRegistration, forKey: "proof_of_registration")
                    return encoder.items
                }
            }

            /// Individual_specs
            ///
            /// Information about the person represented by the account. This field is null unless `business_type` is set to `individual`.
            public struct Individual: Encodable {
                /// Address_specs
                public var address: Address?
                /// Japan_address_kana_specs
                public var addressKana: AddressKana?
                /// Japan_address_kanji_specs
                public var addressKanji: AddressKanji?
                public var dob: Dob?
                public var email: String?
                public var firstName: String?
                public var firstNameKana: String?
                public var firstNameKanji: String?
                public var fullNameAliases: FullNameAliases?
                public var gender: String?
                public var idNumber: String?
                public var lastName: String?
                public var lastNameKana: String?
                public var lastNameKanji: String?
                public var maidenName: String?
                public var metadata: Metadata?
                public var phone: String?
                public var politicalExposure: PoliticalExposure?
                public var ssnLast4: String?
                /// Person_verification_specs
                public var verification: Verification?

                /// Address_specs
                public struct Address: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                /// Japan_address_kana_specs
                public struct AddressKana: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?
                    public var town: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                        self.town = town
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        encoder.encode(town, forKey: "town")
                        return encoder.items
                    }
                }

                /// Japan_address_kanji_specs
                public struct AddressKanji: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?
                    public var town: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                        self.town = town
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        encoder.encode(town, forKey: "town")
                        return encoder.items
                    }
                }

                public struct Dob: Encodable {
                    /// Date_of_birth_specs
                    public var a: A?
                    public var b: B?

                    /// Date_of_birth_specs
                    public struct A: Encodable {
                        public var day: Int
                        public var month: Int
                        public var year: Int

                        public init(day: Int, month: Int, year: Int) {
                            self.day = day
                            self.month = month
                            self.year = year
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(day, forKey: "day")
                            encoder.encode(month, forKey: "month")
                            encoder.encode(year, forKey: "year")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct FullNameAliases: Encodable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public struct Metadata: Encodable {
                    public var stringString: [String: String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(stringString: [String: String]? = nil, object: Object? = nil) {
                        self.stringString = stringString
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(stringString, forKey: "stringString")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public enum PoliticalExposure: String, Codable, CaseIterable {
                    case existing
                    case `none`
                }

                /// Person_verification_specs
                public struct Verification: Encodable {
                    /// Person_verification_document_specs
                    public var additionalDocument: AdditionalDocument?
                    /// Person_verification_document_specs
                    public var document: Document?

                    /// Person_verification_document_specs
                    public struct AdditionalDocument: Encodable {
                        public var back: String?
                        public var front: String?

                        public init(back: String? = nil, front: String? = nil) {
                            self.back = back
                            self.front = front
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(back, forKey: "back")
                            encoder.encode(front, forKey: "front")
                            return encoder.items
                        }
                    }

                    /// Person_verification_document_specs
                    public struct Document: Encodable {
                        public var back: String?
                        public var front: String?

                        public init(back: String? = nil, front: String? = nil) {
                            self.back = back
                            self.front = front
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(back, forKey: "back")
                            encoder.encode(front, forKey: "front")
                            return encoder.items
                        }
                    }

                    public init(additionalDocument: AdditionalDocument? = nil, document: Document? = nil) {
                        self.additionalDocument = additionalDocument
                        self.document = document
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(additionalDocument, forKey: "additional_document")
                        encoder.encode(document, forKey: "document")
                        return encoder.items
                    }
                }

                public init(address: Address? = nil, addressKana: AddressKana? = nil, addressKanji: AddressKanji? = nil, dob: Dob? = nil, email: String? = nil, firstName: String? = nil, firstNameKana: String? = nil, firstNameKanji: String? = nil, fullNameAliases: FullNameAliases? = nil, gender: String? = nil, idNumber: String? = nil, lastName: String? = nil, lastNameKana: String? = nil, lastNameKanji: String? = nil, maidenName: String? = nil, metadata: Metadata? = nil, phone: String? = nil, politicalExposure: PoliticalExposure? = nil, ssnLast4: String? = nil, verification: Verification? = nil) {
                    self.address = address
                    self.addressKana = addressKana
                    self.addressKanji = addressKanji
                    self.dob = dob
                    self.email = email
                    self.firstName = firstName
                    self.firstNameKana = firstNameKana
                    self.firstNameKanji = firstNameKanji
                    self.fullNameAliases = fullNameAliases
                    self.gender = gender
                    self.idNumber = idNumber
                    self.lastName = lastName
                    self.lastNameKana = lastNameKana
                    self.lastNameKanji = lastNameKanji
                    self.maidenName = maidenName
                    self.metadata = metadata
                    self.phone = phone
                    self.politicalExposure = politicalExposure
                    self.ssnLast4 = ssnLast4
                    self.verification = verification
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(addressKana, forKey: "address_kana")
                    encoder.encode(addressKanji, forKey: "address_kanji")
                    encoder.encode(dob, forKey: "dob")
                    encoder.encode(email, forKey: "email")
                    encoder.encode(firstName, forKey: "first_name")
                    encoder.encode(firstNameKana, forKey: "first_name_kana")
                    encoder.encode(firstNameKanji, forKey: "first_name_kanji")
                    encoder.encode(fullNameAliases, forKey: "full_name_aliases")
                    encoder.encode(gender, forKey: "gender")
                    encoder.encode(idNumber, forKey: "id_number")
                    encoder.encode(lastName, forKey: "last_name")
                    encoder.encode(lastNameKana, forKey: "last_name_kana")
                    encoder.encode(lastNameKanji, forKey: "last_name_kanji")
                    encoder.encode(maidenName, forKey: "maiden_name")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(phone, forKey: "phone")
                    encoder.encode(politicalExposure, forKey: "political_exposure")
                    encoder.encode(ssnLast4, forKey: "ssn_last_4")
                    encoder.encode(verification, forKey: "verification")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Settings_specs_update
            ///
            /// Options for customizing how the account functions within Stripe.
            public struct Settings: Encodable {
                /// Branding_settings_specs
                public var branding: Branding?
                /// Card_issuing_settings_specs
                public var cardIssuing: CardIssuing?
                /// Card_payments_settings_specs
                public var cardPayments: CardPayments?
                /// Payments_settings_specs
                public var payments: Payments?
                /// Payout_settings_specs
                public var payouts: Payouts?

                /// Branding_settings_specs
                public struct Branding: Encodable {
                    public var icon: String?
                    public var logo: String?
                    public var primaryColor: String?
                    public var secondaryColor: String?

                    public init(icon: String? = nil, logo: String? = nil, primaryColor: String? = nil, secondaryColor: String? = nil) {
                        self.icon = icon
                        self.logo = logo
                        self.primaryColor = primaryColor
                        self.secondaryColor = secondaryColor
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(icon, forKey: "icon")
                        encoder.encode(logo, forKey: "logo")
                        encoder.encode(primaryColor, forKey: "primary_color")
                        encoder.encode(secondaryColor, forKey: "secondary_color")
                        return encoder.items
                    }
                }

                /// Card_issuing_settings_specs
                public struct CardIssuing: Encodable {
                    /// Settings_terms_of_service_specs
                    public var tosAcceptance: TosAcceptance?

                    /// Settings_terms_of_service_specs
                    public struct TosAcceptance: Encodable {
                        public var date: Int?
                        public var ip: String?
                        public var userAgent: String?

                        public init(date: Int? = nil, ip: String? = nil, userAgent: String? = nil) {
                            self.date = date
                            self.ip = ip
                            self.userAgent = userAgent
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(date, forKey: "date")
                            encoder.encode(ip, forKey: "ip")
                            encoder.encode(userAgent, forKey: "user_agent")
                            return encoder.items
                        }
                    }

                    public init(tosAcceptance: TosAcceptance? = nil) {
                        self.tosAcceptance = tosAcceptance
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(tosAcceptance, forKey: "tos_acceptance")
                        return encoder.items
                    }
                }

                /// Card_payments_settings_specs
                public struct CardPayments: Encodable {
                    /// Decline_charge_on_specs
                    public var declineOn: DeclineOn?
                    public var statementDescriptorPrefix: String?

                    /// Decline_charge_on_specs
                    public struct DeclineOn: Encodable {
                        public var isAvsFailure: Bool?
                        public var isCvcFailure: Bool?

                        public init(isAvsFailure: Bool? = nil, isCvcFailure: Bool? = nil) {
                            self.isAvsFailure = isAvsFailure
                            self.isCvcFailure = isCvcFailure
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(isAvsFailure, forKey: "avs_failure")
                            encoder.encode(isCvcFailure, forKey: "cvc_failure")
                            return encoder.items
                        }
                    }

                    public init(declineOn: DeclineOn? = nil, statementDescriptorPrefix: String? = nil) {
                        self.declineOn = declineOn
                        self.statementDescriptorPrefix = statementDescriptorPrefix
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(declineOn, forKey: "decline_on")
                        encoder.encode(statementDescriptorPrefix, forKey: "statement_descriptor_prefix")
                        return encoder.items
                    }
                }

                /// Payments_settings_specs
                public struct Payments: Encodable {
                    public var statementDescriptor: String?
                    public var statementDescriptorKana: String?
                    public var statementDescriptorKanji: String?

                    public init(statementDescriptor: String? = nil, statementDescriptorKana: String? = nil, statementDescriptorKanji: String? = nil) {
                        self.statementDescriptor = statementDescriptor
                        self.statementDescriptorKana = statementDescriptorKana
                        self.statementDescriptorKanji = statementDescriptorKanji
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                        encoder.encode(statementDescriptorKana, forKey: "statement_descriptor_kana")
                        encoder.encode(statementDescriptorKanji, forKey: "statement_descriptor_kanji")
                        return encoder.items
                    }
                }

                /// Payout_settings_specs
                public struct Payouts: Encodable {
                    public var isDebitNegativeBalances: Bool?
                    /// Transfer_schedule_specs
                    public var schedule: Schedule?
                    public var statementDescriptor: String?

                    /// Transfer_schedule_specs
                    public struct Schedule: Encodable {
                        public var delayDays: DelayDays?
                        public var interval: Interval?
                        public var monthlyAnchor: Int?
                        public var weeklyAnchor: WeeklyAnchor?

                        public struct DelayDays: Encodable {
                            public var object: Object?
                            public var int: Int?

                            public enum Object: String, Codable, CaseIterable {
                                case minimum
                            }

                            public init(object: Object? = nil, int: Int? = nil) {
                                self.object = object
                                self.int = int
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(object, forKey: "object")
                                encoder.encode(int, forKey: "int")
                                return encoder.items
                            }
                        }

                        public enum Interval: String, Codable, CaseIterable {
                            case daily
                            case manual
                            case monthly
                            case weekly
                        }

                        public enum WeeklyAnchor: String, Codable, CaseIterable {
                            case friday
                            case monday
                            case saturday
                            case sunday
                            case thursday
                            case tuesday
                            case wednesday
                        }

                        public init(delayDays: DelayDays? = nil, interval: Interval? = nil, monthlyAnchor: Int? = nil, weeklyAnchor: WeeklyAnchor? = nil) {
                            self.delayDays = delayDays
                            self.interval = interval
                            self.monthlyAnchor = monthlyAnchor
                            self.weeklyAnchor = weeklyAnchor
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(delayDays, forKey: "delay_days")
                            encoder.encode(interval, forKey: "interval")
                            encoder.encode(monthlyAnchor, forKey: "monthly_anchor")
                            encoder.encode(weeklyAnchor, forKey: "weekly_anchor")
                            return encoder.items
                        }
                    }

                    public init(isDebitNegativeBalances: Bool? = nil, schedule: Schedule? = nil, statementDescriptor: String? = nil) {
                        self.isDebitNegativeBalances = isDebitNegativeBalances
                        self.schedule = schedule
                        self.statementDescriptor = statementDescriptor
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isDebitNegativeBalances, forKey: "debit_negative_balances")
                        encoder.encode(schedule, forKey: "schedule")
                        encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                        return encoder.items
                    }
                }

                public init(branding: Branding? = nil, cardIssuing: CardIssuing? = nil, cardPayments: CardPayments? = nil, payments: Payments? = nil, payouts: Payouts? = nil) {
                    self.branding = branding
                    self.cardIssuing = cardIssuing
                    self.cardPayments = cardPayments
                    self.payments = payments
                    self.payouts = payouts
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(branding, forKey: "branding")
                    encoder.encode(cardIssuing, forKey: "card_issuing")
                    encoder.encode(cardPayments, forKey: "card_payments")
                    encoder.encode(payments, forKey: "payments")
                    encoder.encode(payouts, forKey: "payouts")
                    return encoder.items
                }
            }

            /// Tos_acceptance_specs
            ///
            /// Details on the account's acceptance of the [Stripe Services Agreement](https://stripe.com/docs/connect/updating-accounts#tos-acceptance).
            public struct TosAcceptance: Encodable {
                public var date: Int?
                public var ip: String?
                public var serviceAgreement: String?
                public var userAgent: String?

                public init(date: Int? = nil, ip: String? = nil, serviceAgreement: String? = nil, userAgent: String? = nil) {
                    self.date = date
                    self.ip = ip
                    self.serviceAgreement = serviceAgreement
                    self.userAgent = userAgent
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(date, forKey: "date")
                    encoder.encode(ip, forKey: "ip")
                    encoder.encode(serviceAgreement, forKey: "service_agreement")
                    encoder.encode(userAgent, forKey: "user_agent")
                    return encoder.items
                }
            }

            public init(accountToken: String? = nil, bankAccount: BankAccount? = nil, businessProfile: BusinessProfile? = nil, businessType: BusinessType? = nil, capabilities: Capabilities? = nil, company: Company? = nil, defaultCurrency: String? = nil, documents: Documents? = nil, email: String? = nil, expand: [String]? = nil, externalAccount: String? = nil, individual: Individual? = nil, metadata: Metadata? = nil, settings: Settings? = nil, tosAcceptance: TosAcceptance? = nil) {
                self.accountToken = accountToken
                self.bankAccount = bankAccount
                self.businessProfile = businessProfile
                self.businessType = businessType
                self.capabilities = capabilities
                self.company = company
                self.defaultCurrency = defaultCurrency
                self.documents = documents
                self.email = email
                self.expand = expand
                self.externalAccount = externalAccount
                self.individual = individual
                self.metadata = metadata
                self.settings = settings
                self.tosAcceptance = tosAcceptance
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(accountToken, forKey: "account_token")
                encoder.encode(bankAccount, forKey: "bank_account")
                encoder.encode(businessProfile, forKey: "business_profile")
                encoder.encode(businessType, forKey: "business_type")
                encoder.encode(capabilities, forKey: "capabilities")
                encoder.encode(company, forKey: "company")
                encoder.encode(defaultCurrency, forKey: "default_currency")
                encoder.encode(documents, forKey: "documents")
                encoder.encode(email, forKey: "email")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(externalAccount, forKey: "external_account")
                encoder.encode(individual, forKey: "individual")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(settings, forKey: "settings")
                encoder.encode(tosAcceptance, forKey: "tos_acceptance")
                return encoder.items
            }
        }

        /// <p>With <a href="/docs/connect">Connect</a>, you can delete accounts you manage.</p>
        /// 
        /// <p>Accounts created using test-mode keys can be deleted at any time. Custom or Express accounts created using live-mode keys can only be deleted once all balances are zero.</p>
        /// 
        /// <p>If you want to delete your own account, use the <a href="https://dashboard.stripe.com/account">account information tab in your account settings</a> instead.</p>
        public var delete: Request<StripeAPI.DeletedAccount> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccount {
    public var bankAccounts: BankAccounts {
        BankAccounts(path: path + "/bank_accounts")
    }

    public struct BankAccounts {
        /// Path: `/v1/accounts/{account}/bank_accounts`
        public let path: String

        /// <p>Create an external account for a given account.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.ExternalAccount> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details.
            public var bankAccount: BankAccount?
            /// When set to true, or if this is the first external account added in this currency, this account becomes the default external account for its currency.
            public var isDefaultForCurrency: Bool?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Please refer to full [documentation](https://stripe.com/docs/api) instead.
            public var externalAccount: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?

            /// Either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details.
            public struct BankAccount: Encodable {
                /// External_account_payout_bank_account
                public var object: Object?
                public var string: String?

                /// External_account_payout_bank_account
                public struct Object: Encodable {
                    public var accountHolderName: String?
                    public var accountHolderType: AccountHolderType?
                    public var accountNumber: String
                    public var accountType: AccountType?
                    public var country: String
                    public var currency: String?
                    public var object: Object?
                    public var routingNumber: String?

                    public enum AccountHolderType: String, Codable, CaseIterable {
                        case company
                        case individual
                    }

                    public enum AccountType: String, Codable, CaseIterable {
                        case checking
                        case futsu
                        case savings
                        case toza
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case bankAccount = "bank_account"
                    }

                    public init(accountHolderName: String? = nil, accountHolderType: AccountHolderType? = nil, accountNumber: String, accountType: AccountType? = nil, country: String, currency: String? = nil, object: Object? = nil, routingNumber: String? = nil) {
                        self.accountHolderName = accountHolderName
                        self.accountHolderType = accountHolderType
                        self.accountNumber = accountNumber
                        self.accountType = accountType
                        self.country = country
                        self.currency = currency
                        self.object = object
                        self.routingNumber = routingNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountHolderName, forKey: "account_holder_name")
                        encoder.encode(accountHolderType, forKey: "account_holder_type")
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(accountType, forKey: "account_type")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(object, forKey: "object")
                        encoder.encode(routingNumber, forKey: "routing_number")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, string: String? = nil) {
                    self.object = object
                    self.string = string
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(string, forKey: "string")
                    return encoder.items
                }
            }

            public init(bankAccount: BankAccount? = nil, isDefaultForCurrency: Bool? = nil, expand: [String]? = nil, externalAccount: String? = nil, metadata: [String: String]? = nil) {
                self.bankAccount = bankAccount
                self.isDefaultForCurrency = isDefaultForCurrency
                self.expand = expand
                self.externalAccount = externalAccount
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(bankAccount, forKey: "bank_account")
                encoder.encode(isDefaultForCurrency, forKey: "default_for_currency")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(externalAccount, forKey: "external_account")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths.Accounts.WithAccount.BankAccounts {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/accounts/{account}/bank_accounts/{id}`
        public let path: String

        /// <p>Retrieve a specified external account for a given account.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.ExternalAccount> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the metadata, account holder name, account holder type of a bank account belonging to a <a href="/docs/connect/custom-accounts">Custom account</a>, and optionally sets it as the default for its currency. Other bank account details are not editable by design.</p>
        /// 
        /// <p>You can re-enable a disabled bank account by performing an update call without providing any arguments or changes.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.ExternalAccount> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The name of the person or business that owns the bank account.
            public var accountHolderName: String?
            /// The type of entity that holds the account. This can be either `individual` or `company`.
            public var accountHolderType: AccountHolderType?
            /// The bank account type. This can only be `checking` or `savings` in most countries. In Japan, this can only be `futsu` or `toza`.
            public var accountType: AccountType?
            /// City/District/Suburb/Town/Village.
            public var addressCity: String?
            /// Billing address country, if provided when creating card.
            public var addressCountry: String?
            /// Address line 1 (Street address/PO Box/Company name).
            public var addressLine1: String?
            /// Address line 2 (Apartment/Suite/Unit/Building).
            public var addressLine2: String?
            /// State/County/Province/Region.
            public var addressState: String?
            /// ZIP or postal code.
            public var addressZip: String?
            /// When set to true, this becomes the default external account for its currency.
            public var isDefaultForCurrency: Bool?
            /// Two digit number representing the card’s expiration month.
            public var expMonth: String?
            /// Four digit number representing the card’s expiration year.
            public var expYear: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// Cardholder name.
            public var name: String?

            /// The type of entity that holds the account. This can be either `individual` or `company`.
            public enum AccountHolderType: String, Codable, CaseIterable {
                case empty = ""
                case company
                case individual
            }

            /// The bank account type. This can only be `checking` or `savings` in most countries. In Japan, this can only be `futsu` or `toza`.
            public enum AccountType: String, Codable, CaseIterable {
                case checking
                case futsu
                case savings
                case toza
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(accountHolderName: String? = nil, accountHolderType: AccountHolderType? = nil, accountType: AccountType? = nil, addressCity: String? = nil, addressCountry: String? = nil, addressLine1: String? = nil, addressLine2: String? = nil, addressState: String? = nil, addressZip: String? = nil, isDefaultForCurrency: Bool? = nil, expMonth: String? = nil, expYear: String? = nil, expand: [String]? = nil, metadata: Metadata? = nil, name: String? = nil) {
                self.accountHolderName = accountHolderName
                self.accountHolderType = accountHolderType
                self.accountType = accountType
                self.addressCity = addressCity
                self.addressCountry = addressCountry
                self.addressLine1 = addressLine1
                self.addressLine2 = addressLine2
                self.addressState = addressState
                self.addressZip = addressZip
                self.isDefaultForCurrency = isDefaultForCurrency
                self.expMonth = expMonth
                self.expYear = expYear
                self.expand = expand
                self.metadata = metadata
                self.name = name
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(accountHolderName, forKey: "account_holder_name")
                encoder.encode(accountHolderType, forKey: "account_holder_type")
                encoder.encode(accountType, forKey: "account_type")
                encoder.encode(addressCity, forKey: "address_city")
                encoder.encode(addressCountry, forKey: "address_country")
                encoder.encode(addressLine1, forKey: "address_line1")
                encoder.encode(addressLine2, forKey: "address_line2")
                encoder.encode(addressState, forKey: "address_state")
                encoder.encode(addressZip, forKey: "address_zip")
                encoder.encode(isDefaultForCurrency, forKey: "default_for_currency")
                encoder.encode(expMonth, forKey: "exp_month")
                encoder.encode(expYear, forKey: "exp_year")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(name, forKey: "name")
                return encoder.items
            }
        }

        /// <p>Delete a specified external account for a given account.</p>
        public var delete: Request<StripeAPI.DeletedExternalAccount> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccount {
    public var capabilities: Capabilities {
        Capabilities(path: path + "/capabilities")
    }

    public struct Capabilities {
        /// Path: `/v1/accounts/{account}/capabilities`
        public let path: String

        /// <p>Returns a list of capabilities associated with the account. The capabilities are returned sorted by creation date, with the most recent capability appearing first.</p>
        public func get(expand: [String]? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        /// ListAccountCapability
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Capability]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Capability], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths.Accounts.WithAccount.Capabilities {
    public func capability(_ capability: String) -> WithCapability {
        WithCapability(path: "\(path)/\(capability)")
    }

    public struct WithCapability {
        /// Path: `/v1/accounts/{account}/capabilities/{capability}`
        public let path: String

        /// <p>Retrieves information about the specified Account Capability.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Capability> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates an existing Account Capability.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Capability> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Passing true requests the capability for the account, if it is not already requested. A requested capability may not immediately become active. Any requirements to activate the capability are returned in the `requirements` arrays.
            public var isRequested: Bool?

            public init(expand: [String]? = nil, isRequested: Bool? = nil) {
                self.expand = expand
                self.isRequested = isRequested
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(isRequested, forKey: "requested")
                return encoder.items
            }
        }
    }
}

extension Paths.Accounts.WithAccount {
    public var externalAccounts: ExternalAccounts {
        ExternalAccounts(path: path + "/external_accounts")
    }

    public struct ExternalAccounts {
        /// Path: `/v1/accounts/{account}/external_accounts`
        public let path: String

        /// <p>List external accounts for an account.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// ExternalAccountList
        public struct GetResponse: Decodable {
            /// The list contains all external accounts that have been attached to the Stripe account. These may be bank accounts or cards.
            public var data: [Datum]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// Polymorphic
            public struct Datum: Decodable {
                public var bankAccount: StripeAPI.BankAccount?
                public var card: StripeAPI.Card?

                public init(bankAccount: StripeAPI.BankAccount? = nil, card: StripeAPI.Card? = nil) {
                    self.bankAccount = bankAccount
                    self.card = card
                }

                public init(from decoder: Decoder) throws {
                    let container = try decoder.singleValueContainer()
                    self.bankAccount = try? container.decode(StripeAPI.BankAccount.self)
                    self.card = try? container.decode(StripeAPI.Card.self)
                }
            }

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [Datum], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Create an external account for a given account.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.ExternalAccount> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details.
            public var bankAccount: BankAccount?
            /// When set to true, or if this is the first external account added in this currency, this account becomes the default external account for its currency.
            public var isDefaultForCurrency: Bool?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Please refer to full [documentation](https://stripe.com/docs/api) instead.
            public var externalAccount: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?

            /// Either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details.
            public struct BankAccount: Encodable {
                /// External_account_payout_bank_account
                public var object: Object?
                public var string: String?

                /// External_account_payout_bank_account
                public struct Object: Encodable {
                    public var accountHolderName: String?
                    public var accountHolderType: AccountHolderType?
                    public var accountNumber: String
                    public var accountType: AccountType?
                    public var country: String
                    public var currency: String?
                    public var object: Object?
                    public var routingNumber: String?

                    public enum AccountHolderType: String, Codable, CaseIterable {
                        case company
                        case individual
                    }

                    public enum AccountType: String, Codable, CaseIterable {
                        case checking
                        case futsu
                        case savings
                        case toza
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case bankAccount = "bank_account"
                    }

                    public init(accountHolderName: String? = nil, accountHolderType: AccountHolderType? = nil, accountNumber: String, accountType: AccountType? = nil, country: String, currency: String? = nil, object: Object? = nil, routingNumber: String? = nil) {
                        self.accountHolderName = accountHolderName
                        self.accountHolderType = accountHolderType
                        self.accountNumber = accountNumber
                        self.accountType = accountType
                        self.country = country
                        self.currency = currency
                        self.object = object
                        self.routingNumber = routingNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountHolderName, forKey: "account_holder_name")
                        encoder.encode(accountHolderType, forKey: "account_holder_type")
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(accountType, forKey: "account_type")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(object, forKey: "object")
                        encoder.encode(routingNumber, forKey: "routing_number")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, string: String? = nil) {
                    self.object = object
                    self.string = string
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(string, forKey: "string")
                    return encoder.items
                }
            }

            public init(bankAccount: BankAccount? = nil, isDefaultForCurrency: Bool? = nil, expand: [String]? = nil, externalAccount: String? = nil, metadata: [String: String]? = nil) {
                self.bankAccount = bankAccount
                self.isDefaultForCurrency = isDefaultForCurrency
                self.expand = expand
                self.externalAccount = externalAccount
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(bankAccount, forKey: "bank_account")
                encoder.encode(isDefaultForCurrency, forKey: "default_for_currency")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(externalAccount, forKey: "external_account")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths.Accounts.WithAccount.ExternalAccounts {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/accounts/{account}/external_accounts/{id}`
        public let path: String

        /// <p>Retrieve a specified external account for a given account.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.ExternalAccount> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the metadata, account holder name, account holder type of a bank account belonging to a <a href="/docs/connect/custom-accounts">Custom account</a>, and optionally sets it as the default for its currency. Other bank account details are not editable by design.</p>
        /// 
        /// <p>You can re-enable a disabled bank account by performing an update call without providing any arguments or changes.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.ExternalAccount> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The name of the person or business that owns the bank account.
            public var accountHolderName: String?
            /// The type of entity that holds the account. This can be either `individual` or `company`.
            public var accountHolderType: AccountHolderType?
            /// The bank account type. This can only be `checking` or `savings` in most countries. In Japan, this can only be `futsu` or `toza`.
            public var accountType: AccountType?
            /// City/District/Suburb/Town/Village.
            public var addressCity: String?
            /// Billing address country, if provided when creating card.
            public var addressCountry: String?
            /// Address line 1 (Street address/PO Box/Company name).
            public var addressLine1: String?
            /// Address line 2 (Apartment/Suite/Unit/Building).
            public var addressLine2: String?
            /// State/County/Province/Region.
            public var addressState: String?
            /// ZIP or postal code.
            public var addressZip: String?
            /// When set to true, this becomes the default external account for its currency.
            public var isDefaultForCurrency: Bool?
            /// Two digit number representing the card’s expiration month.
            public var expMonth: String?
            /// Four digit number representing the card’s expiration year.
            public var expYear: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// Cardholder name.
            public var name: String?

            /// The type of entity that holds the account. This can be either `individual` or `company`.
            public enum AccountHolderType: String, Codable, CaseIterable {
                case empty = ""
                case company
                case individual
            }

            /// The bank account type. This can only be `checking` or `savings` in most countries. In Japan, this can only be `futsu` or `toza`.
            public enum AccountType: String, Codable, CaseIterable {
                case checking
                case futsu
                case savings
                case toza
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(accountHolderName: String? = nil, accountHolderType: AccountHolderType? = nil, accountType: AccountType? = nil, addressCity: String? = nil, addressCountry: String? = nil, addressLine1: String? = nil, addressLine2: String? = nil, addressState: String? = nil, addressZip: String? = nil, isDefaultForCurrency: Bool? = nil, expMonth: String? = nil, expYear: String? = nil, expand: [String]? = nil, metadata: Metadata? = nil, name: String? = nil) {
                self.accountHolderName = accountHolderName
                self.accountHolderType = accountHolderType
                self.accountType = accountType
                self.addressCity = addressCity
                self.addressCountry = addressCountry
                self.addressLine1 = addressLine1
                self.addressLine2 = addressLine2
                self.addressState = addressState
                self.addressZip = addressZip
                self.isDefaultForCurrency = isDefaultForCurrency
                self.expMonth = expMonth
                self.expYear = expYear
                self.expand = expand
                self.metadata = metadata
                self.name = name
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(accountHolderName, forKey: "account_holder_name")
                encoder.encode(accountHolderType, forKey: "account_holder_type")
                encoder.encode(accountType, forKey: "account_type")
                encoder.encode(addressCity, forKey: "address_city")
                encoder.encode(addressCountry, forKey: "address_country")
                encoder.encode(addressLine1, forKey: "address_line1")
                encoder.encode(addressLine2, forKey: "address_line2")
                encoder.encode(addressState, forKey: "address_state")
                encoder.encode(addressZip, forKey: "address_zip")
                encoder.encode(isDefaultForCurrency, forKey: "default_for_currency")
                encoder.encode(expMonth, forKey: "exp_month")
                encoder.encode(expYear, forKey: "exp_year")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(name, forKey: "name")
                return encoder.items
            }
        }

        /// <p>Delete a specified external account for a given account.</p>
        public var delete: Request<StripeAPI.DeletedExternalAccount> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccount {
    public var loginLinks: LoginLinks {
        LoginLinks(path: path + "/login_links")
    }

    public struct LoginLinks {
        /// Path: `/v1/accounts/{account}/login_links`
        public let path: String

        /// <p>Creates a single-use login link for an Express account to access their Stripe dashboard.</p>
        /// 
        /// <p><strong>You may only create login links for <a href="/docs/connect/express-accounts">Express accounts</a> connected to your platform</strong>.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.LoginLink> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Where to redirect the user after they log out of their dashboard.
            public var redirectURL: String?

            public init(expand: [String]? = nil, redirectURL: String? = nil) {
                self.expand = expand
                self.redirectURL = redirectURL
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(redirectURL, forKey: "redirect_url")
                return encoder.items
            }
        }
    }
}

extension Paths.Accounts.WithAccount {
    public var people: People {
        People(path: path + "/people")
    }

    public struct People {
        /// Path: `/v1/accounts/{account}/people`
        public let path: String

        /// <p>Returns a list of people associated with the account’s legal entity. The people are returned sorted by creation date, with the most recent people appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Person]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Person], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            /// All_people_relationship_specs
            public var relationship: Relationship?
            public var startingAfter: String?

            /// All_people_relationship_specs
            public struct Relationship: Codable {
                public var isDirector: Bool?
                public var isExecutive: Bool?
                public var isOwner: Bool?
                public var isRepresentative: Bool?

                public init(isDirector: Bool? = nil, isExecutive: Bool? = nil, isOwner: Bool? = nil, isRepresentative: Bool? = nil) {
                    self.isDirector = isDirector
                    self.isExecutive = isExecutive
                    self.isOwner = isOwner
                    self.isRepresentative = isRepresentative
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isDirector, forKey: "director")
                    encoder.encode(isExecutive, forKey: "executive")
                    encoder.encode(isOwner, forKey: "owner")
                    encoder.encode(isRepresentative, forKey: "representative")
                    return encoder.items
                }
            }

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, relationship: Relationship? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.relationship = relationship
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(relationship, forKey: "relationship", isDeepObject: true)
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates a new person.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Person> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Address_specs
            ///
            /// The person's address.
            public var address: Address?
            /// Japan_address_kana_specs
            ///
            /// The Kana variation of the person's address (Japan only).
            public var addressKana: AddressKana?
            /// Japan_address_kanji_specs
            ///
            /// The Kanji variation of the person's address (Japan only).
            public var addressKanji: AddressKanji?
            /// The person's date of birth.
            public var dob: Dob?
            /// Person_documents_specs
            ///
            /// Documents that may be submitted to satisfy various informational requests.
            public var documents: Documents?
            /// The person's email address.
            public var email: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The person's first name.
            public var firstName: String?
            /// The Kana variation of the person's first name (Japan only).
            public var firstNameKana: String?
            /// The Kanji variation of the person's first name (Japan only).
            public var firstNameKanji: String?
            /// A list of alternate names or aliases that the person is known by.
            public var fullNameAliases: FullNameAliases?
            /// The person's gender (International regulations require either "male" or "female").
            public var gender: String?
            /// The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
            public var idNumber: String?
            /// The person's last name.
            public var lastName: String?
            /// The Kana variation of the person's last name (Japan only).
            public var lastNameKana: String?
            /// The Kanji variation of the person's last name (Japan only).
            public var lastNameKanji: String?
            /// The person's maiden name.
            public var maidenName: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or "XX" if unavailable.
            public var nationality: String?
            /// A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
            public var personToken: String?
            /// The person's phone number.
            public var phone: String?
            /// Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
            public var politicalExposure: String?
            /// Relationship_specs
            ///
            /// The relationship that this person has with the account's legal entity.
            public var relationship: Relationship?
            /// The last four digits of the person's Social Security number (U.S. only).
            public var ssnLast4: String?
            /// Person_verification_specs
            ///
            /// The person's verification status.
            public var verification: Verification?

            /// Address_specs
            ///
            /// The person's address.
            public struct Address: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    return encoder.items
                }
            }

            /// Japan_address_kana_specs
            ///
            /// The Kana variation of the person's address (Japan only).
            public struct AddressKana: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?
                public var town: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                    self.town = town
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    encoder.encode(town, forKey: "town")
                    return encoder.items
                }
            }

            /// Japan_address_kanji_specs
            ///
            /// The Kanji variation of the person's address (Japan only).
            public struct AddressKanji: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?
                public var town: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                    self.town = town
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    encoder.encode(town, forKey: "town")
                    return encoder.items
                }
            }

            /// The person's date of birth.
            public struct Dob: Encodable {
                /// Date_of_birth_specs
                public var a: A?
                public var b: B?

                /// Date_of_birth_specs
                public struct A: Encodable {
                    public var day: Int
                    public var month: Int
                    public var year: Int

                    public init(day: Int, month: Int, year: Int) {
                        self.day = day
                        self.month = month
                        self.year = year
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(day, forKey: "day")
                        encoder.encode(month, forKey: "month")
                        encoder.encode(year, forKey: "year")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Person_documents_specs
            ///
            /// Documents that may be submitted to satisfy various informational requests.
            public struct Documents: Encodable {
                /// Documents_param
                public var companyAuthorization: CompanyAuthorization?
                /// Documents_param
                public var passport: Passport?
                /// Documents_param
                public var visa: Visa?

                /// Documents_param
                public struct CompanyAuthorization: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct Passport: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct Visa: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                public init(companyAuthorization: CompanyAuthorization? = nil, passport: Passport? = nil, visa: Visa? = nil) {
                    self.companyAuthorization = companyAuthorization
                    self.passport = passport
                    self.visa = visa
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(companyAuthorization, forKey: "company_authorization")
                    encoder.encode(passport, forKey: "passport")
                    encoder.encode(visa, forKey: "visa")
                    return encoder.items
                }
            }

            /// A list of alternate names or aliases that the person is known by.
            public struct FullNameAliases: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Relationship_specs
            ///
            /// The relationship that this person has with the account's legal entity.
            public struct Relationship: Encodable {
                public var isDirector: Bool?
                public var isExecutive: Bool?
                public var isOwner: Bool?
                public var percentOwnership: PercentOwnership?
                public var isRepresentative: Bool?
                public var title: String?

                public struct PercentOwnership: Encodable {
                    public var double: Double?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(double: Double? = nil, object: Object? = nil) {
                        self.double = double
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(double, forKey: "double")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(isDirector: Bool? = nil, isExecutive: Bool? = nil, isOwner: Bool? = nil, percentOwnership: PercentOwnership? = nil, isRepresentative: Bool? = nil, title: String? = nil) {
                    self.isDirector = isDirector
                    self.isExecutive = isExecutive
                    self.isOwner = isOwner
                    self.percentOwnership = percentOwnership
                    self.isRepresentative = isRepresentative
                    self.title = title
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isDirector, forKey: "director")
                    encoder.encode(isExecutive, forKey: "executive")
                    encoder.encode(isOwner, forKey: "owner")
                    encoder.encode(percentOwnership, forKey: "percent_ownership")
                    encoder.encode(isRepresentative, forKey: "representative")
                    encoder.encode(title, forKey: "title")
                    return encoder.items
                }
            }

            /// Person_verification_specs
            ///
            /// The person's verification status.
            public struct Verification: Encodable {
                /// Person_verification_document_specs
                public var additionalDocument: AdditionalDocument?
                /// Person_verification_document_specs
                public var document: Document?

                /// Person_verification_document_specs
                public struct AdditionalDocument: Encodable {
                    public var back: String?
                    public var front: String?

                    public init(back: String? = nil, front: String? = nil) {
                        self.back = back
                        self.front = front
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(back, forKey: "back")
                        encoder.encode(front, forKey: "front")
                        return encoder.items
                    }
                }

                /// Person_verification_document_specs
                public struct Document: Encodable {
                    public var back: String?
                    public var front: String?

                    public init(back: String? = nil, front: String? = nil) {
                        self.back = back
                        self.front = front
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(back, forKey: "back")
                        encoder.encode(front, forKey: "front")
                        return encoder.items
                    }
                }

                public init(additionalDocument: AdditionalDocument? = nil, document: Document? = nil) {
                    self.additionalDocument = additionalDocument
                    self.document = document
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(additionalDocument, forKey: "additional_document")
                    encoder.encode(document, forKey: "document")
                    return encoder.items
                }
            }

            public init(address: Address? = nil, addressKana: AddressKana? = nil, addressKanji: AddressKanji? = nil, dob: Dob? = nil, documents: Documents? = nil, email: String? = nil, expand: [String]? = nil, firstName: String? = nil, firstNameKana: String? = nil, firstNameKanji: String? = nil, fullNameAliases: FullNameAliases? = nil, gender: String? = nil, idNumber: String? = nil, lastName: String? = nil, lastNameKana: String? = nil, lastNameKanji: String? = nil, maidenName: String? = nil, metadata: Metadata? = nil, nationality: String? = nil, personToken: String? = nil, phone: String? = nil, politicalExposure: String? = nil, relationship: Relationship? = nil, ssnLast4: String? = nil, verification: Verification? = nil) {
                self.address = address
                self.addressKana = addressKana
                self.addressKanji = addressKanji
                self.dob = dob
                self.documents = documents
                self.email = email
                self.expand = expand
                self.firstName = firstName
                self.firstNameKana = firstNameKana
                self.firstNameKanji = firstNameKanji
                self.fullNameAliases = fullNameAliases
                self.gender = gender
                self.idNumber = idNumber
                self.lastName = lastName
                self.lastNameKana = lastNameKana
                self.lastNameKanji = lastNameKanji
                self.maidenName = maidenName
                self.metadata = metadata
                self.nationality = nationality
                self.personToken = personToken
                self.phone = phone
                self.politicalExposure = politicalExposure
                self.relationship = relationship
                self.ssnLast4 = ssnLast4
                self.verification = verification
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(address, forKey: "address")
                encoder.encode(addressKana, forKey: "address_kana")
                encoder.encode(addressKanji, forKey: "address_kanji")
                encoder.encode(dob, forKey: "dob")
                encoder.encode(documents, forKey: "documents")
                encoder.encode(email, forKey: "email")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(firstName, forKey: "first_name")
                encoder.encode(firstNameKana, forKey: "first_name_kana")
                encoder.encode(firstNameKanji, forKey: "first_name_kanji")
                encoder.encode(fullNameAliases, forKey: "full_name_aliases")
                encoder.encode(gender, forKey: "gender")
                encoder.encode(idNumber, forKey: "id_number")
                encoder.encode(lastName, forKey: "last_name")
                encoder.encode(lastNameKana, forKey: "last_name_kana")
                encoder.encode(lastNameKanji, forKey: "last_name_kanji")
                encoder.encode(maidenName, forKey: "maiden_name")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(nationality, forKey: "nationality")
                encoder.encode(personToken, forKey: "person_token")
                encoder.encode(phone, forKey: "phone")
                encoder.encode(politicalExposure, forKey: "political_exposure")
                encoder.encode(relationship, forKey: "relationship")
                encoder.encode(ssnLast4, forKey: "ssn_last_4")
                encoder.encode(verification, forKey: "verification")
                return encoder.items
            }
        }
    }
}

extension Paths.Accounts.WithAccount.People {
    public func person(_ person: String) -> WithPerson {
        WithPerson(path: "\(path)/\(person)")
    }

    public struct WithPerson {
        /// Path: `/v1/accounts/{account}/people/{person}`
        public let path: String

        /// <p>Retrieves an existing person.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Person> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates an existing person.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Person> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Address_specs
            ///
            /// The person's address.
            public var address: Address?
            /// Japan_address_kana_specs
            ///
            /// The Kana variation of the person's address (Japan only).
            public var addressKana: AddressKana?
            /// Japan_address_kanji_specs
            ///
            /// The Kanji variation of the person's address (Japan only).
            public var addressKanji: AddressKanji?
            /// The person's date of birth.
            public var dob: Dob?
            /// Person_documents_specs
            ///
            /// Documents that may be submitted to satisfy various informational requests.
            public var documents: Documents?
            /// The person's email address.
            public var email: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The person's first name.
            public var firstName: String?
            /// The Kana variation of the person's first name (Japan only).
            public var firstNameKana: String?
            /// The Kanji variation of the person's first name (Japan only).
            public var firstNameKanji: String?
            /// A list of alternate names or aliases that the person is known by.
            public var fullNameAliases: FullNameAliases?
            /// The person's gender (International regulations require either "male" or "female").
            public var gender: String?
            /// The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
            public var idNumber: String?
            /// The person's last name.
            public var lastName: String?
            /// The Kana variation of the person's last name (Japan only).
            public var lastNameKana: String?
            /// The Kanji variation of the person's last name (Japan only).
            public var lastNameKanji: String?
            /// The person's maiden name.
            public var maidenName: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or "XX" if unavailable.
            public var nationality: String?
            /// A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
            public var personToken: String?
            /// The person's phone number.
            public var phone: String?
            /// Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
            public var politicalExposure: String?
            /// Relationship_specs
            ///
            /// The relationship that this person has with the account's legal entity.
            public var relationship: Relationship?
            /// The last four digits of the person's Social Security number (U.S. only).
            public var ssnLast4: String?
            /// Person_verification_specs
            ///
            /// The person's verification status.
            public var verification: Verification?

            /// Address_specs
            ///
            /// The person's address.
            public struct Address: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    return encoder.items
                }
            }

            /// Japan_address_kana_specs
            ///
            /// The Kana variation of the person's address (Japan only).
            public struct AddressKana: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?
                public var town: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                    self.town = town
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    encoder.encode(town, forKey: "town")
                    return encoder.items
                }
            }

            /// Japan_address_kanji_specs
            ///
            /// The Kanji variation of the person's address (Japan only).
            public struct AddressKanji: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?
                public var town: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                    self.town = town
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    encoder.encode(town, forKey: "town")
                    return encoder.items
                }
            }

            /// The person's date of birth.
            public struct Dob: Encodable {
                /// Date_of_birth_specs
                public var a: A?
                public var b: B?

                /// Date_of_birth_specs
                public struct A: Encodable {
                    public var day: Int
                    public var month: Int
                    public var year: Int

                    public init(day: Int, month: Int, year: Int) {
                        self.day = day
                        self.month = month
                        self.year = year
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(day, forKey: "day")
                        encoder.encode(month, forKey: "month")
                        encoder.encode(year, forKey: "year")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Person_documents_specs
            ///
            /// Documents that may be submitted to satisfy various informational requests.
            public struct Documents: Encodable {
                /// Documents_param
                public var companyAuthorization: CompanyAuthorization?
                /// Documents_param
                public var passport: Passport?
                /// Documents_param
                public var visa: Visa?

                /// Documents_param
                public struct CompanyAuthorization: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct Passport: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct Visa: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                public init(companyAuthorization: CompanyAuthorization? = nil, passport: Passport? = nil, visa: Visa? = nil) {
                    self.companyAuthorization = companyAuthorization
                    self.passport = passport
                    self.visa = visa
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(companyAuthorization, forKey: "company_authorization")
                    encoder.encode(passport, forKey: "passport")
                    encoder.encode(visa, forKey: "visa")
                    return encoder.items
                }
            }

            /// A list of alternate names or aliases that the person is known by.
            public struct FullNameAliases: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Relationship_specs
            ///
            /// The relationship that this person has with the account's legal entity.
            public struct Relationship: Encodable {
                public var isDirector: Bool?
                public var isExecutive: Bool?
                public var isOwner: Bool?
                public var percentOwnership: PercentOwnership?
                public var isRepresentative: Bool?
                public var title: String?

                public struct PercentOwnership: Encodable {
                    public var double: Double?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(double: Double? = nil, object: Object? = nil) {
                        self.double = double
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(double, forKey: "double")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(isDirector: Bool? = nil, isExecutive: Bool? = nil, isOwner: Bool? = nil, percentOwnership: PercentOwnership? = nil, isRepresentative: Bool? = nil, title: String? = nil) {
                    self.isDirector = isDirector
                    self.isExecutive = isExecutive
                    self.isOwner = isOwner
                    self.percentOwnership = percentOwnership
                    self.isRepresentative = isRepresentative
                    self.title = title
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isDirector, forKey: "director")
                    encoder.encode(isExecutive, forKey: "executive")
                    encoder.encode(isOwner, forKey: "owner")
                    encoder.encode(percentOwnership, forKey: "percent_ownership")
                    encoder.encode(isRepresentative, forKey: "representative")
                    encoder.encode(title, forKey: "title")
                    return encoder.items
                }
            }

            /// Person_verification_specs
            ///
            /// The person's verification status.
            public struct Verification: Encodable {
                /// Person_verification_document_specs
                public var additionalDocument: AdditionalDocument?
                /// Person_verification_document_specs
                public var document: Document?

                /// Person_verification_document_specs
                public struct AdditionalDocument: Encodable {
                    public var back: String?
                    public var front: String?

                    public init(back: String? = nil, front: String? = nil) {
                        self.back = back
                        self.front = front
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(back, forKey: "back")
                        encoder.encode(front, forKey: "front")
                        return encoder.items
                    }
                }

                /// Person_verification_document_specs
                public struct Document: Encodable {
                    public var back: String?
                    public var front: String?

                    public init(back: String? = nil, front: String? = nil) {
                        self.back = back
                        self.front = front
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(back, forKey: "back")
                        encoder.encode(front, forKey: "front")
                        return encoder.items
                    }
                }

                public init(additionalDocument: AdditionalDocument? = nil, document: Document? = nil) {
                    self.additionalDocument = additionalDocument
                    self.document = document
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(additionalDocument, forKey: "additional_document")
                    encoder.encode(document, forKey: "document")
                    return encoder.items
                }
            }

            public init(address: Address? = nil, addressKana: AddressKana? = nil, addressKanji: AddressKanji? = nil, dob: Dob? = nil, documents: Documents? = nil, email: String? = nil, expand: [String]? = nil, firstName: String? = nil, firstNameKana: String? = nil, firstNameKanji: String? = nil, fullNameAliases: FullNameAliases? = nil, gender: String? = nil, idNumber: String? = nil, lastName: String? = nil, lastNameKana: String? = nil, lastNameKanji: String? = nil, maidenName: String? = nil, metadata: Metadata? = nil, nationality: String? = nil, personToken: String? = nil, phone: String? = nil, politicalExposure: String? = nil, relationship: Relationship? = nil, ssnLast4: String? = nil, verification: Verification? = nil) {
                self.address = address
                self.addressKana = addressKana
                self.addressKanji = addressKanji
                self.dob = dob
                self.documents = documents
                self.email = email
                self.expand = expand
                self.firstName = firstName
                self.firstNameKana = firstNameKana
                self.firstNameKanji = firstNameKanji
                self.fullNameAliases = fullNameAliases
                self.gender = gender
                self.idNumber = idNumber
                self.lastName = lastName
                self.lastNameKana = lastNameKana
                self.lastNameKanji = lastNameKanji
                self.maidenName = maidenName
                self.metadata = metadata
                self.nationality = nationality
                self.personToken = personToken
                self.phone = phone
                self.politicalExposure = politicalExposure
                self.relationship = relationship
                self.ssnLast4 = ssnLast4
                self.verification = verification
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(address, forKey: "address")
                encoder.encode(addressKana, forKey: "address_kana")
                encoder.encode(addressKanji, forKey: "address_kanji")
                encoder.encode(dob, forKey: "dob")
                encoder.encode(documents, forKey: "documents")
                encoder.encode(email, forKey: "email")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(firstName, forKey: "first_name")
                encoder.encode(firstNameKana, forKey: "first_name_kana")
                encoder.encode(firstNameKanji, forKey: "first_name_kanji")
                encoder.encode(fullNameAliases, forKey: "full_name_aliases")
                encoder.encode(gender, forKey: "gender")
                encoder.encode(idNumber, forKey: "id_number")
                encoder.encode(lastName, forKey: "last_name")
                encoder.encode(lastNameKana, forKey: "last_name_kana")
                encoder.encode(lastNameKanji, forKey: "last_name_kanji")
                encoder.encode(maidenName, forKey: "maiden_name")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(nationality, forKey: "nationality")
                encoder.encode(personToken, forKey: "person_token")
                encoder.encode(phone, forKey: "phone")
                encoder.encode(politicalExposure, forKey: "political_exposure")
                encoder.encode(relationship, forKey: "relationship")
                encoder.encode(ssnLast4, forKey: "ssn_last_4")
                encoder.encode(verification, forKey: "verification")
                return encoder.items
            }
        }

        /// <p>Deletes an existing person’s relationship to the account’s legal entity. Any person with a relationship for an account can be deleted through the API, except if the person is the <code>account_opener</code>. If your integration is using the <code>executive</code> parameter, you cannot delete the only verified <code>executive</code> on file.</p>
        public var delete: Request<StripeAPI.DeletedPerson> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccount {
    public var persons: Persons {
        Persons(path: path + "/persons")
    }

    public struct Persons {
        /// Path: `/v1/accounts/{account}/persons`
        public let path: String

        /// <p>Returns a list of people associated with the account’s legal entity. The people are returned sorted by creation date, with the most recent people appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Person]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Person], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            /// All_people_relationship_specs
            public var relationship: Relationship?
            public var startingAfter: String?

            /// All_people_relationship_specs
            public struct Relationship: Codable {
                public var isDirector: Bool?
                public var isExecutive: Bool?
                public var isOwner: Bool?
                public var isRepresentative: Bool?

                public init(isDirector: Bool? = nil, isExecutive: Bool? = nil, isOwner: Bool? = nil, isRepresentative: Bool? = nil) {
                    self.isDirector = isDirector
                    self.isExecutive = isExecutive
                    self.isOwner = isOwner
                    self.isRepresentative = isRepresentative
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isDirector, forKey: "director")
                    encoder.encode(isExecutive, forKey: "executive")
                    encoder.encode(isOwner, forKey: "owner")
                    encoder.encode(isRepresentative, forKey: "representative")
                    return encoder.items
                }
            }

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, relationship: Relationship? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.relationship = relationship
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(relationship, forKey: "relationship", isDeepObject: true)
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates a new person.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Person> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Address_specs
            ///
            /// The person's address.
            public var address: Address?
            /// Japan_address_kana_specs
            ///
            /// The Kana variation of the person's address (Japan only).
            public var addressKana: AddressKana?
            /// Japan_address_kanji_specs
            ///
            /// The Kanji variation of the person's address (Japan only).
            public var addressKanji: AddressKanji?
            /// The person's date of birth.
            public var dob: Dob?
            /// Person_documents_specs
            ///
            /// Documents that may be submitted to satisfy various informational requests.
            public var documents: Documents?
            /// The person's email address.
            public var email: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The person's first name.
            public var firstName: String?
            /// The Kana variation of the person's first name (Japan only).
            public var firstNameKana: String?
            /// The Kanji variation of the person's first name (Japan only).
            public var firstNameKanji: String?
            /// A list of alternate names or aliases that the person is known by.
            public var fullNameAliases: FullNameAliases?
            /// The person's gender (International regulations require either "male" or "female").
            public var gender: String?
            /// The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
            public var idNumber: String?
            /// The person's last name.
            public var lastName: String?
            /// The Kana variation of the person's last name (Japan only).
            public var lastNameKana: String?
            /// The Kanji variation of the person's last name (Japan only).
            public var lastNameKanji: String?
            /// The person's maiden name.
            public var maidenName: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or "XX" if unavailable.
            public var nationality: String?
            /// A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
            public var personToken: String?
            /// The person's phone number.
            public var phone: String?
            /// Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
            public var politicalExposure: String?
            /// Relationship_specs
            ///
            /// The relationship that this person has with the account's legal entity.
            public var relationship: Relationship?
            /// The last four digits of the person's Social Security number (U.S. only).
            public var ssnLast4: String?
            /// Person_verification_specs
            ///
            /// The person's verification status.
            public var verification: Verification?

            /// Address_specs
            ///
            /// The person's address.
            public struct Address: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    return encoder.items
                }
            }

            /// Japan_address_kana_specs
            ///
            /// The Kana variation of the person's address (Japan only).
            public struct AddressKana: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?
                public var town: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                    self.town = town
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    encoder.encode(town, forKey: "town")
                    return encoder.items
                }
            }

            /// Japan_address_kanji_specs
            ///
            /// The Kanji variation of the person's address (Japan only).
            public struct AddressKanji: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?
                public var town: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                    self.town = town
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    encoder.encode(town, forKey: "town")
                    return encoder.items
                }
            }

            /// The person's date of birth.
            public struct Dob: Encodable {
                /// Date_of_birth_specs
                public var a: A?
                public var b: B?

                /// Date_of_birth_specs
                public struct A: Encodable {
                    public var day: Int
                    public var month: Int
                    public var year: Int

                    public init(day: Int, month: Int, year: Int) {
                        self.day = day
                        self.month = month
                        self.year = year
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(day, forKey: "day")
                        encoder.encode(month, forKey: "month")
                        encoder.encode(year, forKey: "year")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Person_documents_specs
            ///
            /// Documents that may be submitted to satisfy various informational requests.
            public struct Documents: Encodable {
                /// Documents_param
                public var companyAuthorization: CompanyAuthorization?
                /// Documents_param
                public var passport: Passport?
                /// Documents_param
                public var visa: Visa?

                /// Documents_param
                public struct CompanyAuthorization: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct Passport: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct Visa: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                public init(companyAuthorization: CompanyAuthorization? = nil, passport: Passport? = nil, visa: Visa? = nil) {
                    self.companyAuthorization = companyAuthorization
                    self.passport = passport
                    self.visa = visa
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(companyAuthorization, forKey: "company_authorization")
                    encoder.encode(passport, forKey: "passport")
                    encoder.encode(visa, forKey: "visa")
                    return encoder.items
                }
            }

            /// A list of alternate names or aliases that the person is known by.
            public struct FullNameAliases: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Relationship_specs
            ///
            /// The relationship that this person has with the account's legal entity.
            public struct Relationship: Encodable {
                public var isDirector: Bool?
                public var isExecutive: Bool?
                public var isOwner: Bool?
                public var percentOwnership: PercentOwnership?
                public var isRepresentative: Bool?
                public var title: String?

                public struct PercentOwnership: Encodable {
                    public var double: Double?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(double: Double? = nil, object: Object? = nil) {
                        self.double = double
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(double, forKey: "double")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(isDirector: Bool? = nil, isExecutive: Bool? = nil, isOwner: Bool? = nil, percentOwnership: PercentOwnership? = nil, isRepresentative: Bool? = nil, title: String? = nil) {
                    self.isDirector = isDirector
                    self.isExecutive = isExecutive
                    self.isOwner = isOwner
                    self.percentOwnership = percentOwnership
                    self.isRepresentative = isRepresentative
                    self.title = title
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isDirector, forKey: "director")
                    encoder.encode(isExecutive, forKey: "executive")
                    encoder.encode(isOwner, forKey: "owner")
                    encoder.encode(percentOwnership, forKey: "percent_ownership")
                    encoder.encode(isRepresentative, forKey: "representative")
                    encoder.encode(title, forKey: "title")
                    return encoder.items
                }
            }

            /// Person_verification_specs
            ///
            /// The person's verification status.
            public struct Verification: Encodable {
                /// Person_verification_document_specs
                public var additionalDocument: AdditionalDocument?
                /// Person_verification_document_specs
                public var document: Document?

                /// Person_verification_document_specs
                public struct AdditionalDocument: Encodable {
                    public var back: String?
                    public var front: String?

                    public init(back: String? = nil, front: String? = nil) {
                        self.back = back
                        self.front = front
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(back, forKey: "back")
                        encoder.encode(front, forKey: "front")
                        return encoder.items
                    }
                }

                /// Person_verification_document_specs
                public struct Document: Encodable {
                    public var back: String?
                    public var front: String?

                    public init(back: String? = nil, front: String? = nil) {
                        self.back = back
                        self.front = front
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(back, forKey: "back")
                        encoder.encode(front, forKey: "front")
                        return encoder.items
                    }
                }

                public init(additionalDocument: AdditionalDocument? = nil, document: Document? = nil) {
                    self.additionalDocument = additionalDocument
                    self.document = document
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(additionalDocument, forKey: "additional_document")
                    encoder.encode(document, forKey: "document")
                    return encoder.items
                }
            }

            public init(address: Address? = nil, addressKana: AddressKana? = nil, addressKanji: AddressKanji? = nil, dob: Dob? = nil, documents: Documents? = nil, email: String? = nil, expand: [String]? = nil, firstName: String? = nil, firstNameKana: String? = nil, firstNameKanji: String? = nil, fullNameAliases: FullNameAliases? = nil, gender: String? = nil, idNumber: String? = nil, lastName: String? = nil, lastNameKana: String? = nil, lastNameKanji: String? = nil, maidenName: String? = nil, metadata: Metadata? = nil, nationality: String? = nil, personToken: String? = nil, phone: String? = nil, politicalExposure: String? = nil, relationship: Relationship? = nil, ssnLast4: String? = nil, verification: Verification? = nil) {
                self.address = address
                self.addressKana = addressKana
                self.addressKanji = addressKanji
                self.dob = dob
                self.documents = documents
                self.email = email
                self.expand = expand
                self.firstName = firstName
                self.firstNameKana = firstNameKana
                self.firstNameKanji = firstNameKanji
                self.fullNameAliases = fullNameAliases
                self.gender = gender
                self.idNumber = idNumber
                self.lastName = lastName
                self.lastNameKana = lastNameKana
                self.lastNameKanji = lastNameKanji
                self.maidenName = maidenName
                self.metadata = metadata
                self.nationality = nationality
                self.personToken = personToken
                self.phone = phone
                self.politicalExposure = politicalExposure
                self.relationship = relationship
                self.ssnLast4 = ssnLast4
                self.verification = verification
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(address, forKey: "address")
                encoder.encode(addressKana, forKey: "address_kana")
                encoder.encode(addressKanji, forKey: "address_kanji")
                encoder.encode(dob, forKey: "dob")
                encoder.encode(documents, forKey: "documents")
                encoder.encode(email, forKey: "email")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(firstName, forKey: "first_name")
                encoder.encode(firstNameKana, forKey: "first_name_kana")
                encoder.encode(firstNameKanji, forKey: "first_name_kanji")
                encoder.encode(fullNameAliases, forKey: "full_name_aliases")
                encoder.encode(gender, forKey: "gender")
                encoder.encode(idNumber, forKey: "id_number")
                encoder.encode(lastName, forKey: "last_name")
                encoder.encode(lastNameKana, forKey: "last_name_kana")
                encoder.encode(lastNameKanji, forKey: "last_name_kanji")
                encoder.encode(maidenName, forKey: "maiden_name")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(nationality, forKey: "nationality")
                encoder.encode(personToken, forKey: "person_token")
                encoder.encode(phone, forKey: "phone")
                encoder.encode(politicalExposure, forKey: "political_exposure")
                encoder.encode(relationship, forKey: "relationship")
                encoder.encode(ssnLast4, forKey: "ssn_last_4")
                encoder.encode(verification, forKey: "verification")
                return encoder.items
            }
        }
    }
}

extension Paths.Accounts.WithAccount.Persons {
    public func person(_ person: String) -> WithPerson {
        WithPerson(path: "\(path)/\(person)")
    }

    public struct WithPerson {
        /// Path: `/v1/accounts/{account}/persons/{person}`
        public let path: String

        /// <p>Retrieves an existing person.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Person> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates an existing person.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Person> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Address_specs
            ///
            /// The person's address.
            public var address: Address?
            /// Japan_address_kana_specs
            ///
            /// The Kana variation of the person's address (Japan only).
            public var addressKana: AddressKana?
            /// Japan_address_kanji_specs
            ///
            /// The Kanji variation of the person's address (Japan only).
            public var addressKanji: AddressKanji?
            /// The person's date of birth.
            public var dob: Dob?
            /// Person_documents_specs
            ///
            /// Documents that may be submitted to satisfy various informational requests.
            public var documents: Documents?
            /// The person's email address.
            public var email: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The person's first name.
            public var firstName: String?
            /// The Kana variation of the person's first name (Japan only).
            public var firstNameKana: String?
            /// The Kanji variation of the person's first name (Japan only).
            public var firstNameKanji: String?
            /// A list of alternate names or aliases that the person is known by.
            public var fullNameAliases: FullNameAliases?
            /// The person's gender (International regulations require either "male" or "female").
            public var gender: String?
            /// The person's ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type=pii).
            public var idNumber: String?
            /// The person's last name.
            public var lastName: String?
            /// The Kana variation of the person's last name (Japan only).
            public var lastNameKana: String?
            /// The Kanji variation of the person's last name (Japan only).
            public var lastNameKanji: String?
            /// The person's maiden name.
            public var maidenName: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or "XX" if unavailable.
            public var nationality: String?
            /// A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
            public var personToken: String?
            /// The person's phone number.
            public var phone: String?
            /// Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
            public var politicalExposure: String?
            /// Relationship_specs
            ///
            /// The relationship that this person has with the account's legal entity.
            public var relationship: Relationship?
            /// The last four digits of the person's Social Security number (U.S. only).
            public var ssnLast4: String?
            /// Person_verification_specs
            ///
            /// The person's verification status.
            public var verification: Verification?

            /// Address_specs
            ///
            /// The person's address.
            public struct Address: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    return encoder.items
                }
            }

            /// Japan_address_kana_specs
            ///
            /// The Kana variation of the person's address (Japan only).
            public struct AddressKana: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?
                public var town: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                    self.town = town
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    encoder.encode(town, forKey: "town")
                    return encoder.items
                }
            }

            /// Japan_address_kanji_specs
            ///
            /// The Kanji variation of the person's address (Japan only).
            public struct AddressKanji: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?
                public var town: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                    self.town = town
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    encoder.encode(town, forKey: "town")
                    return encoder.items
                }
            }

            /// The person's date of birth.
            public struct Dob: Encodable {
                /// Date_of_birth_specs
                public var a: A?
                public var b: B?

                /// Date_of_birth_specs
                public struct A: Encodable {
                    public var day: Int
                    public var month: Int
                    public var year: Int

                    public init(day: Int, month: Int, year: Int) {
                        self.day = day
                        self.month = month
                        self.year = year
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(day, forKey: "day")
                        encoder.encode(month, forKey: "month")
                        encoder.encode(year, forKey: "year")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Person_documents_specs
            ///
            /// Documents that may be submitted to satisfy various informational requests.
            public struct Documents: Encodable {
                /// Documents_param
                public var companyAuthorization: CompanyAuthorization?
                /// Documents_param
                public var passport: Passport?
                /// Documents_param
                public var visa: Visa?

                /// Documents_param
                public struct CompanyAuthorization: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct Passport: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                /// Documents_param
                public struct Visa: Encodable {
                    public var files: [String]?

                    public init(files: [String]? = nil) {
                        self.files = files
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(files, forKey: "files")
                        return encoder.items
                    }
                }

                public init(companyAuthorization: CompanyAuthorization? = nil, passport: Passport? = nil, visa: Visa? = nil) {
                    self.companyAuthorization = companyAuthorization
                    self.passport = passport
                    self.visa = visa
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(companyAuthorization, forKey: "company_authorization")
                    encoder.encode(passport, forKey: "passport")
                    encoder.encode(visa, forKey: "visa")
                    return encoder.items
                }
            }

            /// A list of alternate names or aliases that the person is known by.
            public struct FullNameAliases: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Relationship_specs
            ///
            /// The relationship that this person has with the account's legal entity.
            public struct Relationship: Encodable {
                public var isDirector: Bool?
                public var isExecutive: Bool?
                public var isOwner: Bool?
                public var percentOwnership: PercentOwnership?
                public var isRepresentative: Bool?
                public var title: String?

                public struct PercentOwnership: Encodable {
                    public var double: Double?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(double: Double? = nil, object: Object? = nil) {
                        self.double = double
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(double, forKey: "double")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(isDirector: Bool? = nil, isExecutive: Bool? = nil, isOwner: Bool? = nil, percentOwnership: PercentOwnership? = nil, isRepresentative: Bool? = nil, title: String? = nil) {
                    self.isDirector = isDirector
                    self.isExecutive = isExecutive
                    self.isOwner = isOwner
                    self.percentOwnership = percentOwnership
                    self.isRepresentative = isRepresentative
                    self.title = title
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isDirector, forKey: "director")
                    encoder.encode(isExecutive, forKey: "executive")
                    encoder.encode(isOwner, forKey: "owner")
                    encoder.encode(percentOwnership, forKey: "percent_ownership")
                    encoder.encode(isRepresentative, forKey: "representative")
                    encoder.encode(title, forKey: "title")
                    return encoder.items
                }
            }

            /// Person_verification_specs
            ///
            /// The person's verification status.
            public struct Verification: Encodable {
                /// Person_verification_document_specs
                public var additionalDocument: AdditionalDocument?
                /// Person_verification_document_specs
                public var document: Document?

                /// Person_verification_document_specs
                public struct AdditionalDocument: Encodable {
                    public var back: String?
                    public var front: String?

                    public init(back: String? = nil, front: String? = nil) {
                        self.back = back
                        self.front = front
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(back, forKey: "back")
                        encoder.encode(front, forKey: "front")
                        return encoder.items
                    }
                }

                /// Person_verification_document_specs
                public struct Document: Encodable {
                    public var back: String?
                    public var front: String?

                    public init(back: String? = nil, front: String? = nil) {
                        self.back = back
                        self.front = front
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(back, forKey: "back")
                        encoder.encode(front, forKey: "front")
                        return encoder.items
                    }
                }

                public init(additionalDocument: AdditionalDocument? = nil, document: Document? = nil) {
                    self.additionalDocument = additionalDocument
                    self.document = document
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(additionalDocument, forKey: "additional_document")
                    encoder.encode(document, forKey: "document")
                    return encoder.items
                }
            }

            public init(address: Address? = nil, addressKana: AddressKana? = nil, addressKanji: AddressKanji? = nil, dob: Dob? = nil, documents: Documents? = nil, email: String? = nil, expand: [String]? = nil, firstName: String? = nil, firstNameKana: String? = nil, firstNameKanji: String? = nil, fullNameAliases: FullNameAliases? = nil, gender: String? = nil, idNumber: String? = nil, lastName: String? = nil, lastNameKana: String? = nil, lastNameKanji: String? = nil, maidenName: String? = nil, metadata: Metadata? = nil, nationality: String? = nil, personToken: String? = nil, phone: String? = nil, politicalExposure: String? = nil, relationship: Relationship? = nil, ssnLast4: String? = nil, verification: Verification? = nil) {
                self.address = address
                self.addressKana = addressKana
                self.addressKanji = addressKanji
                self.dob = dob
                self.documents = documents
                self.email = email
                self.expand = expand
                self.firstName = firstName
                self.firstNameKana = firstNameKana
                self.firstNameKanji = firstNameKanji
                self.fullNameAliases = fullNameAliases
                self.gender = gender
                self.idNumber = idNumber
                self.lastName = lastName
                self.lastNameKana = lastNameKana
                self.lastNameKanji = lastNameKanji
                self.maidenName = maidenName
                self.metadata = metadata
                self.nationality = nationality
                self.personToken = personToken
                self.phone = phone
                self.politicalExposure = politicalExposure
                self.relationship = relationship
                self.ssnLast4 = ssnLast4
                self.verification = verification
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(address, forKey: "address")
                encoder.encode(addressKana, forKey: "address_kana")
                encoder.encode(addressKanji, forKey: "address_kanji")
                encoder.encode(dob, forKey: "dob")
                encoder.encode(documents, forKey: "documents")
                encoder.encode(email, forKey: "email")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(firstName, forKey: "first_name")
                encoder.encode(firstNameKana, forKey: "first_name_kana")
                encoder.encode(firstNameKanji, forKey: "first_name_kanji")
                encoder.encode(fullNameAliases, forKey: "full_name_aliases")
                encoder.encode(gender, forKey: "gender")
                encoder.encode(idNumber, forKey: "id_number")
                encoder.encode(lastName, forKey: "last_name")
                encoder.encode(lastNameKana, forKey: "last_name_kana")
                encoder.encode(lastNameKanji, forKey: "last_name_kanji")
                encoder.encode(maidenName, forKey: "maiden_name")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(nationality, forKey: "nationality")
                encoder.encode(personToken, forKey: "person_token")
                encoder.encode(phone, forKey: "phone")
                encoder.encode(politicalExposure, forKey: "political_exposure")
                encoder.encode(relationship, forKey: "relationship")
                encoder.encode(ssnLast4, forKey: "ssn_last_4")
                encoder.encode(verification, forKey: "verification")
                return encoder.items
            }
        }

        /// <p>Deletes an existing person’s relationship to the account’s legal entity. Any person with a relationship for an account can be deleted through the API, except if the person is the <code>account_opener</code>. If your integration is using the <code>executive</code> parameter, you cannot delete the only verified <code>executive</code> on file.</p>
        public var delete: Request<StripeAPI.DeletedPerson> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccount {
    public var reject: Reject {
        Reject(path: path + "/reject")
    }

    public struct Reject {
        /// Path: `/v1/accounts/{account}/reject`
        public let path: String

        /// <p>With <a href="/docs/connect">Connect</a>, you may flag accounts as suspicious.</p>
        /// 
        /// <p>Test-mode Custom and Express accounts can be rejected at any time. Accounts created using live-mode keys may only be rejected once all balances are zero.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.Account> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The reason for rejecting the account. Can be `fraud`, `terms_of_service`, or `other`.
            public var reason: String

            public init(expand: [String]? = nil, reason: String) {
                self.expand = expand
                self.reason = reason
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(reason, forKey: "reason")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var applePay: ApplePay {
        ApplePay(path: "/v1/apple_pay")
    }

    public struct ApplePay {
        /// Path: `/v1/apple_pay`
        public let path: String
    }
}

extension Paths.ApplePay {
    public var domains: Domains {
        Domains(path: path + "/domains")
    }

    public struct Domains {
        /// Path: `/v1/apple_pay/domains`
        public let path: String

        /// <p>List apple pay domains.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// ApplePayDomainList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.ApplePayDomain]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.ApplePayDomain], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var domainName: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(domainName: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.domainName = domainName
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(domainName, forKey: "domain_name")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Create an apple pay domain.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.ApplePayDomain> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            public var domainName: String
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(domainName: String, expand: [String]? = nil) {
                self.domainName = domainName
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(domainName, forKey: "domain_name")
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.ApplePay.Domains {
    public func domain(_ domain: String) -> WithDomain {
        WithDomain(path: "\(path)/\(domain)")
    }

    public struct WithDomain {
        /// Path: `/v1/apple_pay/domains/{domain}`
        public let path: String

        /// <p>Retrieve an apple pay domain.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.ApplePayDomain> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Delete an apple pay domain.</p>
        public var delete: Request<StripeAPI.DeletedApplePayDomain> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var applicationFees: ApplicationFees {
        ApplicationFees(path: "/v1/application_fees")
    }

    public struct ApplicationFees {
        /// Path: `/v1/application_fees`
        public let path: String

        /// <p>Returns a list of application fees you’ve previously collected. The application fees are returned in sorted order, with the most recent fees appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.ApplicationFee]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.ApplicationFee], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var charge: String?
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(charge: String? = nil, created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.charge = charge
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(charge, forKey: "charge")
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }
    }
}

extension Paths.ApplicationFees {
    public func fee(_ fee: String) -> WithFee {
        WithFee(path: "\(path)/\(fee)")
    }

    public struct WithFee {
        /// Path: `/v1/application_fees/{fee}`
        public let path: String
    }
}

extension Paths.ApplicationFees.WithFee {
    public var refunds: Refunds {
        Refunds(path: path + "/refunds")
    }

    public struct Refunds {
        /// Path: `/v1/application_fees/{fee}/refunds`
        public let path: String
    }
}

extension Paths.ApplicationFees.WithFee.Refunds {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/application_fees/{fee}/refunds/{id}`
        public let path: String

        /// <p>By default, you can see the 10 most recent refunds stored directly on the application fee object, but you can also retrieve details about a specific refund stored on the application fee.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.FeeRefund> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the specified application fee refund by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
        /// 
        /// <p>This request only accepts metadata as an argument.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.FeeRefund> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(expand: [String]? = nil, metadata: Metadata? = nil) {
                self.expand = expand
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths.ApplicationFees {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/application_fees/{id}`
        public let path: String

        /// <p>Retrieves the details of an application fee that your account has collected. The same information is returned when refunding the application fee.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.ApplicationFee> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths.ApplicationFees.WithID {
    public var refund: Refund {
        Refund(path: path + "/refund")
    }

    public struct Refund {
        /// Path: `/v1/application_fees/{id}/refund`
        public let path: String

        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.ApplicationFee> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            public var amount: Int?
            public var directive: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(amount: Int? = nil, directive: String? = nil, expand: [String]? = nil) {
                self.amount = amount
                self.directive = directive
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(directive, forKey: "directive")
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.ApplicationFees.WithID {
    public var refunds: Refunds {
        Refunds(path: path + "/refunds")
    }

    public struct Refunds {
        /// Path: `/v1/application_fees/{id}/refunds`
        public let path: String

        /// <p>You can see a list of the refunds belonging to a specific application fee. Note that the 10 most recent refunds are always available by default on the application fee object. If you need more than those 10, you can use this API method and the <code>limit</code> and <code>starting_after</code> parameters to page through additional refunds.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// FeeRefundList
        public struct GetResponse: Decodable {
            /// Details about each object.
            public var data: [StripeAPI.FeeRefund]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.FeeRefund], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Refunds an application fee that has previously been collected but not yet refunded.
        /// Funds will be refunded to the Stripe account from which the fee was originally collected.</p>
        /// 
        /// <p>You can optionally refund only part of an application fee.
        /// You can do so multiple times, until the entire fee has been refunded.</p>
        /// 
        /// <p>Once entirely refunded, an application fee can’t be refunded again.
        /// This method will raise an error when called on an already-refunded application fee,
        /// or when trying to refund more money than is left on an application fee.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.FeeRefund> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// A positive integer, in _%s_, representing how much of this fee to refund. Can refund only up to the remaining unrefunded amount of the fee.
            public var amount: Int?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?

            public init(amount: Int? = nil, expand: [String]? = nil, metadata: [String: String]? = nil) {
                self.amount = amount
                self.expand = expand
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var balance: Balance {
        Balance(path: "/v1/balance")
    }

    public struct Balance {
        /// Path: `/v1/balance`
        public let path: String

        /// <p>Retrieves the current account balance, based on the authentication that was used to make the request.
        ///  For a sample request, see <a href="/docs/connect/account-balances#accounting-for-negative-balances">Accounting for negative balances</a>.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Balance> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths.Balance {
    public var history: History {
        History(path: path + "/history")
    }

    public struct History {
        /// Path: `/v1/balance/history`
        public let path: String

        /// <p>Returns a list of transactions that have contributed to the Stripe account balance (e.g., charges, transfers, and so forth). The transactions are returned in sorted order, with the most recent transactions appearing first.</p>
        /// 
        /// <p>Note that this endpoint was previously called “Balance history” and used the path <code>/v1/balance/history</code>.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// BalanceTransactionsList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.BalanceTransaction]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.BalanceTransaction], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var currency: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var payout: String?
            public var source: String?
            public var startingAfter: String?
            public var type: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(created: Created? = nil, currency: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, payout: String? = nil, source: String? = nil, startingAfter: String? = nil, type: String? = nil) {
                self.created = created
                self.currency = currency
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.payout = payout
                self.source = source
                self.startingAfter = startingAfter
                self.type = type
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(currency, forKey: "currency")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(payout, forKey: "payout")
                encoder.encode(source, forKey: "source")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(type, forKey: "type")
                return encoder.items
            }
        }
    }
}

extension Paths.Balance.History {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/balance/history/{id}`
        public let path: String

        /// <p>Retrieves the balance transaction with the given ID.</p>
        /// 
        /// <p>Note that this endpoint previously used the path <code>/v1/balance/history/:id</code>.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.BalanceTransaction> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths {
    public static var balanceTransactions: BalanceTransactions {
        BalanceTransactions(path: "/v1/balance_transactions")
    }

    public struct BalanceTransactions {
        /// Path: `/v1/balance_transactions`
        public let path: String

        /// <p>Returns a list of transactions that have contributed to the Stripe account balance (e.g., charges, transfers, and so forth). The transactions are returned in sorted order, with the most recent transactions appearing first.</p>
        /// 
        /// <p>Note that this endpoint was previously called “Balance history” and used the path <code>/v1/balance/history</code>.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// BalanceTransactionsList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.BalanceTransaction]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.BalanceTransaction], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var currency: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var payout: String?
            public var source: String?
            public var startingAfter: String?
            public var type: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(created: Created? = nil, currency: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, payout: String? = nil, source: String? = nil, startingAfter: String? = nil, type: String? = nil) {
                self.created = created
                self.currency = currency
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.payout = payout
                self.source = source
                self.startingAfter = startingAfter
                self.type = type
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(currency, forKey: "currency")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(payout, forKey: "payout")
                encoder.encode(source, forKey: "source")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(type, forKey: "type")
                return encoder.items
            }
        }
    }
}

extension Paths.BalanceTransactions {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/balance_transactions/{id}`
        public let path: String

        /// <p>Retrieves the balance transaction with the given ID.</p>
        /// 
        /// <p>Note that this endpoint previously used the path <code>/v1/balance/history/:id</code>.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.BalanceTransaction> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths {
    public static var billingPortal: BillingPortal {
        BillingPortal(path: "/v1/billing_portal")
    }

    public struct BillingPortal {
        /// Path: `/v1/billing_portal`
        public let path: String
    }
}

extension Paths.BillingPortal {
    public var configurations: Configurations {
        Configurations(path: path + "/configurations")
    }

    public struct Configurations {
        /// Path: `/v1/billing_portal/configurations`
        public let path: String

        /// <p>Returns a list of configurations that describe the functionality of the customer portal.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.BillingPortalConfiguration]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.BillingPortalConfiguration], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var isActive: Bool?
            public var endingBefore: String?
            public var expand: [String]?
            public var isDefault: Bool?
            public var limit: Int?
            public var startingAfter: String?

            public init(isActive: Bool? = nil, endingBefore: String? = nil, expand: [String]? = nil, isDefault: Bool? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.isActive = isActive
                self.endingBefore = endingBefore
                self.expand = expand
                self.isDefault = isDefault
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(isDefault, forKey: "is_default")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates a configuration that describes the functionality and behavior of a PortalSession</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.BillingPortalConfiguration> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Business_profile_create_param
            ///
            /// The business information shown to customers in the portal.
            public var businessProfile: BusinessProfile
            /// The default URL to redirect customers to when they click on the portal's link to return to your website. This can be [overriden](https://stripe.com/docs/api/customer_portal/sessions/create#create_portal_session-return_url) when creating the session.
            public var defaultReturnURL: DefaultReturnURL?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Features_creation_param
            ///
            /// Information about the features available in the portal.
            public var features: Features
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?

            /// Business_profile_create_param
            ///
            /// The business information shown to customers in the portal.
            public struct BusinessProfile: Encodable {
                public var headline: String?
                public var privacyPolicyURL: String
                public var termsOfServiceURL: String

                public init(headline: String? = nil, privacyPolicyURL: String, termsOfServiceURL: String) {
                    self.headline = headline
                    self.privacyPolicyURL = privacyPolicyURL
                    self.termsOfServiceURL = termsOfServiceURL
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(headline, forKey: "headline")
                    encoder.encode(privacyPolicyURL, forKey: "privacy_policy_url")
                    encoder.encode(termsOfServiceURL, forKey: "terms_of_service_url")
                    return encoder.items
                }
            }

            /// The default URL to redirect customers to when they click on the portal's link to return to your website. This can be [overriden](https://stripe.com/docs/api/customer_portal/sessions/create#create_portal_session-return_url) when creating the session.
            public struct DefaultReturnURL: Encodable {
                public var string: String?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(string: String? = nil, object: Object? = nil) {
                    self.string = string
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(string, forKey: "string")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Features_creation_param
            ///
            /// Information about the features available in the portal.
            public struct Features: Encodable {
                /// Customer_update_creation_param
                public var customerUpdate: CustomerUpdate?
                /// Invoice_list_param
                public var invoiceHistory: InvoiceHistory?
                /// Payment_method_update_param
                public var paymentMethodUpdate: PaymentMethodUpdate?
                /// Subscription_cancel_creation_param
                public var subscriptionCancel: SubscriptionCancel?
                /// Subscription_pause_param
                public var subscriptionPause: SubscriptionPause?
                /// Subscription_update_creation_param
                public var subscriptionUpdate: SubscriptionUpdate?

                /// Customer_update_creation_param
                public struct CustomerUpdate: Encodable {
                    public var allowedUpdates: AllowedUpdates
                    public var isEnabled: Bool

                    public struct AllowedUpdates: Encodable {
                        public var placeholderItems: [PlaceholderItem]?
                        public var object: Object?

                        public enum PlaceholderItem: String, Codable, CaseIterable {
                            case address
                            case email
                            case phone
                            case shipping
                            case taxID = "tax_id"
                        }

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                            self.placeholderItems = placeholderItems
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(placeholderItems, forKey: "placeholderItems")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public init(allowedUpdates: AllowedUpdates, isEnabled: Bool) {
                        self.allowedUpdates = allowedUpdates
                        self.isEnabled = isEnabled
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(allowedUpdates, forKey: "allowed_updates")
                        encoder.encode(isEnabled, forKey: "enabled")
                        return encoder.items
                    }
                }

                /// Invoice_list_param
                public struct InvoiceHistory: Encodable {
                    public var isEnabled: Bool

                    public init(isEnabled: Bool) {
                        self.isEnabled = isEnabled
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isEnabled, forKey: "enabled")
                        return encoder.items
                    }
                }

                /// Payment_method_update_param
                public struct PaymentMethodUpdate: Encodable {
                    public var isEnabled: Bool

                    public init(isEnabled: Bool) {
                        self.isEnabled = isEnabled
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isEnabled, forKey: "enabled")
                        return encoder.items
                    }
                }

                /// Subscription_cancel_creation_param
                public struct SubscriptionCancel: Encodable {
                    /// Subscription_cancellation_reason_creation_param
                    public var cancellationReason: CancellationReason?
                    public var isEnabled: Bool
                    public var mode: Mode?
                    public var prorationBehavior: ProrationBehavior?

                    /// Subscription_cancellation_reason_creation_param
                    public struct CancellationReason: Encodable {
                        public var isEnabled: Bool
                        public var options: Options

                        public struct Options: Encodable {
                            public var placeholderItems: [PlaceholderItem]?
                            public var object: Object?

                            public enum PlaceholderItem: String, Codable, CaseIterable {
                                case customerService = "customer_service"
                                case lowQuality = "low_quality"
                                case missingFeatures = "missing_features"
                                case other
                                case switchedService = "switched_service"
                                case tooComplex = "too_complex"
                                case tooExpensive = "too_expensive"
                                case unused
                            }

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                                self.placeholderItems = placeholderItems
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(placeholderItems, forKey: "placeholderItems")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public init(isEnabled: Bool, options: Options) {
                            self.isEnabled = isEnabled
                            self.options = options
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(isEnabled, forKey: "enabled")
                            encoder.encode(options, forKey: "options")
                            return encoder.items
                        }
                    }

                    public enum Mode: String, Codable, CaseIterable {
                        case atPeriodEnd = "at_period_end"
                        case immediately
                    }

                    public enum ProrationBehavior: String, Codable, CaseIterable {
                        case alwaysInvoice = "always_invoice"
                        case createProrations = "create_prorations"
                        case `none`
                    }

                    public init(cancellationReason: CancellationReason? = nil, isEnabled: Bool, mode: Mode? = nil, prorationBehavior: ProrationBehavior? = nil) {
                        self.cancellationReason = cancellationReason
                        self.isEnabled = isEnabled
                        self.mode = mode
                        self.prorationBehavior = prorationBehavior
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(cancellationReason, forKey: "cancellation_reason")
                        encoder.encode(isEnabled, forKey: "enabled")
                        encoder.encode(mode, forKey: "mode")
                        encoder.encode(prorationBehavior, forKey: "proration_behavior")
                        return encoder.items
                    }
                }

                /// Subscription_pause_param
                public struct SubscriptionPause: Encodable {
                    public var isEnabled: Bool?

                    public init(isEnabled: Bool? = nil) {
                        self.isEnabled = isEnabled
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isEnabled, forKey: "enabled")
                        return encoder.items
                    }
                }

                /// Subscription_update_creation_param
                public struct SubscriptionUpdate: Encodable {
                    public var defaultAllowedUpdates: DefaultAllowedUpdates
                    public var isEnabled: Bool
                    public var products: Products
                    public var prorationBehavior: ProrationBehavior?

                    public struct DefaultAllowedUpdates: Encodable {
                        public var placeholderItems: [PlaceholderItem]?
                        public var object: Object?

                        public enum PlaceholderItem: String, Codable, CaseIterable {
                            case price
                            case promotionCode = "promotion_code"
                            case quantity
                        }

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                            self.placeholderItems = placeholderItems
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(placeholderItems, forKey: "placeholderItems")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public struct Products: Encodable {
                        public var placeholderItems: [PlaceholderItem]?
                        public var object: Object?

                        /// Subscription_update_product_param
                        public struct PlaceholderItem: Encodable {
                            public var prices: [String]
                            public var product: String

                            public init(prices: [String], product: String) {
                                self.prices = prices
                                self.product = product
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(prices, forKey: "prices")
                                encoder.encode(product, forKey: "product")
                                return encoder.items
                            }
                        }

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                            self.placeholderItems = placeholderItems
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(placeholderItems, forKey: "placeholderItems")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public enum ProrationBehavior: String, Codable, CaseIterable {
                        case alwaysInvoice = "always_invoice"
                        case createProrations = "create_prorations"
                        case `none`
                    }

                    public init(defaultAllowedUpdates: DefaultAllowedUpdates, isEnabled: Bool, products: Products, prorationBehavior: ProrationBehavior? = nil) {
                        self.defaultAllowedUpdates = defaultAllowedUpdates
                        self.isEnabled = isEnabled
                        self.products = products
                        self.prorationBehavior = prorationBehavior
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(defaultAllowedUpdates, forKey: "default_allowed_updates")
                        encoder.encode(isEnabled, forKey: "enabled")
                        encoder.encode(products, forKey: "products")
                        encoder.encode(prorationBehavior, forKey: "proration_behavior")
                        return encoder.items
                    }
                }

                public init(customerUpdate: CustomerUpdate? = nil, invoiceHistory: InvoiceHistory? = nil, paymentMethodUpdate: PaymentMethodUpdate? = nil, subscriptionCancel: SubscriptionCancel? = nil, subscriptionPause: SubscriptionPause? = nil, subscriptionUpdate: SubscriptionUpdate? = nil) {
                    self.customerUpdate = customerUpdate
                    self.invoiceHistory = invoiceHistory
                    self.paymentMethodUpdate = paymentMethodUpdate
                    self.subscriptionCancel = subscriptionCancel
                    self.subscriptionPause = subscriptionPause
                    self.subscriptionUpdate = subscriptionUpdate
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(customerUpdate, forKey: "customer_update")
                    encoder.encode(invoiceHistory, forKey: "invoice_history")
                    encoder.encode(paymentMethodUpdate, forKey: "payment_method_update")
                    encoder.encode(subscriptionCancel, forKey: "subscription_cancel")
                    encoder.encode(subscriptionPause, forKey: "subscription_pause")
                    encoder.encode(subscriptionUpdate, forKey: "subscription_update")
                    return encoder.items
                }
            }

            public init(businessProfile: BusinessProfile, defaultReturnURL: DefaultReturnURL? = nil, expand: [String]? = nil, features: Features, metadata: [String: String]? = nil) {
                self.businessProfile = businessProfile
                self.defaultReturnURL = defaultReturnURL
                self.expand = expand
                self.features = features
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(businessProfile, forKey: "business_profile")
                encoder.encode(defaultReturnURL, forKey: "default_return_url")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(features, forKey: "features")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths.BillingPortal.Configurations {
    public func configuration(_ configuration: String) -> WithConfiguration {
        WithConfiguration(path: "\(path)/\(configuration)")
    }

    public struct WithConfiguration {
        /// Path: `/v1/billing_portal/configurations/{configuration}`
        public let path: String

        /// <p>Retrieves a configuration that describes the functionality of the customer portal.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.BillingPortalConfiguration> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates a configuration that describes the functionality of the customer portal.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.BillingPortalConfiguration> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Whether the configuration is active and can be used to create portal sessions.
            public var isActive: Bool?
            /// Business_profile_update_param
            ///
            /// The business information shown to customers in the portal.
            public var businessProfile: BusinessProfile?
            /// The default URL to redirect customers to when they click on the portal's link to return to your website. This can be [overriden](https://stripe.com/docs/api/customer_portal/sessions/create#create_portal_session-return_url) when creating the session.
            public var defaultReturnURL: DefaultReturnURL?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Features_updating_param
            ///
            /// Information about the features available in the portal.
            public var features: Features?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?

            /// Business_profile_update_param
            ///
            /// The business information shown to customers in the portal.
            public struct BusinessProfile: Encodable {
                public var headline: String?
                public var privacyPolicyURL: String?
                public var termsOfServiceURL: String?

                public init(headline: String? = nil, privacyPolicyURL: String? = nil, termsOfServiceURL: String? = nil) {
                    self.headline = headline
                    self.privacyPolicyURL = privacyPolicyURL
                    self.termsOfServiceURL = termsOfServiceURL
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(headline, forKey: "headline")
                    encoder.encode(privacyPolicyURL, forKey: "privacy_policy_url")
                    encoder.encode(termsOfServiceURL, forKey: "terms_of_service_url")
                    return encoder.items
                }
            }

            /// The default URL to redirect customers to when they click on the portal's link to return to your website. This can be [overriden](https://stripe.com/docs/api/customer_portal/sessions/create#create_portal_session-return_url) when creating the session.
            public struct DefaultReturnURL: Encodable {
                public var string: String?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(string: String? = nil, object: Object? = nil) {
                    self.string = string
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(string, forKey: "string")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Features_updating_param
            ///
            /// Information about the features available in the portal.
            public struct Features: Encodable {
                /// Customer_update_updating_param
                public var customerUpdate: CustomerUpdate?
                /// Invoice_list_param
                public var invoiceHistory: InvoiceHistory?
                /// Payment_method_update_param
                public var paymentMethodUpdate: PaymentMethodUpdate?
                /// Subscription_cancel_updating_param
                public var subscriptionCancel: SubscriptionCancel?
                /// Subscription_pause_param
                public var subscriptionPause: SubscriptionPause?
                /// Subscription_update_updating_param
                public var subscriptionUpdate: SubscriptionUpdate?

                /// Customer_update_updating_param
                public struct CustomerUpdate: Encodable {
                    public var allowedUpdates: AllowedUpdates?
                    public var isEnabled: Bool?

                    public struct AllowedUpdates: Encodable {
                        public var placeholderItems: [PlaceholderItem]?
                        public var object: Object?

                        public enum PlaceholderItem: String, Codable, CaseIterable {
                            case address
                            case email
                            case phone
                            case shipping
                            case taxID = "tax_id"
                        }

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                            self.placeholderItems = placeholderItems
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(placeholderItems, forKey: "placeholderItems")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public init(allowedUpdates: AllowedUpdates? = nil, isEnabled: Bool? = nil) {
                        self.allowedUpdates = allowedUpdates
                        self.isEnabled = isEnabled
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(allowedUpdates, forKey: "allowed_updates")
                        encoder.encode(isEnabled, forKey: "enabled")
                        return encoder.items
                    }
                }

                /// Invoice_list_param
                public struct InvoiceHistory: Encodable {
                    public var isEnabled: Bool

                    public init(isEnabled: Bool) {
                        self.isEnabled = isEnabled
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isEnabled, forKey: "enabled")
                        return encoder.items
                    }
                }

                /// Payment_method_update_param
                public struct PaymentMethodUpdate: Encodable {
                    public var isEnabled: Bool

                    public init(isEnabled: Bool) {
                        self.isEnabled = isEnabled
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isEnabled, forKey: "enabled")
                        return encoder.items
                    }
                }

                /// Subscription_cancel_updating_param
                public struct SubscriptionCancel: Encodable {
                    /// Subscription_cancellation_reason_updating_param
                    public var cancellationReason: CancellationReason?
                    public var isEnabled: Bool?
                    public var mode: Mode?
                    public var prorationBehavior: ProrationBehavior?

                    /// Subscription_cancellation_reason_updating_param
                    public struct CancellationReason: Encodable {
                        public var isEnabled: Bool
                        public var options: Options?

                        public struct Options: Encodable {
                            public var placeholderItems: [PlaceholderItem]?
                            public var object: Object?

                            public enum PlaceholderItem: String, Codable, CaseIterable {
                                case customerService = "customer_service"
                                case lowQuality = "low_quality"
                                case missingFeatures = "missing_features"
                                case other
                                case switchedService = "switched_service"
                                case tooComplex = "too_complex"
                                case tooExpensive = "too_expensive"
                                case unused
                            }

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                                self.placeholderItems = placeholderItems
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(placeholderItems, forKey: "placeholderItems")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public init(isEnabled: Bool, options: Options? = nil) {
                            self.isEnabled = isEnabled
                            self.options = options
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(isEnabled, forKey: "enabled")
                            encoder.encode(options, forKey: "options")
                            return encoder.items
                        }
                    }

                    public enum Mode: String, Codable, CaseIterable {
                        case atPeriodEnd = "at_period_end"
                        case immediately
                    }

                    public enum ProrationBehavior: String, Codable, CaseIterable {
                        case alwaysInvoice = "always_invoice"
                        case createProrations = "create_prorations"
                        case `none`
                    }

                    public init(cancellationReason: CancellationReason? = nil, isEnabled: Bool? = nil, mode: Mode? = nil, prorationBehavior: ProrationBehavior? = nil) {
                        self.cancellationReason = cancellationReason
                        self.isEnabled = isEnabled
                        self.mode = mode
                        self.prorationBehavior = prorationBehavior
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(cancellationReason, forKey: "cancellation_reason")
                        encoder.encode(isEnabled, forKey: "enabled")
                        encoder.encode(mode, forKey: "mode")
                        encoder.encode(prorationBehavior, forKey: "proration_behavior")
                        return encoder.items
                    }
                }

                /// Subscription_pause_param
                public struct SubscriptionPause: Encodable {
                    public var isEnabled: Bool?

                    public init(isEnabled: Bool? = nil) {
                        self.isEnabled = isEnabled
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isEnabled, forKey: "enabled")
                        return encoder.items
                    }
                }

                /// Subscription_update_updating_param
                public struct SubscriptionUpdate: Encodable {
                    public var defaultAllowedUpdates: DefaultAllowedUpdates?
                    public var isEnabled: Bool?
                    public var products: Products?
                    public var prorationBehavior: ProrationBehavior?

                    public struct DefaultAllowedUpdates: Encodable {
                        public var placeholderItems: [PlaceholderItem]?
                        public var object: Object?

                        public enum PlaceholderItem: String, Codable, CaseIterable {
                            case price
                            case promotionCode = "promotion_code"
                            case quantity
                        }

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                            self.placeholderItems = placeholderItems
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(placeholderItems, forKey: "placeholderItems")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public struct Products: Encodable {
                        public var placeholderItems: [PlaceholderItem]?
                        public var object: Object?

                        /// Subscription_update_product_param
                        public struct PlaceholderItem: Encodable {
                            public var prices: [String]
                            public var product: String

                            public init(prices: [String], product: String) {
                                self.prices = prices
                                self.product = product
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(prices, forKey: "prices")
                                encoder.encode(product, forKey: "product")
                                return encoder.items
                            }
                        }

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                            self.placeholderItems = placeholderItems
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(placeholderItems, forKey: "placeholderItems")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public enum ProrationBehavior: String, Codable, CaseIterable {
                        case alwaysInvoice = "always_invoice"
                        case createProrations = "create_prorations"
                        case `none`
                    }

                    public init(defaultAllowedUpdates: DefaultAllowedUpdates? = nil, isEnabled: Bool? = nil, products: Products? = nil, prorationBehavior: ProrationBehavior? = nil) {
                        self.defaultAllowedUpdates = defaultAllowedUpdates
                        self.isEnabled = isEnabled
                        self.products = products
                        self.prorationBehavior = prorationBehavior
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(defaultAllowedUpdates, forKey: "default_allowed_updates")
                        encoder.encode(isEnabled, forKey: "enabled")
                        encoder.encode(products, forKey: "products")
                        encoder.encode(prorationBehavior, forKey: "proration_behavior")
                        return encoder.items
                    }
                }

                public init(customerUpdate: CustomerUpdate? = nil, invoiceHistory: InvoiceHistory? = nil, paymentMethodUpdate: PaymentMethodUpdate? = nil, subscriptionCancel: SubscriptionCancel? = nil, subscriptionPause: SubscriptionPause? = nil, subscriptionUpdate: SubscriptionUpdate? = nil) {
                    self.customerUpdate = customerUpdate
                    self.invoiceHistory = invoiceHistory
                    self.paymentMethodUpdate = paymentMethodUpdate
                    self.subscriptionCancel = subscriptionCancel
                    self.subscriptionPause = subscriptionPause
                    self.subscriptionUpdate = subscriptionUpdate
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(customerUpdate, forKey: "customer_update")
                    encoder.encode(invoiceHistory, forKey: "invoice_history")
                    encoder.encode(paymentMethodUpdate, forKey: "payment_method_update")
                    encoder.encode(subscriptionCancel, forKey: "subscription_cancel")
                    encoder.encode(subscriptionPause, forKey: "subscription_pause")
                    encoder.encode(subscriptionUpdate, forKey: "subscription_update")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(isActive: Bool? = nil, businessProfile: BusinessProfile? = nil, defaultReturnURL: DefaultReturnURL? = nil, expand: [String]? = nil, features: Features? = nil, metadata: Metadata? = nil) {
                self.isActive = isActive
                self.businessProfile = businessProfile
                self.defaultReturnURL = defaultReturnURL
                self.expand = expand
                self.features = features
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(businessProfile, forKey: "business_profile")
                encoder.encode(defaultReturnURL, forKey: "default_return_url")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(features, forKey: "features")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths.BillingPortal {
    public var sessions: Sessions {
        Sessions(path: path + "/sessions")
    }

    public struct Sessions {
        /// Path: `/v1/billing_portal/sessions`
        public let path: String

        /// <p>Creates a session of the customer portal.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.BillingPortalSession> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The ID of an existing [configuration](https://stripe.com/docs/api/customer_portal/configuration) to use for this session, describing its functionality and features. If not specified, the session uses the default configuration.
            public var configuration: String?
            /// The ID of an existing customer.
            public var customer: String
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The IETF language tag of the locale Customer Portal is displayed in. If blank or auto, the customer’s `preferred_locales` or browser’s locale is used.
            public var locale: Locale?
            /// The `on_behalf_of` account to use for this session. When specified, only subscriptions and invoices with this `on_behalf_of` account appear in the portal. For more information, see the [docs](https://stripe.com/docs/connect/charges-transfers#on-behalf-of). Use the [Accounts API](https://stripe.com/docs/api/accounts/object#account_object-settings-branding) to modify the `on_behalf_of` account's branding settings, which the portal displays.
            public var onBehalfOf: String?
            /// The default URL to redirect customers to when they click on the portal's link to return to your website.
            public var returnURL: String?

            /// The IETF language tag of the locale Customer Portal is displayed in. If blank or auto, the customer’s `preferred_locales` or browser’s locale is used.
            public enum Locale: String, Codable, CaseIterable {
                case auto
                case bg
                case cs
                case da
                case de
                case el
                case en
                case enAU = "en-AU"
                case enCA = "en-CA"
                case enGB = "en-GB"
                case enIE = "en-IE"
                case enIN = "en-IN"
                case enNZ = "en-NZ"
                case enSG = "en-SG"
                case es
                case es419 = "es-419"
                case et
                case fi
                case fil
                case fr
                case frCA = "fr-CA"
                case hr
                case hu
                case id
                case it
                case ja
                case ko
                case lt
                case lv
                case ms
                case mt
                case nb
                case nl
                case pl
                case pt
                case ptBR = "pt-BR"
                case ro
                case ru
                case sk
                case sl
                case sv
                case th
                case tr
                case vi
                case zh
                case zhHK = "zh-HK"
                case zhTW = "zh-TW"
            }

            public init(configuration: String? = nil, customer: String, expand: [String]? = nil, locale: Locale? = nil, onBehalfOf: String? = nil, returnURL: String? = nil) {
                self.configuration = configuration
                self.customer = customer
                self.expand = expand
                self.locale = locale
                self.onBehalfOf = onBehalfOf
                self.returnURL = returnURL
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(configuration, forKey: "configuration")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(locale, forKey: "locale")
                encoder.encode(onBehalfOf, forKey: "on_behalf_of")
                encoder.encode(returnURL, forKey: "return_url")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var bitcoin: Bitcoin {
        Bitcoin(path: "/v1/bitcoin")
    }

    public struct Bitcoin {
        /// Path: `/v1/bitcoin`
        public let path: String
    }
}

extension Paths.Bitcoin {
    public var receivers: Receivers {
        Receivers(path: path + "/receivers")
    }

    public struct Receivers {
        /// Path: `/v1/bitcoin/receivers`
        public let path: String

        /// <p>Returns a list of your receivers. Receivers are returned sorted by creation date, with the most recently created receivers appearing first.</p>
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.BitcoinReceiver]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.BitcoinReceiver], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var isActive: Bool?
            public var endingBefore: String?
            public var expand: [String]?
            public var isFilled: Bool?
            public var limit: Int?
            public var startingAfter: String?
            public var isUncapturedFunds: Bool?

            public init(isActive: Bool? = nil, endingBefore: String? = nil, expand: [String]? = nil, isFilled: Bool? = nil, limit: Int? = nil, startingAfter: String? = nil, isUncapturedFunds: Bool? = nil) {
                self.isActive = isActive
                self.endingBefore = endingBefore
                self.expand = expand
                self.isFilled = isFilled
                self.limit = limit
                self.startingAfter = startingAfter
                self.isUncapturedFunds = isUncapturedFunds
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(isFilled, forKey: "filled")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(isUncapturedFunds, forKey: "uncaptured_funds")
                return encoder.items
            }
        }
    }
}

extension Paths.Bitcoin.Receivers {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/bitcoin/receivers/{id}`
        public let path: String

        /// <p>Retrieves the Bitcoin receiver with the given ID.</p>
        @available(*, deprecated, message: "Deprecated")
        public func get(expand: [String]? = nil) -> Request<StripeAPI.BitcoinReceiver> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths.Bitcoin.Receivers {
    public func receiver(_ receiver: String) -> WithReceiver {
        WithReceiver(path: "\(path)/\(receiver)")
    }

    public struct WithReceiver {
        /// Path: `/v1/bitcoin/receivers/{receiver}`
        public let path: String
    }
}

extension Paths.Bitcoin.Receivers.WithReceiver {
    public var transactions: Transactions {
        Transactions(path: path + "/transactions")
    }

    public struct Transactions {
        /// Path: `/v1/bitcoin/receivers/{receiver}/transactions`
        public let path: String

        /// <p>List bitcoin transacitons for a given receiver.</p>
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// BitcoinTransactionList
        public struct GetResponse: Decodable {
            /// Details about each object.
            public var data: [StripeAPI.BitcoinTransaction]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.BitcoinTransaction], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var customer: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(customer: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.customer = customer
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(customer, forKey: "customer")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }
    }
}

extension Paths.Bitcoin {
    public var transactions: Transactions {
        Transactions(path: path + "/transactions")
    }

    public struct Transactions {
        /// Path: `/v1/bitcoin/transactions`
        public let path: String

        /// <p>List bitcoin transacitons for a given receiver.</p>
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// BitcoinTransactionList
        public struct GetResponse: Decodable {
            /// Details about each object.
            public var data: [StripeAPI.BitcoinTransaction]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.BitcoinTransaction], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var customer: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var receiver: String?
            public var startingAfter: String?

            public init(customer: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, receiver: String? = nil, startingAfter: String? = nil) {
                self.customer = customer
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.receiver = receiver
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(customer, forKey: "customer")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(receiver, forKey: "receiver")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var charges: Charges {
        Charges(path: "/v1/charges")
    }

    public struct Charges {
        /// Path: `/v1/charges`
        public let path: String

        /// <p>Returns a list of charges you’ve previously created. The charges are returned in sorted order, with the most recent charges appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Charge]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Charge], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var customer: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var paymentIntent: String?
            public var startingAfter: String?
            public var transferGroup: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(created: Created? = nil, customer: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, paymentIntent: String? = nil, startingAfter: String? = nil, transferGroup: String? = nil) {
                self.created = created
                self.customer = customer
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.paymentIntent = paymentIntent
                self.startingAfter = startingAfter
                self.transferGroup = transferGroup
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(customer, forKey: "customer")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(paymentIntent, forKey: "payment_intent")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(transferGroup, forKey: "transfer_group")
                return encoder.items
            }
        }

        /// <p>To charge a credit card or other payment source, you create a <code>Charge</code> object. If your API key is in test mode, the supplied payment source (e.g., card) won’t actually be charged, although everything else will occur as if in live mode. (Stripe assumes that the charge would have completed successfully).</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Charge> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Amount intended to be collected by this payment. A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum amount is $0.50 US or [equivalent in charge currency](https://stripe.com/docs/currencies#minimum-and-maximum-charge-amounts). The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of $999,999.99).
            public var amount: Int?
            public var applicationFee: Int?
            /// A fee in %s that will be applied to the charge and transferred to the application owner's Stripe account. The request must be made with an OAuth key or the `Stripe-Account` header in order to take an application fee. For more information, see the application fees [documentation](https://stripe.com/docs/connect/direct-charges#collecting-fees).
            public var applicationFeeAmount: Int?
            /// Whether to immediately capture the charge. Defaults to `true`. When `false`, the charge issues an authorization (or pre-authorization), and will need to be [captured](https://stripe.com/docs/api#capture_charge) later. Uncaptured charges expire after a set number of days (7 by default). For more information, see the [authorizing charges and settling later](https://stripe.com/docs/charges/placing-a-hold) documentation.
            public var isCapture: Bool?
            /// A token, like the ones returned by [Stripe.js](https://stripe.com/docs/js).
            public var card: Card?
            /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
            public var currency: String?
            /// The ID of an existing customer that will be charged in this request.
            public var customer: String?
            /// An arbitrary string which you can attach to a `Charge` object. It is displayed when in the web interface alongside the charge. Note that if you use Stripe to send automatic email receipts to your customers, your receipt emails will include the `description` of the charge(s) that they are describing.
            public var description: String?
            public var destination: Destination?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The Stripe account ID for which these funds are intended. Automatically set if you use the `destination` parameter. For details, see [Creating Separate Charges and Transfers](https://stripe.com/docs/connect/charges-transfers#on-behalf-of).
            public var onBehalfOf: String?
            /// The email address to which this charge's [receipt](https://stripe.com/docs/dashboard/receipts) will be sent. The receipt will not be sent until the charge is paid, and no receipts will be sent for test mode charges. If this charge is for a [Customer](https://stripe.com/docs/api/customers/object), the email address specified here will override the customer's email address. If `receipt_email` is specified for a charge in live mode, a receipt will be sent regardless of your [email settings](https://dashboard.stripe.com/account/emails).
            public var receiptEmail: String?
            /// Optional_fields_shipping
            ///
            /// Shipping information for the charge. Helps prevent fraud on charges for physical goods.
            public var shipping: Shipping?
            /// A payment source to be charged. This can be the ID of a [card](https://stripe.com/docs/api#cards) (i.e., credit or debit card), a [bank account](https://stripe.com/docs/api#bank_accounts), a [source](https://stripe.com/docs/api#sources), a [token](https://stripe.com/docs/api#tokens), or a [connected account](https://stripe.com/docs/connect/account-debits#charging-a-connected-account). For certain sources---namely, [cards](https://stripe.com/docs/api#cards), [bank accounts](https://stripe.com/docs/api#bank_accounts), and attached [sources](https://stripe.com/docs/api#sources)---you must also pass the ID of the associated customer.
            public var source: String?
            /// For card charges, use `statement_descriptor_suffix` instead. Otherwise, you can use this value as the complete description of a charge on your customers’ statements. Must contain at least one letter, maximum 22 characters.
            public var statementDescriptor: String?
            /// Provides information about the charge that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
            public var statementDescriptorSuffix: String?
            /// Transfer_data_specs
            ///
            /// An optional dictionary including the account to automatically transfer to as part of a destination charge. [See the Connect documentation](https://stripe.com/docs/connect/destination-charges) for details.
            public var transferData: TransferData?
            /// A string that identifies this transaction as part of a group. For details, see [Grouping transactions](https://stripe.com/docs/connect/charges-transfers#transfer-options).
            public var transferGroup: String?

            /// A token, like the ones returned by [Stripe.js](https://stripe.com/docs/js).
            public struct Card: Encodable {
                /// Customer_payment_source_card
                public var object: Object?
                public var string: String?

                /// Customer_payment_source_card
                public struct Object: Encodable {
                    public var addressCity: String?
                    public var addressCountry: String?
                    public var addressLine1: String?
                    public var addressLine2: String?
                    public var addressState: String?
                    public var addressZip: String?
                    public var cvc: String?
                    public var expMonth: Int
                    public var expYear: Int
                    public var metadata: [String: String]?
                    public var name: String?
                    public var number: String
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case card
                    }

                    public init(addressCity: String? = nil, addressCountry: String? = nil, addressLine1: String? = nil, addressLine2: String? = nil, addressState: String? = nil, addressZip: String? = nil, cvc: String? = nil, expMonth: Int, expYear: Int, metadata: [String: String]? = nil, name: String? = nil, number: String, object: Object? = nil) {
                        self.addressCity = addressCity
                        self.addressCountry = addressCountry
                        self.addressLine1 = addressLine1
                        self.addressLine2 = addressLine2
                        self.addressState = addressState
                        self.addressZip = addressZip
                        self.cvc = cvc
                        self.expMonth = expMonth
                        self.expYear = expYear
                        self.metadata = metadata
                        self.name = name
                        self.number = number
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(addressCity, forKey: "address_city")
                        encoder.encode(addressCountry, forKey: "address_country")
                        encoder.encode(addressLine1, forKey: "address_line1")
                        encoder.encode(addressLine2, forKey: "address_line2")
                        encoder.encode(addressState, forKey: "address_state")
                        encoder.encode(addressZip, forKey: "address_zip")
                        encoder.encode(cvc, forKey: "cvc")
                        encoder.encode(expMonth, forKey: "exp_month")
                        encoder.encode(expYear, forKey: "exp_year")
                        encoder.encode(metadata, forKey: "metadata")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(number, forKey: "number")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, string: String? = nil) {
                    self.object = object
                    self.string = string
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(string, forKey: "string")
                    return encoder.items
                }
            }

            public struct Destination: Encodable {
                /// Destination_specs
                public var object: Object?
                public var string: String?

                /// Destination_specs
                public struct Object: Encodable {
                    public var account: String
                    public var amount: Int?

                    public init(account: String, amount: Int? = nil) {
                        self.account = account
                        self.amount = amount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(account, forKey: "account")
                        encoder.encode(amount, forKey: "amount")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, string: String? = nil) {
                    self.object = object
                    self.string = string
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(string, forKey: "string")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Optional_fields_shipping
            ///
            /// Shipping information for the charge. Helps prevent fraud on charges for physical goods.
            public struct Shipping: Encodable {
                /// Optional_fields_address
                public var address: Address
                public var carrier: String?
                public var name: String
                public var phone: String?
                public var trackingNumber: String?

                /// Optional_fields_address
                public struct Address: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                public init(address: Address, carrier: String? = nil, name: String, phone: String? = nil, trackingNumber: String? = nil) {
                    self.address = address
                    self.carrier = carrier
                    self.name = name
                    self.phone = phone
                    self.trackingNumber = trackingNumber
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(carrier, forKey: "carrier")
                    encoder.encode(name, forKey: "name")
                    encoder.encode(phone, forKey: "phone")
                    encoder.encode(trackingNumber, forKey: "tracking_number")
                    return encoder.items
                }
            }

            /// Transfer_data_specs
            ///
            /// An optional dictionary including the account to automatically transfer to as part of a destination charge. [See the Connect documentation](https://stripe.com/docs/connect/destination-charges) for details.
            public struct TransferData: Encodable {
                public var amount: Int?
                public var destination: String

                public init(amount: Int? = nil, destination: String) {
                    self.amount = amount
                    self.destination = destination
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(amount, forKey: "amount")
                    encoder.encode(destination, forKey: "destination")
                    return encoder.items
                }
            }

            public init(amount: Int? = nil, applicationFee: Int? = nil, applicationFeeAmount: Int? = nil, isCapture: Bool? = nil, card: Card? = nil, currency: String? = nil, customer: String? = nil, description: String? = nil, destination: Destination? = nil, expand: [String]? = nil, metadata: Metadata? = nil, onBehalfOf: String? = nil, receiptEmail: String? = nil, shipping: Shipping? = nil, source: String? = nil, statementDescriptor: String? = nil, statementDescriptorSuffix: String? = nil, transferData: TransferData? = nil, transferGroup: String? = nil) {
                self.amount = amount
                self.applicationFee = applicationFee
                self.applicationFeeAmount = applicationFeeAmount
                self.isCapture = isCapture
                self.card = card
                self.currency = currency
                self.customer = customer
                self.description = description
                self.destination = destination
                self.expand = expand
                self.metadata = metadata
                self.onBehalfOf = onBehalfOf
                self.receiptEmail = receiptEmail
                self.shipping = shipping
                self.source = source
                self.statementDescriptor = statementDescriptor
                self.statementDescriptorSuffix = statementDescriptorSuffix
                self.transferData = transferData
                self.transferGroup = transferGroup
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(applicationFee, forKey: "application_fee")
                encoder.encode(applicationFeeAmount, forKey: "application_fee_amount")
                encoder.encode(isCapture, forKey: "capture")
                encoder.encode(card, forKey: "card")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(description, forKey: "description")
                encoder.encode(destination, forKey: "destination")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(onBehalfOf, forKey: "on_behalf_of")
                encoder.encode(receiptEmail, forKey: "receipt_email")
                encoder.encode(shipping, forKey: "shipping")
                encoder.encode(source, forKey: "source")
                encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                encoder.encode(statementDescriptorSuffix, forKey: "statement_descriptor_suffix")
                encoder.encode(transferData, forKey: "transfer_data")
                encoder.encode(transferGroup, forKey: "transfer_group")
                return encoder.items
            }
        }
    }
}

extension Paths.Charges {
    public func charge(_ charge: String) -> WithCharge {
        WithCharge(path: "\(path)/\(charge)")
    }

    public struct WithCharge {
        /// Path: `/v1/charges/{charge}`
        public let path: String

        /// <p>Retrieves the details of a charge that has previously been created. Supply the unique charge ID that was returned from your previous request, and Stripe will return the corresponding charge information. The same information is returned when creating or refunding the charge.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Charge> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the specified charge by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Charge> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The ID of an existing customer that will be associated with this request. This field may only be updated if there is no existing associated customer with this charge.
            public var customer: String?
            /// An arbitrary string which you can attach to a charge object. It is displayed when in the web interface alongside the charge. Note that if you use Stripe to send automatic email receipts to your customers, your receipt emails will include the `description` of the charge(s) that they are describing.
            public var description: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Fraud_details
            ///
            /// A set of key-value pairs you can attach to a charge giving information about its riskiness. If you believe a charge is fraudulent, include a `user_report` key with a value of `fraudulent`. If you believe a charge is safe, include a `user_report` key with a value of `safe`. Stripe will use the information you send to improve our fraud detection algorithms.
            public var fraudDetails: FraudDetails?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// This is the email address that the receipt for this charge will be sent to. If this field is updated, then a new email receipt will be sent to the updated address.
            public var receiptEmail: String?
            /// Optional_fields_shipping
            ///
            /// Shipping information for the charge. Helps prevent fraud on charges for physical goods.
            public var shipping: Shipping?
            /// A string that identifies this transaction as part of a group. `transfer_group` may only be provided if it has not been set. See the [Connect documentation](https://stripe.com/docs/connect/charges-transfers#transfer-options) for details.
            public var transferGroup: String?

            /// Fraud_details
            ///
            /// A set of key-value pairs you can attach to a charge giving information about its riskiness. If you believe a charge is fraudulent, include a `user_report` key with a value of `fraudulent`. If you believe a charge is safe, include a `user_report` key with a value of `safe`. Stripe will use the information you send to improve our fraud detection algorithms.
            public struct FraudDetails: Encodable {
                public var userReport: UserReport

                public enum UserReport: String, Codable, CaseIterable {
                    case empty = ""
                    case fraudulent
                    case safe
                }

                public init(userReport: UserReport) {
                    self.userReport = userReport
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(userReport, forKey: "user_report")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Optional_fields_shipping
            ///
            /// Shipping information for the charge. Helps prevent fraud on charges for physical goods.
            public struct Shipping: Encodable {
                /// Optional_fields_address
                public var address: Address
                public var carrier: String?
                public var name: String
                public var phone: String?
                public var trackingNumber: String?

                /// Optional_fields_address
                public struct Address: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                public init(address: Address, carrier: String? = nil, name: String, phone: String? = nil, trackingNumber: String? = nil) {
                    self.address = address
                    self.carrier = carrier
                    self.name = name
                    self.phone = phone
                    self.trackingNumber = trackingNumber
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(carrier, forKey: "carrier")
                    encoder.encode(name, forKey: "name")
                    encoder.encode(phone, forKey: "phone")
                    encoder.encode(trackingNumber, forKey: "tracking_number")
                    return encoder.items
                }
            }

            public init(customer: String? = nil, description: String? = nil, expand: [String]? = nil, fraudDetails: FraudDetails? = nil, metadata: Metadata? = nil, receiptEmail: String? = nil, shipping: Shipping? = nil, transferGroup: String? = nil) {
                self.customer = customer
                self.description = description
                self.expand = expand
                self.fraudDetails = fraudDetails
                self.metadata = metadata
                self.receiptEmail = receiptEmail
                self.shipping = shipping
                self.transferGroup = transferGroup
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(customer, forKey: "customer")
                encoder.encode(description, forKey: "description")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(fraudDetails, forKey: "fraud_details")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(receiptEmail, forKey: "receipt_email")
                encoder.encode(shipping, forKey: "shipping")
                encoder.encode(transferGroup, forKey: "transfer_group")
                return encoder.items
            }
        }
    }
}

extension Paths.Charges.WithCharge {
    public var capture: Capture {
        Capture(path: path + "/capture")
    }

    public struct Capture {
        /// Path: `/v1/charges/{charge}/capture`
        public let path: String

        /// <p>Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you <a href="#create_charge">created a charge</a> with the capture option set to false.</p>
        /// 
        /// <p>Uncaptured payments expire a set number of days after they are created (<a href="/docs/charges/placing-a-hold">7 by default</a>). If they are not captured by that point in time, they will be marked as refunded and will no longer be capturable.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Charge> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The amount to capture, which must be less than or equal to the original amount. Any additional amount will be automatically refunded.
            public var amount: Int?
            /// An application fee to add on to this charge.
            public var applicationFee: Int?
            /// An application fee amount to add on to this charge, which must be less than or equal to the original amount.
            public var applicationFeeAmount: Int?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The email address to send this charge's receipt to. This will override the previously-specified email address for this charge, if one was set. Receipts will not be sent in test mode.
            public var receiptEmail: String?
            /// For card charges, use `statement_descriptor_suffix` instead. Otherwise, you can use this value as the complete description of a charge on your customers’ statements. Must contain at least one letter, maximum 22 characters.
            public var statementDescriptor: String?
            /// Provides information about the charge that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
            public var statementDescriptorSuffix: String?
            /// Transfer_data_specs
            ///
            /// An optional dictionary including the account to automatically transfer to as part of a destination charge. [See the Connect documentation](https://stripe.com/docs/connect/destination-charges) for details.
            public var transferData: TransferData?
            /// A string that identifies this transaction as part of a group. `transfer_group` may only be provided if it has not been set. See the [Connect documentation](https://stripe.com/docs/connect/charges-transfers#transfer-options) for details.
            public var transferGroup: String?

            /// Transfer_data_specs
            ///
            /// An optional dictionary including the account to automatically transfer to as part of a destination charge. [See the Connect documentation](https://stripe.com/docs/connect/destination-charges) for details.
            public struct TransferData: Encodable {
                public var amount: Int?

                public init(amount: Int? = nil) {
                    self.amount = amount
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(amount, forKey: "amount")
                    return encoder.items
                }
            }

            public init(amount: Int? = nil, applicationFee: Int? = nil, applicationFeeAmount: Int? = nil, expand: [String]? = nil, receiptEmail: String? = nil, statementDescriptor: String? = nil, statementDescriptorSuffix: String? = nil, transferData: TransferData? = nil, transferGroup: String? = nil) {
                self.amount = amount
                self.applicationFee = applicationFee
                self.applicationFeeAmount = applicationFeeAmount
                self.expand = expand
                self.receiptEmail = receiptEmail
                self.statementDescriptor = statementDescriptor
                self.statementDescriptorSuffix = statementDescriptorSuffix
                self.transferData = transferData
                self.transferGroup = transferGroup
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(applicationFee, forKey: "application_fee")
                encoder.encode(applicationFeeAmount, forKey: "application_fee_amount")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(receiptEmail, forKey: "receipt_email")
                encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                encoder.encode(statementDescriptorSuffix, forKey: "statement_descriptor_suffix")
                encoder.encode(transferData, forKey: "transfer_data")
                encoder.encode(transferGroup, forKey: "transfer_group")
                return encoder.items
            }
        }
    }
}

extension Paths.Charges.WithCharge {
    public var dispute: Dispute {
        Dispute(path: path + "/dispute")
    }

    public struct Dispute {
        /// Path: `/v1/charges/{charge}/dispute`
        public let path: String

        /// <p>Retrieve a dispute for a specified charge.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Dispute> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Dispute> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Dispute_evidence_params
            ///
            /// Evidence to upload, to respond to a dispute. Updating any field in the hash will submit all fields in the hash for review. The combined character count of all fields is limited to 150,000.
            public var evidence: Evidence?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// Whether to immediately submit evidence to the bank. If `false`, evidence is staged on the dispute. Staged evidence is visible in the API and Dashboard, and can be submitted to the bank by making another request with this attribute set to `true` (the default).
            public var isSubmit: Bool?

            /// Dispute_evidence_params
            ///
            /// Evidence to upload, to respond to a dispute. Updating any field in the hash will submit all fields in the hash for review. The combined character count of all fields is limited to 150,000.
            public struct Evidence: Encodable {
                public var accessActivityLog: String?
                public var billingAddress: String?
                public var cancellationPolicy: String?
                public var cancellationPolicyDisclosure: String?
                public var cancellationRebuttal: String?
                public var customerCommunication: String?
                public var customerEmailAddress: String?
                public var customerName: String?
                public var customerPurchaseIp: String?
                public var customerSignature: String?
                public var duplicateChargeDocumentation: String?
                public var duplicateChargeExplanation: String?
                public var duplicateChargeID: String?
                public var productDescription: String?
                public var receipt: String?
                public var refundPolicy: String?
                public var refundPolicyDisclosure: String?
                public var refundRefusalExplanation: String?
                public var serviceDate: String?
                public var serviceDocumentation: String?
                public var shippingAddress: String?
                public var shippingCarrier: String?
                public var shippingDate: String?
                public var shippingDocumentation: String?
                public var shippingTrackingNumber: String?
                public var uncategorizedFile: String?
                public var uncategorizedText: String?

                public init(accessActivityLog: String? = nil, billingAddress: String? = nil, cancellationPolicy: String? = nil, cancellationPolicyDisclosure: String? = nil, cancellationRebuttal: String? = nil, customerCommunication: String? = nil, customerEmailAddress: String? = nil, customerName: String? = nil, customerPurchaseIp: String? = nil, customerSignature: String? = nil, duplicateChargeDocumentation: String? = nil, duplicateChargeExplanation: String? = nil, duplicateChargeID: String? = nil, productDescription: String? = nil, receipt: String? = nil, refundPolicy: String? = nil, refundPolicyDisclosure: String? = nil, refundRefusalExplanation: String? = nil, serviceDate: String? = nil, serviceDocumentation: String? = nil, shippingAddress: String? = nil, shippingCarrier: String? = nil, shippingDate: String? = nil, shippingDocumentation: String? = nil, shippingTrackingNumber: String? = nil, uncategorizedFile: String? = nil, uncategorizedText: String? = nil) {
                    self.accessActivityLog = accessActivityLog
                    self.billingAddress = billingAddress
                    self.cancellationPolicy = cancellationPolicy
                    self.cancellationPolicyDisclosure = cancellationPolicyDisclosure
                    self.cancellationRebuttal = cancellationRebuttal
                    self.customerCommunication = customerCommunication
                    self.customerEmailAddress = customerEmailAddress
                    self.customerName = customerName
                    self.customerPurchaseIp = customerPurchaseIp
                    self.customerSignature = customerSignature
                    self.duplicateChargeDocumentation = duplicateChargeDocumentation
                    self.duplicateChargeExplanation = duplicateChargeExplanation
                    self.duplicateChargeID = duplicateChargeID
                    self.productDescription = productDescription
                    self.receipt = receipt
                    self.refundPolicy = refundPolicy
                    self.refundPolicyDisclosure = refundPolicyDisclosure
                    self.refundRefusalExplanation = refundRefusalExplanation
                    self.serviceDate = serviceDate
                    self.serviceDocumentation = serviceDocumentation
                    self.shippingAddress = shippingAddress
                    self.shippingCarrier = shippingCarrier
                    self.shippingDate = shippingDate
                    self.shippingDocumentation = shippingDocumentation
                    self.shippingTrackingNumber = shippingTrackingNumber
                    self.uncategorizedFile = uncategorizedFile
                    self.uncategorizedText = uncategorizedText
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(accessActivityLog, forKey: "access_activity_log")
                    encoder.encode(billingAddress, forKey: "billing_address")
                    encoder.encode(cancellationPolicy, forKey: "cancellation_policy")
                    encoder.encode(cancellationPolicyDisclosure, forKey: "cancellation_policy_disclosure")
                    encoder.encode(cancellationRebuttal, forKey: "cancellation_rebuttal")
                    encoder.encode(customerCommunication, forKey: "customer_communication")
                    encoder.encode(customerEmailAddress, forKey: "customer_email_address")
                    encoder.encode(customerName, forKey: "customer_name")
                    encoder.encode(customerPurchaseIp, forKey: "customer_purchase_ip")
                    encoder.encode(customerSignature, forKey: "customer_signature")
                    encoder.encode(duplicateChargeDocumentation, forKey: "duplicate_charge_documentation")
                    encoder.encode(duplicateChargeExplanation, forKey: "duplicate_charge_explanation")
                    encoder.encode(duplicateChargeID, forKey: "duplicate_charge_id")
                    encoder.encode(productDescription, forKey: "product_description")
                    encoder.encode(receipt, forKey: "receipt")
                    encoder.encode(refundPolicy, forKey: "refund_policy")
                    encoder.encode(refundPolicyDisclosure, forKey: "refund_policy_disclosure")
                    encoder.encode(refundRefusalExplanation, forKey: "refund_refusal_explanation")
                    encoder.encode(serviceDate, forKey: "service_date")
                    encoder.encode(serviceDocumentation, forKey: "service_documentation")
                    encoder.encode(shippingAddress, forKey: "shipping_address")
                    encoder.encode(shippingCarrier, forKey: "shipping_carrier")
                    encoder.encode(shippingDate, forKey: "shipping_date")
                    encoder.encode(shippingDocumentation, forKey: "shipping_documentation")
                    encoder.encode(shippingTrackingNumber, forKey: "shipping_tracking_number")
                    encoder.encode(uncategorizedFile, forKey: "uncategorized_file")
                    encoder.encode(uncategorizedText, forKey: "uncategorized_text")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(evidence: Evidence? = nil, expand: [String]? = nil, metadata: Metadata? = nil, isSubmit: Bool? = nil) {
                self.evidence = evidence
                self.expand = expand
                self.metadata = metadata
                self.isSubmit = isSubmit
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(evidence, forKey: "evidence")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(isSubmit, forKey: "submit")
                return encoder.items
            }
        }
    }
}

extension Paths.Charges.WithCharge.Dispute {
    public var close: Close {
        Close(path: path + "/close")
    }

    public struct Close {
        /// Path: `/v1/charges/{charge}/dispute/close`
        public let path: String

        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Dispute> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(expand: [String]? = nil) {
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.Charges.WithCharge {
    public var refund: Refund {
        Refund(path: path + "/refund")
    }

    public struct Refund {
        /// Path: `/v1/charges/{charge}/refund`
        public let path: String

        /// <p>When you create a new refund, you must specify a Charge or a PaymentIntent object on which to create it.</p>
        /// 
        /// <p>Creating a new refund will refund a charge that has previously been created but not yet refunded.
        /// Funds will be refunded to the credit or debit card that was originally charged.</p>
        /// 
        /// <p>You can optionally refund only part of a charge.
        /// You can do so multiple times, until the entire charge has been refunded.</p>
        /// 
        /// <p>Once entirely refunded, a charge can’t be refunded again.
        /// This method will raise an error when called on an already-refunded charge,
        /// or when trying to refund more money than is left on a charge.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Charge> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            public var amount: Int?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            public var paymentIntent: String?
            public var reason: Reason?
            public var isRefundApplicationFee: Bool?
            public var isReverseTransfer: Bool?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public enum Reason: String, Codable, CaseIterable {
                case duplicate
                case fraudulent
                case requestedByCustomer = "requested_by_customer"
            }

            public init(amount: Int? = nil, expand: [String]? = nil, metadata: Metadata? = nil, paymentIntent: String? = nil, reason: Reason? = nil, isRefundApplicationFee: Bool? = nil, isReverseTransfer: Bool? = nil) {
                self.amount = amount
                self.expand = expand
                self.metadata = metadata
                self.paymentIntent = paymentIntent
                self.reason = reason
                self.isRefundApplicationFee = isRefundApplicationFee
                self.isReverseTransfer = isReverseTransfer
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(paymentIntent, forKey: "payment_intent")
                encoder.encode(reason, forKey: "reason")
                encoder.encode(isRefundApplicationFee, forKey: "refund_application_fee")
                encoder.encode(isReverseTransfer, forKey: "reverse_transfer")
                return encoder.items
            }
        }
    }
}

extension Paths.Charges.WithCharge {
    public var refunds: Refunds {
        Refunds(path: path + "/refunds")
    }

    public struct Refunds {
        /// Path: `/v1/charges/{charge}/refunds`
        public let path: String

        /// <p>You can see a list of the refunds belonging to a specific charge. Note that the 10 most recent refunds are always available by default on the charge object. If you need more than those 10, you can use this API method and the <code>limit</code> and <code>starting_after</code> parameters to page through additional refunds.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// RefundList
        public struct GetResponse: Decodable {
            /// Details about each object.
            public var data: [StripeAPI.Refund]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Refund], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Create a refund.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Refund> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            public var amount: Int?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            public var paymentIntent: String?
            public var reason: Reason?
            public var isRefundApplicationFee: Bool?
            public var isReverseTransfer: Bool?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public enum Reason: String, Codable, CaseIterable {
                case duplicate
                case fraudulent
                case requestedByCustomer = "requested_by_customer"
            }

            public init(amount: Int? = nil, expand: [String]? = nil, metadata: Metadata? = nil, paymentIntent: String? = nil, reason: Reason? = nil, isRefundApplicationFee: Bool? = nil, isReverseTransfer: Bool? = nil) {
                self.amount = amount
                self.expand = expand
                self.metadata = metadata
                self.paymentIntent = paymentIntent
                self.reason = reason
                self.isRefundApplicationFee = isRefundApplicationFee
                self.isReverseTransfer = isReverseTransfer
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(paymentIntent, forKey: "payment_intent")
                encoder.encode(reason, forKey: "reason")
                encoder.encode(isRefundApplicationFee, forKey: "refund_application_fee")
                encoder.encode(isReverseTransfer, forKey: "reverse_transfer")
                return encoder.items
            }
        }
    }
}

extension Paths.Charges.WithCharge.Refunds {
    public func refund(_ refund: String) -> WithRefund {
        WithRefund(path: "\(path)/\(refund)")
    }

    public struct WithRefund {
        /// Path: `/v1/charges/{charge}/refunds/{refund}`
        public let path: String

        /// <p>Retrieves the details of an existing refund.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Refund> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Update a specified refund.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Refund> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            public var metadata: Metadata?

            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(expand: [String]? = nil, metadata: Metadata? = nil) {
                self.expand = expand
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var checkout: Checkout {
        Checkout(path: "/v1/checkout")
    }

    public struct Checkout {
        /// Path: `/v1/checkout`
        public let path: String
    }
}

extension Paths.Checkout {
    public var sessions: Sessions {
        Sessions(path: path + "/sessions")
    }

    public struct Sessions {
        /// Path: `/v1/checkout/sessions`
        public let path: String

        /// <p>Returns a list of Checkout Sessions.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// PaymentPagesCheckoutSessionList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.CheckoutSession]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.CheckoutSession], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var paymentIntent: String?
            public var startingAfter: String?
            public var subscription: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, paymentIntent: String? = nil, startingAfter: String? = nil, subscription: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.paymentIntent = paymentIntent
                self.startingAfter = startingAfter
                self.subscription = subscription
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(paymentIntent, forKey: "payment_intent")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(subscription, forKey: "subscription")
                return encoder.items
            }
        }

        /// <p>Creates a Session object.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.CheckoutSession> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// After_expiration_params
            ///
            /// Configure actions after a Checkout Session has expired.
            public var afterExpiration: AfterExpiration?
            /// Enables user redeemable promotion codes.
            public var allowPromotionCodes: Bool?
            /// Automatic_tax_params
            ///
            /// Settings for automatic tax lookup for this session and resulting payments, invoices, and subscriptions.
            public var automaticTax: AutomaticTax?
            /// Specify whether Checkout should collect the customer's billing address.
            public var billingAddressCollection: BillingAddressCollection?
            /// The URL the customer will be directed to if they decide to cancel payment and return to your website.
            public var cancelURL: String
            /// A unique string to reference the Checkout Session. This can be a
            /// customer ID, a cart ID, or similar, and can be used to reconcile the
            /// session with your internal systems.
            public var clientReferenceID: String?
            /// Consent_collection_params
            ///
            /// Configure fields for the Checkout Session to gather active consent from customers.
            public var consentCollection: ConsentCollection?
            /// ID of an existing Customer, if one exists. In `payment` mode, the customer’s most recent card
            /// payment method will be used to prefill the email, name, card details, and billing address
            /// on the Checkout page. In `subscription` mode, the customer’s [default payment method](https://stripe.com/docs/api/customers/update#update_customer-invoice_settings-default_payment_method)
            /// will be used if it’s a card, and otherwise the most recent card will be used. A valid billing address is required for Checkout to prefill the customer's card details.
            /// 
            /// If the Customer already has a valid [email](https://stripe.com/docs/api/customers/object#customer_object-email) set, the email will be prefilled and not editable in Checkout.
            /// If the Customer does not have a valid `email`, Checkout will set the email entered during the session on the Customer.
            /// 
            /// If blank for Checkout Sessions in `payment` or `subscription` mode, Checkout will create a new Customer object based on information provided during the payment flow.
            /// 
            /// You can set [`payment_intent_data.setup_future_usage`](https://stripe.com/docs/api/checkout/sessions/create#create_checkout_session-payment_intent_data-setup_future_usage) to have Checkout automatically attach the payment method to the Customer you pass in for future reuse.
            public var customer: String?
            /// If provided, this value will be used when the Customer object is created.
            /// If not provided, customers will be asked to enter their email address.
            /// Use this parameter to prefill customer data if you already have an email
            /// on file. To access information about the customer once a session is
            /// complete, use the `customer` field.
            public var customerEmail: String?
            /// Customer_update_params
            ///
            /// Controls what fields on Customer can be updated by the Checkout Session. Can only be provided when `customer` is provided.
            public var customerUpdate: CustomerUpdate?
            /// The coupon or promotion code to apply to this Session. Currently, only up to one may be specified.
            public var discounts: [Discount]?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The Epoch time in seconds at which the Checkout Session will expire. It can be anywhere from 1 to 24 hours after Checkout Session creation. By default, this value is 24 hours from creation.
            public var expiresAt: Int?
            /// A list of items the customer is purchasing. Use this parameter to pass one-time or recurring [Prices](https://stripe.com/docs/api/prices).
            /// 
            /// For `payment` mode, there is a maximum of 100 line items, however it is recommended to consolidate line items if there are more than a few dozen.
            /// 
            /// For `subscription` mode, there is a maximum of 20 line items with recurring Prices and 20 line items with one-time Prices. Line items with one-time Prices in will be on the initial invoice only.
            public var lineItems: [LineItem]?
            /// The IETF language tag of the locale Checkout is displayed in. If blank or `auto`, the browser's locale is used.
            public var locale: Locale?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// The mode of the Checkout Session. Required when using prices or `setup` mode. Pass `subscription` if the Checkout Session includes at least one recurring item.
            public var mode: Mode?
            /// Payment_intent_data_params
            ///
            /// A subset of parameters to be passed to PaymentIntent creation for Checkout Sessions in `payment` mode.
            public var paymentIntentData: PaymentIntentData?
            /// Payment_method_options_param
            ///
            /// Payment-method-specific configuration.
            public var paymentMethodOptions: PaymentMethodOptions?
            /// A list of the types of payment methods (e.g., `card`) this Checkout Session can accept.
            /// 
            /// Read more about the supported payment methods and their requirements in our [payment
            /// method details guide](/docs/payments/checkout/payment-methods).
            /// 
            /// If multiple payment methods are passed, Checkout will dynamically reorder them to
            /// prioritize the most relevant payment methods based on the customer's location and
            /// other characteristics.
            public var paymentMethodTypes: [PaymentMethodType]?
            /// Phone_number_collection_params
            ///
            /// Controls phone number collection settings for the session.
            /// 
            /// We recommend that you review your privacy policy and check with your legal contacts
            /// before using this feature. Learn more about [collecting phone numbers with Checkout](https://stripe.com/docs/payments/checkout/phone-numbers).
            public var phoneNumberCollection: PhoneNumberCollection?
            /// Setup_intent_data_param
            ///
            /// A subset of parameters to be passed to SetupIntent creation for Checkout Sessions in `setup` mode.
            public var setupIntentData: SetupIntentData?
            /// Shipping_address_collection_params
            ///
            /// When set, provides configuration for Checkout to collect a shipping address from a customer.
            public var shippingAddressCollection: ShippingAddressCollection?
            /// The shipping rate options to apply to this Session.
            public var shippingOptions: [ShippingOption]?
            /// Describes the type of transaction being performed by Checkout in order to customize
            /// relevant text on the page, such as the submit button. `submit_type` can only be
            /// specified on Checkout Sessions in `payment` mode, but not Checkout Sessions
            /// in `subscription` or `setup` mode.
            public var submitType: SubmitType?
            /// Subscription_data_params
            ///
            /// A subset of parameters to be passed to subscription creation for Checkout Sessions in `subscription` mode.
            public var subscriptionData: SubscriptionData?
            /// The URL to which Stripe should send customers when payment or setup
            /// is complete.
            /// If you’d like to use information from the successful Checkout Session on your page,
            /// read the guide on [customizing your success page](https://stripe.com/docs/payments/checkout/custom-success-page).
            public var successURL: String
            /// Tax_id_collection_params
            ///
            /// Controls tax ID collection settings for the session.
            public var taxIDCollection: TaxIDCollection?

            /// After_expiration_params
            ///
            /// Configure actions after a Checkout Session has expired.
            public struct AfterExpiration: Encodable {
                /// Recovery_params
                public var recovery: Recovery?

                /// Recovery_params
                public struct Recovery: Encodable {
                    public var allowPromotionCodes: Bool?
                    public var isEnabled: Bool

                    public init(allowPromotionCodes: Bool? = nil, isEnabled: Bool) {
                        self.allowPromotionCodes = allowPromotionCodes
                        self.isEnabled = isEnabled
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(allowPromotionCodes, forKey: "allow_promotion_codes")
                        encoder.encode(isEnabled, forKey: "enabled")
                        return encoder.items
                    }
                }

                public init(recovery: Recovery? = nil) {
                    self.recovery = recovery
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(recovery, forKey: "recovery")
                    return encoder.items
                }
            }

            /// Automatic_tax_params
            ///
            /// Settings for automatic tax lookup for this session and resulting payments, invoices, and subscriptions.
            public struct AutomaticTax: Encodable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Specify whether Checkout should collect the customer's billing address.
            public enum BillingAddressCollection: String, Codable, CaseIterable {
                case auto
                case required
            }

            /// Consent_collection_params
            ///
            /// Configure fields for the Checkout Session to gather active consent from customers.
            public struct ConsentCollection: Encodable {
                public var promotions: Promotions?

                public enum Promotions: String, Codable, CaseIterable {
                    case auto
                }

                public init(promotions: Promotions? = nil) {
                    self.promotions = promotions
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(promotions, forKey: "promotions")
                    return encoder.items
                }
            }

            /// Customer_update_params
            ///
            /// Controls what fields on Customer can be updated by the Checkout Session. Can only be provided when `customer` is provided.
            public struct CustomerUpdate: Encodable {
                public var address: Address?
                public var name: Name?
                public var shipping: Shipping?

                public enum Address: String, Codable, CaseIterable {
                    case auto
                    case never
                }

                public enum Name: String, Codable, CaseIterable {
                    case auto
                    case never
                }

                public enum Shipping: String, Codable, CaseIterable {
                    case auto
                    case never
                }

                public init(address: Address? = nil, name: Name? = nil, shipping: Shipping? = nil) {
                    self.address = address
                    self.name = name
                    self.shipping = shipping
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(name, forKey: "name")
                    encoder.encode(shipping, forKey: "shipping")
                    return encoder.items
                }
            }

            /// Discount_params
            public struct Discount: Encodable {
                public var coupon: String?
                public var promotionCode: String?

                public init(coupon: String? = nil, promotionCode: String? = nil) {
                    self.coupon = coupon
                    self.promotionCode = promotionCode
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(coupon, forKey: "coupon")
                    encoder.encode(promotionCode, forKey: "promotion_code")
                    return encoder.items
                }
            }

            /// Line_item_params
            public struct LineItem: Encodable {
                /// Adjustable_quantity_params
                public var adjustableQuantity: AdjustableQuantity?
                public var description: String?
                public var dynamicTaxRates: [String]?
                public var price: String?
                /// Price_data_with_product_data
                public var priceData: PriceData?
                public var quantity: Int?
                public var taxRates: [String]?

                /// Adjustable_quantity_params
                public struct AdjustableQuantity: Encodable {
                    public var isEnabled: Bool
                    public var maximum: Int?
                    public var minimum: Int?

                    public init(isEnabled: Bool, maximum: Int? = nil, minimum: Int? = nil) {
                        self.isEnabled = isEnabled
                        self.maximum = maximum
                        self.minimum = minimum
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isEnabled, forKey: "enabled")
                        encoder.encode(maximum, forKey: "maximum")
                        encoder.encode(minimum, forKey: "minimum")
                        return encoder.items
                    }
                }

                /// Price_data_with_product_data
                public struct PriceData: Encodable {
                    public var currency: String
                    public var product: String?
                    /// Product_data
                    public var productData: ProductData?
                    /// Recurring_adhoc
                    public var recurring: Recurring?
                    public var taxBehavior: TaxBehavior?
                    public var unitAmount: Int?
                    public var unitAmountDecimal: String?

                    /// Product_data
                    public struct ProductData: Encodable {
                        public var description: String?
                        public var images: [String]?
                        public var metadata: [String: String]?
                        public var name: String
                        public var taxCode: String?

                        public init(description: String? = nil, images: [String]? = nil, metadata: [String: String]? = nil, name: String, taxCode: String? = nil) {
                            self.description = description
                            self.images = images
                            self.metadata = metadata
                            self.name = name
                            self.taxCode = taxCode
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(description, forKey: "description")
                            encoder.encode(images, forKey: "images")
                            encoder.encode(metadata, forKey: "metadata")
                            encoder.encode(name, forKey: "name")
                            encoder.encode(taxCode, forKey: "tax_code")
                            return encoder.items
                        }
                    }

                    /// Recurring_adhoc
                    public struct Recurring: Encodable {
                        public var interval: Interval
                        public var intervalCount: Int?

                        public enum Interval: String, Codable, CaseIterable {
                            case day
                            case month
                            case week
                            case year
                        }

                        public init(interval: Interval, intervalCount: Int? = nil) {
                            self.interval = interval
                            self.intervalCount = intervalCount
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(interval, forKey: "interval")
                            encoder.encode(intervalCount, forKey: "interval_count")
                            return encoder.items
                        }
                    }

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public init(currency: String, product: String? = nil, productData: ProductData? = nil, recurring: Recurring? = nil, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                        self.currency = currency
                        self.product = product
                        self.productData = productData
                        self.recurring = recurring
                        self.taxBehavior = taxBehavior
                        self.unitAmount = unitAmount
                        self.unitAmountDecimal = unitAmountDecimal
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(product, forKey: "product")
                        encoder.encode(productData, forKey: "product_data")
                        encoder.encode(recurring, forKey: "recurring")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(unitAmount, forKey: "unit_amount")
                        encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                        return encoder.items
                    }
                }

                public init(adjustableQuantity: AdjustableQuantity? = nil, description: String? = nil, dynamicTaxRates: [String]? = nil, price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: [String]? = nil) {
                    self.adjustableQuantity = adjustableQuantity
                    self.description = description
                    self.dynamicTaxRates = dynamicTaxRates
                    self.price = price
                    self.priceData = priceData
                    self.quantity = quantity
                    self.taxRates = taxRates
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(adjustableQuantity, forKey: "adjustable_quantity")
                    encoder.encode(description, forKey: "description")
                    encoder.encode(dynamicTaxRates, forKey: "dynamic_tax_rates")
                    encoder.encode(price, forKey: "price")
                    encoder.encode(priceData, forKey: "price_data")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    return encoder.items
                }
            }

            /// The IETF language tag of the locale Checkout is displayed in. If blank or `auto`, the browser's locale is used.
            public enum Locale: String, Codable, CaseIterable {
                case auto
                case bg
                case cs
                case da
                case de
                case el
                case en
                case enGB = "en-GB"
                case es
                case es419 = "es-419"
                case et
                case fi
                case fil
                case fr
                case frCA = "fr-CA"
                case hr
                case hu
                case id
                case it
                case ja
                case ko
                case lt
                case lv
                case ms
                case mt
                case nb
                case nl
                case pl
                case pt
                case ptBR = "pt-BR"
                case ro
                case ru
                case sk
                case sl
                case sv
                case th
                case tr
                case vi
                case zh
                case zhHK = "zh-HK"
                case zhTW = "zh-TW"
            }

            /// The mode of the Checkout Session. Required when using prices or `setup` mode. Pass `subscription` if the Checkout Session includes at least one recurring item.
            public enum Mode: String, Codable, CaseIterable {
                case payment
                case setup
                case subscription
            }

            /// Payment_intent_data_params
            ///
            /// A subset of parameters to be passed to PaymentIntent creation for Checkout Sessions in `payment` mode.
            public struct PaymentIntentData: Encodable {
                public var applicationFeeAmount: Int?
                public var captureMethod: CaptureMethod?
                public var description: String?
                public var metadata: [String: String]?
                public var onBehalfOf: String?
                public var receiptEmail: String?
                public var setupFutureUsage: SetupFutureUsage?
                public var shipping: Shipping?
                public var statementDescriptor: String?
                public var statementDescriptorSuffix: String?
                /// Transfer_data_params
                public var transferData: TransferData?
                public var transferGroup: String?

                public enum CaptureMethod: String, Codable, CaseIterable {
                    case automatic
                    case manual
                }

                public enum SetupFutureUsage: String, Codable, CaseIterable {
                    case offSession = "off_session"
                    case onSession = "on_session"
                }

                public struct Shipping: Encodable {
                    public var address: Address
                    public var carrier: String?
                    public var name: String
                    public var phone: String?
                    public var trackingNumber: String?

                    public struct Address: Encodable {
                        public var city: String?
                        public var country: String?
                        public var line1: String
                        public var line2: String?
                        public var postalCode: String?
                        public var state: String?

                        public init(city: String? = nil, country: String? = nil, line1: String, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                            self.city = city
                            self.country = country
                            self.line1 = line1
                            self.line2 = line2
                            self.postalCode = postalCode
                            self.state = state
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(city, forKey: "city")
                            encoder.encode(country, forKey: "country")
                            encoder.encode(line1, forKey: "line1")
                            encoder.encode(line2, forKey: "line2")
                            encoder.encode(postalCode, forKey: "postal_code")
                            encoder.encode(state, forKey: "state")
                            return encoder.items
                        }
                    }

                    public init(address: Address, carrier: String? = nil, name: String, phone: String? = nil, trackingNumber: String? = nil) {
                        self.address = address
                        self.carrier = carrier
                        self.name = name
                        self.phone = phone
                        self.trackingNumber = trackingNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(address, forKey: "address")
                        encoder.encode(carrier, forKey: "carrier")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(phone, forKey: "phone")
                        encoder.encode(trackingNumber, forKey: "tracking_number")
                        return encoder.items
                    }
                }

                /// Transfer_data_params
                public struct TransferData: Encodable {
                    public var amount: Int?
                    public var destination: String

                    public init(amount: Int? = nil, destination: String) {
                        self.amount = amount
                        self.destination = destination
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amount, forKey: "amount")
                        encoder.encode(destination, forKey: "destination")
                        return encoder.items
                    }
                }

                public init(applicationFeeAmount: Int? = nil, captureMethod: CaptureMethod? = nil, description: String? = nil, metadata: [String: String]? = nil, onBehalfOf: String? = nil, receiptEmail: String? = nil, setupFutureUsage: SetupFutureUsage? = nil, shipping: Shipping? = nil, statementDescriptor: String? = nil, statementDescriptorSuffix: String? = nil, transferData: TransferData? = nil, transferGroup: String? = nil) {
                    self.applicationFeeAmount = applicationFeeAmount
                    self.captureMethod = captureMethod
                    self.description = description
                    self.metadata = metadata
                    self.onBehalfOf = onBehalfOf
                    self.receiptEmail = receiptEmail
                    self.setupFutureUsage = setupFutureUsage
                    self.shipping = shipping
                    self.statementDescriptor = statementDescriptor
                    self.statementDescriptorSuffix = statementDescriptorSuffix
                    self.transferData = transferData
                    self.transferGroup = transferGroup
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(applicationFeeAmount, forKey: "application_fee_amount")
                    encoder.encode(captureMethod, forKey: "capture_method")
                    encoder.encode(description, forKey: "description")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(onBehalfOf, forKey: "on_behalf_of")
                    encoder.encode(receiptEmail, forKey: "receipt_email")
                    encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                    encoder.encode(shipping, forKey: "shipping")
                    encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                    encoder.encode(statementDescriptorSuffix, forKey: "statement_descriptor_suffix")
                    encoder.encode(transferData, forKey: "transfer_data")
                    encoder.encode(transferGroup, forKey: "transfer_group")
                    return encoder.items
                }
            }

            /// Payment_method_options_param
            ///
            /// Payment-method-specific configuration.
            public struct PaymentMethodOptions: Encodable {
                /// Payment_method_options_param
                public var acssDebit: AcssDebit?
                /// Payment_method_options_param
                public var boleto: Boleto?
                /// Payment_method_options_param
                public var oxxo: Oxxo?
                /// Payment_method_options_param
                public var wechatPay: WechatPay?

                /// Payment_method_options_param
                public struct AcssDebit: Encodable {
                    public var currency: Currency?
                    /// Mandate_options_param
                    public var mandateOptions: MandateOptions?
                    public var verificationMethod: VerificationMethod?

                    public enum Currency: String, Codable, CaseIterable {
                        case cad
                        case usd
                    }

                    /// Mandate_options_param
                    public struct MandateOptions: Encodable {
                        public var customMandateURL: CustomMandateURL?
                        public var defaultFor: [DefaultForItem]?
                        public var intervalDescription: String?
                        public var paymentSchedule: PaymentSchedule?
                        public var transactionType: TransactionType?

                        public struct CustomMandateURL: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public enum DefaultForItem: String, Codable, CaseIterable {
                            case invoice
                            case subscription
                        }

                        public enum PaymentSchedule: String, Codable, CaseIterable {
                            case combined
                            case interval
                            case sporadic
                        }

                        public enum TransactionType: String, Codable, CaseIterable {
                            case business
                            case personal
                        }

                        public init(customMandateURL: CustomMandateURL? = nil, defaultFor: [DefaultForItem]? = nil, intervalDescription: String? = nil, paymentSchedule: PaymentSchedule? = nil, transactionType: TransactionType? = nil) {
                            self.customMandateURL = customMandateURL
                            self.defaultFor = defaultFor
                            self.intervalDescription = intervalDescription
                            self.paymentSchedule = paymentSchedule
                            self.transactionType = transactionType
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(customMandateURL, forKey: "custom_mandate_url")
                            encoder.encode(defaultFor, forKey: "default_for")
                            encoder.encode(intervalDescription, forKey: "interval_description")
                            encoder.encode(paymentSchedule, forKey: "payment_schedule")
                            encoder.encode(transactionType, forKey: "transaction_type")
                            return encoder.items
                        }
                    }

                    public enum VerificationMethod: String, Codable, CaseIterable {
                        case automatic
                        case instant
                        case microdeposits
                    }

                    public init(currency: Currency? = nil, mandateOptions: MandateOptions? = nil, verificationMethod: VerificationMethod? = nil) {
                        self.currency = currency
                        self.mandateOptions = mandateOptions
                        self.verificationMethod = verificationMethod
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(mandateOptions, forKey: "mandate_options")
                        encoder.encode(verificationMethod, forKey: "verification_method")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct Boleto: Encodable {
                    public var expiresAfterDays: Int?

                    public init(expiresAfterDays: Int? = nil) {
                        self.expiresAfterDays = expiresAfterDays
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(expiresAfterDays, forKey: "expires_after_days")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct Oxxo: Encodable {
                    public var expiresAfterDays: Int?

                    public init(expiresAfterDays: Int? = nil) {
                        self.expiresAfterDays = expiresAfterDays
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(expiresAfterDays, forKey: "expires_after_days")
                        return encoder.items
                    }
                }

                /// Payment_method_options_param
                public struct WechatPay: Encodable {
                    public var appID: String?
                    public var client: Client

                    public enum Client: String, Codable, CaseIterable {
                        case android
                        case ios
                        case web
                    }

                    public init(appID: String? = nil, client: Client) {
                        self.appID = appID
                        self.client = client
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(appID, forKey: "app_id")
                        encoder.encode(client, forKey: "client")
                        return encoder.items
                    }
                }

                public init(acssDebit: AcssDebit? = nil, boleto: Boleto? = nil, oxxo: Oxxo? = nil, wechatPay: WechatPay? = nil) {
                    self.acssDebit = acssDebit
                    self.boleto = boleto
                    self.oxxo = oxxo
                    self.wechatPay = wechatPay
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(acssDebit, forKey: "acss_debit")
                    encoder.encode(boleto, forKey: "boleto")
                    encoder.encode(oxxo, forKey: "oxxo")
                    encoder.encode(wechatPay, forKey: "wechat_pay")
                    return encoder.items
                }
            }

            public enum PaymentMethodType: String, Codable, CaseIterable {
                case acssDebit = "acss_debit"
                case afterpayClearpay = "afterpay_clearpay"
                case alipay
                case bacsDebit = "bacs_debit"
                case bancontact
                case boleto
                case card
                case eps
                case fpx
                case giropay
                case grabpay
                case ideal
                case klarna
                case oxxo
                case p24
                case sepaDebit = "sepa_debit"
                case sofort
                case wechatPay = "wechat_pay"
            }

            /// Phone_number_collection_params
            ///
            /// Controls phone number collection settings for the session.
            /// 
            /// We recommend that you review your privacy policy and check with your legal contacts
            /// before using this feature. Learn more about [collecting phone numbers with Checkout](https://stripe.com/docs/payments/checkout/phone-numbers).
            public struct PhoneNumberCollection: Encodable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Setup_intent_data_param
            ///
            /// A subset of parameters to be passed to SetupIntent creation for Checkout Sessions in `setup` mode.
            public struct SetupIntentData: Encodable {
                public var description: String?
                public var metadata: [String: String]?
                public var onBehalfOf: String?

                public init(description: String? = nil, metadata: [String: String]? = nil, onBehalfOf: String? = nil) {
                    self.description = description
                    self.metadata = metadata
                    self.onBehalfOf = onBehalfOf
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(description, forKey: "description")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(onBehalfOf, forKey: "on_behalf_of")
                    return encoder.items
                }
            }

            /// Shipping_address_collection_params
            ///
            /// When set, provides configuration for Checkout to collect a shipping address from a customer.
            public struct ShippingAddressCollection: Encodable {
                public var allowedCountries: [AllowedCountry]

                public enum AllowedCountry: String, Codable, CaseIterable {
                    case ac = "AC"
                    case ad = "AD"
                    case ae = "AE"
                    case af = "AF"
                    case ag = "AG"
                    case ai = "AI"
                    case al = "AL"
                    case am = "AM"
                    case ao = "AO"
                    case aq = "AQ"
                    case ar = "AR"
                    case at = "AT"
                    case au = "AU"
                    case aw = "AW"
                    case ax = "AX"
                    case az = "AZ"
                    case ba = "BA"
                    case bb = "BB"
                    case bd = "BD"
                    case be = "BE"
                    case bf = "BF"
                    case bg = "BG"
                    case bh = "BH"
                    case bi = "BI"
                    case bj = "BJ"
                    case bl = "BL"
                    case bm = "BM"
                    case bn = "BN"
                    case bo = "BO"
                    case bq = "BQ"
                    case br = "BR"
                    case bs = "BS"
                    case bt = "BT"
                    case bv = "BV"
                    case bw = "BW"
                    case by = "BY"
                    case bz = "BZ"
                    case ca = "CA"
                    case cd = "CD"
                    case cf = "CF"
                    case cg = "CG"
                    case ch = "CH"
                    case ci = "CI"
                    case ck = "CK"
                    case cl = "CL"
                    case cm = "CM"
                    case cn = "CN"
                    case co = "CO"
                    case cr = "CR"
                    case cv = "CV"
                    case cw = "CW"
                    case cy = "CY"
                    case cz = "CZ"
                    case de = "DE"
                    case dj = "DJ"
                    case dk = "DK"
                    case dm = "DM"
                    case `do` = "DO"
                    case dz = "DZ"
                    case ec = "EC"
                    case ee = "EE"
                    case eg = "EG"
                    case eh = "EH"
                    case er = "ER"
                    case es = "ES"
                    case et = "ET"
                    case fi = "FI"
                    case fj = "FJ"
                    case fk = "FK"
                    case fo = "FO"
                    case fr = "FR"
                    case ga = "GA"
                    case gb = "GB"
                    case gd = "GD"
                    case ge = "GE"
                    case gf = "GF"
                    case gg = "GG"
                    case gh = "GH"
                    case gi = "GI"
                    case gl = "GL"
                    case gm = "GM"
                    case gn = "GN"
                    case gp = "GP"
                    case gq = "GQ"
                    case gr = "GR"
                    case gs = "GS"
                    case gt = "GT"
                    case gu = "GU"
                    case gw = "GW"
                    case gy = "GY"
                    case hk = "HK"
                    case hn = "HN"
                    case hr = "HR"
                    case ht = "HT"
                    case hu = "HU"
                    case id = "ID"
                    case ie = "IE"
                    case il = "IL"
                    case im = "IM"
                    case `in` = "IN"
                    case io = "IO"
                    case iq = "IQ"
                    case `is` = "IS"
                    case it = "IT"
                    case je = "JE"
                    case jm = "JM"
                    case jo = "JO"
                    case jp = "JP"
                    case ke = "KE"
                    case kg = "KG"
                    case kh = "KH"
                    case ki = "KI"
                    case km = "KM"
                    case kn = "KN"
                    case kr = "KR"
                    case kw = "KW"
                    case ky = "KY"
                    case kz = "KZ"
                    case la = "LA"
                    case lb = "LB"
                    case lc = "LC"
                    case li = "LI"
                    case lk = "LK"
                    case lr = "LR"
                    case ls = "LS"
                    case lt = "LT"
                    case lu = "LU"
                    case lv = "LV"
                    case ly = "LY"
                    case ma = "MA"
                    case mc = "MC"
                    case md = "MD"
                    case me = "ME"
                    case mf = "MF"
                    case mg = "MG"
                    case mk = "MK"
                    case ml = "ML"
                    case mm = "MM"
                    case mn = "MN"
                    case mo = "MO"
                    case mq = "MQ"
                    case mr = "MR"
                    case ms = "MS"
                    case mt = "MT"
                    case mu = "MU"
                    case mv = "MV"
                    case mw = "MW"
                    case mx = "MX"
                    case my = "MY"
                    case mz = "MZ"
                    case na = "NA"
                    case nc = "NC"
                    case ne = "NE"
                    case ng = "NG"
                    case ni = "NI"
                    case nl = "NL"
                    case no = "NO"
                    case np = "NP"
                    case nr = "NR"
                    case nu = "NU"
                    case nz = "NZ"
                    case om = "OM"
                    case pa = "PA"
                    case pe = "PE"
                    case pf = "PF"
                    case pg = "PG"
                    case ph = "PH"
                    case pk = "PK"
                    case pl = "PL"
                    case pm = "PM"
                    case pn = "PN"
                    case pr = "PR"
                    case ps = "PS"
                    case pt = "PT"
                    case py = "PY"
                    case qa = "QA"
                    case re = "RE"
                    case ro = "RO"
                    case rs = "RS"
                    case ru = "RU"
                    case rw = "RW"
                    case sa = "SA"
                    case sb = "SB"
                    case sc = "SC"
                    case se = "SE"
                    case sg = "SG"
                    case sh = "SH"
                    case si = "SI"
                    case sj = "SJ"
                    case sk = "SK"
                    case sl = "SL"
                    case sm = "SM"
                    case sn = "SN"
                    case so = "SO"
                    case sr = "SR"
                    case ss = "SS"
                    case st = "ST"
                    case sv = "SV"
                    case sx = "SX"
                    case sz = "SZ"
                    case ta = "TA"
                    case tc = "TC"
                    case td = "TD"
                    case tf = "TF"
                    case tg = "TG"
                    case th = "TH"
                    case tj = "TJ"
                    case tk = "TK"
                    case tl = "TL"
                    case tm = "TM"
                    case tn = "TN"
                    case to = "TO"
                    case tr = "TR"
                    case tt = "TT"
                    case tv = "TV"
                    case tw = "TW"
                    case tz = "TZ"
                    case ua = "UA"
                    case ug = "UG"
                    case us = "US"
                    case uy = "UY"
                    case uz = "UZ"
                    case va = "VA"
                    case vc = "VC"
                    case ve = "VE"
                    case vg = "VG"
                    case vn = "VN"
                    case vu = "VU"
                    case wf = "WF"
                    case ws = "WS"
                    case xk = "XK"
                    case ye = "YE"
                    case yt = "YT"
                    case za = "ZA"
                    case zm = "ZM"
                    case zw = "ZW"
                    case zz = "ZZ"
                }

                public init(allowedCountries: [AllowedCountry]) {
                    self.allowedCountries = allowedCountries
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(allowedCountries, forKey: "allowed_countries")
                    return encoder.items
                }
            }

            /// Shipping_option_params
            public struct ShippingOption: Encodable {
                public var shippingRate: String?
                /// Method_params
                public var shippingRateData: ShippingRateData?

                /// Method_params
                public struct ShippingRateData: Encodable {
                    /// Delivery_estimate
                    public var deliveryEstimate: DeliveryEstimate?
                    public var displayName: String
                    /// Fixed_amount
                    public var fixedAmount: FixedAmount?
                    public var metadata: [String: String]?
                    public var taxBehavior: TaxBehavior?
                    public var taxCode: String?
                    public var type: `Type`?

                    /// Delivery_estimate
                    public struct DeliveryEstimate: Encodable {
                        /// Delivery_estimate_bound
                        public var maximum: Maximum?
                        /// Delivery_estimate_bound
                        public var minimum: Minimum?

                        /// Delivery_estimate_bound
                        public struct Maximum: Encodable {
                            public var unit: Unit
                            public var value: Int

                            public enum Unit: String, Codable, CaseIterable {
                                case businessDay = "business_day"
                                case day
                                case hour
                                case month
                                case week
                            }

                            public init(unit: Unit, value: Int) {
                                self.unit = unit
                                self.value = value
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(unit, forKey: "unit")
                                encoder.encode(value, forKey: "value")
                                return encoder.items
                            }
                        }

                        /// Delivery_estimate_bound
                        public struct Minimum: Encodable {
                            public var unit: Unit
                            public var value: Int

                            public enum Unit: String, Codable, CaseIterable {
                                case businessDay = "business_day"
                                case day
                                case hour
                                case month
                                case week
                            }

                            public init(unit: Unit, value: Int) {
                                self.unit = unit
                                self.value = value
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(unit, forKey: "unit")
                                encoder.encode(value, forKey: "value")
                                return encoder.items
                            }
                        }

                        public init(maximum: Maximum? = nil, minimum: Minimum? = nil) {
                            self.maximum = maximum
                            self.minimum = minimum
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(maximum, forKey: "maximum")
                            encoder.encode(minimum, forKey: "minimum")
                            return encoder.items
                        }
                    }

                    /// Fixed_amount
                    public struct FixedAmount: Encodable {
                        public var amount: Int
                        public var currency: String

                        public init(amount: Int, currency: String) {
                            self.amount = amount
                            self.currency = currency
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(amount, forKey: "amount")
                            encoder.encode(currency, forKey: "currency")
                            return encoder.items
                        }
                    }

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public enum `Type`: String, Codable, CaseIterable {
                        case fixedAmount = "fixed_amount"
                    }

                    public init(deliveryEstimate: DeliveryEstimate? = nil, displayName: String, fixedAmount: FixedAmount? = nil, metadata: [String: String]? = nil, taxBehavior: TaxBehavior? = nil, taxCode: String? = nil, type: `Type`? = nil) {
                        self.deliveryEstimate = deliveryEstimate
                        self.displayName = displayName
                        self.fixedAmount = fixedAmount
                        self.metadata = metadata
                        self.taxBehavior = taxBehavior
                        self.taxCode = taxCode
                        self.type = type
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(deliveryEstimate, forKey: "delivery_estimate")
                        encoder.encode(displayName, forKey: "display_name")
                        encoder.encode(fixedAmount, forKey: "fixed_amount")
                        encoder.encode(metadata, forKey: "metadata")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(taxCode, forKey: "tax_code")
                        encoder.encode(type, forKey: "type")
                        return encoder.items
                    }
                }

                public init(shippingRate: String? = nil, shippingRateData: ShippingRateData? = nil) {
                    self.shippingRate = shippingRate
                    self.shippingRateData = shippingRateData
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(shippingRate, forKey: "shipping_rate")
                    encoder.encode(shippingRateData, forKey: "shipping_rate_data")
                    return encoder.items
                }
            }

            /// Describes the type of transaction being performed by Checkout in order to customize
            /// relevant text on the page, such as the submit button. `submit_type` can only be
            /// specified on Checkout Sessions in `payment` mode, but not Checkout Sessions
            /// in `subscription` or `setup` mode.
            public enum SubmitType: String, Codable, CaseIterable {
                case auto
                case book
                case donate
                case pay
            }

            /// Subscription_data_params
            ///
            /// A subset of parameters to be passed to subscription creation for Checkout Sessions in `subscription` mode.
            public struct SubscriptionData: Encodable {
                public var applicationFeePercent: Double?
                public var defaultTaxRates: [String]?
                public var items: [Item]?
                public var metadata: [String: String]?
                /// Transfer_data_specs
                public var transferData: TransferData?
                public var trialEnd: Int?
                public var trialPeriodDays: Int?

                /// Subscription_data_item_param
                public struct Item: Encodable {
                    public var plan: String
                    public var quantity: Int?
                    public var taxRates: [String]?

                    public init(plan: String, quantity: Int? = nil, taxRates: [String]? = nil) {
                        self.plan = plan
                        self.quantity = quantity
                        self.taxRates = taxRates
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(plan, forKey: "plan")
                        encoder.encode(quantity, forKey: "quantity")
                        encoder.encode(taxRates, forKey: "tax_rates")
                        return encoder.items
                    }
                }

                /// Transfer_data_specs
                public struct TransferData: Encodable {
                    public var amountPercent: Double?
                    public var destination: String

                    public init(amountPercent: Double? = nil, destination: String) {
                        self.amountPercent = amountPercent
                        self.destination = destination
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amountPercent, forKey: "amount_percent")
                        encoder.encode(destination, forKey: "destination")
                        return encoder.items
                    }
                }

                public init(applicationFeePercent: Double? = nil, defaultTaxRates: [String]? = nil, items: [Item]? = nil, metadata: [String: String]? = nil, transferData: TransferData? = nil, trialEnd: Int? = nil, trialPeriodDays: Int? = nil) {
                    self.applicationFeePercent = applicationFeePercent
                    self.defaultTaxRates = defaultTaxRates
                    self.items = items
                    self.metadata = metadata
                    self.transferData = transferData
                    self.trialEnd = trialEnd
                    self.trialPeriodDays = trialPeriodDays
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(applicationFeePercent, forKey: "application_fee_percent")
                    encoder.encode(defaultTaxRates, forKey: "default_tax_rates")
                    encoder.encode(items, forKey: "items")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(transferData, forKey: "transfer_data")
                    encoder.encode(trialEnd, forKey: "trial_end")
                    encoder.encode(trialPeriodDays, forKey: "trial_period_days")
                    return encoder.items
                }
            }

            /// Tax_id_collection_params
            ///
            /// Controls tax ID collection settings for the session.
            public struct TaxIDCollection: Encodable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            public init(afterExpiration: AfterExpiration? = nil, allowPromotionCodes: Bool? = nil, automaticTax: AutomaticTax? = nil, billingAddressCollection: BillingAddressCollection? = nil, cancelURL: String, clientReferenceID: String? = nil, consentCollection: ConsentCollection? = nil, customer: String? = nil, customerEmail: String? = nil, customerUpdate: CustomerUpdate? = nil, discounts: [Discount]? = nil, expand: [String]? = nil, expiresAt: Int? = nil, lineItems: [LineItem]? = nil, locale: Locale? = nil, metadata: [String: String]? = nil, mode: Mode? = nil, paymentIntentData: PaymentIntentData? = nil, paymentMethodOptions: PaymentMethodOptions? = nil, paymentMethodTypes: [PaymentMethodType]? = nil, phoneNumberCollection: PhoneNumberCollection? = nil, setupIntentData: SetupIntentData? = nil, shippingAddressCollection: ShippingAddressCollection? = nil, shippingOptions: [ShippingOption]? = nil, submitType: SubmitType? = nil, subscriptionData: SubscriptionData? = nil, successURL: String, taxIDCollection: TaxIDCollection? = nil) {
                self.afterExpiration = afterExpiration
                self.allowPromotionCodes = allowPromotionCodes
                self.automaticTax = automaticTax
                self.billingAddressCollection = billingAddressCollection
                self.cancelURL = cancelURL
                self.clientReferenceID = clientReferenceID
                self.consentCollection = consentCollection
                self.customer = customer
                self.customerEmail = customerEmail
                self.customerUpdate = customerUpdate
                self.discounts = discounts
                self.expand = expand
                self.expiresAt = expiresAt
                self.lineItems = lineItems
                self.locale = locale
                self.metadata = metadata
                self.mode = mode
                self.paymentIntentData = paymentIntentData
                self.paymentMethodOptions = paymentMethodOptions
                self.paymentMethodTypes = paymentMethodTypes
                self.phoneNumberCollection = phoneNumberCollection
                self.setupIntentData = setupIntentData
                self.shippingAddressCollection = shippingAddressCollection
                self.shippingOptions = shippingOptions
                self.submitType = submitType
                self.subscriptionData = subscriptionData
                self.successURL = successURL
                self.taxIDCollection = taxIDCollection
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(afterExpiration, forKey: "after_expiration")
                encoder.encode(allowPromotionCodes, forKey: "allow_promotion_codes")
                encoder.encode(automaticTax, forKey: "automatic_tax")
                encoder.encode(billingAddressCollection, forKey: "billing_address_collection")
                encoder.encode(cancelURL, forKey: "cancel_url")
                encoder.encode(clientReferenceID, forKey: "client_reference_id")
                encoder.encode(consentCollection, forKey: "consent_collection")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(customerEmail, forKey: "customer_email")
                encoder.encode(customerUpdate, forKey: "customer_update")
                encoder.encode(discounts, forKey: "discounts")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(expiresAt, forKey: "expires_at")
                encoder.encode(lineItems, forKey: "line_items")
                encoder.encode(locale, forKey: "locale")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(mode, forKey: "mode")
                encoder.encode(paymentIntentData, forKey: "payment_intent_data")
                encoder.encode(paymentMethodOptions, forKey: "payment_method_options")
                encoder.encode(paymentMethodTypes, forKey: "payment_method_types")
                encoder.encode(phoneNumberCollection, forKey: "phone_number_collection")
                encoder.encode(setupIntentData, forKey: "setup_intent_data")
                encoder.encode(shippingAddressCollection, forKey: "shipping_address_collection")
                encoder.encode(shippingOptions, forKey: "shipping_options")
                encoder.encode(submitType, forKey: "submit_type")
                encoder.encode(subscriptionData, forKey: "subscription_data")
                encoder.encode(successURL, forKey: "success_url")
                encoder.encode(taxIDCollection, forKey: "tax_id_collection")
                return encoder.items
            }
        }
    }
}

extension Paths.Checkout.Sessions {
    public func session(_ session: String) -> WithSession {
        WithSession(path: "\(path)/\(session)")
    }

    public struct WithSession {
        /// Path: `/v1/checkout/sessions/{session}`
        public let path: String

        /// <p>Retrieves a Session object.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.CheckoutSession> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths.Checkout.Sessions.WithSession {
    public var expire: Expire {
        Expire(path: path + "/expire")
    }

    public struct Expire {
        /// Path: `/v1/checkout/sessions/{session}/expire`
        public let path: String

        /// <p>A Session can be expired when it is in one of these statuses: <code>open</code> </p>
        /// 
        /// <p>After it expires, a customer can’t complete a Session and customers loading the Session see a message saying the Session is expired.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.CheckoutSession> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(expand: [String]? = nil) {
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.Checkout.Sessions.WithSession {
    public var lineItems: LineItems {
        LineItems(path: path + "/line_items")
    }

    public struct LineItems {
        /// Path: `/v1/checkout/sessions/{session}/line_items`
        public let path: String

        /// <p>When retrieving a Checkout Session, there is an includable <strong>line_items</strong> property containing the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// PaymentPagesCheckoutSessionListLineItems
        public struct GetResponse: Decodable {
            /// Details about each object.
            public var data: [StripeAPI.Item]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Item], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var countrySpecs: CountrySpecs {
        CountrySpecs(path: "/v1/country_specs")
    }

    public struct CountrySpecs {
        /// Path: `/v1/country_specs`
        public let path: String

        /// <p>Lists all Country Spec objects available in the API.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.CountrySpec]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.CountrySpec], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }
    }
}

extension Paths.CountrySpecs {
    public func country(_ country: String) -> WithCountry {
        WithCountry(path: "\(path)/\(country)")
    }

    public struct WithCountry {
        /// Path: `/v1/country_specs/{country}`
        public let path: String

        /// <p>Returns a Country Spec for a given Country code.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.CountrySpec> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths {
    public static var coupons: Coupons {
        Coupons(path: "/v1/coupons")
    }

    public struct Coupons {
        /// Path: `/v1/coupons`
        public let path: String

        /// <p>Returns a list of your coupons.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Coupon]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Coupon], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>You can create coupons easily via the <a href="https://dashboard.stripe.com/coupons">coupon management</a> page of the Stripe dashboard. Coupon creation is also accessible via the API if you need to create coupons on the fly.</p>
        /// 
        /// <p>A coupon has either a <code>percent_off</code> or an <code>amount_off</code> and <code>currency</code>. If you set an <code>amount_off</code>, that amount will be subtracted from any invoice’s subtotal. For example, an invoice with a subtotal of <currency>100</currency> will have a final total of <currency>0</currency> if a coupon with an <code>amount_off</code> of <amount>200</amount> is applied to it and an invoice with a subtotal of <currency>300</currency> will have a final total of <currency>100</currency> if a coupon with an <code>amount_off</code> of <amount>200</amount> is applied to it.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Coupon> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// A positive integer representing the amount to subtract from an invoice total (required if `percent_off` is not passed).
            public var amountOff: Int?
            /// Applies_to_params
            ///
            /// A hash containing directions for what this Coupon will apply discounts to.
            public var appliesTo: AppliesTo?
            /// Three-letter [ISO code for the currency](https://stripe.com/docs/currencies) of the `amount_off` parameter (required if `amount_off` is passed).
            public var currency: String?
            /// Specifies how long the discount will be in effect if used on a subscription. Can be `forever`, `once`, or `repeating`. Defaults to `once`.
            public var duration: Duration?
            /// Required only if `duration` is `repeating`, in which case it must be a positive integer that specifies the number of months the discount will be in effect.
            public var durationInMonths: Int?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Unique string of your choice that will be used to identify this coupon when applying it to a customer. If you don't want to specify a particular code, you can leave the ID blank and we'll generate a random code for you.
            public var id: String?
            /// A positive integer specifying the number of times the coupon can be redeemed before it's no longer valid. For example, you might have a 50% off coupon that the first 20 readers of your blog can use.
            public var maxRedemptions: Int?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// Name of the coupon displayed to customers on, for instance invoices, or receipts. By default the `id` is shown if `name` is not set.
            public var name: String?
            /// A positive float larger than 0, and smaller or equal to 100, that represents the discount the coupon will apply (required if `amount_off` is not passed).
            public var percentOff: Double?
            /// Unix timestamp specifying the last time at which the coupon can be redeemed. After the redeem_by date, the coupon can no longer be applied to new customers.
            public var redeemBy: Int?

            /// Applies_to_params
            ///
            /// A hash containing directions for what this Coupon will apply discounts to.
            public struct AppliesTo: Encodable {
                public var products: [String]?

                public init(products: [String]? = nil) {
                    self.products = products
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(products, forKey: "products")
                    return encoder.items
                }
            }

            /// Specifies how long the discount will be in effect if used on a subscription. Can be `forever`, `once`, or `repeating`. Defaults to `once`.
            public enum Duration: String, Codable, CaseIterable {
                case forever
                case once
                case repeating
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(amountOff: Int? = nil, appliesTo: AppliesTo? = nil, currency: String? = nil, duration: Duration? = nil, durationInMonths: Int? = nil, expand: [String]? = nil, id: String? = nil, maxRedemptions: Int? = nil, metadata: Metadata? = nil, name: String? = nil, percentOff: Double? = nil, redeemBy: Int? = nil) {
                self.amountOff = amountOff
                self.appliesTo = appliesTo
                self.currency = currency
                self.duration = duration
                self.durationInMonths = durationInMonths
                self.expand = expand
                self.id = id
                self.maxRedemptions = maxRedemptions
                self.metadata = metadata
                self.name = name
                self.percentOff = percentOff
                self.redeemBy = redeemBy
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amountOff, forKey: "amount_off")
                encoder.encode(appliesTo, forKey: "applies_to")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(duration, forKey: "duration")
                encoder.encode(durationInMonths, forKey: "duration_in_months")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(id, forKey: "id")
                encoder.encode(maxRedemptions, forKey: "max_redemptions")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(name, forKey: "name")
                encoder.encode(percentOff, forKey: "percent_off")
                encoder.encode(redeemBy, forKey: "redeem_by")
                return encoder.items
            }
        }
    }
}

extension Paths.Coupons {
    public func coupon(_ coupon: String) -> WithCoupon {
        WithCoupon(path: "\(path)/\(coupon)")
    }

    public struct WithCoupon {
        /// Path: `/v1/coupons/{coupon}`
        public let path: String

        /// <p>Retrieves the coupon with the given ID.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Coupon> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the metadata of a coupon. Other coupon details (currency, duration, amount_off) are, by design, not editable.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Coupon> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// Name of the coupon displayed to customers on, for instance invoices, or receipts. By default the `id` is shown if `name` is not set.
            public var name: String?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(expand: [String]? = nil, metadata: Metadata? = nil, name: String? = nil) {
                self.expand = expand
                self.metadata = metadata
                self.name = name
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(name, forKey: "name")
                return encoder.items
            }
        }

        /// <p>You can delete coupons via the <a href="https://dashboard.stripe.com/coupons">coupon management</a> page of the Stripe dashboard. However, deleting a coupon does not affect any customers who have already applied the coupon; it means that new customers can’t redeem the coupon. You can also delete coupons via the API.</p>
        public var delete: Request<StripeAPI.DeletedCoupon> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var creditNotes: CreditNotes {
        CreditNotes(path: "/v1/credit_notes")
    }

    public struct CreditNotes {
        /// Path: `/v1/credit_notes`
        public let path: String

        /// <p>Returns a list of credit notes.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// CreditNotesList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.CreditNote]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.CreditNote], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var customer: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var invoice: String?
            public var limit: Int?
            public var startingAfter: String?

            public init(customer: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, invoice: String? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.customer = customer
                self.endingBefore = endingBefore
                self.expand = expand
                self.invoice = invoice
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(customer, forKey: "customer")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(invoice, forKey: "invoice")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Issue a credit note to adjust the amount of a finalized invoice. For a <code>status=open</code> invoice, a credit note reduces
        /// its <code>amount_due</code>. For a <code>status=paid</code> invoice, a credit note does not affect its <code>amount_due</code>. Instead, it can result
        /// in any combination of the following:</p>
        /// 
        /// <ul>
        /// <li>Refund: create a new refund (using <code>refund_amount</code>) or link an existing refund (using <code>refund</code>).</li>
        /// <li>Customer balance credit: credit the customer’s balance (using <code>credit_amount</code>) which will be automatically applied to their next invoice when it’s finalized.</li>
        /// <li>Outside of Stripe credit: record the amount that is or will be credited outside of Stripe (using <code>out_of_band_amount</code>).</li>
        /// </ul>
        /// 
        /// <p>For post-payment credit notes the sum of the refund, credit and outside of Stripe amounts must equal the credit note total.</p>
        /// 
        /// <p>You may issue multiple credit notes for an invoice. Each credit note will increment the invoice’s <code>pre_payment_credit_notes_amount</code>
        /// or <code>post_payment_credit_notes_amount</code> depending on its <code>status</code> at the time of credit note creation.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.CreditNote> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The integer amount in %s representing the total amount of the credit note.
            public var amount: Int?
            /// The integer amount in %s representing the amount to credit the customer's balance, which will be automatically applied to their next invoice.
            public var creditAmount: Int?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// ID of the invoice.
            public var invoice: String
            /// Line items that make up the credit note.
            public var lines: [Line]?
            /// The credit note's memo appears on the credit note PDF.
            public var memo: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// The integer amount in %s representing the amount that is credited outside of Stripe.
            public var outOfBandAmount: Int?
            /// Reason for issuing this credit note, one of `duplicate`, `fraudulent`, `order_change`, or `product_unsatisfactory`
            public var reason: Reason?
            /// ID of an existing refund to link this credit note to.
            public var refund: String?
            /// The integer amount in %s representing the amount to refund. If set, a refund will be created for the charge associated with the invoice.
            public var refundAmount: Int?

            /// Credit_note_line_item_params
            public struct Line: Encodable {
                public var amount: Int?
                public var description: String?
                public var invoiceLineItem: String?
                public var quantity: Int?
                public var taxRates: TaxRates?
                public var type: `Type`
                public var unitAmount: Int?
                public var unitAmountDecimal: String?

                public struct TaxRates: Encodable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public enum `Type`: String, Codable, CaseIterable {
                    case customLineItem = "custom_line_item"
                    case invoiceLineItem = "invoice_line_item"
                }

                public init(amount: Int? = nil, description: String? = nil, invoiceLineItem: String? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil, type: `Type`, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                    self.amount = amount
                    self.description = description
                    self.invoiceLineItem = invoiceLineItem
                    self.quantity = quantity
                    self.taxRates = taxRates
                    self.type = type
                    self.unitAmount = unitAmount
                    self.unitAmountDecimal = unitAmountDecimal
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(amount, forKey: "amount")
                    encoder.encode(description, forKey: "description")
                    encoder.encode(invoiceLineItem, forKey: "invoice_line_item")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    encoder.encode(type, forKey: "type")
                    encoder.encode(unitAmount, forKey: "unit_amount")
                    encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                    return encoder.items
                }
            }

            /// Reason for issuing this credit note, one of `duplicate`, `fraudulent`, `order_change`, or `product_unsatisfactory`
            public enum Reason: String, Codable, CaseIterable {
                case duplicate
                case fraudulent
                case orderChange = "order_change"
                case productUnsatisfactory = "product_unsatisfactory"
            }

            public init(amount: Int? = nil, creditAmount: Int? = nil, expand: [String]? = nil, invoice: String, lines: [Line]? = nil, memo: String? = nil, metadata: [String: String]? = nil, outOfBandAmount: Int? = nil, reason: Reason? = nil, refund: String? = nil, refundAmount: Int? = nil) {
                self.amount = amount
                self.creditAmount = creditAmount
                self.expand = expand
                self.invoice = invoice
                self.lines = lines
                self.memo = memo
                self.metadata = metadata
                self.outOfBandAmount = outOfBandAmount
                self.reason = reason
                self.refund = refund
                self.refundAmount = refundAmount
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(creditAmount, forKey: "credit_amount")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(invoice, forKey: "invoice")
                encoder.encode(lines, forKey: "lines")
                encoder.encode(memo, forKey: "memo")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(outOfBandAmount, forKey: "out_of_band_amount")
                encoder.encode(reason, forKey: "reason")
                encoder.encode(refund, forKey: "refund")
                encoder.encode(refundAmount, forKey: "refund_amount")
                return encoder.items
            }
        }
    }
}

extension Paths.CreditNotes {
    public var preview: Preview {
        Preview(path: path + "/preview")
    }

    public struct Preview {
        /// Path: `/v1/credit_notes/preview`
        public let path: String

        /// <p>Get a preview of a credit note without creating it.</p>
        public func get(parameters: GetParameters) -> Request<StripeAPI.CreditNote> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var amount: Int?
            public var creditAmount: Int?
            public var expand: [String]?
            public var invoice: String
            public var lines: [Lines]?
            public var memo: String?
            public var metadata: Metadata?
            public var outOfBandAmount: Int?
            public var reason: Reason?
            public var refund: String?
            public var refundAmount: Int?

            /// Credit_note_line_item_params
            public struct Lines: Codable {
                public var amount: Int?
                public var description: String?
                public var invoiceLineItem: String?
                public var quantity: Int?
                public var taxRates: TaxRates?
                public var type: `Type`
                public var unitAmount: Int?
                public var unitAmountDecimal: String?

                public struct TaxRates: Codable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public enum `Type`: String, Codable, CaseIterable {
                    case customLineItem = "custom_line_item"
                    case invoiceLineItem = "invoice_line_item"
                }

                public init(amount: Int? = nil, description: String? = nil, invoiceLineItem: String? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil, type: `Type`, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                    self.amount = amount
                    self.description = description
                    self.invoiceLineItem = invoiceLineItem
                    self.quantity = quantity
                    self.taxRates = taxRates
                    self.type = type
                    self.unitAmount = unitAmount
                    self.unitAmountDecimal = unitAmountDecimal
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(amount, forKey: "amount")
                    encoder.encode(description, forKey: "description")
                    encoder.encode(invoiceLineItem, forKey: "invoice_line_item")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    encoder.encode(type, forKey: "type")
                    encoder.encode(unitAmount, forKey: "unit_amount")
                    encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                    return encoder.items
                }
            }

            public typealias Metadata = [String: String]

            public enum Reason: String, Codable, CaseIterable {
                case duplicate
                case fraudulent
                case orderChange = "order_change"
                case productUnsatisfactory = "product_unsatisfactory"
            }

            public init(amount: Int? = nil, creditAmount: Int? = nil, expand: [String]? = nil, invoice: String, lines: [Lines]? = nil, memo: String? = nil, metadata: Metadata? = nil, outOfBandAmount: Int? = nil, reason: Reason? = nil, refund: String? = nil, refundAmount: Int? = nil) {
                self.amount = amount
                self.creditAmount = creditAmount
                self.expand = expand
                self.invoice = invoice
                self.lines = lines
                self.memo = memo
                self.metadata = metadata
                self.outOfBandAmount = outOfBandAmount
                self.reason = reason
                self.refund = refund
                self.refundAmount = refundAmount
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(creditAmount, forKey: "credit_amount")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(invoice, forKey: "invoice")
                encoder.encode(lines, forKey: "lines", isDeepObject: true)
                encoder.encode(memo, forKey: "memo")
                encoder.encode(metadata, forKey: "metadata", isDeepObject: true)
                encoder.encode(outOfBandAmount, forKey: "out_of_band_amount")
                encoder.encode(reason, forKey: "reason")
                encoder.encode(refund, forKey: "refund")
                encoder.encode(refundAmount, forKey: "refund_amount")
                return encoder.items
            }
        }
    }
}

extension Paths.CreditNotes.Preview {
    public var lines: Lines {
        Lines(path: path + "/lines")
    }

    public struct Lines {
        /// Path: `/v1/credit_notes/preview/lines`
        public let path: String

        /// <p>When retrieving a credit note preview, you’ll get a <strong>lines</strong> property containing the first handful of those items. This URL you can retrieve the full (paginated) list of line items.</p>
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        /// CreditNoteLinesList
        public struct GetResponse: Decodable {
            /// Details about each object.
            public var data: [StripeAPI.CreditNoteLineItem]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.CreditNoteLineItem], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var amount: Int?
            public var creditAmount: Int?
            public var endingBefore: String?
            public var expand: [String]?
            public var invoice: String
            public var limit: Int?
            public var lines: [Lines]?
            public var memo: String?
            public var metadata: Metadata?
            public var outOfBandAmount: Int?
            public var reason: Reason?
            public var refund: String?
            public var refundAmount: Int?
            public var startingAfter: String?

            /// Credit_note_line_item_params
            public struct Lines: Codable {
                public var amount: Int?
                public var description: String?
                public var invoiceLineItem: String?
                public var quantity: Int?
                public var taxRates: TaxRates?
                public var type: `Type`
                public var unitAmount: Int?
                public var unitAmountDecimal: String?

                public struct TaxRates: Codable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public enum `Type`: String, Codable, CaseIterable {
                    case customLineItem = "custom_line_item"
                    case invoiceLineItem = "invoice_line_item"
                }

                public init(amount: Int? = nil, description: String? = nil, invoiceLineItem: String? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil, type: `Type`, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                    self.amount = amount
                    self.description = description
                    self.invoiceLineItem = invoiceLineItem
                    self.quantity = quantity
                    self.taxRates = taxRates
                    self.type = type
                    self.unitAmount = unitAmount
                    self.unitAmountDecimal = unitAmountDecimal
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(amount, forKey: "amount")
                    encoder.encode(description, forKey: "description")
                    encoder.encode(invoiceLineItem, forKey: "invoice_line_item")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    encoder.encode(type, forKey: "type")
                    encoder.encode(unitAmount, forKey: "unit_amount")
                    encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                    return encoder.items
                }
            }

            public typealias Metadata = [String: String]

            public enum Reason: String, Codable, CaseIterable {
                case duplicate
                case fraudulent
                case orderChange = "order_change"
                case productUnsatisfactory = "product_unsatisfactory"
            }

            public init(amount: Int? = nil, creditAmount: Int? = nil, endingBefore: String? = nil, expand: [String]? = nil, invoice: String, limit: Int? = nil, lines: [Lines]? = nil, memo: String? = nil, metadata: Metadata? = nil, outOfBandAmount: Int? = nil, reason: Reason? = nil, refund: String? = nil, refundAmount: Int? = nil, startingAfter: String? = nil) {
                self.amount = amount
                self.creditAmount = creditAmount
                self.endingBefore = endingBefore
                self.expand = expand
                self.invoice = invoice
                self.limit = limit
                self.lines = lines
                self.memo = memo
                self.metadata = metadata
                self.outOfBandAmount = outOfBandAmount
                self.reason = reason
                self.refund = refund
                self.refundAmount = refundAmount
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(creditAmount, forKey: "credit_amount")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(invoice, forKey: "invoice")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(lines, forKey: "lines", isDeepObject: true)
                encoder.encode(memo, forKey: "memo")
                encoder.encode(metadata, forKey: "metadata", isDeepObject: true)
                encoder.encode(outOfBandAmount, forKey: "out_of_band_amount")
                encoder.encode(reason, forKey: "reason")
                encoder.encode(refund, forKey: "refund")
                encoder.encode(refundAmount, forKey: "refund_amount")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }
    }
}

extension Paths.CreditNotes {
    public func creditNote(_ creditNote: String) -> WithCreditNote {
        WithCreditNote(path: "\(path)/\(creditNote)")
    }

    public struct WithCreditNote {
        /// Path: `/v1/credit_notes/{credit_note}`
        public let path: String
    }
}

extension Paths.CreditNotes.WithCreditNote {
    public var lines: Lines {
        Lines(path: path + "/lines")
    }

    public struct Lines {
        /// Path: `/v1/credit_notes/{credit_note}/lines`
        public let path: String

        /// <p>When retrieving a credit note, you’ll get a <strong>lines</strong> property containing the the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// CreditNoteLinesList
        public struct GetResponse: Decodable {
            /// Details about each object.
            public var data: [StripeAPI.CreditNoteLineItem]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.CreditNoteLineItem], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }
    }
}

extension Paths.CreditNotes {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/credit_notes/{id}`
        public let path: String

        /// <p>Retrieves the credit note object with the given identifier.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.CreditNote> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates an existing credit note.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.CreditNote> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Credit note memo.
            public var memo: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?

            public init(expand: [String]? = nil, memo: String? = nil, metadata: [String: String]? = nil) {
                self.expand = expand
                self.memo = memo
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(memo, forKey: "memo")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths.CreditNotes.WithID {
    public var void: Void {
        Void(path: path + "/void")
    }

    public struct Void {
        /// Path: `/v1/credit_notes/{id}/void`
        public let path: String

        /// <p>Marks a credit note as void. Learn more about <a href="/docs/billing/invoices/credit-notes#voiding">voiding credit notes</a>.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.CreditNote> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(expand: [String]? = nil) {
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var customers: Customers {
        Customers(path: "/v1/customers")
    }

    public struct Customers {
        /// Path: `/v1/customers`
        public let path: String

        /// <p>Returns a list of your customers. The customers are returned sorted by creation date, with the most recent customers appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Customer]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Customer], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var email: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(created: Created? = nil, email: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.created = created
                self.email = email
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(email, forKey: "email")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates a new customer object.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Customer> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The customer's address.
            public var address: Address?
            /// An integer amount in %s that represents the customer's current balance, which affect the customer's future invoices. A negative amount represents a credit that decreases the amount due on an invoice; a positive amount increases the amount due on an invoice.
            public var balance: Int?
            public var coupon: String?
            /// An arbitrary string that you can attach to a customer object. It is displayed alongside the customer in the dashboard.
            public var description: String?
            /// Customer's email address. It's displayed alongside the customer in your dashboard and can be useful for searching and tracking. This may be up to *512 characters*.
            public var email: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The prefix for the customer used to generate unique invoice numbers. Must be 3–12 uppercase letters or numbers.
            public var invoicePrefix: String?
            /// Customer_param
            ///
            /// Default invoice settings for this customer.
            public var invoiceSettings: InvoiceSettings?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The customer's full name or business name.
            public var name: String?
            /// The sequence to be used on the customer's next invoice. Defaults to 1.
            public var nextInvoiceSequence: Int?
            public var paymentMethod: String?
            /// The customer's phone number.
            public var phone: String?
            /// Customer's preferred languages, ordered by preference.
            public var preferredLocales: [String]?
            /// The API ID of a promotion code to apply to the customer. The customer will have a discount applied on all recurring payments. Charges you create through the API will not have the discount.
            public var promotionCode: String?
            /// The customer's shipping information. Appears on invoices emailed to this customer.
            public var shipping: Shipping?
            public var source: String?
            /// Tax_param
            ///
            /// Tax details about the customer.
            public var tax: Tax?
            /// The customer's tax exemption. One of `none`, `exempt`, or `reverse`.
            public var taxExempt: TaxExempt?
            /// The customer's tax IDs.
            public var taxIDData: [TaxIDDatum]?

            /// The customer's address.
            public struct Address: Encodable {
                /// Optional_fields_address
                public var a: A?
                public var b: B?

                /// Optional_fields_address
                public struct A: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Customer_param
            ///
            /// Default invoice settings for this customer.
            public struct InvoiceSettings: Encodable {
                public var customFields: CustomFields?
                public var defaultPaymentMethod: String?
                public var footer: String?

                public struct CustomFields: Encodable {
                    public var placeholderItems: [PlaceholderItem]?
                    public var object: Object?

                    /// Custom_field_params
                    public struct PlaceholderItem: Encodable {
                        public var name: String
                        public var value: String

                        public init(name: String, value: String) {
                            self.name = name
                            self.value = value
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(name, forKey: "name")
                            encoder.encode(value, forKey: "value")
                            return encoder.items
                        }
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                        self.placeholderItems = placeholderItems
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(placeholderItems, forKey: "placeholderItems")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(customFields: CustomFields? = nil, defaultPaymentMethod: String? = nil, footer: String? = nil) {
                    self.customFields = customFields
                    self.defaultPaymentMethod = defaultPaymentMethod
                    self.footer = footer
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(customFields, forKey: "custom_fields")
                    encoder.encode(defaultPaymentMethod, forKey: "default_payment_method")
                    encoder.encode(footer, forKey: "footer")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// The customer's shipping information. Appears on invoices emailed to this customer.
            public struct Shipping: Encodable {
                /// Customer_shipping
                public var a: A?
                public var b: B?

                /// Customer_shipping
                public struct A: Encodable {
                    /// Optional_fields_address
                    public var address: Address
                    public var name: String
                    public var phone: String?

                    /// Optional_fields_address
                    public struct Address: Encodable {
                        public var city: String?
                        public var country: String?
                        public var line1: String?
                        public var line2: String?
                        public var postalCode: String?
                        public var state: String?

                        public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                            self.city = city
                            self.country = country
                            self.line1 = line1
                            self.line2 = line2
                            self.postalCode = postalCode
                            self.state = state
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(city, forKey: "city")
                            encoder.encode(country, forKey: "country")
                            encoder.encode(line1, forKey: "line1")
                            encoder.encode(line2, forKey: "line2")
                            encoder.encode(postalCode, forKey: "postal_code")
                            encoder.encode(state, forKey: "state")
                            return encoder.items
                        }
                    }

                    public init(address: Address, name: String, phone: String? = nil) {
                        self.address = address
                        self.name = name
                        self.phone = phone
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(address, forKey: "address")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(phone, forKey: "phone")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Tax_param
            ///
            /// Tax details about the customer.
            public struct Tax: Encodable {
                public var ipAddress: IpAddress?

                public struct IpAddress: Encodable {
                    public var string: String?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(string: String? = nil, object: Object? = nil) {
                        self.string = string
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(string, forKey: "string")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(ipAddress: IpAddress? = nil) {
                    self.ipAddress = ipAddress
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(ipAddress, forKey: "ip_address")
                    return encoder.items
                }
            }

            /// The customer's tax exemption. One of `none`, `exempt`, or `reverse`.
            public enum TaxExempt: String, Codable, CaseIterable {
                case empty = ""
                case exempt
                case `none`
                case reverse
            }

            /// Data_params
            public struct TaxIDDatum: Encodable {
                public var type: `Type`
                public var value: String

                public enum `Type`: String, Codable, CaseIterable {
                    case aeTrn = "ae_trn"
                    case auAbn = "au_abn"
                    case auArn = "au_arn"
                    case brCnpj = "br_cnpj"
                    case brCpf = "br_cpf"
                    case caBn = "ca_bn"
                    case caGstHst = "ca_gst_hst"
                    case caPstBc = "ca_pst_bc"
                    case caPstMb = "ca_pst_mb"
                    case caPstSk = "ca_pst_sk"
                    case caQst = "ca_qst"
                    case chVat = "ch_vat"
                    case clTin = "cl_tin"
                    case esCif = "es_cif"
                    case euVat = "eu_vat"
                    case gbVat = "gb_vat"
                    case geVat = "ge_vat"
                    case hkBr = "hk_br"
                    case idNpwp = "id_npwp"
                    case ilVat = "il_vat"
                    case inGst = "in_gst"
                    case jpCn = "jp_cn"
                    case jpRn = "jp_rn"
                    case krBrn = "kr_brn"
                    case liUid = "li_uid"
                    case mxRfc = "mx_rfc"
                    case myFrp = "my_frp"
                    case myItn = "my_itn"
                    case mySst = "my_sst"
                    case noVat = "no_vat"
                    case nzGst = "nz_gst"
                    case ruInn = "ru_inn"
                    case ruKpp = "ru_kpp"
                    case saVat = "sa_vat"
                    case sgGst = "sg_gst"
                    case sgUen = "sg_uen"
                    case thVat = "th_vat"
                    case twVat = "tw_vat"
                    case uaVat = "ua_vat"
                    case usEin = "us_ein"
                    case zaVat = "za_vat"
                }

                public init(type: `Type`, value: String) {
                    self.type = type
                    self.value = value
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(type, forKey: "type")
                    encoder.encode(value, forKey: "value")
                    return encoder.items
                }
            }

            public init(address: Address? = nil, balance: Int? = nil, coupon: String? = nil, description: String? = nil, email: String? = nil, expand: [String]? = nil, invoicePrefix: String? = nil, invoiceSettings: InvoiceSettings? = nil, metadata: Metadata? = nil, name: String? = nil, nextInvoiceSequence: Int? = nil, paymentMethod: String? = nil, phone: String? = nil, preferredLocales: [String]? = nil, promotionCode: String? = nil, shipping: Shipping? = nil, source: String? = nil, tax: Tax? = nil, taxExempt: TaxExempt? = nil, taxIDData: [TaxIDDatum]? = nil) {
                self.address = address
                self.balance = balance
                self.coupon = coupon
                self.description = description
                self.email = email
                self.expand = expand
                self.invoicePrefix = invoicePrefix
                self.invoiceSettings = invoiceSettings
                self.metadata = metadata
                self.name = name
                self.nextInvoiceSequence = nextInvoiceSequence
                self.paymentMethod = paymentMethod
                self.phone = phone
                self.preferredLocales = preferredLocales
                self.promotionCode = promotionCode
                self.shipping = shipping
                self.source = source
                self.tax = tax
                self.taxExempt = taxExempt
                self.taxIDData = taxIDData
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(address, forKey: "address")
                encoder.encode(balance, forKey: "balance")
                encoder.encode(coupon, forKey: "coupon")
                encoder.encode(description, forKey: "description")
                encoder.encode(email, forKey: "email")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(invoicePrefix, forKey: "invoice_prefix")
                encoder.encode(invoiceSettings, forKey: "invoice_settings")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(name, forKey: "name")
                encoder.encode(nextInvoiceSequence, forKey: "next_invoice_sequence")
                encoder.encode(paymentMethod, forKey: "payment_method")
                encoder.encode(phone, forKey: "phone")
                encoder.encode(preferredLocales, forKey: "preferred_locales")
                encoder.encode(promotionCode, forKey: "promotion_code")
                encoder.encode(shipping, forKey: "shipping")
                encoder.encode(source, forKey: "source")
                encoder.encode(tax, forKey: "tax")
                encoder.encode(taxExempt, forKey: "tax_exempt")
                encoder.encode(taxIDData, forKey: "tax_id_data")
                return encoder.items
            }
        }
    }
}

extension Paths.Customers {
    public func customer(_ customer: String) -> WithCustomer {
        WithCustomer(path: "\(path)/\(customer)")
    }

    public struct WithCustomer {
        /// Path: `/v1/customers/{customer}`
        public let path: String

        /// <p>Retrieves a Customer object.</p>
        public func get(expand: [String]? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var customer: StripeAPI.Customer?
            public var deletedCustomer: StripeAPI.DeletedCustomer?

            public init(customer: StripeAPI.Customer? = nil, deletedCustomer: StripeAPI.DeletedCustomer? = nil) {
                self.customer = customer
                self.deletedCustomer = deletedCustomer
            }

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                self.customer = try? container.decode(StripeAPI.Customer.self)
                self.deletedCustomer = try? container.decode(StripeAPI.DeletedCustomer.self)
            }
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the specified customer by setting the values of the parameters passed. Any parameters not provided will be left unchanged. For example, if you pass the <strong>source</strong> parameter, that becomes the customer’s active source (e.g., a card) to be used for all charges in the future. When you update a customer to a new valid card source by passing the <strong>source</strong> parameter: for each of the customer’s current subscriptions, if the subscription bills automatically and is in the <code>past_due</code> state, then the latest open invoice for the subscription with automatic collection enabled will be retried. This retry will not count as an automatic retry, and will not affect the next regularly scheduled payment for the invoice. Changing the <strong>default_source</strong> for a customer will not trigger this behavior.</p>
        /// 
        /// <p>This request accepts mostly the same arguments as the customer creation call.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Customer> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The customer's address.
            public var address: Address?
            /// An integer amount in %s that represents the customer's current balance, which affect the customer's future invoices. A negative amount represents a credit that decreases the amount due on an invoice; a positive amount increases the amount due on an invoice.
            public var balance: Int?
            /// Either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details.
            public var bankAccount: BankAccount?
            /// A token, like the ones returned by [Stripe.js](https://stripe.com/docs/js).
            public var card: Card?
            public var coupon: String?
            /// ID of Alipay account to make the customer's new default for invoice payments.
            public var defaultAlipayAccount: String?
            /// ID of bank account to make the customer's new default for invoice payments.
            public var defaultBankAccount: String?
            /// ID of card to make the customer's new default for invoice payments.
            public var defaultCard: String?
            /// If you are using payment methods created via the PaymentMethods API, see the [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/update#update_customer-invoice_settings-default_payment_method) parameter.
            /// 
            /// Provide the ID of a payment source already attached to this customer to make it this customer's default payment source.
            /// 
            /// If you want to add a new payment source and make it the default, see the [source](https://stripe.com/docs/api/customers/update#update_customer-source) property.
            public var defaultSource: String?
            /// An arbitrary string that you can attach to a customer object. It is displayed alongside the customer in the dashboard.
            public var description: String?
            /// Customer's email address. It's displayed alongside the customer in your dashboard and can be useful for searching and tracking. This may be up to *512 characters*.
            public var email: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The prefix for the customer used to generate unique invoice numbers. Must be 3–12 uppercase letters or numbers.
            public var invoicePrefix: String?
            /// Customer_param
            ///
            /// Default invoice settings for this customer.
            public var invoiceSettings: InvoiceSettings?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The customer's full name or business name.
            public var name: String?
            /// The sequence to be used on the customer's next invoice. Defaults to 1.
            public var nextInvoiceSequence: Int?
            /// The customer's phone number.
            public var phone: String?
            /// Customer's preferred languages, ordered by preference.
            public var preferredLocales: [String]?
            /// The API ID of a promotion code to apply to the customer. The customer will have a discount applied on all recurring payments. Charges you create through the API will not have the discount.
            public var promotionCode: String?
            /// The customer's shipping information. Appears on invoices emailed to this customer.
            public var shipping: Shipping?
            public var source: String?
            /// Tax_param
            ///
            /// Tax details about the customer.
            public var tax: Tax?
            /// The customer's tax exemption. One of `none`, `exempt`, or `reverse`.
            public var taxExempt: TaxExempt?
            /// Unix timestamp representing the end of the trial period the customer will get before being charged for the first time. This will always overwrite any trials that might apply via a subscribed plan. If set, trial_end will override the default trial period of the plan the customer is being subscribed to. The special value `now` can be provided to end the customer's trial immediately. Can be at most two years from `billing_cycle_anchor`.
            public var trialEnd: TrialEnd?

            /// The customer's address.
            public struct Address: Encodable {
                /// Optional_fields_address
                public var a: A?
                public var b: B?

                /// Optional_fields_address
                public struct A: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details.
            public struct BankAccount: Encodable {
                /// Customer_payment_source_bank_account
                public var object: Object?
                public var string: String?

                /// Customer_payment_source_bank_account
                public struct Object: Encodable {
                    public var accountHolderName: String?
                    public var accountHolderType: AccountHolderType?
                    public var accountNumber: String
                    public var country: String
                    public var currency: String?
                    public var object: Object?
                    public var routingNumber: String?

                    public enum AccountHolderType: String, Codable, CaseIterable {
                        case company
                        case individual
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case bankAccount = "bank_account"
                    }

                    public init(accountHolderName: String? = nil, accountHolderType: AccountHolderType? = nil, accountNumber: String, country: String, currency: String? = nil, object: Object? = nil, routingNumber: String? = nil) {
                        self.accountHolderName = accountHolderName
                        self.accountHolderType = accountHolderType
                        self.accountNumber = accountNumber
                        self.country = country
                        self.currency = currency
                        self.object = object
                        self.routingNumber = routingNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountHolderName, forKey: "account_holder_name")
                        encoder.encode(accountHolderType, forKey: "account_holder_type")
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(object, forKey: "object")
                        encoder.encode(routingNumber, forKey: "routing_number")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, string: String? = nil) {
                    self.object = object
                    self.string = string
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(string, forKey: "string")
                    return encoder.items
                }
            }

            /// A token, like the ones returned by [Stripe.js](https://stripe.com/docs/js).
            public struct Card: Encodable {
                /// Customer_payment_source_card
                public var object: Object?
                public var string: String?

                /// Customer_payment_source_card
                public struct Object: Encodable {
                    public var addressCity: String?
                    public var addressCountry: String?
                    public var addressLine1: String?
                    public var addressLine2: String?
                    public var addressState: String?
                    public var addressZip: String?
                    public var cvc: String?
                    public var expMonth: Int
                    public var expYear: Int
                    public var metadata: [String: String]?
                    public var name: String?
                    public var number: String
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case card
                    }

                    public init(addressCity: String? = nil, addressCountry: String? = nil, addressLine1: String? = nil, addressLine2: String? = nil, addressState: String? = nil, addressZip: String? = nil, cvc: String? = nil, expMonth: Int, expYear: Int, metadata: [String: String]? = nil, name: String? = nil, number: String, object: Object? = nil) {
                        self.addressCity = addressCity
                        self.addressCountry = addressCountry
                        self.addressLine1 = addressLine1
                        self.addressLine2 = addressLine2
                        self.addressState = addressState
                        self.addressZip = addressZip
                        self.cvc = cvc
                        self.expMonth = expMonth
                        self.expYear = expYear
                        self.metadata = metadata
                        self.name = name
                        self.number = number
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(addressCity, forKey: "address_city")
                        encoder.encode(addressCountry, forKey: "address_country")
                        encoder.encode(addressLine1, forKey: "address_line1")
                        encoder.encode(addressLine2, forKey: "address_line2")
                        encoder.encode(addressState, forKey: "address_state")
                        encoder.encode(addressZip, forKey: "address_zip")
                        encoder.encode(cvc, forKey: "cvc")
                        encoder.encode(expMonth, forKey: "exp_month")
                        encoder.encode(expYear, forKey: "exp_year")
                        encoder.encode(metadata, forKey: "metadata")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(number, forKey: "number")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, string: String? = nil) {
                    self.object = object
                    self.string = string
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(string, forKey: "string")
                    return encoder.items
                }
            }

            /// Customer_param
            ///
            /// Default invoice settings for this customer.
            public struct InvoiceSettings: Encodable {
                public var customFields: CustomFields?
                public var defaultPaymentMethod: String?
                public var footer: String?

                public struct CustomFields: Encodable {
                    public var placeholderItems: [PlaceholderItem]?
                    public var object: Object?

                    /// Custom_field_params
                    public struct PlaceholderItem: Encodable {
                        public var name: String
                        public var value: String

                        public init(name: String, value: String) {
                            self.name = name
                            self.value = value
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(name, forKey: "name")
                            encoder.encode(value, forKey: "value")
                            return encoder.items
                        }
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                        self.placeholderItems = placeholderItems
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(placeholderItems, forKey: "placeholderItems")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(customFields: CustomFields? = nil, defaultPaymentMethod: String? = nil, footer: String? = nil) {
                    self.customFields = customFields
                    self.defaultPaymentMethod = defaultPaymentMethod
                    self.footer = footer
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(customFields, forKey: "custom_fields")
                    encoder.encode(defaultPaymentMethod, forKey: "default_payment_method")
                    encoder.encode(footer, forKey: "footer")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// The customer's shipping information. Appears on invoices emailed to this customer.
            public struct Shipping: Encodable {
                /// Customer_shipping
                public var a: A?
                public var b: B?

                /// Customer_shipping
                public struct A: Encodable {
                    /// Optional_fields_address
                    public var address: Address
                    public var name: String
                    public var phone: String?

                    /// Optional_fields_address
                    public struct Address: Encodable {
                        public var city: String?
                        public var country: String?
                        public var line1: String?
                        public var line2: String?
                        public var postalCode: String?
                        public var state: String?

                        public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                            self.city = city
                            self.country = country
                            self.line1 = line1
                            self.line2 = line2
                            self.postalCode = postalCode
                            self.state = state
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(city, forKey: "city")
                            encoder.encode(country, forKey: "country")
                            encoder.encode(line1, forKey: "line1")
                            encoder.encode(line2, forKey: "line2")
                            encoder.encode(postalCode, forKey: "postal_code")
                            encoder.encode(state, forKey: "state")
                            return encoder.items
                        }
                    }

                    public init(address: Address, name: String, phone: String? = nil) {
                        self.address = address
                        self.name = name
                        self.phone = phone
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(address, forKey: "address")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(phone, forKey: "phone")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Tax_param
            ///
            /// Tax details about the customer.
            public struct Tax: Encodable {
                public var ipAddress: IpAddress?

                public struct IpAddress: Encodable {
                    public var string: String?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(string: String? = nil, object: Object? = nil) {
                        self.string = string
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(string, forKey: "string")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(ipAddress: IpAddress? = nil) {
                    self.ipAddress = ipAddress
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(ipAddress, forKey: "ip_address")
                    return encoder.items
                }
            }

            /// The customer's tax exemption. One of `none`, `exempt`, or `reverse`.
            public enum TaxExempt: String, Codable, CaseIterable {
                case empty = ""
                case exempt
                case `none`
                case reverse
            }

            /// Unix timestamp representing the end of the trial period the customer will get before being charged for the first time. This will always overwrite any trials that might apply via a subscribed plan. If set, trial_end will override the default trial period of the plan the customer is being subscribed to. The special value `now` can be provided to end the customer's trial immediately. Can be at most two years from `billing_cycle_anchor`.
            public struct TrialEnd: Encodable {
                public var object: Object?
                public var int: Int?

                public enum Object: String, Codable, CaseIterable {
                    case now
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(address: Address? = nil, balance: Int? = nil, bankAccount: BankAccount? = nil, card: Card? = nil, coupon: String? = nil, defaultAlipayAccount: String? = nil, defaultBankAccount: String? = nil, defaultCard: String? = nil, defaultSource: String? = nil, description: String? = nil, email: String? = nil, expand: [String]? = nil, invoicePrefix: String? = nil, invoiceSettings: InvoiceSettings? = nil, metadata: Metadata? = nil, name: String? = nil, nextInvoiceSequence: Int? = nil, phone: String? = nil, preferredLocales: [String]? = nil, promotionCode: String? = nil, shipping: Shipping? = nil, source: String? = nil, tax: Tax? = nil, taxExempt: TaxExempt? = nil, trialEnd: TrialEnd? = nil) {
                self.address = address
                self.balance = balance
                self.bankAccount = bankAccount
                self.card = card
                self.coupon = coupon
                self.defaultAlipayAccount = defaultAlipayAccount
                self.defaultBankAccount = defaultBankAccount
                self.defaultCard = defaultCard
                self.defaultSource = defaultSource
                self.description = description
                self.email = email
                self.expand = expand
                self.invoicePrefix = invoicePrefix
                self.invoiceSettings = invoiceSettings
                self.metadata = metadata
                self.name = name
                self.nextInvoiceSequence = nextInvoiceSequence
                self.phone = phone
                self.preferredLocales = preferredLocales
                self.promotionCode = promotionCode
                self.shipping = shipping
                self.source = source
                self.tax = tax
                self.taxExempt = taxExempt
                self.trialEnd = trialEnd
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(address, forKey: "address")
                encoder.encode(balance, forKey: "balance")
                encoder.encode(bankAccount, forKey: "bank_account")
                encoder.encode(card, forKey: "card")
                encoder.encode(coupon, forKey: "coupon")
                encoder.encode(defaultAlipayAccount, forKey: "default_alipay_account")
                encoder.encode(defaultBankAccount, forKey: "default_bank_account")
                encoder.encode(defaultCard, forKey: "default_card")
                encoder.encode(defaultSource, forKey: "default_source")
                encoder.encode(description, forKey: "description")
                encoder.encode(email, forKey: "email")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(invoicePrefix, forKey: "invoice_prefix")
                encoder.encode(invoiceSettings, forKey: "invoice_settings")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(name, forKey: "name")
                encoder.encode(nextInvoiceSequence, forKey: "next_invoice_sequence")
                encoder.encode(phone, forKey: "phone")
                encoder.encode(preferredLocales, forKey: "preferred_locales")
                encoder.encode(promotionCode, forKey: "promotion_code")
                encoder.encode(shipping, forKey: "shipping")
                encoder.encode(source, forKey: "source")
                encoder.encode(tax, forKey: "tax")
                encoder.encode(taxExempt, forKey: "tax_exempt")
                encoder.encode(trialEnd, forKey: "trial_end")
                return encoder.items
            }
        }

        /// <p>Permanently deletes a customer. It cannot be undone. Also immediately cancels any active subscriptions on the customer.</p>
        public var delete: Request<StripeAPI.DeletedCustomer> {
            .delete(path)
        }
    }
}

extension Paths.Customers.WithCustomer {
    public var balanceTransactions: BalanceTransactions {
        BalanceTransactions(path: path + "/balance_transactions")
    }

    public struct BalanceTransactions {
        /// Path: `/v1/customers/{customer}/balance_transactions`
        public let path: String

        /// <p>Returns a list of transactions that updated the customer’s <a href="/docs/billing/customer/balance">balances</a>.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// CustomerBalanceTransactionList
        public struct GetResponse: Decodable {
            /// Details about each object.
            public var data: [StripeAPI.CustomerBalanceTransaction]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.CustomerBalanceTransaction], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates an immutable transaction that updates the customer’s credit <a href="/docs/billing/customer/balance">balance</a>.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.CustomerBalanceTransaction> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The integer amount in **%s** to apply to the customer's credit balance.
            public var amount: Int
            /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies). If the customer's [`currency`](https://stripe.com/docs/api/customers/object#customer_object-currency) is set, this value must match it. If the customer's `currency` is not set, it will be updated to this value.
            public var currency: String
            /// An arbitrary string attached to the object. Often useful for displaying to users.
            public var description: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(amount: Int, currency: String, description: String? = nil, expand: [String]? = nil, metadata: Metadata? = nil) {
                self.amount = amount
                self.currency = currency
                self.description = description
                self.expand = expand
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(description, forKey: "description")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths.Customers.WithCustomer.BalanceTransactions {
    public func transaction(_ transaction: String) -> WithTransaction {
        WithTransaction(path: "\(path)/\(transaction)")
    }

    public struct WithTransaction {
        /// Path: `/v1/customers/{customer}/balance_transactions/{transaction}`
        public let path: String

        /// <p>Retrieves a specific customer balance transaction that updated the customer’s <a href="/docs/billing/customer/balance">balances</a>.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.CustomerBalanceTransaction> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Most credit balance transaction fields are immutable, but you may update its <code>description</code> and <code>metadata</code>.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.CustomerBalanceTransaction> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// An arbitrary string attached to the object. Often useful for displaying to users.
            public var description: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(description: String? = nil, expand: [String]? = nil, metadata: Metadata? = nil) {
                self.description = description
                self.expand = expand
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(description, forKey: "description")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths.Customers.WithCustomer {
    public var bankAccounts: BankAccounts {
        BankAccounts(path: path + "/bank_accounts")
    }

    public struct BankAccounts {
        /// Path: `/v1/customers/{customer}/bank_accounts`
        public let path: String

        /// <p>You can see a list of the bank accounts belonging to a Customer. Note that the 10 most recent sources are always available by default on the Customer. If you need more than those 10, you can use this API method and the <code>limit</code> and <code>starting_after</code> parameters to page through additional bank accounts.</p>
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// BankAccountList
        public struct GetResponse: Decodable {
            /// Details about each object.
            public var data: [StripeAPI.BankAccount]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.BankAccount], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>When you create a new credit card, you must specify a customer or recipient on which to create it.</p>
        /// 
        /// <p>If the card’s owner has no default card, then the new card will become the default.
        /// However, if the owner already has a default, then it will not change.
        /// To change the default, you should <a href="/docs/api#update_customer">update the customer</a> to have a new <code>default_source</code>.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.PaymentSource> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// A token returned by [Stripe.js](https://stripe.com/docs/js) representing the user’s Alipay account details.
            public var alipayAccount: String?
            /// Either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details.
            public var bankAccount: BankAccount?
            /// A token, like the ones returned by [Stripe.js](https://stripe.com/docs/js).
            public var card: Card?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// Please refer to full [documentation](https://stripe.com/docs/api) instead.
            public var source: String?

            /// Either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details.
            public struct BankAccount: Encodable {
                /// Customer_payment_source_bank_account
                public var object: Object?
                public var string: String?

                /// Customer_payment_source_bank_account
                public struct Object: Encodable {
                    public var accountHolderName: String?
                    public var accountHolderType: AccountHolderType?
                    public var accountNumber: String
                    public var country: String
                    public var currency: String?
                    public var object: Object?
                    public var routingNumber: String?

                    public enum AccountHolderType: String, Codable, CaseIterable {
                        case company
                        case individual
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case bankAccount = "bank_account"
                    }

                    public init(accountHolderName: String? = nil, accountHolderType: AccountHolderType? = nil, accountNumber: String, country: String, currency: String? = nil, object: Object? = nil, routingNumber: String? = nil) {
                        self.accountHolderName = accountHolderName
                        self.accountHolderType = accountHolderType
                        self.accountNumber = accountNumber
                        self.country = country
                        self.currency = currency
                        self.object = object
                        self.routingNumber = routingNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountHolderName, forKey: "account_holder_name")
                        encoder.encode(accountHolderType, forKey: "account_holder_type")
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(object, forKey: "object")
                        encoder.encode(routingNumber, forKey: "routing_number")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, string: String? = nil) {
                    self.object = object
                    self.string = string
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(string, forKey: "string")
                    return encoder.items
                }
            }

            /// A token, like the ones returned by [Stripe.js](https://stripe.com/docs/js).
            public struct Card: Encodable {
                /// Customer_payment_source_card
                public var object: Object?
                public var string: String?

                /// Customer_payment_source_card
                public struct Object: Encodable {
                    public var addressCity: String?
                    public var addressCountry: String?
                    public var addressLine1: String?
                    public var addressLine2: String?
                    public var addressState: String?
                    public var addressZip: String?
                    public var cvc: String?
                    public var expMonth: Int
                    public var expYear: Int
                    public var metadata: [String: String]?
                    public var name: String?
                    public var number: String
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case card
                    }

                    public init(addressCity: String? = nil, addressCountry: String? = nil, addressLine1: String? = nil, addressLine2: String? = nil, addressState: String? = nil, addressZip: String? = nil, cvc: String? = nil, expMonth: Int, expYear: Int, metadata: [String: String]? = nil, name: String? = nil, number: String, object: Object? = nil) {
                        self.addressCity = addressCity
                        self.addressCountry = addressCountry
                        self.addressLine1 = addressLine1
                        self.addressLine2 = addressLine2
                        self.addressState = addressState
                        self.addressZip = addressZip
                        self.cvc = cvc
                        self.expMonth = expMonth
                        self.expYear = expYear
                        self.metadata = metadata
                        self.name = name
                        self.number = number
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(addressCity, forKey: "address_city")
                        encoder.encode(addressCountry, forKey: "address_country")
                        encoder.encode(addressLine1, forKey: "address_line1")
                        encoder.encode(addressLine2, forKey: "address_line2")
                        encoder.encode(addressState, forKey: "address_state")
                        encoder.encode(addressZip, forKey: "address_zip")
                        encoder.encode(cvc, forKey: "cvc")
                        encoder.encode(expMonth, forKey: "exp_month")
                        encoder.encode(expYear, forKey: "exp_year")
                        encoder.encode(metadata, forKey: "metadata")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(number, forKey: "number")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, string: String? = nil) {
                    self.object = object
                    self.string = string
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(string, forKey: "string")
                    return encoder.items
                }
            }

            public init(alipayAccount: String? = nil, bankAccount: BankAccount? = nil, card: Card? = nil, expand: [String]? = nil, metadata: [String: String]? = nil, source: String? = nil) {
                self.alipayAccount = alipayAccount
                self.bankAccount = bankAccount
                self.card = card
                self.expand = expand
                self.metadata = metadata
                self.source = source
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(alipayAccount, forKey: "alipay_account")
                encoder.encode(bankAccount, forKey: "bank_account")
                encoder.encode(card, forKey: "card")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(source, forKey: "source")
                return encoder.items
            }
        }
    }
}

extension Paths.Customers.WithCustomer.BankAccounts {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/customers/{customer}/bank_accounts/{id}`
        public let path: String

        /// <p>By default, you can see the 10 most recent sources stored on a Customer directly on the object, but you can also retrieve details about a specific bank account stored on the Stripe account.</p>
        @available(*, deprecated, message: "Deprecated")
        public func get(expand: [String]? = nil) -> Request<StripeAPI.BankAccount> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Update a specified source for a given customer.</p>
        public func post(_ body: PostRequest? = nil) -> Request<PostResponse> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostResponse: Decodable {
            public var card: StripeAPI.Card?
            public var bankAccount: StripeAPI.BankAccount?
            /// `Source` objects allow you to accept a variety of payment methods. They
            /// represent a customer's payment instrument, and can be used with the Stripe API
            /// just like a `Card` object: once chargeable, they can be charged, or can be
            /// attached to customers.
            /// 
            /// Related guides: [Sources API](https://stripe.com/docs/sources) and [Sources & Customers](https://stripe.com/docs/sources/customers).
            public var source: StripeAPI.Source?

            public init(card: StripeAPI.Card? = nil, bankAccount: StripeAPI.BankAccount? = nil, source: StripeAPI.Source? = nil) {
                self.card = card
                self.bankAccount = bankAccount
                self.source = source
            }

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                self.card = try? container.decode(StripeAPI.Card.self)
                self.bankAccount = try? container.decode(StripeAPI.BankAccount.self)
                self.source = try? container.decode(StripeAPI.Source.self)
            }
        }

        public struct PostRequest: Encodable {
            /// The name of the person or business that owns the bank account.
            public var accountHolderName: String?
            /// The type of entity that holds the account. This can be either `individual` or `company`.
            public var accountHolderType: AccountHolderType?
            /// City/District/Suburb/Town/Village.
            public var addressCity: String?
            /// Billing address country, if provided when creating card.
            public var addressCountry: String?
            /// Address line 1 (Street address/PO Box/Company name).
            public var addressLine1: String?
            /// Address line 2 (Apartment/Suite/Unit/Building).
            public var addressLine2: String?
            /// State/County/Province/Region.
            public var addressState: String?
            /// ZIP or postal code.
            public var addressZip: String?
            /// Two digit number representing the card’s expiration month.
            public var expMonth: String?
            /// Four digit number representing the card’s expiration year.
            public var expYear: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// Cardholder name.
            public var name: String?
            public var owner: Owner?

            /// The type of entity that holds the account. This can be either `individual` or `company`.
            public enum AccountHolderType: String, Codable, CaseIterable {
                case company
                case individual
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public struct Owner: Encodable {
                /// Source_address
                public var address: Address?
                public var email: String?
                public var name: String?
                public var phone: String?

                /// Source_address
                public struct Address: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                public init(address: Address? = nil, email: String? = nil, name: String? = nil, phone: String? = nil) {
                    self.address = address
                    self.email = email
                    self.name = name
                    self.phone = phone
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(email, forKey: "email")
                    encoder.encode(name, forKey: "name")
                    encoder.encode(phone, forKey: "phone")
                    return encoder.items
                }
            }

            public init(accountHolderName: String? = nil, accountHolderType: AccountHolderType? = nil, addressCity: String? = nil, addressCountry: String? = nil, addressLine1: String? = nil, addressLine2: String? = nil, addressState: String? = nil, addressZip: String? = nil, expMonth: String? = nil, expYear: String? = nil, expand: [String]? = nil, metadata: Metadata? = nil, name: String? = nil, owner: Owner? = nil) {
                self.accountHolderName = accountHolderName
                self.accountHolderType = accountHolderType
                self.addressCity = addressCity
                self.addressCountry = addressCountry
                self.addressLine1 = addressLine1
                self.addressLine2 = addressLine2
                self.addressState = addressState
                self.addressZip = addressZip
                self.expMonth = expMonth
                self.expYear = expYear
                self.expand = expand
                self.metadata = metadata
                self.name = name
                self.owner = owner
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(accountHolderName, forKey: "account_holder_name")
                encoder.encode(accountHolderType, forKey: "account_holder_type")
                encoder.encode(addressCity, forKey: "address_city")
                encoder.encode(addressCountry, forKey: "address_country")
                encoder.encode(addressLine1, forKey: "address_line1")
                encoder.encode(addressLine2, forKey: "address_line2")
                encoder.encode(addressState, forKey: "address_state")
                encoder.encode(addressZip, forKey: "address_zip")
                encoder.encode(expMonth, forKey: "exp_month")
                encoder.encode(expYear, forKey: "exp_year")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(name, forKey: "name")
                encoder.encode(owner, forKey: "owner")
                return encoder.items
            }
        }

        /// <p>Delete a specified source for a given customer.</p>
        public func delete(_ body: DeleteRequest? = nil) -> Request<DeleteResponse> {
            .delete(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct DeleteResponse: Decodable {
            public var paymentSource: StripeAPI.PaymentSource?
            /// Polymorphic
            public var deletedPaymentSource: StripeAPI.DeletedPaymentSource?

            public init(paymentSource: StripeAPI.PaymentSource? = nil, deletedPaymentSource: StripeAPI.DeletedPaymentSource? = nil) {
                self.paymentSource = paymentSource
                self.deletedPaymentSource = deletedPaymentSource
            }

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                self.paymentSource = try? container.decode(StripeAPI.PaymentSource.self)
                self.deletedPaymentSource = try? container.decode(StripeAPI.DeletedPaymentSource.self)
            }
        }

        public struct DeleteRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(expand: [String]? = nil) {
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.Customers.WithCustomer.BankAccounts.WithID {
    public var verify: Verify {
        Verify(path: path + "/verify")
    }

    public struct Verify {
        /// Path: `/v1/customers/{customer}/bank_accounts/{id}/verify`
        public let path: String

        /// <p>Verify a specified bank account for a given customer.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.BankAccount> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Two positive integers, in *cents*, equal to the values of the microdeposits sent to the bank account.
            public var amounts: [Int]?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(amounts: [Int]? = nil, expand: [String]? = nil) {
                self.amounts = amounts
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amounts, forKey: "amounts")
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.Customers.WithCustomer {
    public var cards: Cards {
        Cards(path: path + "/cards")
    }

    public struct Cards {
        /// Path: `/v1/customers/{customer}/cards`
        public let path: String

        /// <p>You can see a list of the cards belonging to a customer.
        /// Note that the 10 most recent sources are always available on the <code>Customer</code> object.
        /// If you need more than those 10, you can use this API method and the <code>limit</code> and <code>starting_after</code> parameters to page through additional cards.</p>
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// CardList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Card]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Card], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>When you create a new credit card, you must specify a customer or recipient on which to create it.</p>
        /// 
        /// <p>If the card’s owner has no default card, then the new card will become the default.
        /// However, if the owner already has a default, then it will not change.
        /// To change the default, you should <a href="/docs/api#update_customer">update the customer</a> to have a new <code>default_source</code>.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.PaymentSource> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// A token returned by [Stripe.js](https://stripe.com/docs/js) representing the user’s Alipay account details.
            public var alipayAccount: String?
            /// Either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details.
            public var bankAccount: BankAccount?
            /// A token, like the ones returned by [Stripe.js](https://stripe.com/docs/js).
            public var card: Card?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// Please refer to full [documentation](https://stripe.com/docs/api) instead.
            public var source: String?

            /// Either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details.
            public struct BankAccount: Encodable {
                /// Customer_payment_source_bank_account
                public var object: Object?
                public var string: String?

                /// Customer_payment_source_bank_account
                public struct Object: Encodable {
                    public var accountHolderName: String?
                    public var accountHolderType: AccountHolderType?
                    public var accountNumber: String
                    public var country: String
                    public var currency: String?
                    public var object: Object?
                    public var routingNumber: String?

                    public enum AccountHolderType: String, Codable, CaseIterable {
                        case company
                        case individual
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case bankAccount = "bank_account"
                    }

                    public init(accountHolderName: String? = nil, accountHolderType: AccountHolderType? = nil, accountNumber: String, country: String, currency: String? = nil, object: Object? = nil, routingNumber: String? = nil) {
                        self.accountHolderName = accountHolderName
                        self.accountHolderType = accountHolderType
                        self.accountNumber = accountNumber
                        self.country = country
                        self.currency = currency
                        self.object = object
                        self.routingNumber = routingNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountHolderName, forKey: "account_holder_name")
                        encoder.encode(accountHolderType, forKey: "account_holder_type")
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(object, forKey: "object")
                        encoder.encode(routingNumber, forKey: "routing_number")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, string: String? = nil) {
                    self.object = object
                    self.string = string
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(string, forKey: "string")
                    return encoder.items
                }
            }

            /// A token, like the ones returned by [Stripe.js](https://stripe.com/docs/js).
            public struct Card: Encodable {
                /// Customer_payment_source_card
                public var object: Object?
                public var string: String?

                /// Customer_payment_source_card
                public struct Object: Encodable {
                    public var addressCity: String?
                    public var addressCountry: String?
                    public var addressLine1: String?
                    public var addressLine2: String?
                    public var addressState: String?
                    public var addressZip: String?
                    public var cvc: String?
                    public var expMonth: Int
                    public var expYear: Int
                    public var metadata: [String: String]?
                    public var name: String?
                    public var number: String
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case card
                    }

                    public init(addressCity: String? = nil, addressCountry: String? = nil, addressLine1: String? = nil, addressLine2: String? = nil, addressState: String? = nil, addressZip: String? = nil, cvc: String? = nil, expMonth: Int, expYear: Int, metadata: [String: String]? = nil, name: String? = nil, number: String, object: Object? = nil) {
                        self.addressCity = addressCity
                        self.addressCountry = addressCountry
                        self.addressLine1 = addressLine1
                        self.addressLine2 = addressLine2
                        self.addressState = addressState
                        self.addressZip = addressZip
                        self.cvc = cvc
                        self.expMonth = expMonth
                        self.expYear = expYear
                        self.metadata = metadata
                        self.name = name
                        self.number = number
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(addressCity, forKey: "address_city")
                        encoder.encode(addressCountry, forKey: "address_country")
                        encoder.encode(addressLine1, forKey: "address_line1")
                        encoder.encode(addressLine2, forKey: "address_line2")
                        encoder.encode(addressState, forKey: "address_state")
                        encoder.encode(addressZip, forKey: "address_zip")
                        encoder.encode(cvc, forKey: "cvc")
                        encoder.encode(expMonth, forKey: "exp_month")
                        encoder.encode(expYear, forKey: "exp_year")
                        encoder.encode(metadata, forKey: "metadata")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(number, forKey: "number")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, string: String? = nil) {
                    self.object = object
                    self.string = string
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(string, forKey: "string")
                    return encoder.items
                }
            }

            public init(alipayAccount: String? = nil, bankAccount: BankAccount? = nil, card: Card? = nil, expand: [String]? = nil, metadata: [String: String]? = nil, source: String? = nil) {
                self.alipayAccount = alipayAccount
                self.bankAccount = bankAccount
                self.card = card
                self.expand = expand
                self.metadata = metadata
                self.source = source
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(alipayAccount, forKey: "alipay_account")
                encoder.encode(bankAccount, forKey: "bank_account")
                encoder.encode(card, forKey: "card")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(source, forKey: "source")
                return encoder.items
            }
        }
    }
}

extension Paths.Customers.WithCustomer.Cards {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/customers/{customer}/cards/{id}`
        public let path: String

        /// <p>You can always see the 10 most recent cards directly on a customer; this method lets you retrieve details about a specific card stored on the customer.</p>
        @available(*, deprecated, message: "Deprecated")
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Card> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Update a specified source for a given customer.</p>
        public func post(_ body: PostRequest? = nil) -> Request<PostResponse> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostResponse: Decodable {
            public var card: StripeAPI.Card?
            public var bankAccount: StripeAPI.BankAccount?
            /// `Source` objects allow you to accept a variety of payment methods. They
            /// represent a customer's payment instrument, and can be used with the Stripe API
            /// just like a `Card` object: once chargeable, they can be charged, or can be
            /// attached to customers.
            /// 
            /// Related guides: [Sources API](https://stripe.com/docs/sources) and [Sources & Customers](https://stripe.com/docs/sources/customers).
            public var source: StripeAPI.Source?

            public init(card: StripeAPI.Card? = nil, bankAccount: StripeAPI.BankAccount? = nil, source: StripeAPI.Source? = nil) {
                self.card = card
                self.bankAccount = bankAccount
                self.source = source
            }

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                self.card = try? container.decode(StripeAPI.Card.self)
                self.bankAccount = try? container.decode(StripeAPI.BankAccount.self)
                self.source = try? container.decode(StripeAPI.Source.self)
            }
        }

        public struct PostRequest: Encodable {
            /// The name of the person or business that owns the bank account.
            public var accountHolderName: String?
            /// The type of entity that holds the account. This can be either `individual` or `company`.
            public var accountHolderType: AccountHolderType?
            /// City/District/Suburb/Town/Village.
            public var addressCity: String?
            /// Billing address country, if provided when creating card.
            public var addressCountry: String?
            /// Address line 1 (Street address/PO Box/Company name).
            public var addressLine1: String?
            /// Address line 2 (Apartment/Suite/Unit/Building).
            public var addressLine2: String?
            /// State/County/Province/Region.
            public var addressState: String?
            /// ZIP or postal code.
            public var addressZip: String?
            /// Two digit number representing the card’s expiration month.
            public var expMonth: String?
            /// Four digit number representing the card’s expiration year.
            public var expYear: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// Cardholder name.
            public var name: String?
            public var owner: Owner?

            /// The type of entity that holds the account. This can be either `individual` or `company`.
            public enum AccountHolderType: String, Codable, CaseIterable {
                case company
                case individual
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public struct Owner: Encodable {
                /// Source_address
                public var address: Address?
                public var email: String?
                public var name: String?
                public var phone: String?

                /// Source_address
                public struct Address: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                public init(address: Address? = nil, email: String? = nil, name: String? = nil, phone: String? = nil) {
                    self.address = address
                    self.email = email
                    self.name = name
                    self.phone = phone
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(email, forKey: "email")
                    encoder.encode(name, forKey: "name")
                    encoder.encode(phone, forKey: "phone")
                    return encoder.items
                }
            }

            public init(accountHolderName: String? = nil, accountHolderType: AccountHolderType? = nil, addressCity: String? = nil, addressCountry: String? = nil, addressLine1: String? = nil, addressLine2: String? = nil, addressState: String? = nil, addressZip: String? = nil, expMonth: String? = nil, expYear: String? = nil, expand: [String]? = nil, metadata: Metadata? = nil, name: String? = nil, owner: Owner? = nil) {
                self.accountHolderName = accountHolderName
                self.accountHolderType = accountHolderType
                self.addressCity = addressCity
                self.addressCountry = addressCountry
                self.addressLine1 = addressLine1
                self.addressLine2 = addressLine2
                self.addressState = addressState
                self.addressZip = addressZip
                self.expMonth = expMonth
                self.expYear = expYear
                self.expand = expand
                self.metadata = metadata
                self.name = name
                self.owner = owner
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(accountHolderName, forKey: "account_holder_name")
                encoder.encode(accountHolderType, forKey: "account_holder_type")
                encoder.encode(addressCity, forKey: "address_city")
                encoder.encode(addressCountry, forKey: "address_country")
                encoder.encode(addressLine1, forKey: "address_line1")
                encoder.encode(addressLine2, forKey: "address_line2")
                encoder.encode(addressState, forKey: "address_state")
                encoder.encode(addressZip, forKey: "address_zip")
                encoder.encode(expMonth, forKey: "exp_month")
                encoder.encode(expYear, forKey: "exp_year")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(name, forKey: "name")
                encoder.encode(owner, forKey: "owner")
                return encoder.items
            }
        }

        /// <p>Delete a specified source for a given customer.</p>
        public func delete(_ body: DeleteRequest? = nil) -> Request<DeleteResponse> {
            .delete(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct DeleteResponse: Decodable {
            public var paymentSource: StripeAPI.PaymentSource?
            /// Polymorphic
            public var deletedPaymentSource: StripeAPI.DeletedPaymentSource?

            public init(paymentSource: StripeAPI.PaymentSource? = nil, deletedPaymentSource: StripeAPI.DeletedPaymentSource? = nil) {
                self.paymentSource = paymentSource
                self.deletedPaymentSource = deletedPaymentSource
            }

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                self.paymentSource = try? container.decode(StripeAPI.PaymentSource.self)
                self.deletedPaymentSource = try? container.decode(StripeAPI.DeletedPaymentSource.self)
            }
        }

        public struct DeleteRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(expand: [String]? = nil) {
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.Customers.WithCustomer {
    public var discount: Discount {
        Discount(path: path + "/discount")
    }

    public struct Discount {
        /// Path: `/v1/customers/{customer}/discount`
        public let path: String

        public func get(expand: [String]? = nil) -> Request<StripeAPI.Discount> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Removes the currently applied discount on a customer.</p>
        public var delete: Request<StripeAPI.DeletedDiscount> {
            .delete(path)
        }
    }
}

extension Paths.Customers.WithCustomer {
    public var paymentMethods: PaymentMethods {
        PaymentMethods(path: path + "/payment_methods")
    }

    public struct PaymentMethods {
        /// Path: `/v1/customers/{customer}/payment_methods`
        public let path: String

        /// <p>Returns a list of PaymentMethods for a given Customer</p>
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        /// CustomerPaymentMethodResourceList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.PaymentMethod]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.PaymentMethod], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?
            public var type: `Type`

            public enum `Type`: String, Codable, CaseIterable {
                case acssDebit = "acss_debit"
                case afterpayClearpay = "afterpay_clearpay"
                case alipay
                case auBecsDebit = "au_becs_debit"
                case bacsDebit = "bacs_debit"
                case bancontact
                case boleto
                case card
                case eps
                case fpx
                case giropay
                case grabpay
                case ideal
                case klarna
                case oxxo
                case p24
                case sepaDebit = "sepa_debit"
                case sofort
                case wechatPay = "wechat_pay"
            }

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil, type: `Type`) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
                self.type = type
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(type, forKey: "type")
                return encoder.items
            }
        }
    }
}

extension Paths.Customers.WithCustomer {
    public var sources: Sources {
        Sources(path: path + "/sources")
    }

    public struct Sources {
        /// Path: `/v1/customers/{customer}/sources`
        public let path: String

        /// <p>List sources for a specified customer.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// ApmsSourcesSourceList
        public struct GetResponse: Decodable {
            /// Details about each object.
            public var data: [Datum]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// Polymorphic
            public struct Datum: Decodable {
                public var alipayAccount: StripeAPI.AlipayAccount?
                public var bankAccount: StripeAPI.BankAccount?
                public var bitcoinReceiver: StripeAPI.BitcoinReceiver?
                public var card: StripeAPI.Card?
                /// `Source` objects allow you to accept a variety of payment methods. They
                /// represent a customer's payment instrument, and can be used with the Stripe API
                /// just like a `Card` object: once chargeable, they can be charged, or can be
                /// attached to customers.
                /// 
                /// Related guides: [Sources API](https://stripe.com/docs/sources) and [Sources & Customers](https://stripe.com/docs/sources/customers).
                public var source: StripeAPI.Source?

                public init(alipayAccount: StripeAPI.AlipayAccount? = nil, bankAccount: StripeAPI.BankAccount? = nil, bitcoinReceiver: StripeAPI.BitcoinReceiver? = nil, card: StripeAPI.Card? = nil, source: StripeAPI.Source? = nil) {
                    self.alipayAccount = alipayAccount
                    self.bankAccount = bankAccount
                    self.bitcoinReceiver = bitcoinReceiver
                    self.card = card
                    self.source = source
                }

                public init(from decoder: Decoder) throws {
                    let container = try decoder.singleValueContainer()
                    self.alipayAccount = try? container.decode(StripeAPI.AlipayAccount.self)
                    self.bankAccount = try? container.decode(StripeAPI.BankAccount.self)
                    self.bitcoinReceiver = try? container.decode(StripeAPI.BitcoinReceiver.self)
                    self.card = try? container.decode(StripeAPI.Card.self)
                    self.source = try? container.decode(StripeAPI.Source.self)
                }
            }

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [Datum], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var object: String?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, object: String? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.object = object
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(object, forKey: "object")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>When you create a new credit card, you must specify a customer or recipient on which to create it.</p>
        /// 
        /// <p>If the card’s owner has no default card, then the new card will become the default.
        /// However, if the owner already has a default, then it will not change.
        /// To change the default, you should <a href="/docs/api#update_customer">update the customer</a> to have a new <code>default_source</code>.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.PaymentSource> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// A token returned by [Stripe.js](https://stripe.com/docs/js) representing the user’s Alipay account details.
            public var alipayAccount: String?
            /// Either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details.
            public var bankAccount: BankAccount?
            /// A token, like the ones returned by [Stripe.js](https://stripe.com/docs/js).
            public var card: Card?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// Please refer to full [documentation](https://stripe.com/docs/api) instead.
            public var source: String?

            /// Either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details.
            public struct BankAccount: Encodable {
                /// Customer_payment_source_bank_account
                public var object: Object?
                public var string: String?

                /// Customer_payment_source_bank_account
                public struct Object: Encodable {
                    public var accountHolderName: String?
                    public var accountHolderType: AccountHolderType?
                    public var accountNumber: String
                    public var country: String
                    public var currency: String?
                    public var object: Object?
                    public var routingNumber: String?

                    public enum AccountHolderType: String, Codable, CaseIterable {
                        case company
                        case individual
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case bankAccount = "bank_account"
                    }

                    public init(accountHolderName: String? = nil, accountHolderType: AccountHolderType? = nil, accountNumber: String, country: String, currency: String? = nil, object: Object? = nil, routingNumber: String? = nil) {
                        self.accountHolderName = accountHolderName
                        self.accountHolderType = accountHolderType
                        self.accountNumber = accountNumber
                        self.country = country
                        self.currency = currency
                        self.object = object
                        self.routingNumber = routingNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountHolderName, forKey: "account_holder_name")
                        encoder.encode(accountHolderType, forKey: "account_holder_type")
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(object, forKey: "object")
                        encoder.encode(routingNumber, forKey: "routing_number")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, string: String? = nil) {
                    self.object = object
                    self.string = string
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(string, forKey: "string")
                    return encoder.items
                }
            }

            /// A token, like the ones returned by [Stripe.js](https://stripe.com/docs/js).
            public struct Card: Encodable {
                /// Customer_payment_source_card
                public var object: Object?
                public var string: String?

                /// Customer_payment_source_card
                public struct Object: Encodable {
                    public var addressCity: String?
                    public var addressCountry: String?
                    public var addressLine1: String?
                    public var addressLine2: String?
                    public var addressState: String?
                    public var addressZip: String?
                    public var cvc: String?
                    public var expMonth: Int
                    public var expYear: Int
                    public var metadata: [String: String]?
                    public var name: String?
                    public var number: String
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case card
                    }

                    public init(addressCity: String? = nil, addressCountry: String? = nil, addressLine1: String? = nil, addressLine2: String? = nil, addressState: String? = nil, addressZip: String? = nil, cvc: String? = nil, expMonth: Int, expYear: Int, metadata: [String: String]? = nil, name: String? = nil, number: String, object: Object? = nil) {
                        self.addressCity = addressCity
                        self.addressCountry = addressCountry
                        self.addressLine1 = addressLine1
                        self.addressLine2 = addressLine2
                        self.addressState = addressState
                        self.addressZip = addressZip
                        self.cvc = cvc
                        self.expMonth = expMonth
                        self.expYear = expYear
                        self.metadata = metadata
                        self.name = name
                        self.number = number
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(addressCity, forKey: "address_city")
                        encoder.encode(addressCountry, forKey: "address_country")
                        encoder.encode(addressLine1, forKey: "address_line1")
                        encoder.encode(addressLine2, forKey: "address_line2")
                        encoder.encode(addressState, forKey: "address_state")
                        encoder.encode(addressZip, forKey: "address_zip")
                        encoder.encode(cvc, forKey: "cvc")
                        encoder.encode(expMonth, forKey: "exp_month")
                        encoder.encode(expYear, forKey: "exp_year")
                        encoder.encode(metadata, forKey: "metadata")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(number, forKey: "number")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, string: String? = nil) {
                    self.object = object
                    self.string = string
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(string, forKey: "string")
                    return encoder.items
                }
            }

            public init(alipayAccount: String? = nil, bankAccount: BankAccount? = nil, card: Card? = nil, expand: [String]? = nil, metadata: [String: String]? = nil, source: String? = nil) {
                self.alipayAccount = alipayAccount
                self.bankAccount = bankAccount
                self.card = card
                self.expand = expand
                self.metadata = metadata
                self.source = source
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(alipayAccount, forKey: "alipay_account")
                encoder.encode(bankAccount, forKey: "bank_account")
                encoder.encode(card, forKey: "card")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(source, forKey: "source")
                return encoder.items
            }
        }
    }
}

extension Paths.Customers.WithCustomer.Sources {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/customers/{customer}/sources/{id}`
        public let path: String

        /// <p>Retrieve a specified source for a given customer.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.PaymentSource> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Update a specified source for a given customer.</p>
        public func post(_ body: PostRequest? = nil) -> Request<PostResponse> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostResponse: Decodable {
            public var card: StripeAPI.Card?
            public var bankAccount: StripeAPI.BankAccount?
            /// `Source` objects allow you to accept a variety of payment methods. They
            /// represent a customer's payment instrument, and can be used with the Stripe API
            /// just like a `Card` object: once chargeable, they can be charged, or can be
            /// attached to customers.
            /// 
            /// Related guides: [Sources API](https://stripe.com/docs/sources) and [Sources & Customers](https://stripe.com/docs/sources/customers).
            public var source: StripeAPI.Source?

            public init(card: StripeAPI.Card? = nil, bankAccount: StripeAPI.BankAccount? = nil, source: StripeAPI.Source? = nil) {
                self.card = card
                self.bankAccount = bankAccount
                self.source = source
            }

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                self.card = try? container.decode(StripeAPI.Card.self)
                self.bankAccount = try? container.decode(StripeAPI.BankAccount.self)
                self.source = try? container.decode(StripeAPI.Source.self)
            }
        }

        public struct PostRequest: Encodable {
            /// The name of the person or business that owns the bank account.
            public var accountHolderName: String?
            /// The type of entity that holds the account. This can be either `individual` or `company`.
            public var accountHolderType: AccountHolderType?
            /// City/District/Suburb/Town/Village.
            public var addressCity: String?
            /// Billing address country, if provided when creating card.
            public var addressCountry: String?
            /// Address line 1 (Street address/PO Box/Company name).
            public var addressLine1: String?
            /// Address line 2 (Apartment/Suite/Unit/Building).
            public var addressLine2: String?
            /// State/County/Province/Region.
            public var addressState: String?
            /// ZIP or postal code.
            public var addressZip: String?
            /// Two digit number representing the card’s expiration month.
            public var expMonth: String?
            /// Four digit number representing the card’s expiration year.
            public var expYear: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// Cardholder name.
            public var name: String?
            public var owner: Owner?

            /// The type of entity that holds the account. This can be either `individual` or `company`.
            public enum AccountHolderType: String, Codable, CaseIterable {
                case company
                case individual
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public struct Owner: Encodable {
                /// Source_address
                public var address: Address?
                public var email: String?
                public var name: String?
                public var phone: String?

                /// Source_address
                public struct Address: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                public init(address: Address? = nil, email: String? = nil, name: String? = nil, phone: String? = nil) {
                    self.address = address
                    self.email = email
                    self.name = name
                    self.phone = phone
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(email, forKey: "email")
                    encoder.encode(name, forKey: "name")
                    encoder.encode(phone, forKey: "phone")
                    return encoder.items
                }
            }

            public init(accountHolderName: String? = nil, accountHolderType: AccountHolderType? = nil, addressCity: String? = nil, addressCountry: String? = nil, addressLine1: String? = nil, addressLine2: String? = nil, addressState: String? = nil, addressZip: String? = nil, expMonth: String? = nil, expYear: String? = nil, expand: [String]? = nil, metadata: Metadata? = nil, name: String? = nil, owner: Owner? = nil) {
                self.accountHolderName = accountHolderName
                self.accountHolderType = accountHolderType
                self.addressCity = addressCity
                self.addressCountry = addressCountry
                self.addressLine1 = addressLine1
                self.addressLine2 = addressLine2
                self.addressState = addressState
                self.addressZip = addressZip
                self.expMonth = expMonth
                self.expYear = expYear
                self.expand = expand
                self.metadata = metadata
                self.name = name
                self.owner = owner
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(accountHolderName, forKey: "account_holder_name")
                encoder.encode(accountHolderType, forKey: "account_holder_type")
                encoder.encode(addressCity, forKey: "address_city")
                encoder.encode(addressCountry, forKey: "address_country")
                encoder.encode(addressLine1, forKey: "address_line1")
                encoder.encode(addressLine2, forKey: "address_line2")
                encoder.encode(addressState, forKey: "address_state")
                encoder.encode(addressZip, forKey: "address_zip")
                encoder.encode(expMonth, forKey: "exp_month")
                encoder.encode(expYear, forKey: "exp_year")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(name, forKey: "name")
                encoder.encode(owner, forKey: "owner")
                return encoder.items
            }
        }

        /// <p>Delete a specified source for a given customer.</p>
        public func delete(_ body: DeleteRequest? = nil) -> Request<DeleteResponse> {
            .delete(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct DeleteResponse: Decodable {
            public var paymentSource: StripeAPI.PaymentSource?
            /// Polymorphic
            public var deletedPaymentSource: StripeAPI.DeletedPaymentSource?

            public init(paymentSource: StripeAPI.PaymentSource? = nil, deletedPaymentSource: StripeAPI.DeletedPaymentSource? = nil) {
                self.paymentSource = paymentSource
                self.deletedPaymentSource = deletedPaymentSource
            }

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                self.paymentSource = try? container.decode(StripeAPI.PaymentSource.self)
                self.deletedPaymentSource = try? container.decode(StripeAPI.DeletedPaymentSource.self)
            }
        }

        public struct DeleteRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(expand: [String]? = nil) {
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.Customers.WithCustomer.Sources.WithID {
    public var verify: Verify {
        Verify(path: path + "/verify")
    }

    public struct Verify {
        /// Path: `/v1/customers/{customer}/sources/{id}/verify`
        public let path: String

        /// <p>Verify a specified bank account for a given customer.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.BankAccount> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Two positive integers, in *cents*, equal to the values of the microdeposits sent to the bank account.
            public var amounts: [Int]?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(amounts: [Int]? = nil, expand: [String]? = nil) {
                self.amounts = amounts
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amounts, forKey: "amounts")
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.Customers.WithCustomer {
    public var subscriptions: Subscriptions {
        Subscriptions(path: path + "/subscriptions")
    }

    public struct Subscriptions {
        /// Path: `/v1/customers/{customer}/subscriptions`
        public let path: String

        /// <p>You can see a list of the customer’s active subscriptions. Note that the 10 most recent active subscriptions are always available by default on the customer object. If you need more than those 10, you can use the limit and starting_after parameters to page through additional subscriptions.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// SubscriptionList
        public struct GetResponse: Decodable {
            /// Details about each object.
            public var data: [StripeAPI.Subscription]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Subscription], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates a new subscription on an existing customer.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Subscription> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// A list of prices and quantities that will generate invoice items appended to the first invoice for this subscription. You may pass up to 20 items.
            public var addInvoiceItems: [AddInvoiceItem]?
            /// A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. The request must be made by a platform account on a connected account in order to set an application fee percentage. For more information, see the application fees [documentation](https://stripe.com/docs/connect/subscriptions#collecting-fees-on-subscriptions).
            public var applicationFeePercent: Double?
            /// Automatic_tax_config
            ///
            /// Automatic tax settings for this subscription.
            public var automaticTax: AutomaticTax?
            /// For new subscriptions, a past timestamp to backdate the subscription's start date to. If set, the first invoice will contain a proration for the timespan between the start date and the current time. Can be combined with trials and the billing cycle anchor.
            public var backdateStartDate: Int?
            /// A future timestamp to anchor the subscription's [billing cycle](https://stripe.com/docs/subscriptions/billing-cycle). This is used to determine the date of the first full invoice, and, for plans with `month` or `year` intervals, the day of the month for subsequent invoices.
            public var billingCycleAnchor: Int?
            /// Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period. Pass an empty string to remove previously-defined thresholds.
            public var billingThresholds: BillingThresholds?
            /// A timestamp at which the subscription should cancel. If set to a date before the current period ends, this will cause a proration if prorations have been enabled using `proration_behavior`. If set during a future period, this will always cause a proration for that period.
            public var cancelAt: Int?
            /// Boolean indicating whether this subscription should cancel at the end of the current period.
            public var isCancelAtPeriodEnd: Bool?
            /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
            public var collectionMethod: CollectionMethod?
            /// The ID of the coupon to apply to this subscription. A coupon applied to a subscription will only affect invoices created for that particular subscription.
            public var coupon: String?
            /// Number of days a customer has to pay invoices generated by this subscription. Valid only for subscriptions where `collection_method` is set to `send_invoice`.
            public var daysUntilDue: Int?
            /// ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over `default_source`. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
            public var defaultPaymentMethod: String?
            /// ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If `default_payment_method` is also set, `default_payment_method` will take precedence. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
            public var defaultSource: String?
            /// The tax rates that will apply to any subscription item that does not have `tax_rates` set. Invoices created will have their `default_tax_rates` populated from the subscription.
            public var defaultTaxRates: DefaultTaxRates?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// A list of up to 20 subscription items, each with an attached price.
            public var items: [Item]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// Indicates if a customer is on or off-session while an invoice payment is attempted.
            public var isOffSession: Bool?
            /// Use `allow_incomplete` to create subscriptions with `status=incomplete` if the first invoice cannot be paid. Creating subscriptions with this status allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.
            /// 
            /// Use `default_incomplete` to create Subscriptions with `status=incomplete` when the first invoice requires payment, otherwise start as active. Subscriptions transition to `status=active` when successfully confirming the payment intent on the first invoice. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method. If the payment intent is not confirmed within 23 hours subscriptions transition to `status=incomplete_expired`, which is a terminal state.
            /// 
            /// Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's first invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not create a subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
            /// 
            /// `pending_if_incomplete` is only used with updates and cannot be passed when creating a subscription.
            public var paymentBehavior: PaymentBehavior?
            /// Payment_settings
            ///
            /// Payment settings to pass to invoices created by the subscription.
            public var paymentSettings: PaymentSettings?
            /// Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling [Create an invoice](https://stripe.com/docs/api#create_invoice) for the given subscription at the specified interval.
            public var pendingInvoiceItemInterval: PendingInvoiceItemInterval?
            /// The API ID of a promotion code to apply to this subscription. A promotion code applied to a subscription will only affect invoices created for that particular subscription.
            public var promotionCode: String?
            /// Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) resulting from the `billing_cycle_anchor`. Valid values are `create_prorations` or `none`.
            /// 
            /// Passing `create_prorations` will cause proration invoice items to be created when applicable. Prorations can be disabled by passing `none`. If no value is passed, the default is `create_prorations`.
            public var prorationBehavior: ProrationBehavior?
            /// Transfer_data_specs
            ///
            /// If specified, the funds from the subscription's invoices will be transferred to the destination and the ID of the resulting transfers will be found on the resulting charges.
            public var transferData: TransferData?
            /// Unix timestamp representing the end of the trial period the customer will get before being charged for the first time. This will always overwrite any trials that might apply via a subscribed plan. If set, trial_end will override the default trial period of the plan the customer is being subscribed to. The special value `now` can be provided to end the customer's trial immediately. Can be at most two years from `billing_cycle_anchor`. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
            public var trialEnd: TrialEnd?
            /// Indicates if a plan's `trial_period_days` should be applied to the subscription. Setting `trial_end` per subscription is preferred, and this defaults to `false`. Setting this flag to `true` together with `trial_end` is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
            public var isTrialFromPlan: Bool?
            /// Integer representing the number of trial period days before the customer is charged for the first time. This will always overwrite any trials that might apply via a subscribed plan. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
            public var trialPeriodDays: Int?

            /// Add_invoice_item_entry
            public struct AddInvoiceItem: Encodable {
                public var price: String?
                /// One_time_price_data
                public var priceData: PriceData?
                public var quantity: Int?
                public var taxRates: TaxRates?

                /// One_time_price_data
                public struct PriceData: Encodable {
                    public var currency: String
                    public var product: String
                    public var taxBehavior: TaxBehavior?
                    public var unitAmount: Int?
                    public var unitAmountDecimal: String?

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public init(currency: String, product: String, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                        self.currency = currency
                        self.product = product
                        self.taxBehavior = taxBehavior
                        self.unitAmount = unitAmount
                        self.unitAmountDecimal = unitAmountDecimal
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(product, forKey: "product")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(unitAmount, forKey: "unit_amount")
                        encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                        return encoder.items
                    }
                }

                public struct TaxRates: Encodable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                    self.price = price
                    self.priceData = priceData
                    self.quantity = quantity
                    self.taxRates = taxRates
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(price, forKey: "price")
                    encoder.encode(priceData, forKey: "price_data")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    return encoder.items
                }
            }

            /// Automatic_tax_config
            ///
            /// Automatic tax settings for this subscription.
            public struct AutomaticTax: Encodable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period. Pass an empty string to remove previously-defined thresholds.
            public struct BillingThresholds: Encodable {
                /// Billing_thresholds_param
                public var a: A?
                public var b: B?

                /// Billing_thresholds_param
                public struct A: Encodable {
                    public var amountGte: Int?
                    public var isResetBillingCycleAnchor: Bool?

                    public init(amountGte: Int? = nil, isResetBillingCycleAnchor: Bool? = nil) {
                        self.amountGte = amountGte
                        self.isResetBillingCycleAnchor = isResetBillingCycleAnchor
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amountGte, forKey: "amount_gte")
                        encoder.encode(isResetBillingCycleAnchor, forKey: "reset_billing_cycle_anchor")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
            public enum CollectionMethod: String, Codable, CaseIterable {
                case chargeAutomatically = "charge_automatically"
                case sendInvoice = "send_invoice"
            }

            /// The tax rates that will apply to any subscription item that does not have `tax_rates` set. Invoices created will have their `default_tax_rates` populated from the subscription.
            public struct DefaultTaxRates: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Subscription_item_create_params
            public struct Item: Encodable {
                public var billingThresholds: BillingThresholds?
                public var metadata: [String: String]?
                public var price: String?
                /// Recurring_price_data
                public var priceData: PriceData?
                public var quantity: Int?
                public var taxRates: TaxRates?

                public struct BillingThresholds: Encodable {
                    /// Item_billing_thresholds_param
                    public var a: A?
                    public var b: B?

                    /// Item_billing_thresholds_param
                    public struct A: Encodable {
                        public var usageGte: Int

                        public init(usageGte: Int) {
                            self.usageGte = usageGte
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(usageGte, forKey: "usage_gte")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                /// Recurring_price_data
                public struct PriceData: Encodable {
                    public var currency: String
                    public var product: String
                    /// Recurring_adhoc
                    public var recurring: Recurring
                    public var taxBehavior: TaxBehavior?
                    public var unitAmount: Int?
                    public var unitAmountDecimal: String?

                    /// Recurring_adhoc
                    public struct Recurring: Encodable {
                        public var interval: Interval
                        public var intervalCount: Int?

                        public enum Interval: String, Codable, CaseIterable {
                            case day
                            case month
                            case week
                            case year
                        }

                        public init(interval: Interval, intervalCount: Int? = nil) {
                            self.interval = interval
                            self.intervalCount = intervalCount
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(interval, forKey: "interval")
                            encoder.encode(intervalCount, forKey: "interval_count")
                            return encoder.items
                        }
                    }

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public init(currency: String, product: String, recurring: Recurring, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                        self.currency = currency
                        self.product = product
                        self.recurring = recurring
                        self.taxBehavior = taxBehavior
                        self.unitAmount = unitAmount
                        self.unitAmountDecimal = unitAmountDecimal
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(product, forKey: "product")
                        encoder.encode(recurring, forKey: "recurring")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(unitAmount, forKey: "unit_amount")
                        encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                        return encoder.items
                    }
                }

                public struct TaxRates: Encodable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(billingThresholds: BillingThresholds? = nil, metadata: [String: String]? = nil, price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                    self.billingThresholds = billingThresholds
                    self.metadata = metadata
                    self.price = price
                    self.priceData = priceData
                    self.quantity = quantity
                    self.taxRates = taxRates
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(billingThresholds, forKey: "billing_thresholds")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(price, forKey: "price")
                    encoder.encode(priceData, forKey: "price_data")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Use `allow_incomplete` to create subscriptions with `status=incomplete` if the first invoice cannot be paid. Creating subscriptions with this status allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.
            /// 
            /// Use `default_incomplete` to create Subscriptions with `status=incomplete` when the first invoice requires payment, otherwise start as active. Subscriptions transition to `status=active` when successfully confirming the payment intent on the first invoice. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method. If the payment intent is not confirmed within 23 hours subscriptions transition to `status=incomplete_expired`, which is a terminal state.
            /// 
            /// Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's first invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not create a subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
            /// 
            /// `pending_if_incomplete` is only used with updates and cannot be passed when creating a subscription.
            public enum PaymentBehavior: String, Codable, CaseIterable {
                case allowIncomplete = "allow_incomplete"
                case defaultIncomplete = "default_incomplete"
                case errorIfIncomplete = "error_if_incomplete"
                case pendingIfIncomplete = "pending_if_incomplete"
            }

            /// Payment_settings
            ///
            /// Payment settings to pass to invoices created by the subscription.
            public struct PaymentSettings: Encodable {
                /// Payment_method_options
                public var paymentMethodOptions: PaymentMethodOptions?
                public var paymentMethodTypes: PaymentMethodTypes?

                /// Payment_method_options
                public struct PaymentMethodOptions: Encodable {
                    public var acssDebit: AcssDebit?
                    public var bancontact: Bancontact?
                    public var card: Card?

                    public struct AcssDebit: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            /// Mandate_options_param
                            public var mandateOptions: MandateOptions?
                            public var verificationMethod: VerificationMethod?

                            /// Mandate_options_param
                            public struct MandateOptions: Encodable {
                                public var transactionType: TransactionType?

                                public enum TransactionType: String, Codable, CaseIterable {
                                    case business
                                    case personal
                                }

                                public init(transactionType: TransactionType? = nil) {
                                    self.transactionType = transactionType
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(transactionType, forKey: "transaction_type")
                                    return encoder.items
                                }
                            }

                            public enum VerificationMethod: String, Codable, CaseIterable {
                                case automatic
                                case instant
                                case microdeposits
                            }

                            public init(mandateOptions: MandateOptions? = nil, verificationMethod: VerificationMethod? = nil) {
                                self.mandateOptions = mandateOptions
                                self.verificationMethod = verificationMethod
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(mandateOptions, forKey: "mandate_options")
                                encoder.encode(verificationMethod, forKey: "verification_method")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct Bancontact: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            public var preferredLanguage: PreferredLanguage?

                            public enum PreferredLanguage: String, Codable, CaseIterable {
                                case de
                                case en
                                case fr
                                case nl
                            }

                            public init(preferredLanguage: PreferredLanguage? = nil) {
                                self.preferredLanguage = preferredLanguage
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(preferredLanguage, forKey: "preferred_language")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct Card: Encodable {
                        /// Subscription_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Subscription_payment_method_options_param
                        public struct A: Encodable {
                            public var requestThreeDSecure: RequestThreeDSecure?

                            public enum RequestThreeDSecure: String, Codable, CaseIterable {
                                case any
                                case automatic
                            }

                            public init(requestThreeDSecure: RequestThreeDSecure? = nil) {
                                self.requestThreeDSecure = requestThreeDSecure
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(requestThreeDSecure, forKey: "request_three_d_secure")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public init(acssDebit: AcssDebit? = nil, bancontact: Bancontact? = nil, card: Card? = nil) {
                        self.acssDebit = acssDebit
                        self.bancontact = bancontact
                        self.card = card
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(acssDebit, forKey: "acss_debit")
                        encoder.encode(bancontact, forKey: "bancontact")
                        encoder.encode(card, forKey: "card")
                        return encoder.items
                    }
                }

                public struct PaymentMethodTypes: Encodable {
                    public var placeholderItems: [PlaceholderItem]?
                    public var object: Object?

                    public enum PlaceholderItem: String, Codable, CaseIterable {
                        case achCreditTransfer = "ach_credit_transfer"
                        case achDebit = "ach_debit"
                        case acssDebit = "acss_debit"
                        case auBecsDebit = "au_becs_debit"
                        case bacsDebit = "bacs_debit"
                        case bancontact
                        case boleto
                        case card
                        case fpx
                        case giropay
                        case ideal
                        case sepaDebit = "sepa_debit"
                        case sofort
                        case wechatPay = "wechat_pay"
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                        self.placeholderItems = placeholderItems
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(placeholderItems, forKey: "placeholderItems")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(paymentMethodOptions: PaymentMethodOptions? = nil, paymentMethodTypes: PaymentMethodTypes? = nil) {
                    self.paymentMethodOptions = paymentMethodOptions
                    self.paymentMethodTypes = paymentMethodTypes
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(paymentMethodOptions, forKey: "payment_method_options")
                    encoder.encode(paymentMethodTypes, forKey: "payment_method_types")
                    return encoder.items
                }
            }

            /// Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling [Create an invoice](https://stripe.com/docs/api#create_invoice) for the given subscription at the specified interval.
            public struct PendingInvoiceItemInterval: Encodable {
                /// Pending_invoice_item_interval_params
                public var a: A?
                public var b: B?

                /// Pending_invoice_item_interval_params
                public struct A: Encodable {
                    public var interval: Interval
                    public var intervalCount: Int?

                    public enum Interval: String, Codable, CaseIterable {
                        case day
                        case month
                        case week
                        case year
                    }

                    public init(interval: Interval, intervalCount: Int? = nil) {
                        self.interval = interval
                        self.intervalCount = intervalCount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(interval, forKey: "interval")
                        encoder.encode(intervalCount, forKey: "interval_count")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) resulting from the `billing_cycle_anchor`. Valid values are `create_prorations` or `none`.
            /// 
            /// Passing `create_prorations` will cause proration invoice items to be created when applicable. Prorations can be disabled by passing `none`. If no value is passed, the default is `create_prorations`.
            public enum ProrationBehavior: String, Codable, CaseIterable {
                case alwaysInvoice = "always_invoice"
                case createProrations = "create_prorations"
                case `none`
            }

            /// Transfer_data_specs
            ///
            /// If specified, the funds from the subscription's invoices will be transferred to the destination and the ID of the resulting transfers will be found on the resulting charges.
            public struct TransferData: Encodable {
                public var amountPercent: Double?
                public var destination: String

                public init(amountPercent: Double? = nil, destination: String) {
                    self.amountPercent = amountPercent
                    self.destination = destination
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(amountPercent, forKey: "amount_percent")
                    encoder.encode(destination, forKey: "destination")
                    return encoder.items
                }
            }

            /// Unix timestamp representing the end of the trial period the customer will get before being charged for the first time. This will always overwrite any trials that might apply via a subscribed plan. If set, trial_end will override the default trial period of the plan the customer is being subscribed to. The special value `now` can be provided to end the customer's trial immediately. Can be at most two years from `billing_cycle_anchor`. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
            public struct TrialEnd: Encodable {
                public var object: Object?
                public var int: Int?

                public enum Object: String, Codable, CaseIterable {
                    case now
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(addInvoiceItems: [AddInvoiceItem]? = nil, applicationFeePercent: Double? = nil, automaticTax: AutomaticTax? = nil, backdateStartDate: Int? = nil, billingCycleAnchor: Int? = nil, billingThresholds: BillingThresholds? = nil, cancelAt: Int? = nil, isCancelAtPeriodEnd: Bool? = nil, collectionMethod: CollectionMethod? = nil, coupon: String? = nil, daysUntilDue: Int? = nil, defaultPaymentMethod: String? = nil, defaultSource: String? = nil, defaultTaxRates: DefaultTaxRates? = nil, expand: [String]? = nil, items: [Item]? = nil, metadata: Metadata? = nil, isOffSession: Bool? = nil, paymentBehavior: PaymentBehavior? = nil, paymentSettings: PaymentSettings? = nil, pendingInvoiceItemInterval: PendingInvoiceItemInterval? = nil, promotionCode: String? = nil, prorationBehavior: ProrationBehavior? = nil, transferData: TransferData? = nil, trialEnd: TrialEnd? = nil, isTrialFromPlan: Bool? = nil, trialPeriodDays: Int? = nil) {
                self.addInvoiceItems = addInvoiceItems
                self.applicationFeePercent = applicationFeePercent
                self.automaticTax = automaticTax
                self.backdateStartDate = backdateStartDate
                self.billingCycleAnchor = billingCycleAnchor
                self.billingThresholds = billingThresholds
                self.cancelAt = cancelAt
                self.isCancelAtPeriodEnd = isCancelAtPeriodEnd
                self.collectionMethod = collectionMethod
                self.coupon = coupon
                self.daysUntilDue = daysUntilDue
                self.defaultPaymentMethod = defaultPaymentMethod
                self.defaultSource = defaultSource
                self.defaultTaxRates = defaultTaxRates
                self.expand = expand
                self.items = items
                self.metadata = metadata
                self.isOffSession = isOffSession
                self.paymentBehavior = paymentBehavior
                self.paymentSettings = paymentSettings
                self.pendingInvoiceItemInterval = pendingInvoiceItemInterval
                self.promotionCode = promotionCode
                self.prorationBehavior = prorationBehavior
                self.transferData = transferData
                self.trialEnd = trialEnd
                self.isTrialFromPlan = isTrialFromPlan
                self.trialPeriodDays = trialPeriodDays
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(addInvoiceItems, forKey: "add_invoice_items")
                encoder.encode(applicationFeePercent, forKey: "application_fee_percent")
                encoder.encode(automaticTax, forKey: "automatic_tax")
                encoder.encode(backdateStartDate, forKey: "backdate_start_date")
                encoder.encode(billingCycleAnchor, forKey: "billing_cycle_anchor")
                encoder.encode(billingThresholds, forKey: "billing_thresholds")
                encoder.encode(cancelAt, forKey: "cancel_at")
                encoder.encode(isCancelAtPeriodEnd, forKey: "cancel_at_period_end")
                encoder.encode(collectionMethod, forKey: "collection_method")
                encoder.encode(coupon, forKey: "coupon")
                encoder.encode(daysUntilDue, forKey: "days_until_due")
                encoder.encode(defaultPaymentMethod, forKey: "default_payment_method")
                encoder.encode(defaultSource, forKey: "default_source")
                encoder.encode(defaultTaxRates, forKey: "default_tax_rates")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(items, forKey: "items")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(isOffSession, forKey: "off_session")
                encoder.encode(paymentBehavior, forKey: "payment_behavior")
                encoder.encode(paymentSettings, forKey: "payment_settings")
                encoder.encode(pendingInvoiceItemInterval, forKey: "pending_invoice_item_interval")
                encoder.encode(promotionCode, forKey: "promotion_code")
                encoder.encode(prorationBehavior, forKey: "proration_behavior")
                encoder.encode(transferData, forKey: "transfer_data")
                encoder.encode(trialEnd, forKey: "trial_end")
                encoder.encode(isTrialFromPlan, forKey: "trial_from_plan")
                encoder.encode(trialPeriodDays, forKey: "trial_period_days")
                return encoder.items
            }
        }
    }
}

extension Paths.Customers.WithCustomer.Subscriptions {
    public func subscriptionExposedID(_ subscriptionExposedID: String) -> WithSubscriptionExposedID {
        WithSubscriptionExposedID(path: "\(path)/\(subscriptionExposedID)")
    }

    public struct WithSubscriptionExposedID {
        /// Path: `/v1/customers/{customer}/subscriptions/{subscription_exposed_id}`
        public let path: String

        /// <p>Retrieves the subscription with the given ID.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Subscription> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates an existing subscription on a customer to match the specified parameters. When changing plans or quantities, we will optionally prorate the price we charge next month to make up for any price changes. To preview how the proration will be calculated, use the <a href="#upcoming_invoice">upcoming invoice</a> endpoint.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Subscription> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// A list of prices and quantities that will generate invoice items appended to the first invoice for this subscription. You may pass up to 20 items.
            public var addInvoiceItems: [AddInvoiceItem]?
            /// A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. The request must be made by a platform account on a connected account in order to set an application fee percentage. For more information, see the application fees [documentation](https://stripe.com/docs/connect/subscriptions#collecting-fees-on-subscriptions).
            public var applicationFeePercent: Double?
            /// Automatic_tax_config
            ///
            /// Automatic tax settings for this subscription.
            public var automaticTax: AutomaticTax?
            /// Either `now` or `unchanged`. Setting the value to `now` resets the subscription's billing cycle anchor to the current time. For more information, see the billing cycle [documentation](https://stripe.com/docs/billing/subscriptions/billing-cycle).
            public var billingCycleAnchor: BillingCycleAnchor?
            /// Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period. Pass an empty string to remove previously-defined thresholds.
            public var billingThresholds: BillingThresholds?
            /// A timestamp at which the subscription should cancel. If set to a date before the current period ends, this will cause a proration if prorations have been enabled using `proration_behavior`. If set during a future period, this will always cause a proration for that period.
            public var cancelAt: CancelAt?
            /// Boolean indicating whether this subscription should cancel at the end of the current period.
            public var isCancelAtPeriodEnd: Bool?
            /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
            public var collectionMethod: CollectionMethod?
            /// The ID of the coupon to apply to this subscription. A coupon applied to a subscription will only affect invoices created for that particular subscription.
            public var coupon: String?
            /// Number of days a customer has to pay invoices generated by this subscription. Valid only for subscriptions where `collection_method` is set to `send_invoice`.
            public var daysUntilDue: Int?
            /// ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over `default_source`. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
            public var defaultPaymentMethod: String?
            /// ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If `default_payment_method` is also set, `default_payment_method` will take precedence. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
            public var defaultSource: String?
            /// The tax rates that will apply to any subscription item that does not have `tax_rates` set. Invoices created will have their `default_tax_rates` populated from the subscription. Pass an empty string to remove previously-defined tax rates.
            public var defaultTaxRates: DefaultTaxRates?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// A list of up to 20 subscription items, each with an attached price.
            public var items: [Item]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// Indicates if a customer is on or off-session while an invoice payment is attempted.
            public var isOffSession: Bool?
            /// If specified, payment collection for this subscription will be paused.
            public var pauseCollection: PauseCollection?
            /// Use `allow_incomplete` to transition the subscription to `status=past_due` if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.
            /// 
            /// Use `default_incomplete` to transition the subscription to `status=past_due` when payment is required and await explicit confirmation of the invoice's payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.
            /// 
            /// Use `pending_if_incomplete` to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use `pending_if_incomplete` you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).
            /// 
            /// Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
            public var paymentBehavior: PaymentBehavior?
            /// Payment_settings
            ///
            /// Payment settings to pass to invoices created by the subscription.
            public var paymentSettings: PaymentSettings?
            /// Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling [Create an invoice](https://stripe.com/docs/api#create_invoice) for the given subscription at the specified interval.
            public var pendingInvoiceItemInterval: PendingInvoiceItemInterval?
            /// The promotion code to apply to this subscription. A promotion code applied to a subscription will only affect invoices created for that particular subscription.
            public var promotionCode: String?
            /// Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes. Valid values are `create_prorations`, `none`, or `always_invoice`.
            /// 
            /// Passing `create_prorations` will cause proration invoice items to be created when applicable. These proration items will only be invoiced immediately under [certain conditions](https://stripe.com/docs/subscriptions/upgrading-downgrading#immediate-payment). In order to always invoice immediately for prorations, pass `always_invoice`.
            /// 
            /// Prorations can be disabled by passing `none`.
            public var prorationBehavior: ProrationBehavior?
            /// If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply exactly the same proration that was previewed with [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint. It can also be used to implement custom proration logic, such as prorating by day instead of by second, by providing the time that you wish to use for proration calculations.
            public var prorationDate: Int?
            /// If specified, the funds from the subscription's invoices will be transferred to the destination and the ID of the resulting transfers will be found on the resulting charges. This will be unset if you POST an empty value.
            public var transferData: TransferData?
            /// Unix timestamp representing the end of the trial period the customer will get before being charged for the first time. This will always overwrite any trials that might apply via a subscribed plan. If set, trial_end will override the default trial period of the plan the customer is being subscribed to. The special value `now` can be provided to end the customer's trial immediately. Can be at most two years from `billing_cycle_anchor`.
            public var trialEnd: TrialEnd?
            /// Indicates if a plan's `trial_period_days` should be applied to the subscription. Setting `trial_end` per subscription is preferred, and this defaults to `false`. Setting this flag to `true` together with `trial_end` is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
            public var isTrialFromPlan: Bool?

            /// Add_invoice_item_entry
            public struct AddInvoiceItem: Encodable {
                public var price: String?
                /// One_time_price_data
                public var priceData: PriceData?
                public var quantity: Int?
                public var taxRates: TaxRates?

                /// One_time_price_data
                public struct PriceData: Encodable {
                    public var currency: String
                    public var product: String
                    public var taxBehavior: TaxBehavior?
                    public var unitAmount: Int?
                    public var unitAmountDecimal: String?

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public init(currency: String, product: String, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                        self.currency = currency
                        self.product = product
                        self.taxBehavior = taxBehavior
                        self.unitAmount = unitAmount
                        self.unitAmountDecimal = unitAmountDecimal
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(product, forKey: "product")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(unitAmount, forKey: "unit_amount")
                        encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                        return encoder.items
                    }
                }

                public struct TaxRates: Encodable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                    self.price = price
                    self.priceData = priceData
                    self.quantity = quantity
                    self.taxRates = taxRates
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(price, forKey: "price")
                    encoder.encode(priceData, forKey: "price_data")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    return encoder.items
                }
            }

            /// Automatic_tax_config
            ///
            /// Automatic tax settings for this subscription.
            public struct AutomaticTax: Encodable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Either `now` or `unchanged`. Setting the value to `now` resets the subscription's billing cycle anchor to the current time. For more information, see the billing cycle [documentation](https://stripe.com/docs/billing/subscriptions/billing-cycle).
            public enum BillingCycleAnchor: String, Codable, CaseIterable {
                case now
                case unchanged
            }

            /// Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period. Pass an empty string to remove previously-defined thresholds.
            public struct BillingThresholds: Encodable {
                /// Billing_thresholds_param
                public var a: A?
                public var b: B?

                /// Billing_thresholds_param
                public struct A: Encodable {
                    public var amountGte: Int?
                    public var isResetBillingCycleAnchor: Bool?

                    public init(amountGte: Int? = nil, isResetBillingCycleAnchor: Bool? = nil) {
                        self.amountGte = amountGte
                        self.isResetBillingCycleAnchor = isResetBillingCycleAnchor
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amountGte, forKey: "amount_gte")
                        encoder.encode(isResetBillingCycleAnchor, forKey: "reset_billing_cycle_anchor")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// A timestamp at which the subscription should cancel. If set to a date before the current period ends, this will cause a proration if prorations have been enabled using `proration_behavior`. If set during a future period, this will always cause a proration for that period.
            public struct CancelAt: Encodable {
                public var int: Int?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(int: Int? = nil, object: Object? = nil) {
                    self.int = int
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(int, forKey: "int")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
            public enum CollectionMethod: String, Codable, CaseIterable {
                case chargeAutomatically = "charge_automatically"
                case sendInvoice = "send_invoice"
            }

            /// The tax rates that will apply to any subscription item that does not have `tax_rates` set. Invoices created will have their `default_tax_rates` populated from the subscription. Pass an empty string to remove previously-defined tax rates.
            public struct DefaultTaxRates: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Subscription_item_update_params
            public struct Item: Encodable {
                public var billingThresholds: BillingThresholds?
                public var isClearUsage: Bool?
                public var isDeleted: Bool?
                public var id: String?
                public var metadata: Metadata?
                public var price: String?
                /// Recurring_price_data
                public var priceData: PriceData?
                public var quantity: Int?
                public var taxRates: TaxRates?

                public struct BillingThresholds: Encodable {
                    /// Item_billing_thresholds_param
                    public var a: A?
                    public var b: B?

                    /// Item_billing_thresholds_param
                    public struct A: Encodable {
                        public var usageGte: Int

                        public init(usageGte: Int) {
                            self.usageGte = usageGte
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(usageGte, forKey: "usage_gte")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Metadata: Encodable {
                    public var stringString: [String: String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(stringString: [String: String]? = nil, object: Object? = nil) {
                        self.stringString = stringString
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(stringString, forKey: "stringString")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                /// Recurring_price_data
                public struct PriceData: Encodable {
                    public var currency: String
                    public var product: String
                    /// Recurring_adhoc
                    public var recurring: Recurring
                    public var taxBehavior: TaxBehavior?
                    public var unitAmount: Int?
                    public var unitAmountDecimal: String?

                    /// Recurring_adhoc
                    public struct Recurring: Encodable {
                        public var interval: Interval
                        public var intervalCount: Int?

                        public enum Interval: String, Codable, CaseIterable {
                            case day
                            case month
                            case week
                            case year
                        }

                        public init(interval: Interval, intervalCount: Int? = nil) {
                            self.interval = interval
                            self.intervalCount = intervalCount
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(interval, forKey: "interval")
                            encoder.encode(intervalCount, forKey: "interval_count")
                            return encoder.items
                        }
                    }

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public init(currency: String, product: String, recurring: Recurring, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                        self.currency = currency
                        self.product = product
                        self.recurring = recurring
                        self.taxBehavior = taxBehavior
                        self.unitAmount = unitAmount
                        self.unitAmountDecimal = unitAmountDecimal
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(product, forKey: "product")
                        encoder.encode(recurring, forKey: "recurring")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(unitAmount, forKey: "unit_amount")
                        encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                        return encoder.items
                    }
                }

                public struct TaxRates: Encodable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(billingThresholds: BillingThresholds? = nil, isClearUsage: Bool? = nil, isDeleted: Bool? = nil, id: String? = nil, metadata: Metadata? = nil, price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                    self.billingThresholds = billingThresholds
                    self.isClearUsage = isClearUsage
                    self.isDeleted = isDeleted
                    self.id = id
                    self.metadata = metadata
                    self.price = price
                    self.priceData = priceData
                    self.quantity = quantity
                    self.taxRates = taxRates
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(billingThresholds, forKey: "billing_thresholds")
                    encoder.encode(isClearUsage, forKey: "clear_usage")
                    encoder.encode(isDeleted, forKey: "deleted")
                    encoder.encode(id, forKey: "id")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(price, forKey: "price")
                    encoder.encode(priceData, forKey: "price_data")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// If specified, payment collection for this subscription will be paused.
            public struct PauseCollection: Encodable {
                /// Pause_collection_param
                public var a: A?
                public var b: B?

                /// Pause_collection_param
                public struct A: Encodable {
                    public var behavior: Behavior
                    public var resumesAt: Int?

                    public enum Behavior: String, Codable, CaseIterable {
                        case keepAsDraft = "keep_as_draft"
                        case markUncollectible = "mark_uncollectible"
                        case void
                    }

                    public init(behavior: Behavior, resumesAt: Int? = nil) {
                        self.behavior = behavior
                        self.resumesAt = resumesAt
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(behavior, forKey: "behavior")
                        encoder.encode(resumesAt, forKey: "resumes_at")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Use `allow_incomplete` to transition the subscription to `status=past_due` if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.
            /// 
            /// Use `default_incomplete` to transition the subscription to `status=past_due` when payment is required and await explicit confirmation of the invoice's payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.
            /// 
            /// Use `pending_if_incomplete` to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use `pending_if_incomplete` you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).
            /// 
            /// Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
            public enum PaymentBehavior: String, Codable, CaseIterable {
                case allowIncomplete = "allow_incomplete"
                case defaultIncomplete = "default_incomplete"
                case errorIfIncomplete = "error_if_incomplete"
                case pendingIfIncomplete = "pending_if_incomplete"
            }

            /// Payment_settings
            ///
            /// Payment settings to pass to invoices created by the subscription.
            public struct PaymentSettings: Encodable {
                /// Payment_method_options
                public var paymentMethodOptions: PaymentMethodOptions?
                public var paymentMethodTypes: PaymentMethodTypes?

                /// Payment_method_options
                public struct PaymentMethodOptions: Encodable {
                    public var acssDebit: AcssDebit?
                    public var bancontact: Bancontact?
                    public var card: Card?

                    public struct AcssDebit: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            /// Mandate_options_param
                            public var mandateOptions: MandateOptions?
                            public var verificationMethod: VerificationMethod?

                            /// Mandate_options_param
                            public struct MandateOptions: Encodable {
                                public var transactionType: TransactionType?

                                public enum TransactionType: String, Codable, CaseIterable {
                                    case business
                                    case personal
                                }

                                public init(transactionType: TransactionType? = nil) {
                                    self.transactionType = transactionType
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(transactionType, forKey: "transaction_type")
                                    return encoder.items
                                }
                            }

                            public enum VerificationMethod: String, Codable, CaseIterable {
                                case automatic
                                case instant
                                case microdeposits
                            }

                            public init(mandateOptions: MandateOptions? = nil, verificationMethod: VerificationMethod? = nil) {
                                self.mandateOptions = mandateOptions
                                self.verificationMethod = verificationMethod
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(mandateOptions, forKey: "mandate_options")
                                encoder.encode(verificationMethod, forKey: "verification_method")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct Bancontact: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            public var preferredLanguage: PreferredLanguage?

                            public enum PreferredLanguage: String, Codable, CaseIterable {
                                case de
                                case en
                                case fr
                                case nl
                            }

                            public init(preferredLanguage: PreferredLanguage? = nil) {
                                self.preferredLanguage = preferredLanguage
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(preferredLanguage, forKey: "preferred_language")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct Card: Encodable {
                        /// Subscription_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Subscription_payment_method_options_param
                        public struct A: Encodable {
                            public var requestThreeDSecure: RequestThreeDSecure?

                            public enum RequestThreeDSecure: String, Codable, CaseIterable {
                                case any
                                case automatic
                            }

                            public init(requestThreeDSecure: RequestThreeDSecure? = nil) {
                                self.requestThreeDSecure = requestThreeDSecure
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(requestThreeDSecure, forKey: "request_three_d_secure")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public init(acssDebit: AcssDebit? = nil, bancontact: Bancontact? = nil, card: Card? = nil) {
                        self.acssDebit = acssDebit
                        self.bancontact = bancontact
                        self.card = card
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(acssDebit, forKey: "acss_debit")
                        encoder.encode(bancontact, forKey: "bancontact")
                        encoder.encode(card, forKey: "card")
                        return encoder.items
                    }
                }

                public struct PaymentMethodTypes: Encodable {
                    public var placeholderItems: [PlaceholderItem]?
                    public var object: Object?

                    public enum PlaceholderItem: String, Codable, CaseIterable {
                        case achCreditTransfer = "ach_credit_transfer"
                        case achDebit = "ach_debit"
                        case acssDebit = "acss_debit"
                        case auBecsDebit = "au_becs_debit"
                        case bacsDebit = "bacs_debit"
                        case bancontact
                        case boleto
                        case card
                        case fpx
                        case giropay
                        case ideal
                        case sepaDebit = "sepa_debit"
                        case sofort
                        case wechatPay = "wechat_pay"
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                        self.placeholderItems = placeholderItems
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(placeholderItems, forKey: "placeholderItems")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(paymentMethodOptions: PaymentMethodOptions? = nil, paymentMethodTypes: PaymentMethodTypes? = nil) {
                    self.paymentMethodOptions = paymentMethodOptions
                    self.paymentMethodTypes = paymentMethodTypes
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(paymentMethodOptions, forKey: "payment_method_options")
                    encoder.encode(paymentMethodTypes, forKey: "payment_method_types")
                    return encoder.items
                }
            }

            /// Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling [Create an invoice](https://stripe.com/docs/api#create_invoice) for the given subscription at the specified interval.
            public struct PendingInvoiceItemInterval: Encodable {
                /// Pending_invoice_item_interval_params
                public var a: A?
                public var b: B?

                /// Pending_invoice_item_interval_params
                public struct A: Encodable {
                    public var interval: Interval
                    public var intervalCount: Int?

                    public enum Interval: String, Codable, CaseIterable {
                        case day
                        case month
                        case week
                        case year
                    }

                    public init(interval: Interval, intervalCount: Int? = nil) {
                        self.interval = interval
                        self.intervalCount = intervalCount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(interval, forKey: "interval")
                        encoder.encode(intervalCount, forKey: "interval_count")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes. Valid values are `create_prorations`, `none`, or `always_invoice`.
            /// 
            /// Passing `create_prorations` will cause proration invoice items to be created when applicable. These proration items will only be invoiced immediately under [certain conditions](https://stripe.com/docs/subscriptions/upgrading-downgrading#immediate-payment). In order to always invoice immediately for prorations, pass `always_invoice`.
            /// 
            /// Prorations can be disabled by passing `none`.
            public enum ProrationBehavior: String, Codable, CaseIterable {
                case alwaysInvoice = "always_invoice"
                case createProrations = "create_prorations"
                case `none`
            }

            /// If specified, the funds from the subscription's invoices will be transferred to the destination and the ID of the resulting transfers will be found on the resulting charges. This will be unset if you POST an empty value.
            public struct TransferData: Encodable {
                /// Transfer_data_specs
                public var a: A?
                public var b: B?

                /// Transfer_data_specs
                public struct A: Encodable {
                    public var amountPercent: Double?
                    public var destination: String

                    public init(amountPercent: Double? = nil, destination: String) {
                        self.amountPercent = amountPercent
                        self.destination = destination
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amountPercent, forKey: "amount_percent")
                        encoder.encode(destination, forKey: "destination")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Unix timestamp representing the end of the trial period the customer will get before being charged for the first time. This will always overwrite any trials that might apply via a subscribed plan. If set, trial_end will override the default trial period of the plan the customer is being subscribed to. The special value `now` can be provided to end the customer's trial immediately. Can be at most two years from `billing_cycle_anchor`.
            public struct TrialEnd: Encodable {
                public var object: Object?
                public var int: Int?

                public enum Object: String, Codable, CaseIterable {
                    case now
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(addInvoiceItems: [AddInvoiceItem]? = nil, applicationFeePercent: Double? = nil, automaticTax: AutomaticTax? = nil, billingCycleAnchor: BillingCycleAnchor? = nil, billingThresholds: BillingThresholds? = nil, cancelAt: CancelAt? = nil, isCancelAtPeriodEnd: Bool? = nil, collectionMethod: CollectionMethod? = nil, coupon: String? = nil, daysUntilDue: Int? = nil, defaultPaymentMethod: String? = nil, defaultSource: String? = nil, defaultTaxRates: DefaultTaxRates? = nil, expand: [String]? = nil, items: [Item]? = nil, metadata: Metadata? = nil, isOffSession: Bool? = nil, pauseCollection: PauseCollection? = nil, paymentBehavior: PaymentBehavior? = nil, paymentSettings: PaymentSettings? = nil, pendingInvoiceItemInterval: PendingInvoiceItemInterval? = nil, promotionCode: String? = nil, prorationBehavior: ProrationBehavior? = nil, prorationDate: Int? = nil, transferData: TransferData? = nil, trialEnd: TrialEnd? = nil, isTrialFromPlan: Bool? = nil) {
                self.addInvoiceItems = addInvoiceItems
                self.applicationFeePercent = applicationFeePercent
                self.automaticTax = automaticTax
                self.billingCycleAnchor = billingCycleAnchor
                self.billingThresholds = billingThresholds
                self.cancelAt = cancelAt
                self.isCancelAtPeriodEnd = isCancelAtPeriodEnd
                self.collectionMethod = collectionMethod
                self.coupon = coupon
                self.daysUntilDue = daysUntilDue
                self.defaultPaymentMethod = defaultPaymentMethod
                self.defaultSource = defaultSource
                self.defaultTaxRates = defaultTaxRates
                self.expand = expand
                self.items = items
                self.metadata = metadata
                self.isOffSession = isOffSession
                self.pauseCollection = pauseCollection
                self.paymentBehavior = paymentBehavior
                self.paymentSettings = paymentSettings
                self.pendingInvoiceItemInterval = pendingInvoiceItemInterval
                self.promotionCode = promotionCode
                self.prorationBehavior = prorationBehavior
                self.prorationDate = prorationDate
                self.transferData = transferData
                self.trialEnd = trialEnd
                self.isTrialFromPlan = isTrialFromPlan
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(addInvoiceItems, forKey: "add_invoice_items")
                encoder.encode(applicationFeePercent, forKey: "application_fee_percent")
                encoder.encode(automaticTax, forKey: "automatic_tax")
                encoder.encode(billingCycleAnchor, forKey: "billing_cycle_anchor")
                encoder.encode(billingThresholds, forKey: "billing_thresholds")
                encoder.encode(cancelAt, forKey: "cancel_at")
                encoder.encode(isCancelAtPeriodEnd, forKey: "cancel_at_period_end")
                encoder.encode(collectionMethod, forKey: "collection_method")
                encoder.encode(coupon, forKey: "coupon")
                encoder.encode(daysUntilDue, forKey: "days_until_due")
                encoder.encode(defaultPaymentMethod, forKey: "default_payment_method")
                encoder.encode(defaultSource, forKey: "default_source")
                encoder.encode(defaultTaxRates, forKey: "default_tax_rates")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(items, forKey: "items")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(isOffSession, forKey: "off_session")
                encoder.encode(pauseCollection, forKey: "pause_collection")
                encoder.encode(paymentBehavior, forKey: "payment_behavior")
                encoder.encode(paymentSettings, forKey: "payment_settings")
                encoder.encode(pendingInvoiceItemInterval, forKey: "pending_invoice_item_interval")
                encoder.encode(promotionCode, forKey: "promotion_code")
                encoder.encode(prorationBehavior, forKey: "proration_behavior")
                encoder.encode(prorationDate, forKey: "proration_date")
                encoder.encode(transferData, forKey: "transfer_data")
                encoder.encode(trialEnd, forKey: "trial_end")
                encoder.encode(isTrialFromPlan, forKey: "trial_from_plan")
                return encoder.items
            }
        }

        /// <p>Cancels a customer’s subscription. If you set the <code>at_period_end</code> parameter to <code>true</code>, the subscription will remain active until the end of the period, at which point it will be canceled and not renewed. Otherwise, with the default <code>false</code> value, the subscription is terminated immediately. In either case, the customer will not be charged again for the subscription.</p>
        /// 
        /// <p>Note, however, that any pending invoice items that you’ve created will still be charged for at the end of the period, unless manually <a href="#delete_invoiceitem">deleted</a>. If you’ve set the subscription to cancel at the end of the period, any pending prorations will also be left in place and collected at the end of the period. But if the subscription is set to cancel immediately, pending prorations will be removed.</p>
        /// 
        /// <p>By default, upon subscription cancellation, Stripe will stop automatic collection of all finalized invoices for the customer. This is intended to prevent unexpected payment attempts after the customer has canceled a subscription. However, you can resume automatic collection of the invoices manually after subscription cancellation to have us proceed. Or, you could check for unpaid invoices before allowing the customer to cancel the subscription at all.</p>
        public func delete(_ body: DeleteRequest? = nil) -> Request<StripeAPI.Subscription> {
            .delete(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct DeleteRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Can be set to `true` if `at_period_end` is not set to `true`. Will generate a final invoice that invoices for any un-invoiced metered usage and new/pending proration invoice items.
            public var isInvoiceNow: Bool?
            /// Can be set to `true` if `at_period_end` is not set to `true`. Will generate a proration invoice item that credits remaining unused time until the subscription period end.
            public var isProrate: Bool?

            public init(expand: [String]? = nil, isInvoiceNow: Bool? = nil, isProrate: Bool? = nil) {
                self.expand = expand
                self.isInvoiceNow = isInvoiceNow
                self.isProrate = isProrate
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(isInvoiceNow, forKey: "invoice_now")
                encoder.encode(isProrate, forKey: "prorate")
                return encoder.items
            }
        }
    }
}

extension Paths.Customers.WithCustomer.Subscriptions.WithSubscriptionExposedID {
    public var discount: Discount {
        Discount(path: path + "/discount")
    }

    public struct Discount {
        /// Path: `/v1/customers/{customer}/subscriptions/{subscription_exposed_id}/discount`
        public let path: String

        public func get(expand: [String]? = nil) -> Request<StripeAPI.Discount> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Removes the currently applied discount on a customer.</p>
        public var delete: Request<StripeAPI.DeletedDiscount> {
            .delete(path)
        }
    }
}

extension Paths.Customers.WithCustomer {
    public var taxIDs: TaxIDs {
        TaxIDs(path: path + "/tax_ids")
    }

    public struct TaxIDs {
        /// Path: `/v1/customers/{customer}/tax_ids`
        public let path: String

        /// <p>Returns a list of tax IDs for a customer.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// TaxIDsList
        public struct GetResponse: Decodable {
            /// Details about each object.
            public var data: [StripeAPI.TaxID]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.TaxID], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates a new <code>TaxID</code> object for a customer.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.TaxID> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Type of the tax ID, one of `ae_trn`, `au_abn`, `au_arn`, `br_cnpj`, `br_cpf`, `ca_bn`, `ca_gst_hst`, `ca_pst_bc`, `ca_pst_mb`, `ca_pst_sk`, `ca_qst`, `ch_vat`, `cl_tin`, `es_cif`, `eu_vat`, `gb_vat`, `ge_vat`, `hk_br`, `id_npwp`, `il_vat`, `in_gst`, `jp_cn`, `jp_rn`, `kr_brn`, `li_uid`, `mx_rfc`, `my_frp`, `my_itn`, `my_sst`, `no_vat`, `nz_gst`, `ru_inn`, `ru_kpp`, `sa_vat`, `sg_gst`, `sg_uen`, `th_vat`, `tw_vat`, `ua_vat`, `us_ein`, or `za_vat`
            public var type: `Type`
            /// Value of the tax ID.
            public var value: String

            /// Type of the tax ID, one of `ae_trn`, `au_abn`, `au_arn`, `br_cnpj`, `br_cpf`, `ca_bn`, `ca_gst_hst`, `ca_pst_bc`, `ca_pst_mb`, `ca_pst_sk`, `ca_qst`, `ch_vat`, `cl_tin`, `es_cif`, `eu_vat`, `gb_vat`, `ge_vat`, `hk_br`, `id_npwp`, `il_vat`, `in_gst`, `jp_cn`, `jp_rn`, `kr_brn`, `li_uid`, `mx_rfc`, `my_frp`, `my_itn`, `my_sst`, `no_vat`, `nz_gst`, `ru_inn`, `ru_kpp`, `sa_vat`, `sg_gst`, `sg_uen`, `th_vat`, `tw_vat`, `ua_vat`, `us_ein`, or `za_vat`
            public enum `Type`: String, Codable, CaseIterable {
                case aeTrn = "ae_trn"
                case auAbn = "au_abn"
                case auArn = "au_arn"
                case brCnpj = "br_cnpj"
                case brCpf = "br_cpf"
                case caBn = "ca_bn"
                case caGstHst = "ca_gst_hst"
                case caPstBc = "ca_pst_bc"
                case caPstMb = "ca_pst_mb"
                case caPstSk = "ca_pst_sk"
                case caQst = "ca_qst"
                case chVat = "ch_vat"
                case clTin = "cl_tin"
                case esCif = "es_cif"
                case euVat = "eu_vat"
                case gbVat = "gb_vat"
                case geVat = "ge_vat"
                case hkBr = "hk_br"
                case idNpwp = "id_npwp"
                case ilVat = "il_vat"
                case inGst = "in_gst"
                case jpCn = "jp_cn"
                case jpRn = "jp_rn"
                case krBrn = "kr_brn"
                case liUid = "li_uid"
                case mxRfc = "mx_rfc"
                case myFrp = "my_frp"
                case myItn = "my_itn"
                case mySst = "my_sst"
                case noVat = "no_vat"
                case nzGst = "nz_gst"
                case ruInn = "ru_inn"
                case ruKpp = "ru_kpp"
                case saVat = "sa_vat"
                case sgGst = "sg_gst"
                case sgUen = "sg_uen"
                case thVat = "th_vat"
                case twVat = "tw_vat"
                case uaVat = "ua_vat"
                case usEin = "us_ein"
                case zaVat = "za_vat"
            }

            public init(expand: [String]? = nil, type: `Type`, value: String) {
                self.expand = expand
                self.type = type
                self.value = value
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(type, forKey: "type")
                encoder.encode(value, forKey: "value")
                return encoder.items
            }
        }
    }
}

extension Paths.Customers.WithCustomer.TaxIDs {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/customers/{customer}/tax_ids/{id}`
        public let path: String

        /// <p>Retrieves the <code>TaxID</code> object with the given identifier.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.TaxID> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Deletes an existing <code>TaxID</code> object.</p>
        public var delete: Request<StripeAPI.DeletedTaxID> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var disputes: Disputes {
        Disputes(path: "/v1/disputes")
    }

    public struct Disputes {
        /// Path: `/v1/disputes`
        public let path: String

        /// <p>Returns a list of your disputes.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Dispute]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Dispute], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var charge: String?
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var paymentIntent: String?
            public var startingAfter: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(charge: String? = nil, created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, paymentIntent: String? = nil, startingAfter: String? = nil) {
                self.charge = charge
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.paymentIntent = paymentIntent
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(charge, forKey: "charge")
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(paymentIntent, forKey: "payment_intent")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }
    }
}

extension Paths.Disputes {
    public func dispute(_ dispute: String) -> WithDispute {
        WithDispute(path: "\(path)/\(dispute)")
    }

    public struct WithDispute {
        /// Path: `/v1/disputes/{dispute}`
        public let path: String

        /// <p>Retrieves the dispute with the given ID.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Dispute> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>When you get a dispute, contacting your customer is always the best first step. If that doesn’t work, you can submit evidence to help us resolve the dispute in your favor. You can do this in your <a href="https://dashboard.stripe.com/disputes">dashboard</a>, but if you prefer, you can use the API to submit evidence programmatically.</p>
        /// 
        /// <p>Depending on your dispute type, different evidence fields will give you a better chance of winning your dispute. To figure out which evidence fields to provide, see our <a href="/docs/disputes/categories">guide to dispute types</a>.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Dispute> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Dispute_evidence_params
            ///
            /// Evidence to upload, to respond to a dispute. Updating any field in the hash will submit all fields in the hash for review. The combined character count of all fields is limited to 150,000.
            public var evidence: Evidence?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// Whether to immediately submit evidence to the bank. If `false`, evidence is staged on the dispute. Staged evidence is visible in the API and Dashboard, and can be submitted to the bank by making another request with this attribute set to `true` (the default).
            public var isSubmit: Bool?

            /// Dispute_evidence_params
            ///
            /// Evidence to upload, to respond to a dispute. Updating any field in the hash will submit all fields in the hash for review. The combined character count of all fields is limited to 150,000.
            public struct Evidence: Encodable {
                public var accessActivityLog: String?
                public var billingAddress: String?
                public var cancellationPolicy: String?
                public var cancellationPolicyDisclosure: String?
                public var cancellationRebuttal: String?
                public var customerCommunication: String?
                public var customerEmailAddress: String?
                public var customerName: String?
                public var customerPurchaseIp: String?
                public var customerSignature: String?
                public var duplicateChargeDocumentation: String?
                public var duplicateChargeExplanation: String?
                public var duplicateChargeID: String?
                public var productDescription: String?
                public var receipt: String?
                public var refundPolicy: String?
                public var refundPolicyDisclosure: String?
                public var refundRefusalExplanation: String?
                public var serviceDate: String?
                public var serviceDocumentation: String?
                public var shippingAddress: String?
                public var shippingCarrier: String?
                public var shippingDate: String?
                public var shippingDocumentation: String?
                public var shippingTrackingNumber: String?
                public var uncategorizedFile: String?
                public var uncategorizedText: String?

                public init(accessActivityLog: String? = nil, billingAddress: String? = nil, cancellationPolicy: String? = nil, cancellationPolicyDisclosure: String? = nil, cancellationRebuttal: String? = nil, customerCommunication: String? = nil, customerEmailAddress: String? = nil, customerName: String? = nil, customerPurchaseIp: String? = nil, customerSignature: String? = nil, duplicateChargeDocumentation: String? = nil, duplicateChargeExplanation: String? = nil, duplicateChargeID: String? = nil, productDescription: String? = nil, receipt: String? = nil, refundPolicy: String? = nil, refundPolicyDisclosure: String? = nil, refundRefusalExplanation: String? = nil, serviceDate: String? = nil, serviceDocumentation: String? = nil, shippingAddress: String? = nil, shippingCarrier: String? = nil, shippingDate: String? = nil, shippingDocumentation: String? = nil, shippingTrackingNumber: String? = nil, uncategorizedFile: String? = nil, uncategorizedText: String? = nil) {
                    self.accessActivityLog = accessActivityLog
                    self.billingAddress = billingAddress
                    self.cancellationPolicy = cancellationPolicy
                    self.cancellationPolicyDisclosure = cancellationPolicyDisclosure
                    self.cancellationRebuttal = cancellationRebuttal
                    self.customerCommunication = customerCommunication
                    self.customerEmailAddress = customerEmailAddress
                    self.customerName = customerName
                    self.customerPurchaseIp = customerPurchaseIp
                    self.customerSignature = customerSignature
                    self.duplicateChargeDocumentation = duplicateChargeDocumentation
                    self.duplicateChargeExplanation = duplicateChargeExplanation
                    self.duplicateChargeID = duplicateChargeID
                    self.productDescription = productDescription
                    self.receipt = receipt
                    self.refundPolicy = refundPolicy
                    self.refundPolicyDisclosure = refundPolicyDisclosure
                    self.refundRefusalExplanation = refundRefusalExplanation
                    self.serviceDate = serviceDate
                    self.serviceDocumentation = serviceDocumentation
                    self.shippingAddress = shippingAddress
                    self.shippingCarrier = shippingCarrier
                    self.shippingDate = shippingDate
                    self.shippingDocumentation = shippingDocumentation
                    self.shippingTrackingNumber = shippingTrackingNumber
                    self.uncategorizedFile = uncategorizedFile
                    self.uncategorizedText = uncategorizedText
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(accessActivityLog, forKey: "access_activity_log")
                    encoder.encode(billingAddress, forKey: "billing_address")
                    encoder.encode(cancellationPolicy, forKey: "cancellation_policy")
                    encoder.encode(cancellationPolicyDisclosure, forKey: "cancellation_policy_disclosure")
                    encoder.encode(cancellationRebuttal, forKey: "cancellation_rebuttal")
                    encoder.encode(customerCommunication, forKey: "customer_communication")
                    encoder.encode(customerEmailAddress, forKey: "customer_email_address")
                    encoder.encode(customerName, forKey: "customer_name")
                    encoder.encode(customerPurchaseIp, forKey: "customer_purchase_ip")
                    encoder.encode(customerSignature, forKey: "customer_signature")
                    encoder.encode(duplicateChargeDocumentation, forKey: "duplicate_charge_documentation")
                    encoder.encode(duplicateChargeExplanation, forKey: "duplicate_charge_explanation")
                    encoder.encode(duplicateChargeID, forKey: "duplicate_charge_id")
                    encoder.encode(productDescription, forKey: "product_description")
                    encoder.encode(receipt, forKey: "receipt")
                    encoder.encode(refundPolicy, forKey: "refund_policy")
                    encoder.encode(refundPolicyDisclosure, forKey: "refund_policy_disclosure")
                    encoder.encode(refundRefusalExplanation, forKey: "refund_refusal_explanation")
                    encoder.encode(serviceDate, forKey: "service_date")
                    encoder.encode(serviceDocumentation, forKey: "service_documentation")
                    encoder.encode(shippingAddress, forKey: "shipping_address")
                    encoder.encode(shippingCarrier, forKey: "shipping_carrier")
                    encoder.encode(shippingDate, forKey: "shipping_date")
                    encoder.encode(shippingDocumentation, forKey: "shipping_documentation")
                    encoder.encode(shippingTrackingNumber, forKey: "shipping_tracking_number")
                    encoder.encode(uncategorizedFile, forKey: "uncategorized_file")
                    encoder.encode(uncategorizedText, forKey: "uncategorized_text")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(evidence: Evidence? = nil, expand: [String]? = nil, metadata: Metadata? = nil, isSubmit: Bool? = nil) {
                self.evidence = evidence
                self.expand = expand
                self.metadata = metadata
                self.isSubmit = isSubmit
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(evidence, forKey: "evidence")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(isSubmit, forKey: "submit")
                return encoder.items
            }
        }
    }
}

extension Paths.Disputes.WithDispute {
    public var close: Close {
        Close(path: path + "/close")
    }

    public struct Close {
        /// Path: `/v1/disputes/{dispute}/close`
        public let path: String

        /// <p>Closing the dispute for a charge indicates that you do not have any evidence to submit and are essentially dismissing the dispute, acknowledging it as lost.</p>
        /// 
        /// <p>The status of the dispute will change from <code>needs_response</code> to <code>lost</code>. <em>Closing a dispute is irreversible</em>.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Dispute> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(expand: [String]? = nil) {
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var ephemeralKeys: EphemeralKeys {
        EphemeralKeys(path: "/v1/ephemeral_keys")
    }

    public struct EphemeralKeys {
        /// Path: `/v1/ephemeral_keys`
        public let path: String

        /// <p>Creates a short-lived API key for a given resource.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.EphemeralKey> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The ID of the Customer you'd like to modify using the resulting ephemeral key.
            public var customer: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The ID of the Issuing Card you'd like to access using the resulting ephemeral key.
            public var issuingCard: String?

            public init(customer: String? = nil, expand: [String]? = nil, issuingCard: String? = nil) {
                self.customer = customer
                self.expand = expand
                self.issuingCard = issuingCard
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(customer, forKey: "customer")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(issuingCard, forKey: "issuing_card")
                return encoder.items
            }
        }
    }
}

extension Paths.EphemeralKeys {
    public func key(_ key: String) -> WithKey {
        WithKey(path: "\(path)/\(key)")
    }

    public struct WithKey {
        /// Path: `/v1/ephemeral_keys/{key}`
        public let path: String

        /// <p>Invalidates a short-lived API key for a given resource.</p>
        public func delete(_ body: DeleteRequest? = nil) -> Request<StripeAPI.EphemeralKey> {
            .delete(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct DeleteRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(expand: [String]? = nil) {
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var events: Events {
        Events(path: "/v1/events")
    }

    public struct Events {
        /// Path: `/v1/events`
        public let path: String

        /// <p>List events, going back up to 30 days. Each event data is rendered according to Stripe API version at its creation time, specified in <a href="/docs/api/events/object">event object</a> <code>api_version</code> attribute (not according to your current Stripe API version or <code>Stripe-Version</code> header).</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// NotificationEventList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Event]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Event], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var isDeliverySuccess: Bool?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?
            public var type: String?
            public var types: [String]?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(created: Created? = nil, isDeliverySuccess: Bool? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil, type: String? = nil, types: [String]? = nil) {
                self.created = created
                self.isDeliverySuccess = isDeliverySuccess
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
                self.type = type
                self.types = types
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(isDeliverySuccess, forKey: "delivery_success")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(type, forKey: "type")
                encoder.encode(types, forKey: "types", isDeepObject: true)
                return encoder.items
            }
        }
    }
}

extension Paths.Events {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/events/{id}`
        public let path: String

        /// <p>Retrieves the details of an event. Supply the unique identifier of the event, which you might have received in a webhook.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Event> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths {
    public static var exchangeRates: ExchangeRates {
        ExchangeRates(path: "/v1/exchange_rates")
    }

    public struct ExchangeRates {
        /// Path: `/v1/exchange_rates`
        public let path: String

        /// <p>Returns a list of objects that contain the rates at which foreign currencies are converted to one another. Only shows the currencies for which Stripe supports.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.ExchangeRate]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.ExchangeRate], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }
    }
}

extension Paths.ExchangeRates {
    public func rateID(_ rateID: String) -> WithRateID {
        WithRateID(path: "\(path)/\(rateID)")
    }

    public struct WithRateID {
        /// Path: `/v1/exchange_rates/{rate_id}`
        public let path: String

        /// <p>Retrieves the exchange rates from the given currency to every supported currency.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.ExchangeRate> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths {
    public static var fileLinks: FileLinks {
        FileLinks(path: "/v1/file_links")
    }

    public struct FileLinks {
        /// Path: `/v1/file_links`
        public let path: String

        /// <p>Returns a list of file links.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.FileLink]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.FileLink], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var isExpired: Bool?
            public var file: String?
            public var limit: Int?
            public var startingAfter: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, isExpired: Bool? = nil, file: String? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.isExpired = isExpired
                self.file = file
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(isExpired, forKey: "expired")
                encoder.encode(file, forKey: "file")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates a new file link object.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.FileLink> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// A future timestamp after which the link will no longer be usable.
            public var expiresAt: Int?
            /// The ID of the file. The file's `purpose` must be one of the following: `business_icon`, `business_logo`, `customer_signature`, `dispute_evidence`, `finance_report_run`, `identity_document_downloadable`, `pci_document`, `selfie`, `sigma_scheduled_query`, or `tax_document_user_upload`.
            public var file: String
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(expand: [String]? = nil, expiresAt: Int? = nil, file: String, metadata: Metadata? = nil) {
                self.expand = expand
                self.expiresAt = expiresAt
                self.file = file
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(expiresAt, forKey: "expires_at")
                encoder.encode(file, forKey: "file")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths.FileLinks {
    public func link(_ link: String) -> WithLink {
        WithLink(path: "\(path)/\(link)")
    }

    public struct WithLink {
        /// Path: `/v1/file_links/{link}`
        public let path: String

        /// <p>Retrieves the file link with the given ID.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.FileLink> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates an existing file link object. Expired links can no longer be updated.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.FileLink> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// A future timestamp after which the link will no longer be usable, or `now` to expire the link immediately.
            public var expiresAt: ExpiresAt?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?

            /// A future timestamp after which the link will no longer be usable, or `now` to expire the link immediately.
            public struct ExpiresAt: Encodable {
                public var object1: Object1?
                public var int: Int?
                public var object2: Object2?

                public enum Object1: String, Codable, CaseIterable {
                    case now
                }

                public enum Object2: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(object1: Object1? = nil, int: Int? = nil, object2: Object2? = nil) {
                    self.object1 = object1
                    self.int = int
                    self.object2 = object2
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object1, forKey: "object1")
                    encoder.encode(int, forKey: "int")
                    encoder.encode(object2, forKey: "object2")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(expand: [String]? = nil, expiresAt: ExpiresAt? = nil, metadata: Metadata? = nil) {
                self.expand = expand
                self.expiresAt = expiresAt
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(expiresAt, forKey: "expires_at")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var files: Files {
        Files(path: "/v1/files")
    }

    public struct Files {
        /// Path: `/v1/files`
        public let path: String

        /// <p>Returns a list of the files that your account has access to. The files are returned sorted by creation date, with the most recently created files appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.File]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.File], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var purpose: Purpose?
            public var startingAfter: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public enum Purpose: String, Codable, CaseIterable {
                case accountRequirement = "account_requirement"
                case additionalVerification = "additional_verification"
                case businessIcon = "business_icon"
                case businessLogo = "business_logo"
                case customerSignature = "customer_signature"
                case disputeEvidence = "dispute_evidence"
                case documentProviderIdentityDocument = "document_provider_identity_document"
                case financeReportRun = "finance_report_run"
                case identityDocument = "identity_document"
                case identityDocumentDownloadable = "identity_document_downloadable"
                case pciDocument = "pci_document"
                case selfie
                case sigmaScheduledQuery = "sigma_scheduled_query"
                case taxDocumentUserUpload = "tax_document_user_upload"
            }

            public init(created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, purpose: Purpose? = nil, startingAfter: String? = nil) {
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.purpose = purpose
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(purpose, forKey: "purpose")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>To upload a file to Stripe, you’ll need to send a request of type <code>multipart/form-data</code>. The request should contain the file you would like to upload, as well as the parameters for creating a file.</p>
        /// 
        /// <p>All of Stripe’s officially supported Client libraries should have support for sending <code>multipart/form-data</code>.</p>
        public func post(_ body: Data) -> Request<StripeAPI.File> {
            .post(path, body: body)
        }
    }
}

extension Paths.Files {
    public func file(_ file: String) -> WithFile {
        WithFile(path: "\(path)/\(file)")
    }

    public struct WithFile {
        /// Path: `/v1/files/{file}`
        public let path: String

        /// <p>Retrieves the details of an existing file object. Supply the unique file ID from a file, and Stripe will return the corresponding file object. To access file contents, see the <a href="/docs/file-upload#download-file-contents">File Upload Guide</a>.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.File> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths {
    public static var identity: Identity {
        Identity(path: "/v1/identity")
    }

    public struct Identity {
        /// Path: `/v1/identity`
        public let path: String
    }
}

extension Paths.Identity {
    public var verificationReports: VerificationReports {
        VerificationReports(path: path + "/verification_reports")
    }

    public struct VerificationReports {
        /// Path: `/v1/identity/verification_reports`
        public let path: String

        /// <p>List all verification reports.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.IdentityVerificationReport]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.IdentityVerificationReport], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?
            public var type: `Type`?
            public var verificationSession: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public enum `Type`: String, Codable, CaseIterable {
                case document
                case idNumber = "id_number"
            }

            public init(created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil, type: `Type`? = nil, verificationSession: String? = nil) {
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
                self.type = type
                self.verificationSession = verificationSession
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(type, forKey: "type")
                encoder.encode(verificationSession, forKey: "verification_session")
                return encoder.items
            }
        }
    }
}

extension Paths.Identity.VerificationReports {
    public func report(_ report: String) -> WithReport {
        WithReport(path: "\(path)/\(report)")
    }

    public struct WithReport {
        /// Path: `/v1/identity/verification_reports/{report}`
        public let path: String

        /// <p>Retrieves an existing VerificationReport</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.IdentityVerificationReport> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths.Identity {
    public var verificationSessions: VerificationSessions {
        VerificationSessions(path: path + "/verification_sessions")
    }

    public struct VerificationSessions {
        /// Path: `/v1/identity/verification_sessions`
        public let path: String

        /// <p>Returns a list of VerificationSessions</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.IdentityVerificationSession]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.IdentityVerificationSession], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?
            public var status: Status?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public enum Status: String, Codable, CaseIterable {
                case canceled
                case processing
                case requiresInput = "requires_input"
                case verified
            }

            public init(created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil, status: Status? = nil) {
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
                self.status = status
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(status, forKey: "status")
                return encoder.items
            }
        }

        /// <p>Creates a VerificationSession object.</p>
        /// 
        /// <p>After the VerificationSession is created, display a verification modal using the session <code>client_secret</code> or send your users to the session’s <code>url</code>.</p>
        /// 
        /// <p>If your API key is in test mode, verification checks won’t actually process, though everything else will occur as if in live mode.</p>
        /// 
        /// <p>Related guide: <a href="/docs/identity/verify-identity-documents">Verify your users’ identity documents</a>.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.IdentityVerificationSession> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// Session_options_param
            ///
            /// A set of options for the session’s verification checks.
            public var options: Options?
            /// The URL that the user will be redirected to upon completing the verification flow.
            public var returnURL: String?
            /// The type of [verification check](https://stripe.com/docs/identity/verification-checks) to be performed.
            public var type: `Type`

            /// Session_options_param
            ///
            /// A set of options for the session’s verification checks.
            public struct Options: Encodable {
                public var document: Document?

                public struct Document: Encodable {
                    /// Document_options
                    public var a: A?
                    public var b: B?

                    /// Document_options
                    public struct A: Encodable {
                        public var allowedTypes: [AllowedType]?
                        public var requireIDNumber: Bool?
                        public var requireLiveCapture: Bool?
                        public var requireMatchingSelfie: Bool?

                        public enum AllowedType: String, Codable, CaseIterable {
                            case drivingLicense = "driving_license"
                            case idCard = "id_card"
                            case passport
                        }

                        public init(allowedTypes: [AllowedType]? = nil, requireIDNumber: Bool? = nil, requireLiveCapture: Bool? = nil, requireMatchingSelfie: Bool? = nil) {
                            self.allowedTypes = allowedTypes
                            self.requireIDNumber = requireIDNumber
                            self.requireLiveCapture = requireLiveCapture
                            self.requireMatchingSelfie = requireMatchingSelfie
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(allowedTypes, forKey: "allowed_types")
                            encoder.encode(requireIDNumber, forKey: "require_id_number")
                            encoder.encode(requireLiveCapture, forKey: "require_live_capture")
                            encoder.encode(requireMatchingSelfie, forKey: "require_matching_selfie")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public init(document: Document? = nil) {
                    self.document = document
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(document, forKey: "document")
                    return encoder.items
                }
            }

            /// The type of [verification check](https://stripe.com/docs/identity/verification-checks) to be performed.
            public enum `Type`: String, Codable, CaseIterable {
                case document
                case idNumber = "id_number"
            }

            public init(expand: [String]? = nil, metadata: [String: String]? = nil, options: Options? = nil, returnURL: String? = nil, type: `Type`) {
                self.expand = expand
                self.metadata = metadata
                self.options = options
                self.returnURL = returnURL
                self.type = type
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(options, forKey: "options")
                encoder.encode(returnURL, forKey: "return_url")
                encoder.encode(type, forKey: "type")
                return encoder.items
            }
        }
    }
}

extension Paths.Identity.VerificationSessions {
    public func session(_ session: String) -> WithSession {
        WithSession(path: "\(path)/\(session)")
    }

    public struct WithSession {
        /// Path: `/v1/identity/verification_sessions/{session}`
        public let path: String

        /// <p>Retrieves the details of a VerificationSession that was previously created.</p>
        /// 
        /// <p>When the session status is <code>requires_input</code>, you can use this method to retrieve a valid
        /// <code>client_secret</code> or <code>url</code> to allow re-submission.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.IdentityVerificationSession> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates a VerificationSession object.</p>
        /// 
        /// <p>When the session status is <code>requires_input</code>, you can use this method to update the
        /// verification check and options.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.IdentityVerificationSession> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// Session_options_param
            ///
            /// A set of options for the session’s verification checks.
            public var options: Options?
            /// The type of [verification check](https://stripe.com/docs/identity/verification-checks) to be performed.
            public var type: `Type`?

            /// Session_options_param
            ///
            /// A set of options for the session’s verification checks.
            public struct Options: Encodable {
                public var document: Document?

                public struct Document: Encodable {
                    /// Document_options
                    public var a: A?
                    public var b: B?

                    /// Document_options
                    public struct A: Encodable {
                        public var allowedTypes: [AllowedType]?
                        public var requireIDNumber: Bool?
                        public var requireLiveCapture: Bool?
                        public var requireMatchingSelfie: Bool?

                        public enum AllowedType: String, Codable, CaseIterable {
                            case drivingLicense = "driving_license"
                            case idCard = "id_card"
                            case passport
                        }

                        public init(allowedTypes: [AllowedType]? = nil, requireIDNumber: Bool? = nil, requireLiveCapture: Bool? = nil, requireMatchingSelfie: Bool? = nil) {
                            self.allowedTypes = allowedTypes
                            self.requireIDNumber = requireIDNumber
                            self.requireLiveCapture = requireLiveCapture
                            self.requireMatchingSelfie = requireMatchingSelfie
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(allowedTypes, forKey: "allowed_types")
                            encoder.encode(requireIDNumber, forKey: "require_id_number")
                            encoder.encode(requireLiveCapture, forKey: "require_live_capture")
                            encoder.encode(requireMatchingSelfie, forKey: "require_matching_selfie")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public init(document: Document? = nil) {
                    self.document = document
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(document, forKey: "document")
                    return encoder.items
                }
            }

            /// The type of [verification check](https://stripe.com/docs/identity/verification-checks) to be performed.
            public enum `Type`: String, Codable, CaseIterable {
                case document
                case idNumber = "id_number"
            }

            public init(expand: [String]? = nil, metadata: [String: String]? = nil, options: Options? = nil, type: `Type`? = nil) {
                self.expand = expand
                self.metadata = metadata
                self.options = options
                self.type = type
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(options, forKey: "options")
                encoder.encode(type, forKey: "type")
                return encoder.items
            }
        }
    }
}

extension Paths.Identity.VerificationSessions.WithSession {
    public var cancel: Cancel {
        Cancel(path: path + "/cancel")
    }

    public struct Cancel {
        /// Path: `/v1/identity/verification_sessions/{session}/cancel`
        public let path: String

        /// <p>A VerificationSession object can be canceled when it is in <code>requires_input</code> <a href="/docs/identity/how-sessions-work">status</a>.</p>
        /// 
        /// <p>Once canceled, future submission attempts are disabled. This cannot be undone. <a href="/docs/identity/verification-sessions#cancel">Learn more</a>.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.IdentityVerificationSession> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(expand: [String]? = nil) {
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.Identity.VerificationSessions.WithSession {
    public var redact: Redact {
        Redact(path: path + "/redact")
    }

    public struct Redact {
        /// Path: `/v1/identity/verification_sessions/{session}/redact`
        public let path: String

        /// <p>Redact a VerificationSession to remove all collected information from Stripe. This will redact
        /// the VerificationSession and all objects related to it, including VerificationReports, Events,
        /// request logs, etc.</p>
        /// 
        /// <p>A VerificationSession object can be redacted when it is in <code>requires_input</code> or <code>verified</code>
        /// <a href="/docs/identity/how-sessions-work">status</a>. Redacting a VerificationSession in <code>requires_action</code>
        /// state will automatically cancel it.</p>
        /// 
        /// <p>The redaction process may take up to four days. When the redaction process is in progress, the
        /// VerificationSession’s <code>redaction.status</code> field will be set to <code>processing</code>; when the process is
        /// finished, it will change to <code>redacted</code> and an <code>identity.verification_session.redacted</code> event
        /// will be emitted.</p>
        /// 
        /// <p>Redaction is irreversible. Redacted objects are still accessible in the Stripe API, but all the
        /// fields that contain personal data will be replaced by the string <code>[redacted]</code> or a similar
        /// placeholder. The <code>metadata</code> field will also be erased. Redacted objects cannot be updated or
        /// used for any purpose.</p>
        /// 
        /// <p><a href="/docs/identity/verification-sessions#redact">Learn more</a>.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.IdentityVerificationSession> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(expand: [String]? = nil) {
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var invoiceitems: Invoiceitems {
        Invoiceitems(path: "/v1/invoiceitems")
    }

    public struct Invoiceitems {
        /// Path: `/v1/invoiceitems`
        public let path: String

        /// <p>Returns a list of your invoice items. Invoice items are returned sorted by creation date, with the most recently created invoice items appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Invoiceitem]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Invoiceitem], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var customer: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var invoice: String?
            public var limit: Int?
            public var isPending: Bool?
            public var startingAfter: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(created: Created? = nil, customer: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, invoice: String? = nil, limit: Int? = nil, isPending: Bool? = nil, startingAfter: String? = nil) {
                self.created = created
                self.customer = customer
                self.endingBefore = endingBefore
                self.expand = expand
                self.invoice = invoice
                self.limit = limit
                self.isPending = isPending
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(customer, forKey: "customer")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(invoice, forKey: "invoice")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(isPending, forKey: "pending")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates an item to be added to a draft invoice (up to 250 items per invoice). If no invoice is specified, the item will be on the next invoice created for the customer specified.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.Invoiceitem> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The integer amount in %s of the charge to be applied to the upcoming invoice. Passing in a negative `amount` will reduce the `amount_due` on the invoice.
            public var amount: Int?
            /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
            public var currency: String?
            /// The ID of the customer who will be billed when this invoice item is billed.
            public var customer: String
            /// An arbitrary string which you can attach to the invoice item. The description is displayed in the invoice for easy tracking.
            public var description: String?
            /// Controls whether discounts apply to this invoice item. Defaults to false for prorations or negative invoice items, and true for all other invoice items.
            public var isDiscountable: Bool?
            /// The coupons to redeem into discounts for the invoice item or invoice line item.
            public var discounts: Discounts?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The ID of an existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming scheduled invoice. This is useful when adding invoice items in response to an invoice.created webhook. You can only add invoice items to draft invoices and there is a maximum of 250 items per invoice.
            public var invoice: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The period associated with this invoice item.
            public var period: Period?
            /// The ID of the price object.
            public var price: String?
            /// One_time_price_data
            ///
            /// Data used to generate a new [Price](https://stripe.com/docs/api/prices) object inline.
            public var priceData: PriceData?
            /// Non-negative integer. The quantity of units for the invoice item.
            public var quantity: Int?
            /// The ID of a subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming scheduled invoice. When set, scheduled invoices for subscriptions other than the specified subscription will ignore the invoice item. Use this when you want to express that an invoice item has been accrued within the context of a particular subscription.
            public var subscription: String?
            /// The tax rates which apply to the invoice item. When set, the `default_tax_rates` on the invoice do not apply to this invoice item.
            public var taxRates: [String]?
            /// The integer unit amount in %s of the charge to be applied to the upcoming invoice. This `unit_amount` will be multiplied by the quantity to get the full amount. Passing in a negative `unit_amount` will reduce the `amount_due` on the invoice.
            public var unitAmount: Int?
            /// Same as `unit_amount`, but accepts a decimal value in %s with at most 12 decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
            public var unitAmountDecimal: String?

            /// The coupons to redeem into discounts for the invoice item or invoice line item.
            public struct Discounts: Encodable {
                public var placeholderItems: [PlaceholderItem]?
                public var object: Object?

                /// Discounts_data_param
                public struct PlaceholderItem: Encodable {
                    public var coupon: String?
                    public var discount: String?

                    public init(coupon: String? = nil, discount: String? = nil) {
                        self.coupon = coupon
                        self.discount = discount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(coupon, forKey: "coupon")
                        encoder.encode(discount, forKey: "discount")
                        return encoder.items
                    }
                }

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                    self.placeholderItems = placeholderItems
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(placeholderItems, forKey: "placeholderItems")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// The period associated with this invoice item.
            public struct Period: Encodable {
                public var end: Int
                public var start: Int

                public init(end: Int, start: Int) {
                    self.end = end
                    self.start = start
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(end, forKey: "end")
                    encoder.encode(start, forKey: "start")
                    return encoder.items
                }
            }

            /// One_time_price_data
            ///
            /// Data used to generate a new [Price](https://stripe.com/docs/api/prices) object inline.
            public struct PriceData: Encodable {
                public var currency: String
                public var product: String
                public var taxBehavior: TaxBehavior?
                public var unitAmount: Int?
                public var unitAmountDecimal: String?

                public enum TaxBehavior: String, Codable, CaseIterable {
                    case exclusive
                    case inclusive
                    case unspecified
                }

                public init(currency: String, product: String, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                    self.currency = currency
                    self.product = product
                    self.taxBehavior = taxBehavior
                    self.unitAmount = unitAmount
                    self.unitAmountDecimal = unitAmountDecimal
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(currency, forKey: "currency")
                    encoder.encode(product, forKey: "product")
                    encoder.encode(taxBehavior, forKey: "tax_behavior")
                    encoder.encode(unitAmount, forKey: "unit_amount")
                    encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                    return encoder.items
                }
            }

            public init(amount: Int? = nil, currency: String? = nil, customer: String, description: String? = nil, isDiscountable: Bool? = nil, discounts: Discounts? = nil, expand: [String]? = nil, invoice: String? = nil, metadata: Metadata? = nil, period: Period? = nil, price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, subscription: String? = nil, taxRates: [String]? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                self.amount = amount
                self.currency = currency
                self.customer = customer
                self.description = description
                self.isDiscountable = isDiscountable
                self.discounts = discounts
                self.expand = expand
                self.invoice = invoice
                self.metadata = metadata
                self.period = period
                self.price = price
                self.priceData = priceData
                self.quantity = quantity
                self.subscription = subscription
                self.taxRates = taxRates
                self.unitAmount = unitAmount
                self.unitAmountDecimal = unitAmountDecimal
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(description, forKey: "description")
                encoder.encode(isDiscountable, forKey: "discountable")
                encoder.encode(discounts, forKey: "discounts")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(invoice, forKey: "invoice")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(period, forKey: "period")
                encoder.encode(price, forKey: "price")
                encoder.encode(priceData, forKey: "price_data")
                encoder.encode(quantity, forKey: "quantity")
                encoder.encode(subscription, forKey: "subscription")
                encoder.encode(taxRates, forKey: "tax_rates")
                encoder.encode(unitAmount, forKey: "unit_amount")
                encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                return encoder.items
            }
        }
    }
}

extension Paths.Invoiceitems {
    public func invoiceitem(_ invoiceitem: String) -> WithInvoiceitem {
        WithInvoiceitem(path: "\(path)/\(invoiceitem)")
    }

    public struct WithInvoiceitem {
        /// Path: `/v1/invoiceitems/{invoiceitem}`
        public let path: String

        /// <p>Retrieves the invoice item with the given ID.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Invoiceitem> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the amount or description of an invoice item on an upcoming invoice. Updating an invoice item is only possible before the invoice it’s attached to is closed.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Invoiceitem> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The integer amount in %s of the charge to be applied to the upcoming invoice. If you want to apply a credit to the customer's account, pass a negative amount.
            public var amount: Int?
            /// An arbitrary string which you can attach to the invoice item. The description is displayed in the invoice for easy tracking.
            public var description: String?
            /// Controls whether discounts apply to this invoice item. Defaults to false for prorations or negative invoice items, and true for all other invoice items. Cannot be set to true for prorations.
            public var isDiscountable: Bool?
            /// The coupons & existing discounts which apply to the invoice item or invoice line item. Item discounts are applied before invoice discounts. Pass an empty string to remove previously-defined discounts.
            public var discounts: Discounts?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The period associated with this invoice item.
            public var period: Period?
            /// The ID of the price object.
            public var price: String?
            /// One_time_price_data
            ///
            /// Data used to generate a new [Price](https://stripe.com/docs/api/prices) object inline.
            public var priceData: PriceData?
            /// Non-negative integer. The quantity of units for the invoice item.
            public var quantity: Int?
            /// The tax rates which apply to the invoice item. When set, the `default_tax_rates` on the invoice do not apply to this invoice item. Pass an empty string to remove previously-defined tax rates.
            public var taxRates: TaxRates?
            /// The integer unit amount in %s of the charge to be applied to the upcoming invoice. This unit_amount will be multiplied by the quantity to get the full amount. If you want to apply a credit to the customer's account, pass a negative unit_amount.
            public var unitAmount: Int?
            /// Same as `unit_amount`, but accepts a decimal value in %s with at most 12 decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
            public var unitAmountDecimal: String?

            /// The coupons & existing discounts which apply to the invoice item or invoice line item. Item discounts are applied before invoice discounts. Pass an empty string to remove previously-defined discounts.
            public struct Discounts: Encodable {
                public var placeholderItems: [PlaceholderItem]?
                public var object: Object?

                /// Discounts_data_param
                public struct PlaceholderItem: Encodable {
                    public var coupon: String?
                    public var discount: String?

                    public init(coupon: String? = nil, discount: String? = nil) {
                        self.coupon = coupon
                        self.discount = discount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(coupon, forKey: "coupon")
                        encoder.encode(discount, forKey: "discount")
                        return encoder.items
                    }
                }

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                    self.placeholderItems = placeholderItems
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(placeholderItems, forKey: "placeholderItems")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// The period associated with this invoice item.
            public struct Period: Encodable {
                public var end: Int
                public var start: Int

                public init(end: Int, start: Int) {
                    self.end = end
                    self.start = start
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(end, forKey: "end")
                    encoder.encode(start, forKey: "start")
                    return encoder.items
                }
            }

            /// One_time_price_data
            ///
            /// Data used to generate a new [Price](https://stripe.com/docs/api/prices) object inline.
            public struct PriceData: Encodable {
                public var currency: String
                public var product: String
                public var taxBehavior: TaxBehavior?
                public var unitAmount: Int?
                public var unitAmountDecimal: String?

                public enum TaxBehavior: String, Codable, CaseIterable {
                    case exclusive
                    case inclusive
                    case unspecified
                }

                public init(currency: String, product: String, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                    self.currency = currency
                    self.product = product
                    self.taxBehavior = taxBehavior
                    self.unitAmount = unitAmount
                    self.unitAmountDecimal = unitAmountDecimal
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(currency, forKey: "currency")
                    encoder.encode(product, forKey: "product")
                    encoder.encode(taxBehavior, forKey: "tax_behavior")
                    encoder.encode(unitAmount, forKey: "unit_amount")
                    encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                    return encoder.items
                }
            }

            /// The tax rates which apply to the invoice item. When set, the `default_tax_rates` on the invoice do not apply to this invoice item. Pass an empty string to remove previously-defined tax rates.
            public struct TaxRates: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(amount: Int? = nil, description: String? = nil, isDiscountable: Bool? = nil, discounts: Discounts? = nil, expand: [String]? = nil, metadata: Metadata? = nil, period: Period? = nil, price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                self.amount = amount
                self.description = description
                self.isDiscountable = isDiscountable
                self.discounts = discounts
                self.expand = expand
                self.metadata = metadata
                self.period = period
                self.price = price
                self.priceData = priceData
                self.quantity = quantity
                self.taxRates = taxRates
                self.unitAmount = unitAmount
                self.unitAmountDecimal = unitAmountDecimal
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(description, forKey: "description")
                encoder.encode(isDiscountable, forKey: "discountable")
                encoder.encode(discounts, forKey: "discounts")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(period, forKey: "period")
                encoder.encode(price, forKey: "price")
                encoder.encode(priceData, forKey: "price_data")
                encoder.encode(quantity, forKey: "quantity")
                encoder.encode(taxRates, forKey: "tax_rates")
                encoder.encode(unitAmount, forKey: "unit_amount")
                encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                return encoder.items
            }
        }

        /// <p>Deletes an invoice item, removing it from an invoice. Deleting invoice items is only possible when they’re not attached to invoices, or if it’s attached to a draft invoice.</p>
        public var delete: Request<StripeAPI.DeletedInvoiceitem> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var invoices: Invoices {
        Invoices(path: "/v1/invoices")
    }

    public struct Invoices {
        /// Path: `/v1/invoices`
        public let path: String

        /// <p>You can list all invoices, or list the invoices for a specific customer. The invoices are returned sorted by creation date, with the most recently created invoices appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// InvoicesList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Invoice]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Invoice], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var collectionMethod: CollectionMethod?
            public var created: Created?
            public var customer: String?
            public var dueDate: DueDate?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?
            public var status: Status?
            public var subscription: String?

            public enum CollectionMethod: String, Codable, CaseIterable {
                case chargeAutomatically = "charge_automatically"
                case sendInvoice = "send_invoice"
            }

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public struct DueDate: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public enum Status: String, Codable, CaseIterable {
                case draft
                case `open`
                case paid
                case uncollectible
                case void
            }

            public init(collectionMethod: CollectionMethod? = nil, created: Created? = nil, customer: String? = nil, dueDate: DueDate? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil, status: Status? = nil, subscription: String? = nil) {
                self.collectionMethod = collectionMethod
                self.created = created
                self.customer = customer
                self.dueDate = dueDate
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
                self.status = status
                self.subscription = subscription
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(collectionMethod, forKey: "collection_method")
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(customer, forKey: "customer")
                encoder.encode(dueDate, forKey: "due_date", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(status, forKey: "status")
                encoder.encode(subscription, forKey: "subscription")
                return encoder.items
            }
        }

        /// <p>This endpoint creates a draft invoice for a given customer. The draft invoice created pulls in all pending invoice items on that customer, including prorations. The invoice remains a draft until you <a href="#finalize_invoice">finalize</a> the invoice, which allows you to <a href="#pay_invoice">pay</a> or <a href="#send_invoice">send</a> the invoice to your customers.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.Invoice> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The account tax IDs associated with the invoice. Only editable when the invoice is a draft.
            public var accountTaxIDs: AccountTaxIDs?
            /// A fee in %s that will be applied to the invoice and transferred to the application owner's Stripe account. The request must be made with an OAuth key or the Stripe-Account header in order to take an application fee. For more information, see the application fees [documentation](https://stripe.com/docs/billing/invoices/connect#collecting-fees).
            public var applicationFeeAmount: Int?
            /// Controls whether Stripe will perform [automatic collection](https://stripe.com/docs/billing/invoices/workflow/#auto_advance) of the invoice. When `false`, the invoice's state will not automatically advance without an explicit action.
            public var isAutoAdvance: Bool?
            /// Automatic_tax_param
            ///
            /// Settings for automatic tax lookup for this invoice.
            public var automaticTax: AutomaticTax?
            /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this invoice using the default source attached to the customer. When sending an invoice, Stripe will email this invoice to the customer with payment instructions. Defaults to `charge_automatically`.
            public var collectionMethod: CollectionMethod?
            /// A list of up to 4 custom fields to be displayed on the invoice.
            public var customFields: CustomFields?
            /// The ID of the customer who will be billed.
            public var customer: String
            /// The number of days from when the invoice is created until it is due. Valid only for invoices where `collection_method=send_invoice`.
            public var daysUntilDue: Int?
            /// ID of the default payment method for the invoice. It must belong to the customer associated with the invoice. If not set, defaults to the subscription's default payment method, if any, or to the default payment method in the customer's invoice settings.
            public var defaultPaymentMethod: String?
            /// ID of the default payment source for the invoice. It must belong to the customer associated with the invoice and be in a chargeable state. If not set, defaults to the subscription's default source, if any, or to the customer's default source.
            public var defaultSource: String?
            /// The tax rates that will apply to any line item that does not have `tax_rates` set.
            public var defaultTaxRates: [String]?
            /// An arbitrary string attached to the object. Often useful for displaying to users. Referenced as 'memo' in the Dashboard.
            public var description: String?
            /// The coupons to redeem into discounts for the invoice. If not specified, inherits the discount from the invoice's customer. Pass an empty string to avoid inheriting any discounts.
            public var discounts: Discounts?
            /// The date on which payment for this invoice is due. Valid only for invoices where `collection_method=send_invoice`.
            public var dueDate: Int?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Footer to be displayed on the invoice.
            public var footer: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The account (if any) for which the funds of the invoice payment are intended. If set, the invoice will be presented with the branding and support information of the specified account. See the [Invoices with Connect](https://stripe.com/docs/billing/invoices/connect) documentation for details.
            public var onBehalfOf: String?
            /// Payment_settings
            ///
            /// Configuration settings for the PaymentIntent that is generated when the invoice is finalized.
            public var paymentSettings: PaymentSettings?
            /// Extra information about a charge for the customer's credit card statement. It must contain at least one letter. If not specified and this invoice is part of a subscription, the default `statement_descriptor` will be set to the first subscription item's product's `statement_descriptor`.
            public var statementDescriptor: String?
            /// The ID of the subscription to invoice, if any. If not set, the created invoice will include all pending invoice items for the customer. If set, the created invoice will only include pending invoice items for that subscription and pending invoice items not associated with any subscription. The subscription's billing cycle and regular subscription events won't be affected.
            public var subscription: String?
            /// Transfer_data_specs
            ///
            /// If specified, the funds from the invoice will be transferred to the destination and the ID of the resulting transfer will be found on the invoice's charge.
            public var transferData: TransferData?

            /// The account tax IDs associated with the invoice. Only editable when the invoice is a draft.
            public struct AccountTaxIDs: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Automatic_tax_param
            ///
            /// Settings for automatic tax lookup for this invoice.
            public struct AutomaticTax: Encodable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this invoice using the default source attached to the customer. When sending an invoice, Stripe will email this invoice to the customer with payment instructions. Defaults to `charge_automatically`.
            public enum CollectionMethod: String, Codable, CaseIterable {
                case chargeAutomatically = "charge_automatically"
                case sendInvoice = "send_invoice"
            }

            /// A list of up to 4 custom fields to be displayed on the invoice.
            public struct CustomFields: Encodable {
                public var placeholderItems: [PlaceholderItem]?
                public var object: Object?

                /// Custom_field_params
                public struct PlaceholderItem: Encodable {
                    public var name: String
                    public var value: String

                    public init(name: String, value: String) {
                        self.name = name
                        self.value = value
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(name, forKey: "name")
                        encoder.encode(value, forKey: "value")
                        return encoder.items
                    }
                }

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                    self.placeholderItems = placeholderItems
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(placeholderItems, forKey: "placeholderItems")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// The coupons to redeem into discounts for the invoice. If not specified, inherits the discount from the invoice's customer. Pass an empty string to avoid inheriting any discounts.
            public struct Discounts: Encodable {
                public var placeholderItems: [PlaceholderItem]?
                public var object: Object?

                /// Discounts_data_param
                public struct PlaceholderItem: Encodable {
                    public var coupon: String?
                    public var discount: String?

                    public init(coupon: String? = nil, discount: String? = nil) {
                        self.coupon = coupon
                        self.discount = discount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(coupon, forKey: "coupon")
                        encoder.encode(discount, forKey: "discount")
                        return encoder.items
                    }
                }

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                    self.placeholderItems = placeholderItems
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(placeholderItems, forKey: "placeholderItems")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Payment_settings
            ///
            /// Configuration settings for the PaymentIntent that is generated when the invoice is finalized.
            public struct PaymentSettings: Encodable {
                /// Payment_method_options
                public var paymentMethodOptions: PaymentMethodOptions?
                public var paymentMethodTypes: PaymentMethodTypes?

                /// Payment_method_options
                public struct PaymentMethodOptions: Encodable {
                    public var acssDebit: AcssDebit?
                    public var bancontact: Bancontact?
                    public var card: Card?

                    public struct AcssDebit: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            /// Mandate_options_param
                            public var mandateOptions: MandateOptions?
                            public var verificationMethod: VerificationMethod?

                            /// Mandate_options_param
                            public struct MandateOptions: Encodable {
                                public var transactionType: TransactionType?

                                public enum TransactionType: String, Codable, CaseIterable {
                                    case business
                                    case personal
                                }

                                public init(transactionType: TransactionType? = nil) {
                                    self.transactionType = transactionType
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(transactionType, forKey: "transaction_type")
                                    return encoder.items
                                }
                            }

                            public enum VerificationMethod: String, Codable, CaseIterable {
                                case automatic
                                case instant
                                case microdeposits
                            }

                            public init(mandateOptions: MandateOptions? = nil, verificationMethod: VerificationMethod? = nil) {
                                self.mandateOptions = mandateOptions
                                self.verificationMethod = verificationMethod
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(mandateOptions, forKey: "mandate_options")
                                encoder.encode(verificationMethod, forKey: "verification_method")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct Bancontact: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            public var preferredLanguage: PreferredLanguage?

                            public enum PreferredLanguage: String, Codable, CaseIterable {
                                case de
                                case en
                                case fr
                                case nl
                            }

                            public init(preferredLanguage: PreferredLanguage? = nil) {
                                self.preferredLanguage = preferredLanguage
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(preferredLanguage, forKey: "preferred_language")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct Card: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            public var requestThreeDSecure: RequestThreeDSecure?

                            public enum RequestThreeDSecure: String, Codable, CaseIterable {
                                case any
                                case automatic
                            }

                            public init(requestThreeDSecure: RequestThreeDSecure? = nil) {
                                self.requestThreeDSecure = requestThreeDSecure
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(requestThreeDSecure, forKey: "request_three_d_secure")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public init(acssDebit: AcssDebit? = nil, bancontact: Bancontact? = nil, card: Card? = nil) {
                        self.acssDebit = acssDebit
                        self.bancontact = bancontact
                        self.card = card
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(acssDebit, forKey: "acss_debit")
                        encoder.encode(bancontact, forKey: "bancontact")
                        encoder.encode(card, forKey: "card")
                        return encoder.items
                    }
                }

                public struct PaymentMethodTypes: Encodable {
                    public var placeholderItems: [PlaceholderItem]?
                    public var object: Object?

                    public enum PlaceholderItem: String, Codable, CaseIterable {
                        case achCreditTransfer = "ach_credit_transfer"
                        case achDebit = "ach_debit"
                        case acssDebit = "acss_debit"
                        case auBecsDebit = "au_becs_debit"
                        case bacsDebit = "bacs_debit"
                        case bancontact
                        case boleto
                        case card
                        case fpx
                        case giropay
                        case ideal
                        case sepaDebit = "sepa_debit"
                        case sofort
                        case wechatPay = "wechat_pay"
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                        self.placeholderItems = placeholderItems
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(placeholderItems, forKey: "placeholderItems")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(paymentMethodOptions: PaymentMethodOptions? = nil, paymentMethodTypes: PaymentMethodTypes? = nil) {
                    self.paymentMethodOptions = paymentMethodOptions
                    self.paymentMethodTypes = paymentMethodTypes
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(paymentMethodOptions, forKey: "payment_method_options")
                    encoder.encode(paymentMethodTypes, forKey: "payment_method_types")
                    return encoder.items
                }
            }

            /// Transfer_data_specs
            ///
            /// If specified, the funds from the invoice will be transferred to the destination and the ID of the resulting transfer will be found on the invoice's charge.
            public struct TransferData: Encodable {
                public var amount: Int?
                public var destination: String

                public init(amount: Int? = nil, destination: String) {
                    self.amount = amount
                    self.destination = destination
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(amount, forKey: "amount")
                    encoder.encode(destination, forKey: "destination")
                    return encoder.items
                }
            }

            public init(accountTaxIDs: AccountTaxIDs? = nil, applicationFeeAmount: Int? = nil, isAutoAdvance: Bool? = nil, automaticTax: AutomaticTax? = nil, collectionMethod: CollectionMethod? = nil, customFields: CustomFields? = nil, customer: String, daysUntilDue: Int? = nil, defaultPaymentMethod: String? = nil, defaultSource: String? = nil, defaultTaxRates: [String]? = nil, description: String? = nil, discounts: Discounts? = nil, dueDate: Int? = nil, expand: [String]? = nil, footer: String? = nil, metadata: Metadata? = nil, onBehalfOf: String? = nil, paymentSettings: PaymentSettings? = nil, statementDescriptor: String? = nil, subscription: String? = nil, transferData: TransferData? = nil) {
                self.accountTaxIDs = accountTaxIDs
                self.applicationFeeAmount = applicationFeeAmount
                self.isAutoAdvance = isAutoAdvance
                self.automaticTax = automaticTax
                self.collectionMethod = collectionMethod
                self.customFields = customFields
                self.customer = customer
                self.daysUntilDue = daysUntilDue
                self.defaultPaymentMethod = defaultPaymentMethod
                self.defaultSource = defaultSource
                self.defaultTaxRates = defaultTaxRates
                self.description = description
                self.discounts = discounts
                self.dueDate = dueDate
                self.expand = expand
                self.footer = footer
                self.metadata = metadata
                self.onBehalfOf = onBehalfOf
                self.paymentSettings = paymentSettings
                self.statementDescriptor = statementDescriptor
                self.subscription = subscription
                self.transferData = transferData
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(accountTaxIDs, forKey: "account_tax_ids")
                encoder.encode(applicationFeeAmount, forKey: "application_fee_amount")
                encoder.encode(isAutoAdvance, forKey: "auto_advance")
                encoder.encode(automaticTax, forKey: "automatic_tax")
                encoder.encode(collectionMethod, forKey: "collection_method")
                encoder.encode(customFields, forKey: "custom_fields")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(daysUntilDue, forKey: "days_until_due")
                encoder.encode(defaultPaymentMethod, forKey: "default_payment_method")
                encoder.encode(defaultSource, forKey: "default_source")
                encoder.encode(defaultTaxRates, forKey: "default_tax_rates")
                encoder.encode(description, forKey: "description")
                encoder.encode(discounts, forKey: "discounts")
                encoder.encode(dueDate, forKey: "due_date")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(footer, forKey: "footer")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(onBehalfOf, forKey: "on_behalf_of")
                encoder.encode(paymentSettings, forKey: "payment_settings")
                encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                encoder.encode(subscription, forKey: "subscription")
                encoder.encode(transferData, forKey: "transfer_data")
                return encoder.items
            }
        }
    }
}

extension Paths.Invoices {
    public var upcoming: Upcoming {
        Upcoming(path: path + "/upcoming")
    }

    public struct Upcoming {
        /// Path: `/v1/invoices/upcoming`
        public let path: String

        /// <p>At any time, you can preview the upcoming invoice for a customer. This will show you all the charges that are pending, including subscription renewal charges, invoice item charges, etc. It will also show you any discounts that are applicable to the invoice.</p>
        /// 
        /// <p>Note that when you are viewing an upcoming invoice, you are simply viewing a preview – the invoice has not yet been created. As such, the upcoming invoice will not show up in invoice listing calls, and you cannot use the API to pay or edit the invoice. If you want to change the amount that your customer will be billed, you can add, remove, or update pending invoice items, or update the customer’s discount.</p>
        /// 
        /// <p>You can preview the effects of updating a subscription, including a preview of what proration will take place. To ensure that the actual proration is calculated exactly the same as the previewed proration, you should pass a <code>proration_date</code> parameter when doing the actual subscription update. The value passed in should be the same as the <code>subscription_proration_date</code> returned on the upcoming invoice resource. The recommended way to get only the prorations being previewed is to consider only proration line items where <code>period[start]</code> is equal to the <code>subscription_proration_date</code> on the upcoming invoice resource.</p>
        public func get(parameters: GetParameters? = nil) -> Request<StripeAPI.Invoice> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// Automatic_tax_param
            public var automaticTax: AutomaticTax?
            public var coupon: String?
            public var customer: String?
            /// Customer_details_param
            public var customerDetails: CustomerDetails?
            public var discounts: Discounts?
            public var expand: [String]?
            public var invoiceItems: [InvoiceItems]?
            public var schedule: String?
            public var subscription: String?
            public var subscriptionBillingCycleAnchor: SubscriptionBillingCycleAnchor?
            public var subscriptionCancelAt: SubscriptionCancelAt?
            public var isSubscriptionCancelAtPeriodEnd: Bool?
            public var isSubscriptionCancelNow: Bool?
            public var subscriptionDefaultTaxRates: SubscriptionDefaultTaxRates?
            public var subscriptionItems: [SubscriptionItems]?
            public var subscriptionProrationBehavior: SubscriptionProrationBehavior?
            public var subscriptionProrationDate: Int?
            public var subscriptionStartDate: Int?
            public var subscriptionTrialEnd: SubscriptionTrialEnd?
            public var isSubscriptionTrialFromPlan: Bool?

            /// Automatic_tax_param
            public struct AutomaticTax: Codable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Customer_details_param
            public struct CustomerDetails: Codable {
                public var address: Address?
                public var shipping: Shipping?
                /// Tax_param
                public var tax: Tax?
                public var taxExempt: TaxExempt?
                public var taxIDs: [TaxID]?

                public struct Address: Codable {
                    /// Optional_fields_address
                    public var a: A?
                    public var b: B?

                    /// Optional_fields_address
                    public struct A: Codable {
                        public var city: String?
                        public var country: String?
                        public var line1: String?
                        public var line2: String?
                        public var postalCode: String?
                        public var state: String?

                        public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                            self.city = city
                            self.country = country
                            self.line1 = line1
                            self.line2 = line2
                            self.postalCode = postalCode
                            self.state = state
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(city, forKey: "city")
                            encoder.encode(country, forKey: "country")
                            encoder.encode(line1, forKey: "line1")
                            encoder.encode(line2, forKey: "line2")
                            encoder.encode(postalCode, forKey: "postal_code")
                            encoder.encode(state, forKey: "state")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Shipping: Codable {
                    /// Customer_shipping
                    public var a: A?
                    public var b: B?

                    /// Customer_shipping
                    public struct A: Codable {
                        /// Optional_fields_address
                        public var address: Address
                        public var name: String
                        public var phone: String?

                        /// Optional_fields_address
                        public struct Address: Codable {
                            public var city: String?
                            public var country: String?
                            public var line1: String?
                            public var line2: String?
                            public var postalCode: String?
                            public var state: String?

                            public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                                self.city = city
                                self.country = country
                                self.line1 = line1
                                self.line2 = line2
                                self.postalCode = postalCode
                                self.state = state
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(city, forKey: "city")
                                encoder.encode(country, forKey: "country")
                                encoder.encode(line1, forKey: "line1")
                                encoder.encode(line2, forKey: "line2")
                                encoder.encode(postalCode, forKey: "postal_code")
                                encoder.encode(state, forKey: "state")
                                return encoder.items
                            }
                        }

                        public init(address: Address, name: String, phone: String? = nil) {
                            self.address = address
                            self.name = name
                            self.phone = phone
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(address, forKey: "address")
                            encoder.encode(name, forKey: "name")
                            encoder.encode(phone, forKey: "phone")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                /// Tax_param
                public struct Tax: Codable {
                    public var ipAddress: IpAddress?

                    public struct IpAddress: Codable {
                        public var string: String?
                        public var object: Object?

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(string: String? = nil, object: Object? = nil) {
                            self.string = string
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(string, forKey: "string")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public init(ipAddress: IpAddress? = nil) {
                        self.ipAddress = ipAddress
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(ipAddress, forKey: "ip_address")
                        return encoder.items
                    }
                }

                public enum TaxExempt: String, Codable, CaseIterable {
                    case empty = ""
                    case exempt
                    case `none`
                    case reverse
                }

                /// Data_params
                public struct TaxID: Codable {
                    public var type: `Type`
                    public var value: String

                    public enum `Type`: String, Codable, CaseIterable {
                        case aeTrn = "ae_trn"
                        case auAbn = "au_abn"
                        case auArn = "au_arn"
                        case brCnpj = "br_cnpj"
                        case brCpf = "br_cpf"
                        case caBn = "ca_bn"
                        case caGstHst = "ca_gst_hst"
                        case caPstBc = "ca_pst_bc"
                        case caPstMb = "ca_pst_mb"
                        case caPstSk = "ca_pst_sk"
                        case caQst = "ca_qst"
                        case chVat = "ch_vat"
                        case clTin = "cl_tin"
                        case esCif = "es_cif"
                        case euVat = "eu_vat"
                        case gbVat = "gb_vat"
                        case geVat = "ge_vat"
                        case hkBr = "hk_br"
                        case idNpwp = "id_npwp"
                        case ilVat = "il_vat"
                        case inGst = "in_gst"
                        case jpCn = "jp_cn"
                        case jpRn = "jp_rn"
                        case krBrn = "kr_brn"
                        case liUid = "li_uid"
                        case mxRfc = "mx_rfc"
                        case myFrp = "my_frp"
                        case myItn = "my_itn"
                        case mySst = "my_sst"
                        case noVat = "no_vat"
                        case nzGst = "nz_gst"
                        case ruInn = "ru_inn"
                        case ruKpp = "ru_kpp"
                        case saVat = "sa_vat"
                        case sgGst = "sg_gst"
                        case sgUen = "sg_uen"
                        case thVat = "th_vat"
                        case twVat = "tw_vat"
                        case uaVat = "ua_vat"
                        case usEin = "us_ein"
                        case zaVat = "za_vat"
                    }

                    public init(type: `Type`, value: String) {
                        self.type = type
                        self.value = value
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(type, forKey: "type")
                        encoder.encode(value, forKey: "value")
                        return encoder.items
                    }
                }

                public init(address: Address? = nil, shipping: Shipping? = nil, tax: Tax? = nil, taxExempt: TaxExempt? = nil, taxIDs: [TaxID]? = nil) {
                    self.address = address
                    self.shipping = shipping
                    self.tax = tax
                    self.taxExempt = taxExempt
                    self.taxIDs = taxIDs
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(shipping, forKey: "shipping")
                    encoder.encode(tax, forKey: "tax")
                    encoder.encode(taxExempt, forKey: "tax_exempt")
                    encoder.encode(taxIDs, forKey: "tax_ids")
                    return encoder.items
                }
            }

            public struct Discounts: Codable {
                public var placeholderItems: [PlaceholderItem]?
                public var object: Object?

                /// Discounts_data_param
                public struct PlaceholderItem: Codable {
                    public var coupon: String?
                    public var discount: String?

                    public init(coupon: String? = nil, discount: String? = nil) {
                        self.coupon = coupon
                        self.discount = discount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(coupon, forKey: "coupon")
                        encoder.encode(discount, forKey: "discount")
                        return encoder.items
                    }
                }

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                    self.placeholderItems = placeholderItems
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(placeholderItems, forKey: "placeholderItems")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Invoice_item_preview_params
            public struct InvoiceItems: Codable {
                public var amount: Int?
                public var currency: String?
                public var description: String?
                public var isDiscountable: Bool?
                public var discounts: Discounts?
                public var invoiceitem: String?
                public var metadata: Metadata?
                public var period: Period?
                public var price: String?
                /// One_time_price_data
                public var priceData: PriceData?
                public var quantity: Int?
                public var taxRates: TaxRates?
                public var unitAmount: Int?
                public var unitAmountDecimal: String?

                public struct Discounts: Codable {
                    public var placeholderItems: [PlaceholderItem]?
                    public var object: Object?

                    /// Discounts_data_param
                    public struct PlaceholderItem: Codable {
                        public var coupon: String?
                        public var discount: String?

                        public init(coupon: String? = nil, discount: String? = nil) {
                            self.coupon = coupon
                            self.discount = discount
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(coupon, forKey: "coupon")
                            encoder.encode(discount, forKey: "discount")
                            return encoder.items
                        }
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                        self.placeholderItems = placeholderItems
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(placeholderItems, forKey: "placeholderItems")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public struct Metadata: Codable {
                    public var stringString: [String: String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(stringString: [String: String]? = nil, object: Object? = nil) {
                        self.stringString = stringString
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(stringString, forKey: "stringString")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public struct Period: Codable {
                    public var end: Int
                    public var start: Int

                    public init(end: Int, start: Int) {
                        self.end = end
                        self.start = start
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(end, forKey: "end")
                        encoder.encode(start, forKey: "start")
                        return encoder.items
                    }
                }

                /// One_time_price_data
                public struct PriceData: Codable {
                    public var currency: String
                    public var product: String
                    public var taxBehavior: TaxBehavior?
                    public var unitAmount: Int?
                    public var unitAmountDecimal: String?

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public init(currency: String, product: String, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                        self.currency = currency
                        self.product = product
                        self.taxBehavior = taxBehavior
                        self.unitAmount = unitAmount
                        self.unitAmountDecimal = unitAmountDecimal
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(product, forKey: "product")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(unitAmount, forKey: "unit_amount")
                        encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                        return encoder.items
                    }
                }

                public struct TaxRates: Codable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(amount: Int? = nil, currency: String? = nil, description: String? = nil, isDiscountable: Bool? = nil, discounts: Discounts? = nil, invoiceitem: String? = nil, metadata: Metadata? = nil, period: Period? = nil, price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                    self.amount = amount
                    self.currency = currency
                    self.description = description
                    self.isDiscountable = isDiscountable
                    self.discounts = discounts
                    self.invoiceitem = invoiceitem
                    self.metadata = metadata
                    self.period = period
                    self.price = price
                    self.priceData = priceData
                    self.quantity = quantity
                    self.taxRates = taxRates
                    self.unitAmount = unitAmount
                    self.unitAmountDecimal = unitAmountDecimal
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(amount, forKey: "amount")
                    encoder.encode(currency, forKey: "currency")
                    encoder.encode(description, forKey: "description")
                    encoder.encode(isDiscountable, forKey: "discountable")
                    encoder.encode(discounts, forKey: "discounts")
                    encoder.encode(invoiceitem, forKey: "invoiceitem")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(period, forKey: "period")
                    encoder.encode(price, forKey: "price")
                    encoder.encode(priceData, forKey: "price_data")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    encoder.encode(unitAmount, forKey: "unit_amount")
                    encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                    return encoder.items
                }
            }

            public struct SubscriptionBillingCycleAnchor: Codable {
                public var object: Object?
                public var int: Int?

                public enum Object: String, Codable, CaseIterable {
                    case now
                    case unchanged
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public struct SubscriptionCancelAt: Codable {
                public var int: Int?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(int: Int? = nil, object: Object? = nil) {
                    self.int = int
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(int, forKey: "int")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public struct SubscriptionDefaultTaxRates: Codable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Subscription_item_update_params
            public struct SubscriptionItems: Codable {
                public var billingThresholds: BillingThresholds?
                public var isClearUsage: Bool?
                public var isDeleted: Bool?
                public var id: String?
                public var metadata: Metadata?
                public var price: String?
                /// Recurring_price_data
                public var priceData: PriceData?
                public var quantity: Int?
                public var taxRates: TaxRates?

                public struct BillingThresholds: Codable {
                    /// Item_billing_thresholds_param
                    public var a: A?
                    public var b: B?

                    /// Item_billing_thresholds_param
                    public struct A: Codable {
                        public var usageGte: Int

                        public init(usageGte: Int) {
                            self.usageGte = usageGte
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(usageGte, forKey: "usage_gte")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Metadata: Codable {
                    public var stringString: [String: String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(stringString: [String: String]? = nil, object: Object? = nil) {
                        self.stringString = stringString
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(stringString, forKey: "stringString")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                /// Recurring_price_data
                public struct PriceData: Codable {
                    public var currency: String
                    public var product: String
                    /// Recurring_adhoc
                    public var recurring: Recurring
                    public var taxBehavior: TaxBehavior?
                    public var unitAmount: Int?
                    public var unitAmountDecimal: String?

                    /// Recurring_adhoc
                    public struct Recurring: Codable {
                        public var interval: Interval
                        public var intervalCount: Int?

                        public enum Interval: String, Codable, CaseIterable {
                            case day
                            case month
                            case week
                            case year
                        }

                        public init(interval: Interval, intervalCount: Int? = nil) {
                            self.interval = interval
                            self.intervalCount = intervalCount
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(interval, forKey: "interval")
                            encoder.encode(intervalCount, forKey: "interval_count")
                            return encoder.items
                        }
                    }

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public init(currency: String, product: String, recurring: Recurring, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                        self.currency = currency
                        self.product = product
                        self.recurring = recurring
                        self.taxBehavior = taxBehavior
                        self.unitAmount = unitAmount
                        self.unitAmountDecimal = unitAmountDecimal
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(product, forKey: "product")
                        encoder.encode(recurring, forKey: "recurring")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(unitAmount, forKey: "unit_amount")
                        encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                        return encoder.items
                    }
                }

                public struct TaxRates: Codable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(billingThresholds: BillingThresholds? = nil, isClearUsage: Bool? = nil, isDeleted: Bool? = nil, id: String? = nil, metadata: Metadata? = nil, price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                    self.billingThresholds = billingThresholds
                    self.isClearUsage = isClearUsage
                    self.isDeleted = isDeleted
                    self.id = id
                    self.metadata = metadata
                    self.price = price
                    self.priceData = priceData
                    self.quantity = quantity
                    self.taxRates = taxRates
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(billingThresholds, forKey: "billing_thresholds")
                    encoder.encode(isClearUsage, forKey: "clear_usage")
                    encoder.encode(isDeleted, forKey: "deleted")
                    encoder.encode(id, forKey: "id")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(price, forKey: "price")
                    encoder.encode(priceData, forKey: "price_data")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    return encoder.items
                }
            }

            public enum SubscriptionProrationBehavior: String, Codable, CaseIterable {
                case alwaysInvoice = "always_invoice"
                case createProrations = "create_prorations"
                case `none`
            }

            public struct SubscriptionTrialEnd: Codable {
                public var object: Object?
                public var int: Int?

                public enum Object: String, Codable, CaseIterable {
                    case now
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(automaticTax: AutomaticTax? = nil, coupon: String? = nil, customer: String? = nil, customerDetails: CustomerDetails? = nil, discounts: Discounts? = nil, expand: [String]? = nil, invoiceItems: [InvoiceItems]? = nil, schedule: String? = nil, subscription: String? = nil, subscriptionBillingCycleAnchor: SubscriptionBillingCycleAnchor? = nil, subscriptionCancelAt: SubscriptionCancelAt? = nil, isSubscriptionCancelAtPeriodEnd: Bool? = nil, isSubscriptionCancelNow: Bool? = nil, subscriptionDefaultTaxRates: SubscriptionDefaultTaxRates? = nil, subscriptionItems: [SubscriptionItems]? = nil, subscriptionProrationBehavior: SubscriptionProrationBehavior? = nil, subscriptionProrationDate: Int? = nil, subscriptionStartDate: Int? = nil, subscriptionTrialEnd: SubscriptionTrialEnd? = nil, isSubscriptionTrialFromPlan: Bool? = nil) {
                self.automaticTax = automaticTax
                self.coupon = coupon
                self.customer = customer
                self.customerDetails = customerDetails
                self.discounts = discounts
                self.expand = expand
                self.invoiceItems = invoiceItems
                self.schedule = schedule
                self.subscription = subscription
                self.subscriptionBillingCycleAnchor = subscriptionBillingCycleAnchor
                self.subscriptionCancelAt = subscriptionCancelAt
                self.isSubscriptionCancelAtPeriodEnd = isSubscriptionCancelAtPeriodEnd
                self.isSubscriptionCancelNow = isSubscriptionCancelNow
                self.subscriptionDefaultTaxRates = subscriptionDefaultTaxRates
                self.subscriptionItems = subscriptionItems
                self.subscriptionProrationBehavior = subscriptionProrationBehavior
                self.subscriptionProrationDate = subscriptionProrationDate
                self.subscriptionStartDate = subscriptionStartDate
                self.subscriptionTrialEnd = subscriptionTrialEnd
                self.isSubscriptionTrialFromPlan = isSubscriptionTrialFromPlan
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(automaticTax, forKey: "automatic_tax", isDeepObject: true)
                encoder.encode(coupon, forKey: "coupon")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(customerDetails, forKey: "customer_details", isDeepObject: true)
                encoder.encode(discounts, forKey: "discounts", isDeepObject: true)
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(invoiceItems, forKey: "invoice_items", isDeepObject: true)
                encoder.encode(schedule, forKey: "schedule")
                encoder.encode(subscription, forKey: "subscription")
                encoder.encode(subscriptionBillingCycleAnchor, forKey: "subscription_billing_cycle_anchor", isDeepObject: true)
                encoder.encode(subscriptionCancelAt, forKey: "subscription_cancel_at", isDeepObject: true)
                encoder.encode(isSubscriptionCancelAtPeriodEnd, forKey: "subscription_cancel_at_period_end")
                encoder.encode(isSubscriptionCancelNow, forKey: "subscription_cancel_now")
                encoder.encode(subscriptionDefaultTaxRates, forKey: "subscription_default_tax_rates", isDeepObject: true)
                encoder.encode(subscriptionItems, forKey: "subscription_items", isDeepObject: true)
                encoder.encode(subscriptionProrationBehavior, forKey: "subscription_proration_behavior")
                encoder.encode(subscriptionProrationDate, forKey: "subscription_proration_date")
                encoder.encode(subscriptionStartDate, forKey: "subscription_start_date")
                encoder.encode(subscriptionTrialEnd, forKey: "subscription_trial_end", isDeepObject: true)
                encoder.encode(isSubscriptionTrialFromPlan, forKey: "subscription_trial_from_plan")
                return encoder.items
            }
        }
    }
}

extension Paths.Invoices.Upcoming {
    public var lines: Lines {
        Lines(path: path + "/lines")
    }

    public struct Lines {
        /// Path: `/v1/invoices/upcoming/lines`
        public let path: String

        /// <p>When retrieving an upcoming invoice, you’ll get a <strong>lines</strong> property containing the total count of line items and the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// InvoiceLinesList
        public struct GetResponse: Decodable {
            /// Details about each object.
            public var data: [StripeAPI.LineItem]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.LineItem], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            /// Automatic_tax_param
            public var automaticTax: AutomaticTax?
            public var coupon: String?
            public var customer: String?
            /// Customer_details_param
            public var customerDetails: CustomerDetails?
            public var discounts: Discounts?
            public var endingBefore: String?
            public var expand: [String]?
            public var invoiceItems: [InvoiceItems]?
            public var limit: Int?
            public var schedule: String?
            public var startingAfter: String?
            public var subscription: String?
            public var subscriptionBillingCycleAnchor: SubscriptionBillingCycleAnchor?
            public var subscriptionCancelAt: SubscriptionCancelAt?
            public var isSubscriptionCancelAtPeriodEnd: Bool?
            public var isSubscriptionCancelNow: Bool?
            public var subscriptionDefaultTaxRates: SubscriptionDefaultTaxRates?
            public var subscriptionItems: [SubscriptionItems]?
            public var subscriptionProrationBehavior: SubscriptionProrationBehavior?
            public var subscriptionProrationDate: Int?
            public var subscriptionStartDate: Int?
            public var subscriptionTrialEnd: SubscriptionTrialEnd?
            public var isSubscriptionTrialFromPlan: Bool?

            /// Automatic_tax_param
            public struct AutomaticTax: Codable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Customer_details_param
            public struct CustomerDetails: Codable {
                public var address: Address?
                public var shipping: Shipping?
                /// Tax_param
                public var tax: Tax?
                public var taxExempt: TaxExempt?
                public var taxIDs: [TaxID]?

                public struct Address: Codable {
                    /// Optional_fields_address
                    public var a: A?
                    public var b: B?

                    /// Optional_fields_address
                    public struct A: Codable {
                        public var city: String?
                        public var country: String?
                        public var line1: String?
                        public var line2: String?
                        public var postalCode: String?
                        public var state: String?

                        public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                            self.city = city
                            self.country = country
                            self.line1 = line1
                            self.line2 = line2
                            self.postalCode = postalCode
                            self.state = state
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(city, forKey: "city")
                            encoder.encode(country, forKey: "country")
                            encoder.encode(line1, forKey: "line1")
                            encoder.encode(line2, forKey: "line2")
                            encoder.encode(postalCode, forKey: "postal_code")
                            encoder.encode(state, forKey: "state")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Shipping: Codable {
                    /// Customer_shipping
                    public var a: A?
                    public var b: B?

                    /// Customer_shipping
                    public struct A: Codable {
                        /// Optional_fields_address
                        public var address: Address
                        public var name: String
                        public var phone: String?

                        /// Optional_fields_address
                        public struct Address: Codable {
                            public var city: String?
                            public var country: String?
                            public var line1: String?
                            public var line2: String?
                            public var postalCode: String?
                            public var state: String?

                            public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                                self.city = city
                                self.country = country
                                self.line1 = line1
                                self.line2 = line2
                                self.postalCode = postalCode
                                self.state = state
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(city, forKey: "city")
                                encoder.encode(country, forKey: "country")
                                encoder.encode(line1, forKey: "line1")
                                encoder.encode(line2, forKey: "line2")
                                encoder.encode(postalCode, forKey: "postal_code")
                                encoder.encode(state, forKey: "state")
                                return encoder.items
                            }
                        }

                        public init(address: Address, name: String, phone: String? = nil) {
                            self.address = address
                            self.name = name
                            self.phone = phone
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(address, forKey: "address")
                            encoder.encode(name, forKey: "name")
                            encoder.encode(phone, forKey: "phone")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                /// Tax_param
                public struct Tax: Codable {
                    public var ipAddress: IpAddress?

                    public struct IpAddress: Codable {
                        public var string: String?
                        public var object: Object?

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(string: String? = nil, object: Object? = nil) {
                            self.string = string
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(string, forKey: "string")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public init(ipAddress: IpAddress? = nil) {
                        self.ipAddress = ipAddress
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(ipAddress, forKey: "ip_address")
                        return encoder.items
                    }
                }

                public enum TaxExempt: String, Codable, CaseIterable {
                    case empty = ""
                    case exempt
                    case `none`
                    case reverse
                }

                /// Data_params
                public struct TaxID: Codable {
                    public var type: `Type`
                    public var value: String

                    public enum `Type`: String, Codable, CaseIterable {
                        case aeTrn = "ae_trn"
                        case auAbn = "au_abn"
                        case auArn = "au_arn"
                        case brCnpj = "br_cnpj"
                        case brCpf = "br_cpf"
                        case caBn = "ca_bn"
                        case caGstHst = "ca_gst_hst"
                        case caPstBc = "ca_pst_bc"
                        case caPstMb = "ca_pst_mb"
                        case caPstSk = "ca_pst_sk"
                        case caQst = "ca_qst"
                        case chVat = "ch_vat"
                        case clTin = "cl_tin"
                        case esCif = "es_cif"
                        case euVat = "eu_vat"
                        case gbVat = "gb_vat"
                        case geVat = "ge_vat"
                        case hkBr = "hk_br"
                        case idNpwp = "id_npwp"
                        case ilVat = "il_vat"
                        case inGst = "in_gst"
                        case jpCn = "jp_cn"
                        case jpRn = "jp_rn"
                        case krBrn = "kr_brn"
                        case liUid = "li_uid"
                        case mxRfc = "mx_rfc"
                        case myFrp = "my_frp"
                        case myItn = "my_itn"
                        case mySst = "my_sst"
                        case noVat = "no_vat"
                        case nzGst = "nz_gst"
                        case ruInn = "ru_inn"
                        case ruKpp = "ru_kpp"
                        case saVat = "sa_vat"
                        case sgGst = "sg_gst"
                        case sgUen = "sg_uen"
                        case thVat = "th_vat"
                        case twVat = "tw_vat"
                        case uaVat = "ua_vat"
                        case usEin = "us_ein"
                        case zaVat = "za_vat"
                    }

                    public init(type: `Type`, value: String) {
                        self.type = type
                        self.value = value
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(type, forKey: "type")
                        encoder.encode(value, forKey: "value")
                        return encoder.items
                    }
                }

                public init(address: Address? = nil, shipping: Shipping? = nil, tax: Tax? = nil, taxExempt: TaxExempt? = nil, taxIDs: [TaxID]? = nil) {
                    self.address = address
                    self.shipping = shipping
                    self.tax = tax
                    self.taxExempt = taxExempt
                    self.taxIDs = taxIDs
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(shipping, forKey: "shipping")
                    encoder.encode(tax, forKey: "tax")
                    encoder.encode(taxExempt, forKey: "tax_exempt")
                    encoder.encode(taxIDs, forKey: "tax_ids")
                    return encoder.items
                }
            }

            public struct Discounts: Codable {
                public var placeholderItems: [PlaceholderItem]?
                public var object: Object?

                /// Discounts_data_param
                public struct PlaceholderItem: Codable {
                    public var coupon: String?
                    public var discount: String?

                    public init(coupon: String? = nil, discount: String? = nil) {
                        self.coupon = coupon
                        self.discount = discount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(coupon, forKey: "coupon")
                        encoder.encode(discount, forKey: "discount")
                        return encoder.items
                    }
                }

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                    self.placeholderItems = placeholderItems
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(placeholderItems, forKey: "placeholderItems")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Invoice_item_preview_params
            public struct InvoiceItems: Codable {
                public var amount: Int?
                public var currency: String?
                public var description: String?
                public var isDiscountable: Bool?
                public var discounts: Discounts?
                public var invoiceitem: String?
                public var metadata: Metadata?
                public var period: Period?
                public var price: String?
                /// One_time_price_data
                public var priceData: PriceData?
                public var quantity: Int?
                public var taxRates: TaxRates?
                public var unitAmount: Int?
                public var unitAmountDecimal: String?

                public struct Discounts: Codable {
                    public var placeholderItems: [PlaceholderItem]?
                    public var object: Object?

                    /// Discounts_data_param
                    public struct PlaceholderItem: Codable {
                        public var coupon: String?
                        public var discount: String?

                        public init(coupon: String? = nil, discount: String? = nil) {
                            self.coupon = coupon
                            self.discount = discount
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(coupon, forKey: "coupon")
                            encoder.encode(discount, forKey: "discount")
                            return encoder.items
                        }
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                        self.placeholderItems = placeholderItems
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(placeholderItems, forKey: "placeholderItems")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public struct Metadata: Codable {
                    public var stringString: [String: String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(stringString: [String: String]? = nil, object: Object? = nil) {
                        self.stringString = stringString
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(stringString, forKey: "stringString")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public struct Period: Codable {
                    public var end: Int
                    public var start: Int

                    public init(end: Int, start: Int) {
                        self.end = end
                        self.start = start
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(end, forKey: "end")
                        encoder.encode(start, forKey: "start")
                        return encoder.items
                    }
                }

                /// One_time_price_data
                public struct PriceData: Codable {
                    public var currency: String
                    public var product: String
                    public var taxBehavior: TaxBehavior?
                    public var unitAmount: Int?
                    public var unitAmountDecimal: String?

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public init(currency: String, product: String, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                        self.currency = currency
                        self.product = product
                        self.taxBehavior = taxBehavior
                        self.unitAmount = unitAmount
                        self.unitAmountDecimal = unitAmountDecimal
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(product, forKey: "product")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(unitAmount, forKey: "unit_amount")
                        encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                        return encoder.items
                    }
                }

                public struct TaxRates: Codable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(amount: Int? = nil, currency: String? = nil, description: String? = nil, isDiscountable: Bool? = nil, discounts: Discounts? = nil, invoiceitem: String? = nil, metadata: Metadata? = nil, period: Period? = nil, price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                    self.amount = amount
                    self.currency = currency
                    self.description = description
                    self.isDiscountable = isDiscountable
                    self.discounts = discounts
                    self.invoiceitem = invoiceitem
                    self.metadata = metadata
                    self.period = period
                    self.price = price
                    self.priceData = priceData
                    self.quantity = quantity
                    self.taxRates = taxRates
                    self.unitAmount = unitAmount
                    self.unitAmountDecimal = unitAmountDecimal
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(amount, forKey: "amount")
                    encoder.encode(currency, forKey: "currency")
                    encoder.encode(description, forKey: "description")
                    encoder.encode(isDiscountable, forKey: "discountable")
                    encoder.encode(discounts, forKey: "discounts")
                    encoder.encode(invoiceitem, forKey: "invoiceitem")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(period, forKey: "period")
                    encoder.encode(price, forKey: "price")
                    encoder.encode(priceData, forKey: "price_data")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    encoder.encode(unitAmount, forKey: "unit_amount")
                    encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                    return encoder.items
                }
            }

            public struct SubscriptionBillingCycleAnchor: Codable {
                public var object: Object?
                public var int: Int?

                public enum Object: String, Codable, CaseIterable {
                    case now
                    case unchanged
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public struct SubscriptionCancelAt: Codable {
                public var int: Int?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(int: Int? = nil, object: Object? = nil) {
                    self.int = int
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(int, forKey: "int")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public struct SubscriptionDefaultTaxRates: Codable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Subscription_item_update_params
            public struct SubscriptionItems: Codable {
                public var billingThresholds: BillingThresholds?
                public var isClearUsage: Bool?
                public var isDeleted: Bool?
                public var id: String?
                public var metadata: Metadata?
                public var price: String?
                /// Recurring_price_data
                public var priceData: PriceData?
                public var quantity: Int?
                public var taxRates: TaxRates?

                public struct BillingThresholds: Codable {
                    /// Item_billing_thresholds_param
                    public var a: A?
                    public var b: B?

                    /// Item_billing_thresholds_param
                    public struct A: Codable {
                        public var usageGte: Int

                        public init(usageGte: Int) {
                            self.usageGte = usageGte
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(usageGte, forKey: "usage_gte")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Metadata: Codable {
                    public var stringString: [String: String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(stringString: [String: String]? = nil, object: Object? = nil) {
                        self.stringString = stringString
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(stringString, forKey: "stringString")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                /// Recurring_price_data
                public struct PriceData: Codable {
                    public var currency: String
                    public var product: String
                    /// Recurring_adhoc
                    public var recurring: Recurring
                    public var taxBehavior: TaxBehavior?
                    public var unitAmount: Int?
                    public var unitAmountDecimal: String?

                    /// Recurring_adhoc
                    public struct Recurring: Codable {
                        public var interval: Interval
                        public var intervalCount: Int?

                        public enum Interval: String, Codable, CaseIterable {
                            case day
                            case month
                            case week
                            case year
                        }

                        public init(interval: Interval, intervalCount: Int? = nil) {
                            self.interval = interval
                            self.intervalCount = intervalCount
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(interval, forKey: "interval")
                            encoder.encode(intervalCount, forKey: "interval_count")
                            return encoder.items
                        }
                    }

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public init(currency: String, product: String, recurring: Recurring, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                        self.currency = currency
                        self.product = product
                        self.recurring = recurring
                        self.taxBehavior = taxBehavior
                        self.unitAmount = unitAmount
                        self.unitAmountDecimal = unitAmountDecimal
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(product, forKey: "product")
                        encoder.encode(recurring, forKey: "recurring")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(unitAmount, forKey: "unit_amount")
                        encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                        return encoder.items
                    }
                }

                public struct TaxRates: Codable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(billingThresholds: BillingThresholds? = nil, isClearUsage: Bool? = nil, isDeleted: Bool? = nil, id: String? = nil, metadata: Metadata? = nil, price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                    self.billingThresholds = billingThresholds
                    self.isClearUsage = isClearUsage
                    self.isDeleted = isDeleted
                    self.id = id
                    self.metadata = metadata
                    self.price = price
                    self.priceData = priceData
                    self.quantity = quantity
                    self.taxRates = taxRates
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(billingThresholds, forKey: "billing_thresholds")
                    encoder.encode(isClearUsage, forKey: "clear_usage")
                    encoder.encode(isDeleted, forKey: "deleted")
                    encoder.encode(id, forKey: "id")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(price, forKey: "price")
                    encoder.encode(priceData, forKey: "price_data")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    return encoder.items
                }
            }

            public enum SubscriptionProrationBehavior: String, Codable, CaseIterable {
                case alwaysInvoice = "always_invoice"
                case createProrations = "create_prorations"
                case `none`
            }

            public struct SubscriptionTrialEnd: Codable {
                public var object: Object?
                public var int: Int?

                public enum Object: String, Codable, CaseIterable {
                    case now
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(automaticTax: AutomaticTax? = nil, coupon: String? = nil, customer: String? = nil, customerDetails: CustomerDetails? = nil, discounts: Discounts? = nil, endingBefore: String? = nil, expand: [String]? = nil, invoiceItems: [InvoiceItems]? = nil, limit: Int? = nil, schedule: String? = nil, startingAfter: String? = nil, subscription: String? = nil, subscriptionBillingCycleAnchor: SubscriptionBillingCycleAnchor? = nil, subscriptionCancelAt: SubscriptionCancelAt? = nil, isSubscriptionCancelAtPeriodEnd: Bool? = nil, isSubscriptionCancelNow: Bool? = nil, subscriptionDefaultTaxRates: SubscriptionDefaultTaxRates? = nil, subscriptionItems: [SubscriptionItems]? = nil, subscriptionProrationBehavior: SubscriptionProrationBehavior? = nil, subscriptionProrationDate: Int? = nil, subscriptionStartDate: Int? = nil, subscriptionTrialEnd: SubscriptionTrialEnd? = nil, isSubscriptionTrialFromPlan: Bool? = nil) {
                self.automaticTax = automaticTax
                self.coupon = coupon
                self.customer = customer
                self.customerDetails = customerDetails
                self.discounts = discounts
                self.endingBefore = endingBefore
                self.expand = expand
                self.invoiceItems = invoiceItems
                self.limit = limit
                self.schedule = schedule
                self.startingAfter = startingAfter
                self.subscription = subscription
                self.subscriptionBillingCycleAnchor = subscriptionBillingCycleAnchor
                self.subscriptionCancelAt = subscriptionCancelAt
                self.isSubscriptionCancelAtPeriodEnd = isSubscriptionCancelAtPeriodEnd
                self.isSubscriptionCancelNow = isSubscriptionCancelNow
                self.subscriptionDefaultTaxRates = subscriptionDefaultTaxRates
                self.subscriptionItems = subscriptionItems
                self.subscriptionProrationBehavior = subscriptionProrationBehavior
                self.subscriptionProrationDate = subscriptionProrationDate
                self.subscriptionStartDate = subscriptionStartDate
                self.subscriptionTrialEnd = subscriptionTrialEnd
                self.isSubscriptionTrialFromPlan = isSubscriptionTrialFromPlan
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(automaticTax, forKey: "automatic_tax", isDeepObject: true)
                encoder.encode(coupon, forKey: "coupon")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(customerDetails, forKey: "customer_details", isDeepObject: true)
                encoder.encode(discounts, forKey: "discounts", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(invoiceItems, forKey: "invoice_items", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(schedule, forKey: "schedule")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(subscription, forKey: "subscription")
                encoder.encode(subscriptionBillingCycleAnchor, forKey: "subscription_billing_cycle_anchor", isDeepObject: true)
                encoder.encode(subscriptionCancelAt, forKey: "subscription_cancel_at", isDeepObject: true)
                encoder.encode(isSubscriptionCancelAtPeriodEnd, forKey: "subscription_cancel_at_period_end")
                encoder.encode(isSubscriptionCancelNow, forKey: "subscription_cancel_now")
                encoder.encode(subscriptionDefaultTaxRates, forKey: "subscription_default_tax_rates", isDeepObject: true)
                encoder.encode(subscriptionItems, forKey: "subscription_items", isDeepObject: true)
                encoder.encode(subscriptionProrationBehavior, forKey: "subscription_proration_behavior")
                encoder.encode(subscriptionProrationDate, forKey: "subscription_proration_date")
                encoder.encode(subscriptionStartDate, forKey: "subscription_start_date")
                encoder.encode(subscriptionTrialEnd, forKey: "subscription_trial_end", isDeepObject: true)
                encoder.encode(isSubscriptionTrialFromPlan, forKey: "subscription_trial_from_plan")
                return encoder.items
            }
        }
    }
}

extension Paths.Invoices {
    public func invoice(_ invoice: String) -> WithInvoice {
        WithInvoice(path: "\(path)/\(invoice)")
    }

    public struct WithInvoice {
        /// Path: `/v1/invoices/{invoice}`
        public let path: String

        /// <p>Retrieves the invoice with the given ID.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Invoice> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Draft invoices are fully editable. Once an invoice is <a href="/docs/billing/invoices/workflow#finalized">finalized</a>,
        /// monetary values, as well as <code>collection_method</code>, become uneditable.</p>
        /// 
        /// <p>If you would like to stop the Stripe Billing engine from automatically finalizing, reattempting payments on,
        /// sending reminders for, or <a href="/docs/billing/invoices/reconciliation">automatically reconciling</a> invoices, pass
        /// <code>auto_advance=false</code>.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Invoice> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The account tax IDs associated with the invoice. Only editable when the invoice is a draft.
            public var accountTaxIDs: AccountTaxIDs?
            /// A fee in %s that will be applied to the invoice and transferred to the application owner's Stripe account. The request must be made with an OAuth key or the Stripe-Account header in order to take an application fee. For more information, see the application fees [documentation](https://stripe.com/docs/billing/invoices/connect#collecting-fees).
            public var applicationFeeAmount: Int?
            /// Controls whether Stripe will perform [automatic collection](https://stripe.com/docs/billing/invoices/workflow/#auto_advance) of the invoice.
            public var isAutoAdvance: Bool?
            /// Automatic_tax_param
            ///
            /// Settings for automatic tax lookup for this invoice.
            public var automaticTax: AutomaticTax?
            /// Either `charge_automatically` or `send_invoice`. This field can be updated only on `draft` invoices.
            public var collectionMethod: CollectionMethod?
            /// A list of up to 4 custom fields to be displayed on the invoice. If a value for `custom_fields` is specified, the list specified will replace the existing custom field list on this invoice. Pass an empty string to remove previously-defined fields.
            public var customFields: CustomFields?
            /// The number of days from which the invoice is created until it is due. Only valid for invoices where `collection_method=send_invoice`. This field can only be updated on `draft` invoices.
            public var daysUntilDue: Int?
            /// ID of the default payment method for the invoice. It must belong to the customer associated with the invoice. If not set, defaults to the subscription's default payment method, if any, or to the default payment method in the customer's invoice settings.
            public var defaultPaymentMethod: String?
            /// ID of the default payment source for the invoice. It must belong to the customer associated with the invoice and be in a chargeable state. If not set, defaults to the subscription's default source, if any, or to the customer's default source.
            public var defaultSource: String?
            /// The tax rates that will apply to any line item that does not have `tax_rates` set. Pass an empty string to remove previously-defined tax rates.
            public var defaultTaxRates: DefaultTaxRates?
            /// An arbitrary string attached to the object. Often useful for displaying to users. Referenced as 'memo' in the Dashboard.
            public var description: String?
            /// The discounts that will apply to the invoice. Pass an empty string to remove previously-defined discounts.
            public var discounts: Discounts?
            /// The date on which payment for this invoice is due. Only valid for invoices where `collection_method=send_invoice`. This field can only be updated on `draft` invoices.
            public var dueDate: Int?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Footer to be displayed on the invoice.
            public var footer: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The account (if any) for which the funds of the invoice payment are intended. If set, the invoice will be presented with the branding and support information of the specified account. See the [Invoices with Connect](https://stripe.com/docs/billing/invoices/connect) documentation for details.
            public var onBehalfOf: OnBehalfOf?
            /// Payment_settings
            ///
            /// Configuration settings for the PaymentIntent that is generated when the invoice is finalized.
            public var paymentSettings: PaymentSettings?
            /// Extra information about a charge for the customer's credit card statement. It must contain at least one letter. If not specified and this invoice is part of a subscription, the default `statement_descriptor` will be set to the first subscription item's product's `statement_descriptor`.
            public var statementDescriptor: String?
            /// If specified, the funds from the invoice will be transferred to the destination and the ID of the resulting transfer will be found on the invoice's charge. This will be unset if you POST an empty value.
            public var transferData: TransferData?

            /// The account tax IDs associated with the invoice. Only editable when the invoice is a draft.
            public struct AccountTaxIDs: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Automatic_tax_param
            ///
            /// Settings for automatic tax lookup for this invoice.
            public struct AutomaticTax: Encodable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Either `charge_automatically` or `send_invoice`. This field can be updated only on `draft` invoices.
            public enum CollectionMethod: String, Codable, CaseIterable {
                case chargeAutomatically = "charge_automatically"
                case sendInvoice = "send_invoice"
            }

            /// A list of up to 4 custom fields to be displayed on the invoice. If a value for `custom_fields` is specified, the list specified will replace the existing custom field list on this invoice. Pass an empty string to remove previously-defined fields.
            public struct CustomFields: Encodable {
                public var placeholderItems: [PlaceholderItem]?
                public var object: Object?

                /// Custom_field_params
                public struct PlaceholderItem: Encodable {
                    public var name: String
                    public var value: String

                    public init(name: String, value: String) {
                        self.name = name
                        self.value = value
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(name, forKey: "name")
                        encoder.encode(value, forKey: "value")
                        return encoder.items
                    }
                }

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                    self.placeholderItems = placeholderItems
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(placeholderItems, forKey: "placeholderItems")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// The tax rates that will apply to any line item that does not have `tax_rates` set. Pass an empty string to remove previously-defined tax rates.
            public struct DefaultTaxRates: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// The discounts that will apply to the invoice. Pass an empty string to remove previously-defined discounts.
            public struct Discounts: Encodable {
                public var placeholderItems: [PlaceholderItem]?
                public var object: Object?

                /// Discounts_data_param
                public struct PlaceholderItem: Encodable {
                    public var coupon: String?
                    public var discount: String?

                    public init(coupon: String? = nil, discount: String? = nil) {
                        self.coupon = coupon
                        self.discount = discount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(coupon, forKey: "coupon")
                        encoder.encode(discount, forKey: "discount")
                        return encoder.items
                    }
                }

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                    self.placeholderItems = placeholderItems
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(placeholderItems, forKey: "placeholderItems")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// The account (if any) for which the funds of the invoice payment are intended. If set, the invoice will be presented with the branding and support information of the specified account. See the [Invoices with Connect](https://stripe.com/docs/billing/invoices/connect) documentation for details.
            public struct OnBehalfOf: Encodable {
                public var string: String?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(string: String? = nil, object: Object? = nil) {
                    self.string = string
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(string, forKey: "string")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Payment_settings
            ///
            /// Configuration settings for the PaymentIntent that is generated when the invoice is finalized.
            public struct PaymentSettings: Encodable {
                /// Payment_method_options
                public var paymentMethodOptions: PaymentMethodOptions?
                public var paymentMethodTypes: PaymentMethodTypes?

                /// Payment_method_options
                public struct PaymentMethodOptions: Encodable {
                    public var acssDebit: AcssDebit?
                    public var bancontact: Bancontact?
                    public var card: Card?

                    public struct AcssDebit: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            /// Mandate_options_param
                            public var mandateOptions: MandateOptions?
                            public var verificationMethod: VerificationMethod?

                            /// Mandate_options_param
                            public struct MandateOptions: Encodable {
                                public var transactionType: TransactionType?

                                public enum TransactionType: String, Codable, CaseIterable {
                                    case business
                                    case personal
                                }

                                public init(transactionType: TransactionType? = nil) {
                                    self.transactionType = transactionType
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(transactionType, forKey: "transaction_type")
                                    return encoder.items
                                }
                            }

                            public enum VerificationMethod: String, Codable, CaseIterable {
                                case automatic
                                case instant
                                case microdeposits
                            }

                            public init(mandateOptions: MandateOptions? = nil, verificationMethod: VerificationMethod? = nil) {
                                self.mandateOptions = mandateOptions
                                self.verificationMethod = verificationMethod
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(mandateOptions, forKey: "mandate_options")
                                encoder.encode(verificationMethod, forKey: "verification_method")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct Bancontact: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            public var preferredLanguage: PreferredLanguage?

                            public enum PreferredLanguage: String, Codable, CaseIterable {
                                case de
                                case en
                                case fr
                                case nl
                            }

                            public init(preferredLanguage: PreferredLanguage? = nil) {
                                self.preferredLanguage = preferredLanguage
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(preferredLanguage, forKey: "preferred_language")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct Card: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            public var requestThreeDSecure: RequestThreeDSecure?

                            public enum RequestThreeDSecure: String, Codable, CaseIterable {
                                case any
                                case automatic
                            }

                            public init(requestThreeDSecure: RequestThreeDSecure? = nil) {
                                self.requestThreeDSecure = requestThreeDSecure
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(requestThreeDSecure, forKey: "request_three_d_secure")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public init(acssDebit: AcssDebit? = nil, bancontact: Bancontact? = nil, card: Card? = nil) {
                        self.acssDebit = acssDebit
                        self.bancontact = bancontact
                        self.card = card
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(acssDebit, forKey: "acss_debit")
                        encoder.encode(bancontact, forKey: "bancontact")
                        encoder.encode(card, forKey: "card")
                        return encoder.items
                    }
                }

                public struct PaymentMethodTypes: Encodable {
                    public var placeholderItems: [PlaceholderItem]?
                    public var object: Object?

                    public enum PlaceholderItem: String, Codable, CaseIterable {
                        case achCreditTransfer = "ach_credit_transfer"
                        case achDebit = "ach_debit"
                        case acssDebit = "acss_debit"
                        case auBecsDebit = "au_becs_debit"
                        case bacsDebit = "bacs_debit"
                        case bancontact
                        case boleto
                        case card
                        case fpx
                        case giropay
                        case ideal
                        case sepaDebit = "sepa_debit"
                        case sofort
                        case wechatPay = "wechat_pay"
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                        self.placeholderItems = placeholderItems
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(placeholderItems, forKey: "placeholderItems")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(paymentMethodOptions: PaymentMethodOptions? = nil, paymentMethodTypes: PaymentMethodTypes? = nil) {
                    self.paymentMethodOptions = paymentMethodOptions
                    self.paymentMethodTypes = paymentMethodTypes
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(paymentMethodOptions, forKey: "payment_method_options")
                    encoder.encode(paymentMethodTypes, forKey: "payment_method_types")
                    return encoder.items
                }
            }

            /// If specified, the funds from the invoice will be transferred to the destination and the ID of the resulting transfer will be found on the invoice's charge. This will be unset if you POST an empty value.
            public struct TransferData: Encodable {
                /// Transfer_data_specs
                public var a: A?
                public var b: B?

                /// Transfer_data_specs
                public struct A: Encodable {
                    public var amount: Int?
                    public var destination: String

                    public init(amount: Int? = nil, destination: String) {
                        self.amount = amount
                        self.destination = destination
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amount, forKey: "amount")
                        encoder.encode(destination, forKey: "destination")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            public init(accountTaxIDs: AccountTaxIDs? = nil, applicationFeeAmount: Int? = nil, isAutoAdvance: Bool? = nil, automaticTax: AutomaticTax? = nil, collectionMethod: CollectionMethod? = nil, customFields: CustomFields? = nil, daysUntilDue: Int? = nil, defaultPaymentMethod: String? = nil, defaultSource: String? = nil, defaultTaxRates: DefaultTaxRates? = nil, description: String? = nil, discounts: Discounts? = nil, dueDate: Int? = nil, expand: [String]? = nil, footer: String? = nil, metadata: Metadata? = nil, onBehalfOf: OnBehalfOf? = nil, paymentSettings: PaymentSettings? = nil, statementDescriptor: String? = nil, transferData: TransferData? = nil) {
                self.accountTaxIDs = accountTaxIDs
                self.applicationFeeAmount = applicationFeeAmount
                self.isAutoAdvance = isAutoAdvance
                self.automaticTax = automaticTax
                self.collectionMethod = collectionMethod
                self.customFields = customFields
                self.daysUntilDue = daysUntilDue
                self.defaultPaymentMethod = defaultPaymentMethod
                self.defaultSource = defaultSource
                self.defaultTaxRates = defaultTaxRates
                self.description = description
                self.discounts = discounts
                self.dueDate = dueDate
                self.expand = expand
                self.footer = footer
                self.metadata = metadata
                self.onBehalfOf = onBehalfOf
                self.paymentSettings = paymentSettings
                self.statementDescriptor = statementDescriptor
                self.transferData = transferData
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(accountTaxIDs, forKey: "account_tax_ids")
                encoder.encode(applicationFeeAmount, forKey: "application_fee_amount")
                encoder.encode(isAutoAdvance, forKey: "auto_advance")
                encoder.encode(automaticTax, forKey: "automatic_tax")
                encoder.encode(collectionMethod, forKey: "collection_method")
                encoder.encode(customFields, forKey: "custom_fields")
                encoder.encode(daysUntilDue, forKey: "days_until_due")
                encoder.encode(defaultPaymentMethod, forKey: "default_payment_method")
                encoder.encode(defaultSource, forKey: "default_source")
                encoder.encode(defaultTaxRates, forKey: "default_tax_rates")
                encoder.encode(description, forKey: "description")
                encoder.encode(discounts, forKey: "discounts")
                encoder.encode(dueDate, forKey: "due_date")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(footer, forKey: "footer")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(onBehalfOf, forKey: "on_behalf_of")
                encoder.encode(paymentSettings, forKey: "payment_settings")
                encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                encoder.encode(transferData, forKey: "transfer_data")
                return encoder.items
            }
        }

        /// <p>Permanently deletes a one-off invoice draft. This cannot be undone. Attempts to delete invoices that are no longer in a draft state will fail; once an invoice has been finalized or if an invoice is for a subscription, it must be <a href="#void_invoice">voided</a>.</p>
        public var delete: Request<StripeAPI.DeletedInvoice> {
            .delete(path)
        }
    }
}

extension Paths.Invoices.WithInvoice {
    public var finalize: Finalize {
        Finalize(path: path + "/finalize")
    }

    public struct Finalize {
        /// Path: `/v1/invoices/{invoice}/finalize`
        public let path: String

        /// <p>Stripe automatically finalizes drafts before sending and attempting payment on invoices. However, if you’d like to finalize a draft invoice manually, you can do so using this method.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Invoice> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Controls whether Stripe will perform [automatic collection](https://stripe.com/docs/billing/invoices/overview#auto-advance) of the invoice. When `false`, the invoice's state will not automatically advance without an explicit action.
            public var isAutoAdvance: Bool?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(isAutoAdvance: Bool? = nil, expand: [String]? = nil) {
                self.isAutoAdvance = isAutoAdvance
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isAutoAdvance, forKey: "auto_advance")
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.Invoices.WithInvoice {
    public var lines: Lines {
        Lines(path: path + "/lines")
    }

    public struct Lines {
        /// Path: `/v1/invoices/{invoice}/lines`
        public let path: String

        /// <p>When retrieving an invoice, you’ll get a <strong>lines</strong> property containing the total count of line items and the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// InvoiceLinesList
        public struct GetResponse: Decodable {
            /// Details about each object.
            public var data: [StripeAPI.LineItem]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.LineItem], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }
    }
}

extension Paths.Invoices.WithInvoice {
    public var markUncollectible: MarkUncollectible {
        MarkUncollectible(path: path + "/mark_uncollectible")
    }

    public struct MarkUncollectible {
        /// Path: `/v1/invoices/{invoice}/mark_uncollectible`
        public let path: String

        /// <p>Marking an invoice as uncollectible is useful for keeping track of bad debts that can be written off for accounting purposes.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Invoice> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(expand: [String]? = nil) {
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.Invoices.WithInvoice {
    public var pay: Pay {
        Pay(path: path + "/pay")
    }

    public struct Pay {
        /// Path: `/v1/invoices/{invoice}/pay`
        public let path: String

        /// <p>Stripe automatically creates and then attempts to collect payment on invoices for customers on subscriptions according to your <a href="https://dashboard.stripe.com/account/billing/automatic">subscriptions settings</a>. However, if you’d like to attempt payment on an invoice out of the normal collection schedule or for some other reason, you can do so.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Invoice> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// In cases where the source used to pay the invoice has insufficient funds, passing `forgive=true` controls whether a charge should be attempted for the full amount available on the source, up to the amount to fully pay the invoice. This effectively forgives the difference between the amount available on the source and the amount due. 
            /// 
            /// Passing `forgive=false` will fail the charge if the source hasn't been pre-funded with the right amount. An example for this case is with ACH Credit Transfers and wires: if the amount wired is less than the amount due by a small amount, you might want to forgive the difference. Defaults to `false`.
            public var isForgive: Bool?
            /// Indicates if a customer is on or off-session while an invoice payment is attempted. Defaults to `true` (off-session).
            public var isOffSession: Bool?
            /// Boolean representing whether an invoice is paid outside of Stripe. This will result in no charge being made. Defaults to `false`.
            public var isPaidOutOfBand: Bool?
            /// A PaymentMethod to be charged. The PaymentMethod must be the ID of a PaymentMethod belonging to the customer associated with the invoice being paid.
            public var paymentMethod: String?
            /// A payment source to be charged. The source must be the ID of a source belonging to the customer associated with the invoice being paid.
            public var source: String?

            public init(expand: [String]? = nil, isForgive: Bool? = nil, isOffSession: Bool? = nil, isPaidOutOfBand: Bool? = nil, paymentMethod: String? = nil, source: String? = nil) {
                self.expand = expand
                self.isForgive = isForgive
                self.isOffSession = isOffSession
                self.isPaidOutOfBand = isPaidOutOfBand
                self.paymentMethod = paymentMethod
                self.source = source
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(isForgive, forKey: "forgive")
                encoder.encode(isOffSession, forKey: "off_session")
                encoder.encode(isPaidOutOfBand, forKey: "paid_out_of_band")
                encoder.encode(paymentMethod, forKey: "payment_method")
                encoder.encode(source, forKey: "source")
                return encoder.items
            }
        }
    }
}

extension Paths.Invoices.WithInvoice {
    public var send: Send {
        Send(path: path + "/send")
    }

    public struct Send {
        /// Path: `/v1/invoices/{invoice}/send`
        public let path: String

        /// <p>Stripe will automatically send invoices to customers according to your <a href="https://dashboard.stripe.com/account/billing/automatic">subscriptions settings</a>. However, if you’d like to manually send an invoice to your customer out of the normal schedule, you can do so. When sending invoices that have already been paid, there will be no reference to the payment in the email.</p>
        /// 
        /// <p>Requests made in test-mode result in no emails being sent, despite sending an <code>invoice.sent</code> event.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Invoice> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(expand: [String]? = nil) {
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.Invoices.WithInvoice {
    public var void: Void {
        Void(path: path + "/void")
    }

    public struct Void {
        /// Path: `/v1/invoices/{invoice}/void`
        public let path: String

        /// <p>Mark a finalized invoice as void. This cannot be undone. Voiding an invoice is similar to <a href="#delete_invoice">deletion</a>, however it only applies to finalized invoices and maintains a papertrail where the invoice can still be found.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Invoice> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(expand: [String]? = nil) {
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var issuerFraudRecords: IssuerFraudRecords {
        IssuerFraudRecords(path: "/v1/issuer_fraud_records")
    }

    public struct IssuerFraudRecords {
        /// Path: `/v1/issuer_fraud_records`
        public let path: String

        /// <p>Returns a list of issuer fraud records.</p>
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// RadarIssuerFraudRecordList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.IssuerFraudRecord]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.IssuerFraudRecord], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var charge: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(charge: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.charge = charge
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(charge, forKey: "charge")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }
    }
}

extension Paths.IssuerFraudRecords {
    public func issuerFraudRecord(_ issuerFraudRecord: String) -> WithIssuerFraudRecord {
        WithIssuerFraudRecord(path: "\(path)/\(issuerFraudRecord)")
    }

    public struct WithIssuerFraudRecord {
        /// Path: `/v1/issuer_fraud_records/{issuer_fraud_record}`
        public let path: String

        /// <p>Retrieves the details of an issuer fraud record that has previously been created. </p>
        /// 
        /// <p>Please refer to the <a href="#issuer_fraud_record_object">issuer fraud record</a> object reference for more details.</p>
        @available(*, deprecated, message: "Deprecated")
        public func get(expand: [String]? = nil) -> Request<StripeAPI.IssuerFraudRecord> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths {
    public static var issuing: Issuing {
        Issuing(path: "/v1/issuing")
    }

    public struct Issuing {
        /// Path: `/v1/issuing`
        public let path: String
    }
}

extension Paths.Issuing {
    public var authorizations: Authorizations {
        Authorizations(path: path + "/authorizations")
    }

    public struct Authorizations {
        /// Path: `/v1/issuing/authorizations`
        public let path: String

        /// <p>Returns a list of Issuing <code>Authorization</code> objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.IssuingAuthorization]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.IssuingAuthorization], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var card: String?
            public var cardholder: String?
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?
            public var status: Status?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public enum Status: String, Codable, CaseIterable {
                case closed
                case pending
                case reversed
            }

            public init(card: String? = nil, cardholder: String? = nil, created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil, status: Status? = nil) {
                self.card = card
                self.cardholder = cardholder
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
                self.status = status
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(card, forKey: "card")
                encoder.encode(cardholder, forKey: "cardholder")
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(status, forKey: "status")
                return encoder.items
            }
        }
    }
}

extension Paths.Issuing.Authorizations {
    public func authorization(_ authorization: String) -> WithAuthorization {
        WithAuthorization(path: "\(path)/\(authorization)")
    }

    public struct WithAuthorization {
        /// Path: `/v1/issuing/authorizations/{authorization}`
        public let path: String

        /// <p>Retrieves an Issuing <code>Authorization</code> object.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.IssuingAuthorization> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the specified Issuing <code>Authorization</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.IssuingAuthorization> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(expand: [String]? = nil, metadata: Metadata? = nil) {
                self.expand = expand
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths.Issuing.Authorizations.WithAuthorization {
    public var approve: Approve {
        Approve(path: path + "/approve")
    }

    public struct Approve {
        /// Path: `/v1/issuing/authorizations/{authorization}/approve`
        public let path: String

        /// <p>Approves a pending Issuing <code>Authorization</code> object. This request should be made within the timeout window of the <a href="/docs/issuing/controls/real-time-authorizations">real-time authorization</a> flow.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.IssuingAuthorization> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// If the authorization's `pending_request.is_amount_controllable` property is `true`, you may provide this value to control how much to hold for the authorization. Must be positive (use [`decline`](https://stripe.com/docs/api/issuing/authorizations/decline) to decline an authorization request).
            public var amount: Int?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(amount: Int? = nil, expand: [String]? = nil, metadata: Metadata? = nil) {
                self.amount = amount
                self.expand = expand
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths.Issuing.Authorizations.WithAuthorization {
    public var decline: Decline {
        Decline(path: path + "/decline")
    }

    public struct Decline {
        /// Path: `/v1/issuing/authorizations/{authorization}/decline`
        public let path: String

        /// <p>Declines a pending Issuing <code>Authorization</code> object. This request should be made within the timeout window of the <a href="/docs/issuing/controls/real-time-authorizations">real time authorization</a> flow.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.IssuingAuthorization> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(expand: [String]? = nil, metadata: Metadata? = nil) {
                self.expand = expand
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths.Issuing {
    public var cardholders: Cardholders {
        Cardholders(path: path + "/cardholders")
    }

    public struct Cardholders {
        /// Path: `/v1/issuing/cardholders`
        public let path: String

        /// <p>Returns a list of Issuing <code>Cardholder</code> objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.IssuingCardholder]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.IssuingCardholder], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var email: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var phoneNumber: String?
            public var startingAfter: String?
            public var status: Status?
            public var type: `Type`?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public enum Status: String, Codable, CaseIterable {
                case active
                case blocked
                case inactive
            }

            public enum `Type`: String, Codable, CaseIterable {
                case company
                case individual
            }

            public init(created: Created? = nil, email: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, phoneNumber: String? = nil, startingAfter: String? = nil, status: Status? = nil, type: `Type`? = nil) {
                self.created = created
                self.email = email
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.phoneNumber = phoneNumber
                self.startingAfter = startingAfter
                self.status = status
                self.type = type
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(email, forKey: "email")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(phoneNumber, forKey: "phone_number")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(status, forKey: "status")
                encoder.encode(type, forKey: "type")
                return encoder.items
            }
        }

        /// <p>Creates a new Issuing <code>Cardholder</code> object that can be issued cards.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.IssuingCardholder> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Billing_specs
            ///
            /// The cardholder's billing address.
            public var billing: Billing
            /// Company_param
            ///
            /// Additional information about a `company` cardholder.
            public var company: Company?
            /// The cardholder's email address.
            public var email: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Individual_param
            ///
            /// Additional information about an `individual` cardholder.
            public var individual: Individual?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// The cardholder's name. This will be printed on cards issued to them.
            public var name: String
            /// The cardholder's phone number. This will be transformed to [E.164](https://en.wikipedia.org/wiki/E.164) if it is not provided in that format already. This is required for all cardholders who will be creating EU cards. See the [3D Secure documentation](https://stripe.com/docs/issuing/3d-secure#when-is-3d-secure-applied) for more details.
            public var phoneNumber: String?
            /// Authorization_controls_param_v2
            ///
            /// Rules that control spending across this cardholder's cards. Refer to our [documentation](https://stripe.com/docs/issuing/controls/spending-controls) for more details.
            public var spendingControls: SpendingControls?
            /// Specifies whether to permit authorizations on this cardholder's cards. Defaults to `active`.
            public var status: Status?
            /// One of `individual` or `company`.
            public var type: `Type`

            /// Billing_specs
            ///
            /// The cardholder's billing address.
            public struct Billing: Encodable {
                /// Required_address
                public var address: Address

                /// Required_address
                public struct Address: Encodable {
                    public var city: String
                    public var country: String
                    public var line1: String
                    public var line2: String?
                    public var postalCode: String
                    public var state: String?

                    public init(city: String, country: String, line1: String, line2: String? = nil, postalCode: String, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                public init(address: Address) {
                    self.address = address
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    return encoder.items
                }
            }

            /// Company_param
            ///
            /// Additional information about a `company` cardholder.
            public struct Company: Encodable {
                public var taxID: String?

                public init(taxID: String? = nil) {
                    self.taxID = taxID
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(taxID, forKey: "tax_id")
                    return encoder.items
                }
            }

            /// Individual_param
            ///
            /// Additional information about an `individual` cardholder.
            public struct Individual: Encodable {
                /// Date_of_birth_specs
                public var dob: Dob?
                public var firstName: String
                public var lastName: String
                /// Person_verification_param
                public var verification: Verification?

                /// Date_of_birth_specs
                public struct Dob: Encodable {
                    public var day: Int
                    public var month: Int
                    public var year: Int

                    public init(day: Int, month: Int, year: Int) {
                        self.day = day
                        self.month = month
                        self.year = year
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(day, forKey: "day")
                        encoder.encode(month, forKey: "month")
                        encoder.encode(year, forKey: "year")
                        return encoder.items
                    }
                }

                /// Person_verification_param
                public struct Verification: Encodable {
                    /// Person_verification_document_param
                    public var document: Document?

                    /// Person_verification_document_param
                    public struct Document: Encodable {
                        public var back: String?
                        public var front: String?

                        public init(back: String? = nil, front: String? = nil) {
                            self.back = back
                            self.front = front
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(back, forKey: "back")
                            encoder.encode(front, forKey: "front")
                            return encoder.items
                        }
                    }

                    public init(document: Document? = nil) {
                        self.document = document
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(document, forKey: "document")
                        return encoder.items
                    }
                }

                public init(dob: Dob? = nil, firstName: String, lastName: String, verification: Verification? = nil) {
                    self.dob = dob
                    self.firstName = firstName
                    self.lastName = lastName
                    self.verification = verification
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(dob, forKey: "dob")
                    encoder.encode(firstName, forKey: "first_name")
                    encoder.encode(lastName, forKey: "last_name")
                    encoder.encode(verification, forKey: "verification")
                    return encoder.items
                }
            }

            /// Authorization_controls_param_v2
            ///
            /// Rules that control spending across this cardholder's cards. Refer to our [documentation](https://stripe.com/docs/issuing/controls/spending-controls) for more details.
            public struct SpendingControls: Encodable {
                public var allowedCategories: [AllowedCategory]?
                public var blockedCategories: [BlockedCategory]?
                public var spendingLimits: [SpendingLimit]?
                public var spendingLimitsCurrency: String?

                public enum AllowedCategory: String, Codable, CaseIterable {
                    case acRefrigerationRepair = "ac_refrigeration_repair"
                    case accountingBookkeepingServices = "accounting_bookkeeping_services"
                    case advertisingServices = "advertising_services"
                    case agriculturalCooperative = "agricultural_cooperative"
                    case airlinesAirCarriers = "airlines_air_carriers"
                    case airportsFlyingFields = "airports_flying_fields"
                    case ambulanceServices = "ambulance_services"
                    case amusementParksCarnivals = "amusement_parks_carnivals"
                    case antiqueReproductions = "antique_reproductions"
                    case antiqueShops = "antique_shops"
                    case aquariums
                    case architecturalSurveyingServices = "architectural_surveying_services"
                    case artDealersAndGalleries = "art_dealers_and_galleries"
                    case artistsSupplyAndCraftShops = "artists_supply_and_craft_shops"
                    case autoAndHomeSupplyStores = "auto_and_home_supply_stores"
                    case autoBodyRepairShops = "auto_body_repair_shops"
                    case autoPaintShops = "auto_paint_shops"
                    case autoServiceShops = "auto_service_shops"
                    case automatedCashDisburse = "automated_cash_disburse"
                    case automatedFuelDispensers = "automated_fuel_dispensers"
                    case automobileAssociations = "automobile_associations"
                    case automotivePartsAndAccessoriesStores = "automotive_parts_and_accessories_stores"
                    case automotiveTireStores = "automotive_tire_stores"
                    case bailAndBondPayments = "bail_and_bond_payments"
                    case bakeries
                    case bandsOrchestras = "bands_orchestras"
                    case barberAndBeautyShops = "barber_and_beauty_shops"
                    case bettingCasinoGambling = "betting_casino_gambling"
                    case bicycleShops = "bicycle_shops"
                    case billiardPoolEstablishments = "billiard_pool_establishments"
                    case boatDealers = "boat_dealers"
                    case boatRentalsAndLeases = "boat_rentals_and_leases"
                    case bookStores = "book_stores"
                    case booksPeriodicalsAndNewspapers = "books_periodicals_and_newspapers"
                    case bowlingAlleys = "bowling_alleys"
                    case busLines = "bus_lines"
                    case businessSecretarialSchools = "business_secretarial_schools"
                    case buyingShoppingServices = "buying_shopping_services"
                    case cableSatelliteAndOtherPayTelevisionAndRadio = "cable_satellite_and_other_pay_television_and_radio"
                    case cameraAndPhotographicSupplyStores = "camera_and_photographic_supply_stores"
                    case candyNutAndConfectioneryStores = "candy_nut_and_confectionery_stores"
                    case carAndTruckDealersNewUsed = "car_and_truck_dealers_new_used"
                    case carAndTruckDealersUsedOnly = "car_and_truck_dealers_used_only"
                    case carRentalAgencies = "car_rental_agencies"
                    case carWashes = "car_washes"
                    case carpentryServices = "carpentry_services"
                    case carpetUpholsteryCleaning = "carpet_upholstery_cleaning"
                    case caterers
                    case charitableAndSocialServiceOrganizationsFundraising = "charitable_and_social_service_organizations_fundraising"
                    case chemicalsAndAlliedProducts = "chemicals_and_allied_products"
                    case childCareServices = "child_care_services"
                    case childrensAndInfantsWearStores = "childrens_and_infants_wear_stores"
                    case chiropodistsPodiatrists = "chiropodists_podiatrists"
                    case chiropractors
                    case cigarStoresAndStands = "cigar_stores_and_stands"
                    case civicSocialFraternalAssociations = "civic_social_fraternal_associations"
                    case cleaningAndMaintenance = "cleaning_and_maintenance"
                    case clothingRental = "clothing_rental"
                    case collegesUniversities = "colleges_universities"
                    case commercialEquipment = "commercial_equipment"
                    case commercialFootwear = "commercial_footwear"
                    case commercialPhotographyArtAndGraphics = "commercial_photography_art_and_graphics"
                    case commuterTransportAndFerries = "commuter_transport_and_ferries"
                    case computerNetworkServices = "computer_network_services"
                    case computerProgramming = "computer_programming"
                    case computerRepair = "computer_repair"
                    case computerSoftwareStores = "computer_software_stores"
                    case computersPeripheralsAndSoftware = "computers_peripherals_and_software"
                    case concreteWorkServices = "concrete_work_services"
                    case constructionMaterials = "construction_materials"
                    case consultingPublicRelations = "consulting_public_relations"
                    case correspondenceSchools = "correspondence_schools"
                    case cosmeticStores = "cosmetic_stores"
                    case counselingServices = "counseling_services"
                    case countryClubs = "country_clubs"
                    case courierServices = "courier_services"
                    case courtCosts = "court_costs"
                    case creditReportingAgencies = "credit_reporting_agencies"
                    case cruiseLines = "cruise_lines"
                    case dairyProductsStores = "dairy_products_stores"
                    case danceHallStudiosSchools = "dance_hall_studios_schools"
                    case datingEscortServices = "dating_escort_services"
                    case dentistsOrthodontists = "dentists_orthodontists"
                    case departmentStores = "department_stores"
                    case detectiveAgencies = "detective_agencies"
                    case digitalGoodsApplications = "digital_goods_applications"
                    case digitalGoodsGames = "digital_goods_games"
                    case digitalGoodsLargeVolume = "digital_goods_large_volume"
                    case digitalGoodsMedia = "digital_goods_media"
                    case directMarketingCatalogMerchant = "direct_marketing_catalog_merchant"
                    case directMarketingCombinationCatalogAndRetailMerchant = "direct_marketing_combination_catalog_and_retail_merchant"
                    case directMarketingInboundTelemarketing = "direct_marketing_inbound_telemarketing"
                    case directMarketingInsuranceServices = "direct_marketing_insurance_services"
                    case directMarketingOther = "direct_marketing_other"
                    case directMarketingOutboundTelemarketing = "direct_marketing_outbound_telemarketing"
                    case directMarketingSubscription = "direct_marketing_subscription"
                    case directMarketingTravel = "direct_marketing_travel"
                    case discountStores = "discount_stores"
                    case doctors
                    case doorToDoorSales = "door_to_door_sales"
                    case draperyWindowCoveringAndUpholsteryStores = "drapery_window_covering_and_upholstery_stores"
                    case drinkingPlaces = "drinking_places"
                    case drugStoresAndPharmacies = "drug_stores_and_pharmacies"
                    case drugsDrugProprietariesAndDruggistSundries = "drugs_drug_proprietaries_and_druggist_sundries"
                    case dryCleaners = "dry_cleaners"
                    case durableGoods = "durable_goods"
                    case dutyFreeStores = "duty_free_stores"
                    case eatingPlacesRestaurants = "eating_places_restaurants"
                    case educationalServices = "educational_services"
                    case electricRazorStores = "electric_razor_stores"
                    case electricalPartsAndEquipment = "electrical_parts_and_equipment"
                    case electricalServices = "electrical_services"
                    case electronicsRepairShops = "electronics_repair_shops"
                    case electronicsStores = "electronics_stores"
                    case elementarySecondarySchools = "elementary_secondary_schools"
                    case employmentTempAgencies = "employment_temp_agencies"
                    case equipmentRental = "equipment_rental"
                    case exterminatingServices = "exterminating_services"
                    case familyClothingStores = "family_clothing_stores"
                    case fastFoodRestaurants = "fast_food_restaurants"
                    case financialInstitutions = "financial_institutions"
                    case finesGovernmentAdministrativeEntities = "fines_government_administrative_entities"
                    case fireplaceFireplaceScreensAndAccessoriesStores = "fireplace_fireplace_screens_and_accessories_stores"
                    case floorCoveringStores = "floor_covering_stores"
                    case florists
                    case floristsSuppliesNurseryStockAndFlowers = "florists_supplies_nursery_stock_and_flowers"
                    case freezerAndLockerMeatProvisioners = "freezer_and_locker_meat_provisioners"
                    case fuelDealersNonAutomotive = "fuel_dealers_non_automotive"
                    case funeralServicesCrematories = "funeral_services_crematories"
                    case furnitureHomeFurnishingsAndEquipmentStoresExceptAppliances = "furniture_home_furnishings_and_equipment_stores_except_appliances"
                    case furnitureRepairRefinishing = "furniture_repair_refinishing"
                    case furriersAndFurShops = "furriers_and_fur_shops"
                    case generalServices = "general_services"
                    case giftCardNoveltyAndSouvenirShops = "gift_card_novelty_and_souvenir_shops"
                    case glassPaintAndWallpaperStores = "glass_paint_and_wallpaper_stores"
                    case glasswareCrystalStores = "glassware_crystal_stores"
                    case golfCoursesPublic = "golf_courses_public"
                    case governmentServices = "government_services"
                    case groceryStoresSupermarkets = "grocery_stores_supermarkets"
                    case hardwareEquipmentAndSupplies = "hardware_equipment_and_supplies"
                    case hardwareStores = "hardware_stores"
                    case healthAndBeautySpas = "health_and_beauty_spas"
                    case hearingAidsSalesAndSupplies = "hearing_aids_sales_and_supplies"
                    case heatingPlumbingAC = "heating_plumbing_a_c"
                    case hobbyToyAndGameShops = "hobby_toy_and_game_shops"
                    case homeSupplyWarehouseStores = "home_supply_warehouse_stores"
                    case hospitals
                    case hotelsMotelsAndResorts = "hotels_motels_and_resorts"
                    case householdApplianceStores = "household_appliance_stores"
                    case industrialSupplies = "industrial_supplies"
                    case informationRetrievalServices = "information_retrieval_services"
                    case insuranceDefault = "insurance_default"
                    case insuranceUnderwritingPremiums = "insurance_underwriting_premiums"
                    case intraCompanyPurchases = "intra_company_purchases"
                    case jewelryStoresWatchesClocksAndSilverwareStores = "jewelry_stores_watches_clocks_and_silverware_stores"
                    case landscapingServices = "landscaping_services"
                    case laundries
                    case laundryCleaningServices = "laundry_cleaning_services"
                    case legalServicesAttorneys = "legal_services_attorneys"
                    case luggageAndLeatherGoodsStores = "luggage_and_leather_goods_stores"
                    case lumberBuildingMaterialsStores = "lumber_building_materials_stores"
                    case manualCashDisburse = "manual_cash_disburse"
                    case marinasServiceAndSupplies = "marinas_service_and_supplies"
                    case masonryStoneworkAndPlaster = "masonry_stonework_and_plaster"
                    case massageParlors = "massage_parlors"
                    case medicalAndDentalLabs = "medical_and_dental_labs"
                    case medicalDentalOphthalmicAndHospitalEquipmentAndSupplies = "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
                    case medicalServices = "medical_services"
                    case membershipOrganizations = "membership_organizations"
                    case mensAndBoysClothingAndAccessoriesStores = "mens_and_boys_clothing_and_accessories_stores"
                    case mensWomensClothingStores = "mens_womens_clothing_stores"
                    case metalServiceCenters = "metal_service_centers"
                    case miscellaneous
                    case miscellaneousApparelAndAccessoryShops = "miscellaneous_apparel_and_accessory_shops"
                    case miscellaneousAutoDealers = "miscellaneous_auto_dealers"
                    case miscellaneousBusinessServices = "miscellaneous_business_services"
                    case miscellaneousFoodStores = "miscellaneous_food_stores"
                    case miscellaneousGeneralMerchandise = "miscellaneous_general_merchandise"
                    case miscellaneousGeneralServices = "miscellaneous_general_services"
                    case miscellaneousHomeFurnishingSpecialtyStores = "miscellaneous_home_furnishing_specialty_stores"
                    case miscellaneousPublishingAndPrinting = "miscellaneous_publishing_and_printing"
                    case miscellaneousRecreationServices = "miscellaneous_recreation_services"
                    case miscellaneousRepairShops = "miscellaneous_repair_shops"
                    case miscellaneousSpecialtyRetail = "miscellaneous_specialty_retail"
                    case mobileHomeDealers = "mobile_home_dealers"
                    case motionPictureTheaters = "motion_picture_theaters"
                    case motorFreightCarriersAndTrucking = "motor_freight_carriers_and_trucking"
                    case motorHomesDealers = "motor_homes_dealers"
                    case motorVehicleSuppliesAndNewParts = "motor_vehicle_supplies_and_new_parts"
                    case motorcycleShopsAndDealers = "motorcycle_shops_and_dealers"
                    case motorcycleShopsDealers = "motorcycle_shops_dealers"
                    case musicStoresMusicalInstrumentsPianosAndSheetMusic = "music_stores_musical_instruments_pianos_and_sheet_music"
                    case newsDealersAndNewsstands = "news_dealers_and_newsstands"
                    case nonFiMoneyOrders = "non_fi_money_orders"
                    case nonFiStoredValueCardPurchaseLoad = "non_fi_stored_value_card_purchase_load"
                    case nondurableGoods = "nondurable_goods"
                    case nurseriesLawnAndGardenSupplyStores = "nurseries_lawn_and_garden_supply_stores"
                    case nursingPersonalCare = "nursing_personal_care"
                    case officeAndCommercialFurniture = "office_and_commercial_furniture"
                    case opticiansEyeglasses = "opticians_eyeglasses"
                    case optometristsOphthalmologist = "optometrists_ophthalmologist"
                    case orthopedicGoodsProstheticDevices = "orthopedic_goods_prosthetic_devices"
                    case osteopaths
                    case packageStoresBeerWineAndLiquor = "package_stores_beer_wine_and_liquor"
                    case paintsVarnishesAndSupplies = "paints_varnishes_and_supplies"
                    case parkingLotsGarages = "parking_lots_garages"
                    case passengerRailways = "passenger_railways"
                    case pawnShops = "pawn_shops"
                    case petShopsPetFoodAndSupplies = "pet_shops_pet_food_and_supplies"
                    case petroleumAndPetroleumProducts = "petroleum_and_petroleum_products"
                    case photoDeveloping = "photo_developing"
                    case photographicPhotocopyMicrofilmEquipmentAndSupplies = "photographic_photocopy_microfilm_equipment_and_supplies"
                    case photographicStudios = "photographic_studios"
                    case pictureVideoProduction = "picture_video_production"
                    case pieceGoodsNotionsAndOtherDryGoods = "piece_goods_notions_and_other_dry_goods"
                    case plumbingHeatingEquipmentAndSupplies = "plumbing_heating_equipment_and_supplies"
                    case politicalOrganizations = "political_organizations"
                    case postalServicesGovernmentOnly = "postal_services_government_only"
                    case preciousStonesAndMetalsWatchesAndJewelry = "precious_stones_and_metals_watches_and_jewelry"
                    case professionalServices = "professional_services"
                    case publicWarehousingAndStorage = "public_warehousing_and_storage"
                    case quickCopyReproAndBlueprint = "quick_copy_repro_and_blueprint"
                    case railroads
                    case realEstateAgentsAndManagersRentals = "real_estate_agents_and_managers_rentals"
                    case recordStores = "record_stores"
                    case recreationalVehicleRentals = "recreational_vehicle_rentals"
                    case religiousGoodsStores = "religious_goods_stores"
                    case religiousOrganizations = "religious_organizations"
                    case roofingSidingSheetMetal = "roofing_siding_sheet_metal"
                    case secretarialSupportServices = "secretarial_support_services"
                    case securityBrokersDealers = "security_brokers_dealers"
                    case serviceStations = "service_stations"
                    case sewingNeedleworkFabricAndPieceGoodsStores = "sewing_needlework_fabric_and_piece_goods_stores"
                    case shoeRepairHatCleaning = "shoe_repair_hat_cleaning"
                    case shoeStores = "shoe_stores"
                    case smallApplianceRepair = "small_appliance_repair"
                    case snowmobileDealers = "snowmobile_dealers"
                    case specialTradeServices = "special_trade_services"
                    case specialtyCleaning = "specialty_cleaning"
                    case sportingGoodsStores = "sporting_goods_stores"
                    case sportingRecreationCamps = "sporting_recreation_camps"
                    case sportsAndRidingApparelStores = "sports_and_riding_apparel_stores"
                    case sportsClubsFields = "sports_clubs_fields"
                    case stampAndCoinStores = "stamp_and_coin_stores"
                    case stationaryOfficeSuppliesPrintingAndWritingPaper = "stationary_office_supplies_printing_and_writing_paper"
                    case stationeryStoresOfficeAndSchoolSupplyStores = "stationery_stores_office_and_school_supply_stores"
                    case swimmingPoolsSales = "swimming_pools_sales"
                    case tUiTravelGermany = "t_ui_travel_germany"
                    case tailorsAlterations = "tailors_alterations"
                    case taxPaymentsGovernmentAgencies = "tax_payments_government_agencies"
                    case taxPreparationServices = "tax_preparation_services"
                    case taxicabsLimousines = "taxicabs_limousines"
                    case telecommunicationEquipmentAndTelephoneSales = "telecommunication_equipment_and_telephone_sales"
                    case telecommunicationServices = "telecommunication_services"
                    case telegraphServices = "telegraph_services"
                    case tentAndAwningShops = "tent_and_awning_shops"
                    case testingLaboratories = "testing_laboratories"
                    case theatricalTicketAgencies = "theatrical_ticket_agencies"
                    case timeshares
                    case tireRetreadingAndRepair = "tire_retreading_and_repair"
                    case tollsBridgeFees = "tolls_bridge_fees"
                    case touristAttractionsAndExhibits = "tourist_attractions_and_exhibits"
                    case towingServices = "towing_services"
                    case trailerParksCampgrounds = "trailer_parks_campgrounds"
                    case transportationServices = "transportation_services"
                    case travelAgenciesTourOperators = "travel_agencies_tour_operators"
                    case truckStopIteration = "truck_stop_iteration"
                    case truckUtilityTrailerRentals = "truck_utility_trailer_rentals"
                    case typesettingPlateMakingAndRelatedServices = "typesetting_plate_making_and_related_services"
                    case typewriterStores = "typewriter_stores"
                    case uSFederalGovernmentAgenciesOrDepartments = "u_s_federal_government_agencies_or_departments"
                    case uniformsCommercialClothing = "uniforms_commercial_clothing"
                    case usedMerchandiseAndSecondhandStores = "used_merchandise_and_secondhand_stores"
                    case utilities
                    case varietyStores = "variety_stores"
                    case veterinaryServices = "veterinary_services"
                    case videoAmusementGameSupplies = "video_amusement_game_supplies"
                    case videoGameArcades = "video_game_arcades"
                    case videoTapeRentalStores = "video_tape_rental_stores"
                    case vocationalTradeSchools = "vocational_trade_schools"
                    case watchJewelryRepair = "watch_jewelry_repair"
                    case weldingRepair = "welding_repair"
                    case wholesaleClubs = "wholesale_clubs"
                    case wigAndToupeeStores = "wig_and_toupee_stores"
                    case wiresMoneyOrders = "wires_money_orders"
                    case womensAccessoryAndSpecialtyShops = "womens_accessory_and_specialty_shops"
                    case womensReadyToWearStores = "womens_ready_to_wear_stores"
                    case wreckingAndSalvageYards = "wrecking_and_salvage_yards"
                }

                public enum BlockedCategory: String, Codable, CaseIterable {
                    case acRefrigerationRepair = "ac_refrigeration_repair"
                    case accountingBookkeepingServices = "accounting_bookkeeping_services"
                    case advertisingServices = "advertising_services"
                    case agriculturalCooperative = "agricultural_cooperative"
                    case airlinesAirCarriers = "airlines_air_carriers"
                    case airportsFlyingFields = "airports_flying_fields"
                    case ambulanceServices = "ambulance_services"
                    case amusementParksCarnivals = "amusement_parks_carnivals"
                    case antiqueReproductions = "antique_reproductions"
                    case antiqueShops = "antique_shops"
                    case aquariums
                    case architecturalSurveyingServices = "architectural_surveying_services"
                    case artDealersAndGalleries = "art_dealers_and_galleries"
                    case artistsSupplyAndCraftShops = "artists_supply_and_craft_shops"
                    case autoAndHomeSupplyStores = "auto_and_home_supply_stores"
                    case autoBodyRepairShops = "auto_body_repair_shops"
                    case autoPaintShops = "auto_paint_shops"
                    case autoServiceShops = "auto_service_shops"
                    case automatedCashDisburse = "automated_cash_disburse"
                    case automatedFuelDispensers = "automated_fuel_dispensers"
                    case automobileAssociations = "automobile_associations"
                    case automotivePartsAndAccessoriesStores = "automotive_parts_and_accessories_stores"
                    case automotiveTireStores = "automotive_tire_stores"
                    case bailAndBondPayments = "bail_and_bond_payments"
                    case bakeries
                    case bandsOrchestras = "bands_orchestras"
                    case barberAndBeautyShops = "barber_and_beauty_shops"
                    case bettingCasinoGambling = "betting_casino_gambling"
                    case bicycleShops = "bicycle_shops"
                    case billiardPoolEstablishments = "billiard_pool_establishments"
                    case boatDealers = "boat_dealers"
                    case boatRentalsAndLeases = "boat_rentals_and_leases"
                    case bookStores = "book_stores"
                    case booksPeriodicalsAndNewspapers = "books_periodicals_and_newspapers"
                    case bowlingAlleys = "bowling_alleys"
                    case busLines = "bus_lines"
                    case businessSecretarialSchools = "business_secretarial_schools"
                    case buyingShoppingServices = "buying_shopping_services"
                    case cableSatelliteAndOtherPayTelevisionAndRadio = "cable_satellite_and_other_pay_television_and_radio"
                    case cameraAndPhotographicSupplyStores = "camera_and_photographic_supply_stores"
                    case candyNutAndConfectioneryStores = "candy_nut_and_confectionery_stores"
                    case carAndTruckDealersNewUsed = "car_and_truck_dealers_new_used"
                    case carAndTruckDealersUsedOnly = "car_and_truck_dealers_used_only"
                    case carRentalAgencies = "car_rental_agencies"
                    case carWashes = "car_washes"
                    case carpentryServices = "carpentry_services"
                    case carpetUpholsteryCleaning = "carpet_upholstery_cleaning"
                    case caterers
                    case charitableAndSocialServiceOrganizationsFundraising = "charitable_and_social_service_organizations_fundraising"
                    case chemicalsAndAlliedProducts = "chemicals_and_allied_products"
                    case childCareServices = "child_care_services"
                    case childrensAndInfantsWearStores = "childrens_and_infants_wear_stores"
                    case chiropodistsPodiatrists = "chiropodists_podiatrists"
                    case chiropractors
                    case cigarStoresAndStands = "cigar_stores_and_stands"
                    case civicSocialFraternalAssociations = "civic_social_fraternal_associations"
                    case cleaningAndMaintenance = "cleaning_and_maintenance"
                    case clothingRental = "clothing_rental"
                    case collegesUniversities = "colleges_universities"
                    case commercialEquipment = "commercial_equipment"
                    case commercialFootwear = "commercial_footwear"
                    case commercialPhotographyArtAndGraphics = "commercial_photography_art_and_graphics"
                    case commuterTransportAndFerries = "commuter_transport_and_ferries"
                    case computerNetworkServices = "computer_network_services"
                    case computerProgramming = "computer_programming"
                    case computerRepair = "computer_repair"
                    case computerSoftwareStores = "computer_software_stores"
                    case computersPeripheralsAndSoftware = "computers_peripherals_and_software"
                    case concreteWorkServices = "concrete_work_services"
                    case constructionMaterials = "construction_materials"
                    case consultingPublicRelations = "consulting_public_relations"
                    case correspondenceSchools = "correspondence_schools"
                    case cosmeticStores = "cosmetic_stores"
                    case counselingServices = "counseling_services"
                    case countryClubs = "country_clubs"
                    case courierServices = "courier_services"
                    case courtCosts = "court_costs"
                    case creditReportingAgencies = "credit_reporting_agencies"
                    case cruiseLines = "cruise_lines"
                    case dairyProductsStores = "dairy_products_stores"
                    case danceHallStudiosSchools = "dance_hall_studios_schools"
                    case datingEscortServices = "dating_escort_services"
                    case dentistsOrthodontists = "dentists_orthodontists"
                    case departmentStores = "department_stores"
                    case detectiveAgencies = "detective_agencies"
                    case digitalGoodsApplications = "digital_goods_applications"
                    case digitalGoodsGames = "digital_goods_games"
                    case digitalGoodsLargeVolume = "digital_goods_large_volume"
                    case digitalGoodsMedia = "digital_goods_media"
                    case directMarketingCatalogMerchant = "direct_marketing_catalog_merchant"
                    case directMarketingCombinationCatalogAndRetailMerchant = "direct_marketing_combination_catalog_and_retail_merchant"
                    case directMarketingInboundTelemarketing = "direct_marketing_inbound_telemarketing"
                    case directMarketingInsuranceServices = "direct_marketing_insurance_services"
                    case directMarketingOther = "direct_marketing_other"
                    case directMarketingOutboundTelemarketing = "direct_marketing_outbound_telemarketing"
                    case directMarketingSubscription = "direct_marketing_subscription"
                    case directMarketingTravel = "direct_marketing_travel"
                    case discountStores = "discount_stores"
                    case doctors
                    case doorToDoorSales = "door_to_door_sales"
                    case draperyWindowCoveringAndUpholsteryStores = "drapery_window_covering_and_upholstery_stores"
                    case drinkingPlaces = "drinking_places"
                    case drugStoresAndPharmacies = "drug_stores_and_pharmacies"
                    case drugsDrugProprietariesAndDruggistSundries = "drugs_drug_proprietaries_and_druggist_sundries"
                    case dryCleaners = "dry_cleaners"
                    case durableGoods = "durable_goods"
                    case dutyFreeStores = "duty_free_stores"
                    case eatingPlacesRestaurants = "eating_places_restaurants"
                    case educationalServices = "educational_services"
                    case electricRazorStores = "electric_razor_stores"
                    case electricalPartsAndEquipment = "electrical_parts_and_equipment"
                    case electricalServices = "electrical_services"
                    case electronicsRepairShops = "electronics_repair_shops"
                    case electronicsStores = "electronics_stores"
                    case elementarySecondarySchools = "elementary_secondary_schools"
                    case employmentTempAgencies = "employment_temp_agencies"
                    case equipmentRental = "equipment_rental"
                    case exterminatingServices = "exterminating_services"
                    case familyClothingStores = "family_clothing_stores"
                    case fastFoodRestaurants = "fast_food_restaurants"
                    case financialInstitutions = "financial_institutions"
                    case finesGovernmentAdministrativeEntities = "fines_government_administrative_entities"
                    case fireplaceFireplaceScreensAndAccessoriesStores = "fireplace_fireplace_screens_and_accessories_stores"
                    case floorCoveringStores = "floor_covering_stores"
                    case florists
                    case floristsSuppliesNurseryStockAndFlowers = "florists_supplies_nursery_stock_and_flowers"
                    case freezerAndLockerMeatProvisioners = "freezer_and_locker_meat_provisioners"
                    case fuelDealersNonAutomotive = "fuel_dealers_non_automotive"
                    case funeralServicesCrematories = "funeral_services_crematories"
                    case furnitureHomeFurnishingsAndEquipmentStoresExceptAppliances = "furniture_home_furnishings_and_equipment_stores_except_appliances"
                    case furnitureRepairRefinishing = "furniture_repair_refinishing"
                    case furriersAndFurShops = "furriers_and_fur_shops"
                    case generalServices = "general_services"
                    case giftCardNoveltyAndSouvenirShops = "gift_card_novelty_and_souvenir_shops"
                    case glassPaintAndWallpaperStores = "glass_paint_and_wallpaper_stores"
                    case glasswareCrystalStores = "glassware_crystal_stores"
                    case golfCoursesPublic = "golf_courses_public"
                    case governmentServices = "government_services"
                    case groceryStoresSupermarkets = "grocery_stores_supermarkets"
                    case hardwareEquipmentAndSupplies = "hardware_equipment_and_supplies"
                    case hardwareStores = "hardware_stores"
                    case healthAndBeautySpas = "health_and_beauty_spas"
                    case hearingAidsSalesAndSupplies = "hearing_aids_sales_and_supplies"
                    case heatingPlumbingAC = "heating_plumbing_a_c"
                    case hobbyToyAndGameShops = "hobby_toy_and_game_shops"
                    case homeSupplyWarehouseStores = "home_supply_warehouse_stores"
                    case hospitals
                    case hotelsMotelsAndResorts = "hotels_motels_and_resorts"
                    case householdApplianceStores = "household_appliance_stores"
                    case industrialSupplies = "industrial_supplies"
                    case informationRetrievalServices = "information_retrieval_services"
                    case insuranceDefault = "insurance_default"
                    case insuranceUnderwritingPremiums = "insurance_underwriting_premiums"
                    case intraCompanyPurchases = "intra_company_purchases"
                    case jewelryStoresWatchesClocksAndSilverwareStores = "jewelry_stores_watches_clocks_and_silverware_stores"
                    case landscapingServices = "landscaping_services"
                    case laundries
                    case laundryCleaningServices = "laundry_cleaning_services"
                    case legalServicesAttorneys = "legal_services_attorneys"
                    case luggageAndLeatherGoodsStores = "luggage_and_leather_goods_stores"
                    case lumberBuildingMaterialsStores = "lumber_building_materials_stores"
                    case manualCashDisburse = "manual_cash_disburse"
                    case marinasServiceAndSupplies = "marinas_service_and_supplies"
                    case masonryStoneworkAndPlaster = "masonry_stonework_and_plaster"
                    case massageParlors = "massage_parlors"
                    case medicalAndDentalLabs = "medical_and_dental_labs"
                    case medicalDentalOphthalmicAndHospitalEquipmentAndSupplies = "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
                    case medicalServices = "medical_services"
                    case membershipOrganizations = "membership_organizations"
                    case mensAndBoysClothingAndAccessoriesStores = "mens_and_boys_clothing_and_accessories_stores"
                    case mensWomensClothingStores = "mens_womens_clothing_stores"
                    case metalServiceCenters = "metal_service_centers"
                    case miscellaneous
                    case miscellaneousApparelAndAccessoryShops = "miscellaneous_apparel_and_accessory_shops"
                    case miscellaneousAutoDealers = "miscellaneous_auto_dealers"
                    case miscellaneousBusinessServices = "miscellaneous_business_services"
                    case miscellaneousFoodStores = "miscellaneous_food_stores"
                    case miscellaneousGeneralMerchandise = "miscellaneous_general_merchandise"
                    case miscellaneousGeneralServices = "miscellaneous_general_services"
                    case miscellaneousHomeFurnishingSpecialtyStores = "miscellaneous_home_furnishing_specialty_stores"
                    case miscellaneousPublishingAndPrinting = "miscellaneous_publishing_and_printing"
                    case miscellaneousRecreationServices = "miscellaneous_recreation_services"
                    case miscellaneousRepairShops = "miscellaneous_repair_shops"
                    case miscellaneousSpecialtyRetail = "miscellaneous_specialty_retail"
                    case mobileHomeDealers = "mobile_home_dealers"
                    case motionPictureTheaters = "motion_picture_theaters"
                    case motorFreightCarriersAndTrucking = "motor_freight_carriers_and_trucking"
                    case motorHomesDealers = "motor_homes_dealers"
                    case motorVehicleSuppliesAndNewParts = "motor_vehicle_supplies_and_new_parts"
                    case motorcycleShopsAndDealers = "motorcycle_shops_and_dealers"
                    case motorcycleShopsDealers = "motorcycle_shops_dealers"
                    case musicStoresMusicalInstrumentsPianosAndSheetMusic = "music_stores_musical_instruments_pianos_and_sheet_music"
                    case newsDealersAndNewsstands = "news_dealers_and_newsstands"
                    case nonFiMoneyOrders = "non_fi_money_orders"
                    case nonFiStoredValueCardPurchaseLoad = "non_fi_stored_value_card_purchase_load"
                    case nondurableGoods = "nondurable_goods"
                    case nurseriesLawnAndGardenSupplyStores = "nurseries_lawn_and_garden_supply_stores"
                    case nursingPersonalCare = "nursing_personal_care"
                    case officeAndCommercialFurniture = "office_and_commercial_furniture"
                    case opticiansEyeglasses = "opticians_eyeglasses"
                    case optometristsOphthalmologist = "optometrists_ophthalmologist"
                    case orthopedicGoodsProstheticDevices = "orthopedic_goods_prosthetic_devices"
                    case osteopaths
                    case packageStoresBeerWineAndLiquor = "package_stores_beer_wine_and_liquor"
                    case paintsVarnishesAndSupplies = "paints_varnishes_and_supplies"
                    case parkingLotsGarages = "parking_lots_garages"
                    case passengerRailways = "passenger_railways"
                    case pawnShops = "pawn_shops"
                    case petShopsPetFoodAndSupplies = "pet_shops_pet_food_and_supplies"
                    case petroleumAndPetroleumProducts = "petroleum_and_petroleum_products"
                    case photoDeveloping = "photo_developing"
                    case photographicPhotocopyMicrofilmEquipmentAndSupplies = "photographic_photocopy_microfilm_equipment_and_supplies"
                    case photographicStudios = "photographic_studios"
                    case pictureVideoProduction = "picture_video_production"
                    case pieceGoodsNotionsAndOtherDryGoods = "piece_goods_notions_and_other_dry_goods"
                    case plumbingHeatingEquipmentAndSupplies = "plumbing_heating_equipment_and_supplies"
                    case politicalOrganizations = "political_organizations"
                    case postalServicesGovernmentOnly = "postal_services_government_only"
                    case preciousStonesAndMetalsWatchesAndJewelry = "precious_stones_and_metals_watches_and_jewelry"
                    case professionalServices = "professional_services"
                    case publicWarehousingAndStorage = "public_warehousing_and_storage"
                    case quickCopyReproAndBlueprint = "quick_copy_repro_and_blueprint"
                    case railroads
                    case realEstateAgentsAndManagersRentals = "real_estate_agents_and_managers_rentals"
                    case recordStores = "record_stores"
                    case recreationalVehicleRentals = "recreational_vehicle_rentals"
                    case religiousGoodsStores = "religious_goods_stores"
                    case religiousOrganizations = "religious_organizations"
                    case roofingSidingSheetMetal = "roofing_siding_sheet_metal"
                    case secretarialSupportServices = "secretarial_support_services"
                    case securityBrokersDealers = "security_brokers_dealers"
                    case serviceStations = "service_stations"
                    case sewingNeedleworkFabricAndPieceGoodsStores = "sewing_needlework_fabric_and_piece_goods_stores"
                    case shoeRepairHatCleaning = "shoe_repair_hat_cleaning"
                    case shoeStores = "shoe_stores"
                    case smallApplianceRepair = "small_appliance_repair"
                    case snowmobileDealers = "snowmobile_dealers"
                    case specialTradeServices = "special_trade_services"
                    case specialtyCleaning = "specialty_cleaning"
                    case sportingGoodsStores = "sporting_goods_stores"
                    case sportingRecreationCamps = "sporting_recreation_camps"
                    case sportsAndRidingApparelStores = "sports_and_riding_apparel_stores"
                    case sportsClubsFields = "sports_clubs_fields"
                    case stampAndCoinStores = "stamp_and_coin_stores"
                    case stationaryOfficeSuppliesPrintingAndWritingPaper = "stationary_office_supplies_printing_and_writing_paper"
                    case stationeryStoresOfficeAndSchoolSupplyStores = "stationery_stores_office_and_school_supply_stores"
                    case swimmingPoolsSales = "swimming_pools_sales"
                    case tUiTravelGermany = "t_ui_travel_germany"
                    case tailorsAlterations = "tailors_alterations"
                    case taxPaymentsGovernmentAgencies = "tax_payments_government_agencies"
                    case taxPreparationServices = "tax_preparation_services"
                    case taxicabsLimousines = "taxicabs_limousines"
                    case telecommunicationEquipmentAndTelephoneSales = "telecommunication_equipment_and_telephone_sales"
                    case telecommunicationServices = "telecommunication_services"
                    case telegraphServices = "telegraph_services"
                    case tentAndAwningShops = "tent_and_awning_shops"
                    case testingLaboratories = "testing_laboratories"
                    case theatricalTicketAgencies = "theatrical_ticket_agencies"
                    case timeshares
                    case tireRetreadingAndRepair = "tire_retreading_and_repair"
                    case tollsBridgeFees = "tolls_bridge_fees"
                    case touristAttractionsAndExhibits = "tourist_attractions_and_exhibits"
                    case towingServices = "towing_services"
                    case trailerParksCampgrounds = "trailer_parks_campgrounds"
                    case transportationServices = "transportation_services"
                    case travelAgenciesTourOperators = "travel_agencies_tour_operators"
                    case truckStopIteration = "truck_stop_iteration"
                    case truckUtilityTrailerRentals = "truck_utility_trailer_rentals"
                    case typesettingPlateMakingAndRelatedServices = "typesetting_plate_making_and_related_services"
                    case typewriterStores = "typewriter_stores"
                    case uSFederalGovernmentAgenciesOrDepartments = "u_s_federal_government_agencies_or_departments"
                    case uniformsCommercialClothing = "uniforms_commercial_clothing"
                    case usedMerchandiseAndSecondhandStores = "used_merchandise_and_secondhand_stores"
                    case utilities
                    case varietyStores = "variety_stores"
                    case veterinaryServices = "veterinary_services"
                    case videoAmusementGameSupplies = "video_amusement_game_supplies"
                    case videoGameArcades = "video_game_arcades"
                    case videoTapeRentalStores = "video_tape_rental_stores"
                    case vocationalTradeSchools = "vocational_trade_schools"
                    case watchJewelryRepair = "watch_jewelry_repair"
                    case weldingRepair = "welding_repair"
                    case wholesaleClubs = "wholesale_clubs"
                    case wigAndToupeeStores = "wig_and_toupee_stores"
                    case wiresMoneyOrders = "wires_money_orders"
                    case womensAccessoryAndSpecialtyShops = "womens_accessory_and_specialty_shops"
                    case womensReadyToWearStores = "womens_ready_to_wear_stores"
                    case wreckingAndSalvageYards = "wrecking_and_salvage_yards"
                }

                /// Spending_limits_param
                public struct SpendingLimit: Encodable {
                    public var amount: Int
                    public var categories: [Category]?
                    public var interval: Interval

                    public enum Category: String, Codable, CaseIterable {
                        case acRefrigerationRepair = "ac_refrigeration_repair"
                        case accountingBookkeepingServices = "accounting_bookkeeping_services"
                        case advertisingServices = "advertising_services"
                        case agriculturalCooperative = "agricultural_cooperative"
                        case airlinesAirCarriers = "airlines_air_carriers"
                        case airportsFlyingFields = "airports_flying_fields"
                        case ambulanceServices = "ambulance_services"
                        case amusementParksCarnivals = "amusement_parks_carnivals"
                        case antiqueReproductions = "antique_reproductions"
                        case antiqueShops = "antique_shops"
                        case aquariums
                        case architecturalSurveyingServices = "architectural_surveying_services"
                        case artDealersAndGalleries = "art_dealers_and_galleries"
                        case artistsSupplyAndCraftShops = "artists_supply_and_craft_shops"
                        case autoAndHomeSupplyStores = "auto_and_home_supply_stores"
                        case autoBodyRepairShops = "auto_body_repair_shops"
                        case autoPaintShops = "auto_paint_shops"
                        case autoServiceShops = "auto_service_shops"
                        case automatedCashDisburse = "automated_cash_disburse"
                        case automatedFuelDispensers = "automated_fuel_dispensers"
                        case automobileAssociations = "automobile_associations"
                        case automotivePartsAndAccessoriesStores = "automotive_parts_and_accessories_stores"
                        case automotiveTireStores = "automotive_tire_stores"
                        case bailAndBondPayments = "bail_and_bond_payments"
                        case bakeries
                        case bandsOrchestras = "bands_orchestras"
                        case barberAndBeautyShops = "barber_and_beauty_shops"
                        case bettingCasinoGambling = "betting_casino_gambling"
                        case bicycleShops = "bicycle_shops"
                        case billiardPoolEstablishments = "billiard_pool_establishments"
                        case boatDealers = "boat_dealers"
                        case boatRentalsAndLeases = "boat_rentals_and_leases"
                        case bookStores = "book_stores"
                        case booksPeriodicalsAndNewspapers = "books_periodicals_and_newspapers"
                        case bowlingAlleys = "bowling_alleys"
                        case busLines = "bus_lines"
                        case businessSecretarialSchools = "business_secretarial_schools"
                        case buyingShoppingServices = "buying_shopping_services"
                        case cableSatelliteAndOtherPayTelevisionAndRadio = "cable_satellite_and_other_pay_television_and_radio"
                        case cameraAndPhotographicSupplyStores = "camera_and_photographic_supply_stores"
                        case candyNutAndConfectioneryStores = "candy_nut_and_confectionery_stores"
                        case carAndTruckDealersNewUsed = "car_and_truck_dealers_new_used"
                        case carAndTruckDealersUsedOnly = "car_and_truck_dealers_used_only"
                        case carRentalAgencies = "car_rental_agencies"
                        case carWashes = "car_washes"
                        case carpentryServices = "carpentry_services"
                        case carpetUpholsteryCleaning = "carpet_upholstery_cleaning"
                        case caterers
                        case charitableAndSocialServiceOrganizationsFundraising = "charitable_and_social_service_organizations_fundraising"
                        case chemicalsAndAlliedProducts = "chemicals_and_allied_products"
                        case childCareServices = "child_care_services"
                        case childrensAndInfantsWearStores = "childrens_and_infants_wear_stores"
                        case chiropodistsPodiatrists = "chiropodists_podiatrists"
                        case chiropractors
                        case cigarStoresAndStands = "cigar_stores_and_stands"
                        case civicSocialFraternalAssociations = "civic_social_fraternal_associations"
                        case cleaningAndMaintenance = "cleaning_and_maintenance"
                        case clothingRental = "clothing_rental"
                        case collegesUniversities = "colleges_universities"
                        case commercialEquipment = "commercial_equipment"
                        case commercialFootwear = "commercial_footwear"
                        case commercialPhotographyArtAndGraphics = "commercial_photography_art_and_graphics"
                        case commuterTransportAndFerries = "commuter_transport_and_ferries"
                        case computerNetworkServices = "computer_network_services"
                        case computerProgramming = "computer_programming"
                        case computerRepair = "computer_repair"
                        case computerSoftwareStores = "computer_software_stores"
                        case computersPeripheralsAndSoftware = "computers_peripherals_and_software"
                        case concreteWorkServices = "concrete_work_services"
                        case constructionMaterials = "construction_materials"
                        case consultingPublicRelations = "consulting_public_relations"
                        case correspondenceSchools = "correspondence_schools"
                        case cosmeticStores = "cosmetic_stores"
                        case counselingServices = "counseling_services"
                        case countryClubs = "country_clubs"
                        case courierServices = "courier_services"
                        case courtCosts = "court_costs"
                        case creditReportingAgencies = "credit_reporting_agencies"
                        case cruiseLines = "cruise_lines"
                        case dairyProductsStores = "dairy_products_stores"
                        case danceHallStudiosSchools = "dance_hall_studios_schools"
                        case datingEscortServices = "dating_escort_services"
                        case dentistsOrthodontists = "dentists_orthodontists"
                        case departmentStores = "department_stores"
                        case detectiveAgencies = "detective_agencies"
                        case digitalGoodsApplications = "digital_goods_applications"
                        case digitalGoodsGames = "digital_goods_games"
                        case digitalGoodsLargeVolume = "digital_goods_large_volume"
                        case digitalGoodsMedia = "digital_goods_media"
                        case directMarketingCatalogMerchant = "direct_marketing_catalog_merchant"
                        case directMarketingCombinationCatalogAndRetailMerchant = "direct_marketing_combination_catalog_and_retail_merchant"
                        case directMarketingInboundTelemarketing = "direct_marketing_inbound_telemarketing"
                        case directMarketingInsuranceServices = "direct_marketing_insurance_services"
                        case directMarketingOther = "direct_marketing_other"
                        case directMarketingOutboundTelemarketing = "direct_marketing_outbound_telemarketing"
                        case directMarketingSubscription = "direct_marketing_subscription"
                        case directMarketingTravel = "direct_marketing_travel"
                        case discountStores = "discount_stores"
                        case doctors
                        case doorToDoorSales = "door_to_door_sales"
                        case draperyWindowCoveringAndUpholsteryStores = "drapery_window_covering_and_upholstery_stores"
                        case drinkingPlaces = "drinking_places"
                        case drugStoresAndPharmacies = "drug_stores_and_pharmacies"
                        case drugsDrugProprietariesAndDruggistSundries = "drugs_drug_proprietaries_and_druggist_sundries"
                        case dryCleaners = "dry_cleaners"
                        case durableGoods = "durable_goods"
                        case dutyFreeStores = "duty_free_stores"
                        case eatingPlacesRestaurants = "eating_places_restaurants"
                        case educationalServices = "educational_services"
                        case electricRazorStores = "electric_razor_stores"
                        case electricalPartsAndEquipment = "electrical_parts_and_equipment"
                        case electricalServices = "electrical_services"
                        case electronicsRepairShops = "electronics_repair_shops"
                        case electronicsStores = "electronics_stores"
                        case elementarySecondarySchools = "elementary_secondary_schools"
                        case employmentTempAgencies = "employment_temp_agencies"
                        case equipmentRental = "equipment_rental"
                        case exterminatingServices = "exterminating_services"
                        case familyClothingStores = "family_clothing_stores"
                        case fastFoodRestaurants = "fast_food_restaurants"
                        case financialInstitutions = "financial_institutions"
                        case finesGovernmentAdministrativeEntities = "fines_government_administrative_entities"
                        case fireplaceFireplaceScreensAndAccessoriesStores = "fireplace_fireplace_screens_and_accessories_stores"
                        case floorCoveringStores = "floor_covering_stores"
                        case florists
                        case floristsSuppliesNurseryStockAndFlowers = "florists_supplies_nursery_stock_and_flowers"
                        case freezerAndLockerMeatProvisioners = "freezer_and_locker_meat_provisioners"
                        case fuelDealersNonAutomotive = "fuel_dealers_non_automotive"
                        case funeralServicesCrematories = "funeral_services_crematories"
                        case furnitureHomeFurnishingsAndEquipmentStoresExceptAppliances = "furniture_home_furnishings_and_equipment_stores_except_appliances"
                        case furnitureRepairRefinishing = "furniture_repair_refinishing"
                        case furriersAndFurShops = "furriers_and_fur_shops"
                        case generalServices = "general_services"
                        case giftCardNoveltyAndSouvenirShops = "gift_card_novelty_and_souvenir_shops"
                        case glassPaintAndWallpaperStores = "glass_paint_and_wallpaper_stores"
                        case glasswareCrystalStores = "glassware_crystal_stores"
                        case golfCoursesPublic = "golf_courses_public"
                        case governmentServices = "government_services"
                        case groceryStoresSupermarkets = "grocery_stores_supermarkets"
                        case hardwareEquipmentAndSupplies = "hardware_equipment_and_supplies"
                        case hardwareStores = "hardware_stores"
                        case healthAndBeautySpas = "health_and_beauty_spas"
                        case hearingAidsSalesAndSupplies = "hearing_aids_sales_and_supplies"
                        case heatingPlumbingAC = "heating_plumbing_a_c"
                        case hobbyToyAndGameShops = "hobby_toy_and_game_shops"
                        case homeSupplyWarehouseStores = "home_supply_warehouse_stores"
                        case hospitals
                        case hotelsMotelsAndResorts = "hotels_motels_and_resorts"
                        case householdApplianceStores = "household_appliance_stores"
                        case industrialSupplies = "industrial_supplies"
                        case informationRetrievalServices = "information_retrieval_services"
                        case insuranceDefault = "insurance_default"
                        case insuranceUnderwritingPremiums = "insurance_underwriting_premiums"
                        case intraCompanyPurchases = "intra_company_purchases"
                        case jewelryStoresWatchesClocksAndSilverwareStores = "jewelry_stores_watches_clocks_and_silverware_stores"
                        case landscapingServices = "landscaping_services"
                        case laundries
                        case laundryCleaningServices = "laundry_cleaning_services"
                        case legalServicesAttorneys = "legal_services_attorneys"
                        case luggageAndLeatherGoodsStores = "luggage_and_leather_goods_stores"
                        case lumberBuildingMaterialsStores = "lumber_building_materials_stores"
                        case manualCashDisburse = "manual_cash_disburse"
                        case marinasServiceAndSupplies = "marinas_service_and_supplies"
                        case masonryStoneworkAndPlaster = "masonry_stonework_and_plaster"
                        case massageParlors = "massage_parlors"
                        case medicalAndDentalLabs = "medical_and_dental_labs"
                        case medicalDentalOphthalmicAndHospitalEquipmentAndSupplies = "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
                        case medicalServices = "medical_services"
                        case membershipOrganizations = "membership_organizations"
                        case mensAndBoysClothingAndAccessoriesStores = "mens_and_boys_clothing_and_accessories_stores"
                        case mensWomensClothingStores = "mens_womens_clothing_stores"
                        case metalServiceCenters = "metal_service_centers"
                        case miscellaneous
                        case miscellaneousApparelAndAccessoryShops = "miscellaneous_apparel_and_accessory_shops"
                        case miscellaneousAutoDealers = "miscellaneous_auto_dealers"
                        case miscellaneousBusinessServices = "miscellaneous_business_services"
                        case miscellaneousFoodStores = "miscellaneous_food_stores"
                        case miscellaneousGeneralMerchandise = "miscellaneous_general_merchandise"
                        case miscellaneousGeneralServices = "miscellaneous_general_services"
                        case miscellaneousHomeFurnishingSpecialtyStores = "miscellaneous_home_furnishing_specialty_stores"
                        case miscellaneousPublishingAndPrinting = "miscellaneous_publishing_and_printing"
                        case miscellaneousRecreationServices = "miscellaneous_recreation_services"
                        case miscellaneousRepairShops = "miscellaneous_repair_shops"
                        case miscellaneousSpecialtyRetail = "miscellaneous_specialty_retail"
                        case mobileHomeDealers = "mobile_home_dealers"
                        case motionPictureTheaters = "motion_picture_theaters"
                        case motorFreightCarriersAndTrucking = "motor_freight_carriers_and_trucking"
                        case motorHomesDealers = "motor_homes_dealers"
                        case motorVehicleSuppliesAndNewParts = "motor_vehicle_supplies_and_new_parts"
                        case motorcycleShopsAndDealers = "motorcycle_shops_and_dealers"
                        case motorcycleShopsDealers = "motorcycle_shops_dealers"
                        case musicStoresMusicalInstrumentsPianosAndSheetMusic = "music_stores_musical_instruments_pianos_and_sheet_music"
                        case newsDealersAndNewsstands = "news_dealers_and_newsstands"
                        case nonFiMoneyOrders = "non_fi_money_orders"
                        case nonFiStoredValueCardPurchaseLoad = "non_fi_stored_value_card_purchase_load"
                        case nondurableGoods = "nondurable_goods"
                        case nurseriesLawnAndGardenSupplyStores = "nurseries_lawn_and_garden_supply_stores"
                        case nursingPersonalCare = "nursing_personal_care"
                        case officeAndCommercialFurniture = "office_and_commercial_furniture"
                        case opticiansEyeglasses = "opticians_eyeglasses"
                        case optometristsOphthalmologist = "optometrists_ophthalmologist"
                        case orthopedicGoodsProstheticDevices = "orthopedic_goods_prosthetic_devices"
                        case osteopaths
                        case packageStoresBeerWineAndLiquor = "package_stores_beer_wine_and_liquor"
                        case paintsVarnishesAndSupplies = "paints_varnishes_and_supplies"
                        case parkingLotsGarages = "parking_lots_garages"
                        case passengerRailways = "passenger_railways"
                        case pawnShops = "pawn_shops"
                        case petShopsPetFoodAndSupplies = "pet_shops_pet_food_and_supplies"
                        case petroleumAndPetroleumProducts = "petroleum_and_petroleum_products"
                        case photoDeveloping = "photo_developing"
                        case photographicPhotocopyMicrofilmEquipmentAndSupplies = "photographic_photocopy_microfilm_equipment_and_supplies"
                        case photographicStudios = "photographic_studios"
                        case pictureVideoProduction = "picture_video_production"
                        case pieceGoodsNotionsAndOtherDryGoods = "piece_goods_notions_and_other_dry_goods"
                        case plumbingHeatingEquipmentAndSupplies = "plumbing_heating_equipment_and_supplies"
                        case politicalOrganizations = "political_organizations"
                        case postalServicesGovernmentOnly = "postal_services_government_only"
                        case preciousStonesAndMetalsWatchesAndJewelry = "precious_stones_and_metals_watches_and_jewelry"
                        case professionalServices = "professional_services"
                        case publicWarehousingAndStorage = "public_warehousing_and_storage"
                        case quickCopyReproAndBlueprint = "quick_copy_repro_and_blueprint"
                        case railroads
                        case realEstateAgentsAndManagersRentals = "real_estate_agents_and_managers_rentals"
                        case recordStores = "record_stores"
                        case recreationalVehicleRentals = "recreational_vehicle_rentals"
                        case religiousGoodsStores = "religious_goods_stores"
                        case religiousOrganizations = "religious_organizations"
                        case roofingSidingSheetMetal = "roofing_siding_sheet_metal"
                        case secretarialSupportServices = "secretarial_support_services"
                        case securityBrokersDealers = "security_brokers_dealers"
                        case serviceStations = "service_stations"
                        case sewingNeedleworkFabricAndPieceGoodsStores = "sewing_needlework_fabric_and_piece_goods_stores"
                        case shoeRepairHatCleaning = "shoe_repair_hat_cleaning"
                        case shoeStores = "shoe_stores"
                        case smallApplianceRepair = "small_appliance_repair"
                        case snowmobileDealers = "snowmobile_dealers"
                        case specialTradeServices = "special_trade_services"
                        case specialtyCleaning = "specialty_cleaning"
                        case sportingGoodsStores = "sporting_goods_stores"
                        case sportingRecreationCamps = "sporting_recreation_camps"
                        case sportsAndRidingApparelStores = "sports_and_riding_apparel_stores"
                        case sportsClubsFields = "sports_clubs_fields"
                        case stampAndCoinStores = "stamp_and_coin_stores"
                        case stationaryOfficeSuppliesPrintingAndWritingPaper = "stationary_office_supplies_printing_and_writing_paper"
                        case stationeryStoresOfficeAndSchoolSupplyStores = "stationery_stores_office_and_school_supply_stores"
                        case swimmingPoolsSales = "swimming_pools_sales"
                        case tUiTravelGermany = "t_ui_travel_germany"
                        case tailorsAlterations = "tailors_alterations"
                        case taxPaymentsGovernmentAgencies = "tax_payments_government_agencies"
                        case taxPreparationServices = "tax_preparation_services"
                        case taxicabsLimousines = "taxicabs_limousines"
                        case telecommunicationEquipmentAndTelephoneSales = "telecommunication_equipment_and_telephone_sales"
                        case telecommunicationServices = "telecommunication_services"
                        case telegraphServices = "telegraph_services"
                        case tentAndAwningShops = "tent_and_awning_shops"
                        case testingLaboratories = "testing_laboratories"
                        case theatricalTicketAgencies = "theatrical_ticket_agencies"
                        case timeshares
                        case tireRetreadingAndRepair = "tire_retreading_and_repair"
                        case tollsBridgeFees = "tolls_bridge_fees"
                        case touristAttractionsAndExhibits = "tourist_attractions_and_exhibits"
                        case towingServices = "towing_services"
                        case trailerParksCampgrounds = "trailer_parks_campgrounds"
                        case transportationServices = "transportation_services"
                        case travelAgenciesTourOperators = "travel_agencies_tour_operators"
                        case truckStopIteration = "truck_stop_iteration"
                        case truckUtilityTrailerRentals = "truck_utility_trailer_rentals"
                        case typesettingPlateMakingAndRelatedServices = "typesetting_plate_making_and_related_services"
                        case typewriterStores = "typewriter_stores"
                        case uSFederalGovernmentAgenciesOrDepartments = "u_s_federal_government_agencies_or_departments"
                        case uniformsCommercialClothing = "uniforms_commercial_clothing"
                        case usedMerchandiseAndSecondhandStores = "used_merchandise_and_secondhand_stores"
                        case utilities
                        case varietyStores = "variety_stores"
                        case veterinaryServices = "veterinary_services"
                        case videoAmusementGameSupplies = "video_amusement_game_supplies"
                        case videoGameArcades = "video_game_arcades"
                        case videoTapeRentalStores = "video_tape_rental_stores"
                        case vocationalTradeSchools = "vocational_trade_schools"
                        case watchJewelryRepair = "watch_jewelry_repair"
                        case weldingRepair = "welding_repair"
                        case wholesaleClubs = "wholesale_clubs"
                        case wigAndToupeeStores = "wig_and_toupee_stores"
                        case wiresMoneyOrders = "wires_money_orders"
                        case womensAccessoryAndSpecialtyShops = "womens_accessory_and_specialty_shops"
                        case womensReadyToWearStores = "womens_ready_to_wear_stores"
                        case wreckingAndSalvageYards = "wrecking_and_salvage_yards"
                    }

                    public enum Interval: String, Codable, CaseIterable {
                        case allTime = "all_time"
                        case daily
                        case monthly
                        case perAuthorization = "per_authorization"
                        case weekly
                        case yearly
                    }

                    public init(amount: Int, categories: [Category]? = nil, interval: Interval) {
                        self.amount = amount
                        self.categories = categories
                        self.interval = interval
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amount, forKey: "amount")
                        encoder.encode(categories, forKey: "categories")
                        encoder.encode(interval, forKey: "interval")
                        return encoder.items
                    }
                }

                public init(allowedCategories: [AllowedCategory]? = nil, blockedCategories: [BlockedCategory]? = nil, spendingLimits: [SpendingLimit]? = nil, spendingLimitsCurrency: String? = nil) {
                    self.allowedCategories = allowedCategories
                    self.blockedCategories = blockedCategories
                    self.spendingLimits = spendingLimits
                    self.spendingLimitsCurrency = spendingLimitsCurrency
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(allowedCategories, forKey: "allowed_categories")
                    encoder.encode(blockedCategories, forKey: "blocked_categories")
                    encoder.encode(spendingLimits, forKey: "spending_limits")
                    encoder.encode(spendingLimitsCurrency, forKey: "spending_limits_currency")
                    return encoder.items
                }
            }

            /// Specifies whether to permit authorizations on this cardholder's cards. Defaults to `active`.
            public enum Status: String, Codable, CaseIterable {
                case active
                case inactive
            }

            /// One of `individual` or `company`.
            public enum `Type`: String, Codable, CaseIterable {
                case company
                case individual
            }

            public init(billing: Billing, company: Company? = nil, email: String? = nil, expand: [String]? = nil, individual: Individual? = nil, metadata: [String: String]? = nil, name: String, phoneNumber: String? = nil, spendingControls: SpendingControls? = nil, status: Status? = nil, type: `Type`) {
                self.billing = billing
                self.company = company
                self.email = email
                self.expand = expand
                self.individual = individual
                self.metadata = metadata
                self.name = name
                self.phoneNumber = phoneNumber
                self.spendingControls = spendingControls
                self.status = status
                self.type = type
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(billing, forKey: "billing")
                encoder.encode(company, forKey: "company")
                encoder.encode(email, forKey: "email")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(individual, forKey: "individual")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(name, forKey: "name")
                encoder.encode(phoneNumber, forKey: "phone_number")
                encoder.encode(spendingControls, forKey: "spending_controls")
                encoder.encode(status, forKey: "status")
                encoder.encode(type, forKey: "type")
                return encoder.items
            }
        }
    }
}

extension Paths.Issuing.Cardholders {
    public func cardholder(_ cardholder: String) -> WithCardholder {
        WithCardholder(path: "\(path)/\(cardholder)")
    }

    public struct WithCardholder {
        /// Path: `/v1/issuing/cardholders/{cardholder}`
        public let path: String

        /// <p>Retrieves an Issuing <code>Cardholder</code> object.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.IssuingCardholder> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the specified Issuing <code>Cardholder</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.IssuingCardholder> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Billing_specs
            ///
            /// The cardholder's billing address.
            public var billing: Billing?
            /// Company_param
            ///
            /// Additional information about a `company` cardholder.
            public var company: Company?
            /// The cardholder's email address.
            public var email: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Individual_param
            ///
            /// Additional information about an `individual` cardholder.
            public var individual: Individual?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// The cardholder's phone number. This is required for all cardholders who will be creating EU cards. See the [3D Secure documentation](https://stripe.com/docs/issuing/3d-secure) for more details.
            public var phoneNumber: String?
            /// Authorization_controls_param_v2
            ///
            /// Rules that control spending across this cardholder's cards. Refer to our [documentation](https://stripe.com/docs/issuing/controls/spending-controls) for more details.
            public var spendingControls: SpendingControls?
            /// Specifies whether to permit authorizations on this cardholder's cards.
            public var status: Status?

            /// Billing_specs
            ///
            /// The cardholder's billing address.
            public struct Billing: Encodable {
                /// Required_address
                public var address: Address

                /// Required_address
                public struct Address: Encodable {
                    public var city: String
                    public var country: String
                    public var line1: String
                    public var line2: String?
                    public var postalCode: String
                    public var state: String?

                    public init(city: String, country: String, line1: String, line2: String? = nil, postalCode: String, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                public init(address: Address) {
                    self.address = address
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    return encoder.items
                }
            }

            /// Company_param
            ///
            /// Additional information about a `company` cardholder.
            public struct Company: Encodable {
                public var taxID: String?

                public init(taxID: String? = nil) {
                    self.taxID = taxID
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(taxID, forKey: "tax_id")
                    return encoder.items
                }
            }

            /// Individual_param
            ///
            /// Additional information about an `individual` cardholder.
            public struct Individual: Encodable {
                /// Date_of_birth_specs
                public var dob: Dob?
                public var firstName: String
                public var lastName: String
                /// Person_verification_param
                public var verification: Verification?

                /// Date_of_birth_specs
                public struct Dob: Encodable {
                    public var day: Int
                    public var month: Int
                    public var year: Int

                    public init(day: Int, month: Int, year: Int) {
                        self.day = day
                        self.month = month
                        self.year = year
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(day, forKey: "day")
                        encoder.encode(month, forKey: "month")
                        encoder.encode(year, forKey: "year")
                        return encoder.items
                    }
                }

                /// Person_verification_param
                public struct Verification: Encodable {
                    /// Person_verification_document_param
                    public var document: Document?

                    /// Person_verification_document_param
                    public struct Document: Encodable {
                        public var back: String?
                        public var front: String?

                        public init(back: String? = nil, front: String? = nil) {
                            self.back = back
                            self.front = front
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(back, forKey: "back")
                            encoder.encode(front, forKey: "front")
                            return encoder.items
                        }
                    }

                    public init(document: Document? = nil) {
                        self.document = document
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(document, forKey: "document")
                        return encoder.items
                    }
                }

                public init(dob: Dob? = nil, firstName: String, lastName: String, verification: Verification? = nil) {
                    self.dob = dob
                    self.firstName = firstName
                    self.lastName = lastName
                    self.verification = verification
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(dob, forKey: "dob")
                    encoder.encode(firstName, forKey: "first_name")
                    encoder.encode(lastName, forKey: "last_name")
                    encoder.encode(verification, forKey: "verification")
                    return encoder.items
                }
            }

            /// Authorization_controls_param_v2
            ///
            /// Rules that control spending across this cardholder's cards. Refer to our [documentation](https://stripe.com/docs/issuing/controls/spending-controls) for more details.
            public struct SpendingControls: Encodable {
                public var allowedCategories: [AllowedCategory]?
                public var blockedCategories: [BlockedCategory]?
                public var spendingLimits: [SpendingLimit]?
                public var spendingLimitsCurrency: String?

                public enum AllowedCategory: String, Codable, CaseIterable {
                    case acRefrigerationRepair = "ac_refrigeration_repair"
                    case accountingBookkeepingServices = "accounting_bookkeeping_services"
                    case advertisingServices = "advertising_services"
                    case agriculturalCooperative = "agricultural_cooperative"
                    case airlinesAirCarriers = "airlines_air_carriers"
                    case airportsFlyingFields = "airports_flying_fields"
                    case ambulanceServices = "ambulance_services"
                    case amusementParksCarnivals = "amusement_parks_carnivals"
                    case antiqueReproductions = "antique_reproductions"
                    case antiqueShops = "antique_shops"
                    case aquariums
                    case architecturalSurveyingServices = "architectural_surveying_services"
                    case artDealersAndGalleries = "art_dealers_and_galleries"
                    case artistsSupplyAndCraftShops = "artists_supply_and_craft_shops"
                    case autoAndHomeSupplyStores = "auto_and_home_supply_stores"
                    case autoBodyRepairShops = "auto_body_repair_shops"
                    case autoPaintShops = "auto_paint_shops"
                    case autoServiceShops = "auto_service_shops"
                    case automatedCashDisburse = "automated_cash_disburse"
                    case automatedFuelDispensers = "automated_fuel_dispensers"
                    case automobileAssociations = "automobile_associations"
                    case automotivePartsAndAccessoriesStores = "automotive_parts_and_accessories_stores"
                    case automotiveTireStores = "automotive_tire_stores"
                    case bailAndBondPayments = "bail_and_bond_payments"
                    case bakeries
                    case bandsOrchestras = "bands_orchestras"
                    case barberAndBeautyShops = "barber_and_beauty_shops"
                    case bettingCasinoGambling = "betting_casino_gambling"
                    case bicycleShops = "bicycle_shops"
                    case billiardPoolEstablishments = "billiard_pool_establishments"
                    case boatDealers = "boat_dealers"
                    case boatRentalsAndLeases = "boat_rentals_and_leases"
                    case bookStores = "book_stores"
                    case booksPeriodicalsAndNewspapers = "books_periodicals_and_newspapers"
                    case bowlingAlleys = "bowling_alleys"
                    case busLines = "bus_lines"
                    case businessSecretarialSchools = "business_secretarial_schools"
                    case buyingShoppingServices = "buying_shopping_services"
                    case cableSatelliteAndOtherPayTelevisionAndRadio = "cable_satellite_and_other_pay_television_and_radio"
                    case cameraAndPhotographicSupplyStores = "camera_and_photographic_supply_stores"
                    case candyNutAndConfectioneryStores = "candy_nut_and_confectionery_stores"
                    case carAndTruckDealersNewUsed = "car_and_truck_dealers_new_used"
                    case carAndTruckDealersUsedOnly = "car_and_truck_dealers_used_only"
                    case carRentalAgencies = "car_rental_agencies"
                    case carWashes = "car_washes"
                    case carpentryServices = "carpentry_services"
                    case carpetUpholsteryCleaning = "carpet_upholstery_cleaning"
                    case caterers
                    case charitableAndSocialServiceOrganizationsFundraising = "charitable_and_social_service_organizations_fundraising"
                    case chemicalsAndAlliedProducts = "chemicals_and_allied_products"
                    case childCareServices = "child_care_services"
                    case childrensAndInfantsWearStores = "childrens_and_infants_wear_stores"
                    case chiropodistsPodiatrists = "chiropodists_podiatrists"
                    case chiropractors
                    case cigarStoresAndStands = "cigar_stores_and_stands"
                    case civicSocialFraternalAssociations = "civic_social_fraternal_associations"
                    case cleaningAndMaintenance = "cleaning_and_maintenance"
                    case clothingRental = "clothing_rental"
                    case collegesUniversities = "colleges_universities"
                    case commercialEquipment = "commercial_equipment"
                    case commercialFootwear = "commercial_footwear"
                    case commercialPhotographyArtAndGraphics = "commercial_photography_art_and_graphics"
                    case commuterTransportAndFerries = "commuter_transport_and_ferries"
                    case computerNetworkServices = "computer_network_services"
                    case computerProgramming = "computer_programming"
                    case computerRepair = "computer_repair"
                    case computerSoftwareStores = "computer_software_stores"
                    case computersPeripheralsAndSoftware = "computers_peripherals_and_software"
                    case concreteWorkServices = "concrete_work_services"
                    case constructionMaterials = "construction_materials"
                    case consultingPublicRelations = "consulting_public_relations"
                    case correspondenceSchools = "correspondence_schools"
                    case cosmeticStores = "cosmetic_stores"
                    case counselingServices = "counseling_services"
                    case countryClubs = "country_clubs"
                    case courierServices = "courier_services"
                    case courtCosts = "court_costs"
                    case creditReportingAgencies = "credit_reporting_agencies"
                    case cruiseLines = "cruise_lines"
                    case dairyProductsStores = "dairy_products_stores"
                    case danceHallStudiosSchools = "dance_hall_studios_schools"
                    case datingEscortServices = "dating_escort_services"
                    case dentistsOrthodontists = "dentists_orthodontists"
                    case departmentStores = "department_stores"
                    case detectiveAgencies = "detective_agencies"
                    case digitalGoodsApplications = "digital_goods_applications"
                    case digitalGoodsGames = "digital_goods_games"
                    case digitalGoodsLargeVolume = "digital_goods_large_volume"
                    case digitalGoodsMedia = "digital_goods_media"
                    case directMarketingCatalogMerchant = "direct_marketing_catalog_merchant"
                    case directMarketingCombinationCatalogAndRetailMerchant = "direct_marketing_combination_catalog_and_retail_merchant"
                    case directMarketingInboundTelemarketing = "direct_marketing_inbound_telemarketing"
                    case directMarketingInsuranceServices = "direct_marketing_insurance_services"
                    case directMarketingOther = "direct_marketing_other"
                    case directMarketingOutboundTelemarketing = "direct_marketing_outbound_telemarketing"
                    case directMarketingSubscription = "direct_marketing_subscription"
                    case directMarketingTravel = "direct_marketing_travel"
                    case discountStores = "discount_stores"
                    case doctors
                    case doorToDoorSales = "door_to_door_sales"
                    case draperyWindowCoveringAndUpholsteryStores = "drapery_window_covering_and_upholstery_stores"
                    case drinkingPlaces = "drinking_places"
                    case drugStoresAndPharmacies = "drug_stores_and_pharmacies"
                    case drugsDrugProprietariesAndDruggistSundries = "drugs_drug_proprietaries_and_druggist_sundries"
                    case dryCleaners = "dry_cleaners"
                    case durableGoods = "durable_goods"
                    case dutyFreeStores = "duty_free_stores"
                    case eatingPlacesRestaurants = "eating_places_restaurants"
                    case educationalServices = "educational_services"
                    case electricRazorStores = "electric_razor_stores"
                    case electricalPartsAndEquipment = "electrical_parts_and_equipment"
                    case electricalServices = "electrical_services"
                    case electronicsRepairShops = "electronics_repair_shops"
                    case electronicsStores = "electronics_stores"
                    case elementarySecondarySchools = "elementary_secondary_schools"
                    case employmentTempAgencies = "employment_temp_agencies"
                    case equipmentRental = "equipment_rental"
                    case exterminatingServices = "exterminating_services"
                    case familyClothingStores = "family_clothing_stores"
                    case fastFoodRestaurants = "fast_food_restaurants"
                    case financialInstitutions = "financial_institutions"
                    case finesGovernmentAdministrativeEntities = "fines_government_administrative_entities"
                    case fireplaceFireplaceScreensAndAccessoriesStores = "fireplace_fireplace_screens_and_accessories_stores"
                    case floorCoveringStores = "floor_covering_stores"
                    case florists
                    case floristsSuppliesNurseryStockAndFlowers = "florists_supplies_nursery_stock_and_flowers"
                    case freezerAndLockerMeatProvisioners = "freezer_and_locker_meat_provisioners"
                    case fuelDealersNonAutomotive = "fuel_dealers_non_automotive"
                    case funeralServicesCrematories = "funeral_services_crematories"
                    case furnitureHomeFurnishingsAndEquipmentStoresExceptAppliances = "furniture_home_furnishings_and_equipment_stores_except_appliances"
                    case furnitureRepairRefinishing = "furniture_repair_refinishing"
                    case furriersAndFurShops = "furriers_and_fur_shops"
                    case generalServices = "general_services"
                    case giftCardNoveltyAndSouvenirShops = "gift_card_novelty_and_souvenir_shops"
                    case glassPaintAndWallpaperStores = "glass_paint_and_wallpaper_stores"
                    case glasswareCrystalStores = "glassware_crystal_stores"
                    case golfCoursesPublic = "golf_courses_public"
                    case governmentServices = "government_services"
                    case groceryStoresSupermarkets = "grocery_stores_supermarkets"
                    case hardwareEquipmentAndSupplies = "hardware_equipment_and_supplies"
                    case hardwareStores = "hardware_stores"
                    case healthAndBeautySpas = "health_and_beauty_spas"
                    case hearingAidsSalesAndSupplies = "hearing_aids_sales_and_supplies"
                    case heatingPlumbingAC = "heating_plumbing_a_c"
                    case hobbyToyAndGameShops = "hobby_toy_and_game_shops"
                    case homeSupplyWarehouseStores = "home_supply_warehouse_stores"
                    case hospitals
                    case hotelsMotelsAndResorts = "hotels_motels_and_resorts"
                    case householdApplianceStores = "household_appliance_stores"
                    case industrialSupplies = "industrial_supplies"
                    case informationRetrievalServices = "information_retrieval_services"
                    case insuranceDefault = "insurance_default"
                    case insuranceUnderwritingPremiums = "insurance_underwriting_premiums"
                    case intraCompanyPurchases = "intra_company_purchases"
                    case jewelryStoresWatchesClocksAndSilverwareStores = "jewelry_stores_watches_clocks_and_silverware_stores"
                    case landscapingServices = "landscaping_services"
                    case laundries
                    case laundryCleaningServices = "laundry_cleaning_services"
                    case legalServicesAttorneys = "legal_services_attorneys"
                    case luggageAndLeatherGoodsStores = "luggage_and_leather_goods_stores"
                    case lumberBuildingMaterialsStores = "lumber_building_materials_stores"
                    case manualCashDisburse = "manual_cash_disburse"
                    case marinasServiceAndSupplies = "marinas_service_and_supplies"
                    case masonryStoneworkAndPlaster = "masonry_stonework_and_plaster"
                    case massageParlors = "massage_parlors"
                    case medicalAndDentalLabs = "medical_and_dental_labs"
                    case medicalDentalOphthalmicAndHospitalEquipmentAndSupplies = "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
                    case medicalServices = "medical_services"
                    case membershipOrganizations = "membership_organizations"
                    case mensAndBoysClothingAndAccessoriesStores = "mens_and_boys_clothing_and_accessories_stores"
                    case mensWomensClothingStores = "mens_womens_clothing_stores"
                    case metalServiceCenters = "metal_service_centers"
                    case miscellaneous
                    case miscellaneousApparelAndAccessoryShops = "miscellaneous_apparel_and_accessory_shops"
                    case miscellaneousAutoDealers = "miscellaneous_auto_dealers"
                    case miscellaneousBusinessServices = "miscellaneous_business_services"
                    case miscellaneousFoodStores = "miscellaneous_food_stores"
                    case miscellaneousGeneralMerchandise = "miscellaneous_general_merchandise"
                    case miscellaneousGeneralServices = "miscellaneous_general_services"
                    case miscellaneousHomeFurnishingSpecialtyStores = "miscellaneous_home_furnishing_specialty_stores"
                    case miscellaneousPublishingAndPrinting = "miscellaneous_publishing_and_printing"
                    case miscellaneousRecreationServices = "miscellaneous_recreation_services"
                    case miscellaneousRepairShops = "miscellaneous_repair_shops"
                    case miscellaneousSpecialtyRetail = "miscellaneous_specialty_retail"
                    case mobileHomeDealers = "mobile_home_dealers"
                    case motionPictureTheaters = "motion_picture_theaters"
                    case motorFreightCarriersAndTrucking = "motor_freight_carriers_and_trucking"
                    case motorHomesDealers = "motor_homes_dealers"
                    case motorVehicleSuppliesAndNewParts = "motor_vehicle_supplies_and_new_parts"
                    case motorcycleShopsAndDealers = "motorcycle_shops_and_dealers"
                    case motorcycleShopsDealers = "motorcycle_shops_dealers"
                    case musicStoresMusicalInstrumentsPianosAndSheetMusic = "music_stores_musical_instruments_pianos_and_sheet_music"
                    case newsDealersAndNewsstands = "news_dealers_and_newsstands"
                    case nonFiMoneyOrders = "non_fi_money_orders"
                    case nonFiStoredValueCardPurchaseLoad = "non_fi_stored_value_card_purchase_load"
                    case nondurableGoods = "nondurable_goods"
                    case nurseriesLawnAndGardenSupplyStores = "nurseries_lawn_and_garden_supply_stores"
                    case nursingPersonalCare = "nursing_personal_care"
                    case officeAndCommercialFurniture = "office_and_commercial_furniture"
                    case opticiansEyeglasses = "opticians_eyeglasses"
                    case optometristsOphthalmologist = "optometrists_ophthalmologist"
                    case orthopedicGoodsProstheticDevices = "orthopedic_goods_prosthetic_devices"
                    case osteopaths
                    case packageStoresBeerWineAndLiquor = "package_stores_beer_wine_and_liquor"
                    case paintsVarnishesAndSupplies = "paints_varnishes_and_supplies"
                    case parkingLotsGarages = "parking_lots_garages"
                    case passengerRailways = "passenger_railways"
                    case pawnShops = "pawn_shops"
                    case petShopsPetFoodAndSupplies = "pet_shops_pet_food_and_supplies"
                    case petroleumAndPetroleumProducts = "petroleum_and_petroleum_products"
                    case photoDeveloping = "photo_developing"
                    case photographicPhotocopyMicrofilmEquipmentAndSupplies = "photographic_photocopy_microfilm_equipment_and_supplies"
                    case photographicStudios = "photographic_studios"
                    case pictureVideoProduction = "picture_video_production"
                    case pieceGoodsNotionsAndOtherDryGoods = "piece_goods_notions_and_other_dry_goods"
                    case plumbingHeatingEquipmentAndSupplies = "plumbing_heating_equipment_and_supplies"
                    case politicalOrganizations = "political_organizations"
                    case postalServicesGovernmentOnly = "postal_services_government_only"
                    case preciousStonesAndMetalsWatchesAndJewelry = "precious_stones_and_metals_watches_and_jewelry"
                    case professionalServices = "professional_services"
                    case publicWarehousingAndStorage = "public_warehousing_and_storage"
                    case quickCopyReproAndBlueprint = "quick_copy_repro_and_blueprint"
                    case railroads
                    case realEstateAgentsAndManagersRentals = "real_estate_agents_and_managers_rentals"
                    case recordStores = "record_stores"
                    case recreationalVehicleRentals = "recreational_vehicle_rentals"
                    case religiousGoodsStores = "religious_goods_stores"
                    case religiousOrganizations = "religious_organizations"
                    case roofingSidingSheetMetal = "roofing_siding_sheet_metal"
                    case secretarialSupportServices = "secretarial_support_services"
                    case securityBrokersDealers = "security_brokers_dealers"
                    case serviceStations = "service_stations"
                    case sewingNeedleworkFabricAndPieceGoodsStores = "sewing_needlework_fabric_and_piece_goods_stores"
                    case shoeRepairHatCleaning = "shoe_repair_hat_cleaning"
                    case shoeStores = "shoe_stores"
                    case smallApplianceRepair = "small_appliance_repair"
                    case snowmobileDealers = "snowmobile_dealers"
                    case specialTradeServices = "special_trade_services"
                    case specialtyCleaning = "specialty_cleaning"
                    case sportingGoodsStores = "sporting_goods_stores"
                    case sportingRecreationCamps = "sporting_recreation_camps"
                    case sportsAndRidingApparelStores = "sports_and_riding_apparel_stores"
                    case sportsClubsFields = "sports_clubs_fields"
                    case stampAndCoinStores = "stamp_and_coin_stores"
                    case stationaryOfficeSuppliesPrintingAndWritingPaper = "stationary_office_supplies_printing_and_writing_paper"
                    case stationeryStoresOfficeAndSchoolSupplyStores = "stationery_stores_office_and_school_supply_stores"
                    case swimmingPoolsSales = "swimming_pools_sales"
                    case tUiTravelGermany = "t_ui_travel_germany"
                    case tailorsAlterations = "tailors_alterations"
                    case taxPaymentsGovernmentAgencies = "tax_payments_government_agencies"
                    case taxPreparationServices = "tax_preparation_services"
                    case taxicabsLimousines = "taxicabs_limousines"
                    case telecommunicationEquipmentAndTelephoneSales = "telecommunication_equipment_and_telephone_sales"
                    case telecommunicationServices = "telecommunication_services"
                    case telegraphServices = "telegraph_services"
                    case tentAndAwningShops = "tent_and_awning_shops"
                    case testingLaboratories = "testing_laboratories"
                    case theatricalTicketAgencies = "theatrical_ticket_agencies"
                    case timeshares
                    case tireRetreadingAndRepair = "tire_retreading_and_repair"
                    case tollsBridgeFees = "tolls_bridge_fees"
                    case touristAttractionsAndExhibits = "tourist_attractions_and_exhibits"
                    case towingServices = "towing_services"
                    case trailerParksCampgrounds = "trailer_parks_campgrounds"
                    case transportationServices = "transportation_services"
                    case travelAgenciesTourOperators = "travel_agencies_tour_operators"
                    case truckStopIteration = "truck_stop_iteration"
                    case truckUtilityTrailerRentals = "truck_utility_trailer_rentals"
                    case typesettingPlateMakingAndRelatedServices = "typesetting_plate_making_and_related_services"
                    case typewriterStores = "typewriter_stores"
                    case uSFederalGovernmentAgenciesOrDepartments = "u_s_federal_government_agencies_or_departments"
                    case uniformsCommercialClothing = "uniforms_commercial_clothing"
                    case usedMerchandiseAndSecondhandStores = "used_merchandise_and_secondhand_stores"
                    case utilities
                    case varietyStores = "variety_stores"
                    case veterinaryServices = "veterinary_services"
                    case videoAmusementGameSupplies = "video_amusement_game_supplies"
                    case videoGameArcades = "video_game_arcades"
                    case videoTapeRentalStores = "video_tape_rental_stores"
                    case vocationalTradeSchools = "vocational_trade_schools"
                    case watchJewelryRepair = "watch_jewelry_repair"
                    case weldingRepair = "welding_repair"
                    case wholesaleClubs = "wholesale_clubs"
                    case wigAndToupeeStores = "wig_and_toupee_stores"
                    case wiresMoneyOrders = "wires_money_orders"
                    case womensAccessoryAndSpecialtyShops = "womens_accessory_and_specialty_shops"
                    case womensReadyToWearStores = "womens_ready_to_wear_stores"
                    case wreckingAndSalvageYards = "wrecking_and_salvage_yards"
                }

                public enum BlockedCategory: String, Codable, CaseIterable {
                    case acRefrigerationRepair = "ac_refrigeration_repair"
                    case accountingBookkeepingServices = "accounting_bookkeeping_services"
                    case advertisingServices = "advertising_services"
                    case agriculturalCooperative = "agricultural_cooperative"
                    case airlinesAirCarriers = "airlines_air_carriers"
                    case airportsFlyingFields = "airports_flying_fields"
                    case ambulanceServices = "ambulance_services"
                    case amusementParksCarnivals = "amusement_parks_carnivals"
                    case antiqueReproductions = "antique_reproductions"
                    case antiqueShops = "antique_shops"
                    case aquariums
                    case architecturalSurveyingServices = "architectural_surveying_services"
                    case artDealersAndGalleries = "art_dealers_and_galleries"
                    case artistsSupplyAndCraftShops = "artists_supply_and_craft_shops"
                    case autoAndHomeSupplyStores = "auto_and_home_supply_stores"
                    case autoBodyRepairShops = "auto_body_repair_shops"
                    case autoPaintShops = "auto_paint_shops"
                    case autoServiceShops = "auto_service_shops"
                    case automatedCashDisburse = "automated_cash_disburse"
                    case automatedFuelDispensers = "automated_fuel_dispensers"
                    case automobileAssociations = "automobile_associations"
                    case automotivePartsAndAccessoriesStores = "automotive_parts_and_accessories_stores"
                    case automotiveTireStores = "automotive_tire_stores"
                    case bailAndBondPayments = "bail_and_bond_payments"
                    case bakeries
                    case bandsOrchestras = "bands_orchestras"
                    case barberAndBeautyShops = "barber_and_beauty_shops"
                    case bettingCasinoGambling = "betting_casino_gambling"
                    case bicycleShops = "bicycle_shops"
                    case billiardPoolEstablishments = "billiard_pool_establishments"
                    case boatDealers = "boat_dealers"
                    case boatRentalsAndLeases = "boat_rentals_and_leases"
                    case bookStores = "book_stores"
                    case booksPeriodicalsAndNewspapers = "books_periodicals_and_newspapers"
                    case bowlingAlleys = "bowling_alleys"
                    case busLines = "bus_lines"
                    case businessSecretarialSchools = "business_secretarial_schools"
                    case buyingShoppingServices = "buying_shopping_services"
                    case cableSatelliteAndOtherPayTelevisionAndRadio = "cable_satellite_and_other_pay_television_and_radio"
                    case cameraAndPhotographicSupplyStores = "camera_and_photographic_supply_stores"
                    case candyNutAndConfectioneryStores = "candy_nut_and_confectionery_stores"
                    case carAndTruckDealersNewUsed = "car_and_truck_dealers_new_used"
                    case carAndTruckDealersUsedOnly = "car_and_truck_dealers_used_only"
                    case carRentalAgencies = "car_rental_agencies"
                    case carWashes = "car_washes"
                    case carpentryServices = "carpentry_services"
                    case carpetUpholsteryCleaning = "carpet_upholstery_cleaning"
                    case caterers
                    case charitableAndSocialServiceOrganizationsFundraising = "charitable_and_social_service_organizations_fundraising"
                    case chemicalsAndAlliedProducts = "chemicals_and_allied_products"
                    case childCareServices = "child_care_services"
                    case childrensAndInfantsWearStores = "childrens_and_infants_wear_stores"
                    case chiropodistsPodiatrists = "chiropodists_podiatrists"
                    case chiropractors
                    case cigarStoresAndStands = "cigar_stores_and_stands"
                    case civicSocialFraternalAssociations = "civic_social_fraternal_associations"
                    case cleaningAndMaintenance = "cleaning_and_maintenance"
                    case clothingRental = "clothing_rental"
                    case collegesUniversities = "colleges_universities"
                    case commercialEquipment = "commercial_equipment"
                    case commercialFootwear = "commercial_footwear"
                    case commercialPhotographyArtAndGraphics = "commercial_photography_art_and_graphics"
                    case commuterTransportAndFerries = "commuter_transport_and_ferries"
                    case computerNetworkServices = "computer_network_services"
                    case computerProgramming = "computer_programming"
                    case computerRepair = "computer_repair"
                    case computerSoftwareStores = "computer_software_stores"
                    case computersPeripheralsAndSoftware = "computers_peripherals_and_software"
                    case concreteWorkServices = "concrete_work_services"
                    case constructionMaterials = "construction_materials"
                    case consultingPublicRelations = "consulting_public_relations"
                    case correspondenceSchools = "correspondence_schools"
                    case cosmeticStores = "cosmetic_stores"
                    case counselingServices = "counseling_services"
                    case countryClubs = "country_clubs"
                    case courierServices = "courier_services"
                    case courtCosts = "court_costs"
                    case creditReportingAgencies = "credit_reporting_agencies"
                    case cruiseLines = "cruise_lines"
                    case dairyProductsStores = "dairy_products_stores"
                    case danceHallStudiosSchools = "dance_hall_studios_schools"
                    case datingEscortServices = "dating_escort_services"
                    case dentistsOrthodontists = "dentists_orthodontists"
                    case departmentStores = "department_stores"
                    case detectiveAgencies = "detective_agencies"
                    case digitalGoodsApplications = "digital_goods_applications"
                    case digitalGoodsGames = "digital_goods_games"
                    case digitalGoodsLargeVolume = "digital_goods_large_volume"
                    case digitalGoodsMedia = "digital_goods_media"
                    case directMarketingCatalogMerchant = "direct_marketing_catalog_merchant"
                    case directMarketingCombinationCatalogAndRetailMerchant = "direct_marketing_combination_catalog_and_retail_merchant"
                    case directMarketingInboundTelemarketing = "direct_marketing_inbound_telemarketing"
                    case directMarketingInsuranceServices = "direct_marketing_insurance_services"
                    case directMarketingOther = "direct_marketing_other"
                    case directMarketingOutboundTelemarketing = "direct_marketing_outbound_telemarketing"
                    case directMarketingSubscription = "direct_marketing_subscription"
                    case directMarketingTravel = "direct_marketing_travel"
                    case discountStores = "discount_stores"
                    case doctors
                    case doorToDoorSales = "door_to_door_sales"
                    case draperyWindowCoveringAndUpholsteryStores = "drapery_window_covering_and_upholstery_stores"
                    case drinkingPlaces = "drinking_places"
                    case drugStoresAndPharmacies = "drug_stores_and_pharmacies"
                    case drugsDrugProprietariesAndDruggistSundries = "drugs_drug_proprietaries_and_druggist_sundries"
                    case dryCleaners = "dry_cleaners"
                    case durableGoods = "durable_goods"
                    case dutyFreeStores = "duty_free_stores"
                    case eatingPlacesRestaurants = "eating_places_restaurants"
                    case educationalServices = "educational_services"
                    case electricRazorStores = "electric_razor_stores"
                    case electricalPartsAndEquipment = "electrical_parts_and_equipment"
                    case electricalServices = "electrical_services"
                    case electronicsRepairShops = "electronics_repair_shops"
                    case electronicsStores = "electronics_stores"
                    case elementarySecondarySchools = "elementary_secondary_schools"
                    case employmentTempAgencies = "employment_temp_agencies"
                    case equipmentRental = "equipment_rental"
                    case exterminatingServices = "exterminating_services"
                    case familyClothingStores = "family_clothing_stores"
                    case fastFoodRestaurants = "fast_food_restaurants"
                    case financialInstitutions = "financial_institutions"
                    case finesGovernmentAdministrativeEntities = "fines_government_administrative_entities"
                    case fireplaceFireplaceScreensAndAccessoriesStores = "fireplace_fireplace_screens_and_accessories_stores"
                    case floorCoveringStores = "floor_covering_stores"
                    case florists
                    case floristsSuppliesNurseryStockAndFlowers = "florists_supplies_nursery_stock_and_flowers"
                    case freezerAndLockerMeatProvisioners = "freezer_and_locker_meat_provisioners"
                    case fuelDealersNonAutomotive = "fuel_dealers_non_automotive"
                    case funeralServicesCrematories = "funeral_services_crematories"
                    case furnitureHomeFurnishingsAndEquipmentStoresExceptAppliances = "furniture_home_furnishings_and_equipment_stores_except_appliances"
                    case furnitureRepairRefinishing = "furniture_repair_refinishing"
                    case furriersAndFurShops = "furriers_and_fur_shops"
                    case generalServices = "general_services"
                    case giftCardNoveltyAndSouvenirShops = "gift_card_novelty_and_souvenir_shops"
                    case glassPaintAndWallpaperStores = "glass_paint_and_wallpaper_stores"
                    case glasswareCrystalStores = "glassware_crystal_stores"
                    case golfCoursesPublic = "golf_courses_public"
                    case governmentServices = "government_services"
                    case groceryStoresSupermarkets = "grocery_stores_supermarkets"
                    case hardwareEquipmentAndSupplies = "hardware_equipment_and_supplies"
                    case hardwareStores = "hardware_stores"
                    case healthAndBeautySpas = "health_and_beauty_spas"
                    case hearingAidsSalesAndSupplies = "hearing_aids_sales_and_supplies"
                    case heatingPlumbingAC = "heating_plumbing_a_c"
                    case hobbyToyAndGameShops = "hobby_toy_and_game_shops"
                    case homeSupplyWarehouseStores = "home_supply_warehouse_stores"
                    case hospitals
                    case hotelsMotelsAndResorts = "hotels_motels_and_resorts"
                    case householdApplianceStores = "household_appliance_stores"
                    case industrialSupplies = "industrial_supplies"
                    case informationRetrievalServices = "information_retrieval_services"
                    case insuranceDefault = "insurance_default"
                    case insuranceUnderwritingPremiums = "insurance_underwriting_premiums"
                    case intraCompanyPurchases = "intra_company_purchases"
                    case jewelryStoresWatchesClocksAndSilverwareStores = "jewelry_stores_watches_clocks_and_silverware_stores"
                    case landscapingServices = "landscaping_services"
                    case laundries
                    case laundryCleaningServices = "laundry_cleaning_services"
                    case legalServicesAttorneys = "legal_services_attorneys"
                    case luggageAndLeatherGoodsStores = "luggage_and_leather_goods_stores"
                    case lumberBuildingMaterialsStores = "lumber_building_materials_stores"
                    case manualCashDisburse = "manual_cash_disburse"
                    case marinasServiceAndSupplies = "marinas_service_and_supplies"
                    case masonryStoneworkAndPlaster = "masonry_stonework_and_plaster"
                    case massageParlors = "massage_parlors"
                    case medicalAndDentalLabs = "medical_and_dental_labs"
                    case medicalDentalOphthalmicAndHospitalEquipmentAndSupplies = "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
                    case medicalServices = "medical_services"
                    case membershipOrganizations = "membership_organizations"
                    case mensAndBoysClothingAndAccessoriesStores = "mens_and_boys_clothing_and_accessories_stores"
                    case mensWomensClothingStores = "mens_womens_clothing_stores"
                    case metalServiceCenters = "metal_service_centers"
                    case miscellaneous
                    case miscellaneousApparelAndAccessoryShops = "miscellaneous_apparel_and_accessory_shops"
                    case miscellaneousAutoDealers = "miscellaneous_auto_dealers"
                    case miscellaneousBusinessServices = "miscellaneous_business_services"
                    case miscellaneousFoodStores = "miscellaneous_food_stores"
                    case miscellaneousGeneralMerchandise = "miscellaneous_general_merchandise"
                    case miscellaneousGeneralServices = "miscellaneous_general_services"
                    case miscellaneousHomeFurnishingSpecialtyStores = "miscellaneous_home_furnishing_specialty_stores"
                    case miscellaneousPublishingAndPrinting = "miscellaneous_publishing_and_printing"
                    case miscellaneousRecreationServices = "miscellaneous_recreation_services"
                    case miscellaneousRepairShops = "miscellaneous_repair_shops"
                    case miscellaneousSpecialtyRetail = "miscellaneous_specialty_retail"
                    case mobileHomeDealers = "mobile_home_dealers"
                    case motionPictureTheaters = "motion_picture_theaters"
                    case motorFreightCarriersAndTrucking = "motor_freight_carriers_and_trucking"
                    case motorHomesDealers = "motor_homes_dealers"
                    case motorVehicleSuppliesAndNewParts = "motor_vehicle_supplies_and_new_parts"
                    case motorcycleShopsAndDealers = "motorcycle_shops_and_dealers"
                    case motorcycleShopsDealers = "motorcycle_shops_dealers"
                    case musicStoresMusicalInstrumentsPianosAndSheetMusic = "music_stores_musical_instruments_pianos_and_sheet_music"
                    case newsDealersAndNewsstands = "news_dealers_and_newsstands"
                    case nonFiMoneyOrders = "non_fi_money_orders"
                    case nonFiStoredValueCardPurchaseLoad = "non_fi_stored_value_card_purchase_load"
                    case nondurableGoods = "nondurable_goods"
                    case nurseriesLawnAndGardenSupplyStores = "nurseries_lawn_and_garden_supply_stores"
                    case nursingPersonalCare = "nursing_personal_care"
                    case officeAndCommercialFurniture = "office_and_commercial_furniture"
                    case opticiansEyeglasses = "opticians_eyeglasses"
                    case optometristsOphthalmologist = "optometrists_ophthalmologist"
                    case orthopedicGoodsProstheticDevices = "orthopedic_goods_prosthetic_devices"
                    case osteopaths
                    case packageStoresBeerWineAndLiquor = "package_stores_beer_wine_and_liquor"
                    case paintsVarnishesAndSupplies = "paints_varnishes_and_supplies"
                    case parkingLotsGarages = "parking_lots_garages"
                    case passengerRailways = "passenger_railways"
                    case pawnShops = "pawn_shops"
                    case petShopsPetFoodAndSupplies = "pet_shops_pet_food_and_supplies"
                    case petroleumAndPetroleumProducts = "petroleum_and_petroleum_products"
                    case photoDeveloping = "photo_developing"
                    case photographicPhotocopyMicrofilmEquipmentAndSupplies = "photographic_photocopy_microfilm_equipment_and_supplies"
                    case photographicStudios = "photographic_studios"
                    case pictureVideoProduction = "picture_video_production"
                    case pieceGoodsNotionsAndOtherDryGoods = "piece_goods_notions_and_other_dry_goods"
                    case plumbingHeatingEquipmentAndSupplies = "plumbing_heating_equipment_and_supplies"
                    case politicalOrganizations = "political_organizations"
                    case postalServicesGovernmentOnly = "postal_services_government_only"
                    case preciousStonesAndMetalsWatchesAndJewelry = "precious_stones_and_metals_watches_and_jewelry"
                    case professionalServices = "professional_services"
                    case publicWarehousingAndStorage = "public_warehousing_and_storage"
                    case quickCopyReproAndBlueprint = "quick_copy_repro_and_blueprint"
                    case railroads
                    case realEstateAgentsAndManagersRentals = "real_estate_agents_and_managers_rentals"
                    case recordStores = "record_stores"
                    case recreationalVehicleRentals = "recreational_vehicle_rentals"
                    case religiousGoodsStores = "religious_goods_stores"
                    case religiousOrganizations = "religious_organizations"
                    case roofingSidingSheetMetal = "roofing_siding_sheet_metal"
                    case secretarialSupportServices = "secretarial_support_services"
                    case securityBrokersDealers = "security_brokers_dealers"
                    case serviceStations = "service_stations"
                    case sewingNeedleworkFabricAndPieceGoodsStores = "sewing_needlework_fabric_and_piece_goods_stores"
                    case shoeRepairHatCleaning = "shoe_repair_hat_cleaning"
                    case shoeStores = "shoe_stores"
                    case smallApplianceRepair = "small_appliance_repair"
                    case snowmobileDealers = "snowmobile_dealers"
                    case specialTradeServices = "special_trade_services"
                    case specialtyCleaning = "specialty_cleaning"
                    case sportingGoodsStores = "sporting_goods_stores"
                    case sportingRecreationCamps = "sporting_recreation_camps"
                    case sportsAndRidingApparelStores = "sports_and_riding_apparel_stores"
                    case sportsClubsFields = "sports_clubs_fields"
                    case stampAndCoinStores = "stamp_and_coin_stores"
                    case stationaryOfficeSuppliesPrintingAndWritingPaper = "stationary_office_supplies_printing_and_writing_paper"
                    case stationeryStoresOfficeAndSchoolSupplyStores = "stationery_stores_office_and_school_supply_stores"
                    case swimmingPoolsSales = "swimming_pools_sales"
                    case tUiTravelGermany = "t_ui_travel_germany"
                    case tailorsAlterations = "tailors_alterations"
                    case taxPaymentsGovernmentAgencies = "tax_payments_government_agencies"
                    case taxPreparationServices = "tax_preparation_services"
                    case taxicabsLimousines = "taxicabs_limousines"
                    case telecommunicationEquipmentAndTelephoneSales = "telecommunication_equipment_and_telephone_sales"
                    case telecommunicationServices = "telecommunication_services"
                    case telegraphServices = "telegraph_services"
                    case tentAndAwningShops = "tent_and_awning_shops"
                    case testingLaboratories = "testing_laboratories"
                    case theatricalTicketAgencies = "theatrical_ticket_agencies"
                    case timeshares
                    case tireRetreadingAndRepair = "tire_retreading_and_repair"
                    case tollsBridgeFees = "tolls_bridge_fees"
                    case touristAttractionsAndExhibits = "tourist_attractions_and_exhibits"
                    case towingServices = "towing_services"
                    case trailerParksCampgrounds = "trailer_parks_campgrounds"
                    case transportationServices = "transportation_services"
                    case travelAgenciesTourOperators = "travel_agencies_tour_operators"
                    case truckStopIteration = "truck_stop_iteration"
                    case truckUtilityTrailerRentals = "truck_utility_trailer_rentals"
                    case typesettingPlateMakingAndRelatedServices = "typesetting_plate_making_and_related_services"
                    case typewriterStores = "typewriter_stores"
                    case uSFederalGovernmentAgenciesOrDepartments = "u_s_federal_government_agencies_or_departments"
                    case uniformsCommercialClothing = "uniforms_commercial_clothing"
                    case usedMerchandiseAndSecondhandStores = "used_merchandise_and_secondhand_stores"
                    case utilities
                    case varietyStores = "variety_stores"
                    case veterinaryServices = "veterinary_services"
                    case videoAmusementGameSupplies = "video_amusement_game_supplies"
                    case videoGameArcades = "video_game_arcades"
                    case videoTapeRentalStores = "video_tape_rental_stores"
                    case vocationalTradeSchools = "vocational_trade_schools"
                    case watchJewelryRepair = "watch_jewelry_repair"
                    case weldingRepair = "welding_repair"
                    case wholesaleClubs = "wholesale_clubs"
                    case wigAndToupeeStores = "wig_and_toupee_stores"
                    case wiresMoneyOrders = "wires_money_orders"
                    case womensAccessoryAndSpecialtyShops = "womens_accessory_and_specialty_shops"
                    case womensReadyToWearStores = "womens_ready_to_wear_stores"
                    case wreckingAndSalvageYards = "wrecking_and_salvage_yards"
                }

                /// Spending_limits_param
                public struct SpendingLimit: Encodable {
                    public var amount: Int
                    public var categories: [Category]?
                    public var interval: Interval

                    public enum Category: String, Codable, CaseIterable {
                        case acRefrigerationRepair = "ac_refrigeration_repair"
                        case accountingBookkeepingServices = "accounting_bookkeeping_services"
                        case advertisingServices = "advertising_services"
                        case agriculturalCooperative = "agricultural_cooperative"
                        case airlinesAirCarriers = "airlines_air_carriers"
                        case airportsFlyingFields = "airports_flying_fields"
                        case ambulanceServices = "ambulance_services"
                        case amusementParksCarnivals = "amusement_parks_carnivals"
                        case antiqueReproductions = "antique_reproductions"
                        case antiqueShops = "antique_shops"
                        case aquariums
                        case architecturalSurveyingServices = "architectural_surveying_services"
                        case artDealersAndGalleries = "art_dealers_and_galleries"
                        case artistsSupplyAndCraftShops = "artists_supply_and_craft_shops"
                        case autoAndHomeSupplyStores = "auto_and_home_supply_stores"
                        case autoBodyRepairShops = "auto_body_repair_shops"
                        case autoPaintShops = "auto_paint_shops"
                        case autoServiceShops = "auto_service_shops"
                        case automatedCashDisburse = "automated_cash_disburse"
                        case automatedFuelDispensers = "automated_fuel_dispensers"
                        case automobileAssociations = "automobile_associations"
                        case automotivePartsAndAccessoriesStores = "automotive_parts_and_accessories_stores"
                        case automotiveTireStores = "automotive_tire_stores"
                        case bailAndBondPayments = "bail_and_bond_payments"
                        case bakeries
                        case bandsOrchestras = "bands_orchestras"
                        case barberAndBeautyShops = "barber_and_beauty_shops"
                        case bettingCasinoGambling = "betting_casino_gambling"
                        case bicycleShops = "bicycle_shops"
                        case billiardPoolEstablishments = "billiard_pool_establishments"
                        case boatDealers = "boat_dealers"
                        case boatRentalsAndLeases = "boat_rentals_and_leases"
                        case bookStores = "book_stores"
                        case booksPeriodicalsAndNewspapers = "books_periodicals_and_newspapers"
                        case bowlingAlleys = "bowling_alleys"
                        case busLines = "bus_lines"
                        case businessSecretarialSchools = "business_secretarial_schools"
                        case buyingShoppingServices = "buying_shopping_services"
                        case cableSatelliteAndOtherPayTelevisionAndRadio = "cable_satellite_and_other_pay_television_and_radio"
                        case cameraAndPhotographicSupplyStores = "camera_and_photographic_supply_stores"
                        case candyNutAndConfectioneryStores = "candy_nut_and_confectionery_stores"
                        case carAndTruckDealersNewUsed = "car_and_truck_dealers_new_used"
                        case carAndTruckDealersUsedOnly = "car_and_truck_dealers_used_only"
                        case carRentalAgencies = "car_rental_agencies"
                        case carWashes = "car_washes"
                        case carpentryServices = "carpentry_services"
                        case carpetUpholsteryCleaning = "carpet_upholstery_cleaning"
                        case caterers
                        case charitableAndSocialServiceOrganizationsFundraising = "charitable_and_social_service_organizations_fundraising"
                        case chemicalsAndAlliedProducts = "chemicals_and_allied_products"
                        case childCareServices = "child_care_services"
                        case childrensAndInfantsWearStores = "childrens_and_infants_wear_stores"
                        case chiropodistsPodiatrists = "chiropodists_podiatrists"
                        case chiropractors
                        case cigarStoresAndStands = "cigar_stores_and_stands"
                        case civicSocialFraternalAssociations = "civic_social_fraternal_associations"
                        case cleaningAndMaintenance = "cleaning_and_maintenance"
                        case clothingRental = "clothing_rental"
                        case collegesUniversities = "colleges_universities"
                        case commercialEquipment = "commercial_equipment"
                        case commercialFootwear = "commercial_footwear"
                        case commercialPhotographyArtAndGraphics = "commercial_photography_art_and_graphics"
                        case commuterTransportAndFerries = "commuter_transport_and_ferries"
                        case computerNetworkServices = "computer_network_services"
                        case computerProgramming = "computer_programming"
                        case computerRepair = "computer_repair"
                        case computerSoftwareStores = "computer_software_stores"
                        case computersPeripheralsAndSoftware = "computers_peripherals_and_software"
                        case concreteWorkServices = "concrete_work_services"
                        case constructionMaterials = "construction_materials"
                        case consultingPublicRelations = "consulting_public_relations"
                        case correspondenceSchools = "correspondence_schools"
                        case cosmeticStores = "cosmetic_stores"
                        case counselingServices = "counseling_services"
                        case countryClubs = "country_clubs"
                        case courierServices = "courier_services"
                        case courtCosts = "court_costs"
                        case creditReportingAgencies = "credit_reporting_agencies"
                        case cruiseLines = "cruise_lines"
                        case dairyProductsStores = "dairy_products_stores"
                        case danceHallStudiosSchools = "dance_hall_studios_schools"
                        case datingEscortServices = "dating_escort_services"
                        case dentistsOrthodontists = "dentists_orthodontists"
                        case departmentStores = "department_stores"
                        case detectiveAgencies = "detective_agencies"
                        case digitalGoodsApplications = "digital_goods_applications"
                        case digitalGoodsGames = "digital_goods_games"
                        case digitalGoodsLargeVolume = "digital_goods_large_volume"
                        case digitalGoodsMedia = "digital_goods_media"
                        case directMarketingCatalogMerchant = "direct_marketing_catalog_merchant"
                        case directMarketingCombinationCatalogAndRetailMerchant = "direct_marketing_combination_catalog_and_retail_merchant"
                        case directMarketingInboundTelemarketing = "direct_marketing_inbound_telemarketing"
                        case directMarketingInsuranceServices = "direct_marketing_insurance_services"
                        case directMarketingOther = "direct_marketing_other"
                        case directMarketingOutboundTelemarketing = "direct_marketing_outbound_telemarketing"
                        case directMarketingSubscription = "direct_marketing_subscription"
                        case directMarketingTravel = "direct_marketing_travel"
                        case discountStores = "discount_stores"
                        case doctors
                        case doorToDoorSales = "door_to_door_sales"
                        case draperyWindowCoveringAndUpholsteryStores = "drapery_window_covering_and_upholstery_stores"
                        case drinkingPlaces = "drinking_places"
                        case drugStoresAndPharmacies = "drug_stores_and_pharmacies"
                        case drugsDrugProprietariesAndDruggistSundries = "drugs_drug_proprietaries_and_druggist_sundries"
                        case dryCleaners = "dry_cleaners"
                        case durableGoods = "durable_goods"
                        case dutyFreeStores = "duty_free_stores"
                        case eatingPlacesRestaurants = "eating_places_restaurants"
                        case educationalServices = "educational_services"
                        case electricRazorStores = "electric_razor_stores"
                        case electricalPartsAndEquipment = "electrical_parts_and_equipment"
                        case electricalServices = "electrical_services"
                        case electronicsRepairShops = "electronics_repair_shops"
                        case electronicsStores = "electronics_stores"
                        case elementarySecondarySchools = "elementary_secondary_schools"
                        case employmentTempAgencies = "employment_temp_agencies"
                        case equipmentRental = "equipment_rental"
                        case exterminatingServices = "exterminating_services"
                        case familyClothingStores = "family_clothing_stores"
                        case fastFoodRestaurants = "fast_food_restaurants"
                        case financialInstitutions = "financial_institutions"
                        case finesGovernmentAdministrativeEntities = "fines_government_administrative_entities"
                        case fireplaceFireplaceScreensAndAccessoriesStores = "fireplace_fireplace_screens_and_accessories_stores"
                        case floorCoveringStores = "floor_covering_stores"
                        case florists
                        case floristsSuppliesNurseryStockAndFlowers = "florists_supplies_nursery_stock_and_flowers"
                        case freezerAndLockerMeatProvisioners = "freezer_and_locker_meat_provisioners"
                        case fuelDealersNonAutomotive = "fuel_dealers_non_automotive"
                        case funeralServicesCrematories = "funeral_services_crematories"
                        case furnitureHomeFurnishingsAndEquipmentStoresExceptAppliances = "furniture_home_furnishings_and_equipment_stores_except_appliances"
                        case furnitureRepairRefinishing = "furniture_repair_refinishing"
                        case furriersAndFurShops = "furriers_and_fur_shops"
                        case generalServices = "general_services"
                        case giftCardNoveltyAndSouvenirShops = "gift_card_novelty_and_souvenir_shops"
                        case glassPaintAndWallpaperStores = "glass_paint_and_wallpaper_stores"
                        case glasswareCrystalStores = "glassware_crystal_stores"
                        case golfCoursesPublic = "golf_courses_public"
                        case governmentServices = "government_services"
                        case groceryStoresSupermarkets = "grocery_stores_supermarkets"
                        case hardwareEquipmentAndSupplies = "hardware_equipment_and_supplies"
                        case hardwareStores = "hardware_stores"
                        case healthAndBeautySpas = "health_and_beauty_spas"
                        case hearingAidsSalesAndSupplies = "hearing_aids_sales_and_supplies"
                        case heatingPlumbingAC = "heating_plumbing_a_c"
                        case hobbyToyAndGameShops = "hobby_toy_and_game_shops"
                        case homeSupplyWarehouseStores = "home_supply_warehouse_stores"
                        case hospitals
                        case hotelsMotelsAndResorts = "hotels_motels_and_resorts"
                        case householdApplianceStores = "household_appliance_stores"
                        case industrialSupplies = "industrial_supplies"
                        case informationRetrievalServices = "information_retrieval_services"
                        case insuranceDefault = "insurance_default"
                        case insuranceUnderwritingPremiums = "insurance_underwriting_premiums"
                        case intraCompanyPurchases = "intra_company_purchases"
                        case jewelryStoresWatchesClocksAndSilverwareStores = "jewelry_stores_watches_clocks_and_silverware_stores"
                        case landscapingServices = "landscaping_services"
                        case laundries
                        case laundryCleaningServices = "laundry_cleaning_services"
                        case legalServicesAttorneys = "legal_services_attorneys"
                        case luggageAndLeatherGoodsStores = "luggage_and_leather_goods_stores"
                        case lumberBuildingMaterialsStores = "lumber_building_materials_stores"
                        case manualCashDisburse = "manual_cash_disburse"
                        case marinasServiceAndSupplies = "marinas_service_and_supplies"
                        case masonryStoneworkAndPlaster = "masonry_stonework_and_plaster"
                        case massageParlors = "massage_parlors"
                        case medicalAndDentalLabs = "medical_and_dental_labs"
                        case medicalDentalOphthalmicAndHospitalEquipmentAndSupplies = "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
                        case medicalServices = "medical_services"
                        case membershipOrganizations = "membership_organizations"
                        case mensAndBoysClothingAndAccessoriesStores = "mens_and_boys_clothing_and_accessories_stores"
                        case mensWomensClothingStores = "mens_womens_clothing_stores"
                        case metalServiceCenters = "metal_service_centers"
                        case miscellaneous
                        case miscellaneousApparelAndAccessoryShops = "miscellaneous_apparel_and_accessory_shops"
                        case miscellaneousAutoDealers = "miscellaneous_auto_dealers"
                        case miscellaneousBusinessServices = "miscellaneous_business_services"
                        case miscellaneousFoodStores = "miscellaneous_food_stores"
                        case miscellaneousGeneralMerchandise = "miscellaneous_general_merchandise"
                        case miscellaneousGeneralServices = "miscellaneous_general_services"
                        case miscellaneousHomeFurnishingSpecialtyStores = "miscellaneous_home_furnishing_specialty_stores"
                        case miscellaneousPublishingAndPrinting = "miscellaneous_publishing_and_printing"
                        case miscellaneousRecreationServices = "miscellaneous_recreation_services"
                        case miscellaneousRepairShops = "miscellaneous_repair_shops"
                        case miscellaneousSpecialtyRetail = "miscellaneous_specialty_retail"
                        case mobileHomeDealers = "mobile_home_dealers"
                        case motionPictureTheaters = "motion_picture_theaters"
                        case motorFreightCarriersAndTrucking = "motor_freight_carriers_and_trucking"
                        case motorHomesDealers = "motor_homes_dealers"
                        case motorVehicleSuppliesAndNewParts = "motor_vehicle_supplies_and_new_parts"
                        case motorcycleShopsAndDealers = "motorcycle_shops_and_dealers"
                        case motorcycleShopsDealers = "motorcycle_shops_dealers"
                        case musicStoresMusicalInstrumentsPianosAndSheetMusic = "music_stores_musical_instruments_pianos_and_sheet_music"
                        case newsDealersAndNewsstands = "news_dealers_and_newsstands"
                        case nonFiMoneyOrders = "non_fi_money_orders"
                        case nonFiStoredValueCardPurchaseLoad = "non_fi_stored_value_card_purchase_load"
                        case nondurableGoods = "nondurable_goods"
                        case nurseriesLawnAndGardenSupplyStores = "nurseries_lawn_and_garden_supply_stores"
                        case nursingPersonalCare = "nursing_personal_care"
                        case officeAndCommercialFurniture = "office_and_commercial_furniture"
                        case opticiansEyeglasses = "opticians_eyeglasses"
                        case optometristsOphthalmologist = "optometrists_ophthalmologist"
                        case orthopedicGoodsProstheticDevices = "orthopedic_goods_prosthetic_devices"
                        case osteopaths
                        case packageStoresBeerWineAndLiquor = "package_stores_beer_wine_and_liquor"
                        case paintsVarnishesAndSupplies = "paints_varnishes_and_supplies"
                        case parkingLotsGarages = "parking_lots_garages"
                        case passengerRailways = "passenger_railways"
                        case pawnShops = "pawn_shops"
                        case petShopsPetFoodAndSupplies = "pet_shops_pet_food_and_supplies"
                        case petroleumAndPetroleumProducts = "petroleum_and_petroleum_products"
                        case photoDeveloping = "photo_developing"
                        case photographicPhotocopyMicrofilmEquipmentAndSupplies = "photographic_photocopy_microfilm_equipment_and_supplies"
                        case photographicStudios = "photographic_studios"
                        case pictureVideoProduction = "picture_video_production"
                        case pieceGoodsNotionsAndOtherDryGoods = "piece_goods_notions_and_other_dry_goods"
                        case plumbingHeatingEquipmentAndSupplies = "plumbing_heating_equipment_and_supplies"
                        case politicalOrganizations = "political_organizations"
                        case postalServicesGovernmentOnly = "postal_services_government_only"
                        case preciousStonesAndMetalsWatchesAndJewelry = "precious_stones_and_metals_watches_and_jewelry"
                        case professionalServices = "professional_services"
                        case publicWarehousingAndStorage = "public_warehousing_and_storage"
                        case quickCopyReproAndBlueprint = "quick_copy_repro_and_blueprint"
                        case railroads
                        case realEstateAgentsAndManagersRentals = "real_estate_agents_and_managers_rentals"
                        case recordStores = "record_stores"
                        case recreationalVehicleRentals = "recreational_vehicle_rentals"
                        case religiousGoodsStores = "religious_goods_stores"
                        case religiousOrganizations = "religious_organizations"
                        case roofingSidingSheetMetal = "roofing_siding_sheet_metal"
                        case secretarialSupportServices = "secretarial_support_services"
                        case securityBrokersDealers = "security_brokers_dealers"
                        case serviceStations = "service_stations"
                        case sewingNeedleworkFabricAndPieceGoodsStores = "sewing_needlework_fabric_and_piece_goods_stores"
                        case shoeRepairHatCleaning = "shoe_repair_hat_cleaning"
                        case shoeStores = "shoe_stores"
                        case smallApplianceRepair = "small_appliance_repair"
                        case snowmobileDealers = "snowmobile_dealers"
                        case specialTradeServices = "special_trade_services"
                        case specialtyCleaning = "specialty_cleaning"
                        case sportingGoodsStores = "sporting_goods_stores"
                        case sportingRecreationCamps = "sporting_recreation_camps"
                        case sportsAndRidingApparelStores = "sports_and_riding_apparel_stores"
                        case sportsClubsFields = "sports_clubs_fields"
                        case stampAndCoinStores = "stamp_and_coin_stores"
                        case stationaryOfficeSuppliesPrintingAndWritingPaper = "stationary_office_supplies_printing_and_writing_paper"
                        case stationeryStoresOfficeAndSchoolSupplyStores = "stationery_stores_office_and_school_supply_stores"
                        case swimmingPoolsSales = "swimming_pools_sales"
                        case tUiTravelGermany = "t_ui_travel_germany"
                        case tailorsAlterations = "tailors_alterations"
                        case taxPaymentsGovernmentAgencies = "tax_payments_government_agencies"
                        case taxPreparationServices = "tax_preparation_services"
                        case taxicabsLimousines = "taxicabs_limousines"
                        case telecommunicationEquipmentAndTelephoneSales = "telecommunication_equipment_and_telephone_sales"
                        case telecommunicationServices = "telecommunication_services"
                        case telegraphServices = "telegraph_services"
                        case tentAndAwningShops = "tent_and_awning_shops"
                        case testingLaboratories = "testing_laboratories"
                        case theatricalTicketAgencies = "theatrical_ticket_agencies"
                        case timeshares
                        case tireRetreadingAndRepair = "tire_retreading_and_repair"
                        case tollsBridgeFees = "tolls_bridge_fees"
                        case touristAttractionsAndExhibits = "tourist_attractions_and_exhibits"
                        case towingServices = "towing_services"
                        case trailerParksCampgrounds = "trailer_parks_campgrounds"
                        case transportationServices = "transportation_services"
                        case travelAgenciesTourOperators = "travel_agencies_tour_operators"
                        case truckStopIteration = "truck_stop_iteration"
                        case truckUtilityTrailerRentals = "truck_utility_trailer_rentals"
                        case typesettingPlateMakingAndRelatedServices = "typesetting_plate_making_and_related_services"
                        case typewriterStores = "typewriter_stores"
                        case uSFederalGovernmentAgenciesOrDepartments = "u_s_federal_government_agencies_or_departments"
                        case uniformsCommercialClothing = "uniforms_commercial_clothing"
                        case usedMerchandiseAndSecondhandStores = "used_merchandise_and_secondhand_stores"
                        case utilities
                        case varietyStores = "variety_stores"
                        case veterinaryServices = "veterinary_services"
                        case videoAmusementGameSupplies = "video_amusement_game_supplies"
                        case videoGameArcades = "video_game_arcades"
                        case videoTapeRentalStores = "video_tape_rental_stores"
                        case vocationalTradeSchools = "vocational_trade_schools"
                        case watchJewelryRepair = "watch_jewelry_repair"
                        case weldingRepair = "welding_repair"
                        case wholesaleClubs = "wholesale_clubs"
                        case wigAndToupeeStores = "wig_and_toupee_stores"
                        case wiresMoneyOrders = "wires_money_orders"
                        case womensAccessoryAndSpecialtyShops = "womens_accessory_and_specialty_shops"
                        case womensReadyToWearStores = "womens_ready_to_wear_stores"
                        case wreckingAndSalvageYards = "wrecking_and_salvage_yards"
                    }

                    public enum Interval: String, Codable, CaseIterable {
                        case allTime = "all_time"
                        case daily
                        case monthly
                        case perAuthorization = "per_authorization"
                        case weekly
                        case yearly
                    }

                    public init(amount: Int, categories: [Category]? = nil, interval: Interval) {
                        self.amount = amount
                        self.categories = categories
                        self.interval = interval
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amount, forKey: "amount")
                        encoder.encode(categories, forKey: "categories")
                        encoder.encode(interval, forKey: "interval")
                        return encoder.items
                    }
                }

                public init(allowedCategories: [AllowedCategory]? = nil, blockedCategories: [BlockedCategory]? = nil, spendingLimits: [SpendingLimit]? = nil, spendingLimitsCurrency: String? = nil) {
                    self.allowedCategories = allowedCategories
                    self.blockedCategories = blockedCategories
                    self.spendingLimits = spendingLimits
                    self.spendingLimitsCurrency = spendingLimitsCurrency
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(allowedCategories, forKey: "allowed_categories")
                    encoder.encode(blockedCategories, forKey: "blocked_categories")
                    encoder.encode(spendingLimits, forKey: "spending_limits")
                    encoder.encode(spendingLimitsCurrency, forKey: "spending_limits_currency")
                    return encoder.items
                }
            }

            /// Specifies whether to permit authorizations on this cardholder's cards.
            public enum Status: String, Codable, CaseIterable {
                case active
                case inactive
            }

            public init(billing: Billing? = nil, company: Company? = nil, email: String? = nil, expand: [String]? = nil, individual: Individual? = nil, metadata: [String: String]? = nil, phoneNumber: String? = nil, spendingControls: SpendingControls? = nil, status: Status? = nil) {
                self.billing = billing
                self.company = company
                self.email = email
                self.expand = expand
                self.individual = individual
                self.metadata = metadata
                self.phoneNumber = phoneNumber
                self.spendingControls = spendingControls
                self.status = status
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(billing, forKey: "billing")
                encoder.encode(company, forKey: "company")
                encoder.encode(email, forKey: "email")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(individual, forKey: "individual")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(phoneNumber, forKey: "phone_number")
                encoder.encode(spendingControls, forKey: "spending_controls")
                encoder.encode(status, forKey: "status")
                return encoder.items
            }
        }
    }
}

extension Paths.Issuing {
    public var cards: Cards {
        Cards(path: path + "/cards")
    }

    public struct Cards {
        /// Path: `/v1/issuing/cards`
        public let path: String

        /// <p>Returns a list of Issuing <code>Card</code> objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.IssuingCard]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.IssuingCard], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var cardholder: String?
            public var created: Created?
            public var endingBefore: String?
            public var expMonth: Int?
            public var expYear: Int?
            public var expand: [String]?
            public var last4: String?
            public var limit: Int?
            public var startingAfter: String?
            public var status: Status?
            public var type: `Type`?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public enum Status: String, Codable, CaseIterable {
                case active
                case canceled
                case inactive
            }

            public enum `Type`: String, Codable, CaseIterable {
                case physical
                case virtual
            }

            public init(cardholder: String? = nil, created: Created? = nil, endingBefore: String? = nil, expMonth: Int? = nil, expYear: Int? = nil, expand: [String]? = nil, last4: String? = nil, limit: Int? = nil, startingAfter: String? = nil, status: Status? = nil, type: `Type`? = nil) {
                self.cardholder = cardholder
                self.created = created
                self.endingBefore = endingBefore
                self.expMonth = expMonth
                self.expYear = expYear
                self.expand = expand
                self.last4 = last4
                self.limit = limit
                self.startingAfter = startingAfter
                self.status = status
                self.type = type
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(cardholder, forKey: "cardholder")
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expMonth, forKey: "exp_month")
                encoder.encode(expYear, forKey: "exp_year")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(last4, forKey: "last4")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(status, forKey: "status")
                encoder.encode(type, forKey: "type")
                return encoder.items
            }
        }

        /// <p>Creates an Issuing <code>Card</code> object.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.IssuingCard> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The [Cardholder](https://stripe.com/docs/api#issuing_cardholder_object) object with which the card will be associated.
            public var cardholder: String?
            /// The currency for the card.
            public var currency: String
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// The card this is meant to be a replacement for (if any).
            public var replacementFor: String?
            /// If `replacement_for` is specified, this should indicate why that card is being replaced.
            public var replacementReason: ReplacementReason?
            /// Shipping_specs
            ///
            /// The address where the card will be shipped.
            public var shipping: Shipping?
            /// Authorization_controls_param
            ///
            /// Rules that control spending for this card. Refer to our [documentation](https://stripe.com/docs/issuing/controls/spending-controls) for more details.
            public var spendingControls: SpendingControls?
            /// Whether authorizations can be approved on this card. Defaults to `inactive`.
            public var status: Status?
            /// The type of card to issue. Possible values are `physical` or `virtual`.
            public var type: `Type`

            /// If `replacement_for` is specified, this should indicate why that card is being replaced.
            public enum ReplacementReason: String, Codable, CaseIterable {
                case damaged
                case expired
                case lost
                case stolen
            }

            /// Shipping_specs
            ///
            /// The address where the card will be shipped.
            public struct Shipping: Encodable {
                /// Required_address
                public var address: Address
                public var name: String
                public var service: Service?
                public var type: `Type`?

                /// Required_address
                public struct Address: Encodable {
                    public var city: String
                    public var country: String
                    public var line1: String
                    public var line2: String?
                    public var postalCode: String
                    public var state: String?

                    public init(city: String, country: String, line1: String, line2: String? = nil, postalCode: String, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                public enum Service: String, Codable, CaseIterable {
                    case express
                    case priority
                    case standard
                }

                public enum `Type`: String, Codable, CaseIterable {
                    case bulk
                    case individual
                }

                public init(address: Address, name: String, service: Service? = nil, type: `Type`? = nil) {
                    self.address = address
                    self.name = name
                    self.service = service
                    self.type = type
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(name, forKey: "name")
                    encoder.encode(service, forKey: "service")
                    encoder.encode(type, forKey: "type")
                    return encoder.items
                }
            }

            /// Authorization_controls_param
            ///
            /// Rules that control spending for this card. Refer to our [documentation](https://stripe.com/docs/issuing/controls/spending-controls) for more details.
            public struct SpendingControls: Encodable {
                public var allowedCategories: [AllowedCategory]?
                public var blockedCategories: [BlockedCategory]?
                public var spendingLimits: [SpendingLimit]?

                public enum AllowedCategory: String, Codable, CaseIterable {
                    case acRefrigerationRepair = "ac_refrigeration_repair"
                    case accountingBookkeepingServices = "accounting_bookkeeping_services"
                    case advertisingServices = "advertising_services"
                    case agriculturalCooperative = "agricultural_cooperative"
                    case airlinesAirCarriers = "airlines_air_carriers"
                    case airportsFlyingFields = "airports_flying_fields"
                    case ambulanceServices = "ambulance_services"
                    case amusementParksCarnivals = "amusement_parks_carnivals"
                    case antiqueReproductions = "antique_reproductions"
                    case antiqueShops = "antique_shops"
                    case aquariums
                    case architecturalSurveyingServices = "architectural_surveying_services"
                    case artDealersAndGalleries = "art_dealers_and_galleries"
                    case artistsSupplyAndCraftShops = "artists_supply_and_craft_shops"
                    case autoAndHomeSupplyStores = "auto_and_home_supply_stores"
                    case autoBodyRepairShops = "auto_body_repair_shops"
                    case autoPaintShops = "auto_paint_shops"
                    case autoServiceShops = "auto_service_shops"
                    case automatedCashDisburse = "automated_cash_disburse"
                    case automatedFuelDispensers = "automated_fuel_dispensers"
                    case automobileAssociations = "automobile_associations"
                    case automotivePartsAndAccessoriesStores = "automotive_parts_and_accessories_stores"
                    case automotiveTireStores = "automotive_tire_stores"
                    case bailAndBondPayments = "bail_and_bond_payments"
                    case bakeries
                    case bandsOrchestras = "bands_orchestras"
                    case barberAndBeautyShops = "barber_and_beauty_shops"
                    case bettingCasinoGambling = "betting_casino_gambling"
                    case bicycleShops = "bicycle_shops"
                    case billiardPoolEstablishments = "billiard_pool_establishments"
                    case boatDealers = "boat_dealers"
                    case boatRentalsAndLeases = "boat_rentals_and_leases"
                    case bookStores = "book_stores"
                    case booksPeriodicalsAndNewspapers = "books_periodicals_and_newspapers"
                    case bowlingAlleys = "bowling_alleys"
                    case busLines = "bus_lines"
                    case businessSecretarialSchools = "business_secretarial_schools"
                    case buyingShoppingServices = "buying_shopping_services"
                    case cableSatelliteAndOtherPayTelevisionAndRadio = "cable_satellite_and_other_pay_television_and_radio"
                    case cameraAndPhotographicSupplyStores = "camera_and_photographic_supply_stores"
                    case candyNutAndConfectioneryStores = "candy_nut_and_confectionery_stores"
                    case carAndTruckDealersNewUsed = "car_and_truck_dealers_new_used"
                    case carAndTruckDealersUsedOnly = "car_and_truck_dealers_used_only"
                    case carRentalAgencies = "car_rental_agencies"
                    case carWashes = "car_washes"
                    case carpentryServices = "carpentry_services"
                    case carpetUpholsteryCleaning = "carpet_upholstery_cleaning"
                    case caterers
                    case charitableAndSocialServiceOrganizationsFundraising = "charitable_and_social_service_organizations_fundraising"
                    case chemicalsAndAlliedProducts = "chemicals_and_allied_products"
                    case childCareServices = "child_care_services"
                    case childrensAndInfantsWearStores = "childrens_and_infants_wear_stores"
                    case chiropodistsPodiatrists = "chiropodists_podiatrists"
                    case chiropractors
                    case cigarStoresAndStands = "cigar_stores_and_stands"
                    case civicSocialFraternalAssociations = "civic_social_fraternal_associations"
                    case cleaningAndMaintenance = "cleaning_and_maintenance"
                    case clothingRental = "clothing_rental"
                    case collegesUniversities = "colleges_universities"
                    case commercialEquipment = "commercial_equipment"
                    case commercialFootwear = "commercial_footwear"
                    case commercialPhotographyArtAndGraphics = "commercial_photography_art_and_graphics"
                    case commuterTransportAndFerries = "commuter_transport_and_ferries"
                    case computerNetworkServices = "computer_network_services"
                    case computerProgramming = "computer_programming"
                    case computerRepair = "computer_repair"
                    case computerSoftwareStores = "computer_software_stores"
                    case computersPeripheralsAndSoftware = "computers_peripherals_and_software"
                    case concreteWorkServices = "concrete_work_services"
                    case constructionMaterials = "construction_materials"
                    case consultingPublicRelations = "consulting_public_relations"
                    case correspondenceSchools = "correspondence_schools"
                    case cosmeticStores = "cosmetic_stores"
                    case counselingServices = "counseling_services"
                    case countryClubs = "country_clubs"
                    case courierServices = "courier_services"
                    case courtCosts = "court_costs"
                    case creditReportingAgencies = "credit_reporting_agencies"
                    case cruiseLines = "cruise_lines"
                    case dairyProductsStores = "dairy_products_stores"
                    case danceHallStudiosSchools = "dance_hall_studios_schools"
                    case datingEscortServices = "dating_escort_services"
                    case dentistsOrthodontists = "dentists_orthodontists"
                    case departmentStores = "department_stores"
                    case detectiveAgencies = "detective_agencies"
                    case digitalGoodsApplications = "digital_goods_applications"
                    case digitalGoodsGames = "digital_goods_games"
                    case digitalGoodsLargeVolume = "digital_goods_large_volume"
                    case digitalGoodsMedia = "digital_goods_media"
                    case directMarketingCatalogMerchant = "direct_marketing_catalog_merchant"
                    case directMarketingCombinationCatalogAndRetailMerchant = "direct_marketing_combination_catalog_and_retail_merchant"
                    case directMarketingInboundTelemarketing = "direct_marketing_inbound_telemarketing"
                    case directMarketingInsuranceServices = "direct_marketing_insurance_services"
                    case directMarketingOther = "direct_marketing_other"
                    case directMarketingOutboundTelemarketing = "direct_marketing_outbound_telemarketing"
                    case directMarketingSubscription = "direct_marketing_subscription"
                    case directMarketingTravel = "direct_marketing_travel"
                    case discountStores = "discount_stores"
                    case doctors
                    case doorToDoorSales = "door_to_door_sales"
                    case draperyWindowCoveringAndUpholsteryStores = "drapery_window_covering_and_upholstery_stores"
                    case drinkingPlaces = "drinking_places"
                    case drugStoresAndPharmacies = "drug_stores_and_pharmacies"
                    case drugsDrugProprietariesAndDruggistSundries = "drugs_drug_proprietaries_and_druggist_sundries"
                    case dryCleaners = "dry_cleaners"
                    case durableGoods = "durable_goods"
                    case dutyFreeStores = "duty_free_stores"
                    case eatingPlacesRestaurants = "eating_places_restaurants"
                    case educationalServices = "educational_services"
                    case electricRazorStores = "electric_razor_stores"
                    case electricalPartsAndEquipment = "electrical_parts_and_equipment"
                    case electricalServices = "electrical_services"
                    case electronicsRepairShops = "electronics_repair_shops"
                    case electronicsStores = "electronics_stores"
                    case elementarySecondarySchools = "elementary_secondary_schools"
                    case employmentTempAgencies = "employment_temp_agencies"
                    case equipmentRental = "equipment_rental"
                    case exterminatingServices = "exterminating_services"
                    case familyClothingStores = "family_clothing_stores"
                    case fastFoodRestaurants = "fast_food_restaurants"
                    case financialInstitutions = "financial_institutions"
                    case finesGovernmentAdministrativeEntities = "fines_government_administrative_entities"
                    case fireplaceFireplaceScreensAndAccessoriesStores = "fireplace_fireplace_screens_and_accessories_stores"
                    case floorCoveringStores = "floor_covering_stores"
                    case florists
                    case floristsSuppliesNurseryStockAndFlowers = "florists_supplies_nursery_stock_and_flowers"
                    case freezerAndLockerMeatProvisioners = "freezer_and_locker_meat_provisioners"
                    case fuelDealersNonAutomotive = "fuel_dealers_non_automotive"
                    case funeralServicesCrematories = "funeral_services_crematories"
                    case furnitureHomeFurnishingsAndEquipmentStoresExceptAppliances = "furniture_home_furnishings_and_equipment_stores_except_appliances"
                    case furnitureRepairRefinishing = "furniture_repair_refinishing"
                    case furriersAndFurShops = "furriers_and_fur_shops"
                    case generalServices = "general_services"
                    case giftCardNoveltyAndSouvenirShops = "gift_card_novelty_and_souvenir_shops"
                    case glassPaintAndWallpaperStores = "glass_paint_and_wallpaper_stores"
                    case glasswareCrystalStores = "glassware_crystal_stores"
                    case golfCoursesPublic = "golf_courses_public"
                    case governmentServices = "government_services"
                    case groceryStoresSupermarkets = "grocery_stores_supermarkets"
                    case hardwareEquipmentAndSupplies = "hardware_equipment_and_supplies"
                    case hardwareStores = "hardware_stores"
                    case healthAndBeautySpas = "health_and_beauty_spas"
                    case hearingAidsSalesAndSupplies = "hearing_aids_sales_and_supplies"
                    case heatingPlumbingAC = "heating_plumbing_a_c"
                    case hobbyToyAndGameShops = "hobby_toy_and_game_shops"
                    case homeSupplyWarehouseStores = "home_supply_warehouse_stores"
                    case hospitals
                    case hotelsMotelsAndResorts = "hotels_motels_and_resorts"
                    case householdApplianceStores = "household_appliance_stores"
                    case industrialSupplies = "industrial_supplies"
                    case informationRetrievalServices = "information_retrieval_services"
                    case insuranceDefault = "insurance_default"
                    case insuranceUnderwritingPremiums = "insurance_underwriting_premiums"
                    case intraCompanyPurchases = "intra_company_purchases"
                    case jewelryStoresWatchesClocksAndSilverwareStores = "jewelry_stores_watches_clocks_and_silverware_stores"
                    case landscapingServices = "landscaping_services"
                    case laundries
                    case laundryCleaningServices = "laundry_cleaning_services"
                    case legalServicesAttorneys = "legal_services_attorneys"
                    case luggageAndLeatherGoodsStores = "luggage_and_leather_goods_stores"
                    case lumberBuildingMaterialsStores = "lumber_building_materials_stores"
                    case manualCashDisburse = "manual_cash_disburse"
                    case marinasServiceAndSupplies = "marinas_service_and_supplies"
                    case masonryStoneworkAndPlaster = "masonry_stonework_and_plaster"
                    case massageParlors = "massage_parlors"
                    case medicalAndDentalLabs = "medical_and_dental_labs"
                    case medicalDentalOphthalmicAndHospitalEquipmentAndSupplies = "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
                    case medicalServices = "medical_services"
                    case membershipOrganizations = "membership_organizations"
                    case mensAndBoysClothingAndAccessoriesStores = "mens_and_boys_clothing_and_accessories_stores"
                    case mensWomensClothingStores = "mens_womens_clothing_stores"
                    case metalServiceCenters = "metal_service_centers"
                    case miscellaneous
                    case miscellaneousApparelAndAccessoryShops = "miscellaneous_apparel_and_accessory_shops"
                    case miscellaneousAutoDealers = "miscellaneous_auto_dealers"
                    case miscellaneousBusinessServices = "miscellaneous_business_services"
                    case miscellaneousFoodStores = "miscellaneous_food_stores"
                    case miscellaneousGeneralMerchandise = "miscellaneous_general_merchandise"
                    case miscellaneousGeneralServices = "miscellaneous_general_services"
                    case miscellaneousHomeFurnishingSpecialtyStores = "miscellaneous_home_furnishing_specialty_stores"
                    case miscellaneousPublishingAndPrinting = "miscellaneous_publishing_and_printing"
                    case miscellaneousRecreationServices = "miscellaneous_recreation_services"
                    case miscellaneousRepairShops = "miscellaneous_repair_shops"
                    case miscellaneousSpecialtyRetail = "miscellaneous_specialty_retail"
                    case mobileHomeDealers = "mobile_home_dealers"
                    case motionPictureTheaters = "motion_picture_theaters"
                    case motorFreightCarriersAndTrucking = "motor_freight_carriers_and_trucking"
                    case motorHomesDealers = "motor_homes_dealers"
                    case motorVehicleSuppliesAndNewParts = "motor_vehicle_supplies_and_new_parts"
                    case motorcycleShopsAndDealers = "motorcycle_shops_and_dealers"
                    case motorcycleShopsDealers = "motorcycle_shops_dealers"
                    case musicStoresMusicalInstrumentsPianosAndSheetMusic = "music_stores_musical_instruments_pianos_and_sheet_music"
                    case newsDealersAndNewsstands = "news_dealers_and_newsstands"
                    case nonFiMoneyOrders = "non_fi_money_orders"
                    case nonFiStoredValueCardPurchaseLoad = "non_fi_stored_value_card_purchase_load"
                    case nondurableGoods = "nondurable_goods"
                    case nurseriesLawnAndGardenSupplyStores = "nurseries_lawn_and_garden_supply_stores"
                    case nursingPersonalCare = "nursing_personal_care"
                    case officeAndCommercialFurniture = "office_and_commercial_furniture"
                    case opticiansEyeglasses = "opticians_eyeglasses"
                    case optometristsOphthalmologist = "optometrists_ophthalmologist"
                    case orthopedicGoodsProstheticDevices = "orthopedic_goods_prosthetic_devices"
                    case osteopaths
                    case packageStoresBeerWineAndLiquor = "package_stores_beer_wine_and_liquor"
                    case paintsVarnishesAndSupplies = "paints_varnishes_and_supplies"
                    case parkingLotsGarages = "parking_lots_garages"
                    case passengerRailways = "passenger_railways"
                    case pawnShops = "pawn_shops"
                    case petShopsPetFoodAndSupplies = "pet_shops_pet_food_and_supplies"
                    case petroleumAndPetroleumProducts = "petroleum_and_petroleum_products"
                    case photoDeveloping = "photo_developing"
                    case photographicPhotocopyMicrofilmEquipmentAndSupplies = "photographic_photocopy_microfilm_equipment_and_supplies"
                    case photographicStudios = "photographic_studios"
                    case pictureVideoProduction = "picture_video_production"
                    case pieceGoodsNotionsAndOtherDryGoods = "piece_goods_notions_and_other_dry_goods"
                    case plumbingHeatingEquipmentAndSupplies = "plumbing_heating_equipment_and_supplies"
                    case politicalOrganizations = "political_organizations"
                    case postalServicesGovernmentOnly = "postal_services_government_only"
                    case preciousStonesAndMetalsWatchesAndJewelry = "precious_stones_and_metals_watches_and_jewelry"
                    case professionalServices = "professional_services"
                    case publicWarehousingAndStorage = "public_warehousing_and_storage"
                    case quickCopyReproAndBlueprint = "quick_copy_repro_and_blueprint"
                    case railroads
                    case realEstateAgentsAndManagersRentals = "real_estate_agents_and_managers_rentals"
                    case recordStores = "record_stores"
                    case recreationalVehicleRentals = "recreational_vehicle_rentals"
                    case religiousGoodsStores = "religious_goods_stores"
                    case religiousOrganizations = "religious_organizations"
                    case roofingSidingSheetMetal = "roofing_siding_sheet_metal"
                    case secretarialSupportServices = "secretarial_support_services"
                    case securityBrokersDealers = "security_brokers_dealers"
                    case serviceStations = "service_stations"
                    case sewingNeedleworkFabricAndPieceGoodsStores = "sewing_needlework_fabric_and_piece_goods_stores"
                    case shoeRepairHatCleaning = "shoe_repair_hat_cleaning"
                    case shoeStores = "shoe_stores"
                    case smallApplianceRepair = "small_appliance_repair"
                    case snowmobileDealers = "snowmobile_dealers"
                    case specialTradeServices = "special_trade_services"
                    case specialtyCleaning = "specialty_cleaning"
                    case sportingGoodsStores = "sporting_goods_stores"
                    case sportingRecreationCamps = "sporting_recreation_camps"
                    case sportsAndRidingApparelStores = "sports_and_riding_apparel_stores"
                    case sportsClubsFields = "sports_clubs_fields"
                    case stampAndCoinStores = "stamp_and_coin_stores"
                    case stationaryOfficeSuppliesPrintingAndWritingPaper = "stationary_office_supplies_printing_and_writing_paper"
                    case stationeryStoresOfficeAndSchoolSupplyStores = "stationery_stores_office_and_school_supply_stores"
                    case swimmingPoolsSales = "swimming_pools_sales"
                    case tUiTravelGermany = "t_ui_travel_germany"
                    case tailorsAlterations = "tailors_alterations"
                    case taxPaymentsGovernmentAgencies = "tax_payments_government_agencies"
                    case taxPreparationServices = "tax_preparation_services"
                    case taxicabsLimousines = "taxicabs_limousines"
                    case telecommunicationEquipmentAndTelephoneSales = "telecommunication_equipment_and_telephone_sales"
                    case telecommunicationServices = "telecommunication_services"
                    case telegraphServices = "telegraph_services"
                    case tentAndAwningShops = "tent_and_awning_shops"
                    case testingLaboratories = "testing_laboratories"
                    case theatricalTicketAgencies = "theatrical_ticket_agencies"
                    case timeshares
                    case tireRetreadingAndRepair = "tire_retreading_and_repair"
                    case tollsBridgeFees = "tolls_bridge_fees"
                    case touristAttractionsAndExhibits = "tourist_attractions_and_exhibits"
                    case towingServices = "towing_services"
                    case trailerParksCampgrounds = "trailer_parks_campgrounds"
                    case transportationServices = "transportation_services"
                    case travelAgenciesTourOperators = "travel_agencies_tour_operators"
                    case truckStopIteration = "truck_stop_iteration"
                    case truckUtilityTrailerRentals = "truck_utility_trailer_rentals"
                    case typesettingPlateMakingAndRelatedServices = "typesetting_plate_making_and_related_services"
                    case typewriterStores = "typewriter_stores"
                    case uSFederalGovernmentAgenciesOrDepartments = "u_s_federal_government_agencies_or_departments"
                    case uniformsCommercialClothing = "uniforms_commercial_clothing"
                    case usedMerchandiseAndSecondhandStores = "used_merchandise_and_secondhand_stores"
                    case utilities
                    case varietyStores = "variety_stores"
                    case veterinaryServices = "veterinary_services"
                    case videoAmusementGameSupplies = "video_amusement_game_supplies"
                    case videoGameArcades = "video_game_arcades"
                    case videoTapeRentalStores = "video_tape_rental_stores"
                    case vocationalTradeSchools = "vocational_trade_schools"
                    case watchJewelryRepair = "watch_jewelry_repair"
                    case weldingRepair = "welding_repair"
                    case wholesaleClubs = "wholesale_clubs"
                    case wigAndToupeeStores = "wig_and_toupee_stores"
                    case wiresMoneyOrders = "wires_money_orders"
                    case womensAccessoryAndSpecialtyShops = "womens_accessory_and_specialty_shops"
                    case womensReadyToWearStores = "womens_ready_to_wear_stores"
                    case wreckingAndSalvageYards = "wrecking_and_salvage_yards"
                }

                public enum BlockedCategory: String, Codable, CaseIterable {
                    case acRefrigerationRepair = "ac_refrigeration_repair"
                    case accountingBookkeepingServices = "accounting_bookkeeping_services"
                    case advertisingServices = "advertising_services"
                    case agriculturalCooperative = "agricultural_cooperative"
                    case airlinesAirCarriers = "airlines_air_carriers"
                    case airportsFlyingFields = "airports_flying_fields"
                    case ambulanceServices = "ambulance_services"
                    case amusementParksCarnivals = "amusement_parks_carnivals"
                    case antiqueReproductions = "antique_reproductions"
                    case antiqueShops = "antique_shops"
                    case aquariums
                    case architecturalSurveyingServices = "architectural_surveying_services"
                    case artDealersAndGalleries = "art_dealers_and_galleries"
                    case artistsSupplyAndCraftShops = "artists_supply_and_craft_shops"
                    case autoAndHomeSupplyStores = "auto_and_home_supply_stores"
                    case autoBodyRepairShops = "auto_body_repair_shops"
                    case autoPaintShops = "auto_paint_shops"
                    case autoServiceShops = "auto_service_shops"
                    case automatedCashDisburse = "automated_cash_disburse"
                    case automatedFuelDispensers = "automated_fuel_dispensers"
                    case automobileAssociations = "automobile_associations"
                    case automotivePartsAndAccessoriesStores = "automotive_parts_and_accessories_stores"
                    case automotiveTireStores = "automotive_tire_stores"
                    case bailAndBondPayments = "bail_and_bond_payments"
                    case bakeries
                    case bandsOrchestras = "bands_orchestras"
                    case barberAndBeautyShops = "barber_and_beauty_shops"
                    case bettingCasinoGambling = "betting_casino_gambling"
                    case bicycleShops = "bicycle_shops"
                    case billiardPoolEstablishments = "billiard_pool_establishments"
                    case boatDealers = "boat_dealers"
                    case boatRentalsAndLeases = "boat_rentals_and_leases"
                    case bookStores = "book_stores"
                    case booksPeriodicalsAndNewspapers = "books_periodicals_and_newspapers"
                    case bowlingAlleys = "bowling_alleys"
                    case busLines = "bus_lines"
                    case businessSecretarialSchools = "business_secretarial_schools"
                    case buyingShoppingServices = "buying_shopping_services"
                    case cableSatelliteAndOtherPayTelevisionAndRadio = "cable_satellite_and_other_pay_television_and_radio"
                    case cameraAndPhotographicSupplyStores = "camera_and_photographic_supply_stores"
                    case candyNutAndConfectioneryStores = "candy_nut_and_confectionery_stores"
                    case carAndTruckDealersNewUsed = "car_and_truck_dealers_new_used"
                    case carAndTruckDealersUsedOnly = "car_and_truck_dealers_used_only"
                    case carRentalAgencies = "car_rental_agencies"
                    case carWashes = "car_washes"
                    case carpentryServices = "carpentry_services"
                    case carpetUpholsteryCleaning = "carpet_upholstery_cleaning"
                    case caterers
                    case charitableAndSocialServiceOrganizationsFundraising = "charitable_and_social_service_organizations_fundraising"
                    case chemicalsAndAlliedProducts = "chemicals_and_allied_products"
                    case childCareServices = "child_care_services"
                    case childrensAndInfantsWearStores = "childrens_and_infants_wear_stores"
                    case chiropodistsPodiatrists = "chiropodists_podiatrists"
                    case chiropractors
                    case cigarStoresAndStands = "cigar_stores_and_stands"
                    case civicSocialFraternalAssociations = "civic_social_fraternal_associations"
                    case cleaningAndMaintenance = "cleaning_and_maintenance"
                    case clothingRental = "clothing_rental"
                    case collegesUniversities = "colleges_universities"
                    case commercialEquipment = "commercial_equipment"
                    case commercialFootwear = "commercial_footwear"
                    case commercialPhotographyArtAndGraphics = "commercial_photography_art_and_graphics"
                    case commuterTransportAndFerries = "commuter_transport_and_ferries"
                    case computerNetworkServices = "computer_network_services"
                    case computerProgramming = "computer_programming"
                    case computerRepair = "computer_repair"
                    case computerSoftwareStores = "computer_software_stores"
                    case computersPeripheralsAndSoftware = "computers_peripherals_and_software"
                    case concreteWorkServices = "concrete_work_services"
                    case constructionMaterials = "construction_materials"
                    case consultingPublicRelations = "consulting_public_relations"
                    case correspondenceSchools = "correspondence_schools"
                    case cosmeticStores = "cosmetic_stores"
                    case counselingServices = "counseling_services"
                    case countryClubs = "country_clubs"
                    case courierServices = "courier_services"
                    case courtCosts = "court_costs"
                    case creditReportingAgencies = "credit_reporting_agencies"
                    case cruiseLines = "cruise_lines"
                    case dairyProductsStores = "dairy_products_stores"
                    case danceHallStudiosSchools = "dance_hall_studios_schools"
                    case datingEscortServices = "dating_escort_services"
                    case dentistsOrthodontists = "dentists_orthodontists"
                    case departmentStores = "department_stores"
                    case detectiveAgencies = "detective_agencies"
                    case digitalGoodsApplications = "digital_goods_applications"
                    case digitalGoodsGames = "digital_goods_games"
                    case digitalGoodsLargeVolume = "digital_goods_large_volume"
                    case digitalGoodsMedia = "digital_goods_media"
                    case directMarketingCatalogMerchant = "direct_marketing_catalog_merchant"
                    case directMarketingCombinationCatalogAndRetailMerchant = "direct_marketing_combination_catalog_and_retail_merchant"
                    case directMarketingInboundTelemarketing = "direct_marketing_inbound_telemarketing"
                    case directMarketingInsuranceServices = "direct_marketing_insurance_services"
                    case directMarketingOther = "direct_marketing_other"
                    case directMarketingOutboundTelemarketing = "direct_marketing_outbound_telemarketing"
                    case directMarketingSubscription = "direct_marketing_subscription"
                    case directMarketingTravel = "direct_marketing_travel"
                    case discountStores = "discount_stores"
                    case doctors
                    case doorToDoorSales = "door_to_door_sales"
                    case draperyWindowCoveringAndUpholsteryStores = "drapery_window_covering_and_upholstery_stores"
                    case drinkingPlaces = "drinking_places"
                    case drugStoresAndPharmacies = "drug_stores_and_pharmacies"
                    case drugsDrugProprietariesAndDruggistSundries = "drugs_drug_proprietaries_and_druggist_sundries"
                    case dryCleaners = "dry_cleaners"
                    case durableGoods = "durable_goods"
                    case dutyFreeStores = "duty_free_stores"
                    case eatingPlacesRestaurants = "eating_places_restaurants"
                    case educationalServices = "educational_services"
                    case electricRazorStores = "electric_razor_stores"
                    case electricalPartsAndEquipment = "electrical_parts_and_equipment"
                    case electricalServices = "electrical_services"
                    case electronicsRepairShops = "electronics_repair_shops"
                    case electronicsStores = "electronics_stores"
                    case elementarySecondarySchools = "elementary_secondary_schools"
                    case employmentTempAgencies = "employment_temp_agencies"
                    case equipmentRental = "equipment_rental"
                    case exterminatingServices = "exterminating_services"
                    case familyClothingStores = "family_clothing_stores"
                    case fastFoodRestaurants = "fast_food_restaurants"
                    case financialInstitutions = "financial_institutions"
                    case finesGovernmentAdministrativeEntities = "fines_government_administrative_entities"
                    case fireplaceFireplaceScreensAndAccessoriesStores = "fireplace_fireplace_screens_and_accessories_stores"
                    case floorCoveringStores = "floor_covering_stores"
                    case florists
                    case floristsSuppliesNurseryStockAndFlowers = "florists_supplies_nursery_stock_and_flowers"
                    case freezerAndLockerMeatProvisioners = "freezer_and_locker_meat_provisioners"
                    case fuelDealersNonAutomotive = "fuel_dealers_non_automotive"
                    case funeralServicesCrematories = "funeral_services_crematories"
                    case furnitureHomeFurnishingsAndEquipmentStoresExceptAppliances = "furniture_home_furnishings_and_equipment_stores_except_appliances"
                    case furnitureRepairRefinishing = "furniture_repair_refinishing"
                    case furriersAndFurShops = "furriers_and_fur_shops"
                    case generalServices = "general_services"
                    case giftCardNoveltyAndSouvenirShops = "gift_card_novelty_and_souvenir_shops"
                    case glassPaintAndWallpaperStores = "glass_paint_and_wallpaper_stores"
                    case glasswareCrystalStores = "glassware_crystal_stores"
                    case golfCoursesPublic = "golf_courses_public"
                    case governmentServices = "government_services"
                    case groceryStoresSupermarkets = "grocery_stores_supermarkets"
                    case hardwareEquipmentAndSupplies = "hardware_equipment_and_supplies"
                    case hardwareStores = "hardware_stores"
                    case healthAndBeautySpas = "health_and_beauty_spas"
                    case hearingAidsSalesAndSupplies = "hearing_aids_sales_and_supplies"
                    case heatingPlumbingAC = "heating_plumbing_a_c"
                    case hobbyToyAndGameShops = "hobby_toy_and_game_shops"
                    case homeSupplyWarehouseStores = "home_supply_warehouse_stores"
                    case hospitals
                    case hotelsMotelsAndResorts = "hotels_motels_and_resorts"
                    case householdApplianceStores = "household_appliance_stores"
                    case industrialSupplies = "industrial_supplies"
                    case informationRetrievalServices = "information_retrieval_services"
                    case insuranceDefault = "insurance_default"
                    case insuranceUnderwritingPremiums = "insurance_underwriting_premiums"
                    case intraCompanyPurchases = "intra_company_purchases"
                    case jewelryStoresWatchesClocksAndSilverwareStores = "jewelry_stores_watches_clocks_and_silverware_stores"
                    case landscapingServices = "landscaping_services"
                    case laundries
                    case laundryCleaningServices = "laundry_cleaning_services"
                    case legalServicesAttorneys = "legal_services_attorneys"
                    case luggageAndLeatherGoodsStores = "luggage_and_leather_goods_stores"
                    case lumberBuildingMaterialsStores = "lumber_building_materials_stores"
                    case manualCashDisburse = "manual_cash_disburse"
                    case marinasServiceAndSupplies = "marinas_service_and_supplies"
                    case masonryStoneworkAndPlaster = "masonry_stonework_and_plaster"
                    case massageParlors = "massage_parlors"
                    case medicalAndDentalLabs = "medical_and_dental_labs"
                    case medicalDentalOphthalmicAndHospitalEquipmentAndSupplies = "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
                    case medicalServices = "medical_services"
                    case membershipOrganizations = "membership_organizations"
                    case mensAndBoysClothingAndAccessoriesStores = "mens_and_boys_clothing_and_accessories_stores"
                    case mensWomensClothingStores = "mens_womens_clothing_stores"
                    case metalServiceCenters = "metal_service_centers"
                    case miscellaneous
                    case miscellaneousApparelAndAccessoryShops = "miscellaneous_apparel_and_accessory_shops"
                    case miscellaneousAutoDealers = "miscellaneous_auto_dealers"
                    case miscellaneousBusinessServices = "miscellaneous_business_services"
                    case miscellaneousFoodStores = "miscellaneous_food_stores"
                    case miscellaneousGeneralMerchandise = "miscellaneous_general_merchandise"
                    case miscellaneousGeneralServices = "miscellaneous_general_services"
                    case miscellaneousHomeFurnishingSpecialtyStores = "miscellaneous_home_furnishing_specialty_stores"
                    case miscellaneousPublishingAndPrinting = "miscellaneous_publishing_and_printing"
                    case miscellaneousRecreationServices = "miscellaneous_recreation_services"
                    case miscellaneousRepairShops = "miscellaneous_repair_shops"
                    case miscellaneousSpecialtyRetail = "miscellaneous_specialty_retail"
                    case mobileHomeDealers = "mobile_home_dealers"
                    case motionPictureTheaters = "motion_picture_theaters"
                    case motorFreightCarriersAndTrucking = "motor_freight_carriers_and_trucking"
                    case motorHomesDealers = "motor_homes_dealers"
                    case motorVehicleSuppliesAndNewParts = "motor_vehicle_supplies_and_new_parts"
                    case motorcycleShopsAndDealers = "motorcycle_shops_and_dealers"
                    case motorcycleShopsDealers = "motorcycle_shops_dealers"
                    case musicStoresMusicalInstrumentsPianosAndSheetMusic = "music_stores_musical_instruments_pianos_and_sheet_music"
                    case newsDealersAndNewsstands = "news_dealers_and_newsstands"
                    case nonFiMoneyOrders = "non_fi_money_orders"
                    case nonFiStoredValueCardPurchaseLoad = "non_fi_stored_value_card_purchase_load"
                    case nondurableGoods = "nondurable_goods"
                    case nurseriesLawnAndGardenSupplyStores = "nurseries_lawn_and_garden_supply_stores"
                    case nursingPersonalCare = "nursing_personal_care"
                    case officeAndCommercialFurniture = "office_and_commercial_furniture"
                    case opticiansEyeglasses = "opticians_eyeglasses"
                    case optometristsOphthalmologist = "optometrists_ophthalmologist"
                    case orthopedicGoodsProstheticDevices = "orthopedic_goods_prosthetic_devices"
                    case osteopaths
                    case packageStoresBeerWineAndLiquor = "package_stores_beer_wine_and_liquor"
                    case paintsVarnishesAndSupplies = "paints_varnishes_and_supplies"
                    case parkingLotsGarages = "parking_lots_garages"
                    case passengerRailways = "passenger_railways"
                    case pawnShops = "pawn_shops"
                    case petShopsPetFoodAndSupplies = "pet_shops_pet_food_and_supplies"
                    case petroleumAndPetroleumProducts = "petroleum_and_petroleum_products"
                    case photoDeveloping = "photo_developing"
                    case photographicPhotocopyMicrofilmEquipmentAndSupplies = "photographic_photocopy_microfilm_equipment_and_supplies"
                    case photographicStudios = "photographic_studios"
                    case pictureVideoProduction = "picture_video_production"
                    case pieceGoodsNotionsAndOtherDryGoods = "piece_goods_notions_and_other_dry_goods"
                    case plumbingHeatingEquipmentAndSupplies = "plumbing_heating_equipment_and_supplies"
                    case politicalOrganizations = "political_organizations"
                    case postalServicesGovernmentOnly = "postal_services_government_only"
                    case preciousStonesAndMetalsWatchesAndJewelry = "precious_stones_and_metals_watches_and_jewelry"
                    case professionalServices = "professional_services"
                    case publicWarehousingAndStorage = "public_warehousing_and_storage"
                    case quickCopyReproAndBlueprint = "quick_copy_repro_and_blueprint"
                    case railroads
                    case realEstateAgentsAndManagersRentals = "real_estate_agents_and_managers_rentals"
                    case recordStores = "record_stores"
                    case recreationalVehicleRentals = "recreational_vehicle_rentals"
                    case religiousGoodsStores = "religious_goods_stores"
                    case religiousOrganizations = "religious_organizations"
                    case roofingSidingSheetMetal = "roofing_siding_sheet_metal"
                    case secretarialSupportServices = "secretarial_support_services"
                    case securityBrokersDealers = "security_brokers_dealers"
                    case serviceStations = "service_stations"
                    case sewingNeedleworkFabricAndPieceGoodsStores = "sewing_needlework_fabric_and_piece_goods_stores"
                    case shoeRepairHatCleaning = "shoe_repair_hat_cleaning"
                    case shoeStores = "shoe_stores"
                    case smallApplianceRepair = "small_appliance_repair"
                    case snowmobileDealers = "snowmobile_dealers"
                    case specialTradeServices = "special_trade_services"
                    case specialtyCleaning = "specialty_cleaning"
                    case sportingGoodsStores = "sporting_goods_stores"
                    case sportingRecreationCamps = "sporting_recreation_camps"
                    case sportsAndRidingApparelStores = "sports_and_riding_apparel_stores"
                    case sportsClubsFields = "sports_clubs_fields"
                    case stampAndCoinStores = "stamp_and_coin_stores"
                    case stationaryOfficeSuppliesPrintingAndWritingPaper = "stationary_office_supplies_printing_and_writing_paper"
                    case stationeryStoresOfficeAndSchoolSupplyStores = "stationery_stores_office_and_school_supply_stores"
                    case swimmingPoolsSales = "swimming_pools_sales"
                    case tUiTravelGermany = "t_ui_travel_germany"
                    case tailorsAlterations = "tailors_alterations"
                    case taxPaymentsGovernmentAgencies = "tax_payments_government_agencies"
                    case taxPreparationServices = "tax_preparation_services"
                    case taxicabsLimousines = "taxicabs_limousines"
                    case telecommunicationEquipmentAndTelephoneSales = "telecommunication_equipment_and_telephone_sales"
                    case telecommunicationServices = "telecommunication_services"
                    case telegraphServices = "telegraph_services"
                    case tentAndAwningShops = "tent_and_awning_shops"
                    case testingLaboratories = "testing_laboratories"
                    case theatricalTicketAgencies = "theatrical_ticket_agencies"
                    case timeshares
                    case tireRetreadingAndRepair = "tire_retreading_and_repair"
                    case tollsBridgeFees = "tolls_bridge_fees"
                    case touristAttractionsAndExhibits = "tourist_attractions_and_exhibits"
                    case towingServices = "towing_services"
                    case trailerParksCampgrounds = "trailer_parks_campgrounds"
                    case transportationServices = "transportation_services"
                    case travelAgenciesTourOperators = "travel_agencies_tour_operators"
                    case truckStopIteration = "truck_stop_iteration"
                    case truckUtilityTrailerRentals = "truck_utility_trailer_rentals"
                    case typesettingPlateMakingAndRelatedServices = "typesetting_plate_making_and_related_services"
                    case typewriterStores = "typewriter_stores"
                    case uSFederalGovernmentAgenciesOrDepartments = "u_s_federal_government_agencies_or_departments"
                    case uniformsCommercialClothing = "uniforms_commercial_clothing"
                    case usedMerchandiseAndSecondhandStores = "used_merchandise_and_secondhand_stores"
                    case utilities
                    case varietyStores = "variety_stores"
                    case veterinaryServices = "veterinary_services"
                    case videoAmusementGameSupplies = "video_amusement_game_supplies"
                    case videoGameArcades = "video_game_arcades"
                    case videoTapeRentalStores = "video_tape_rental_stores"
                    case vocationalTradeSchools = "vocational_trade_schools"
                    case watchJewelryRepair = "watch_jewelry_repair"
                    case weldingRepair = "welding_repair"
                    case wholesaleClubs = "wholesale_clubs"
                    case wigAndToupeeStores = "wig_and_toupee_stores"
                    case wiresMoneyOrders = "wires_money_orders"
                    case womensAccessoryAndSpecialtyShops = "womens_accessory_and_specialty_shops"
                    case womensReadyToWearStores = "womens_ready_to_wear_stores"
                    case wreckingAndSalvageYards = "wrecking_and_salvage_yards"
                }

                /// Spending_limits_param
                public struct SpendingLimit: Encodable {
                    public var amount: Int
                    public var categories: [Category]?
                    public var interval: Interval

                    public enum Category: String, Codable, CaseIterable {
                        case acRefrigerationRepair = "ac_refrigeration_repair"
                        case accountingBookkeepingServices = "accounting_bookkeeping_services"
                        case advertisingServices = "advertising_services"
                        case agriculturalCooperative = "agricultural_cooperative"
                        case airlinesAirCarriers = "airlines_air_carriers"
                        case airportsFlyingFields = "airports_flying_fields"
                        case ambulanceServices = "ambulance_services"
                        case amusementParksCarnivals = "amusement_parks_carnivals"
                        case antiqueReproductions = "antique_reproductions"
                        case antiqueShops = "antique_shops"
                        case aquariums
                        case architecturalSurveyingServices = "architectural_surveying_services"
                        case artDealersAndGalleries = "art_dealers_and_galleries"
                        case artistsSupplyAndCraftShops = "artists_supply_and_craft_shops"
                        case autoAndHomeSupplyStores = "auto_and_home_supply_stores"
                        case autoBodyRepairShops = "auto_body_repair_shops"
                        case autoPaintShops = "auto_paint_shops"
                        case autoServiceShops = "auto_service_shops"
                        case automatedCashDisburse = "automated_cash_disburse"
                        case automatedFuelDispensers = "automated_fuel_dispensers"
                        case automobileAssociations = "automobile_associations"
                        case automotivePartsAndAccessoriesStores = "automotive_parts_and_accessories_stores"
                        case automotiveTireStores = "automotive_tire_stores"
                        case bailAndBondPayments = "bail_and_bond_payments"
                        case bakeries
                        case bandsOrchestras = "bands_orchestras"
                        case barberAndBeautyShops = "barber_and_beauty_shops"
                        case bettingCasinoGambling = "betting_casino_gambling"
                        case bicycleShops = "bicycle_shops"
                        case billiardPoolEstablishments = "billiard_pool_establishments"
                        case boatDealers = "boat_dealers"
                        case boatRentalsAndLeases = "boat_rentals_and_leases"
                        case bookStores = "book_stores"
                        case booksPeriodicalsAndNewspapers = "books_periodicals_and_newspapers"
                        case bowlingAlleys = "bowling_alleys"
                        case busLines = "bus_lines"
                        case businessSecretarialSchools = "business_secretarial_schools"
                        case buyingShoppingServices = "buying_shopping_services"
                        case cableSatelliteAndOtherPayTelevisionAndRadio = "cable_satellite_and_other_pay_television_and_radio"
                        case cameraAndPhotographicSupplyStores = "camera_and_photographic_supply_stores"
                        case candyNutAndConfectioneryStores = "candy_nut_and_confectionery_stores"
                        case carAndTruckDealersNewUsed = "car_and_truck_dealers_new_used"
                        case carAndTruckDealersUsedOnly = "car_and_truck_dealers_used_only"
                        case carRentalAgencies = "car_rental_agencies"
                        case carWashes = "car_washes"
                        case carpentryServices = "carpentry_services"
                        case carpetUpholsteryCleaning = "carpet_upholstery_cleaning"
                        case caterers
                        case charitableAndSocialServiceOrganizationsFundraising = "charitable_and_social_service_organizations_fundraising"
                        case chemicalsAndAlliedProducts = "chemicals_and_allied_products"
                        case childCareServices = "child_care_services"
                        case childrensAndInfantsWearStores = "childrens_and_infants_wear_stores"
                        case chiropodistsPodiatrists = "chiropodists_podiatrists"
                        case chiropractors
                        case cigarStoresAndStands = "cigar_stores_and_stands"
                        case civicSocialFraternalAssociations = "civic_social_fraternal_associations"
                        case cleaningAndMaintenance = "cleaning_and_maintenance"
                        case clothingRental = "clothing_rental"
                        case collegesUniversities = "colleges_universities"
                        case commercialEquipment = "commercial_equipment"
                        case commercialFootwear = "commercial_footwear"
                        case commercialPhotographyArtAndGraphics = "commercial_photography_art_and_graphics"
                        case commuterTransportAndFerries = "commuter_transport_and_ferries"
                        case computerNetworkServices = "computer_network_services"
                        case computerProgramming = "computer_programming"
                        case computerRepair = "computer_repair"
                        case computerSoftwareStores = "computer_software_stores"
                        case computersPeripheralsAndSoftware = "computers_peripherals_and_software"
                        case concreteWorkServices = "concrete_work_services"
                        case constructionMaterials = "construction_materials"
                        case consultingPublicRelations = "consulting_public_relations"
                        case correspondenceSchools = "correspondence_schools"
                        case cosmeticStores = "cosmetic_stores"
                        case counselingServices = "counseling_services"
                        case countryClubs = "country_clubs"
                        case courierServices = "courier_services"
                        case courtCosts = "court_costs"
                        case creditReportingAgencies = "credit_reporting_agencies"
                        case cruiseLines = "cruise_lines"
                        case dairyProductsStores = "dairy_products_stores"
                        case danceHallStudiosSchools = "dance_hall_studios_schools"
                        case datingEscortServices = "dating_escort_services"
                        case dentistsOrthodontists = "dentists_orthodontists"
                        case departmentStores = "department_stores"
                        case detectiveAgencies = "detective_agencies"
                        case digitalGoodsApplications = "digital_goods_applications"
                        case digitalGoodsGames = "digital_goods_games"
                        case digitalGoodsLargeVolume = "digital_goods_large_volume"
                        case digitalGoodsMedia = "digital_goods_media"
                        case directMarketingCatalogMerchant = "direct_marketing_catalog_merchant"
                        case directMarketingCombinationCatalogAndRetailMerchant = "direct_marketing_combination_catalog_and_retail_merchant"
                        case directMarketingInboundTelemarketing = "direct_marketing_inbound_telemarketing"
                        case directMarketingInsuranceServices = "direct_marketing_insurance_services"
                        case directMarketingOther = "direct_marketing_other"
                        case directMarketingOutboundTelemarketing = "direct_marketing_outbound_telemarketing"
                        case directMarketingSubscription = "direct_marketing_subscription"
                        case directMarketingTravel = "direct_marketing_travel"
                        case discountStores = "discount_stores"
                        case doctors
                        case doorToDoorSales = "door_to_door_sales"
                        case draperyWindowCoveringAndUpholsteryStores = "drapery_window_covering_and_upholstery_stores"
                        case drinkingPlaces = "drinking_places"
                        case drugStoresAndPharmacies = "drug_stores_and_pharmacies"
                        case drugsDrugProprietariesAndDruggistSundries = "drugs_drug_proprietaries_and_druggist_sundries"
                        case dryCleaners = "dry_cleaners"
                        case durableGoods = "durable_goods"
                        case dutyFreeStores = "duty_free_stores"
                        case eatingPlacesRestaurants = "eating_places_restaurants"
                        case educationalServices = "educational_services"
                        case electricRazorStores = "electric_razor_stores"
                        case electricalPartsAndEquipment = "electrical_parts_and_equipment"
                        case electricalServices = "electrical_services"
                        case electronicsRepairShops = "electronics_repair_shops"
                        case electronicsStores = "electronics_stores"
                        case elementarySecondarySchools = "elementary_secondary_schools"
                        case employmentTempAgencies = "employment_temp_agencies"
                        case equipmentRental = "equipment_rental"
                        case exterminatingServices = "exterminating_services"
                        case familyClothingStores = "family_clothing_stores"
                        case fastFoodRestaurants = "fast_food_restaurants"
                        case financialInstitutions = "financial_institutions"
                        case finesGovernmentAdministrativeEntities = "fines_government_administrative_entities"
                        case fireplaceFireplaceScreensAndAccessoriesStores = "fireplace_fireplace_screens_and_accessories_stores"
                        case floorCoveringStores = "floor_covering_stores"
                        case florists
                        case floristsSuppliesNurseryStockAndFlowers = "florists_supplies_nursery_stock_and_flowers"
                        case freezerAndLockerMeatProvisioners = "freezer_and_locker_meat_provisioners"
                        case fuelDealersNonAutomotive = "fuel_dealers_non_automotive"
                        case funeralServicesCrematories = "funeral_services_crematories"
                        case furnitureHomeFurnishingsAndEquipmentStoresExceptAppliances = "furniture_home_furnishings_and_equipment_stores_except_appliances"
                        case furnitureRepairRefinishing = "furniture_repair_refinishing"
                        case furriersAndFurShops = "furriers_and_fur_shops"
                        case generalServices = "general_services"
                        case giftCardNoveltyAndSouvenirShops = "gift_card_novelty_and_souvenir_shops"
                        case glassPaintAndWallpaperStores = "glass_paint_and_wallpaper_stores"
                        case glasswareCrystalStores = "glassware_crystal_stores"
                        case golfCoursesPublic = "golf_courses_public"
                        case governmentServices = "government_services"
                        case groceryStoresSupermarkets = "grocery_stores_supermarkets"
                        case hardwareEquipmentAndSupplies = "hardware_equipment_and_supplies"
                        case hardwareStores = "hardware_stores"
                        case healthAndBeautySpas = "health_and_beauty_spas"
                        case hearingAidsSalesAndSupplies = "hearing_aids_sales_and_supplies"
                        case heatingPlumbingAC = "heating_plumbing_a_c"
                        case hobbyToyAndGameShops = "hobby_toy_and_game_shops"
                        case homeSupplyWarehouseStores = "home_supply_warehouse_stores"
                        case hospitals
                        case hotelsMotelsAndResorts = "hotels_motels_and_resorts"
                        case householdApplianceStores = "household_appliance_stores"
                        case industrialSupplies = "industrial_supplies"
                        case informationRetrievalServices = "information_retrieval_services"
                        case insuranceDefault = "insurance_default"
                        case insuranceUnderwritingPremiums = "insurance_underwriting_premiums"
                        case intraCompanyPurchases = "intra_company_purchases"
                        case jewelryStoresWatchesClocksAndSilverwareStores = "jewelry_stores_watches_clocks_and_silverware_stores"
                        case landscapingServices = "landscaping_services"
                        case laundries
                        case laundryCleaningServices = "laundry_cleaning_services"
                        case legalServicesAttorneys = "legal_services_attorneys"
                        case luggageAndLeatherGoodsStores = "luggage_and_leather_goods_stores"
                        case lumberBuildingMaterialsStores = "lumber_building_materials_stores"
                        case manualCashDisburse = "manual_cash_disburse"
                        case marinasServiceAndSupplies = "marinas_service_and_supplies"
                        case masonryStoneworkAndPlaster = "masonry_stonework_and_plaster"
                        case massageParlors = "massage_parlors"
                        case medicalAndDentalLabs = "medical_and_dental_labs"
                        case medicalDentalOphthalmicAndHospitalEquipmentAndSupplies = "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
                        case medicalServices = "medical_services"
                        case membershipOrganizations = "membership_organizations"
                        case mensAndBoysClothingAndAccessoriesStores = "mens_and_boys_clothing_and_accessories_stores"
                        case mensWomensClothingStores = "mens_womens_clothing_stores"
                        case metalServiceCenters = "metal_service_centers"
                        case miscellaneous
                        case miscellaneousApparelAndAccessoryShops = "miscellaneous_apparel_and_accessory_shops"
                        case miscellaneousAutoDealers = "miscellaneous_auto_dealers"
                        case miscellaneousBusinessServices = "miscellaneous_business_services"
                        case miscellaneousFoodStores = "miscellaneous_food_stores"
                        case miscellaneousGeneralMerchandise = "miscellaneous_general_merchandise"
                        case miscellaneousGeneralServices = "miscellaneous_general_services"
                        case miscellaneousHomeFurnishingSpecialtyStores = "miscellaneous_home_furnishing_specialty_stores"
                        case miscellaneousPublishingAndPrinting = "miscellaneous_publishing_and_printing"
                        case miscellaneousRecreationServices = "miscellaneous_recreation_services"
                        case miscellaneousRepairShops = "miscellaneous_repair_shops"
                        case miscellaneousSpecialtyRetail = "miscellaneous_specialty_retail"
                        case mobileHomeDealers = "mobile_home_dealers"
                        case motionPictureTheaters = "motion_picture_theaters"
                        case motorFreightCarriersAndTrucking = "motor_freight_carriers_and_trucking"
                        case motorHomesDealers = "motor_homes_dealers"
                        case motorVehicleSuppliesAndNewParts = "motor_vehicle_supplies_and_new_parts"
                        case motorcycleShopsAndDealers = "motorcycle_shops_and_dealers"
                        case motorcycleShopsDealers = "motorcycle_shops_dealers"
                        case musicStoresMusicalInstrumentsPianosAndSheetMusic = "music_stores_musical_instruments_pianos_and_sheet_music"
                        case newsDealersAndNewsstands = "news_dealers_and_newsstands"
                        case nonFiMoneyOrders = "non_fi_money_orders"
                        case nonFiStoredValueCardPurchaseLoad = "non_fi_stored_value_card_purchase_load"
                        case nondurableGoods = "nondurable_goods"
                        case nurseriesLawnAndGardenSupplyStores = "nurseries_lawn_and_garden_supply_stores"
                        case nursingPersonalCare = "nursing_personal_care"
                        case officeAndCommercialFurniture = "office_and_commercial_furniture"
                        case opticiansEyeglasses = "opticians_eyeglasses"
                        case optometristsOphthalmologist = "optometrists_ophthalmologist"
                        case orthopedicGoodsProstheticDevices = "orthopedic_goods_prosthetic_devices"
                        case osteopaths
                        case packageStoresBeerWineAndLiquor = "package_stores_beer_wine_and_liquor"
                        case paintsVarnishesAndSupplies = "paints_varnishes_and_supplies"
                        case parkingLotsGarages = "parking_lots_garages"
                        case passengerRailways = "passenger_railways"
                        case pawnShops = "pawn_shops"
                        case petShopsPetFoodAndSupplies = "pet_shops_pet_food_and_supplies"
                        case petroleumAndPetroleumProducts = "petroleum_and_petroleum_products"
                        case photoDeveloping = "photo_developing"
                        case photographicPhotocopyMicrofilmEquipmentAndSupplies = "photographic_photocopy_microfilm_equipment_and_supplies"
                        case photographicStudios = "photographic_studios"
                        case pictureVideoProduction = "picture_video_production"
                        case pieceGoodsNotionsAndOtherDryGoods = "piece_goods_notions_and_other_dry_goods"
                        case plumbingHeatingEquipmentAndSupplies = "plumbing_heating_equipment_and_supplies"
                        case politicalOrganizations = "political_organizations"
                        case postalServicesGovernmentOnly = "postal_services_government_only"
                        case preciousStonesAndMetalsWatchesAndJewelry = "precious_stones_and_metals_watches_and_jewelry"
                        case professionalServices = "professional_services"
                        case publicWarehousingAndStorage = "public_warehousing_and_storage"
                        case quickCopyReproAndBlueprint = "quick_copy_repro_and_blueprint"
                        case railroads
                        case realEstateAgentsAndManagersRentals = "real_estate_agents_and_managers_rentals"
                        case recordStores = "record_stores"
                        case recreationalVehicleRentals = "recreational_vehicle_rentals"
                        case religiousGoodsStores = "religious_goods_stores"
                        case religiousOrganizations = "religious_organizations"
                        case roofingSidingSheetMetal = "roofing_siding_sheet_metal"
                        case secretarialSupportServices = "secretarial_support_services"
                        case securityBrokersDealers = "security_brokers_dealers"
                        case serviceStations = "service_stations"
                        case sewingNeedleworkFabricAndPieceGoodsStores = "sewing_needlework_fabric_and_piece_goods_stores"
                        case shoeRepairHatCleaning = "shoe_repair_hat_cleaning"
                        case shoeStores = "shoe_stores"
                        case smallApplianceRepair = "small_appliance_repair"
                        case snowmobileDealers = "snowmobile_dealers"
                        case specialTradeServices = "special_trade_services"
                        case specialtyCleaning = "specialty_cleaning"
                        case sportingGoodsStores = "sporting_goods_stores"
                        case sportingRecreationCamps = "sporting_recreation_camps"
                        case sportsAndRidingApparelStores = "sports_and_riding_apparel_stores"
                        case sportsClubsFields = "sports_clubs_fields"
                        case stampAndCoinStores = "stamp_and_coin_stores"
                        case stationaryOfficeSuppliesPrintingAndWritingPaper = "stationary_office_supplies_printing_and_writing_paper"
                        case stationeryStoresOfficeAndSchoolSupplyStores = "stationery_stores_office_and_school_supply_stores"
                        case swimmingPoolsSales = "swimming_pools_sales"
                        case tUiTravelGermany = "t_ui_travel_germany"
                        case tailorsAlterations = "tailors_alterations"
                        case taxPaymentsGovernmentAgencies = "tax_payments_government_agencies"
                        case taxPreparationServices = "tax_preparation_services"
                        case taxicabsLimousines = "taxicabs_limousines"
                        case telecommunicationEquipmentAndTelephoneSales = "telecommunication_equipment_and_telephone_sales"
                        case telecommunicationServices = "telecommunication_services"
                        case telegraphServices = "telegraph_services"
                        case tentAndAwningShops = "tent_and_awning_shops"
                        case testingLaboratories = "testing_laboratories"
                        case theatricalTicketAgencies = "theatrical_ticket_agencies"
                        case timeshares
                        case tireRetreadingAndRepair = "tire_retreading_and_repair"
                        case tollsBridgeFees = "tolls_bridge_fees"
                        case touristAttractionsAndExhibits = "tourist_attractions_and_exhibits"
                        case towingServices = "towing_services"
                        case trailerParksCampgrounds = "trailer_parks_campgrounds"
                        case transportationServices = "transportation_services"
                        case travelAgenciesTourOperators = "travel_agencies_tour_operators"
                        case truckStopIteration = "truck_stop_iteration"
                        case truckUtilityTrailerRentals = "truck_utility_trailer_rentals"
                        case typesettingPlateMakingAndRelatedServices = "typesetting_plate_making_and_related_services"
                        case typewriterStores = "typewriter_stores"
                        case uSFederalGovernmentAgenciesOrDepartments = "u_s_federal_government_agencies_or_departments"
                        case uniformsCommercialClothing = "uniforms_commercial_clothing"
                        case usedMerchandiseAndSecondhandStores = "used_merchandise_and_secondhand_stores"
                        case utilities
                        case varietyStores = "variety_stores"
                        case veterinaryServices = "veterinary_services"
                        case videoAmusementGameSupplies = "video_amusement_game_supplies"
                        case videoGameArcades = "video_game_arcades"
                        case videoTapeRentalStores = "video_tape_rental_stores"
                        case vocationalTradeSchools = "vocational_trade_schools"
                        case watchJewelryRepair = "watch_jewelry_repair"
                        case weldingRepair = "welding_repair"
                        case wholesaleClubs = "wholesale_clubs"
                        case wigAndToupeeStores = "wig_and_toupee_stores"
                        case wiresMoneyOrders = "wires_money_orders"
                        case womensAccessoryAndSpecialtyShops = "womens_accessory_and_specialty_shops"
                        case womensReadyToWearStores = "womens_ready_to_wear_stores"
                        case wreckingAndSalvageYards = "wrecking_and_salvage_yards"
                    }

                    public enum Interval: String, Codable, CaseIterable {
                        case allTime = "all_time"
                        case daily
                        case monthly
                        case perAuthorization = "per_authorization"
                        case weekly
                        case yearly
                    }

                    public init(amount: Int, categories: [Category]? = nil, interval: Interval) {
                        self.amount = amount
                        self.categories = categories
                        self.interval = interval
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amount, forKey: "amount")
                        encoder.encode(categories, forKey: "categories")
                        encoder.encode(interval, forKey: "interval")
                        return encoder.items
                    }
                }

                public init(allowedCategories: [AllowedCategory]? = nil, blockedCategories: [BlockedCategory]? = nil, spendingLimits: [SpendingLimit]? = nil) {
                    self.allowedCategories = allowedCategories
                    self.blockedCategories = blockedCategories
                    self.spendingLimits = spendingLimits
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(allowedCategories, forKey: "allowed_categories")
                    encoder.encode(blockedCategories, forKey: "blocked_categories")
                    encoder.encode(spendingLimits, forKey: "spending_limits")
                    return encoder.items
                }
            }

            /// Whether authorizations can be approved on this card. Defaults to `inactive`.
            public enum Status: String, Codable, CaseIterable {
                case active
                case inactive
            }

            /// The type of card to issue. Possible values are `physical` or `virtual`.
            public enum `Type`: String, Codable, CaseIterable {
                case physical
                case virtual
            }

            public init(cardholder: String? = nil, currency: String, expand: [String]? = nil, metadata: [String: String]? = nil, replacementFor: String? = nil, replacementReason: ReplacementReason? = nil, shipping: Shipping? = nil, spendingControls: SpendingControls? = nil, status: Status? = nil, type: `Type`) {
                self.cardholder = cardholder
                self.currency = currency
                self.expand = expand
                self.metadata = metadata
                self.replacementFor = replacementFor
                self.replacementReason = replacementReason
                self.shipping = shipping
                self.spendingControls = spendingControls
                self.status = status
                self.type = type
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(cardholder, forKey: "cardholder")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(replacementFor, forKey: "replacement_for")
                encoder.encode(replacementReason, forKey: "replacement_reason")
                encoder.encode(shipping, forKey: "shipping")
                encoder.encode(spendingControls, forKey: "spending_controls")
                encoder.encode(status, forKey: "status")
                encoder.encode(type, forKey: "type")
                return encoder.items
            }
        }
    }
}

extension Paths.Issuing.Cards {
    public func card(_ card: String) -> WithCard {
        WithCard(path: "\(path)/\(card)")
    }

    public struct WithCard {
        /// Path: `/v1/issuing/cards/{card}`
        public let path: String

        /// <p>Retrieves an Issuing <code>Card</code> object.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.IssuingCard> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the specified Issuing <code>Card</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.IssuingCard> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Reason why the `status` of this card is `canceled`.
            public var cancellationReason: CancellationReason?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// Authorization_controls_param
            ///
            /// Rules that control spending for this card. Refer to our [documentation](https://stripe.com/docs/issuing/controls/spending-controls) for more details.
            public var spendingControls: SpendingControls?
            /// Dictates whether authorizations can be approved on this card. If this card is being canceled because it was lost or stolen, this information should be provided as `cancellation_reason`.
            public var status: Status?

            /// Reason why the `status` of this card is `canceled`.
            public enum CancellationReason: String, Codable, CaseIterable {
                case lost
                case stolen
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Authorization_controls_param
            ///
            /// Rules that control spending for this card. Refer to our [documentation](https://stripe.com/docs/issuing/controls/spending-controls) for more details.
            public struct SpendingControls: Encodable {
                public var allowedCategories: [AllowedCategory]?
                public var blockedCategories: [BlockedCategory]?
                public var spendingLimits: [SpendingLimit]?

                public enum AllowedCategory: String, Codable, CaseIterable {
                    case acRefrigerationRepair = "ac_refrigeration_repair"
                    case accountingBookkeepingServices = "accounting_bookkeeping_services"
                    case advertisingServices = "advertising_services"
                    case agriculturalCooperative = "agricultural_cooperative"
                    case airlinesAirCarriers = "airlines_air_carriers"
                    case airportsFlyingFields = "airports_flying_fields"
                    case ambulanceServices = "ambulance_services"
                    case amusementParksCarnivals = "amusement_parks_carnivals"
                    case antiqueReproductions = "antique_reproductions"
                    case antiqueShops = "antique_shops"
                    case aquariums
                    case architecturalSurveyingServices = "architectural_surveying_services"
                    case artDealersAndGalleries = "art_dealers_and_galleries"
                    case artistsSupplyAndCraftShops = "artists_supply_and_craft_shops"
                    case autoAndHomeSupplyStores = "auto_and_home_supply_stores"
                    case autoBodyRepairShops = "auto_body_repair_shops"
                    case autoPaintShops = "auto_paint_shops"
                    case autoServiceShops = "auto_service_shops"
                    case automatedCashDisburse = "automated_cash_disburse"
                    case automatedFuelDispensers = "automated_fuel_dispensers"
                    case automobileAssociations = "automobile_associations"
                    case automotivePartsAndAccessoriesStores = "automotive_parts_and_accessories_stores"
                    case automotiveTireStores = "automotive_tire_stores"
                    case bailAndBondPayments = "bail_and_bond_payments"
                    case bakeries
                    case bandsOrchestras = "bands_orchestras"
                    case barberAndBeautyShops = "barber_and_beauty_shops"
                    case bettingCasinoGambling = "betting_casino_gambling"
                    case bicycleShops = "bicycle_shops"
                    case billiardPoolEstablishments = "billiard_pool_establishments"
                    case boatDealers = "boat_dealers"
                    case boatRentalsAndLeases = "boat_rentals_and_leases"
                    case bookStores = "book_stores"
                    case booksPeriodicalsAndNewspapers = "books_periodicals_and_newspapers"
                    case bowlingAlleys = "bowling_alleys"
                    case busLines = "bus_lines"
                    case businessSecretarialSchools = "business_secretarial_schools"
                    case buyingShoppingServices = "buying_shopping_services"
                    case cableSatelliteAndOtherPayTelevisionAndRadio = "cable_satellite_and_other_pay_television_and_radio"
                    case cameraAndPhotographicSupplyStores = "camera_and_photographic_supply_stores"
                    case candyNutAndConfectioneryStores = "candy_nut_and_confectionery_stores"
                    case carAndTruckDealersNewUsed = "car_and_truck_dealers_new_used"
                    case carAndTruckDealersUsedOnly = "car_and_truck_dealers_used_only"
                    case carRentalAgencies = "car_rental_agencies"
                    case carWashes = "car_washes"
                    case carpentryServices = "carpentry_services"
                    case carpetUpholsteryCleaning = "carpet_upholstery_cleaning"
                    case caterers
                    case charitableAndSocialServiceOrganizationsFundraising = "charitable_and_social_service_organizations_fundraising"
                    case chemicalsAndAlliedProducts = "chemicals_and_allied_products"
                    case childCareServices = "child_care_services"
                    case childrensAndInfantsWearStores = "childrens_and_infants_wear_stores"
                    case chiropodistsPodiatrists = "chiropodists_podiatrists"
                    case chiropractors
                    case cigarStoresAndStands = "cigar_stores_and_stands"
                    case civicSocialFraternalAssociations = "civic_social_fraternal_associations"
                    case cleaningAndMaintenance = "cleaning_and_maintenance"
                    case clothingRental = "clothing_rental"
                    case collegesUniversities = "colleges_universities"
                    case commercialEquipment = "commercial_equipment"
                    case commercialFootwear = "commercial_footwear"
                    case commercialPhotographyArtAndGraphics = "commercial_photography_art_and_graphics"
                    case commuterTransportAndFerries = "commuter_transport_and_ferries"
                    case computerNetworkServices = "computer_network_services"
                    case computerProgramming = "computer_programming"
                    case computerRepair = "computer_repair"
                    case computerSoftwareStores = "computer_software_stores"
                    case computersPeripheralsAndSoftware = "computers_peripherals_and_software"
                    case concreteWorkServices = "concrete_work_services"
                    case constructionMaterials = "construction_materials"
                    case consultingPublicRelations = "consulting_public_relations"
                    case correspondenceSchools = "correspondence_schools"
                    case cosmeticStores = "cosmetic_stores"
                    case counselingServices = "counseling_services"
                    case countryClubs = "country_clubs"
                    case courierServices = "courier_services"
                    case courtCosts = "court_costs"
                    case creditReportingAgencies = "credit_reporting_agencies"
                    case cruiseLines = "cruise_lines"
                    case dairyProductsStores = "dairy_products_stores"
                    case danceHallStudiosSchools = "dance_hall_studios_schools"
                    case datingEscortServices = "dating_escort_services"
                    case dentistsOrthodontists = "dentists_orthodontists"
                    case departmentStores = "department_stores"
                    case detectiveAgencies = "detective_agencies"
                    case digitalGoodsApplications = "digital_goods_applications"
                    case digitalGoodsGames = "digital_goods_games"
                    case digitalGoodsLargeVolume = "digital_goods_large_volume"
                    case digitalGoodsMedia = "digital_goods_media"
                    case directMarketingCatalogMerchant = "direct_marketing_catalog_merchant"
                    case directMarketingCombinationCatalogAndRetailMerchant = "direct_marketing_combination_catalog_and_retail_merchant"
                    case directMarketingInboundTelemarketing = "direct_marketing_inbound_telemarketing"
                    case directMarketingInsuranceServices = "direct_marketing_insurance_services"
                    case directMarketingOther = "direct_marketing_other"
                    case directMarketingOutboundTelemarketing = "direct_marketing_outbound_telemarketing"
                    case directMarketingSubscription = "direct_marketing_subscription"
                    case directMarketingTravel = "direct_marketing_travel"
                    case discountStores = "discount_stores"
                    case doctors
                    case doorToDoorSales = "door_to_door_sales"
                    case draperyWindowCoveringAndUpholsteryStores = "drapery_window_covering_and_upholstery_stores"
                    case drinkingPlaces = "drinking_places"
                    case drugStoresAndPharmacies = "drug_stores_and_pharmacies"
                    case drugsDrugProprietariesAndDruggistSundries = "drugs_drug_proprietaries_and_druggist_sundries"
                    case dryCleaners = "dry_cleaners"
                    case durableGoods = "durable_goods"
                    case dutyFreeStores = "duty_free_stores"
                    case eatingPlacesRestaurants = "eating_places_restaurants"
                    case educationalServices = "educational_services"
                    case electricRazorStores = "electric_razor_stores"
                    case electricalPartsAndEquipment = "electrical_parts_and_equipment"
                    case electricalServices = "electrical_services"
                    case electronicsRepairShops = "electronics_repair_shops"
                    case electronicsStores = "electronics_stores"
                    case elementarySecondarySchools = "elementary_secondary_schools"
                    case employmentTempAgencies = "employment_temp_agencies"
                    case equipmentRental = "equipment_rental"
                    case exterminatingServices = "exterminating_services"
                    case familyClothingStores = "family_clothing_stores"
                    case fastFoodRestaurants = "fast_food_restaurants"
                    case financialInstitutions = "financial_institutions"
                    case finesGovernmentAdministrativeEntities = "fines_government_administrative_entities"
                    case fireplaceFireplaceScreensAndAccessoriesStores = "fireplace_fireplace_screens_and_accessories_stores"
                    case floorCoveringStores = "floor_covering_stores"
                    case florists
                    case floristsSuppliesNurseryStockAndFlowers = "florists_supplies_nursery_stock_and_flowers"
                    case freezerAndLockerMeatProvisioners = "freezer_and_locker_meat_provisioners"
                    case fuelDealersNonAutomotive = "fuel_dealers_non_automotive"
                    case funeralServicesCrematories = "funeral_services_crematories"
                    case furnitureHomeFurnishingsAndEquipmentStoresExceptAppliances = "furniture_home_furnishings_and_equipment_stores_except_appliances"
                    case furnitureRepairRefinishing = "furniture_repair_refinishing"
                    case furriersAndFurShops = "furriers_and_fur_shops"
                    case generalServices = "general_services"
                    case giftCardNoveltyAndSouvenirShops = "gift_card_novelty_and_souvenir_shops"
                    case glassPaintAndWallpaperStores = "glass_paint_and_wallpaper_stores"
                    case glasswareCrystalStores = "glassware_crystal_stores"
                    case golfCoursesPublic = "golf_courses_public"
                    case governmentServices = "government_services"
                    case groceryStoresSupermarkets = "grocery_stores_supermarkets"
                    case hardwareEquipmentAndSupplies = "hardware_equipment_and_supplies"
                    case hardwareStores = "hardware_stores"
                    case healthAndBeautySpas = "health_and_beauty_spas"
                    case hearingAidsSalesAndSupplies = "hearing_aids_sales_and_supplies"
                    case heatingPlumbingAC = "heating_plumbing_a_c"
                    case hobbyToyAndGameShops = "hobby_toy_and_game_shops"
                    case homeSupplyWarehouseStores = "home_supply_warehouse_stores"
                    case hospitals
                    case hotelsMotelsAndResorts = "hotels_motels_and_resorts"
                    case householdApplianceStores = "household_appliance_stores"
                    case industrialSupplies = "industrial_supplies"
                    case informationRetrievalServices = "information_retrieval_services"
                    case insuranceDefault = "insurance_default"
                    case insuranceUnderwritingPremiums = "insurance_underwriting_premiums"
                    case intraCompanyPurchases = "intra_company_purchases"
                    case jewelryStoresWatchesClocksAndSilverwareStores = "jewelry_stores_watches_clocks_and_silverware_stores"
                    case landscapingServices = "landscaping_services"
                    case laundries
                    case laundryCleaningServices = "laundry_cleaning_services"
                    case legalServicesAttorneys = "legal_services_attorneys"
                    case luggageAndLeatherGoodsStores = "luggage_and_leather_goods_stores"
                    case lumberBuildingMaterialsStores = "lumber_building_materials_stores"
                    case manualCashDisburse = "manual_cash_disburse"
                    case marinasServiceAndSupplies = "marinas_service_and_supplies"
                    case masonryStoneworkAndPlaster = "masonry_stonework_and_plaster"
                    case massageParlors = "massage_parlors"
                    case medicalAndDentalLabs = "medical_and_dental_labs"
                    case medicalDentalOphthalmicAndHospitalEquipmentAndSupplies = "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
                    case medicalServices = "medical_services"
                    case membershipOrganizations = "membership_organizations"
                    case mensAndBoysClothingAndAccessoriesStores = "mens_and_boys_clothing_and_accessories_stores"
                    case mensWomensClothingStores = "mens_womens_clothing_stores"
                    case metalServiceCenters = "metal_service_centers"
                    case miscellaneous
                    case miscellaneousApparelAndAccessoryShops = "miscellaneous_apparel_and_accessory_shops"
                    case miscellaneousAutoDealers = "miscellaneous_auto_dealers"
                    case miscellaneousBusinessServices = "miscellaneous_business_services"
                    case miscellaneousFoodStores = "miscellaneous_food_stores"
                    case miscellaneousGeneralMerchandise = "miscellaneous_general_merchandise"
                    case miscellaneousGeneralServices = "miscellaneous_general_services"
                    case miscellaneousHomeFurnishingSpecialtyStores = "miscellaneous_home_furnishing_specialty_stores"
                    case miscellaneousPublishingAndPrinting = "miscellaneous_publishing_and_printing"
                    case miscellaneousRecreationServices = "miscellaneous_recreation_services"
                    case miscellaneousRepairShops = "miscellaneous_repair_shops"
                    case miscellaneousSpecialtyRetail = "miscellaneous_specialty_retail"
                    case mobileHomeDealers = "mobile_home_dealers"
                    case motionPictureTheaters = "motion_picture_theaters"
                    case motorFreightCarriersAndTrucking = "motor_freight_carriers_and_trucking"
                    case motorHomesDealers = "motor_homes_dealers"
                    case motorVehicleSuppliesAndNewParts = "motor_vehicle_supplies_and_new_parts"
                    case motorcycleShopsAndDealers = "motorcycle_shops_and_dealers"
                    case motorcycleShopsDealers = "motorcycle_shops_dealers"
                    case musicStoresMusicalInstrumentsPianosAndSheetMusic = "music_stores_musical_instruments_pianos_and_sheet_music"
                    case newsDealersAndNewsstands = "news_dealers_and_newsstands"
                    case nonFiMoneyOrders = "non_fi_money_orders"
                    case nonFiStoredValueCardPurchaseLoad = "non_fi_stored_value_card_purchase_load"
                    case nondurableGoods = "nondurable_goods"
                    case nurseriesLawnAndGardenSupplyStores = "nurseries_lawn_and_garden_supply_stores"
                    case nursingPersonalCare = "nursing_personal_care"
                    case officeAndCommercialFurniture = "office_and_commercial_furniture"
                    case opticiansEyeglasses = "opticians_eyeglasses"
                    case optometristsOphthalmologist = "optometrists_ophthalmologist"
                    case orthopedicGoodsProstheticDevices = "orthopedic_goods_prosthetic_devices"
                    case osteopaths
                    case packageStoresBeerWineAndLiquor = "package_stores_beer_wine_and_liquor"
                    case paintsVarnishesAndSupplies = "paints_varnishes_and_supplies"
                    case parkingLotsGarages = "parking_lots_garages"
                    case passengerRailways = "passenger_railways"
                    case pawnShops = "pawn_shops"
                    case petShopsPetFoodAndSupplies = "pet_shops_pet_food_and_supplies"
                    case petroleumAndPetroleumProducts = "petroleum_and_petroleum_products"
                    case photoDeveloping = "photo_developing"
                    case photographicPhotocopyMicrofilmEquipmentAndSupplies = "photographic_photocopy_microfilm_equipment_and_supplies"
                    case photographicStudios = "photographic_studios"
                    case pictureVideoProduction = "picture_video_production"
                    case pieceGoodsNotionsAndOtherDryGoods = "piece_goods_notions_and_other_dry_goods"
                    case plumbingHeatingEquipmentAndSupplies = "plumbing_heating_equipment_and_supplies"
                    case politicalOrganizations = "political_organizations"
                    case postalServicesGovernmentOnly = "postal_services_government_only"
                    case preciousStonesAndMetalsWatchesAndJewelry = "precious_stones_and_metals_watches_and_jewelry"
                    case professionalServices = "professional_services"
                    case publicWarehousingAndStorage = "public_warehousing_and_storage"
                    case quickCopyReproAndBlueprint = "quick_copy_repro_and_blueprint"
                    case railroads
                    case realEstateAgentsAndManagersRentals = "real_estate_agents_and_managers_rentals"
                    case recordStores = "record_stores"
                    case recreationalVehicleRentals = "recreational_vehicle_rentals"
                    case religiousGoodsStores = "religious_goods_stores"
                    case religiousOrganizations = "religious_organizations"
                    case roofingSidingSheetMetal = "roofing_siding_sheet_metal"
                    case secretarialSupportServices = "secretarial_support_services"
                    case securityBrokersDealers = "security_brokers_dealers"
                    case serviceStations = "service_stations"
                    case sewingNeedleworkFabricAndPieceGoodsStores = "sewing_needlework_fabric_and_piece_goods_stores"
                    case shoeRepairHatCleaning = "shoe_repair_hat_cleaning"
                    case shoeStores = "shoe_stores"
                    case smallApplianceRepair = "small_appliance_repair"
                    case snowmobileDealers = "snowmobile_dealers"
                    case specialTradeServices = "special_trade_services"
                    case specialtyCleaning = "specialty_cleaning"
                    case sportingGoodsStores = "sporting_goods_stores"
                    case sportingRecreationCamps = "sporting_recreation_camps"
                    case sportsAndRidingApparelStores = "sports_and_riding_apparel_stores"
                    case sportsClubsFields = "sports_clubs_fields"
                    case stampAndCoinStores = "stamp_and_coin_stores"
                    case stationaryOfficeSuppliesPrintingAndWritingPaper = "stationary_office_supplies_printing_and_writing_paper"
                    case stationeryStoresOfficeAndSchoolSupplyStores = "stationery_stores_office_and_school_supply_stores"
                    case swimmingPoolsSales = "swimming_pools_sales"
                    case tUiTravelGermany = "t_ui_travel_germany"
                    case tailorsAlterations = "tailors_alterations"
                    case taxPaymentsGovernmentAgencies = "tax_payments_government_agencies"
                    case taxPreparationServices = "tax_preparation_services"
                    case taxicabsLimousines = "taxicabs_limousines"
                    case telecommunicationEquipmentAndTelephoneSales = "telecommunication_equipment_and_telephone_sales"
                    case telecommunicationServices = "telecommunication_services"
                    case telegraphServices = "telegraph_services"
                    case tentAndAwningShops = "tent_and_awning_shops"
                    case testingLaboratories = "testing_laboratories"
                    case theatricalTicketAgencies = "theatrical_ticket_agencies"
                    case timeshares
                    case tireRetreadingAndRepair = "tire_retreading_and_repair"
                    case tollsBridgeFees = "tolls_bridge_fees"
                    case touristAttractionsAndExhibits = "tourist_attractions_and_exhibits"
                    case towingServices = "towing_services"
                    case trailerParksCampgrounds = "trailer_parks_campgrounds"
                    case transportationServices = "transportation_services"
                    case travelAgenciesTourOperators = "travel_agencies_tour_operators"
                    case truckStopIteration = "truck_stop_iteration"
                    case truckUtilityTrailerRentals = "truck_utility_trailer_rentals"
                    case typesettingPlateMakingAndRelatedServices = "typesetting_plate_making_and_related_services"
                    case typewriterStores = "typewriter_stores"
                    case uSFederalGovernmentAgenciesOrDepartments = "u_s_federal_government_agencies_or_departments"
                    case uniformsCommercialClothing = "uniforms_commercial_clothing"
                    case usedMerchandiseAndSecondhandStores = "used_merchandise_and_secondhand_stores"
                    case utilities
                    case varietyStores = "variety_stores"
                    case veterinaryServices = "veterinary_services"
                    case videoAmusementGameSupplies = "video_amusement_game_supplies"
                    case videoGameArcades = "video_game_arcades"
                    case videoTapeRentalStores = "video_tape_rental_stores"
                    case vocationalTradeSchools = "vocational_trade_schools"
                    case watchJewelryRepair = "watch_jewelry_repair"
                    case weldingRepair = "welding_repair"
                    case wholesaleClubs = "wholesale_clubs"
                    case wigAndToupeeStores = "wig_and_toupee_stores"
                    case wiresMoneyOrders = "wires_money_orders"
                    case womensAccessoryAndSpecialtyShops = "womens_accessory_and_specialty_shops"
                    case womensReadyToWearStores = "womens_ready_to_wear_stores"
                    case wreckingAndSalvageYards = "wrecking_and_salvage_yards"
                }

                public enum BlockedCategory: String, Codable, CaseIterable {
                    case acRefrigerationRepair = "ac_refrigeration_repair"
                    case accountingBookkeepingServices = "accounting_bookkeeping_services"
                    case advertisingServices = "advertising_services"
                    case agriculturalCooperative = "agricultural_cooperative"
                    case airlinesAirCarriers = "airlines_air_carriers"
                    case airportsFlyingFields = "airports_flying_fields"
                    case ambulanceServices = "ambulance_services"
                    case amusementParksCarnivals = "amusement_parks_carnivals"
                    case antiqueReproductions = "antique_reproductions"
                    case antiqueShops = "antique_shops"
                    case aquariums
                    case architecturalSurveyingServices = "architectural_surveying_services"
                    case artDealersAndGalleries = "art_dealers_and_galleries"
                    case artistsSupplyAndCraftShops = "artists_supply_and_craft_shops"
                    case autoAndHomeSupplyStores = "auto_and_home_supply_stores"
                    case autoBodyRepairShops = "auto_body_repair_shops"
                    case autoPaintShops = "auto_paint_shops"
                    case autoServiceShops = "auto_service_shops"
                    case automatedCashDisburse = "automated_cash_disburse"
                    case automatedFuelDispensers = "automated_fuel_dispensers"
                    case automobileAssociations = "automobile_associations"
                    case automotivePartsAndAccessoriesStores = "automotive_parts_and_accessories_stores"
                    case automotiveTireStores = "automotive_tire_stores"
                    case bailAndBondPayments = "bail_and_bond_payments"
                    case bakeries
                    case bandsOrchestras = "bands_orchestras"
                    case barberAndBeautyShops = "barber_and_beauty_shops"
                    case bettingCasinoGambling = "betting_casino_gambling"
                    case bicycleShops = "bicycle_shops"
                    case billiardPoolEstablishments = "billiard_pool_establishments"
                    case boatDealers = "boat_dealers"
                    case boatRentalsAndLeases = "boat_rentals_and_leases"
                    case bookStores = "book_stores"
                    case booksPeriodicalsAndNewspapers = "books_periodicals_and_newspapers"
                    case bowlingAlleys = "bowling_alleys"
                    case busLines = "bus_lines"
                    case businessSecretarialSchools = "business_secretarial_schools"
                    case buyingShoppingServices = "buying_shopping_services"
                    case cableSatelliteAndOtherPayTelevisionAndRadio = "cable_satellite_and_other_pay_television_and_radio"
                    case cameraAndPhotographicSupplyStores = "camera_and_photographic_supply_stores"
                    case candyNutAndConfectioneryStores = "candy_nut_and_confectionery_stores"
                    case carAndTruckDealersNewUsed = "car_and_truck_dealers_new_used"
                    case carAndTruckDealersUsedOnly = "car_and_truck_dealers_used_only"
                    case carRentalAgencies = "car_rental_agencies"
                    case carWashes = "car_washes"
                    case carpentryServices = "carpentry_services"
                    case carpetUpholsteryCleaning = "carpet_upholstery_cleaning"
                    case caterers
                    case charitableAndSocialServiceOrganizationsFundraising = "charitable_and_social_service_organizations_fundraising"
                    case chemicalsAndAlliedProducts = "chemicals_and_allied_products"
                    case childCareServices = "child_care_services"
                    case childrensAndInfantsWearStores = "childrens_and_infants_wear_stores"
                    case chiropodistsPodiatrists = "chiropodists_podiatrists"
                    case chiropractors
                    case cigarStoresAndStands = "cigar_stores_and_stands"
                    case civicSocialFraternalAssociations = "civic_social_fraternal_associations"
                    case cleaningAndMaintenance = "cleaning_and_maintenance"
                    case clothingRental = "clothing_rental"
                    case collegesUniversities = "colleges_universities"
                    case commercialEquipment = "commercial_equipment"
                    case commercialFootwear = "commercial_footwear"
                    case commercialPhotographyArtAndGraphics = "commercial_photography_art_and_graphics"
                    case commuterTransportAndFerries = "commuter_transport_and_ferries"
                    case computerNetworkServices = "computer_network_services"
                    case computerProgramming = "computer_programming"
                    case computerRepair = "computer_repair"
                    case computerSoftwareStores = "computer_software_stores"
                    case computersPeripheralsAndSoftware = "computers_peripherals_and_software"
                    case concreteWorkServices = "concrete_work_services"
                    case constructionMaterials = "construction_materials"
                    case consultingPublicRelations = "consulting_public_relations"
                    case correspondenceSchools = "correspondence_schools"
                    case cosmeticStores = "cosmetic_stores"
                    case counselingServices = "counseling_services"
                    case countryClubs = "country_clubs"
                    case courierServices = "courier_services"
                    case courtCosts = "court_costs"
                    case creditReportingAgencies = "credit_reporting_agencies"
                    case cruiseLines = "cruise_lines"
                    case dairyProductsStores = "dairy_products_stores"
                    case danceHallStudiosSchools = "dance_hall_studios_schools"
                    case datingEscortServices = "dating_escort_services"
                    case dentistsOrthodontists = "dentists_orthodontists"
                    case departmentStores = "department_stores"
                    case detectiveAgencies = "detective_agencies"
                    case digitalGoodsApplications = "digital_goods_applications"
                    case digitalGoodsGames = "digital_goods_games"
                    case digitalGoodsLargeVolume = "digital_goods_large_volume"
                    case digitalGoodsMedia = "digital_goods_media"
                    case directMarketingCatalogMerchant = "direct_marketing_catalog_merchant"
                    case directMarketingCombinationCatalogAndRetailMerchant = "direct_marketing_combination_catalog_and_retail_merchant"
                    case directMarketingInboundTelemarketing = "direct_marketing_inbound_telemarketing"
                    case directMarketingInsuranceServices = "direct_marketing_insurance_services"
                    case directMarketingOther = "direct_marketing_other"
                    case directMarketingOutboundTelemarketing = "direct_marketing_outbound_telemarketing"
                    case directMarketingSubscription = "direct_marketing_subscription"
                    case directMarketingTravel = "direct_marketing_travel"
                    case discountStores = "discount_stores"
                    case doctors
                    case doorToDoorSales = "door_to_door_sales"
                    case draperyWindowCoveringAndUpholsteryStores = "drapery_window_covering_and_upholstery_stores"
                    case drinkingPlaces = "drinking_places"
                    case drugStoresAndPharmacies = "drug_stores_and_pharmacies"
                    case drugsDrugProprietariesAndDruggistSundries = "drugs_drug_proprietaries_and_druggist_sundries"
                    case dryCleaners = "dry_cleaners"
                    case durableGoods = "durable_goods"
                    case dutyFreeStores = "duty_free_stores"
                    case eatingPlacesRestaurants = "eating_places_restaurants"
                    case educationalServices = "educational_services"
                    case electricRazorStores = "electric_razor_stores"
                    case electricalPartsAndEquipment = "electrical_parts_and_equipment"
                    case electricalServices = "electrical_services"
                    case electronicsRepairShops = "electronics_repair_shops"
                    case electronicsStores = "electronics_stores"
                    case elementarySecondarySchools = "elementary_secondary_schools"
                    case employmentTempAgencies = "employment_temp_agencies"
                    case equipmentRental = "equipment_rental"
                    case exterminatingServices = "exterminating_services"
                    case familyClothingStores = "family_clothing_stores"
                    case fastFoodRestaurants = "fast_food_restaurants"
                    case financialInstitutions = "financial_institutions"
                    case finesGovernmentAdministrativeEntities = "fines_government_administrative_entities"
                    case fireplaceFireplaceScreensAndAccessoriesStores = "fireplace_fireplace_screens_and_accessories_stores"
                    case floorCoveringStores = "floor_covering_stores"
                    case florists
                    case floristsSuppliesNurseryStockAndFlowers = "florists_supplies_nursery_stock_and_flowers"
                    case freezerAndLockerMeatProvisioners = "freezer_and_locker_meat_provisioners"
                    case fuelDealersNonAutomotive = "fuel_dealers_non_automotive"
                    case funeralServicesCrematories = "funeral_services_crematories"
                    case furnitureHomeFurnishingsAndEquipmentStoresExceptAppliances = "furniture_home_furnishings_and_equipment_stores_except_appliances"
                    case furnitureRepairRefinishing = "furniture_repair_refinishing"
                    case furriersAndFurShops = "furriers_and_fur_shops"
                    case generalServices = "general_services"
                    case giftCardNoveltyAndSouvenirShops = "gift_card_novelty_and_souvenir_shops"
                    case glassPaintAndWallpaperStores = "glass_paint_and_wallpaper_stores"
                    case glasswareCrystalStores = "glassware_crystal_stores"
                    case golfCoursesPublic = "golf_courses_public"
                    case governmentServices = "government_services"
                    case groceryStoresSupermarkets = "grocery_stores_supermarkets"
                    case hardwareEquipmentAndSupplies = "hardware_equipment_and_supplies"
                    case hardwareStores = "hardware_stores"
                    case healthAndBeautySpas = "health_and_beauty_spas"
                    case hearingAidsSalesAndSupplies = "hearing_aids_sales_and_supplies"
                    case heatingPlumbingAC = "heating_plumbing_a_c"
                    case hobbyToyAndGameShops = "hobby_toy_and_game_shops"
                    case homeSupplyWarehouseStores = "home_supply_warehouse_stores"
                    case hospitals
                    case hotelsMotelsAndResorts = "hotels_motels_and_resorts"
                    case householdApplianceStores = "household_appliance_stores"
                    case industrialSupplies = "industrial_supplies"
                    case informationRetrievalServices = "information_retrieval_services"
                    case insuranceDefault = "insurance_default"
                    case insuranceUnderwritingPremiums = "insurance_underwriting_premiums"
                    case intraCompanyPurchases = "intra_company_purchases"
                    case jewelryStoresWatchesClocksAndSilverwareStores = "jewelry_stores_watches_clocks_and_silverware_stores"
                    case landscapingServices = "landscaping_services"
                    case laundries
                    case laundryCleaningServices = "laundry_cleaning_services"
                    case legalServicesAttorneys = "legal_services_attorneys"
                    case luggageAndLeatherGoodsStores = "luggage_and_leather_goods_stores"
                    case lumberBuildingMaterialsStores = "lumber_building_materials_stores"
                    case manualCashDisburse = "manual_cash_disburse"
                    case marinasServiceAndSupplies = "marinas_service_and_supplies"
                    case masonryStoneworkAndPlaster = "masonry_stonework_and_plaster"
                    case massageParlors = "massage_parlors"
                    case medicalAndDentalLabs = "medical_and_dental_labs"
                    case medicalDentalOphthalmicAndHospitalEquipmentAndSupplies = "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
                    case medicalServices = "medical_services"
                    case membershipOrganizations = "membership_organizations"
                    case mensAndBoysClothingAndAccessoriesStores = "mens_and_boys_clothing_and_accessories_stores"
                    case mensWomensClothingStores = "mens_womens_clothing_stores"
                    case metalServiceCenters = "metal_service_centers"
                    case miscellaneous
                    case miscellaneousApparelAndAccessoryShops = "miscellaneous_apparel_and_accessory_shops"
                    case miscellaneousAutoDealers = "miscellaneous_auto_dealers"
                    case miscellaneousBusinessServices = "miscellaneous_business_services"
                    case miscellaneousFoodStores = "miscellaneous_food_stores"
                    case miscellaneousGeneralMerchandise = "miscellaneous_general_merchandise"
                    case miscellaneousGeneralServices = "miscellaneous_general_services"
                    case miscellaneousHomeFurnishingSpecialtyStores = "miscellaneous_home_furnishing_specialty_stores"
                    case miscellaneousPublishingAndPrinting = "miscellaneous_publishing_and_printing"
                    case miscellaneousRecreationServices = "miscellaneous_recreation_services"
                    case miscellaneousRepairShops = "miscellaneous_repair_shops"
                    case miscellaneousSpecialtyRetail = "miscellaneous_specialty_retail"
                    case mobileHomeDealers = "mobile_home_dealers"
                    case motionPictureTheaters = "motion_picture_theaters"
                    case motorFreightCarriersAndTrucking = "motor_freight_carriers_and_trucking"
                    case motorHomesDealers = "motor_homes_dealers"
                    case motorVehicleSuppliesAndNewParts = "motor_vehicle_supplies_and_new_parts"
                    case motorcycleShopsAndDealers = "motorcycle_shops_and_dealers"
                    case motorcycleShopsDealers = "motorcycle_shops_dealers"
                    case musicStoresMusicalInstrumentsPianosAndSheetMusic = "music_stores_musical_instruments_pianos_and_sheet_music"
                    case newsDealersAndNewsstands = "news_dealers_and_newsstands"
                    case nonFiMoneyOrders = "non_fi_money_orders"
                    case nonFiStoredValueCardPurchaseLoad = "non_fi_stored_value_card_purchase_load"
                    case nondurableGoods = "nondurable_goods"
                    case nurseriesLawnAndGardenSupplyStores = "nurseries_lawn_and_garden_supply_stores"
                    case nursingPersonalCare = "nursing_personal_care"
                    case officeAndCommercialFurniture = "office_and_commercial_furniture"
                    case opticiansEyeglasses = "opticians_eyeglasses"
                    case optometristsOphthalmologist = "optometrists_ophthalmologist"
                    case orthopedicGoodsProstheticDevices = "orthopedic_goods_prosthetic_devices"
                    case osteopaths
                    case packageStoresBeerWineAndLiquor = "package_stores_beer_wine_and_liquor"
                    case paintsVarnishesAndSupplies = "paints_varnishes_and_supplies"
                    case parkingLotsGarages = "parking_lots_garages"
                    case passengerRailways = "passenger_railways"
                    case pawnShops = "pawn_shops"
                    case petShopsPetFoodAndSupplies = "pet_shops_pet_food_and_supplies"
                    case petroleumAndPetroleumProducts = "petroleum_and_petroleum_products"
                    case photoDeveloping = "photo_developing"
                    case photographicPhotocopyMicrofilmEquipmentAndSupplies = "photographic_photocopy_microfilm_equipment_and_supplies"
                    case photographicStudios = "photographic_studios"
                    case pictureVideoProduction = "picture_video_production"
                    case pieceGoodsNotionsAndOtherDryGoods = "piece_goods_notions_and_other_dry_goods"
                    case plumbingHeatingEquipmentAndSupplies = "plumbing_heating_equipment_and_supplies"
                    case politicalOrganizations = "political_organizations"
                    case postalServicesGovernmentOnly = "postal_services_government_only"
                    case preciousStonesAndMetalsWatchesAndJewelry = "precious_stones_and_metals_watches_and_jewelry"
                    case professionalServices = "professional_services"
                    case publicWarehousingAndStorage = "public_warehousing_and_storage"
                    case quickCopyReproAndBlueprint = "quick_copy_repro_and_blueprint"
                    case railroads
                    case realEstateAgentsAndManagersRentals = "real_estate_agents_and_managers_rentals"
                    case recordStores = "record_stores"
                    case recreationalVehicleRentals = "recreational_vehicle_rentals"
                    case religiousGoodsStores = "religious_goods_stores"
                    case religiousOrganizations = "religious_organizations"
                    case roofingSidingSheetMetal = "roofing_siding_sheet_metal"
                    case secretarialSupportServices = "secretarial_support_services"
                    case securityBrokersDealers = "security_brokers_dealers"
                    case serviceStations = "service_stations"
                    case sewingNeedleworkFabricAndPieceGoodsStores = "sewing_needlework_fabric_and_piece_goods_stores"
                    case shoeRepairHatCleaning = "shoe_repair_hat_cleaning"
                    case shoeStores = "shoe_stores"
                    case smallApplianceRepair = "small_appliance_repair"
                    case snowmobileDealers = "snowmobile_dealers"
                    case specialTradeServices = "special_trade_services"
                    case specialtyCleaning = "specialty_cleaning"
                    case sportingGoodsStores = "sporting_goods_stores"
                    case sportingRecreationCamps = "sporting_recreation_camps"
                    case sportsAndRidingApparelStores = "sports_and_riding_apparel_stores"
                    case sportsClubsFields = "sports_clubs_fields"
                    case stampAndCoinStores = "stamp_and_coin_stores"
                    case stationaryOfficeSuppliesPrintingAndWritingPaper = "stationary_office_supplies_printing_and_writing_paper"
                    case stationeryStoresOfficeAndSchoolSupplyStores = "stationery_stores_office_and_school_supply_stores"
                    case swimmingPoolsSales = "swimming_pools_sales"
                    case tUiTravelGermany = "t_ui_travel_germany"
                    case tailorsAlterations = "tailors_alterations"
                    case taxPaymentsGovernmentAgencies = "tax_payments_government_agencies"
                    case taxPreparationServices = "tax_preparation_services"
                    case taxicabsLimousines = "taxicabs_limousines"
                    case telecommunicationEquipmentAndTelephoneSales = "telecommunication_equipment_and_telephone_sales"
                    case telecommunicationServices = "telecommunication_services"
                    case telegraphServices = "telegraph_services"
                    case tentAndAwningShops = "tent_and_awning_shops"
                    case testingLaboratories = "testing_laboratories"
                    case theatricalTicketAgencies = "theatrical_ticket_agencies"
                    case timeshares
                    case tireRetreadingAndRepair = "tire_retreading_and_repair"
                    case tollsBridgeFees = "tolls_bridge_fees"
                    case touristAttractionsAndExhibits = "tourist_attractions_and_exhibits"
                    case towingServices = "towing_services"
                    case trailerParksCampgrounds = "trailer_parks_campgrounds"
                    case transportationServices = "transportation_services"
                    case travelAgenciesTourOperators = "travel_agencies_tour_operators"
                    case truckStopIteration = "truck_stop_iteration"
                    case truckUtilityTrailerRentals = "truck_utility_trailer_rentals"
                    case typesettingPlateMakingAndRelatedServices = "typesetting_plate_making_and_related_services"
                    case typewriterStores = "typewriter_stores"
                    case uSFederalGovernmentAgenciesOrDepartments = "u_s_federal_government_agencies_or_departments"
                    case uniformsCommercialClothing = "uniforms_commercial_clothing"
                    case usedMerchandiseAndSecondhandStores = "used_merchandise_and_secondhand_stores"
                    case utilities
                    case varietyStores = "variety_stores"
                    case veterinaryServices = "veterinary_services"
                    case videoAmusementGameSupplies = "video_amusement_game_supplies"
                    case videoGameArcades = "video_game_arcades"
                    case videoTapeRentalStores = "video_tape_rental_stores"
                    case vocationalTradeSchools = "vocational_trade_schools"
                    case watchJewelryRepair = "watch_jewelry_repair"
                    case weldingRepair = "welding_repair"
                    case wholesaleClubs = "wholesale_clubs"
                    case wigAndToupeeStores = "wig_and_toupee_stores"
                    case wiresMoneyOrders = "wires_money_orders"
                    case womensAccessoryAndSpecialtyShops = "womens_accessory_and_specialty_shops"
                    case womensReadyToWearStores = "womens_ready_to_wear_stores"
                    case wreckingAndSalvageYards = "wrecking_and_salvage_yards"
                }

                /// Spending_limits_param
                public struct SpendingLimit: Encodable {
                    public var amount: Int
                    public var categories: [Category]?
                    public var interval: Interval

                    public enum Category: String, Codable, CaseIterable {
                        case acRefrigerationRepair = "ac_refrigeration_repair"
                        case accountingBookkeepingServices = "accounting_bookkeeping_services"
                        case advertisingServices = "advertising_services"
                        case agriculturalCooperative = "agricultural_cooperative"
                        case airlinesAirCarriers = "airlines_air_carriers"
                        case airportsFlyingFields = "airports_flying_fields"
                        case ambulanceServices = "ambulance_services"
                        case amusementParksCarnivals = "amusement_parks_carnivals"
                        case antiqueReproductions = "antique_reproductions"
                        case antiqueShops = "antique_shops"
                        case aquariums
                        case architecturalSurveyingServices = "architectural_surveying_services"
                        case artDealersAndGalleries = "art_dealers_and_galleries"
                        case artistsSupplyAndCraftShops = "artists_supply_and_craft_shops"
                        case autoAndHomeSupplyStores = "auto_and_home_supply_stores"
                        case autoBodyRepairShops = "auto_body_repair_shops"
                        case autoPaintShops = "auto_paint_shops"
                        case autoServiceShops = "auto_service_shops"
                        case automatedCashDisburse = "automated_cash_disburse"
                        case automatedFuelDispensers = "automated_fuel_dispensers"
                        case automobileAssociations = "automobile_associations"
                        case automotivePartsAndAccessoriesStores = "automotive_parts_and_accessories_stores"
                        case automotiveTireStores = "automotive_tire_stores"
                        case bailAndBondPayments = "bail_and_bond_payments"
                        case bakeries
                        case bandsOrchestras = "bands_orchestras"
                        case barberAndBeautyShops = "barber_and_beauty_shops"
                        case bettingCasinoGambling = "betting_casino_gambling"
                        case bicycleShops = "bicycle_shops"
                        case billiardPoolEstablishments = "billiard_pool_establishments"
                        case boatDealers = "boat_dealers"
                        case boatRentalsAndLeases = "boat_rentals_and_leases"
                        case bookStores = "book_stores"
                        case booksPeriodicalsAndNewspapers = "books_periodicals_and_newspapers"
                        case bowlingAlleys = "bowling_alleys"
                        case busLines = "bus_lines"
                        case businessSecretarialSchools = "business_secretarial_schools"
                        case buyingShoppingServices = "buying_shopping_services"
                        case cableSatelliteAndOtherPayTelevisionAndRadio = "cable_satellite_and_other_pay_television_and_radio"
                        case cameraAndPhotographicSupplyStores = "camera_and_photographic_supply_stores"
                        case candyNutAndConfectioneryStores = "candy_nut_and_confectionery_stores"
                        case carAndTruckDealersNewUsed = "car_and_truck_dealers_new_used"
                        case carAndTruckDealersUsedOnly = "car_and_truck_dealers_used_only"
                        case carRentalAgencies = "car_rental_agencies"
                        case carWashes = "car_washes"
                        case carpentryServices = "carpentry_services"
                        case carpetUpholsteryCleaning = "carpet_upholstery_cleaning"
                        case caterers
                        case charitableAndSocialServiceOrganizationsFundraising = "charitable_and_social_service_organizations_fundraising"
                        case chemicalsAndAlliedProducts = "chemicals_and_allied_products"
                        case childCareServices = "child_care_services"
                        case childrensAndInfantsWearStores = "childrens_and_infants_wear_stores"
                        case chiropodistsPodiatrists = "chiropodists_podiatrists"
                        case chiropractors
                        case cigarStoresAndStands = "cigar_stores_and_stands"
                        case civicSocialFraternalAssociations = "civic_social_fraternal_associations"
                        case cleaningAndMaintenance = "cleaning_and_maintenance"
                        case clothingRental = "clothing_rental"
                        case collegesUniversities = "colleges_universities"
                        case commercialEquipment = "commercial_equipment"
                        case commercialFootwear = "commercial_footwear"
                        case commercialPhotographyArtAndGraphics = "commercial_photography_art_and_graphics"
                        case commuterTransportAndFerries = "commuter_transport_and_ferries"
                        case computerNetworkServices = "computer_network_services"
                        case computerProgramming = "computer_programming"
                        case computerRepair = "computer_repair"
                        case computerSoftwareStores = "computer_software_stores"
                        case computersPeripheralsAndSoftware = "computers_peripherals_and_software"
                        case concreteWorkServices = "concrete_work_services"
                        case constructionMaterials = "construction_materials"
                        case consultingPublicRelations = "consulting_public_relations"
                        case correspondenceSchools = "correspondence_schools"
                        case cosmeticStores = "cosmetic_stores"
                        case counselingServices = "counseling_services"
                        case countryClubs = "country_clubs"
                        case courierServices = "courier_services"
                        case courtCosts = "court_costs"
                        case creditReportingAgencies = "credit_reporting_agencies"
                        case cruiseLines = "cruise_lines"
                        case dairyProductsStores = "dairy_products_stores"
                        case danceHallStudiosSchools = "dance_hall_studios_schools"
                        case datingEscortServices = "dating_escort_services"
                        case dentistsOrthodontists = "dentists_orthodontists"
                        case departmentStores = "department_stores"
                        case detectiveAgencies = "detective_agencies"
                        case digitalGoodsApplications = "digital_goods_applications"
                        case digitalGoodsGames = "digital_goods_games"
                        case digitalGoodsLargeVolume = "digital_goods_large_volume"
                        case digitalGoodsMedia = "digital_goods_media"
                        case directMarketingCatalogMerchant = "direct_marketing_catalog_merchant"
                        case directMarketingCombinationCatalogAndRetailMerchant = "direct_marketing_combination_catalog_and_retail_merchant"
                        case directMarketingInboundTelemarketing = "direct_marketing_inbound_telemarketing"
                        case directMarketingInsuranceServices = "direct_marketing_insurance_services"
                        case directMarketingOther = "direct_marketing_other"
                        case directMarketingOutboundTelemarketing = "direct_marketing_outbound_telemarketing"
                        case directMarketingSubscription = "direct_marketing_subscription"
                        case directMarketingTravel = "direct_marketing_travel"
                        case discountStores = "discount_stores"
                        case doctors
                        case doorToDoorSales = "door_to_door_sales"
                        case draperyWindowCoveringAndUpholsteryStores = "drapery_window_covering_and_upholstery_stores"
                        case drinkingPlaces = "drinking_places"
                        case drugStoresAndPharmacies = "drug_stores_and_pharmacies"
                        case drugsDrugProprietariesAndDruggistSundries = "drugs_drug_proprietaries_and_druggist_sundries"
                        case dryCleaners = "dry_cleaners"
                        case durableGoods = "durable_goods"
                        case dutyFreeStores = "duty_free_stores"
                        case eatingPlacesRestaurants = "eating_places_restaurants"
                        case educationalServices = "educational_services"
                        case electricRazorStores = "electric_razor_stores"
                        case electricalPartsAndEquipment = "electrical_parts_and_equipment"
                        case electricalServices = "electrical_services"
                        case electronicsRepairShops = "electronics_repair_shops"
                        case electronicsStores = "electronics_stores"
                        case elementarySecondarySchools = "elementary_secondary_schools"
                        case employmentTempAgencies = "employment_temp_agencies"
                        case equipmentRental = "equipment_rental"
                        case exterminatingServices = "exterminating_services"
                        case familyClothingStores = "family_clothing_stores"
                        case fastFoodRestaurants = "fast_food_restaurants"
                        case financialInstitutions = "financial_institutions"
                        case finesGovernmentAdministrativeEntities = "fines_government_administrative_entities"
                        case fireplaceFireplaceScreensAndAccessoriesStores = "fireplace_fireplace_screens_and_accessories_stores"
                        case floorCoveringStores = "floor_covering_stores"
                        case florists
                        case floristsSuppliesNurseryStockAndFlowers = "florists_supplies_nursery_stock_and_flowers"
                        case freezerAndLockerMeatProvisioners = "freezer_and_locker_meat_provisioners"
                        case fuelDealersNonAutomotive = "fuel_dealers_non_automotive"
                        case funeralServicesCrematories = "funeral_services_crematories"
                        case furnitureHomeFurnishingsAndEquipmentStoresExceptAppliances = "furniture_home_furnishings_and_equipment_stores_except_appliances"
                        case furnitureRepairRefinishing = "furniture_repair_refinishing"
                        case furriersAndFurShops = "furriers_and_fur_shops"
                        case generalServices = "general_services"
                        case giftCardNoveltyAndSouvenirShops = "gift_card_novelty_and_souvenir_shops"
                        case glassPaintAndWallpaperStores = "glass_paint_and_wallpaper_stores"
                        case glasswareCrystalStores = "glassware_crystal_stores"
                        case golfCoursesPublic = "golf_courses_public"
                        case governmentServices = "government_services"
                        case groceryStoresSupermarkets = "grocery_stores_supermarkets"
                        case hardwareEquipmentAndSupplies = "hardware_equipment_and_supplies"
                        case hardwareStores = "hardware_stores"
                        case healthAndBeautySpas = "health_and_beauty_spas"
                        case hearingAidsSalesAndSupplies = "hearing_aids_sales_and_supplies"
                        case heatingPlumbingAC = "heating_plumbing_a_c"
                        case hobbyToyAndGameShops = "hobby_toy_and_game_shops"
                        case homeSupplyWarehouseStores = "home_supply_warehouse_stores"
                        case hospitals
                        case hotelsMotelsAndResorts = "hotels_motels_and_resorts"
                        case householdApplianceStores = "household_appliance_stores"
                        case industrialSupplies = "industrial_supplies"
                        case informationRetrievalServices = "information_retrieval_services"
                        case insuranceDefault = "insurance_default"
                        case insuranceUnderwritingPremiums = "insurance_underwriting_premiums"
                        case intraCompanyPurchases = "intra_company_purchases"
                        case jewelryStoresWatchesClocksAndSilverwareStores = "jewelry_stores_watches_clocks_and_silverware_stores"
                        case landscapingServices = "landscaping_services"
                        case laundries
                        case laundryCleaningServices = "laundry_cleaning_services"
                        case legalServicesAttorneys = "legal_services_attorneys"
                        case luggageAndLeatherGoodsStores = "luggage_and_leather_goods_stores"
                        case lumberBuildingMaterialsStores = "lumber_building_materials_stores"
                        case manualCashDisburse = "manual_cash_disburse"
                        case marinasServiceAndSupplies = "marinas_service_and_supplies"
                        case masonryStoneworkAndPlaster = "masonry_stonework_and_plaster"
                        case massageParlors = "massage_parlors"
                        case medicalAndDentalLabs = "medical_and_dental_labs"
                        case medicalDentalOphthalmicAndHospitalEquipmentAndSupplies = "medical_dental_ophthalmic_and_hospital_equipment_and_supplies"
                        case medicalServices = "medical_services"
                        case membershipOrganizations = "membership_organizations"
                        case mensAndBoysClothingAndAccessoriesStores = "mens_and_boys_clothing_and_accessories_stores"
                        case mensWomensClothingStores = "mens_womens_clothing_stores"
                        case metalServiceCenters = "metal_service_centers"
                        case miscellaneous
                        case miscellaneousApparelAndAccessoryShops = "miscellaneous_apparel_and_accessory_shops"
                        case miscellaneousAutoDealers = "miscellaneous_auto_dealers"
                        case miscellaneousBusinessServices = "miscellaneous_business_services"
                        case miscellaneousFoodStores = "miscellaneous_food_stores"
                        case miscellaneousGeneralMerchandise = "miscellaneous_general_merchandise"
                        case miscellaneousGeneralServices = "miscellaneous_general_services"
                        case miscellaneousHomeFurnishingSpecialtyStores = "miscellaneous_home_furnishing_specialty_stores"
                        case miscellaneousPublishingAndPrinting = "miscellaneous_publishing_and_printing"
                        case miscellaneousRecreationServices = "miscellaneous_recreation_services"
                        case miscellaneousRepairShops = "miscellaneous_repair_shops"
                        case miscellaneousSpecialtyRetail = "miscellaneous_specialty_retail"
                        case mobileHomeDealers = "mobile_home_dealers"
                        case motionPictureTheaters = "motion_picture_theaters"
                        case motorFreightCarriersAndTrucking = "motor_freight_carriers_and_trucking"
                        case motorHomesDealers = "motor_homes_dealers"
                        case motorVehicleSuppliesAndNewParts = "motor_vehicle_supplies_and_new_parts"
                        case motorcycleShopsAndDealers = "motorcycle_shops_and_dealers"
                        case motorcycleShopsDealers = "motorcycle_shops_dealers"
                        case musicStoresMusicalInstrumentsPianosAndSheetMusic = "music_stores_musical_instruments_pianos_and_sheet_music"
                        case newsDealersAndNewsstands = "news_dealers_and_newsstands"
                        case nonFiMoneyOrders = "non_fi_money_orders"
                        case nonFiStoredValueCardPurchaseLoad = "non_fi_stored_value_card_purchase_load"
                        case nondurableGoods = "nondurable_goods"
                        case nurseriesLawnAndGardenSupplyStores = "nurseries_lawn_and_garden_supply_stores"
                        case nursingPersonalCare = "nursing_personal_care"
                        case officeAndCommercialFurniture = "office_and_commercial_furniture"
                        case opticiansEyeglasses = "opticians_eyeglasses"
                        case optometristsOphthalmologist = "optometrists_ophthalmologist"
                        case orthopedicGoodsProstheticDevices = "orthopedic_goods_prosthetic_devices"
                        case osteopaths
                        case packageStoresBeerWineAndLiquor = "package_stores_beer_wine_and_liquor"
                        case paintsVarnishesAndSupplies = "paints_varnishes_and_supplies"
                        case parkingLotsGarages = "parking_lots_garages"
                        case passengerRailways = "passenger_railways"
                        case pawnShops = "pawn_shops"
                        case petShopsPetFoodAndSupplies = "pet_shops_pet_food_and_supplies"
                        case petroleumAndPetroleumProducts = "petroleum_and_petroleum_products"
                        case photoDeveloping = "photo_developing"
                        case photographicPhotocopyMicrofilmEquipmentAndSupplies = "photographic_photocopy_microfilm_equipment_and_supplies"
                        case photographicStudios = "photographic_studios"
                        case pictureVideoProduction = "picture_video_production"
                        case pieceGoodsNotionsAndOtherDryGoods = "piece_goods_notions_and_other_dry_goods"
                        case plumbingHeatingEquipmentAndSupplies = "plumbing_heating_equipment_and_supplies"
                        case politicalOrganizations = "political_organizations"
                        case postalServicesGovernmentOnly = "postal_services_government_only"
                        case preciousStonesAndMetalsWatchesAndJewelry = "precious_stones_and_metals_watches_and_jewelry"
                        case professionalServices = "professional_services"
                        case publicWarehousingAndStorage = "public_warehousing_and_storage"
                        case quickCopyReproAndBlueprint = "quick_copy_repro_and_blueprint"
                        case railroads
                        case realEstateAgentsAndManagersRentals = "real_estate_agents_and_managers_rentals"
                        case recordStores = "record_stores"
                        case recreationalVehicleRentals = "recreational_vehicle_rentals"
                        case religiousGoodsStores = "religious_goods_stores"
                        case religiousOrganizations = "religious_organizations"
                        case roofingSidingSheetMetal = "roofing_siding_sheet_metal"
                        case secretarialSupportServices = "secretarial_support_services"
                        case securityBrokersDealers = "security_brokers_dealers"
                        case serviceStations = "service_stations"
                        case sewingNeedleworkFabricAndPieceGoodsStores = "sewing_needlework_fabric_and_piece_goods_stores"
                        case shoeRepairHatCleaning = "shoe_repair_hat_cleaning"
                        case shoeStores = "shoe_stores"
                        case smallApplianceRepair = "small_appliance_repair"
                        case snowmobileDealers = "snowmobile_dealers"
                        case specialTradeServices = "special_trade_services"
                        case specialtyCleaning = "specialty_cleaning"
                        case sportingGoodsStores = "sporting_goods_stores"
                        case sportingRecreationCamps = "sporting_recreation_camps"
                        case sportsAndRidingApparelStores = "sports_and_riding_apparel_stores"
                        case sportsClubsFields = "sports_clubs_fields"
                        case stampAndCoinStores = "stamp_and_coin_stores"
                        case stationaryOfficeSuppliesPrintingAndWritingPaper = "stationary_office_supplies_printing_and_writing_paper"
                        case stationeryStoresOfficeAndSchoolSupplyStores = "stationery_stores_office_and_school_supply_stores"
                        case swimmingPoolsSales = "swimming_pools_sales"
                        case tUiTravelGermany = "t_ui_travel_germany"
                        case tailorsAlterations = "tailors_alterations"
                        case taxPaymentsGovernmentAgencies = "tax_payments_government_agencies"
                        case taxPreparationServices = "tax_preparation_services"
                        case taxicabsLimousines = "taxicabs_limousines"
                        case telecommunicationEquipmentAndTelephoneSales = "telecommunication_equipment_and_telephone_sales"
                        case telecommunicationServices = "telecommunication_services"
                        case telegraphServices = "telegraph_services"
                        case tentAndAwningShops = "tent_and_awning_shops"
                        case testingLaboratories = "testing_laboratories"
                        case theatricalTicketAgencies = "theatrical_ticket_agencies"
                        case timeshares
                        case tireRetreadingAndRepair = "tire_retreading_and_repair"
                        case tollsBridgeFees = "tolls_bridge_fees"
                        case touristAttractionsAndExhibits = "tourist_attractions_and_exhibits"
                        case towingServices = "towing_services"
                        case trailerParksCampgrounds = "trailer_parks_campgrounds"
                        case transportationServices = "transportation_services"
                        case travelAgenciesTourOperators = "travel_agencies_tour_operators"
                        case truckStopIteration = "truck_stop_iteration"
                        case truckUtilityTrailerRentals = "truck_utility_trailer_rentals"
                        case typesettingPlateMakingAndRelatedServices = "typesetting_plate_making_and_related_services"
                        case typewriterStores = "typewriter_stores"
                        case uSFederalGovernmentAgenciesOrDepartments = "u_s_federal_government_agencies_or_departments"
                        case uniformsCommercialClothing = "uniforms_commercial_clothing"
                        case usedMerchandiseAndSecondhandStores = "used_merchandise_and_secondhand_stores"
                        case utilities
                        case varietyStores = "variety_stores"
                        case veterinaryServices = "veterinary_services"
                        case videoAmusementGameSupplies = "video_amusement_game_supplies"
                        case videoGameArcades = "video_game_arcades"
                        case videoTapeRentalStores = "video_tape_rental_stores"
                        case vocationalTradeSchools = "vocational_trade_schools"
                        case watchJewelryRepair = "watch_jewelry_repair"
                        case weldingRepair = "welding_repair"
                        case wholesaleClubs = "wholesale_clubs"
                        case wigAndToupeeStores = "wig_and_toupee_stores"
                        case wiresMoneyOrders = "wires_money_orders"
                        case womensAccessoryAndSpecialtyShops = "womens_accessory_and_specialty_shops"
                        case womensReadyToWearStores = "womens_ready_to_wear_stores"
                        case wreckingAndSalvageYards = "wrecking_and_salvage_yards"
                    }

                    public enum Interval: String, Codable, CaseIterable {
                        case allTime = "all_time"
                        case daily
                        case monthly
                        case perAuthorization = "per_authorization"
                        case weekly
                        case yearly
                    }

                    public init(amount: Int, categories: [Category]? = nil, interval: Interval) {
                        self.amount = amount
                        self.categories = categories
                        self.interval = interval
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amount, forKey: "amount")
                        encoder.encode(categories, forKey: "categories")
                        encoder.encode(interval, forKey: "interval")
                        return encoder.items
                    }
                }

                public init(allowedCategories: [AllowedCategory]? = nil, blockedCategories: [BlockedCategory]? = nil, spendingLimits: [SpendingLimit]? = nil) {
                    self.allowedCategories = allowedCategories
                    self.blockedCategories = blockedCategories
                    self.spendingLimits = spendingLimits
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(allowedCategories, forKey: "allowed_categories")
                    encoder.encode(blockedCategories, forKey: "blocked_categories")
                    encoder.encode(spendingLimits, forKey: "spending_limits")
                    return encoder.items
                }
            }

            /// Dictates whether authorizations can be approved on this card. If this card is being canceled because it was lost or stolen, this information should be provided as `cancellation_reason`.
            public enum Status: String, Codable, CaseIterable {
                case active
                case canceled
                case inactive
            }

            public init(cancellationReason: CancellationReason? = nil, expand: [String]? = nil, metadata: Metadata? = nil, spendingControls: SpendingControls? = nil, status: Status? = nil) {
                self.cancellationReason = cancellationReason
                self.expand = expand
                self.metadata = metadata
                self.spendingControls = spendingControls
                self.status = status
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(cancellationReason, forKey: "cancellation_reason")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(spendingControls, forKey: "spending_controls")
                encoder.encode(status, forKey: "status")
                return encoder.items
            }
        }
    }
}

extension Paths.Issuing {
    public var disputes: Disputes {
        Disputes(path: path + "/disputes")
    }

    public struct Disputes {
        /// Path: `/v1/issuing/disputes`
        public let path: String

        /// <p>Returns a list of Issuing <code>Dispute</code> objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// IssuingDisputeList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.IssuingDispute]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.IssuingDispute], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?
            public var status: Status?
            public var transaction: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public enum Status: String, Codable, CaseIterable {
                case expired
                case lost
                case submitted
                case unsubmitted
                case won
            }

            public init(created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil, status: Status? = nil, transaction: String? = nil) {
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
                self.status = status
                self.transaction = transaction
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(status, forKey: "status")
                encoder.encode(transaction, forKey: "transaction")
                return encoder.items
            }
        }

        /// <p>Creates an Issuing <code>Dispute</code> object. Individual pieces of evidence within the <code>evidence</code> object are optional at this point. Stripe only validates that required evidence is present during submission. Refer to <a href="/docs/issuing/purchases/disputes#dispute-reasons-and-evidence">Dispute reasons and evidence</a> for more details about evidence requirements.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.IssuingDispute> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Evidence_param
            ///
            /// Evidence provided for the dispute.
            public var evidence: Evidence?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// The ID of the issuing transaction to create a dispute for.
            public var transaction: String

            /// Evidence_param
            ///
            /// Evidence provided for the dispute.
            public struct Evidence: Encodable {
                public var canceled: Canceled?
                public var duplicate: Duplicate?
                public var fraudulent: Fraudulent?
                public var merchandiseNotAsDescribed: MerchandiseNotAsDescribed?
                public var notReceived: NotReceived?
                public var other: Other?
                public var reason: Reason?
                public var serviceNotAsDescribed: ServiceNotAsDescribed?

                public struct Canceled: Encodable {
                    /// Canceled
                    public var a: A?
                    public var b: B?

                    /// Canceled
                    public struct A: Encodable {
                        public var additionalDocumentation: AdditionalDocumentation?
                        public var canceledAt: CanceledAt?
                        public var cancellationPolicyProvided: CancellationPolicyProvided?
                        public var cancellationReason: String?
                        public var expectedAt: ExpectedAt?
                        public var explanation: String?
                        public var productDescription: String?
                        public var productType: ProductType?
                        public var returnStatus: ReturnStatus?
                        public var returnedAt: ReturnedAt?

                        public struct AdditionalDocumentation: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public struct CanceledAt: Encodable {
                            public var int: Int?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(int: Int? = nil, object: Object? = nil) {
                                self.int = int
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(int, forKey: "int")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public struct CancellationPolicyProvided: Encodable {
                            public var isBool: Bool?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(isBool: Bool? = nil, object: Object? = nil) {
                                self.isBool = isBool
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(isBool, forKey: "bool")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public struct ExpectedAt: Encodable {
                            public var int: Int?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(int: Int? = nil, object: Object? = nil) {
                                self.int = int
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(int, forKey: "int")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public enum ProductType: String, Codable, CaseIterable {
                            case empty = ""
                            case merchandise
                            case service
                        }

                        public enum ReturnStatus: String, Codable, CaseIterable {
                            case empty = ""
                            case merchantRejected = "merchant_rejected"
                            case successful
                        }

                        public struct ReturnedAt: Encodable {
                            public var int: Int?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(int: Int? = nil, object: Object? = nil) {
                                self.int = int
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(int, forKey: "int")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public init(additionalDocumentation: AdditionalDocumentation? = nil, canceledAt: CanceledAt? = nil, cancellationPolicyProvided: CancellationPolicyProvided? = nil, cancellationReason: String? = nil, expectedAt: ExpectedAt? = nil, explanation: String? = nil, productDescription: String? = nil, productType: ProductType? = nil, returnStatus: ReturnStatus? = nil, returnedAt: ReturnedAt? = nil) {
                            self.additionalDocumentation = additionalDocumentation
                            self.canceledAt = canceledAt
                            self.cancellationPolicyProvided = cancellationPolicyProvided
                            self.cancellationReason = cancellationReason
                            self.expectedAt = expectedAt
                            self.explanation = explanation
                            self.productDescription = productDescription
                            self.productType = productType
                            self.returnStatus = returnStatus
                            self.returnedAt = returnedAt
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(additionalDocumentation, forKey: "additional_documentation")
                            encoder.encode(canceledAt, forKey: "canceled_at")
                            encoder.encode(cancellationPolicyProvided, forKey: "cancellation_policy_provided")
                            encoder.encode(cancellationReason, forKey: "cancellation_reason")
                            encoder.encode(expectedAt, forKey: "expected_at")
                            encoder.encode(explanation, forKey: "explanation")
                            encoder.encode(productDescription, forKey: "product_description")
                            encoder.encode(productType, forKey: "product_type")
                            encoder.encode(returnStatus, forKey: "return_status")
                            encoder.encode(returnedAt, forKey: "returned_at")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Duplicate: Encodable {
                    /// Duplicate
                    public var a: A?
                    public var b: B?

                    /// Duplicate
                    public struct A: Encodable {
                        public var additionalDocumentation: AdditionalDocumentation?
                        public var cardStatement: CardStatement?
                        public var cashReceipt: CashReceipt?
                        public var checkImage: CheckImage?
                        public var explanation: String?
                        public var originalTransaction: String?

                        public struct AdditionalDocumentation: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public struct CardStatement: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public struct CashReceipt: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public struct CheckImage: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public init(additionalDocumentation: AdditionalDocumentation? = nil, cardStatement: CardStatement? = nil, cashReceipt: CashReceipt? = nil, checkImage: CheckImage? = nil, explanation: String? = nil, originalTransaction: String? = nil) {
                            self.additionalDocumentation = additionalDocumentation
                            self.cardStatement = cardStatement
                            self.cashReceipt = cashReceipt
                            self.checkImage = checkImage
                            self.explanation = explanation
                            self.originalTransaction = originalTransaction
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(additionalDocumentation, forKey: "additional_documentation")
                            encoder.encode(cardStatement, forKey: "card_statement")
                            encoder.encode(cashReceipt, forKey: "cash_receipt")
                            encoder.encode(checkImage, forKey: "check_image")
                            encoder.encode(explanation, forKey: "explanation")
                            encoder.encode(originalTransaction, forKey: "original_transaction")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Fraudulent: Encodable {
                    /// Fraudulent
                    public var a: A?
                    public var b: B?

                    /// Fraudulent
                    public struct A: Encodable {
                        public var additionalDocumentation: AdditionalDocumentation?
                        public var explanation: String?

                        public struct AdditionalDocumentation: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public init(additionalDocumentation: AdditionalDocumentation? = nil, explanation: String? = nil) {
                            self.additionalDocumentation = additionalDocumentation
                            self.explanation = explanation
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(additionalDocumentation, forKey: "additional_documentation")
                            encoder.encode(explanation, forKey: "explanation")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct MerchandiseNotAsDescribed: Encodable {
                    /// Merchandise_not_as_described
                    public var a: A?
                    public var b: B?

                    /// Merchandise_not_as_described
                    public struct A: Encodable {
                        public var additionalDocumentation: AdditionalDocumentation?
                        public var explanation: String?
                        public var receivedAt: ReceivedAt?
                        public var returnDescription: String?
                        public var returnStatus: ReturnStatus?
                        public var returnedAt: ReturnedAt?

                        public struct AdditionalDocumentation: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public struct ReceivedAt: Encodable {
                            public var int: Int?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(int: Int? = nil, object: Object? = nil) {
                                self.int = int
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(int, forKey: "int")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public enum ReturnStatus: String, Codable, CaseIterable {
                            case empty = ""
                            case merchantRejected = "merchant_rejected"
                            case successful
                        }

                        public struct ReturnedAt: Encodable {
                            public var int: Int?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(int: Int? = nil, object: Object? = nil) {
                                self.int = int
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(int, forKey: "int")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public init(additionalDocumentation: AdditionalDocumentation? = nil, explanation: String? = nil, receivedAt: ReceivedAt? = nil, returnDescription: String? = nil, returnStatus: ReturnStatus? = nil, returnedAt: ReturnedAt? = nil) {
                            self.additionalDocumentation = additionalDocumentation
                            self.explanation = explanation
                            self.receivedAt = receivedAt
                            self.returnDescription = returnDescription
                            self.returnStatus = returnStatus
                            self.returnedAt = returnedAt
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(additionalDocumentation, forKey: "additional_documentation")
                            encoder.encode(explanation, forKey: "explanation")
                            encoder.encode(receivedAt, forKey: "received_at")
                            encoder.encode(returnDescription, forKey: "return_description")
                            encoder.encode(returnStatus, forKey: "return_status")
                            encoder.encode(returnedAt, forKey: "returned_at")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct NotReceived: Encodable {
                    /// Not_received
                    public var a: A?
                    public var b: B?

                    /// Not_received
                    public struct A: Encodable {
                        public var additionalDocumentation: AdditionalDocumentation?
                        public var expectedAt: ExpectedAt?
                        public var explanation: String?
                        public var productDescription: String?
                        public var productType: ProductType?

                        public struct AdditionalDocumentation: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public struct ExpectedAt: Encodable {
                            public var int: Int?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(int: Int? = nil, object: Object? = nil) {
                                self.int = int
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(int, forKey: "int")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public enum ProductType: String, Codable, CaseIterable {
                            case empty = ""
                            case merchandise
                            case service
                        }

                        public init(additionalDocumentation: AdditionalDocumentation? = nil, expectedAt: ExpectedAt? = nil, explanation: String? = nil, productDescription: String? = nil, productType: ProductType? = nil) {
                            self.additionalDocumentation = additionalDocumentation
                            self.expectedAt = expectedAt
                            self.explanation = explanation
                            self.productDescription = productDescription
                            self.productType = productType
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(additionalDocumentation, forKey: "additional_documentation")
                            encoder.encode(expectedAt, forKey: "expected_at")
                            encoder.encode(explanation, forKey: "explanation")
                            encoder.encode(productDescription, forKey: "product_description")
                            encoder.encode(productType, forKey: "product_type")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Other: Encodable {
                    /// Other
                    public var a: A?
                    public var b: B?

                    /// Other
                    public struct A: Encodable {
                        public var additionalDocumentation: AdditionalDocumentation?
                        public var explanation: String?
                        public var productDescription: String?
                        public var productType: ProductType?

                        public struct AdditionalDocumentation: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public enum ProductType: String, Codable, CaseIterable {
                            case empty = ""
                            case merchandise
                            case service
                        }

                        public init(additionalDocumentation: AdditionalDocumentation? = nil, explanation: String? = nil, productDescription: String? = nil, productType: ProductType? = nil) {
                            self.additionalDocumentation = additionalDocumentation
                            self.explanation = explanation
                            self.productDescription = productDescription
                            self.productType = productType
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(additionalDocumentation, forKey: "additional_documentation")
                            encoder.encode(explanation, forKey: "explanation")
                            encoder.encode(productDescription, forKey: "product_description")
                            encoder.encode(productType, forKey: "product_type")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public enum Reason: String, Codable, CaseIterable {
                    case canceled
                    case duplicate
                    case fraudulent
                    case merchandiseNotAsDescribed = "merchandise_not_as_described"
                    case notReceived = "not_received"
                    case other
                    case serviceNotAsDescribed = "service_not_as_described"
                }

                public struct ServiceNotAsDescribed: Encodable {
                    /// Service_not_as_described
                    public var a: A?
                    public var b: B?

                    /// Service_not_as_described
                    public struct A: Encodable {
                        public var additionalDocumentation: AdditionalDocumentation?
                        public var canceledAt: CanceledAt?
                        public var cancellationReason: String?
                        public var explanation: String?
                        public var receivedAt: ReceivedAt?

                        public struct AdditionalDocumentation: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public struct CanceledAt: Encodable {
                            public var int: Int?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(int: Int? = nil, object: Object? = nil) {
                                self.int = int
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(int, forKey: "int")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public struct ReceivedAt: Encodable {
                            public var int: Int?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(int: Int? = nil, object: Object? = nil) {
                                self.int = int
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(int, forKey: "int")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public init(additionalDocumentation: AdditionalDocumentation? = nil, canceledAt: CanceledAt? = nil, cancellationReason: String? = nil, explanation: String? = nil, receivedAt: ReceivedAt? = nil) {
                            self.additionalDocumentation = additionalDocumentation
                            self.canceledAt = canceledAt
                            self.cancellationReason = cancellationReason
                            self.explanation = explanation
                            self.receivedAt = receivedAt
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(additionalDocumentation, forKey: "additional_documentation")
                            encoder.encode(canceledAt, forKey: "canceled_at")
                            encoder.encode(cancellationReason, forKey: "cancellation_reason")
                            encoder.encode(explanation, forKey: "explanation")
                            encoder.encode(receivedAt, forKey: "received_at")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public init(canceled: Canceled? = nil, duplicate: Duplicate? = nil, fraudulent: Fraudulent? = nil, merchandiseNotAsDescribed: MerchandiseNotAsDescribed? = nil, notReceived: NotReceived? = nil, other: Other? = nil, reason: Reason? = nil, serviceNotAsDescribed: ServiceNotAsDescribed? = nil) {
                    self.canceled = canceled
                    self.duplicate = duplicate
                    self.fraudulent = fraudulent
                    self.merchandiseNotAsDescribed = merchandiseNotAsDescribed
                    self.notReceived = notReceived
                    self.other = other
                    self.reason = reason
                    self.serviceNotAsDescribed = serviceNotAsDescribed
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(canceled, forKey: "canceled")
                    encoder.encode(duplicate, forKey: "duplicate")
                    encoder.encode(fraudulent, forKey: "fraudulent")
                    encoder.encode(merchandiseNotAsDescribed, forKey: "merchandise_not_as_described")
                    encoder.encode(notReceived, forKey: "not_received")
                    encoder.encode(other, forKey: "other")
                    encoder.encode(reason, forKey: "reason")
                    encoder.encode(serviceNotAsDescribed, forKey: "service_not_as_described")
                    return encoder.items
                }
            }

            public init(evidence: Evidence? = nil, expand: [String]? = nil, metadata: [String: String]? = nil, transaction: String) {
                self.evidence = evidence
                self.expand = expand
                self.metadata = metadata
                self.transaction = transaction
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(evidence, forKey: "evidence")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(transaction, forKey: "transaction")
                return encoder.items
            }
        }
    }
}

extension Paths.Issuing.Disputes {
    public func dispute(_ dispute: String) -> WithDispute {
        WithDispute(path: "\(path)/\(dispute)")
    }

    public struct WithDispute {
        /// Path: `/v1/issuing/disputes/{dispute}`
        public let path: String

        /// <p>Retrieves an Issuing <code>Dispute</code> object.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.IssuingDispute> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the specified Issuing <code>Dispute</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged. Properties on the <code>evidence</code> object can be unset by passing in an empty string.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.IssuingDispute> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Evidence_param
            ///
            /// Evidence provided for the dispute.
            public var evidence: Evidence?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?

            /// Evidence_param
            ///
            /// Evidence provided for the dispute.
            public struct Evidence: Encodable {
                public var canceled: Canceled?
                public var duplicate: Duplicate?
                public var fraudulent: Fraudulent?
                public var merchandiseNotAsDescribed: MerchandiseNotAsDescribed?
                public var notReceived: NotReceived?
                public var other: Other?
                public var reason: Reason?
                public var serviceNotAsDescribed: ServiceNotAsDescribed?

                public struct Canceled: Encodable {
                    /// Canceled
                    public var a: A?
                    public var b: B?

                    /// Canceled
                    public struct A: Encodable {
                        public var additionalDocumentation: AdditionalDocumentation?
                        public var canceledAt: CanceledAt?
                        public var cancellationPolicyProvided: CancellationPolicyProvided?
                        public var cancellationReason: String?
                        public var expectedAt: ExpectedAt?
                        public var explanation: String?
                        public var productDescription: String?
                        public var productType: ProductType?
                        public var returnStatus: ReturnStatus?
                        public var returnedAt: ReturnedAt?

                        public struct AdditionalDocumentation: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public struct CanceledAt: Encodable {
                            public var int: Int?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(int: Int? = nil, object: Object? = nil) {
                                self.int = int
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(int, forKey: "int")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public struct CancellationPolicyProvided: Encodable {
                            public var isBool: Bool?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(isBool: Bool? = nil, object: Object? = nil) {
                                self.isBool = isBool
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(isBool, forKey: "bool")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public struct ExpectedAt: Encodable {
                            public var int: Int?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(int: Int? = nil, object: Object? = nil) {
                                self.int = int
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(int, forKey: "int")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public enum ProductType: String, Codable, CaseIterable {
                            case empty = ""
                            case merchandise
                            case service
                        }

                        public enum ReturnStatus: String, Codable, CaseIterable {
                            case empty = ""
                            case merchantRejected = "merchant_rejected"
                            case successful
                        }

                        public struct ReturnedAt: Encodable {
                            public var int: Int?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(int: Int? = nil, object: Object? = nil) {
                                self.int = int
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(int, forKey: "int")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public init(additionalDocumentation: AdditionalDocumentation? = nil, canceledAt: CanceledAt? = nil, cancellationPolicyProvided: CancellationPolicyProvided? = nil, cancellationReason: String? = nil, expectedAt: ExpectedAt? = nil, explanation: String? = nil, productDescription: String? = nil, productType: ProductType? = nil, returnStatus: ReturnStatus? = nil, returnedAt: ReturnedAt? = nil) {
                            self.additionalDocumentation = additionalDocumentation
                            self.canceledAt = canceledAt
                            self.cancellationPolicyProvided = cancellationPolicyProvided
                            self.cancellationReason = cancellationReason
                            self.expectedAt = expectedAt
                            self.explanation = explanation
                            self.productDescription = productDescription
                            self.productType = productType
                            self.returnStatus = returnStatus
                            self.returnedAt = returnedAt
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(additionalDocumentation, forKey: "additional_documentation")
                            encoder.encode(canceledAt, forKey: "canceled_at")
                            encoder.encode(cancellationPolicyProvided, forKey: "cancellation_policy_provided")
                            encoder.encode(cancellationReason, forKey: "cancellation_reason")
                            encoder.encode(expectedAt, forKey: "expected_at")
                            encoder.encode(explanation, forKey: "explanation")
                            encoder.encode(productDescription, forKey: "product_description")
                            encoder.encode(productType, forKey: "product_type")
                            encoder.encode(returnStatus, forKey: "return_status")
                            encoder.encode(returnedAt, forKey: "returned_at")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Duplicate: Encodable {
                    /// Duplicate
                    public var a: A?
                    public var b: B?

                    /// Duplicate
                    public struct A: Encodable {
                        public var additionalDocumentation: AdditionalDocumentation?
                        public var cardStatement: CardStatement?
                        public var cashReceipt: CashReceipt?
                        public var checkImage: CheckImage?
                        public var explanation: String?
                        public var originalTransaction: String?

                        public struct AdditionalDocumentation: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public struct CardStatement: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public struct CashReceipt: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public struct CheckImage: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public init(additionalDocumentation: AdditionalDocumentation? = nil, cardStatement: CardStatement? = nil, cashReceipt: CashReceipt? = nil, checkImage: CheckImage? = nil, explanation: String? = nil, originalTransaction: String? = nil) {
                            self.additionalDocumentation = additionalDocumentation
                            self.cardStatement = cardStatement
                            self.cashReceipt = cashReceipt
                            self.checkImage = checkImage
                            self.explanation = explanation
                            self.originalTransaction = originalTransaction
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(additionalDocumentation, forKey: "additional_documentation")
                            encoder.encode(cardStatement, forKey: "card_statement")
                            encoder.encode(cashReceipt, forKey: "cash_receipt")
                            encoder.encode(checkImage, forKey: "check_image")
                            encoder.encode(explanation, forKey: "explanation")
                            encoder.encode(originalTransaction, forKey: "original_transaction")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Fraudulent: Encodable {
                    /// Fraudulent
                    public var a: A?
                    public var b: B?

                    /// Fraudulent
                    public struct A: Encodable {
                        public var additionalDocumentation: AdditionalDocumentation?
                        public var explanation: String?

                        public struct AdditionalDocumentation: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public init(additionalDocumentation: AdditionalDocumentation? = nil, explanation: String? = nil) {
                            self.additionalDocumentation = additionalDocumentation
                            self.explanation = explanation
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(additionalDocumentation, forKey: "additional_documentation")
                            encoder.encode(explanation, forKey: "explanation")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct MerchandiseNotAsDescribed: Encodable {
                    /// Merchandise_not_as_described
                    public var a: A?
                    public var b: B?

                    /// Merchandise_not_as_described
                    public struct A: Encodable {
                        public var additionalDocumentation: AdditionalDocumentation?
                        public var explanation: String?
                        public var receivedAt: ReceivedAt?
                        public var returnDescription: String?
                        public var returnStatus: ReturnStatus?
                        public var returnedAt: ReturnedAt?

                        public struct AdditionalDocumentation: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public struct ReceivedAt: Encodable {
                            public var int: Int?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(int: Int? = nil, object: Object? = nil) {
                                self.int = int
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(int, forKey: "int")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public enum ReturnStatus: String, Codable, CaseIterable {
                            case empty = ""
                            case merchantRejected = "merchant_rejected"
                            case successful
                        }

                        public struct ReturnedAt: Encodable {
                            public var int: Int?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(int: Int? = nil, object: Object? = nil) {
                                self.int = int
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(int, forKey: "int")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public init(additionalDocumentation: AdditionalDocumentation? = nil, explanation: String? = nil, receivedAt: ReceivedAt? = nil, returnDescription: String? = nil, returnStatus: ReturnStatus? = nil, returnedAt: ReturnedAt? = nil) {
                            self.additionalDocumentation = additionalDocumentation
                            self.explanation = explanation
                            self.receivedAt = receivedAt
                            self.returnDescription = returnDescription
                            self.returnStatus = returnStatus
                            self.returnedAt = returnedAt
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(additionalDocumentation, forKey: "additional_documentation")
                            encoder.encode(explanation, forKey: "explanation")
                            encoder.encode(receivedAt, forKey: "received_at")
                            encoder.encode(returnDescription, forKey: "return_description")
                            encoder.encode(returnStatus, forKey: "return_status")
                            encoder.encode(returnedAt, forKey: "returned_at")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct NotReceived: Encodable {
                    /// Not_received
                    public var a: A?
                    public var b: B?

                    /// Not_received
                    public struct A: Encodable {
                        public var additionalDocumentation: AdditionalDocumentation?
                        public var expectedAt: ExpectedAt?
                        public var explanation: String?
                        public var productDescription: String?
                        public var productType: ProductType?

                        public struct AdditionalDocumentation: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public struct ExpectedAt: Encodable {
                            public var int: Int?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(int: Int? = nil, object: Object? = nil) {
                                self.int = int
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(int, forKey: "int")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public enum ProductType: String, Codable, CaseIterable {
                            case empty = ""
                            case merchandise
                            case service
                        }

                        public init(additionalDocumentation: AdditionalDocumentation? = nil, expectedAt: ExpectedAt? = nil, explanation: String? = nil, productDescription: String? = nil, productType: ProductType? = nil) {
                            self.additionalDocumentation = additionalDocumentation
                            self.expectedAt = expectedAt
                            self.explanation = explanation
                            self.productDescription = productDescription
                            self.productType = productType
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(additionalDocumentation, forKey: "additional_documentation")
                            encoder.encode(expectedAt, forKey: "expected_at")
                            encoder.encode(explanation, forKey: "explanation")
                            encoder.encode(productDescription, forKey: "product_description")
                            encoder.encode(productType, forKey: "product_type")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Other: Encodable {
                    /// Other
                    public var a: A?
                    public var b: B?

                    /// Other
                    public struct A: Encodable {
                        public var additionalDocumentation: AdditionalDocumentation?
                        public var explanation: String?
                        public var productDescription: String?
                        public var productType: ProductType?

                        public struct AdditionalDocumentation: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public enum ProductType: String, Codable, CaseIterable {
                            case empty = ""
                            case merchandise
                            case service
                        }

                        public init(additionalDocumentation: AdditionalDocumentation? = nil, explanation: String? = nil, productDescription: String? = nil, productType: ProductType? = nil) {
                            self.additionalDocumentation = additionalDocumentation
                            self.explanation = explanation
                            self.productDescription = productDescription
                            self.productType = productType
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(additionalDocumentation, forKey: "additional_documentation")
                            encoder.encode(explanation, forKey: "explanation")
                            encoder.encode(productDescription, forKey: "product_description")
                            encoder.encode(productType, forKey: "product_type")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public enum Reason: String, Codable, CaseIterable {
                    case canceled
                    case duplicate
                    case fraudulent
                    case merchandiseNotAsDescribed = "merchandise_not_as_described"
                    case notReceived = "not_received"
                    case other
                    case serviceNotAsDescribed = "service_not_as_described"
                }

                public struct ServiceNotAsDescribed: Encodable {
                    /// Service_not_as_described
                    public var a: A?
                    public var b: B?

                    /// Service_not_as_described
                    public struct A: Encodable {
                        public var additionalDocumentation: AdditionalDocumentation?
                        public var canceledAt: CanceledAt?
                        public var cancellationReason: String?
                        public var explanation: String?
                        public var receivedAt: ReceivedAt?

                        public struct AdditionalDocumentation: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public struct CanceledAt: Encodable {
                            public var int: Int?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(int: Int? = nil, object: Object? = nil) {
                                self.int = int
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(int, forKey: "int")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public struct ReceivedAt: Encodable {
                            public var int: Int?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(int: Int? = nil, object: Object? = nil) {
                                self.int = int
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(int, forKey: "int")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public init(additionalDocumentation: AdditionalDocumentation? = nil, canceledAt: CanceledAt? = nil, cancellationReason: String? = nil, explanation: String? = nil, receivedAt: ReceivedAt? = nil) {
                            self.additionalDocumentation = additionalDocumentation
                            self.canceledAt = canceledAt
                            self.cancellationReason = cancellationReason
                            self.explanation = explanation
                            self.receivedAt = receivedAt
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(additionalDocumentation, forKey: "additional_documentation")
                            encoder.encode(canceledAt, forKey: "canceled_at")
                            encoder.encode(cancellationReason, forKey: "cancellation_reason")
                            encoder.encode(explanation, forKey: "explanation")
                            encoder.encode(receivedAt, forKey: "received_at")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public init(canceled: Canceled? = nil, duplicate: Duplicate? = nil, fraudulent: Fraudulent? = nil, merchandiseNotAsDescribed: MerchandiseNotAsDescribed? = nil, notReceived: NotReceived? = nil, other: Other? = nil, reason: Reason? = nil, serviceNotAsDescribed: ServiceNotAsDescribed? = nil) {
                    self.canceled = canceled
                    self.duplicate = duplicate
                    self.fraudulent = fraudulent
                    self.merchandiseNotAsDescribed = merchandiseNotAsDescribed
                    self.notReceived = notReceived
                    self.other = other
                    self.reason = reason
                    self.serviceNotAsDescribed = serviceNotAsDescribed
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(canceled, forKey: "canceled")
                    encoder.encode(duplicate, forKey: "duplicate")
                    encoder.encode(fraudulent, forKey: "fraudulent")
                    encoder.encode(merchandiseNotAsDescribed, forKey: "merchandise_not_as_described")
                    encoder.encode(notReceived, forKey: "not_received")
                    encoder.encode(other, forKey: "other")
                    encoder.encode(reason, forKey: "reason")
                    encoder.encode(serviceNotAsDescribed, forKey: "service_not_as_described")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(evidence: Evidence? = nil, expand: [String]? = nil, metadata: Metadata? = nil) {
                self.evidence = evidence
                self.expand = expand
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(evidence, forKey: "evidence")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths.Issuing.Disputes.WithDispute {
    public var submit: Submit {
        Submit(path: path + "/submit")
    }

    public struct Submit {
        /// Path: `/v1/issuing/disputes/{dispute}/submit`
        public let path: String

        /// <p>Submits an Issuing <code>Dispute</code> to the card network. Stripe validates that all evidence fields required for the dispute’s reason are present. For more details, see <a href="/docs/issuing/purchases/disputes#dispute-reasons-and-evidence">Dispute reasons and evidence</a>.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.IssuingDispute> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(expand: [String]? = nil, metadata: Metadata? = nil) {
                self.expand = expand
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths.Issuing {
    public var settlements: Settlements {
        Settlements(path: path + "/settlements")
    }

    public struct Settlements {
        /// Path: `/v1/issuing/settlements`
        public let path: String

        /// <p>Returns a list of Issuing <code>Settlement</code> objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.IssuingSettlement]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.IssuingSettlement], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }
    }
}

extension Paths.Issuing.Settlements {
    public func settlement(_ settlement: String) -> WithSettlement {
        WithSettlement(path: "\(path)/\(settlement)")
    }

    public struct WithSettlement {
        /// Path: `/v1/issuing/settlements/{settlement}`
        public let path: String

        /// <p>Retrieves an Issuing <code>Settlement</code> object.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.IssuingSettlement> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the specified Issuing <code>Settlement</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.IssuingSettlement> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?

            public init(expand: [String]? = nil, metadata: [String: String]? = nil) {
                self.expand = expand
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths.Issuing {
    public var transactions: Transactions {
        Transactions(path: path + "/transactions")
    }

    public struct Transactions {
        /// Path: `/v1/issuing/transactions`
        public let path: String

        /// <p>Returns a list of Issuing <code>Transaction</code> objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.IssuingTransaction]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.IssuingTransaction], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var card: String?
            public var cardholder: String?
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?
            public var type: `Type`?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public enum `Type`: String, Codable, CaseIterable {
                case capture
                case refund
            }

            public init(card: String? = nil, cardholder: String? = nil, created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil, type: `Type`? = nil) {
                self.card = card
                self.cardholder = cardholder
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
                self.type = type
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(card, forKey: "card")
                encoder.encode(cardholder, forKey: "cardholder")
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(type, forKey: "type")
                return encoder.items
            }
        }
    }
}

extension Paths.Issuing.Transactions {
    public func transaction(_ transaction: String) -> WithTransaction {
        WithTransaction(path: "\(path)/\(transaction)")
    }

    public struct WithTransaction {
        /// Path: `/v1/issuing/transactions/{transaction}`
        public let path: String

        /// <p>Retrieves an Issuing <code>Transaction</code> object.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.IssuingTransaction> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the specified Issuing <code>Transaction</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.IssuingTransaction> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(expand: [String]? = nil, metadata: Metadata? = nil) {
                self.expand = expand
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var mandates: Mandates {
        Mandates(path: "/v1/mandates")
    }

    public struct Mandates {
        /// Path: `/v1/mandates`
        public let path: String
    }
}

extension Paths.Mandates {
    public func mandate(_ mandate: String) -> WithMandate {
        WithMandate(path: "\(path)/\(mandate)")
    }

    public struct WithMandate {
        /// Path: `/v1/mandates/{mandate}`
        public let path: String

        /// <p>Retrieves a Mandate object.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Mandate> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths {
    public static var orderReturns: OrderReturns {
        OrderReturns(path: "/v1/order_returns")
    }

    public struct OrderReturns {
        /// Path: `/v1/order_returns`
        public let path: String

        /// <p>Returns a list of your order returns. The returns are returned sorted by creation date, with the most recently created return appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.OrderReturn]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.OrderReturn], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var order: String?
            public var startingAfter: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, order: String? = nil, startingAfter: String? = nil) {
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.order = order
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(order, forKey: "order")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }
    }
}

extension Paths.OrderReturns {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/order_returns/{id}`
        public let path: String

        /// <p>Retrieves the details of an existing order return. Supply the unique order ID from either an order return creation request or the order return list, and Stripe will return the corresponding order information.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.OrderReturn> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths {
    public static var orders: Orders {
        Orders(path: "/v1/orders")
    }

    public struct Orders {
        /// Path: `/v1/orders`
        public let path: String

        /// <p>Returns a list of your orders. The orders are returned sorted by creation date, with the most recently created orders appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// OrdersLegacyResourceOrderList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Order]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Order], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var customer: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var ids: [String]?
            public var limit: Int?
            public var startingAfter: String?
            public var status: String?
            /// Order_timestamp_specs
            public var statusTransitions: StatusTransitions?
            public var upstreamIDs: [String]?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            /// Order_timestamp_specs
            public struct StatusTransitions: Codable {
                public var canceled: Canceled?
                public var fulfilled: Fulfilled?
                public var paid: Paid?
                public var returned: Returned?

                public struct Canceled: Codable {
                    /// Range_query_specs
                    public var object: Object?
                    public var int: Int?

                    /// Range_query_specs
                    public struct Object: Codable {
                        public var gt: Int?
                        public var gte: Int?
                        public var lt: Int?
                        public var lte: Int?

                        public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                            self.gt = gt
                            self.gte = gte
                            self.lt = lt
                            self.lte = lte
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(gt, forKey: "gt")
                            encoder.encode(gte, forKey: "gte")
                            encoder.encode(lt, forKey: "lt")
                            encoder.encode(lte, forKey: "lte")
                            return encoder.items
                        }
                    }

                    public init(object: Object? = nil, int: Int? = nil) {
                        self.object = object
                        self.int = int
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object, forKey: "object")
                        encoder.encode(int, forKey: "int")
                        return encoder.items
                    }
                }

                public struct Fulfilled: Codable {
                    /// Range_query_specs
                    public var object: Object?
                    public var int: Int?

                    /// Range_query_specs
                    public struct Object: Codable {
                        public var gt: Int?
                        public var gte: Int?
                        public var lt: Int?
                        public var lte: Int?

                        public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                            self.gt = gt
                            self.gte = gte
                            self.lt = lt
                            self.lte = lte
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(gt, forKey: "gt")
                            encoder.encode(gte, forKey: "gte")
                            encoder.encode(lt, forKey: "lt")
                            encoder.encode(lte, forKey: "lte")
                            return encoder.items
                        }
                    }

                    public init(object: Object? = nil, int: Int? = nil) {
                        self.object = object
                        self.int = int
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object, forKey: "object")
                        encoder.encode(int, forKey: "int")
                        return encoder.items
                    }
                }

                public struct Paid: Codable {
                    /// Range_query_specs
                    public var object: Object?
                    public var int: Int?

                    /// Range_query_specs
                    public struct Object: Codable {
                        public var gt: Int?
                        public var gte: Int?
                        public var lt: Int?
                        public var lte: Int?

                        public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                            self.gt = gt
                            self.gte = gte
                            self.lt = lt
                            self.lte = lte
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(gt, forKey: "gt")
                            encoder.encode(gte, forKey: "gte")
                            encoder.encode(lt, forKey: "lt")
                            encoder.encode(lte, forKey: "lte")
                            return encoder.items
                        }
                    }

                    public init(object: Object? = nil, int: Int? = nil) {
                        self.object = object
                        self.int = int
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object, forKey: "object")
                        encoder.encode(int, forKey: "int")
                        return encoder.items
                    }
                }

                public struct Returned: Codable {
                    /// Range_query_specs
                    public var object: Object?
                    public var int: Int?

                    /// Range_query_specs
                    public struct Object: Codable {
                        public var gt: Int?
                        public var gte: Int?
                        public var lt: Int?
                        public var lte: Int?

                        public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                            self.gt = gt
                            self.gte = gte
                            self.lt = lt
                            self.lte = lte
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(gt, forKey: "gt")
                            encoder.encode(gte, forKey: "gte")
                            encoder.encode(lt, forKey: "lt")
                            encoder.encode(lte, forKey: "lte")
                            return encoder.items
                        }
                    }

                    public init(object: Object? = nil, int: Int? = nil) {
                        self.object = object
                        self.int = int
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object, forKey: "object")
                        encoder.encode(int, forKey: "int")
                        return encoder.items
                    }
                }

                public init(canceled: Canceled? = nil, fulfilled: Fulfilled? = nil, paid: Paid? = nil, returned: Returned? = nil) {
                    self.canceled = canceled
                    self.fulfilled = fulfilled
                    self.paid = paid
                    self.returned = returned
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(canceled, forKey: "canceled")
                    encoder.encode(fulfilled, forKey: "fulfilled")
                    encoder.encode(paid, forKey: "paid")
                    encoder.encode(returned, forKey: "returned")
                    return encoder.items
                }
            }

            public init(created: Created? = nil, customer: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, ids: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil, status: String? = nil, statusTransitions: StatusTransitions? = nil, upstreamIDs: [String]? = nil) {
                self.created = created
                self.customer = customer
                self.endingBefore = endingBefore
                self.expand = expand
                self.ids = ids
                self.limit = limit
                self.startingAfter = startingAfter
                self.status = status
                self.statusTransitions = statusTransitions
                self.upstreamIDs = upstreamIDs
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(customer, forKey: "customer")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(ids, forKey: "ids", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(status, forKey: "status")
                encoder.encode(statusTransitions, forKey: "status_transitions", isDeepObject: true)
                encoder.encode(upstreamIDs, forKey: "upstream_ids", isDeepObject: true)
                return encoder.items
            }
        }

        /// <p>Creates a new order object.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.Order> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// A coupon code that represents a discount to be applied to this order. Must be one-time duration and in same currency as the order. An order can have multiple coupons.
            public var coupon: String?
            /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
            public var currency: String
            /// The ID of an existing customer to use for this order. If provided, the customer email and shipping address will be used to create the order. Subsequently, the customer will also be charged to pay the order. If `email` or `shipping` are also provided, they will override the values retrieved from the customer object.
            public var customer: String?
            /// The email address of the customer placing the order.
            public var email: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// List of items constituting the order. An order can have up to 25 items.
            public var items: [Item]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// Customer_shipping
            ///
            /// Shipping address for the order. Required if any of the SKUs are for products that have `shippable` set to true.
            public var shipping: Shipping?

            /// Order_item_specs
            public struct Item: Encodable {
                public var amount: Int?
                public var currency: String?
                public var description: String?
                public var parent: String?
                public var quantity: Int?
                public var type: `Type`?

                public enum `Type`: String, Codable, CaseIterable {
                    case discount
                    case shipping
                    case sku
                    case tax
                }

                public init(amount: Int? = nil, currency: String? = nil, description: String? = nil, parent: String? = nil, quantity: Int? = nil, type: `Type`? = nil) {
                    self.amount = amount
                    self.currency = currency
                    self.description = description
                    self.parent = parent
                    self.quantity = quantity
                    self.type = type
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(amount, forKey: "amount")
                    encoder.encode(currency, forKey: "currency")
                    encoder.encode(description, forKey: "description")
                    encoder.encode(parent, forKey: "parent")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(type, forKey: "type")
                    return encoder.items
                }
            }

            /// Customer_shipping
            ///
            /// Shipping address for the order. Required if any of the SKUs are for products that have `shippable` set to true.
            public struct Shipping: Encodable {
                /// Optional_fields_address
                public var address: Address
                public var name: String
                public var phone: String?

                /// Optional_fields_address
                public struct Address: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                public init(address: Address, name: String, phone: String? = nil) {
                    self.address = address
                    self.name = name
                    self.phone = phone
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(name, forKey: "name")
                    encoder.encode(phone, forKey: "phone")
                    return encoder.items
                }
            }

            public init(coupon: String? = nil, currency: String, customer: String? = nil, email: String? = nil, expand: [String]? = nil, items: [Item]? = nil, metadata: [String: String]? = nil, shipping: Shipping? = nil) {
                self.coupon = coupon
                self.currency = currency
                self.customer = customer
                self.email = email
                self.expand = expand
                self.items = items
                self.metadata = metadata
                self.shipping = shipping
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(coupon, forKey: "coupon")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(email, forKey: "email")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(items, forKey: "items")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(shipping, forKey: "shipping")
                return encoder.items
            }
        }
    }
}

extension Paths.Orders {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/orders/{id}`
        public let path: String

        /// <p>Retrieves the details of an existing order. Supply the unique order ID from either an order creation request or the order list, and Stripe will return the corresponding order information.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Order> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the specific order by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Order> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// A coupon code that represents a discount to be applied to this order. Must be one-time duration and in same currency as the order. An order can have multiple coupons.
            public var coupon: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The shipping method to select for fulfilling this order. If specified, must be one of the `id`s of a shipping method in the `shipping_methods` array. If specified, will overwrite the existing selected shipping method, updating `items` as necessary.
            public var selectedShippingMethod: String?
            /// Shipping_tracking_params
            ///
            /// Tracking information once the order has been fulfilled.
            public var shipping: Shipping?
            /// Current order status. One of `created`, `paid`, `canceled`, `fulfilled`, or `returned`. More detail in the [Orders Guide](https://stripe.com/docs/orders/guide#understanding-order-statuses).
            public var status: Status?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Shipping_tracking_params
            ///
            /// Tracking information once the order has been fulfilled.
            public struct Shipping: Encodable {
                public var carrier: String
                public var trackingNumber: String

                public init(carrier: String, trackingNumber: String) {
                    self.carrier = carrier
                    self.trackingNumber = trackingNumber
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(carrier, forKey: "carrier")
                    encoder.encode(trackingNumber, forKey: "tracking_number")
                    return encoder.items
                }
            }

            /// Current order status. One of `created`, `paid`, `canceled`, `fulfilled`, or `returned`. More detail in the [Orders Guide](https://stripe.com/docs/orders/guide#understanding-order-statuses).
            public enum Status: String, Codable, CaseIterable {
                case canceled
                case created
                case fulfilled
                case paid
                case returned
            }

            public init(coupon: String? = nil, expand: [String]? = nil, metadata: Metadata? = nil, selectedShippingMethod: String? = nil, shipping: Shipping? = nil, status: Status? = nil) {
                self.coupon = coupon
                self.expand = expand
                self.metadata = metadata
                self.selectedShippingMethod = selectedShippingMethod
                self.shipping = shipping
                self.status = status
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(coupon, forKey: "coupon")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(selectedShippingMethod, forKey: "selected_shipping_method")
                encoder.encode(shipping, forKey: "shipping")
                encoder.encode(status, forKey: "status")
                return encoder.items
            }
        }
    }
}

extension Paths.Orders.WithID {
    public var pay: Pay {
        Pay(path: path + "/pay")
    }

    public struct Pay {
        /// Path: `/v1/orders/{id}/pay`
        public let path: String

        /// <p>Pay an order by providing a <code>source</code> to create a payment.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Order> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// A fee in %s that will be applied to the order and transferred to the application owner's Stripe account. The request must be made with an OAuth key or the `Stripe-Account` header in order to take an application fee. For more information, see the application fees [documentation](https://stripe.com/docs/connect/direct-charges#collecting-fees).
            public var applicationFee: Int?
            /// The ID of an existing customer that will be charged for this order. If no customer was attached to the order at creation, either `source` or `customer` is required. Otherwise, the specified customer will be charged instead of the one attached to the order.
            public var customer: String?
            /// The email address of the customer placing the order. Required if not previously specified for the order.
            public var email: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// A [Token](https://stripe.com/docs/api#tokens)'s or a [Source](https://stripe.com/docs/api#sources)'s ID, as returned by [Elements](https://stripe.com/docs/elements). If no customer was attached to the order at creation, either `source` or `customer` is required. Otherwise, the specified source will be charged intead of the customer attached to the order.
            public var source: String?

            public init(applicationFee: Int? = nil, customer: String? = nil, email: String? = nil, expand: [String]? = nil, metadata: [String: String]? = nil, source: String? = nil) {
                self.applicationFee = applicationFee
                self.customer = customer
                self.email = email
                self.expand = expand
                self.metadata = metadata
                self.source = source
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(applicationFee, forKey: "application_fee")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(email, forKey: "email")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(source, forKey: "source")
                return encoder.items
            }
        }
    }
}

extension Paths.Orders.WithID {
    public var returns: Returns {
        Returns(path: path + "/returns")
    }

    public struct Returns {
        /// Path: `/v1/orders/{id}/returns`
        public let path: String

        /// <p>Return all or part of an order. The order must have a status of <code>paid</code> or <code>fulfilled</code> before it can be returned. Once all items have been returned, the order will become <code>canceled</code> or <code>returned</code> depending on which status the order started in.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.OrderReturn> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// List of items to return.
            public var items: Items?

            /// List of items to return.
            public struct Items: Encodable {
                public var placeholderItems: [PlaceholderItem]?
                public var object: Object?

                /// Return_order_item_specs
                public struct PlaceholderItem: Encodable {
                    public var amount: Int?
                    public var description: String?
                    public var parent: String?
                    public var quantity: Int?
                    public var type: `Type`?

                    public enum `Type`: String, Codable, CaseIterable {
                        case discount
                        case shipping
                        case sku
                        case tax
                    }

                    public init(amount: Int? = nil, description: String? = nil, parent: String? = nil, quantity: Int? = nil, type: `Type`? = nil) {
                        self.amount = amount
                        self.description = description
                        self.parent = parent
                        self.quantity = quantity
                        self.type = type
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amount, forKey: "amount")
                        encoder.encode(description, forKey: "description")
                        encoder.encode(parent, forKey: "parent")
                        encoder.encode(quantity, forKey: "quantity")
                        encoder.encode(type, forKey: "type")
                        return encoder.items
                    }
                }

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                    self.placeholderItems = placeholderItems
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(placeholderItems, forKey: "placeholderItems")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(expand: [String]? = nil, items: Items? = nil) {
                self.expand = expand
                self.items = items
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(items, forKey: "items")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var paymentIntents: PaymentIntents {
        PaymentIntents(path: "/v1/payment_intents")
    }

    public struct PaymentIntents {
        /// Path: `/v1/payment_intents`
        public let path: String

        /// <p>Returns a list of PaymentIntents.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// PaymentFlowsPaymentIntentList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.PaymentIntent]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.PaymentIntent], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var customer: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(created: Created? = nil, customer: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.created = created
                self.customer = customer
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(customer, forKey: "customer")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates a PaymentIntent object.</p>
        /// 
        /// <p>After the PaymentIntent is created, attach a payment method and <a href="/docs/api/payment_intents/confirm">confirm</a>
        /// to continue the payment. You can read more about the different payment flows
        /// available via the Payment Intents API <a href="/docs/payments/payment-intents">here</a>.</p>
        /// 
        /// <p>When <code>confirm=true</code> is used during creation, it is equivalent to creating
        /// and confirming the PaymentIntent in the same call. You may use any parameters
        /// available in the <a href="/docs/api/payment_intents/confirm">confirm API</a> when <code>confirm=true</code>
        /// is supplied.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.PaymentIntent> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Amount intended to be collected by this PaymentIntent. A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum amount is $0.50 US or [equivalent in charge currency](https://stripe.com/docs/currencies#minimum-and-maximum-charge-amounts). The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of $999,999.99).
            public var amount: Int
            /// The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. The amount of the application fee collected will be capped at the total payment amount. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
            public var applicationFeeAmount: Int?
            /// Automatic_payment_methods_param
            ///
            /// When enabled, this PaymentIntent will accept payment methods that you have enabled in the Dashboard and are compatible with this PaymentIntent's other parameters.
            public var automaticPaymentMethods: AutomaticPaymentMethods?
            /// Controls when the funds will be captured from the customer's account.
            public var captureMethod: CaptureMethod?
            /// Set to `true` to attempt to [confirm](https://stripe.com/docs/api/payment_intents/confirm) this PaymentIntent immediately. This parameter defaults to `false`. When creating and confirming a PaymentIntent at the same time, parameters available in the [confirm](https://stripe.com/docs/api/payment_intents/confirm) API may also be provided.
            public var isConfirm: Bool?
            public var confirmationMethod: ConfirmationMethod?
            /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
            public var currency: String
            /// ID of the Customer this PaymentIntent belongs to, if one exists.
            /// 
            /// Payment methods attached to other Customers cannot be used with this PaymentIntent.
            /// 
            /// If present in combination with [setup_future_usage](https://stripe.com/docs/api#payment_intent_object-setup_future_usage), this PaymentIntent's payment method will be attached to the Customer after the PaymentIntent has been confirmed and any required actions from the user are complete.
            public var customer: String?
            /// An arbitrary string attached to the object. Often useful for displaying to users.
            public var description: String?
            /// Set to `true` to fail the payment attempt if the PaymentIntent transitions into `requires_action`. This parameter is intended for simpler integrations that do not handle customer actions, like [saving cards without authentication](https://stripe.com/docs/payments/save-card-without-authentication). This parameter can only be used with [`confirm=true`](https://stripe.com/docs/api/payment_intents/create#create_payment_intent-confirm).
            public var errorOnRequiresAction: Bool?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// ID of the mandate to be used for this payment. This parameter can only be used with [`confirm=true`](https://stripe.com/docs/api/payment_intents/create#create_payment_intent-confirm).
            public var mandate: String?
            /// Secret_key_param
            ///
            /// This hash contains details about the Mandate to create. This parameter can only be used with [`confirm=true`](https://stripe.com/docs/api/payment_intents/create#create_payment_intent-confirm).
            public var mandateData: MandateData?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// Set to `true` to indicate that the customer is not in your checkout flow during this payment attempt, and therefore is unable to authenticate. This parameter is intended for scenarios where you collect card details and [charge them later](https://stripe.com/docs/payments/cards/charging-saved-cards). This parameter can only be used with [`confirm=true`](https://stripe.com/docs/api/payment_intents/create#create_payment_intent-confirm).
            public var offSession: OffSession?
            /// The Stripe account ID for which these funds are intended. For details, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
            public var onBehalfOf: String?
            /// ID of the payment method (a PaymentMethod, Card, or [compatible Source](https://stripe.com/docs/payments/payment-methods/transitioning#compatibility) object) to attach to this PaymentIntent.
            /// 
            /// If this parameter is omitted with `confirm=true`, `customer.default_source` will be attached as this PaymentIntent's payment instrument to improve the migration experience for users of the Charges API. We recommend that you explicitly provide the `payment_method` going forward.
            public var paymentMethod: String?
            /// Payment_method_data_params
            ///
            /// If provided, this hash will be used to create a PaymentMethod. The new PaymentMethod will appear
            /// in the [payment_method](https://stripe.com/docs/api/payment_intents/object#payment_intent_object-payment_method)
            /// property on the PaymentIntent.
            public var paymentMethodData: PaymentMethodData?
            /// Payment_method_options_param
            ///
            /// Payment-method-specific configuration for this PaymentIntent.
            public var paymentMethodOptions: PaymentMethodOptions?
            /// The list of payment method types (e.g. card) that this PaymentIntent is allowed to use. If this is not provided, defaults to ["card"].
            public var paymentMethodTypes: [String]?
            /// Email address that the receipt for the resulting payment will be sent to. If `receipt_email` is specified for a payment in live mode, a receipt will be sent regardless of your [email settings](https://dashboard.stripe.com/account/emails).
            public var receiptEmail: String?
            /// The URL to redirect your customer back to after they authenticate or cancel their payment on the payment method's app or site. If you'd prefer to redirect to a mobile application, you can alternatively supply an application URI scheme. This parameter can only be used with [`confirm=true`](https://stripe.com/docs/api/payment_intents/create#create_payment_intent-confirm).
            public var returnURL: String?
            /// Indicates that you intend to make future payments with this PaymentIntent's payment method.
            /// 
            /// Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent's Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.
            /// 
            /// When processing card payments, Stripe also uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).
            public var setupFutureUsage: SetupFutureUsage?
            /// Optional_fields_shipping
            ///
            /// Shipping information for this PaymentIntent.
            public var shipping: Shipping?
            /// For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
            public var statementDescriptor: String?
            /// Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
            public var statementDescriptorSuffix: String?
            /// Transfer_data_creation_params
            ///
            /// The parameters used to automatically create a Transfer when the payment succeeds.
            /// For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
            public var transferData: TransferData?
            /// A string that identifies the resulting payment as part of a group. See the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts) for details.
            public var transferGroup: String?
            /// Set to `true` only when using manual confirmation and the iOS or Android SDKs to handle additional authentication steps.
            public var useStripeSdk: Bool?

            /// Automatic_payment_methods_param
            ///
            /// When enabled, this PaymentIntent will accept payment methods that you have enabled in the Dashboard and are compatible with this PaymentIntent's other parameters.
            public struct AutomaticPaymentMethods: Encodable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Controls when the funds will be captured from the customer's account.
            public enum CaptureMethod: String, Codable, CaseIterable {
                case automatic
                case manual
            }

            public enum ConfirmationMethod: String, Codable, CaseIterable {
                case automatic
                case manual
            }

            /// Secret_key_param
            ///
            /// This hash contains details about the Mandate to create. This parameter can only be used with [`confirm=true`](https://stripe.com/docs/api/payment_intents/create#create_payment_intent-confirm).
            public struct MandateData: Encodable {
                /// Customer_acceptance_param
                public var customerAcceptance: CustomerAcceptance

                /// Customer_acceptance_param
                public struct CustomerAcceptance: Encodable {
                    public var acceptedAt: Int?
                    /// Offline_param
                    public var offline: [String: AnyJSON]?
                    /// Online_param
                    public var online: Online?
                    public var type: `Type`

                    /// Online_param
                    public struct Online: Encodable {
                        public var ipAddress: String
                        public var userAgent: String

                        public init(ipAddress: String, userAgent: String) {
                            self.ipAddress = ipAddress
                            self.userAgent = userAgent
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(ipAddress, forKey: "ip_address")
                            encoder.encode(userAgent, forKey: "user_agent")
                            return encoder.items
                        }
                    }

                    public enum `Type`: String, Codable, CaseIterable {
                        case offline
                        case online
                    }

                    public init(acceptedAt: Int? = nil, offline: [String: AnyJSON]? = nil, online: Online? = nil, type: `Type`) {
                        self.acceptedAt = acceptedAt
                        self.offline = offline
                        self.online = online
                        self.type = type
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(acceptedAt, forKey: "accepted_at")
                        encoder.encode(offline, forKey: "offline")
                        encoder.encode(online, forKey: "online")
                        encoder.encode(type, forKey: "type")
                        return encoder.items
                    }
                }

                public init(customerAcceptance: CustomerAcceptance) {
                    self.customerAcceptance = customerAcceptance
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(customerAcceptance, forKey: "customer_acceptance")
                    return encoder.items
                }
            }

            /// Set to `true` to indicate that the customer is not in your checkout flow during this payment attempt, and therefore is unable to authenticate. This parameter is intended for scenarios where you collect card details and [charge them later](https://stripe.com/docs/payments/cards/charging-saved-cards). This parameter can only be used with [`confirm=true`](https://stripe.com/docs/api/payment_intents/create#create_payment_intent-confirm).
            public struct OffSession: Encodable {
                public var isBool: Bool?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case oneOff = "one_off"
                    case recurring
                }

                public init(isBool: Bool? = nil, object: Object? = nil) {
                    self.isBool = isBool
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isBool, forKey: "bool")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Payment_method_data_params
            ///
            /// If provided, this hash will be used to create a PaymentMethod. The new PaymentMethod will appear
            /// in the [payment_method](https://stripe.com/docs/api/payment_intents/object#payment_intent_object-payment_method)
            /// property on the PaymentIntent.
            public struct PaymentMethodData: Encodable {
                /// Payment_method_param
                public var acssDebit: AcssDebit?
                /// Param
                public var afterpayClearpay: [String: AnyJSON]?
                /// Param
                public var alipay: [String: AnyJSON]?
                /// Param
                public var auBecsDebit: AuBecsDebit?
                /// Param
                public var bacsDebit: BacsDebit?
                /// Param
                public var bancontact: [String: AnyJSON]?
                /// Billing_details_inner_params
                public var billingDetails: BillingDetails?
                /// Param
                public var boleto: Boleto?
                /// Param
                public var eps: Eps?
                /// Param
                public var fpx: Fpx?
                /// Param
                public var giropay: [String: AnyJSON]?
                /// Param
                public var grabpay: [String: AnyJSON]?
                /// Param
                public var ideal: Ideal?
                /// Param
                public var interacPresent: [String: AnyJSON]?
                /// Param
                public var klarna: Klarna?
                public var metadata: [String: String]?
                /// Param
                public var oxxo: [String: AnyJSON]?
                /// Param
                public var p24: P24?
                /// Param
                public var sepaDebit: SepaDebit?
                /// Param
                public var sofort: Sofort?
                public var type: `Type`
                /// Param
                public var wechatPay: [String: AnyJSON]?

                /// Payment_method_param
                public struct AcssDebit: Encodable {
                    public var accountNumber: String
                    public var institutionNumber: String
                    public var transitNumber: String

                    public init(accountNumber: String, institutionNumber: String, transitNumber: String) {
                        self.accountNumber = accountNumber
                        self.institutionNumber = institutionNumber
                        self.transitNumber = transitNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(institutionNumber, forKey: "institution_number")
                        encoder.encode(transitNumber, forKey: "transit_number")
                        return encoder.items
                    }
                }

                /// Param
                public struct AuBecsDebit: Encodable {
                    public var accountNumber: String
                    public var bsbNumber: String

                    public init(accountNumber: String, bsbNumber: String) {
                        self.accountNumber = accountNumber
                        self.bsbNumber = bsbNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(bsbNumber, forKey: "bsb_number")
                        return encoder.items
                    }
                }

                /// Param
                public struct BacsDebit: Encodable {
                    public var accountNumber: String?
                    public var sortCode: String?

                    public init(accountNumber: String? = nil, sortCode: String? = nil) {
                        self.accountNumber = accountNumber
                        self.sortCode = sortCode
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(sortCode, forKey: "sort_code")
                        return encoder.items
                    }
                }

                /// Billing_details_inner_params
                public struct BillingDetails: Encodable {
                    public var address: Address?
                    public var email: Email?
                    public var name: String?
                    public var phone: String?

                    public struct Address: Encodable {
                        /// Billing_details_address
                        public var a: A?
                        public var b: B?

                        /// Billing_details_address
                        public struct A: Encodable {
                            public var city: String?
                            public var country: String?
                            public var line1: String?
                            public var line2: String?
                            public var postalCode: String?
                            public var state: String?

                            public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                                self.city = city
                                self.country = country
                                self.line1 = line1
                                self.line2 = line2
                                self.postalCode = postalCode
                                self.state = state
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(city, forKey: "city")
                                encoder.encode(country, forKey: "country")
                                encoder.encode(line1, forKey: "line1")
                                encoder.encode(line2, forKey: "line2")
                                encoder.encode(postalCode, forKey: "postal_code")
                                encoder.encode(state, forKey: "state")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct Email: Encodable {
                        public var string: String?
                        public var object: Object?

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(string: String? = nil, object: Object? = nil) {
                            self.string = string
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(string, forKey: "string")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public init(address: Address? = nil, email: Email? = nil, name: String? = nil, phone: String? = nil) {
                        self.address = address
                        self.email = email
                        self.name = name
                        self.phone = phone
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(address, forKey: "address")
                        encoder.encode(email, forKey: "email")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(phone, forKey: "phone")
                        return encoder.items
                    }
                }

                /// Param
                public struct Boleto: Encodable {
                    public var taxID: String

                    public init(taxID: String) {
                        self.taxID = taxID
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(taxID, forKey: "tax_id")
                        return encoder.items
                    }
                }

                /// Param
                public struct Eps: Encodable {
                    public var bank: Bank?

                    public enum Bank: String, Codable, CaseIterable {
                        case arzteUndApothekerBank = "arzte_und_apotheker_bank"
                        case austrianAnadiBankAg = "austrian_anadi_bank_ag"
                        case bankAustria = "bank_austria"
                        case bankhausCarlSpangler = "bankhaus_carl_spangler"
                        case bankhausSchelhammerUndSchatteraAg = "bankhaus_schelhammer_und_schattera_ag"
                        case bawagPskAg = "bawag_psk_ag"
                        case bksBankAg = "bks_bank_ag"
                        case brullKallmusBankAg = "brull_kallmus_bank_ag"
                        case btvVierLanderBank = "btv_vier_lander_bank"
                        case capitalBankGraweGruppeAg = "capital_bank_grawe_gruppe_ag"
                        case dolomitenbank
                        case easybankAg = "easybank_ag"
                        case ersteBankUndSparkassen = "erste_bank_und_sparkassen"
                        case hypoAlpeadriabankInternationalAg = "hypo_alpeadriabank_international_ag"
                        case hypoBankBurgenlandAktiengesellschaft = "hypo_bank_burgenland_aktiengesellschaft"
                        case hypoNoeLbFurNiederosterreichUWien = "hypo_noe_lb_fur_niederosterreich_u_wien"
                        case hypoOberosterreichSalzburgSteiermark = "hypo_oberosterreich_salzburg_steiermark"
                        case hypoTirolBankAg = "hypo_tirol_bank_ag"
                        case hypoVorarlbergBankAg = "hypo_vorarlberg_bank_ag"
                        case marchfelderBank = "marchfelder_bank"
                        case oberbankAg = "oberbank_ag"
                        case raiffeisenBankengruppeOsterreich = "raiffeisen_bankengruppe_osterreich"
                        case schoellerbankAg = "schoellerbank_ag"
                        case spardaBankWien = "sparda_bank_wien"
                        case volksbankGruppe = "volksbank_gruppe"
                        case volkskreditbankAg = "volkskreditbank_ag"
                        case vrBankBraunau = "vr_bank_braunau"
                    }

                    public init(bank: Bank? = nil) {
                        self.bank = bank
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(bank, forKey: "bank")
                        return encoder.items
                    }
                }

                /// Param
                public struct Fpx: Encodable {
                    public var bank: Bank

                    public enum Bank: String, Codable, CaseIterable {
                        case affinBank = "affin_bank"
                        case agrobank
                        case allianceBank = "alliance_bank"
                        case ambank
                        case bankIslam = "bank_islam"
                        case bankMuamalat = "bank_muamalat"
                        case bankRakyat = "bank_rakyat"
                        case bsn
                        case cimb
                        case deutscheBank = "deutsche_bank"
                        case hongLeongBank = "hong_leong_bank"
                        case hsbc
                        case kfh
                        case maybank2e
                        case maybank2u
                        case ocbc
                        case pbEnterprise = "pb_enterprise"
                        case publicBank = "public_bank"
                        case rhb
                        case standardChartered = "standard_chartered"
                        case uob
                    }

                    public init(bank: Bank) {
                        self.bank = bank
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(bank, forKey: "bank")
                        return encoder.items
                    }
                }

                /// Param
                public struct Ideal: Encodable {
                    public var bank: Bank?

                    public enum Bank: String, Codable, CaseIterable {
                        case abnAmro = "abn_amro"
                        case asnBank = "asn_bank"
                        case bunq
                        case handelsbanken
                        case ing
                        case knab
                        case moneyou
                        case rabobank
                        case regiobank
                        case revolut
                        case snsBank = "sns_bank"
                        case triodosBank = "triodos_bank"
                        case vanLanschot = "van_lanschot"
                    }

                    public init(bank: Bank? = nil) {
                        self.bank = bank
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(bank, forKey: "bank")
                        return encoder.items
                    }
                }

                /// Param
                public struct Klarna: Encodable {
                    /// Date_of_birth
                    public var dob: Dob?

                    /// Date_of_birth
                    public struct Dob: Encodable {
                        public var day: Int
                        public var month: Int
                        public var year: Int

                        public init(day: Int, month: Int, year: Int) {
                            self.day = day
                            self.month = month
                            self.year = year
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(day, forKey: "day")
                            encoder.encode(month, forKey: "month")
                            encoder.encode(year, forKey: "year")
                            return encoder.items
                        }
                    }

                    public init(dob: Dob? = nil) {
                        self.dob = dob
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(dob, forKey: "dob")
                        return encoder.items
                    }
                }

                /// Param
                public struct P24: Encodable {
                    public var bank: Bank?

                    public enum Bank: String, Codable, CaseIterable {
                        case aliorBank = "alior_bank"
                        case bankMillennium = "bank_millennium"
                        case bankNowyBfgSa = "bank_nowy_bfg_sa"
                        case bankPekaoSa = "bank_pekao_sa"
                        case bankiSpbdzielcze = "banki_spbdzielcze"
                        case blik
                        case bnpParibas = "bnp_paribas"
                        case boz
                        case citiHandlowy = "citi_handlowy"
                        case creditAgricole = "credit_agricole"
                        case envelobank
                        case etransferPocztowy24 = "etransfer_pocztowy24"
                        case getinBank = "getin_bank"
                        case ideabank
                        case ing
                        case inteligo
                        case mbankMtransfer = "mbank_mtransfer"
                        case nestPrzelew = "nest_przelew"
                        case noblePay = "noble_pay"
                        case pbacZIpko = "pbac_z_ipko"
                        case plusBank = "plus_bank"
                        case santanderPrzelew24 = "santander_przelew24"
                        case tmobileUsbugiBankowe = "tmobile_usbugi_bankowe"
                        case toyotaBank = "toyota_bank"
                        case volkswagenBank = "volkswagen_bank"
                    }

                    public init(bank: Bank? = nil) {
                        self.bank = bank
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(bank, forKey: "bank")
                        return encoder.items
                    }
                }

                /// Param
                public struct SepaDebit: Encodable {
                    public var iban: String

                    public init(iban: String) {
                        self.iban = iban
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(iban, forKey: "iban")
                        return encoder.items
                    }
                }

                /// Param
                public struct Sofort: Encodable {
                    public var country: Country

                    public enum Country: String, Codable, CaseIterable {
                        case at = "AT"
                        case be = "BE"
                        case de = "DE"
                        case es = "ES"
                        case it = "IT"
                        case nl = "NL"
                    }

                    public init(country: Country) {
                        self.country = country
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(country, forKey: "country")
                        return encoder.items
                    }
                }

                public enum `Type`: String, Codable, CaseIterable {
                    case acssDebit = "acss_debit"
                    case afterpayClearpay = "afterpay_clearpay"
                    case alipay
                    case auBecsDebit = "au_becs_debit"
                    case bacsDebit = "bacs_debit"
                    case bancontact
                    case boleto
                    case eps
                    case fpx
                    case giropay
                    case grabpay
                    case ideal
                    case klarna
                    case oxxo
                    case p24
                    case sepaDebit = "sepa_debit"
                    case sofort
                    case wechatPay = "wechat_pay"
                }

                public init(acssDebit: AcssDebit? = nil, afterpayClearpay: [String: AnyJSON]? = nil, alipay: [String: AnyJSON]? = nil, auBecsDebit: AuBecsDebit? = nil, bacsDebit: BacsDebit? = nil, bancontact: [String: AnyJSON]? = nil, billingDetails: BillingDetails? = nil, boleto: Boleto? = nil, eps: Eps? = nil, fpx: Fpx? = nil, giropay: [String: AnyJSON]? = nil, grabpay: [String: AnyJSON]? = nil, ideal: Ideal? = nil, interacPresent: [String: AnyJSON]? = nil, klarna: Klarna? = nil, metadata: [String: String]? = nil, oxxo: [String: AnyJSON]? = nil, p24: P24? = nil, sepaDebit: SepaDebit? = nil, sofort: Sofort? = nil, type: `Type`, wechatPay: [String: AnyJSON]? = nil) {
                    self.acssDebit = acssDebit
                    self.afterpayClearpay = afterpayClearpay
                    self.alipay = alipay
                    self.auBecsDebit = auBecsDebit
                    self.bacsDebit = bacsDebit
                    self.bancontact = bancontact
                    self.billingDetails = billingDetails
                    self.boleto = boleto
                    self.eps = eps
                    self.fpx = fpx
                    self.giropay = giropay
                    self.grabpay = grabpay
                    self.ideal = ideal
                    self.interacPresent = interacPresent
                    self.klarna = klarna
                    self.metadata = metadata
                    self.oxxo = oxxo
                    self.p24 = p24
                    self.sepaDebit = sepaDebit
                    self.sofort = sofort
                    self.type = type
                    self.wechatPay = wechatPay
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(acssDebit, forKey: "acss_debit")
                    encoder.encode(afterpayClearpay, forKey: "afterpay_clearpay")
                    encoder.encode(alipay, forKey: "alipay")
                    encoder.encode(auBecsDebit, forKey: "au_becs_debit")
                    encoder.encode(bacsDebit, forKey: "bacs_debit")
                    encoder.encode(bancontact, forKey: "bancontact")
                    encoder.encode(billingDetails, forKey: "billing_details")
                    encoder.encode(boleto, forKey: "boleto")
                    encoder.encode(eps, forKey: "eps")
                    encoder.encode(fpx, forKey: "fpx")
                    encoder.encode(giropay, forKey: "giropay")
                    encoder.encode(grabpay, forKey: "grabpay")
                    encoder.encode(ideal, forKey: "ideal")
                    encoder.encode(interacPresent, forKey: "interac_present")
                    encoder.encode(klarna, forKey: "klarna")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(oxxo, forKey: "oxxo")
                    encoder.encode(p24, forKey: "p24")
                    encoder.encode(sepaDebit, forKey: "sepa_debit")
                    encoder.encode(sofort, forKey: "sofort")
                    encoder.encode(type, forKey: "type")
                    encoder.encode(wechatPay, forKey: "wechat_pay")
                    return encoder.items
                }
            }

            /// Payment_method_options_param
            ///
            /// Payment-method-specific configuration for this PaymentIntent.
            public struct PaymentMethodOptions: Encodable {
                public var acssDebit: AcssDebit?
                public var afterpayClearpay: AfterpayClearpay?
                public var alipay: Alipay?
                public var bancontact: Bancontact?
                public var boleto: Boleto?
                public var card: Card?
                public var cardPresent: CardPresent?
                public var giropay: Giropay?
                public var ideal: Ideal?
                public var interacPresent: InteracPresent?
                public var klarna: Klarna?
                public var oxxo: Oxxo?
                public var p24: P24?
                public var sepaDebit: SepaDebit?
                public var sofort: Sofort?
                public var wechatPay: WechatPay?

                public struct AcssDebit: Encodable {
                    /// Payment_intent_payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_intent_payment_method_options_param
                    public struct A: Encodable {
                        /// Payment_intent_payment_method_options_mandate_options_param
                        public var mandateOptions: MandateOptions?
                        public var verificationMethod: VerificationMethod?

                        /// Payment_intent_payment_method_options_mandate_options_param
                        public struct MandateOptions: Encodable {
                            public var customMandateURL: CustomMandateURL?
                            public var intervalDescription: String?
                            public var paymentSchedule: PaymentSchedule?
                            public var transactionType: TransactionType?

                            public struct CustomMandateURL: Encodable {
                                public var string: String?
                                public var object: Object?

                                public enum Object: String, Codable, CaseIterable {
                                    case empty = ""
                                }

                                public init(string: String? = nil, object: Object? = nil) {
                                    self.string = string
                                    self.object = object
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(string, forKey: "string")
                                    encoder.encode(object, forKey: "object")
                                    return encoder.items
                                }
                            }

                            public enum PaymentSchedule: String, Codable, CaseIterable {
                                case combined
                                case interval
                                case sporadic
                            }

                            public enum TransactionType: String, Codable, CaseIterable {
                                case business
                                case personal
                            }

                            public init(customMandateURL: CustomMandateURL? = nil, intervalDescription: String? = nil, paymentSchedule: PaymentSchedule? = nil, transactionType: TransactionType? = nil) {
                                self.customMandateURL = customMandateURL
                                self.intervalDescription = intervalDescription
                                self.paymentSchedule = paymentSchedule
                                self.transactionType = transactionType
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(customMandateURL, forKey: "custom_mandate_url")
                                encoder.encode(intervalDescription, forKey: "interval_description")
                                encoder.encode(paymentSchedule, forKey: "payment_schedule")
                                encoder.encode(transactionType, forKey: "transaction_type")
                                return encoder.items
                            }
                        }

                        public enum VerificationMethod: String, Codable, CaseIterable {
                            case automatic
                            case instant
                            case microdeposits
                        }

                        public init(mandateOptions: MandateOptions? = nil, verificationMethod: VerificationMethod? = nil) {
                            self.mandateOptions = mandateOptions
                            self.verificationMethod = verificationMethod
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(mandateOptions, forKey: "mandate_options")
                            encoder.encode(verificationMethod, forKey: "verification_method")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct AfterpayClearpay: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var reference: String?

                        public init(reference: String? = nil) {
                            self.reference = reference
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(reference, forKey: "reference")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Alipay: Encodable {
                    /// Payment_method_options_param
                    public var object: [String: AnyJSON]?
                    public var object2: Object2?

                    public enum Object2: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(object: [String: AnyJSON]? = nil, object2: Object2? = nil) {
                        self.object = object
                        self.object2 = object2
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object, forKey: "object")
                        encoder.encode(object2, forKey: "object2")
                        return encoder.items
                    }
                }

                public struct Bancontact: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var preferredLanguage: PreferredLanguage?

                        public enum PreferredLanguage: String, Codable, CaseIterable {
                            case de
                            case en
                            case fr
                            case nl
                        }

                        public init(preferredLanguage: PreferredLanguage? = nil) {
                            self.preferredLanguage = preferredLanguage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(preferredLanguage, forKey: "preferred_language")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Boleto: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var expiresAfterDays: Int?

                        public init(expiresAfterDays: Int? = nil) {
                            self.expiresAfterDays = expiresAfterDays
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(expiresAfterDays, forKey: "expires_after_days")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Card: Encodable {
                    /// Payment_intent_param
                    public var a: A?
                    public var b: B?

                    /// Payment_intent_param
                    public struct A: Encodable {
                        public var cvcToken: String?
                        /// Installments_param
                        public var installments: Installments?
                        public var network: Network?
                        public var requestThreeDSecure: RequestThreeDSecure?
                        public var setupFutureUsage: SetupFutureUsage?

                        /// Installments_param
                        public struct Installments: Encodable {
                            public var isEnabled: Bool?
                            public var plan: Plan?

                            public struct Plan: Encodable {
                                /// Installment_plan
                                public var a: A?
                                public var b: B?

                                /// Installment_plan
                                public struct A: Encodable {
                                    public var count: Int
                                    public var interval: Interval
                                    public var type: `Type`

                                    public enum Interval: String, Codable, CaseIterable {
                                        case month
                                    }

                                    public enum `Type`: String, Codable, CaseIterable {
                                        case fixedCount = "fixed_count"
                                    }

                                    public init(count: Int, interval: Interval, type: `Type`) {
                                        self.count = count
                                        self.interval = interval
                                        self.type = type
                                    }

                                    public var asQuery: [(String, String?)] {
                                        let encoder = URLQueryEncoder()
                                        encoder.encode(count, forKey: "count")
                                        encoder.encode(interval, forKey: "interval")
                                        encoder.encode(type, forKey: "type")
                                        return encoder.items
                                    }
                                }

                                public enum B: String, Codable, CaseIterable {
                                    case empty = ""
                                }

                                public init(a: A? = nil, b: B? = nil) {
                                    self.a = a
                                    self.b = b
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(a, forKey: "a")
                                    encoder.encode(b, forKey: "b")
                                    return encoder.items
                                }
                            }

                            public init(isEnabled: Bool? = nil, plan: Plan? = nil) {
                                self.isEnabled = isEnabled
                                self.plan = plan
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(isEnabled, forKey: "enabled")
                                encoder.encode(plan, forKey: "plan")
                                return encoder.items
                            }
                        }

                        public enum Network: String, Codable, CaseIterable {
                            case amex
                            case cartesBancaires = "cartes_bancaires"
                            case diners
                            case discover
                            case interac
                            case jcb
                            case mastercard
                            case unionpay
                            case unknown
                            case visa
                        }

                        public enum RequestThreeDSecure: String, Codable, CaseIterable {
                            case any
                            case automatic
                        }

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case empty = ""
                            case `none`
                            case offSession = "off_session"
                            case onSession = "on_session"
                        }

                        public init(cvcToken: String? = nil, installments: Installments? = nil, network: Network? = nil, requestThreeDSecure: RequestThreeDSecure? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                            self.cvcToken = cvcToken
                            self.installments = installments
                            self.network = network
                            self.requestThreeDSecure = requestThreeDSecure
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(cvcToken, forKey: "cvc_token")
                            encoder.encode(installments, forKey: "installments")
                            encoder.encode(network, forKey: "network")
                            encoder.encode(requestThreeDSecure, forKey: "request_three_d_secure")
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct CardPresent: Encodable {
                    /// Payment_method_options_param
                    public var object: [String: AnyJSON]?
                    public var object2: Object2?

                    public enum Object2: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(object: [String: AnyJSON]? = nil, object2: Object2? = nil) {
                        self.object = object
                        self.object2 = object2
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object, forKey: "object")
                        encoder.encode(object2, forKey: "object2")
                        return encoder.items
                    }
                }

                public struct Giropay: Encodable {
                    /// Payment_method_options_param
                    public var object: [String: AnyJSON]?
                    public var object2: Object2?

                    public enum Object2: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(object: [String: AnyJSON]? = nil, object2: Object2? = nil) {
                        self.object = object
                        self.object2 = object2
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object, forKey: "object")
                        encoder.encode(object2, forKey: "object2")
                        return encoder.items
                    }
                }

                public struct Ideal: Encodable {
                    /// Payment_method_options_param
                    public var object: [String: AnyJSON]?
                    public var object2: Object2?

                    public enum Object2: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(object: [String: AnyJSON]? = nil, object2: Object2? = nil) {
                        self.object = object
                        self.object2 = object2
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object, forKey: "object")
                        encoder.encode(object2, forKey: "object2")
                        return encoder.items
                    }
                }

                public struct InteracPresent: Encodable {
                    /// Payment_method_options_param
                    public var object: [String: AnyJSON]?
                    public var object2: Object2?

                    public enum Object2: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(object: [String: AnyJSON]? = nil, object2: Object2? = nil) {
                        self.object = object
                        self.object2 = object2
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object, forKey: "object")
                        encoder.encode(object2, forKey: "object2")
                        return encoder.items
                    }
                }

                public struct Klarna: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var preferredLocale: PreferredLocale?

                        public enum PreferredLocale: String, Codable, CaseIterable {
                            case daDK = "da-DK"
                            case deAT = "de-AT"
                            case deDE = "de-DE"
                            case enAT = "en-AT"
                            case enBE = "en-BE"
                            case enDE = "en-DE"
                            case enDK = "en-DK"
                            case enES = "en-ES"
                            case enFI = "en-FI"
                            case enGB = "en-GB"
                            case enIE = "en-IE"
                            case enIT = "en-IT"
                            case enNL = "en-NL"
                            case enNO = "en-NO"
                            case enSE = "en-SE"
                            case enUS = "en-US"
                            case esES = "es-ES"
                            case fiFI = "fi-FI"
                            case frBE = "fr-BE"
                            case itIT = "it-IT"
                            case nbNO = "nb-NO"
                            case nlBE = "nl-BE"
                            case nlNL = "nl-NL"
                            case svFI = "sv-FI"
                            case svSE = "sv-SE"
                        }

                        public init(preferredLocale: PreferredLocale? = nil) {
                            self.preferredLocale = preferredLocale
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(preferredLocale, forKey: "preferred_locale")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Oxxo: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var expiresAfterDays: Int?

                        public init(expiresAfterDays: Int? = nil) {
                            self.expiresAfterDays = expiresAfterDays
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(expiresAfterDays, forKey: "expires_after_days")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct P24: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var isTosShownAndAccepted: Bool?

                        public init(isTosShownAndAccepted: Bool? = nil) {
                            self.isTosShownAndAccepted = isTosShownAndAccepted
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(isTosShownAndAccepted, forKey: "tos_shown_and_accepted")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct SepaDebit: Encodable {
                    /// Payment_intent_payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_intent_payment_method_options_param
                    public struct A: Encodable {
                        /// Payment_method_options_mandate_options_param
                        public var mandateOptions: [String: AnyJSON]?

                        public init(mandateOptions: [String: AnyJSON]? = nil) {
                            self.mandateOptions = mandateOptions
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(mandateOptions, forKey: "mandate_options")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Sofort: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var preferredLanguage: PreferredLanguage?

                        public enum PreferredLanguage: String, Codable, CaseIterable {
                            case empty = ""
                            case de
                            case en
                            case es
                            case fr
                            case it
                            case nl
                            case pl
                        }

                        public init(preferredLanguage: PreferredLanguage? = nil) {
                            self.preferredLanguage = preferredLanguage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(preferredLanguage, forKey: "preferred_language")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct WechatPay: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var appID: String?
                        public var client: Client

                        public enum Client: String, Codable, CaseIterable {
                            case android
                            case ios
                            case web
                        }

                        public init(appID: String? = nil, client: Client) {
                            self.appID = appID
                            self.client = client
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(appID, forKey: "app_id")
                            encoder.encode(client, forKey: "client")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public init(acssDebit: AcssDebit? = nil, afterpayClearpay: AfterpayClearpay? = nil, alipay: Alipay? = nil, bancontact: Bancontact? = nil, boleto: Boleto? = nil, card: Card? = nil, cardPresent: CardPresent? = nil, giropay: Giropay? = nil, ideal: Ideal? = nil, interacPresent: InteracPresent? = nil, klarna: Klarna? = nil, oxxo: Oxxo? = nil, p24: P24? = nil, sepaDebit: SepaDebit? = nil, sofort: Sofort? = nil, wechatPay: WechatPay? = nil) {
                    self.acssDebit = acssDebit
                    self.afterpayClearpay = afterpayClearpay
                    self.alipay = alipay
                    self.bancontact = bancontact
                    self.boleto = boleto
                    self.card = card
                    self.cardPresent = cardPresent
                    self.giropay = giropay
                    self.ideal = ideal
                    self.interacPresent = interacPresent
                    self.klarna = klarna
                    self.oxxo = oxxo
                    self.p24 = p24
                    self.sepaDebit = sepaDebit
                    self.sofort = sofort
                    self.wechatPay = wechatPay
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(acssDebit, forKey: "acss_debit")
                    encoder.encode(afterpayClearpay, forKey: "afterpay_clearpay")
                    encoder.encode(alipay, forKey: "alipay")
                    encoder.encode(bancontact, forKey: "bancontact")
                    encoder.encode(boleto, forKey: "boleto")
                    encoder.encode(card, forKey: "card")
                    encoder.encode(cardPresent, forKey: "card_present")
                    encoder.encode(giropay, forKey: "giropay")
                    encoder.encode(ideal, forKey: "ideal")
                    encoder.encode(interacPresent, forKey: "interac_present")
                    encoder.encode(klarna, forKey: "klarna")
                    encoder.encode(oxxo, forKey: "oxxo")
                    encoder.encode(p24, forKey: "p24")
                    encoder.encode(sepaDebit, forKey: "sepa_debit")
                    encoder.encode(sofort, forKey: "sofort")
                    encoder.encode(wechatPay, forKey: "wechat_pay")
                    return encoder.items
                }
            }

            /// Indicates that you intend to make future payments with this PaymentIntent's payment method.
            /// 
            /// Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent's Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.
            /// 
            /// When processing card payments, Stripe also uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).
            public enum SetupFutureUsage: String, Codable, CaseIterable {
                case offSession = "off_session"
                case onSession = "on_session"
            }

            /// Optional_fields_shipping
            ///
            /// Shipping information for this PaymentIntent.
            public struct Shipping: Encodable {
                /// Optional_fields_address
                public var address: Address
                public var carrier: String?
                public var name: String
                public var phone: String?
                public var trackingNumber: String?

                /// Optional_fields_address
                public struct Address: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                public init(address: Address, carrier: String? = nil, name: String, phone: String? = nil, trackingNumber: String? = nil) {
                    self.address = address
                    self.carrier = carrier
                    self.name = name
                    self.phone = phone
                    self.trackingNumber = trackingNumber
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(carrier, forKey: "carrier")
                    encoder.encode(name, forKey: "name")
                    encoder.encode(phone, forKey: "phone")
                    encoder.encode(trackingNumber, forKey: "tracking_number")
                    return encoder.items
                }
            }

            /// Transfer_data_creation_params
            ///
            /// The parameters used to automatically create a Transfer when the payment succeeds.
            /// For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
            public struct TransferData: Encodable {
                public var amount: Int?
                public var destination: String

                public init(amount: Int? = nil, destination: String) {
                    self.amount = amount
                    self.destination = destination
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(amount, forKey: "amount")
                    encoder.encode(destination, forKey: "destination")
                    return encoder.items
                }
            }

            public init(amount: Int, applicationFeeAmount: Int? = nil, automaticPaymentMethods: AutomaticPaymentMethods? = nil, captureMethod: CaptureMethod? = nil, isConfirm: Bool? = nil, confirmationMethod: ConfirmationMethod? = nil, currency: String, customer: String? = nil, description: String? = nil, errorOnRequiresAction: Bool? = nil, expand: [String]? = nil, mandate: String? = nil, mandateData: MandateData? = nil, metadata: [String: String]? = nil, offSession: OffSession? = nil, onBehalfOf: String? = nil, paymentMethod: String? = nil, paymentMethodData: PaymentMethodData? = nil, paymentMethodOptions: PaymentMethodOptions? = nil, paymentMethodTypes: [String]? = nil, receiptEmail: String? = nil, returnURL: String? = nil, setupFutureUsage: SetupFutureUsage? = nil, shipping: Shipping? = nil, statementDescriptor: String? = nil, statementDescriptorSuffix: String? = nil, transferData: TransferData? = nil, transferGroup: String? = nil, useStripeSdk: Bool? = nil) {
                self.amount = amount
                self.applicationFeeAmount = applicationFeeAmount
                self.automaticPaymentMethods = automaticPaymentMethods
                self.captureMethod = captureMethod
                self.isConfirm = isConfirm
                self.confirmationMethod = confirmationMethod
                self.currency = currency
                self.customer = customer
                self.description = description
                self.errorOnRequiresAction = errorOnRequiresAction
                self.expand = expand
                self.mandate = mandate
                self.mandateData = mandateData
                self.metadata = metadata
                self.offSession = offSession
                self.onBehalfOf = onBehalfOf
                self.paymentMethod = paymentMethod
                self.paymentMethodData = paymentMethodData
                self.paymentMethodOptions = paymentMethodOptions
                self.paymentMethodTypes = paymentMethodTypes
                self.receiptEmail = receiptEmail
                self.returnURL = returnURL
                self.setupFutureUsage = setupFutureUsage
                self.shipping = shipping
                self.statementDescriptor = statementDescriptor
                self.statementDescriptorSuffix = statementDescriptorSuffix
                self.transferData = transferData
                self.transferGroup = transferGroup
                self.useStripeSdk = useStripeSdk
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(applicationFeeAmount, forKey: "application_fee_amount")
                encoder.encode(automaticPaymentMethods, forKey: "automatic_payment_methods")
                encoder.encode(captureMethod, forKey: "capture_method")
                encoder.encode(isConfirm, forKey: "confirm")
                encoder.encode(confirmationMethod, forKey: "confirmation_method")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(description, forKey: "description")
                encoder.encode(errorOnRequiresAction, forKey: "error_on_requires_action")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(mandate, forKey: "mandate")
                encoder.encode(mandateData, forKey: "mandate_data")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(offSession, forKey: "off_session")
                encoder.encode(onBehalfOf, forKey: "on_behalf_of")
                encoder.encode(paymentMethod, forKey: "payment_method")
                encoder.encode(paymentMethodData, forKey: "payment_method_data")
                encoder.encode(paymentMethodOptions, forKey: "payment_method_options")
                encoder.encode(paymentMethodTypes, forKey: "payment_method_types")
                encoder.encode(receiptEmail, forKey: "receipt_email")
                encoder.encode(returnURL, forKey: "return_url")
                encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                encoder.encode(shipping, forKey: "shipping")
                encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                encoder.encode(statementDescriptorSuffix, forKey: "statement_descriptor_suffix")
                encoder.encode(transferData, forKey: "transfer_data")
                encoder.encode(transferGroup, forKey: "transfer_group")
                encoder.encode(useStripeSdk, forKey: "use_stripe_sdk")
                return encoder.items
            }
        }
    }
}

extension Paths.PaymentIntents {
    public func intent(_ intent: String) -> WithIntent {
        WithIntent(path: "\(path)/\(intent)")
    }

    public struct WithIntent {
        /// Path: `/v1/payment_intents/{intent}`
        public let path: String

        /// <p>Retrieves the details of a PaymentIntent that has previously been created. </p>
        /// 
        /// <p>Client-side retrieval using a publishable key is allowed when the <code>client_secret</code> is provided in the query string. </p>
        /// 
        /// <p>When retrieved with a publishable key, only a subset of properties will be returned. Please refer to the <a href="#payment_intent_object">payment intent</a> object reference for more details.</p>
        public func get(clientSecret: String? = nil, expand: [String]? = nil) -> Request<StripeAPI.PaymentIntent> {
            .get(path, query: makeGetQuery(clientSecret, expand))
        }

        private func makeGetQuery(_ clientSecret: String?, _ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(clientSecret, forKey: "client_secret")
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates properties on a PaymentIntent object without confirming.</p>
        /// 
        /// <p>Depending on which properties you update, you may need to confirm the
        /// PaymentIntent again. For example, updating the <code>payment_method</code> will
        /// always require you to confirm the PaymentIntent again. If you prefer to
        /// update and confirm at the same time, we recommend updating properties via
        /// the <a href="/docs/api/payment_intents/confirm">confirm API</a> instead.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.PaymentIntent> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Amount intended to be collected by this PaymentIntent. A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum amount is $0.50 US or [equivalent in charge currency](https://stripe.com/docs/currencies#minimum-and-maximum-charge-amounts). The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of $999,999.99).
            public var amount: Int?
            /// The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. The amount of the application fee collected will be capped at the total payment amount. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
            public var applicationFeeAmount: ApplicationFeeAmount?
            /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
            public var currency: String?
            /// ID of the Customer this PaymentIntent belongs to, if one exists.
            /// 
            /// Payment methods attached to other Customers cannot be used with this PaymentIntent.
            /// 
            /// If present in combination with [setup_future_usage](https://stripe.com/docs/api#payment_intent_object-setup_future_usage), this PaymentIntent's payment method will be attached to the Customer after the PaymentIntent has been confirmed and any required actions from the user are complete.
            public var customer: String?
            /// An arbitrary string attached to the object. Often useful for displaying to users.
            public var description: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// ID of the payment method (a PaymentMethod, Card, or [compatible Source](https://stripe.com/docs/payments/payment-methods/transitioning#compatibility) object) to attach to this PaymentIntent.
            public var paymentMethod: String?
            /// Payment_method_data_params
            ///
            /// If provided, this hash will be used to create a PaymentMethod. The new PaymentMethod will appear
            /// in the [payment_method](https://stripe.com/docs/api/payment_intents/object#payment_intent_object-payment_method)
            /// property on the PaymentIntent.
            public var paymentMethodData: PaymentMethodData?
            /// Payment_method_options_param
            ///
            /// Payment-method-specific configuration for this PaymentIntent.
            public var paymentMethodOptions: PaymentMethodOptions?
            /// The list of payment method types (e.g. card) that this PaymentIntent is allowed to use.
            public var paymentMethodTypes: [String]?
            /// Email address that the receipt for the resulting payment will be sent to. If `receipt_email` is specified for a payment in live mode, a receipt will be sent regardless of your [email settings](https://dashboard.stripe.com/account/emails).
            public var receiptEmail: ReceiptEmail?
            /// Indicates that you intend to make future payments with this PaymentIntent's payment method.
            /// 
            /// Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent's Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.
            /// 
            /// When processing card payments, Stripe also uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).
            /// 
            /// If `setup_future_usage` is already set and you are performing a request using a publishable key, you may only update the value from `on_session` to `off_session`.
            public var setupFutureUsage: SetupFutureUsage?
            /// Shipping information for this PaymentIntent.
            public var shipping: Shipping?
            /// For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
            public var statementDescriptor: String?
            /// Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
            public var statementDescriptorSuffix: String?
            /// Transfer_data_update_params
            ///
            /// The parameters used to automatically create a Transfer when the payment succeeds. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
            public var transferData: TransferData?
            /// A string that identifies the resulting payment as part of a group. `transfer_group` may only be provided if it has not been set. See the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts) for details.
            public var transferGroup: String?

            /// The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. The amount of the application fee collected will be capped at the total payment amount. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
            public struct ApplicationFeeAmount: Encodable {
                public var int: Int?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(int: Int? = nil, object: Object? = nil) {
                    self.int = int
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(int, forKey: "int")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Payment_method_data_params
            ///
            /// If provided, this hash will be used to create a PaymentMethod. The new PaymentMethod will appear
            /// in the [payment_method](https://stripe.com/docs/api/payment_intents/object#payment_intent_object-payment_method)
            /// property on the PaymentIntent.
            public struct PaymentMethodData: Encodable {
                /// Payment_method_param
                public var acssDebit: AcssDebit?
                /// Param
                public var afterpayClearpay: [String: AnyJSON]?
                /// Param
                public var alipay: [String: AnyJSON]?
                /// Param
                public var auBecsDebit: AuBecsDebit?
                /// Param
                public var bacsDebit: BacsDebit?
                /// Param
                public var bancontact: [String: AnyJSON]?
                /// Billing_details_inner_params
                public var billingDetails: BillingDetails?
                /// Param
                public var boleto: Boleto?
                /// Param
                public var eps: Eps?
                /// Param
                public var fpx: Fpx?
                /// Param
                public var giropay: [String: AnyJSON]?
                /// Param
                public var grabpay: [String: AnyJSON]?
                /// Param
                public var ideal: Ideal?
                /// Param
                public var interacPresent: [String: AnyJSON]?
                /// Param
                public var klarna: Klarna?
                public var metadata: [String: String]?
                /// Param
                public var oxxo: [String: AnyJSON]?
                /// Param
                public var p24: P24?
                /// Param
                public var sepaDebit: SepaDebit?
                /// Param
                public var sofort: Sofort?
                public var type: `Type`
                /// Param
                public var wechatPay: [String: AnyJSON]?

                /// Payment_method_param
                public struct AcssDebit: Encodable {
                    public var accountNumber: String
                    public var institutionNumber: String
                    public var transitNumber: String

                    public init(accountNumber: String, institutionNumber: String, transitNumber: String) {
                        self.accountNumber = accountNumber
                        self.institutionNumber = institutionNumber
                        self.transitNumber = transitNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(institutionNumber, forKey: "institution_number")
                        encoder.encode(transitNumber, forKey: "transit_number")
                        return encoder.items
                    }
                }

                /// Param
                public struct AuBecsDebit: Encodable {
                    public var accountNumber: String
                    public var bsbNumber: String

                    public init(accountNumber: String, bsbNumber: String) {
                        self.accountNumber = accountNumber
                        self.bsbNumber = bsbNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(bsbNumber, forKey: "bsb_number")
                        return encoder.items
                    }
                }

                /// Param
                public struct BacsDebit: Encodable {
                    public var accountNumber: String?
                    public var sortCode: String?

                    public init(accountNumber: String? = nil, sortCode: String? = nil) {
                        self.accountNumber = accountNumber
                        self.sortCode = sortCode
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(sortCode, forKey: "sort_code")
                        return encoder.items
                    }
                }

                /// Billing_details_inner_params
                public struct BillingDetails: Encodable {
                    public var address: Address?
                    public var email: Email?
                    public var name: String?
                    public var phone: String?

                    public struct Address: Encodable {
                        /// Billing_details_address
                        public var a: A?
                        public var b: B?

                        /// Billing_details_address
                        public struct A: Encodable {
                            public var city: String?
                            public var country: String?
                            public var line1: String?
                            public var line2: String?
                            public var postalCode: String?
                            public var state: String?

                            public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                                self.city = city
                                self.country = country
                                self.line1 = line1
                                self.line2 = line2
                                self.postalCode = postalCode
                                self.state = state
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(city, forKey: "city")
                                encoder.encode(country, forKey: "country")
                                encoder.encode(line1, forKey: "line1")
                                encoder.encode(line2, forKey: "line2")
                                encoder.encode(postalCode, forKey: "postal_code")
                                encoder.encode(state, forKey: "state")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct Email: Encodable {
                        public var string: String?
                        public var object: Object?

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(string: String? = nil, object: Object? = nil) {
                            self.string = string
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(string, forKey: "string")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public init(address: Address? = nil, email: Email? = nil, name: String? = nil, phone: String? = nil) {
                        self.address = address
                        self.email = email
                        self.name = name
                        self.phone = phone
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(address, forKey: "address")
                        encoder.encode(email, forKey: "email")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(phone, forKey: "phone")
                        return encoder.items
                    }
                }

                /// Param
                public struct Boleto: Encodable {
                    public var taxID: String

                    public init(taxID: String) {
                        self.taxID = taxID
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(taxID, forKey: "tax_id")
                        return encoder.items
                    }
                }

                /// Param
                public struct Eps: Encodable {
                    public var bank: Bank?

                    public enum Bank: String, Codable, CaseIterable {
                        case arzteUndApothekerBank = "arzte_und_apotheker_bank"
                        case austrianAnadiBankAg = "austrian_anadi_bank_ag"
                        case bankAustria = "bank_austria"
                        case bankhausCarlSpangler = "bankhaus_carl_spangler"
                        case bankhausSchelhammerUndSchatteraAg = "bankhaus_schelhammer_und_schattera_ag"
                        case bawagPskAg = "bawag_psk_ag"
                        case bksBankAg = "bks_bank_ag"
                        case brullKallmusBankAg = "brull_kallmus_bank_ag"
                        case btvVierLanderBank = "btv_vier_lander_bank"
                        case capitalBankGraweGruppeAg = "capital_bank_grawe_gruppe_ag"
                        case dolomitenbank
                        case easybankAg = "easybank_ag"
                        case ersteBankUndSparkassen = "erste_bank_und_sparkassen"
                        case hypoAlpeadriabankInternationalAg = "hypo_alpeadriabank_international_ag"
                        case hypoBankBurgenlandAktiengesellschaft = "hypo_bank_burgenland_aktiengesellschaft"
                        case hypoNoeLbFurNiederosterreichUWien = "hypo_noe_lb_fur_niederosterreich_u_wien"
                        case hypoOberosterreichSalzburgSteiermark = "hypo_oberosterreich_salzburg_steiermark"
                        case hypoTirolBankAg = "hypo_tirol_bank_ag"
                        case hypoVorarlbergBankAg = "hypo_vorarlberg_bank_ag"
                        case marchfelderBank = "marchfelder_bank"
                        case oberbankAg = "oberbank_ag"
                        case raiffeisenBankengruppeOsterreich = "raiffeisen_bankengruppe_osterreich"
                        case schoellerbankAg = "schoellerbank_ag"
                        case spardaBankWien = "sparda_bank_wien"
                        case volksbankGruppe = "volksbank_gruppe"
                        case volkskreditbankAg = "volkskreditbank_ag"
                        case vrBankBraunau = "vr_bank_braunau"
                    }

                    public init(bank: Bank? = nil) {
                        self.bank = bank
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(bank, forKey: "bank")
                        return encoder.items
                    }
                }

                /// Param
                public struct Fpx: Encodable {
                    public var bank: Bank

                    public enum Bank: String, Codable, CaseIterable {
                        case affinBank = "affin_bank"
                        case agrobank
                        case allianceBank = "alliance_bank"
                        case ambank
                        case bankIslam = "bank_islam"
                        case bankMuamalat = "bank_muamalat"
                        case bankRakyat = "bank_rakyat"
                        case bsn
                        case cimb
                        case deutscheBank = "deutsche_bank"
                        case hongLeongBank = "hong_leong_bank"
                        case hsbc
                        case kfh
                        case maybank2e
                        case maybank2u
                        case ocbc
                        case pbEnterprise = "pb_enterprise"
                        case publicBank = "public_bank"
                        case rhb
                        case standardChartered = "standard_chartered"
                        case uob
                    }

                    public init(bank: Bank) {
                        self.bank = bank
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(bank, forKey: "bank")
                        return encoder.items
                    }
                }

                /// Param
                public struct Ideal: Encodable {
                    public var bank: Bank?

                    public enum Bank: String, Codable, CaseIterable {
                        case abnAmro = "abn_amro"
                        case asnBank = "asn_bank"
                        case bunq
                        case handelsbanken
                        case ing
                        case knab
                        case moneyou
                        case rabobank
                        case regiobank
                        case revolut
                        case snsBank = "sns_bank"
                        case triodosBank = "triodos_bank"
                        case vanLanschot = "van_lanschot"
                    }

                    public init(bank: Bank? = nil) {
                        self.bank = bank
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(bank, forKey: "bank")
                        return encoder.items
                    }
                }

                /// Param
                public struct Klarna: Encodable {
                    /// Date_of_birth
                    public var dob: Dob?

                    /// Date_of_birth
                    public struct Dob: Encodable {
                        public var day: Int
                        public var month: Int
                        public var year: Int

                        public init(day: Int, month: Int, year: Int) {
                            self.day = day
                            self.month = month
                            self.year = year
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(day, forKey: "day")
                            encoder.encode(month, forKey: "month")
                            encoder.encode(year, forKey: "year")
                            return encoder.items
                        }
                    }

                    public init(dob: Dob? = nil) {
                        self.dob = dob
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(dob, forKey: "dob")
                        return encoder.items
                    }
                }

                /// Param
                public struct P24: Encodable {
                    public var bank: Bank?

                    public enum Bank: String, Codable, CaseIterable {
                        case aliorBank = "alior_bank"
                        case bankMillennium = "bank_millennium"
                        case bankNowyBfgSa = "bank_nowy_bfg_sa"
                        case bankPekaoSa = "bank_pekao_sa"
                        case bankiSpbdzielcze = "banki_spbdzielcze"
                        case blik
                        case bnpParibas = "bnp_paribas"
                        case boz
                        case citiHandlowy = "citi_handlowy"
                        case creditAgricole = "credit_agricole"
                        case envelobank
                        case etransferPocztowy24 = "etransfer_pocztowy24"
                        case getinBank = "getin_bank"
                        case ideabank
                        case ing
                        case inteligo
                        case mbankMtransfer = "mbank_mtransfer"
                        case nestPrzelew = "nest_przelew"
                        case noblePay = "noble_pay"
                        case pbacZIpko = "pbac_z_ipko"
                        case plusBank = "plus_bank"
                        case santanderPrzelew24 = "santander_przelew24"
                        case tmobileUsbugiBankowe = "tmobile_usbugi_bankowe"
                        case toyotaBank = "toyota_bank"
                        case volkswagenBank = "volkswagen_bank"
                    }

                    public init(bank: Bank? = nil) {
                        self.bank = bank
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(bank, forKey: "bank")
                        return encoder.items
                    }
                }

                /// Param
                public struct SepaDebit: Encodable {
                    public var iban: String

                    public init(iban: String) {
                        self.iban = iban
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(iban, forKey: "iban")
                        return encoder.items
                    }
                }

                /// Param
                public struct Sofort: Encodable {
                    public var country: Country

                    public enum Country: String, Codable, CaseIterable {
                        case at = "AT"
                        case be = "BE"
                        case de = "DE"
                        case es = "ES"
                        case it = "IT"
                        case nl = "NL"
                    }

                    public init(country: Country) {
                        self.country = country
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(country, forKey: "country")
                        return encoder.items
                    }
                }

                public enum `Type`: String, Codable, CaseIterable {
                    case acssDebit = "acss_debit"
                    case afterpayClearpay = "afterpay_clearpay"
                    case alipay
                    case auBecsDebit = "au_becs_debit"
                    case bacsDebit = "bacs_debit"
                    case bancontact
                    case boleto
                    case eps
                    case fpx
                    case giropay
                    case grabpay
                    case ideal
                    case klarna
                    case oxxo
                    case p24
                    case sepaDebit = "sepa_debit"
                    case sofort
                    case wechatPay = "wechat_pay"
                }

                public init(acssDebit: AcssDebit? = nil, afterpayClearpay: [String: AnyJSON]? = nil, alipay: [String: AnyJSON]? = nil, auBecsDebit: AuBecsDebit? = nil, bacsDebit: BacsDebit? = nil, bancontact: [String: AnyJSON]? = nil, billingDetails: BillingDetails? = nil, boleto: Boleto? = nil, eps: Eps? = nil, fpx: Fpx? = nil, giropay: [String: AnyJSON]? = nil, grabpay: [String: AnyJSON]? = nil, ideal: Ideal? = nil, interacPresent: [String: AnyJSON]? = nil, klarna: Klarna? = nil, metadata: [String: String]? = nil, oxxo: [String: AnyJSON]? = nil, p24: P24? = nil, sepaDebit: SepaDebit? = nil, sofort: Sofort? = nil, type: `Type`, wechatPay: [String: AnyJSON]? = nil) {
                    self.acssDebit = acssDebit
                    self.afterpayClearpay = afterpayClearpay
                    self.alipay = alipay
                    self.auBecsDebit = auBecsDebit
                    self.bacsDebit = bacsDebit
                    self.bancontact = bancontact
                    self.billingDetails = billingDetails
                    self.boleto = boleto
                    self.eps = eps
                    self.fpx = fpx
                    self.giropay = giropay
                    self.grabpay = grabpay
                    self.ideal = ideal
                    self.interacPresent = interacPresent
                    self.klarna = klarna
                    self.metadata = metadata
                    self.oxxo = oxxo
                    self.p24 = p24
                    self.sepaDebit = sepaDebit
                    self.sofort = sofort
                    self.type = type
                    self.wechatPay = wechatPay
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(acssDebit, forKey: "acss_debit")
                    encoder.encode(afterpayClearpay, forKey: "afterpay_clearpay")
                    encoder.encode(alipay, forKey: "alipay")
                    encoder.encode(auBecsDebit, forKey: "au_becs_debit")
                    encoder.encode(bacsDebit, forKey: "bacs_debit")
                    encoder.encode(bancontact, forKey: "bancontact")
                    encoder.encode(billingDetails, forKey: "billing_details")
                    encoder.encode(boleto, forKey: "boleto")
                    encoder.encode(eps, forKey: "eps")
                    encoder.encode(fpx, forKey: "fpx")
                    encoder.encode(giropay, forKey: "giropay")
                    encoder.encode(grabpay, forKey: "grabpay")
                    encoder.encode(ideal, forKey: "ideal")
                    encoder.encode(interacPresent, forKey: "interac_present")
                    encoder.encode(klarna, forKey: "klarna")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(oxxo, forKey: "oxxo")
                    encoder.encode(p24, forKey: "p24")
                    encoder.encode(sepaDebit, forKey: "sepa_debit")
                    encoder.encode(sofort, forKey: "sofort")
                    encoder.encode(type, forKey: "type")
                    encoder.encode(wechatPay, forKey: "wechat_pay")
                    return encoder.items
                }
            }

            /// Payment_method_options_param
            ///
            /// Payment-method-specific configuration for this PaymentIntent.
            public struct PaymentMethodOptions: Encodable {
                public var acssDebit: AcssDebit?
                public var afterpayClearpay: AfterpayClearpay?
                public var alipay: Alipay?
                public var bancontact: Bancontact?
                public var boleto: Boleto?
                public var card: Card?
                public var cardPresent: CardPresent?
                public var giropay: Giropay?
                public var ideal: Ideal?
                public var interacPresent: InteracPresent?
                public var klarna: Klarna?
                public var oxxo: Oxxo?
                public var p24: P24?
                public var sepaDebit: SepaDebit?
                public var sofort: Sofort?
                public var wechatPay: WechatPay?

                public struct AcssDebit: Encodable {
                    /// Payment_intent_payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_intent_payment_method_options_param
                    public struct A: Encodable {
                        /// Payment_intent_payment_method_options_mandate_options_param
                        public var mandateOptions: MandateOptions?
                        public var verificationMethod: VerificationMethod?

                        /// Payment_intent_payment_method_options_mandate_options_param
                        public struct MandateOptions: Encodable {
                            public var customMandateURL: CustomMandateURL?
                            public var intervalDescription: String?
                            public var paymentSchedule: PaymentSchedule?
                            public var transactionType: TransactionType?

                            public struct CustomMandateURL: Encodable {
                                public var string: String?
                                public var object: Object?

                                public enum Object: String, Codable, CaseIterable {
                                    case empty = ""
                                }

                                public init(string: String? = nil, object: Object? = nil) {
                                    self.string = string
                                    self.object = object
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(string, forKey: "string")
                                    encoder.encode(object, forKey: "object")
                                    return encoder.items
                                }
                            }

                            public enum PaymentSchedule: String, Codable, CaseIterable {
                                case combined
                                case interval
                                case sporadic
                            }

                            public enum TransactionType: String, Codable, CaseIterable {
                                case business
                                case personal
                            }

                            public init(customMandateURL: CustomMandateURL? = nil, intervalDescription: String? = nil, paymentSchedule: PaymentSchedule? = nil, transactionType: TransactionType? = nil) {
                                self.customMandateURL = customMandateURL
                                self.intervalDescription = intervalDescription
                                self.paymentSchedule = paymentSchedule
                                self.transactionType = transactionType
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(customMandateURL, forKey: "custom_mandate_url")
                                encoder.encode(intervalDescription, forKey: "interval_description")
                                encoder.encode(paymentSchedule, forKey: "payment_schedule")
                                encoder.encode(transactionType, forKey: "transaction_type")
                                return encoder.items
                            }
                        }

                        public enum VerificationMethod: String, Codable, CaseIterable {
                            case automatic
                            case instant
                            case microdeposits
                        }

                        public init(mandateOptions: MandateOptions? = nil, verificationMethod: VerificationMethod? = nil) {
                            self.mandateOptions = mandateOptions
                            self.verificationMethod = verificationMethod
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(mandateOptions, forKey: "mandate_options")
                            encoder.encode(verificationMethod, forKey: "verification_method")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct AfterpayClearpay: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var reference: String?

                        public init(reference: String? = nil) {
                            self.reference = reference
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(reference, forKey: "reference")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Alipay: Encodable {
                    /// Payment_method_options_param
                    public var object: [String: AnyJSON]?
                    public var object2: Object2?

                    public enum Object2: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(object: [String: AnyJSON]? = nil, object2: Object2? = nil) {
                        self.object = object
                        self.object2 = object2
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object, forKey: "object")
                        encoder.encode(object2, forKey: "object2")
                        return encoder.items
                    }
                }

                public struct Bancontact: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var preferredLanguage: PreferredLanguage?

                        public enum PreferredLanguage: String, Codable, CaseIterable {
                            case de
                            case en
                            case fr
                            case nl
                        }

                        public init(preferredLanguage: PreferredLanguage? = nil) {
                            self.preferredLanguage = preferredLanguage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(preferredLanguage, forKey: "preferred_language")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Boleto: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var expiresAfterDays: Int?

                        public init(expiresAfterDays: Int? = nil) {
                            self.expiresAfterDays = expiresAfterDays
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(expiresAfterDays, forKey: "expires_after_days")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Card: Encodable {
                    /// Payment_intent_param
                    public var a: A?
                    public var b: B?

                    /// Payment_intent_param
                    public struct A: Encodable {
                        public var cvcToken: String?
                        /// Installments_param
                        public var installments: Installments?
                        public var network: Network?
                        public var requestThreeDSecure: RequestThreeDSecure?
                        public var setupFutureUsage: SetupFutureUsage?

                        /// Installments_param
                        public struct Installments: Encodable {
                            public var isEnabled: Bool?
                            public var plan: Plan?

                            public struct Plan: Encodable {
                                /// Installment_plan
                                public var a: A?
                                public var b: B?

                                /// Installment_plan
                                public struct A: Encodable {
                                    public var count: Int
                                    public var interval: Interval
                                    public var type: `Type`

                                    public enum Interval: String, Codable, CaseIterable {
                                        case month
                                    }

                                    public enum `Type`: String, Codable, CaseIterable {
                                        case fixedCount = "fixed_count"
                                    }

                                    public init(count: Int, interval: Interval, type: `Type`) {
                                        self.count = count
                                        self.interval = interval
                                        self.type = type
                                    }

                                    public var asQuery: [(String, String?)] {
                                        let encoder = URLQueryEncoder()
                                        encoder.encode(count, forKey: "count")
                                        encoder.encode(interval, forKey: "interval")
                                        encoder.encode(type, forKey: "type")
                                        return encoder.items
                                    }
                                }

                                public enum B: String, Codable, CaseIterable {
                                    case empty = ""
                                }

                                public init(a: A? = nil, b: B? = nil) {
                                    self.a = a
                                    self.b = b
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(a, forKey: "a")
                                    encoder.encode(b, forKey: "b")
                                    return encoder.items
                                }
                            }

                            public init(isEnabled: Bool? = nil, plan: Plan? = nil) {
                                self.isEnabled = isEnabled
                                self.plan = plan
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(isEnabled, forKey: "enabled")
                                encoder.encode(plan, forKey: "plan")
                                return encoder.items
                            }
                        }

                        public enum Network: String, Codable, CaseIterable {
                            case amex
                            case cartesBancaires = "cartes_bancaires"
                            case diners
                            case discover
                            case interac
                            case jcb
                            case mastercard
                            case unionpay
                            case unknown
                            case visa
                        }

                        public enum RequestThreeDSecure: String, Codable, CaseIterable {
                            case any
                            case automatic
                        }

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case empty = ""
                            case `none`
                            case offSession = "off_session"
                            case onSession = "on_session"
                        }

                        public init(cvcToken: String? = nil, installments: Installments? = nil, network: Network? = nil, requestThreeDSecure: RequestThreeDSecure? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                            self.cvcToken = cvcToken
                            self.installments = installments
                            self.network = network
                            self.requestThreeDSecure = requestThreeDSecure
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(cvcToken, forKey: "cvc_token")
                            encoder.encode(installments, forKey: "installments")
                            encoder.encode(network, forKey: "network")
                            encoder.encode(requestThreeDSecure, forKey: "request_three_d_secure")
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct CardPresent: Encodable {
                    /// Payment_method_options_param
                    public var object: [String: AnyJSON]?
                    public var object2: Object2?

                    public enum Object2: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(object: [String: AnyJSON]? = nil, object2: Object2? = nil) {
                        self.object = object
                        self.object2 = object2
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object, forKey: "object")
                        encoder.encode(object2, forKey: "object2")
                        return encoder.items
                    }
                }

                public struct Giropay: Encodable {
                    /// Payment_method_options_param
                    public var object: [String: AnyJSON]?
                    public var object2: Object2?

                    public enum Object2: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(object: [String: AnyJSON]? = nil, object2: Object2? = nil) {
                        self.object = object
                        self.object2 = object2
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object, forKey: "object")
                        encoder.encode(object2, forKey: "object2")
                        return encoder.items
                    }
                }

                public struct Ideal: Encodable {
                    /// Payment_method_options_param
                    public var object: [String: AnyJSON]?
                    public var object2: Object2?

                    public enum Object2: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(object: [String: AnyJSON]? = nil, object2: Object2? = nil) {
                        self.object = object
                        self.object2 = object2
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object, forKey: "object")
                        encoder.encode(object2, forKey: "object2")
                        return encoder.items
                    }
                }

                public struct InteracPresent: Encodable {
                    /// Payment_method_options_param
                    public var object: [String: AnyJSON]?
                    public var object2: Object2?

                    public enum Object2: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(object: [String: AnyJSON]? = nil, object2: Object2? = nil) {
                        self.object = object
                        self.object2 = object2
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object, forKey: "object")
                        encoder.encode(object2, forKey: "object2")
                        return encoder.items
                    }
                }

                public struct Klarna: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var preferredLocale: PreferredLocale?

                        public enum PreferredLocale: String, Codable, CaseIterable {
                            case daDK = "da-DK"
                            case deAT = "de-AT"
                            case deDE = "de-DE"
                            case enAT = "en-AT"
                            case enBE = "en-BE"
                            case enDE = "en-DE"
                            case enDK = "en-DK"
                            case enES = "en-ES"
                            case enFI = "en-FI"
                            case enGB = "en-GB"
                            case enIE = "en-IE"
                            case enIT = "en-IT"
                            case enNL = "en-NL"
                            case enNO = "en-NO"
                            case enSE = "en-SE"
                            case enUS = "en-US"
                            case esES = "es-ES"
                            case fiFI = "fi-FI"
                            case frBE = "fr-BE"
                            case itIT = "it-IT"
                            case nbNO = "nb-NO"
                            case nlBE = "nl-BE"
                            case nlNL = "nl-NL"
                            case svFI = "sv-FI"
                            case svSE = "sv-SE"
                        }

                        public init(preferredLocale: PreferredLocale? = nil) {
                            self.preferredLocale = preferredLocale
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(preferredLocale, forKey: "preferred_locale")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Oxxo: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var expiresAfterDays: Int?

                        public init(expiresAfterDays: Int? = nil) {
                            self.expiresAfterDays = expiresAfterDays
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(expiresAfterDays, forKey: "expires_after_days")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct P24: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var isTosShownAndAccepted: Bool?

                        public init(isTosShownAndAccepted: Bool? = nil) {
                            self.isTosShownAndAccepted = isTosShownAndAccepted
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(isTosShownAndAccepted, forKey: "tos_shown_and_accepted")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct SepaDebit: Encodable {
                    /// Payment_intent_payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_intent_payment_method_options_param
                    public struct A: Encodable {
                        /// Payment_method_options_mandate_options_param
                        public var mandateOptions: [String: AnyJSON]?

                        public init(mandateOptions: [String: AnyJSON]? = nil) {
                            self.mandateOptions = mandateOptions
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(mandateOptions, forKey: "mandate_options")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Sofort: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var preferredLanguage: PreferredLanguage?

                        public enum PreferredLanguage: String, Codable, CaseIterable {
                            case empty = ""
                            case de
                            case en
                            case es
                            case fr
                            case it
                            case nl
                            case pl
                        }

                        public init(preferredLanguage: PreferredLanguage? = nil) {
                            self.preferredLanguage = preferredLanguage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(preferredLanguage, forKey: "preferred_language")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct WechatPay: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var appID: String?
                        public var client: Client

                        public enum Client: String, Codable, CaseIterable {
                            case android
                            case ios
                            case web
                        }

                        public init(appID: String? = nil, client: Client) {
                            self.appID = appID
                            self.client = client
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(appID, forKey: "app_id")
                            encoder.encode(client, forKey: "client")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public init(acssDebit: AcssDebit? = nil, afterpayClearpay: AfterpayClearpay? = nil, alipay: Alipay? = nil, bancontact: Bancontact? = nil, boleto: Boleto? = nil, card: Card? = nil, cardPresent: CardPresent? = nil, giropay: Giropay? = nil, ideal: Ideal? = nil, interacPresent: InteracPresent? = nil, klarna: Klarna? = nil, oxxo: Oxxo? = nil, p24: P24? = nil, sepaDebit: SepaDebit? = nil, sofort: Sofort? = nil, wechatPay: WechatPay? = nil) {
                    self.acssDebit = acssDebit
                    self.afterpayClearpay = afterpayClearpay
                    self.alipay = alipay
                    self.bancontact = bancontact
                    self.boleto = boleto
                    self.card = card
                    self.cardPresent = cardPresent
                    self.giropay = giropay
                    self.ideal = ideal
                    self.interacPresent = interacPresent
                    self.klarna = klarna
                    self.oxxo = oxxo
                    self.p24 = p24
                    self.sepaDebit = sepaDebit
                    self.sofort = sofort
                    self.wechatPay = wechatPay
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(acssDebit, forKey: "acss_debit")
                    encoder.encode(afterpayClearpay, forKey: "afterpay_clearpay")
                    encoder.encode(alipay, forKey: "alipay")
                    encoder.encode(bancontact, forKey: "bancontact")
                    encoder.encode(boleto, forKey: "boleto")
                    encoder.encode(card, forKey: "card")
                    encoder.encode(cardPresent, forKey: "card_present")
                    encoder.encode(giropay, forKey: "giropay")
                    encoder.encode(ideal, forKey: "ideal")
                    encoder.encode(interacPresent, forKey: "interac_present")
                    encoder.encode(klarna, forKey: "klarna")
                    encoder.encode(oxxo, forKey: "oxxo")
                    encoder.encode(p24, forKey: "p24")
                    encoder.encode(sepaDebit, forKey: "sepa_debit")
                    encoder.encode(sofort, forKey: "sofort")
                    encoder.encode(wechatPay, forKey: "wechat_pay")
                    return encoder.items
                }
            }

            /// Email address that the receipt for the resulting payment will be sent to. If `receipt_email` is specified for a payment in live mode, a receipt will be sent regardless of your [email settings](https://dashboard.stripe.com/account/emails).
            public struct ReceiptEmail: Encodable {
                public var string: String?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(string: String? = nil, object: Object? = nil) {
                    self.string = string
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(string, forKey: "string")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Indicates that you intend to make future payments with this PaymentIntent's payment method.
            /// 
            /// Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent's Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.
            /// 
            /// When processing card payments, Stripe also uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).
            /// 
            /// If `setup_future_usage` is already set and you are performing a request using a publishable key, you may only update the value from `on_session` to `off_session`.
            public enum SetupFutureUsage: String, Codable, CaseIterable {
                case empty = ""
                case offSession = "off_session"
                case onSession = "on_session"
            }

            /// Shipping information for this PaymentIntent.
            public struct Shipping: Encodable {
                /// Optional_fields_shipping
                public var a: A?
                public var b: B?

                /// Optional_fields_shipping
                public struct A: Encodable {
                    /// Optional_fields_address
                    public var address: Address
                    public var carrier: String?
                    public var name: String
                    public var phone: String?
                    public var trackingNumber: String?

                    /// Optional_fields_address
                    public struct Address: Encodable {
                        public var city: String?
                        public var country: String?
                        public var line1: String?
                        public var line2: String?
                        public var postalCode: String?
                        public var state: String?

                        public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                            self.city = city
                            self.country = country
                            self.line1 = line1
                            self.line2 = line2
                            self.postalCode = postalCode
                            self.state = state
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(city, forKey: "city")
                            encoder.encode(country, forKey: "country")
                            encoder.encode(line1, forKey: "line1")
                            encoder.encode(line2, forKey: "line2")
                            encoder.encode(postalCode, forKey: "postal_code")
                            encoder.encode(state, forKey: "state")
                            return encoder.items
                        }
                    }

                    public init(address: Address, carrier: String? = nil, name: String, phone: String? = nil, trackingNumber: String? = nil) {
                        self.address = address
                        self.carrier = carrier
                        self.name = name
                        self.phone = phone
                        self.trackingNumber = trackingNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(address, forKey: "address")
                        encoder.encode(carrier, forKey: "carrier")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(phone, forKey: "phone")
                        encoder.encode(trackingNumber, forKey: "tracking_number")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Transfer_data_update_params
            ///
            /// The parameters used to automatically create a Transfer when the payment succeeds. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
            public struct TransferData: Encodable {
                public var amount: Int?

                public init(amount: Int? = nil) {
                    self.amount = amount
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(amount, forKey: "amount")
                    return encoder.items
                }
            }

            public init(amount: Int? = nil, applicationFeeAmount: ApplicationFeeAmount? = nil, currency: String? = nil, customer: String? = nil, description: String? = nil, expand: [String]? = nil, metadata: Metadata? = nil, paymentMethod: String? = nil, paymentMethodData: PaymentMethodData? = nil, paymentMethodOptions: PaymentMethodOptions? = nil, paymentMethodTypes: [String]? = nil, receiptEmail: ReceiptEmail? = nil, setupFutureUsage: SetupFutureUsage? = nil, shipping: Shipping? = nil, statementDescriptor: String? = nil, statementDescriptorSuffix: String? = nil, transferData: TransferData? = nil, transferGroup: String? = nil) {
                self.amount = amount
                self.applicationFeeAmount = applicationFeeAmount
                self.currency = currency
                self.customer = customer
                self.description = description
                self.expand = expand
                self.metadata = metadata
                self.paymentMethod = paymentMethod
                self.paymentMethodData = paymentMethodData
                self.paymentMethodOptions = paymentMethodOptions
                self.paymentMethodTypes = paymentMethodTypes
                self.receiptEmail = receiptEmail
                self.setupFutureUsage = setupFutureUsage
                self.shipping = shipping
                self.statementDescriptor = statementDescriptor
                self.statementDescriptorSuffix = statementDescriptorSuffix
                self.transferData = transferData
                self.transferGroup = transferGroup
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(applicationFeeAmount, forKey: "application_fee_amount")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(description, forKey: "description")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(paymentMethod, forKey: "payment_method")
                encoder.encode(paymentMethodData, forKey: "payment_method_data")
                encoder.encode(paymentMethodOptions, forKey: "payment_method_options")
                encoder.encode(paymentMethodTypes, forKey: "payment_method_types")
                encoder.encode(receiptEmail, forKey: "receipt_email")
                encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                encoder.encode(shipping, forKey: "shipping")
                encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                encoder.encode(statementDescriptorSuffix, forKey: "statement_descriptor_suffix")
                encoder.encode(transferData, forKey: "transfer_data")
                encoder.encode(transferGroup, forKey: "transfer_group")
                return encoder.items
            }
        }
    }
}

extension Paths.PaymentIntents.WithIntent {
    public var cancel: Cancel {
        Cancel(path: path + "/cancel")
    }

    public struct Cancel {
        /// Path: `/v1/payment_intents/{intent}/cancel`
        public let path: String

        /// <p>A PaymentIntent object can be canceled when it is in one of these statuses: <code>requires_payment_method</code>, <code>requires_capture</code>, <code>requires_confirmation</code>, <code>requires_action</code>, or <code>processing</code>. </p>
        /// 
        /// <p>Once canceled, no additional charges will be made by the PaymentIntent and any operations on the PaymentIntent will fail with an error. For PaymentIntents with <code>status=’requires_capture’</code>, the remaining <code>amount_capturable</code> will automatically be refunded.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.PaymentIntent> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Reason for canceling this PaymentIntent. Possible values are `duplicate`, `fraudulent`, `requested_by_customer`, or `abandoned`
            public var cancellationReason: CancellationReason?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            /// Reason for canceling this PaymentIntent. Possible values are `duplicate`, `fraudulent`, `requested_by_customer`, or `abandoned`
            public enum CancellationReason: String, Codable, CaseIterable {
                case abandoned
                case duplicate
                case fraudulent
                case requestedByCustomer = "requested_by_customer"
            }

            public init(cancellationReason: CancellationReason? = nil, expand: [String]? = nil) {
                self.cancellationReason = cancellationReason
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(cancellationReason, forKey: "cancellation_reason")
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.PaymentIntents.WithIntent {
    public var capture: Capture {
        Capture(path: path + "/capture")
    }

    public struct Capture {
        /// Path: `/v1/payment_intents/{intent}/capture`
        public let path: String

        /// <p>Capture the funds of an existing uncaptured PaymentIntent when its status is <code>requires_capture</code>.</p>
        /// 
        /// <p>Uncaptured PaymentIntents will be canceled a set number of days after they are created (7 by default).</p>
        /// 
        /// <p>Learn more about <a href="/docs/payments/capture-later">separate authorization and capture</a>.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.PaymentIntent> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The amount to capture from the PaymentIntent, which must be less than or equal to the original amount. Any additional amount will be automatically refunded. Defaults to the full `amount_capturable` if not provided.
            public var amountToCapture: Int?
            /// The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. The amount of the application fee collected will be capped at the total payment amount. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
            public var applicationFeeAmount: Int?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
            public var statementDescriptor: String?
            /// Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
            public var statementDescriptorSuffix: String?
            /// Transfer_data_update_params
            ///
            /// The parameters used to automatically create a Transfer when the payment
            /// is captured. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
            public var transferData: TransferData?

            /// Transfer_data_update_params
            ///
            /// The parameters used to automatically create a Transfer when the payment
            /// is captured. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
            public struct TransferData: Encodable {
                public var amount: Int?

                public init(amount: Int? = nil) {
                    self.amount = amount
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(amount, forKey: "amount")
                    return encoder.items
                }
            }

            public init(amountToCapture: Int? = nil, applicationFeeAmount: Int? = nil, expand: [String]? = nil, statementDescriptor: String? = nil, statementDescriptorSuffix: String? = nil, transferData: TransferData? = nil) {
                self.amountToCapture = amountToCapture
                self.applicationFeeAmount = applicationFeeAmount
                self.expand = expand
                self.statementDescriptor = statementDescriptor
                self.statementDescriptorSuffix = statementDescriptorSuffix
                self.transferData = transferData
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amountToCapture, forKey: "amount_to_capture")
                encoder.encode(applicationFeeAmount, forKey: "application_fee_amount")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                encoder.encode(statementDescriptorSuffix, forKey: "statement_descriptor_suffix")
                encoder.encode(transferData, forKey: "transfer_data")
                return encoder.items
            }
        }
    }
}

extension Paths.PaymentIntents.WithIntent {
    public var confirm: Confirm {
        Confirm(path: path + "/confirm")
    }

    public struct Confirm {
        /// Path: `/v1/payment_intents/{intent}/confirm`
        public let path: String

        /// <p>Confirm that your customer intends to pay with current or provided
        /// payment method. Upon confirmation, the PaymentIntent will attempt to initiate
        /// a payment.</p>
        /// 
        /// <p>If the selected payment method requires additional authentication steps, the
        /// PaymentIntent will transition to the <code>requires_action</code> status and
        /// suggest additional actions via <code>next_action</code>. If payment fails,
        /// the PaymentIntent will transition to the <code>requires_payment_method</code> status. If
        /// payment succeeds, the PaymentIntent will transition to the <code>succeeded</code>
        /// status (or <code>requires_capture</code>, if <code>capture_method</code> is set to <code>manual</code>).</p>
        /// 
        /// <p>If the <code>confirmation_method</code> is <code>automatic</code>, payment may be attempted
        /// using our <a href="/docs/stripe-js/reference#stripe-handle-card-payment">client SDKs</a>
        /// and the PaymentIntent’s <a href="#payment_intent_object-client_secret">client_secret</a>.
        /// After <code>next_action</code>s are handled by the client, no additional
        /// confirmation is required to complete the payment.</p>
        /// 
        /// <p>If the <code>confirmation_method</code> is <code>manual</code>, all payment attempts must be
        /// initiated using a secret key.
        /// If any actions are required for the payment, the PaymentIntent will
        /// return to the <code>requires_confirmation</code> state
        /// after those actions are completed. Your server needs to then
        /// explicitly re-confirm the PaymentIntent to initiate the next payment
        /// attempt. Read the <a href="/docs/payments/payment-intents/web-manual">expanded documentation</a>
        /// to learn more about manual confirmation.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.PaymentIntent> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The client secret of the PaymentIntent.
            public var clientSecret: String?
            /// Set to `true` to fail the payment attempt if the PaymentIntent transitions into `requires_action`. This parameter is intended for simpler integrations that do not handle customer actions, like [saving cards without authentication](https://stripe.com/docs/payments/save-card-without-authentication).
            public var errorOnRequiresAction: Bool?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// ID of the mandate to be used for this payment.
            public var mandate: String?
            /// This hash contains details about the Mandate to create
            public var mandateData: MandateData?
            /// Set to `true` to indicate that the customer is not in your checkout flow during this payment attempt, and therefore is unable to authenticate. This parameter is intended for scenarios where you collect card details and [charge them later](https://stripe.com/docs/payments/cards/charging-saved-cards).
            public var offSession: OffSession?
            /// ID of the payment method (a PaymentMethod, Card, or [compatible Source](https://stripe.com/docs/payments/payment-methods/transitioning#compatibility) object) to attach to this PaymentIntent.
            public var paymentMethod: String?
            /// Payment_method_data_params
            ///
            /// If provided, this hash will be used to create a PaymentMethod. The new PaymentMethod will appear
            /// in the [payment_method](https://stripe.com/docs/api/payment_intents/object#payment_intent_object-payment_method)
            /// property on the PaymentIntent.
            public var paymentMethodData: PaymentMethodData?
            /// Payment_method_options_param
            ///
            /// Payment-method-specific configuration for this PaymentIntent.
            public var paymentMethodOptions: PaymentMethodOptions?
            /// The list of payment method types (e.g. card) that this PaymentIntent is allowed to use.
            public var paymentMethodTypes: [String]?
            /// Email address that the receipt for the resulting payment will be sent to. If `receipt_email` is specified for a payment in live mode, a receipt will be sent regardless of your [email settings](https://dashboard.stripe.com/account/emails).
            public var receiptEmail: ReceiptEmail?
            /// The URL to redirect your customer back to after they authenticate or cancel their payment on the payment method's app or site.
            /// If you'd prefer to redirect to a mobile application, you can alternatively supply an application URI scheme.
            /// This parameter is only used for cards and other redirect-based payment methods.
            public var returnURL: String?
            /// Indicates that you intend to make future payments with this PaymentIntent's payment method.
            /// 
            /// Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent's Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.
            /// 
            /// When processing card payments, Stripe also uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).
            /// 
            /// If `setup_future_usage` is already set and you are performing a request using a publishable key, you may only update the value from `on_session` to `off_session`.
            public var setupFutureUsage: SetupFutureUsage?
            /// Shipping information for this PaymentIntent.
            public var shipping: Shipping?
            /// Set to `true` only when using manual confirmation and the iOS or Android SDKs to handle additional authentication steps.
            public var useStripeSdk: Bool?

            /// This hash contains details about the Mandate to create
            public struct MandateData: Encodable {
                /// Secret_key_param
                public var a: A?
                /// Client_key_param
                public var b: B?

                /// Secret_key_param
                public struct A: Encodable {
                    /// Customer_acceptance_param
                    public var customerAcceptance: CustomerAcceptance

                    /// Customer_acceptance_param
                    public struct CustomerAcceptance: Encodable {
                        public var acceptedAt: Int?
                        /// Offline_param
                        public var offline: [String: AnyJSON]?
                        /// Online_param
                        public var online: Online?
                        public var type: `Type`

                        /// Online_param
                        public struct Online: Encodable {
                            public var ipAddress: String
                            public var userAgent: String

                            public init(ipAddress: String, userAgent: String) {
                                self.ipAddress = ipAddress
                                self.userAgent = userAgent
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(ipAddress, forKey: "ip_address")
                                encoder.encode(userAgent, forKey: "user_agent")
                                return encoder.items
                            }
                        }

                        public enum `Type`: String, Codable, CaseIterable {
                            case offline
                            case online
                        }

                        public init(acceptedAt: Int? = nil, offline: [String: AnyJSON]? = nil, online: Online? = nil, type: `Type`) {
                            self.acceptedAt = acceptedAt
                            self.offline = offline
                            self.online = online
                            self.type = type
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(acceptedAt, forKey: "accepted_at")
                            encoder.encode(offline, forKey: "offline")
                            encoder.encode(online, forKey: "online")
                            encoder.encode(type, forKey: "type")
                            return encoder.items
                        }
                    }

                    public init(customerAcceptance: CustomerAcceptance) {
                        self.customerAcceptance = customerAcceptance
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(customerAcceptance, forKey: "customer_acceptance")
                        return encoder.items
                    }
                }

                /// Client_key_param
                public struct B: Encodable {
                    /// Customer_acceptance_param
                    public var customerAcceptance: CustomerAcceptance

                    /// Customer_acceptance_param
                    public struct CustomerAcceptance: Encodable {
                        /// Online_param
                        public var online: Online
                        public var type: `Type`

                        /// Online_param
                        public struct Online: Encodable {
                            public var ipAddress: String?
                            public var userAgent: String?

                            public init(ipAddress: String? = nil, userAgent: String? = nil) {
                                self.ipAddress = ipAddress
                                self.userAgent = userAgent
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(ipAddress, forKey: "ip_address")
                                encoder.encode(userAgent, forKey: "user_agent")
                                return encoder.items
                            }
                        }

                        public enum `Type`: String, Codable, CaseIterable {
                            case online
                        }

                        public init(online: Online, type: `Type`) {
                            self.online = online
                            self.type = type
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(online, forKey: "online")
                            encoder.encode(type, forKey: "type")
                            return encoder.items
                        }
                    }

                    public init(customerAcceptance: CustomerAcceptance) {
                        self.customerAcceptance = customerAcceptance
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(customerAcceptance, forKey: "customer_acceptance")
                        return encoder.items
                    }
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Set to `true` to indicate that the customer is not in your checkout flow during this payment attempt, and therefore is unable to authenticate. This parameter is intended for scenarios where you collect card details and [charge them later](https://stripe.com/docs/payments/cards/charging-saved-cards).
            public struct OffSession: Encodable {
                public var isBool: Bool?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case oneOff = "one_off"
                    case recurring
                }

                public init(isBool: Bool? = nil, object: Object? = nil) {
                    self.isBool = isBool
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isBool, forKey: "bool")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Payment_method_data_params
            ///
            /// If provided, this hash will be used to create a PaymentMethod. The new PaymentMethod will appear
            /// in the [payment_method](https://stripe.com/docs/api/payment_intents/object#payment_intent_object-payment_method)
            /// property on the PaymentIntent.
            public struct PaymentMethodData: Encodable {
                /// Payment_method_param
                public var acssDebit: AcssDebit?
                /// Param
                public var afterpayClearpay: [String: AnyJSON]?
                /// Param
                public var alipay: [String: AnyJSON]?
                /// Param
                public var auBecsDebit: AuBecsDebit?
                /// Param
                public var bacsDebit: BacsDebit?
                /// Param
                public var bancontact: [String: AnyJSON]?
                /// Billing_details_inner_params
                public var billingDetails: BillingDetails?
                /// Param
                public var boleto: Boleto?
                /// Param
                public var eps: Eps?
                /// Param
                public var fpx: Fpx?
                /// Param
                public var giropay: [String: AnyJSON]?
                /// Param
                public var grabpay: [String: AnyJSON]?
                /// Param
                public var ideal: Ideal?
                /// Param
                public var interacPresent: [String: AnyJSON]?
                /// Param
                public var klarna: Klarna?
                public var metadata: [String: String]?
                /// Param
                public var oxxo: [String: AnyJSON]?
                /// Param
                public var p24: P24?
                /// Param
                public var sepaDebit: SepaDebit?
                /// Param
                public var sofort: Sofort?
                public var type: `Type`
                /// Param
                public var wechatPay: [String: AnyJSON]?

                /// Payment_method_param
                public struct AcssDebit: Encodable {
                    public var accountNumber: String
                    public var institutionNumber: String
                    public var transitNumber: String

                    public init(accountNumber: String, institutionNumber: String, transitNumber: String) {
                        self.accountNumber = accountNumber
                        self.institutionNumber = institutionNumber
                        self.transitNumber = transitNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(institutionNumber, forKey: "institution_number")
                        encoder.encode(transitNumber, forKey: "transit_number")
                        return encoder.items
                    }
                }

                /// Param
                public struct AuBecsDebit: Encodable {
                    public var accountNumber: String
                    public var bsbNumber: String

                    public init(accountNumber: String, bsbNumber: String) {
                        self.accountNumber = accountNumber
                        self.bsbNumber = bsbNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(bsbNumber, forKey: "bsb_number")
                        return encoder.items
                    }
                }

                /// Param
                public struct BacsDebit: Encodable {
                    public var accountNumber: String?
                    public var sortCode: String?

                    public init(accountNumber: String? = nil, sortCode: String? = nil) {
                        self.accountNumber = accountNumber
                        self.sortCode = sortCode
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(accountNumber, forKey: "account_number")
                        encoder.encode(sortCode, forKey: "sort_code")
                        return encoder.items
                    }
                }

                /// Billing_details_inner_params
                public struct BillingDetails: Encodable {
                    public var address: Address?
                    public var email: Email?
                    public var name: String?
                    public var phone: String?

                    public struct Address: Encodable {
                        /// Billing_details_address
                        public var a: A?
                        public var b: B?

                        /// Billing_details_address
                        public struct A: Encodable {
                            public var city: String?
                            public var country: String?
                            public var line1: String?
                            public var line2: String?
                            public var postalCode: String?
                            public var state: String?

                            public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                                self.city = city
                                self.country = country
                                self.line1 = line1
                                self.line2 = line2
                                self.postalCode = postalCode
                                self.state = state
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(city, forKey: "city")
                                encoder.encode(country, forKey: "country")
                                encoder.encode(line1, forKey: "line1")
                                encoder.encode(line2, forKey: "line2")
                                encoder.encode(postalCode, forKey: "postal_code")
                                encoder.encode(state, forKey: "state")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct Email: Encodable {
                        public var string: String?
                        public var object: Object?

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(string: String? = nil, object: Object? = nil) {
                            self.string = string
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(string, forKey: "string")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public init(address: Address? = nil, email: Email? = nil, name: String? = nil, phone: String? = nil) {
                        self.address = address
                        self.email = email
                        self.name = name
                        self.phone = phone
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(address, forKey: "address")
                        encoder.encode(email, forKey: "email")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(phone, forKey: "phone")
                        return encoder.items
                    }
                }

                /// Param
                public struct Boleto: Encodable {
                    public var taxID: String

                    public init(taxID: String) {
                        self.taxID = taxID
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(taxID, forKey: "tax_id")
                        return encoder.items
                    }
                }

                /// Param
                public struct Eps: Encodable {
                    public var bank: Bank?

                    public enum Bank: String, Codable, CaseIterable {
                        case arzteUndApothekerBank = "arzte_und_apotheker_bank"
                        case austrianAnadiBankAg = "austrian_anadi_bank_ag"
                        case bankAustria = "bank_austria"
                        case bankhausCarlSpangler = "bankhaus_carl_spangler"
                        case bankhausSchelhammerUndSchatteraAg = "bankhaus_schelhammer_und_schattera_ag"
                        case bawagPskAg = "bawag_psk_ag"
                        case bksBankAg = "bks_bank_ag"
                        case brullKallmusBankAg = "brull_kallmus_bank_ag"
                        case btvVierLanderBank = "btv_vier_lander_bank"
                        case capitalBankGraweGruppeAg = "capital_bank_grawe_gruppe_ag"
                        case dolomitenbank
                        case easybankAg = "easybank_ag"
                        case ersteBankUndSparkassen = "erste_bank_und_sparkassen"
                        case hypoAlpeadriabankInternationalAg = "hypo_alpeadriabank_international_ag"
                        case hypoBankBurgenlandAktiengesellschaft = "hypo_bank_burgenland_aktiengesellschaft"
                        case hypoNoeLbFurNiederosterreichUWien = "hypo_noe_lb_fur_niederosterreich_u_wien"
                        case hypoOberosterreichSalzburgSteiermark = "hypo_oberosterreich_salzburg_steiermark"
                        case hypoTirolBankAg = "hypo_tirol_bank_ag"
                        case hypoVorarlbergBankAg = "hypo_vorarlberg_bank_ag"
                        case marchfelderBank = "marchfelder_bank"
                        case oberbankAg = "oberbank_ag"
                        case raiffeisenBankengruppeOsterreich = "raiffeisen_bankengruppe_osterreich"
                        case schoellerbankAg = "schoellerbank_ag"
                        case spardaBankWien = "sparda_bank_wien"
                        case volksbankGruppe = "volksbank_gruppe"
                        case volkskreditbankAg = "volkskreditbank_ag"
                        case vrBankBraunau = "vr_bank_braunau"
                    }

                    public init(bank: Bank? = nil) {
                        self.bank = bank
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(bank, forKey: "bank")
                        return encoder.items
                    }
                }

                /// Param
                public struct Fpx: Encodable {
                    public var bank: Bank

                    public enum Bank: String, Codable, CaseIterable {
                        case affinBank = "affin_bank"
                        case agrobank
                        case allianceBank = "alliance_bank"
                        case ambank
                        case bankIslam = "bank_islam"
                        case bankMuamalat = "bank_muamalat"
                        case bankRakyat = "bank_rakyat"
                        case bsn
                        case cimb
                        case deutscheBank = "deutsche_bank"
                        case hongLeongBank = "hong_leong_bank"
                        case hsbc
                        case kfh
                        case maybank2e
                        case maybank2u
                        case ocbc
                        case pbEnterprise = "pb_enterprise"
                        case publicBank = "public_bank"
                        case rhb
                        case standardChartered = "standard_chartered"
                        case uob
                    }

                    public init(bank: Bank) {
                        self.bank = bank
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(bank, forKey: "bank")
                        return encoder.items
                    }
                }

                /// Param
                public struct Ideal: Encodable {
                    public var bank: Bank?

                    public enum Bank: String, Codable, CaseIterable {
                        case abnAmro = "abn_amro"
                        case asnBank = "asn_bank"
                        case bunq
                        case handelsbanken
                        case ing
                        case knab
                        case moneyou
                        case rabobank
                        case regiobank
                        case revolut
                        case snsBank = "sns_bank"
                        case triodosBank = "triodos_bank"
                        case vanLanschot = "van_lanschot"
                    }

                    public init(bank: Bank? = nil) {
                        self.bank = bank
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(bank, forKey: "bank")
                        return encoder.items
                    }
                }

                /// Param
                public struct Klarna: Encodable {
                    /// Date_of_birth
                    public var dob: Dob?

                    /// Date_of_birth
                    public struct Dob: Encodable {
                        public var day: Int
                        public var month: Int
                        public var year: Int

                        public init(day: Int, month: Int, year: Int) {
                            self.day = day
                            self.month = month
                            self.year = year
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(day, forKey: "day")
                            encoder.encode(month, forKey: "month")
                            encoder.encode(year, forKey: "year")
                            return encoder.items
                        }
                    }

                    public init(dob: Dob? = nil) {
                        self.dob = dob
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(dob, forKey: "dob")
                        return encoder.items
                    }
                }

                /// Param
                public struct P24: Encodable {
                    public var bank: Bank?

                    public enum Bank: String, Codable, CaseIterable {
                        case aliorBank = "alior_bank"
                        case bankMillennium = "bank_millennium"
                        case bankNowyBfgSa = "bank_nowy_bfg_sa"
                        case bankPekaoSa = "bank_pekao_sa"
                        case bankiSpbdzielcze = "banki_spbdzielcze"
                        case blik
                        case bnpParibas = "bnp_paribas"
                        case boz
                        case citiHandlowy = "citi_handlowy"
                        case creditAgricole = "credit_agricole"
                        case envelobank
                        case etransferPocztowy24 = "etransfer_pocztowy24"
                        case getinBank = "getin_bank"
                        case ideabank
                        case ing
                        case inteligo
                        case mbankMtransfer = "mbank_mtransfer"
                        case nestPrzelew = "nest_przelew"
                        case noblePay = "noble_pay"
                        case pbacZIpko = "pbac_z_ipko"
                        case plusBank = "plus_bank"
                        case santanderPrzelew24 = "santander_przelew24"
                        case tmobileUsbugiBankowe = "tmobile_usbugi_bankowe"
                        case toyotaBank = "toyota_bank"
                        case volkswagenBank = "volkswagen_bank"
                    }

                    public init(bank: Bank? = nil) {
                        self.bank = bank
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(bank, forKey: "bank")
                        return encoder.items
                    }
                }

                /// Param
                public struct SepaDebit: Encodable {
                    public var iban: String

                    public init(iban: String) {
                        self.iban = iban
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(iban, forKey: "iban")
                        return encoder.items
                    }
                }

                /// Param
                public struct Sofort: Encodable {
                    public var country: Country

                    public enum Country: String, Codable, CaseIterable {
                        case at = "AT"
                        case be = "BE"
                        case de = "DE"
                        case es = "ES"
                        case it = "IT"
                        case nl = "NL"
                    }

                    public init(country: Country) {
                        self.country = country
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(country, forKey: "country")
                        return encoder.items
                    }
                }

                public enum `Type`: String, Codable, CaseIterable {
                    case acssDebit = "acss_debit"
                    case afterpayClearpay = "afterpay_clearpay"
                    case alipay
                    case auBecsDebit = "au_becs_debit"
                    case bacsDebit = "bacs_debit"
                    case bancontact
                    case boleto
                    case eps
                    case fpx
                    case giropay
                    case grabpay
                    case ideal
                    case klarna
                    case oxxo
                    case p24
                    case sepaDebit = "sepa_debit"
                    case sofort
                    case wechatPay = "wechat_pay"
                }

                public init(acssDebit: AcssDebit? = nil, afterpayClearpay: [String: AnyJSON]? = nil, alipay: [String: AnyJSON]? = nil, auBecsDebit: AuBecsDebit? = nil, bacsDebit: BacsDebit? = nil, bancontact: [String: AnyJSON]? = nil, billingDetails: BillingDetails? = nil, boleto: Boleto? = nil, eps: Eps? = nil, fpx: Fpx? = nil, giropay: [String: AnyJSON]? = nil, grabpay: [String: AnyJSON]? = nil, ideal: Ideal? = nil, interacPresent: [String: AnyJSON]? = nil, klarna: Klarna? = nil, metadata: [String: String]? = nil, oxxo: [String: AnyJSON]? = nil, p24: P24? = nil, sepaDebit: SepaDebit? = nil, sofort: Sofort? = nil, type: `Type`, wechatPay: [String: AnyJSON]? = nil) {
                    self.acssDebit = acssDebit
                    self.afterpayClearpay = afterpayClearpay
                    self.alipay = alipay
                    self.auBecsDebit = auBecsDebit
                    self.bacsDebit = bacsDebit
                    self.bancontact = bancontact
                    self.billingDetails = billingDetails
                    self.boleto = boleto
                    self.eps = eps
                    self.fpx = fpx
                    self.giropay = giropay
                    self.grabpay = grabpay
                    self.ideal = ideal
                    self.interacPresent = interacPresent
                    self.klarna = klarna
                    self.metadata = metadata
                    self.oxxo = oxxo
                    self.p24 = p24
                    self.sepaDebit = sepaDebit
                    self.sofort = sofort
                    self.type = type
                    self.wechatPay = wechatPay
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(acssDebit, forKey: "acss_debit")
                    encoder.encode(afterpayClearpay, forKey: "afterpay_clearpay")
                    encoder.encode(alipay, forKey: "alipay")
                    encoder.encode(auBecsDebit, forKey: "au_becs_debit")
                    encoder.encode(bacsDebit, forKey: "bacs_debit")
                    encoder.encode(bancontact, forKey: "bancontact")
                    encoder.encode(billingDetails, forKey: "billing_details")
                    encoder.encode(boleto, forKey: "boleto")
                    encoder.encode(eps, forKey: "eps")
                    encoder.encode(fpx, forKey: "fpx")
                    encoder.encode(giropay, forKey: "giropay")
                    encoder.encode(grabpay, forKey: "grabpay")
                    encoder.encode(ideal, forKey: "ideal")
                    encoder.encode(interacPresent, forKey: "interac_present")
                    encoder.encode(klarna, forKey: "klarna")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(oxxo, forKey: "oxxo")
                    encoder.encode(p24, forKey: "p24")
                    encoder.encode(sepaDebit, forKey: "sepa_debit")
                    encoder.encode(sofort, forKey: "sofort")
                    encoder.encode(type, forKey: "type")
                    encoder.encode(wechatPay, forKey: "wechat_pay")
                    return encoder.items
                }
            }

            /// Payment_method_options_param
            ///
            /// Payment-method-specific configuration for this PaymentIntent.
            public struct PaymentMethodOptions: Encodable {
                public var acssDebit: AcssDebit?
                public var afterpayClearpay: AfterpayClearpay?
                public var alipay: Alipay?
                public var bancontact: Bancontact?
                public var boleto: Boleto?
                public var card: Card?
                public var cardPresent: CardPresent?
                public var giropay: Giropay?
                public var ideal: Ideal?
                public var interacPresent: InteracPresent?
                public var klarna: Klarna?
                public var oxxo: Oxxo?
                public var p24: P24?
                public var sepaDebit: SepaDebit?
                public var sofort: Sofort?
                public var wechatPay: WechatPay?

                public struct AcssDebit: Encodable {
                    /// Payment_intent_payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_intent_payment_method_options_param
                    public struct A: Encodable {
                        /// Payment_intent_payment_method_options_mandate_options_param
                        public var mandateOptions: MandateOptions?
                        public var verificationMethod: VerificationMethod?

                        /// Payment_intent_payment_method_options_mandate_options_param
                        public struct MandateOptions: Encodable {
                            public var customMandateURL: CustomMandateURL?
                            public var intervalDescription: String?
                            public var paymentSchedule: PaymentSchedule?
                            public var transactionType: TransactionType?

                            public struct CustomMandateURL: Encodable {
                                public var string: String?
                                public var object: Object?

                                public enum Object: String, Codable, CaseIterable {
                                    case empty = ""
                                }

                                public init(string: String? = nil, object: Object? = nil) {
                                    self.string = string
                                    self.object = object
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(string, forKey: "string")
                                    encoder.encode(object, forKey: "object")
                                    return encoder.items
                                }
                            }

                            public enum PaymentSchedule: String, Codable, CaseIterable {
                                case combined
                                case interval
                                case sporadic
                            }

                            public enum TransactionType: String, Codable, CaseIterable {
                                case business
                                case personal
                            }

                            public init(customMandateURL: CustomMandateURL? = nil, intervalDescription: String? = nil, paymentSchedule: PaymentSchedule? = nil, transactionType: TransactionType? = nil) {
                                self.customMandateURL = customMandateURL
                                self.intervalDescription = intervalDescription
                                self.paymentSchedule = paymentSchedule
                                self.transactionType = transactionType
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(customMandateURL, forKey: "custom_mandate_url")
                                encoder.encode(intervalDescription, forKey: "interval_description")
                                encoder.encode(paymentSchedule, forKey: "payment_schedule")
                                encoder.encode(transactionType, forKey: "transaction_type")
                                return encoder.items
                            }
                        }

                        public enum VerificationMethod: String, Codable, CaseIterable {
                            case automatic
                            case instant
                            case microdeposits
                        }

                        public init(mandateOptions: MandateOptions? = nil, verificationMethod: VerificationMethod? = nil) {
                            self.mandateOptions = mandateOptions
                            self.verificationMethod = verificationMethod
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(mandateOptions, forKey: "mandate_options")
                            encoder.encode(verificationMethod, forKey: "verification_method")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct AfterpayClearpay: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var reference: String?

                        public init(reference: String? = nil) {
                            self.reference = reference
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(reference, forKey: "reference")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Alipay: Encodable {
                    /// Payment_method_options_param
                    public var object: [String: AnyJSON]?
                    public var object2: Object2?

                    public enum Object2: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(object: [String: AnyJSON]? = nil, object2: Object2? = nil) {
                        self.object = object
                        self.object2 = object2
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object, forKey: "object")
                        encoder.encode(object2, forKey: "object2")
                        return encoder.items
                    }
                }

                public struct Bancontact: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var preferredLanguage: PreferredLanguage?

                        public enum PreferredLanguage: String, Codable, CaseIterable {
                            case de
                            case en
                            case fr
                            case nl
                        }

                        public init(preferredLanguage: PreferredLanguage? = nil) {
                            self.preferredLanguage = preferredLanguage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(preferredLanguage, forKey: "preferred_language")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Boleto: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var expiresAfterDays: Int?

                        public init(expiresAfterDays: Int? = nil) {
                            self.expiresAfterDays = expiresAfterDays
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(expiresAfterDays, forKey: "expires_after_days")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Card: Encodable {
                    /// Payment_intent_param
                    public var a: A?
                    public var b: B?

                    /// Payment_intent_param
                    public struct A: Encodable {
                        public var cvcToken: String?
                        /// Installments_param
                        public var installments: Installments?
                        public var network: Network?
                        public var requestThreeDSecure: RequestThreeDSecure?
                        public var setupFutureUsage: SetupFutureUsage?

                        /// Installments_param
                        public struct Installments: Encodable {
                            public var isEnabled: Bool?
                            public var plan: Plan?

                            public struct Plan: Encodable {
                                /// Installment_plan
                                public var a: A?
                                public var b: B?

                                /// Installment_plan
                                public struct A: Encodable {
                                    public var count: Int
                                    public var interval: Interval
                                    public var type: `Type`

                                    public enum Interval: String, Codable, CaseIterable {
                                        case month
                                    }

                                    public enum `Type`: String, Codable, CaseIterable {
                                        case fixedCount = "fixed_count"
                                    }

                                    public init(count: Int, interval: Interval, type: `Type`) {
                                        self.count = count
                                        self.interval = interval
                                        self.type = type
                                    }

                                    public var asQuery: [(String, String?)] {
                                        let encoder = URLQueryEncoder()
                                        encoder.encode(count, forKey: "count")
                                        encoder.encode(interval, forKey: "interval")
                                        encoder.encode(type, forKey: "type")
                                        return encoder.items
                                    }
                                }

                                public enum B: String, Codable, CaseIterable {
                                    case empty = ""
                                }

                                public init(a: A? = nil, b: B? = nil) {
                                    self.a = a
                                    self.b = b
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(a, forKey: "a")
                                    encoder.encode(b, forKey: "b")
                                    return encoder.items
                                }
                            }

                            public init(isEnabled: Bool? = nil, plan: Plan? = nil) {
                                self.isEnabled = isEnabled
                                self.plan = plan
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(isEnabled, forKey: "enabled")
                                encoder.encode(plan, forKey: "plan")
                                return encoder.items
                            }
                        }

                        public enum Network: String, Codable, CaseIterable {
                            case amex
                            case cartesBancaires = "cartes_bancaires"
                            case diners
                            case discover
                            case interac
                            case jcb
                            case mastercard
                            case unionpay
                            case unknown
                            case visa
                        }

                        public enum RequestThreeDSecure: String, Codable, CaseIterable {
                            case any
                            case automatic
                        }

                        public enum SetupFutureUsage: String, Codable, CaseIterable {
                            case empty = ""
                            case `none`
                            case offSession = "off_session"
                            case onSession = "on_session"
                        }

                        public init(cvcToken: String? = nil, installments: Installments? = nil, network: Network? = nil, requestThreeDSecure: RequestThreeDSecure? = nil, setupFutureUsage: SetupFutureUsage? = nil) {
                            self.cvcToken = cvcToken
                            self.installments = installments
                            self.network = network
                            self.requestThreeDSecure = requestThreeDSecure
                            self.setupFutureUsage = setupFutureUsage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(cvcToken, forKey: "cvc_token")
                            encoder.encode(installments, forKey: "installments")
                            encoder.encode(network, forKey: "network")
                            encoder.encode(requestThreeDSecure, forKey: "request_three_d_secure")
                            encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct CardPresent: Encodable {
                    /// Payment_method_options_param
                    public var object: [String: AnyJSON]?
                    public var object2: Object2?

                    public enum Object2: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(object: [String: AnyJSON]? = nil, object2: Object2? = nil) {
                        self.object = object
                        self.object2 = object2
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object, forKey: "object")
                        encoder.encode(object2, forKey: "object2")
                        return encoder.items
                    }
                }

                public struct Giropay: Encodable {
                    /// Payment_method_options_param
                    public var object: [String: AnyJSON]?
                    public var object2: Object2?

                    public enum Object2: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(object: [String: AnyJSON]? = nil, object2: Object2? = nil) {
                        self.object = object
                        self.object2 = object2
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object, forKey: "object")
                        encoder.encode(object2, forKey: "object2")
                        return encoder.items
                    }
                }

                public struct Ideal: Encodable {
                    /// Payment_method_options_param
                    public var object: [String: AnyJSON]?
                    public var object2: Object2?

                    public enum Object2: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(object: [String: AnyJSON]? = nil, object2: Object2? = nil) {
                        self.object = object
                        self.object2 = object2
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object, forKey: "object")
                        encoder.encode(object2, forKey: "object2")
                        return encoder.items
                    }
                }

                public struct InteracPresent: Encodable {
                    /// Payment_method_options_param
                    public var object: [String: AnyJSON]?
                    public var object2: Object2?

                    public enum Object2: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(object: [String: AnyJSON]? = nil, object2: Object2? = nil) {
                        self.object = object
                        self.object2 = object2
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object, forKey: "object")
                        encoder.encode(object2, forKey: "object2")
                        return encoder.items
                    }
                }

                public struct Klarna: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var preferredLocale: PreferredLocale?

                        public enum PreferredLocale: String, Codable, CaseIterable {
                            case daDK = "da-DK"
                            case deAT = "de-AT"
                            case deDE = "de-DE"
                            case enAT = "en-AT"
                            case enBE = "en-BE"
                            case enDE = "en-DE"
                            case enDK = "en-DK"
                            case enES = "en-ES"
                            case enFI = "en-FI"
                            case enGB = "en-GB"
                            case enIE = "en-IE"
                            case enIT = "en-IT"
                            case enNL = "en-NL"
                            case enNO = "en-NO"
                            case enSE = "en-SE"
                            case enUS = "en-US"
                            case esES = "es-ES"
                            case fiFI = "fi-FI"
                            case frBE = "fr-BE"
                            case itIT = "it-IT"
                            case nbNO = "nb-NO"
                            case nlBE = "nl-BE"
                            case nlNL = "nl-NL"
                            case svFI = "sv-FI"
                            case svSE = "sv-SE"
                        }

                        public init(preferredLocale: PreferredLocale? = nil) {
                            self.preferredLocale = preferredLocale
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(preferredLocale, forKey: "preferred_locale")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Oxxo: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var expiresAfterDays: Int?

                        public init(expiresAfterDays: Int? = nil) {
                            self.expiresAfterDays = expiresAfterDays
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(expiresAfterDays, forKey: "expires_after_days")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct P24: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var isTosShownAndAccepted: Bool?

                        public init(isTosShownAndAccepted: Bool? = nil) {
                            self.isTosShownAndAccepted = isTosShownAndAccepted
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(isTosShownAndAccepted, forKey: "tos_shown_and_accepted")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct SepaDebit: Encodable {
                    /// Payment_intent_payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_intent_payment_method_options_param
                    public struct A: Encodable {
                        /// Payment_method_options_mandate_options_param
                        public var mandateOptions: [String: AnyJSON]?

                        public init(mandateOptions: [String: AnyJSON]? = nil) {
                            self.mandateOptions = mandateOptions
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(mandateOptions, forKey: "mandate_options")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Sofort: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var preferredLanguage: PreferredLanguage?

                        public enum PreferredLanguage: String, Codable, CaseIterable {
                            case empty = ""
                            case de
                            case en
                            case es
                            case fr
                            case it
                            case nl
                            case pl
                        }

                        public init(preferredLanguage: PreferredLanguage? = nil) {
                            self.preferredLanguage = preferredLanguage
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(preferredLanguage, forKey: "preferred_language")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct WechatPay: Encodable {
                    /// Payment_method_options_param
                    public var a: A?
                    public var b: B?

                    /// Payment_method_options_param
                    public struct A: Encodable {
                        public var appID: String?
                        public var client: Client

                        public enum Client: String, Codable, CaseIterable {
                            case android
                            case ios
                            case web
                        }

                        public init(appID: String? = nil, client: Client) {
                            self.appID = appID
                            self.client = client
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(appID, forKey: "app_id")
                            encoder.encode(client, forKey: "client")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public init(acssDebit: AcssDebit? = nil, afterpayClearpay: AfterpayClearpay? = nil, alipay: Alipay? = nil, bancontact: Bancontact? = nil, boleto: Boleto? = nil, card: Card? = nil, cardPresent: CardPresent? = nil, giropay: Giropay? = nil, ideal: Ideal? = nil, interacPresent: InteracPresent? = nil, klarna: Klarna? = nil, oxxo: Oxxo? = nil, p24: P24? = nil, sepaDebit: SepaDebit? = nil, sofort: Sofort? = nil, wechatPay: WechatPay? = nil) {
                    self.acssDebit = acssDebit
                    self.afterpayClearpay = afterpayClearpay
                    self.alipay = alipay
                    self.bancontact = bancontact
                    self.boleto = boleto
                    self.card = card
                    self.cardPresent = cardPresent
                    self.giropay = giropay
                    self.ideal = ideal
                    self.interacPresent = interacPresent
                    self.klarna = klarna
                    self.oxxo = oxxo
                    self.p24 = p24
                    self.sepaDebit = sepaDebit
                    self.sofort = sofort
                    self.wechatPay = wechatPay
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(acssDebit, forKey: "acss_debit")
                    encoder.encode(afterpayClearpay, forKey: "afterpay_clearpay")
                    encoder.encode(alipay, forKey: "alipay")
                    encoder.encode(bancontact, forKey: "bancontact")
                    encoder.encode(boleto, forKey: "boleto")
                    encoder.encode(card, forKey: "card")
                    encoder.encode(cardPresent, forKey: "card_present")
                    encoder.encode(giropay, forKey: "giropay")
                    encoder.encode(ideal, forKey: "ideal")
                    encoder.encode(interacPresent, forKey: "interac_present")
                    encoder.encode(klarna, forKey: "klarna")
                    encoder.encode(oxxo, forKey: "oxxo")
                    encoder.encode(p24, forKey: "p24")
                    encoder.encode(sepaDebit, forKey: "sepa_debit")
                    encoder.encode(sofort, forKey: "sofort")
                    encoder.encode(wechatPay, forKey: "wechat_pay")
                    return encoder.items
                }
            }

            /// Email address that the receipt for the resulting payment will be sent to. If `receipt_email` is specified for a payment in live mode, a receipt will be sent regardless of your [email settings](https://dashboard.stripe.com/account/emails).
            public struct ReceiptEmail: Encodable {
                public var string: String?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(string: String? = nil, object: Object? = nil) {
                    self.string = string
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(string, forKey: "string")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Indicates that you intend to make future payments with this PaymentIntent's payment method.
            /// 
            /// Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent's Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.
            /// 
            /// When processing card payments, Stripe also uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).
            /// 
            /// If `setup_future_usage` is already set and you are performing a request using a publishable key, you may only update the value from `on_session` to `off_session`.
            public enum SetupFutureUsage: String, Codable, CaseIterable {
                case empty = ""
                case offSession = "off_session"
                case onSession = "on_session"
            }

            /// Shipping information for this PaymentIntent.
            public struct Shipping: Encodable {
                /// Optional_fields_shipping
                public var a: A?
                public var b: B?

                /// Optional_fields_shipping
                public struct A: Encodable {
                    /// Optional_fields_address
                    public var address: Address
                    public var carrier: String?
                    public var name: String
                    public var phone: String?
                    public var trackingNumber: String?

                    /// Optional_fields_address
                    public struct Address: Encodable {
                        public var city: String?
                        public var country: String?
                        public var line1: String?
                        public var line2: String?
                        public var postalCode: String?
                        public var state: String?

                        public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                            self.city = city
                            self.country = country
                            self.line1 = line1
                            self.line2 = line2
                            self.postalCode = postalCode
                            self.state = state
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(city, forKey: "city")
                            encoder.encode(country, forKey: "country")
                            encoder.encode(line1, forKey: "line1")
                            encoder.encode(line2, forKey: "line2")
                            encoder.encode(postalCode, forKey: "postal_code")
                            encoder.encode(state, forKey: "state")
                            return encoder.items
                        }
                    }

                    public init(address: Address, carrier: String? = nil, name: String, phone: String? = nil, trackingNumber: String? = nil) {
                        self.address = address
                        self.carrier = carrier
                        self.name = name
                        self.phone = phone
                        self.trackingNumber = trackingNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(address, forKey: "address")
                        encoder.encode(carrier, forKey: "carrier")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(phone, forKey: "phone")
                        encoder.encode(trackingNumber, forKey: "tracking_number")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            public init(clientSecret: String? = nil, errorOnRequiresAction: Bool? = nil, expand: [String]? = nil, mandate: String? = nil, mandateData: MandateData? = nil, offSession: OffSession? = nil, paymentMethod: String? = nil, paymentMethodData: PaymentMethodData? = nil, paymentMethodOptions: PaymentMethodOptions? = nil, paymentMethodTypes: [String]? = nil, receiptEmail: ReceiptEmail? = nil, returnURL: String? = nil, setupFutureUsage: SetupFutureUsage? = nil, shipping: Shipping? = nil, useStripeSdk: Bool? = nil) {
                self.clientSecret = clientSecret
                self.errorOnRequiresAction = errorOnRequiresAction
                self.expand = expand
                self.mandate = mandate
                self.mandateData = mandateData
                self.offSession = offSession
                self.paymentMethod = paymentMethod
                self.paymentMethodData = paymentMethodData
                self.paymentMethodOptions = paymentMethodOptions
                self.paymentMethodTypes = paymentMethodTypes
                self.receiptEmail = receiptEmail
                self.returnURL = returnURL
                self.setupFutureUsage = setupFutureUsage
                self.shipping = shipping
                self.useStripeSdk = useStripeSdk
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(clientSecret, forKey: "client_secret")
                encoder.encode(errorOnRequiresAction, forKey: "error_on_requires_action")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(mandate, forKey: "mandate")
                encoder.encode(mandateData, forKey: "mandate_data")
                encoder.encode(offSession, forKey: "off_session")
                encoder.encode(paymentMethod, forKey: "payment_method")
                encoder.encode(paymentMethodData, forKey: "payment_method_data")
                encoder.encode(paymentMethodOptions, forKey: "payment_method_options")
                encoder.encode(paymentMethodTypes, forKey: "payment_method_types")
                encoder.encode(receiptEmail, forKey: "receipt_email")
                encoder.encode(returnURL, forKey: "return_url")
                encoder.encode(setupFutureUsage, forKey: "setup_future_usage")
                encoder.encode(shipping, forKey: "shipping")
                encoder.encode(useStripeSdk, forKey: "use_stripe_sdk")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var paymentMethods: PaymentMethods {
        PaymentMethods(path: "/v1/payment_methods")
    }

    public struct PaymentMethods {
        /// Path: `/v1/payment_methods`
        public let path: String

        /// <p>Returns a list of PaymentMethods. For listing a customer’s payment methods, you should use <a href="/docs/api/payment_methods/customer_list">List a Customer’s PaymentMethods</a></p>
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        /// PaymentFlowsPaymentMethodList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.PaymentMethod]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.PaymentMethod], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var customer: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?
            public var type: `Type`

            public enum `Type`: String, Codable, CaseIterable {
                case acssDebit = "acss_debit"
                case afterpayClearpay = "afterpay_clearpay"
                case alipay
                case auBecsDebit = "au_becs_debit"
                case bacsDebit = "bacs_debit"
                case bancontact
                case boleto
                case card
                case eps
                case fpx
                case giropay
                case grabpay
                case ideal
                case klarna
                case oxxo
                case p24
                case sepaDebit = "sepa_debit"
                case sofort
                case wechatPay = "wechat_pay"
            }

            public init(customer: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil, type: `Type`) {
                self.customer = customer
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
                self.type = type
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(customer, forKey: "customer")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(type, forKey: "type")
                return encoder.items
            }
        }

        /// <p>Creates a PaymentMethod object. Read the <a href="/docs/stripe-js/reference#stripe-create-payment-method">Stripe.js reference</a> to learn how to create PaymentMethods via Stripe.js.</p>
        /// 
        /// <p>Instead of creating a PaymentMethod directly, we recommend using the <a href="/docs/payments/accept-a-payment">PaymentIntents</a> API to accept a payment immediately or the <a href="/docs/payments/save-and-reuse">SetupIntent</a> API to collect payment method details ahead of a future payment.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.PaymentMethod> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Payment_method_param
            ///
            /// If this is an `acss_debit` PaymentMethod, this hash contains details about the ACSS Debit payment method.
            public var acssDebit: AcssDebit?
            /// Param
            ///
            /// If this is an `AfterpayClearpay` PaymentMethod, this hash contains details about the AfterpayClearpay payment method.
            public var afterpayClearpay: [String: AnyJSON]?
            /// Param
            ///
            /// If this is an `Alipay` PaymentMethod, this hash contains details about the Alipay payment method.
            public var alipay: [String: AnyJSON]?
            /// Param
            ///
            /// If this is an `au_becs_debit` PaymentMethod, this hash contains details about the bank account.
            public var auBecsDebit: AuBecsDebit?
            /// Param
            ///
            /// If this is a `bacs_debit` PaymentMethod, this hash contains details about the Bacs Direct Debit bank account.
            public var bacsDebit: BacsDebit?
            /// Param
            ///
            /// If this is a `bancontact` PaymentMethod, this hash contains details about the Bancontact payment method.
            public var bancontact: [String: AnyJSON]?
            /// Billing_details_inner_params
            ///
            /// Billing information associated with the PaymentMethod that may be used or required by particular types of payment methods.
            public var billingDetails: BillingDetails?
            /// Param
            ///
            /// If this is a `boleto` PaymentMethod, this hash contains details about the Boleto payment method.
            public var boleto: Boleto?
            /// If this is a `card` PaymentMethod, this hash contains the user's card details. For backwards compatibility, you can alternatively provide a Stripe token (e.g., for Apple Pay, Amex Express Checkout, or legacy Checkout) into the card hash with format `card: {token: "tok_visa"}`. When providing a card number, you must meet the requirements for [PCI compliance](https://stripe.com/docs/security#validating-pci-compliance). We strongly recommend using Stripe.js instead of interacting with this API directly.
            public var card: Card?
            /// The `Customer` to whom the original PaymentMethod is attached.
            public var customer: String?
            /// Param
            ///
            /// If this is an `eps` PaymentMethod, this hash contains details about the EPS payment method.
            public var eps: Eps?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Param
            ///
            /// If this is an `fpx` PaymentMethod, this hash contains details about the FPX payment method.
            public var fpx: Fpx?
            /// Param
            ///
            /// If this is a `giropay` PaymentMethod, this hash contains details about the Giropay payment method.
            public var giropay: [String: AnyJSON]?
            /// Param
            ///
            /// If this is a `grabpay` PaymentMethod, this hash contains details about the GrabPay payment method.
            public var grabpay: [String: AnyJSON]?
            /// Param
            ///
            /// If this is an `ideal` PaymentMethod, this hash contains details about the iDEAL payment method.
            public var ideal: Ideal?
            /// Param
            ///
            /// If this is an `interac_present` PaymentMethod, this hash contains details about the Interac Present payment method.
            public var interacPresent: [String: AnyJSON]?
            /// Param
            ///
            /// If this is a `klarna` PaymentMethod, this hash contains details about the Klarna payment method.
            public var klarna: Klarna?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// Param
            ///
            /// If this is an `oxxo` PaymentMethod, this hash contains details about the OXXO payment method.
            public var oxxo: [String: AnyJSON]?
            /// Param
            ///
            /// If this is a `p24` PaymentMethod, this hash contains details about the P24 payment method.
            public var p24: P24?
            /// The PaymentMethod to share.
            public var paymentMethod: String?
            /// Param
            ///
            /// If this is a `sepa_debit` PaymentMethod, this hash contains details about the SEPA debit bank account.
            public var sepaDebit: SepaDebit?
            /// Param
            ///
            /// If this is a `sofort` PaymentMethod, this hash contains details about the SOFORT payment method.
            public var sofort: Sofort?
            /// The type of the PaymentMethod. An additional hash is included on the PaymentMethod with a name matching this value. It contains additional information specific to the PaymentMethod type.
            public var type: `Type`?
            /// Param
            ///
            /// If this is an `wechat_pay` PaymentMethod, this hash contains details about the wechat_pay payment method.
            public var wechatPay: [String: AnyJSON]?

            /// Payment_method_param
            ///
            /// If this is an `acss_debit` PaymentMethod, this hash contains details about the ACSS Debit payment method.
            public struct AcssDebit: Encodable {
                public var accountNumber: String
                public var institutionNumber: String
                public var transitNumber: String

                public init(accountNumber: String, institutionNumber: String, transitNumber: String) {
                    self.accountNumber = accountNumber
                    self.institutionNumber = institutionNumber
                    self.transitNumber = transitNumber
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(accountNumber, forKey: "account_number")
                    encoder.encode(institutionNumber, forKey: "institution_number")
                    encoder.encode(transitNumber, forKey: "transit_number")
                    return encoder.items
                }
            }

            /// Param
            ///
            /// If this is an `au_becs_debit` PaymentMethod, this hash contains details about the bank account.
            public struct AuBecsDebit: Encodable {
                public var accountNumber: String
                public var bsbNumber: String

                public init(accountNumber: String, bsbNumber: String) {
                    self.accountNumber = accountNumber
                    self.bsbNumber = bsbNumber
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(accountNumber, forKey: "account_number")
                    encoder.encode(bsbNumber, forKey: "bsb_number")
                    return encoder.items
                }
            }

            /// Param
            ///
            /// If this is a `bacs_debit` PaymentMethod, this hash contains details about the Bacs Direct Debit bank account.
            public struct BacsDebit: Encodable {
                public var accountNumber: String?
                public var sortCode: String?

                public init(accountNumber: String? = nil, sortCode: String? = nil) {
                    self.accountNumber = accountNumber
                    self.sortCode = sortCode
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(accountNumber, forKey: "account_number")
                    encoder.encode(sortCode, forKey: "sort_code")
                    return encoder.items
                }
            }

            /// Billing_details_inner_params
            ///
            /// Billing information associated with the PaymentMethod that may be used or required by particular types of payment methods.
            public struct BillingDetails: Encodable {
                public var address: Address?
                public var email: Email?
                public var name: String?
                public var phone: String?

                public struct Address: Encodable {
                    /// Billing_details_address
                    public var a: A?
                    public var b: B?

                    /// Billing_details_address
                    public struct A: Encodable {
                        public var city: String?
                        public var country: String?
                        public var line1: String?
                        public var line2: String?
                        public var postalCode: String?
                        public var state: String?

                        public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                            self.city = city
                            self.country = country
                            self.line1 = line1
                            self.line2 = line2
                            self.postalCode = postalCode
                            self.state = state
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(city, forKey: "city")
                            encoder.encode(country, forKey: "country")
                            encoder.encode(line1, forKey: "line1")
                            encoder.encode(line2, forKey: "line2")
                            encoder.encode(postalCode, forKey: "postal_code")
                            encoder.encode(state, forKey: "state")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Email: Encodable {
                    public var string: String?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(string: String? = nil, object: Object? = nil) {
                        self.string = string
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(string, forKey: "string")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(address: Address? = nil, email: Email? = nil, name: String? = nil, phone: String? = nil) {
                    self.address = address
                    self.email = email
                    self.name = name
                    self.phone = phone
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(email, forKey: "email")
                    encoder.encode(name, forKey: "name")
                    encoder.encode(phone, forKey: "phone")
                    return encoder.items
                }
            }

            /// Param
            ///
            /// If this is a `boleto` PaymentMethod, this hash contains details about the Boleto payment method.
            public struct Boleto: Encodable {
                public var taxID: String

                public init(taxID: String) {
                    self.taxID = taxID
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(taxID, forKey: "tax_id")
                    return encoder.items
                }
            }

            /// If this is a `card` PaymentMethod, this hash contains the user's card details. For backwards compatibility, you can alternatively provide a Stripe token (e.g., for Apple Pay, Amex Express Checkout, or legacy Checkout) into the card hash with format `card: {token: "tok_visa"}`. When providing a card number, you must meet the requirements for [PCI compliance](https://stripe.com/docs/security#validating-pci-compliance). We strongly recommend using Stripe.js instead of interacting with this API directly.
            public struct Card: Encodable {
                /// Card_details_params
                public var a: A?
                /// Token_params
                public var b: B?

                /// Card_details_params
                public struct A: Encodable {
                    public var cvc: String?
                    public var expMonth: Int
                    public var expYear: Int
                    public var number: String

                    public init(cvc: String? = nil, expMonth: Int, expYear: Int, number: String) {
                        self.cvc = cvc
                        self.expMonth = expMonth
                        self.expYear = expYear
                        self.number = number
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(cvc, forKey: "cvc")
                        encoder.encode(expMonth, forKey: "exp_month")
                        encoder.encode(expYear, forKey: "exp_year")
                        encoder.encode(number, forKey: "number")
                        return encoder.items
                    }
                }

                /// Token_params
                public struct B: Encodable {
                    public var token: String

                    public init(token: String) {
                        self.token = token
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(token, forKey: "token")
                        return encoder.items
                    }
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Param
            ///
            /// If this is an `eps` PaymentMethod, this hash contains details about the EPS payment method.
            public struct Eps: Encodable {
                public var bank: Bank?

                public enum Bank: String, Codable, CaseIterable {
                    case arzteUndApothekerBank = "arzte_und_apotheker_bank"
                    case austrianAnadiBankAg = "austrian_anadi_bank_ag"
                    case bankAustria = "bank_austria"
                    case bankhausCarlSpangler = "bankhaus_carl_spangler"
                    case bankhausSchelhammerUndSchatteraAg = "bankhaus_schelhammer_und_schattera_ag"
                    case bawagPskAg = "bawag_psk_ag"
                    case bksBankAg = "bks_bank_ag"
                    case brullKallmusBankAg = "brull_kallmus_bank_ag"
                    case btvVierLanderBank = "btv_vier_lander_bank"
                    case capitalBankGraweGruppeAg = "capital_bank_grawe_gruppe_ag"
                    case dolomitenbank
                    case easybankAg = "easybank_ag"
                    case ersteBankUndSparkassen = "erste_bank_und_sparkassen"
                    case hypoAlpeadriabankInternationalAg = "hypo_alpeadriabank_international_ag"
                    case hypoBankBurgenlandAktiengesellschaft = "hypo_bank_burgenland_aktiengesellschaft"
                    case hypoNoeLbFurNiederosterreichUWien = "hypo_noe_lb_fur_niederosterreich_u_wien"
                    case hypoOberosterreichSalzburgSteiermark = "hypo_oberosterreich_salzburg_steiermark"
                    case hypoTirolBankAg = "hypo_tirol_bank_ag"
                    case hypoVorarlbergBankAg = "hypo_vorarlberg_bank_ag"
                    case marchfelderBank = "marchfelder_bank"
                    case oberbankAg = "oberbank_ag"
                    case raiffeisenBankengruppeOsterreich = "raiffeisen_bankengruppe_osterreich"
                    case schoellerbankAg = "schoellerbank_ag"
                    case spardaBankWien = "sparda_bank_wien"
                    case volksbankGruppe = "volksbank_gruppe"
                    case volkskreditbankAg = "volkskreditbank_ag"
                    case vrBankBraunau = "vr_bank_braunau"
                }

                public init(bank: Bank? = nil) {
                    self.bank = bank
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(bank, forKey: "bank")
                    return encoder.items
                }
            }

            /// Param
            ///
            /// If this is an `fpx` PaymentMethod, this hash contains details about the FPX payment method.
            public struct Fpx: Encodable {
                public var bank: Bank

                public enum Bank: String, Codable, CaseIterable {
                    case affinBank = "affin_bank"
                    case agrobank
                    case allianceBank = "alliance_bank"
                    case ambank
                    case bankIslam = "bank_islam"
                    case bankMuamalat = "bank_muamalat"
                    case bankRakyat = "bank_rakyat"
                    case bsn
                    case cimb
                    case deutscheBank = "deutsche_bank"
                    case hongLeongBank = "hong_leong_bank"
                    case hsbc
                    case kfh
                    case maybank2e
                    case maybank2u
                    case ocbc
                    case pbEnterprise = "pb_enterprise"
                    case publicBank = "public_bank"
                    case rhb
                    case standardChartered = "standard_chartered"
                    case uob
                }

                public init(bank: Bank) {
                    self.bank = bank
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(bank, forKey: "bank")
                    return encoder.items
                }
            }

            /// Param
            ///
            /// If this is an `ideal` PaymentMethod, this hash contains details about the iDEAL payment method.
            public struct Ideal: Encodable {
                public var bank: Bank?

                public enum Bank: String, Codable, CaseIterable {
                    case abnAmro = "abn_amro"
                    case asnBank = "asn_bank"
                    case bunq
                    case handelsbanken
                    case ing
                    case knab
                    case moneyou
                    case rabobank
                    case regiobank
                    case revolut
                    case snsBank = "sns_bank"
                    case triodosBank = "triodos_bank"
                    case vanLanschot = "van_lanschot"
                }

                public init(bank: Bank? = nil) {
                    self.bank = bank
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(bank, forKey: "bank")
                    return encoder.items
                }
            }

            /// Param
            ///
            /// If this is a `klarna` PaymentMethod, this hash contains details about the Klarna payment method.
            public struct Klarna: Encodable {
                /// Date_of_birth
                public var dob: Dob?

                /// Date_of_birth
                public struct Dob: Encodable {
                    public var day: Int
                    public var month: Int
                    public var year: Int

                    public init(day: Int, month: Int, year: Int) {
                        self.day = day
                        self.month = month
                        self.year = year
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(day, forKey: "day")
                        encoder.encode(month, forKey: "month")
                        encoder.encode(year, forKey: "year")
                        return encoder.items
                    }
                }

                public init(dob: Dob? = nil) {
                    self.dob = dob
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(dob, forKey: "dob")
                    return encoder.items
                }
            }

            /// Param
            ///
            /// If this is a `p24` PaymentMethod, this hash contains details about the P24 payment method.
            public struct P24: Encodable {
                public var bank: Bank?

                public enum Bank: String, Codable, CaseIterable {
                    case aliorBank = "alior_bank"
                    case bankMillennium = "bank_millennium"
                    case bankNowyBfgSa = "bank_nowy_bfg_sa"
                    case bankPekaoSa = "bank_pekao_sa"
                    case bankiSpbdzielcze = "banki_spbdzielcze"
                    case blik
                    case bnpParibas = "bnp_paribas"
                    case boz
                    case citiHandlowy = "citi_handlowy"
                    case creditAgricole = "credit_agricole"
                    case envelobank
                    case etransferPocztowy24 = "etransfer_pocztowy24"
                    case getinBank = "getin_bank"
                    case ideabank
                    case ing
                    case inteligo
                    case mbankMtransfer = "mbank_mtransfer"
                    case nestPrzelew = "nest_przelew"
                    case noblePay = "noble_pay"
                    case pbacZIpko = "pbac_z_ipko"
                    case plusBank = "plus_bank"
                    case santanderPrzelew24 = "santander_przelew24"
                    case tmobileUsbugiBankowe = "tmobile_usbugi_bankowe"
                    case toyotaBank = "toyota_bank"
                    case volkswagenBank = "volkswagen_bank"
                }

                public init(bank: Bank? = nil) {
                    self.bank = bank
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(bank, forKey: "bank")
                    return encoder.items
                }
            }

            /// Param
            ///
            /// If this is a `sepa_debit` PaymentMethod, this hash contains details about the SEPA debit bank account.
            public struct SepaDebit: Encodable {
                public var iban: String

                public init(iban: String) {
                    self.iban = iban
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(iban, forKey: "iban")
                    return encoder.items
                }
            }

            /// Param
            ///
            /// If this is a `sofort` PaymentMethod, this hash contains details about the SOFORT payment method.
            public struct Sofort: Encodable {
                public var country: Country

                public enum Country: String, Codable, CaseIterable {
                    case at = "AT"
                    case be = "BE"
                    case de = "DE"
                    case es = "ES"
                    case it = "IT"
                    case nl = "NL"
                }

                public init(country: Country) {
                    self.country = country
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(country, forKey: "country")
                    return encoder.items
                }
            }

            /// The type of the PaymentMethod. An additional hash is included on the PaymentMethod with a name matching this value. It contains additional information specific to the PaymentMethod type.
            public enum `Type`: String, Codable, CaseIterable {
                case acssDebit = "acss_debit"
                case afterpayClearpay = "afterpay_clearpay"
                case alipay
                case auBecsDebit = "au_becs_debit"
                case bacsDebit = "bacs_debit"
                case bancontact
                case boleto
                case card
                case eps
                case fpx
                case giropay
                case grabpay
                case ideal
                case klarna
                case oxxo
                case p24
                case sepaDebit = "sepa_debit"
                case sofort
                case wechatPay = "wechat_pay"
            }

            public init(acssDebit: AcssDebit? = nil, afterpayClearpay: [String: AnyJSON]? = nil, alipay: [String: AnyJSON]? = nil, auBecsDebit: AuBecsDebit? = nil, bacsDebit: BacsDebit? = nil, bancontact: [String: AnyJSON]? = nil, billingDetails: BillingDetails? = nil, boleto: Boleto? = nil, card: Card? = nil, customer: String? = nil, eps: Eps? = nil, expand: [String]? = nil, fpx: Fpx? = nil, giropay: [String: AnyJSON]? = nil, grabpay: [String: AnyJSON]? = nil, ideal: Ideal? = nil, interacPresent: [String: AnyJSON]? = nil, klarna: Klarna? = nil, metadata: [String: String]? = nil, oxxo: [String: AnyJSON]? = nil, p24: P24? = nil, paymentMethod: String? = nil, sepaDebit: SepaDebit? = nil, sofort: Sofort? = nil, type: `Type`? = nil, wechatPay: [String: AnyJSON]? = nil) {
                self.acssDebit = acssDebit
                self.afterpayClearpay = afterpayClearpay
                self.alipay = alipay
                self.auBecsDebit = auBecsDebit
                self.bacsDebit = bacsDebit
                self.bancontact = bancontact
                self.billingDetails = billingDetails
                self.boleto = boleto
                self.card = card
                self.customer = customer
                self.eps = eps
                self.expand = expand
                self.fpx = fpx
                self.giropay = giropay
                self.grabpay = grabpay
                self.ideal = ideal
                self.interacPresent = interacPresent
                self.klarna = klarna
                self.metadata = metadata
                self.oxxo = oxxo
                self.p24 = p24
                self.paymentMethod = paymentMethod
                self.sepaDebit = sepaDebit
                self.sofort = sofort
                self.type = type
                self.wechatPay = wechatPay
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(acssDebit, forKey: "acss_debit")
                encoder.encode(afterpayClearpay, forKey: "afterpay_clearpay")
                encoder.encode(alipay, forKey: "alipay")
                encoder.encode(auBecsDebit, forKey: "au_becs_debit")
                encoder.encode(bacsDebit, forKey: "bacs_debit")
                encoder.encode(bancontact, forKey: "bancontact")
                encoder.encode(billingDetails, forKey: "billing_details")
                encoder.encode(boleto, forKey: "boleto")
                encoder.encode(card, forKey: "card")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(eps, forKey: "eps")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(fpx, forKey: "fpx")
                encoder.encode(giropay, forKey: "giropay")
                encoder.encode(grabpay, forKey: "grabpay")
                encoder.encode(ideal, forKey: "ideal")
                encoder.encode(interacPresent, forKey: "interac_present")
                encoder.encode(klarna, forKey: "klarna")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(oxxo, forKey: "oxxo")
                encoder.encode(p24, forKey: "p24")
                encoder.encode(paymentMethod, forKey: "payment_method")
                encoder.encode(sepaDebit, forKey: "sepa_debit")
                encoder.encode(sofort, forKey: "sofort")
                encoder.encode(type, forKey: "type")
                encoder.encode(wechatPay, forKey: "wechat_pay")
                return encoder.items
            }
        }
    }
}

extension Paths.PaymentMethods {
    public func paymentMethod(_ paymentMethod: String) -> WithPaymentMethod {
        WithPaymentMethod(path: "\(path)/\(paymentMethod)")
    }

    public struct WithPaymentMethod {
        /// Path: `/v1/payment_methods/{payment_method}`
        public let path: String

        /// <p>Retrieves a PaymentMethod object.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.PaymentMethod> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates a PaymentMethod object. A PaymentMethod must be attached a customer to be updated.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.PaymentMethod> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Billing_details_inner_params
            ///
            /// Billing information associated with the PaymentMethod that may be used or required by particular types of payment methods.
            public var billingDetails: BillingDetails?
            /// Update_api_param
            ///
            /// If this is a `card` PaymentMethod, this hash contains the user's card details.
            public var card: Card?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?

            /// Billing_details_inner_params
            ///
            /// Billing information associated with the PaymentMethod that may be used or required by particular types of payment methods.
            public struct BillingDetails: Encodable {
                public var address: Address?
                public var email: Email?
                public var name: String?
                public var phone: String?

                public struct Address: Encodable {
                    /// Billing_details_address
                    public var a: A?
                    public var b: B?

                    /// Billing_details_address
                    public struct A: Encodable {
                        public var city: String?
                        public var country: String?
                        public var line1: String?
                        public var line2: String?
                        public var postalCode: String?
                        public var state: String?

                        public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                            self.city = city
                            self.country = country
                            self.line1 = line1
                            self.line2 = line2
                            self.postalCode = postalCode
                            self.state = state
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(city, forKey: "city")
                            encoder.encode(country, forKey: "country")
                            encoder.encode(line1, forKey: "line1")
                            encoder.encode(line2, forKey: "line2")
                            encoder.encode(postalCode, forKey: "postal_code")
                            encoder.encode(state, forKey: "state")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Email: Encodable {
                    public var string: String?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(string: String? = nil, object: Object? = nil) {
                        self.string = string
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(string, forKey: "string")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(address: Address? = nil, email: Email? = nil, name: String? = nil, phone: String? = nil) {
                    self.address = address
                    self.email = email
                    self.name = name
                    self.phone = phone
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(email, forKey: "email")
                    encoder.encode(name, forKey: "name")
                    encoder.encode(phone, forKey: "phone")
                    return encoder.items
                }
            }

            /// Update_api_param
            ///
            /// If this is a `card` PaymentMethod, this hash contains the user's card details.
            public struct Card: Encodable {
                public var expMonth: Int?
                public var expYear: Int?

                public init(expMonth: Int? = nil, expYear: Int? = nil) {
                    self.expMonth = expMonth
                    self.expYear = expYear
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(expMonth, forKey: "exp_month")
                    encoder.encode(expYear, forKey: "exp_year")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(billingDetails: BillingDetails? = nil, card: Card? = nil, expand: [String]? = nil, metadata: Metadata? = nil) {
                self.billingDetails = billingDetails
                self.card = card
                self.expand = expand
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(billingDetails, forKey: "billing_details")
                encoder.encode(card, forKey: "card")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths.PaymentMethods.WithPaymentMethod {
    public var attach: Attach {
        Attach(path: path + "/attach")
    }

    public struct Attach {
        /// Path: `/v1/payment_methods/{payment_method}/attach`
        public let path: String

        /// <p>Attaches a PaymentMethod object to a Customer.</p>
        /// 
        /// <p>To attach a new PaymentMethod to a customer for future payments, we recommend you use a <a href="/docs/api/setup_intents">SetupIntent</a>
        /// or a PaymentIntent with <a href="/docs/api/payment_intents/create#create_payment_intent-setup_future_usage">setup_future_usage</a>.
        /// These approaches will perform any necessary steps to ensure that the PaymentMethod can be used in a future payment. Using the
        /// <code>/v1/payment_methods/:id/attach</code> endpoint does not ensure that future payments can be made with the attached PaymentMethod.
        /// See <a href="/docs/payments/payment-intents#future-usage">Optimizing cards for future payments</a> for more information about setting up future payments.</p>
        /// 
        /// <p>To use this PaymentMethod as the default for invoice or subscription payments,
        /// set <a href="/docs/api/customers/update#update_customer-invoice_settings-default_payment_method"><code>invoice_settings.default_payment_method</code></a>,
        /// on the Customer to the PaymentMethod’s ID.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.PaymentMethod> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The ID of the customer to which to attach the PaymentMethod.
            public var customer: String
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(customer: String, expand: [String]? = nil) {
                self.customer = customer
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(customer, forKey: "customer")
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.PaymentMethods.WithPaymentMethod {
    public var detach: Detach {
        Detach(path: path + "/detach")
    }

    public struct Detach {
        /// Path: `/v1/payment_methods/{payment_method}/detach`
        public let path: String

        /// <p>Detaches a PaymentMethod object from a Customer.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.PaymentMethod> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(expand: [String]? = nil) {
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var payouts: Payouts {
        Payouts(path: "/v1/payouts")
    }

    public struct Payouts {
        /// Path: `/v1/payouts`
        public let path: String

        /// <p>Returns a list of existing payouts sent to third-party bank accounts or that Stripe has sent you. The payouts are returned in sorted order, with the most recently created payouts appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// PayoutList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Payout]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Payout], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var arrivalDate: ArrivalDate?
            public var created: Created?
            public var destination: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?
            public var status: String?

            public struct ArrivalDate: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(arrivalDate: ArrivalDate? = nil, created: Created? = nil, destination: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil, status: String? = nil) {
                self.arrivalDate = arrivalDate
                self.created = created
                self.destination = destination
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
                self.status = status
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(arrivalDate, forKey: "arrival_date", isDeepObject: true)
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(destination, forKey: "destination")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(status, forKey: "status")
                return encoder.items
            }
        }

        /// <p>To send funds to your own bank account, you create a new payout object. Your <a href="#balance">Stripe balance</a> must be able to cover the payout amount, or you’ll receive an “Insufficient Funds” error.</p>
        /// 
        /// <p>If your API key is in test mode, money won’t actually be sent, though everything else will occur as if in live mode.</p>
        /// 
        /// <p>If you are creating a manual payout on a Stripe account that uses multiple payment source types, you’ll need to specify the source type balance that the payout should draw from. The <a href="#balance_object">balance object</a> details available and pending amounts by source type.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.Payout> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// A positive integer in cents representing how much to payout.
            public var amount: Int
            /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
            public var currency: String
            /// An arbitrary string attached to the object. Often useful for displaying to users.
            public var description: String?
            /// The ID of a bank account or a card to send the payout to. If no destination is supplied, the default external account for the specified currency will be used.
            public var destination: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// The method used to send this payout, which can be `standard` or `instant`. `instant` is only supported for payouts to debit cards. (See [Instant payouts for marketplaces for more information](https://stripe.com/blog/instant-payouts-for-marketplaces).)
            public var method: Method?
            /// The balance type of your Stripe balance to draw this payout from. Balances for different payment sources are kept separately. You can find the amounts with the balances API. One of `bank_account`, `card`, or `fpx`.
            public var sourceType: SourceType?
            /// A string to be displayed on the recipient's bank or card statement. This may be at most 22 characters. Attempting to use a `statement_descriptor` longer than 22 characters will return an error. Note: Most banks will truncate this information and/or display it inconsistently. Some may not display it at all.
            public var statementDescriptor: String?

            /// The method used to send this payout, which can be `standard` or `instant`. `instant` is only supported for payouts to debit cards. (See [Instant payouts for marketplaces for more information](https://stripe.com/blog/instant-payouts-for-marketplaces).)
            public enum Method: String, Codable, CaseIterable {
                case instant
                case standard
            }

            /// The balance type of your Stripe balance to draw this payout from. Balances for different payment sources are kept separately. You can find the amounts with the balances API. One of `bank_account`, `card`, or `fpx`.
            public enum SourceType: String, Codable, CaseIterable {
                case bankAccount = "bank_account"
                case card
                case fpx
            }

            public init(amount: Int, currency: String, description: String? = nil, destination: String? = nil, expand: [String]? = nil, metadata: [String: String]? = nil, method: Method? = nil, sourceType: SourceType? = nil, statementDescriptor: String? = nil) {
                self.amount = amount
                self.currency = currency
                self.description = description
                self.destination = destination
                self.expand = expand
                self.metadata = metadata
                self.method = method
                self.sourceType = sourceType
                self.statementDescriptor = statementDescriptor
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(description, forKey: "description")
                encoder.encode(destination, forKey: "destination")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(method, forKey: "method")
                encoder.encode(sourceType, forKey: "source_type")
                encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                return encoder.items
            }
        }
    }
}

extension Paths.Payouts {
    public func payout(_ payout: String) -> WithPayout {
        WithPayout(path: "\(path)/\(payout)")
    }

    public struct WithPayout {
        /// Path: `/v1/payouts/{payout}`
        public let path: String

        /// <p>Retrieves the details of an existing payout. Supply the unique payout ID from either a payout creation request or the payout list, and Stripe will return the corresponding payout information.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Payout> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the specified payout by setting the values of the parameters passed. Any parameters not provided will be left unchanged. This request accepts only the metadata as arguments.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Payout> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(expand: [String]? = nil, metadata: Metadata? = nil) {
                self.expand = expand
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths.Payouts.WithPayout {
    public var cancel: Cancel {
        Cancel(path: path + "/cancel")
    }

    public struct Cancel {
        /// Path: `/v1/payouts/{payout}/cancel`
        public let path: String

        /// <p>A previously created payout can be canceled if it has not yet been paid out. Funds will be refunded to your available balance. You may not cancel automatic Stripe payouts.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Payout> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(expand: [String]? = nil) {
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.Payouts.WithPayout {
    public var reverse: Reverse {
        Reverse(path: path + "/reverse")
    }

    public struct Reverse {
        /// Path: `/v1/payouts/{payout}/reverse`
        public let path: String

        /// <p>Reverses a payout by debiting the destination bank account. Only payouts for connected accounts to US bank accounts may be reversed at this time. If the payout is in the <code>pending</code> status, <code>/v1/payouts/:id/cancel</code> should be used instead.</p>
        /// 
        /// <p>By requesting a reversal via <code>/v1/payouts/:id/reverse</code>, you confirm that the authorized signatory of the selected bank account has authorized the debit on the bank account and that no other authorization is required.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Payout> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?

            public init(expand: [String]? = nil, metadata: [String: String]? = nil) {
                self.expand = expand
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var plans: Plans {
        Plans(path: "/v1/plans")
    }

    public struct Plans {
        /// Path: `/v1/plans`
        public let path: String

        /// <p>Returns a list of your plans.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// PlanList
        public struct GetResponse: Decodable {
            /// Details about each object.
            public var data: [StripeAPI.Plan]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Plan], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var isActive: Bool?
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var product: String?
            public var startingAfter: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(isActive: Bool? = nil, created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, product: String? = nil, startingAfter: String? = nil) {
                self.isActive = isActive
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.product = product
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(product, forKey: "product")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>You can now model subscriptions more flexibly using the <a href="#prices">Prices API</a>. It replaces the Plans API and is backwards compatible to simplify your migration.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.Plan> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Whether the plan is currently available for new subscriptions. Defaults to `true`.
            public var isActive: Bool?
            /// Specifies a usage aggregation strategy for plans of `usage_type=metered`. Allowed values are `sum` for summing up all usage during a period, `last_during_period` for using the last usage record reported within a period, `last_ever` for using the last usage record ever (across period bounds) or `max` which uses the usage record with the maximum reported usage during a period. Defaults to `sum`.
            public var aggregateUsage: AggregateUsage?
            /// A positive integer in %s (or 0 for a free plan) representing how much to charge on a recurring basis.
            public var amount: Int?
            /// Same as `amount`, but accepts a decimal value with at most 12 decimal places. Only one of `amount` and `amount_decimal` can be set.
            public var amountDecimal: String?
            /// Describes how to compute the price per period. Either `per_unit` or `tiered`. `per_unit` indicates that the fixed amount (specified in `amount`) will be charged per unit in `quantity` (for plans with `usage_type=licensed`), or per unit of total usage (for plans with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as defined using the `tiers` and `tiers_mode` attributes.
            public var billingScheme: BillingScheme?
            /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
            public var currency: String
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// An identifier randomly generated by Stripe. Used to identify this plan when subscribing a customer. You can optionally override this ID, but the ID must be unique across all plans in your Stripe account. You can, however, use the same plan ID in both live and test modes.
            public var id: String?
            /// Specifies billing frequency. Either `day`, `week`, `month` or `year`.
            public var interval: Interval
            /// The number of intervals between subscription billings. For example, `interval=month` and `interval_count=3` bills every 3 months. Maximum of one year interval allowed (1 year, 12 months, or 52 weeks).
            public var intervalCount: Int?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// A brief description of the plan, hidden from customers.
            public var nickname: String?
            public var product: Product?
            /// Each element represents a pricing tier. This parameter requires `billing_scheme` to be set to `tiered`. See also the documentation for `billing_scheme`.
            public var tiers: [Tier]?
            /// Defines if the tiering price should be `graduated` or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per unit price, in `graduated` tiering pricing can successively change as the quantity grows.
            public var tiersMode: TiersMode?
            /// Transform_usage_param
            ///
            /// Apply a transformation to the reported usage or set quantity before computing the billed price. Cannot be combined with `tiers`.
            public var transformUsage: TransformUsage?
            /// Default number of trial days when subscribing a customer to this plan using [`trial_from_plan=true`](https://stripe.com/docs/api#create_subscription-trial_from_plan).
            public var trialPeriodDays: Int?
            /// Configures how the quantity per period should be determined. Can be either `metered` or `licensed`. `licensed` automatically bills the `quantity` set when adding it to a subscription. `metered` aggregates the total usage based on usage records. Defaults to `licensed`.
            public var usageType: UsageType?

            /// Specifies a usage aggregation strategy for plans of `usage_type=metered`. Allowed values are `sum` for summing up all usage during a period, `last_during_period` for using the last usage record reported within a period, `last_ever` for using the last usage record ever (across period bounds) or `max` which uses the usage record with the maximum reported usage during a period. Defaults to `sum`.
            public enum AggregateUsage: String, Codable, CaseIterable {
                case lastDuringPeriod = "last_during_period"
                case lastEver = "last_ever"
                case max
                case sum
            }

            /// Describes how to compute the price per period. Either `per_unit` or `tiered`. `per_unit` indicates that the fixed amount (specified in `amount`) will be charged per unit in `quantity` (for plans with `usage_type=licensed`), or per unit of total usage (for plans with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as defined using the `tiers` and `tiers_mode` attributes.
            public enum BillingScheme: String, Codable, CaseIterable {
                case perUnit = "per_unit"
                case tiered
            }

            /// Specifies billing frequency. Either `day`, `week`, `month` or `year`.
            public enum Interval: String, Codable, CaseIterable {
                case day
                case month
                case week
                case year
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public struct Product: Encodable {
                /// Inline_product_params
                ///
                /// The product whose pricing the created plan will represent. This can either be the ID of an existing product, or a dictionary containing fields used to create a [service product](https://stripe.com/docs/api#product_object-type).
                public var object: Object?
                /// The ID of the product whose pricing the created plan will represent.
                public var string: String?

                /// Inline_product_params
                ///
                /// The product whose pricing the created plan will represent. This can either be the ID of an existing product, or a dictionary containing fields used to create a [service product](https://stripe.com/docs/api#product_object-type).
                public struct Object: Encodable {
                    public var isActive: Bool?
                    public var id: String?
                    public var metadata: [String: String]?
                    public var name: String
                    public var statementDescriptor: String?
                    public var taxCode: String?
                    public var unitLabel: String?

                    public init(isActive: Bool? = nil, id: String? = nil, metadata: [String: String]? = nil, name: String, statementDescriptor: String? = nil, taxCode: String? = nil, unitLabel: String? = nil) {
                        self.isActive = isActive
                        self.id = id
                        self.metadata = metadata
                        self.name = name
                        self.statementDescriptor = statementDescriptor
                        self.taxCode = taxCode
                        self.unitLabel = unitLabel
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isActive, forKey: "active")
                        encoder.encode(id, forKey: "id")
                        encoder.encode(metadata, forKey: "metadata")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                        encoder.encode(taxCode, forKey: "tax_code")
                        encoder.encode(unitLabel, forKey: "unit_label")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, string: String? = nil) {
                    self.object = object
                    self.string = string
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(string, forKey: "string")
                    return encoder.items
                }
            }

            public struct Tier: Encodable {
                public var flatAmount: Int?
                public var flatAmountDecimal: String?
                public var unitAmount: Int?
                public var unitAmountDecimal: String?
                public var upTo: UpTo

                public struct UpTo: Encodable {
                    public var object: Object?
                    public var int: Int?

                    public enum Object: String, Codable, CaseIterable {
                        case inf
                    }

                    public init(object: Object? = nil, int: Int? = nil) {
                        self.object = object
                        self.int = int
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object, forKey: "object")
                        encoder.encode(int, forKey: "int")
                        return encoder.items
                    }
                }

                public init(flatAmount: Int? = nil, flatAmountDecimal: String? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil, upTo: UpTo) {
                    self.flatAmount = flatAmount
                    self.flatAmountDecimal = flatAmountDecimal
                    self.unitAmount = unitAmount
                    self.unitAmountDecimal = unitAmountDecimal
                    self.upTo = upTo
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(flatAmount, forKey: "flat_amount")
                    encoder.encode(flatAmountDecimal, forKey: "flat_amount_decimal")
                    encoder.encode(unitAmount, forKey: "unit_amount")
                    encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                    encoder.encode(upTo, forKey: "up_to")
                    return encoder.items
                }
            }

            /// Defines if the tiering price should be `graduated` or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per unit price, in `graduated` tiering pricing can successively change as the quantity grows.
            public enum TiersMode: String, Codable, CaseIterable {
                case graduated
                case volume
            }

            /// Transform_usage_param
            ///
            /// Apply a transformation to the reported usage or set quantity before computing the billed price. Cannot be combined with `tiers`.
            public struct TransformUsage: Encodable {
                public var divideBy: Int
                public var round: Round

                public enum Round: String, Codable, CaseIterable {
                    case down
                    case up
                }

                public init(divideBy: Int, round: Round) {
                    self.divideBy = divideBy
                    self.round = round
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(divideBy, forKey: "divide_by")
                    encoder.encode(round, forKey: "round")
                    return encoder.items
                }
            }

            /// Configures how the quantity per period should be determined. Can be either `metered` or `licensed`. `licensed` automatically bills the `quantity` set when adding it to a subscription. `metered` aggregates the total usage based on usage records. Defaults to `licensed`.
            public enum UsageType: String, Codable, CaseIterable {
                case licensed
                case metered
            }

            public init(isActive: Bool? = nil, aggregateUsage: AggregateUsage? = nil, amount: Int? = nil, amountDecimal: String? = nil, billingScheme: BillingScheme? = nil, currency: String, expand: [String]? = nil, id: String? = nil, interval: Interval, intervalCount: Int? = nil, metadata: Metadata? = nil, nickname: String? = nil, product: Product? = nil, tiers: [Tier]? = nil, tiersMode: TiersMode? = nil, transformUsage: TransformUsage? = nil, trialPeriodDays: Int? = nil, usageType: UsageType? = nil) {
                self.isActive = isActive
                self.aggregateUsage = aggregateUsage
                self.amount = amount
                self.amountDecimal = amountDecimal
                self.billingScheme = billingScheme
                self.currency = currency
                self.expand = expand
                self.id = id
                self.interval = interval
                self.intervalCount = intervalCount
                self.metadata = metadata
                self.nickname = nickname
                self.product = product
                self.tiers = tiers
                self.tiersMode = tiersMode
                self.transformUsage = transformUsage
                self.trialPeriodDays = trialPeriodDays
                self.usageType = usageType
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(aggregateUsage, forKey: "aggregate_usage")
                encoder.encode(amount, forKey: "amount")
                encoder.encode(amountDecimal, forKey: "amount_decimal")
                encoder.encode(billingScheme, forKey: "billing_scheme")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(id, forKey: "id")
                encoder.encode(interval, forKey: "interval")
                encoder.encode(intervalCount, forKey: "interval_count")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(nickname, forKey: "nickname")
                encoder.encode(product, forKey: "product")
                encoder.encode(tiers, forKey: "tiers")
                encoder.encode(tiersMode, forKey: "tiers_mode")
                encoder.encode(transformUsage, forKey: "transform_usage")
                encoder.encode(trialPeriodDays, forKey: "trial_period_days")
                encoder.encode(usageType, forKey: "usage_type")
                return encoder.items
            }
        }
    }
}

extension Paths.Plans {
    public func plan(_ plan: String) -> WithPlan {
        WithPlan(path: "\(path)/\(plan)")
    }

    public struct WithPlan {
        /// Path: `/v1/plans/{plan}`
        public let path: String

        /// <p>Retrieves the plan with the given ID.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Plan> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the specified plan by setting the values of the parameters passed. Any parameters not provided are left unchanged. By design, you cannot change a plan’s ID, amount, currency, or billing cycle.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Plan> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Whether the plan is currently available for new subscriptions.
            public var isActive: Bool?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// A brief description of the plan, hidden from customers.
            public var nickname: String?
            /// The product the plan belongs to. This cannot be changed once it has been used in a subscription or subscription schedule.
            public var product: String?
            /// Default number of trial days when subscribing a customer to this plan using [`trial_from_plan=true`](https://stripe.com/docs/api#create_subscription-trial_from_plan).
            public var trialPeriodDays: Int?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(isActive: Bool? = nil, expand: [String]? = nil, metadata: Metadata? = nil, nickname: String? = nil, product: String? = nil, trialPeriodDays: Int? = nil) {
                self.isActive = isActive
                self.expand = expand
                self.metadata = metadata
                self.nickname = nickname
                self.product = product
                self.trialPeriodDays = trialPeriodDays
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(nickname, forKey: "nickname")
                encoder.encode(product, forKey: "product")
                encoder.encode(trialPeriodDays, forKey: "trial_period_days")
                return encoder.items
            }
        }

        /// <p>Deleting plans means new subscribers can’t be added. Existing subscribers aren’t affected.</p>
        public var delete: Request<StripeAPI.DeletedPlan> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var prices: Prices {
        Prices(path: "/v1/prices")
    }

    public struct Prices {
        /// Path: `/v1/prices`
        public let path: String

        /// <p>Returns a list of your prices.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// PriceList
        public struct GetResponse: Decodable {
            /// Details about each object.
            public var data: [StripeAPI.Price]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Price], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var isActive: Bool?
            public var created: Created?
            public var currency: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var lookupKeys: [String]?
            public var product: String?
            /// All_prices_recurring_params
            public var recurring: Recurring?
            public var startingAfter: String?
            public var type: `Type`?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            /// All_prices_recurring_params
            public struct Recurring: Codable {
                public var interval: Interval?
                public var usageType: UsageType?

                public enum Interval: String, Codable, CaseIterable {
                    case day
                    case month
                    case week
                    case year
                }

                public enum UsageType: String, Codable, CaseIterable {
                    case licensed
                    case metered
                }

                public init(interval: Interval? = nil, usageType: UsageType? = nil) {
                    self.interval = interval
                    self.usageType = usageType
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(interval, forKey: "interval")
                    encoder.encode(usageType, forKey: "usage_type")
                    return encoder.items
                }
            }

            public enum `Type`: String, Codable, CaseIterable {
                case oneTime = "one_time"
                case recurring
            }

            public init(isActive: Bool? = nil, created: Created? = nil, currency: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, lookupKeys: [String]? = nil, product: String? = nil, recurring: Recurring? = nil, startingAfter: String? = nil, type: `Type`? = nil) {
                self.isActive = isActive
                self.created = created
                self.currency = currency
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.lookupKeys = lookupKeys
                self.product = product
                self.recurring = recurring
                self.startingAfter = startingAfter
                self.type = type
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(currency, forKey: "currency")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(lookupKeys, forKey: "lookup_keys", isDeepObject: true)
                encoder.encode(product, forKey: "product")
                encoder.encode(recurring, forKey: "recurring", isDeepObject: true)
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(type, forKey: "type")
                return encoder.items
            }
        }

        /// <p>Creates a new price for an existing product. The price can be recurring or one-time.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.Price> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Whether the price can be used for new purchases. Defaults to `true`.
            public var isActive: Bool?
            /// Describes how to compute the price per period. Either `per_unit` or `tiered`. `per_unit` indicates that the fixed amount (specified in `unit_amount` or `unit_amount_decimal`) will be charged per unit in `quantity` (for prices with `usage_type=licensed`), or per unit of total usage (for prices with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as defined using the `tiers` and `tiers_mode` attributes.
            public var billingScheme: BillingScheme?
            /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
            public var currency: String
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// A lookup key used to retrieve prices dynamically from a static string. This may be up to 200 characters.
            public var lookupKey: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// A brief description of the price, hidden from customers.
            public var nickname: String?
            /// The ID of the product that this price will belong to.
            public var product: String?
            /// Inline_product_params
            ///
            /// These fields can be used to create a new product that this price will belong to.
            public var productData: ProductData?
            /// The recurring components of a price such as `interval` and `usage_type`.
            public var recurring: Recurring?
            /// Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it cannot be changed.
            public var taxBehavior: TaxBehavior?
            /// Each element represents a pricing tier. This parameter requires `billing_scheme` to be set to `tiered`. See also the documentation for `billing_scheme`.
            public var tiers: [Tier]?
            /// Defines if the tiering price should be `graduated` or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per unit price, in `graduated` tiering pricing can successively change as the quantity grows.
            public var tiersMode: TiersMode?
            /// If set to true, will atomically remove the lookup key from the existing price, and assign it to this price.
            public var isTransferLookupKey: Bool?
            /// Transform_usage_param
            ///
            /// Apply a transformation to the reported usage or set quantity before computing the billed price. Cannot be combined with `tiers`.
            public var transformQuantity: TransformQuantity?
            /// A positive integer in %s (or 0 for a free price) representing how much to charge.
            public var unitAmount: Int?
            /// Same as `unit_amount`, but accepts a decimal value in %s with at most 12 decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
            public var unitAmountDecimal: String?

            /// Describes how to compute the price per period. Either `per_unit` or `tiered`. `per_unit` indicates that the fixed amount (specified in `unit_amount` or `unit_amount_decimal`) will be charged per unit in `quantity` (for prices with `usage_type=licensed`), or per unit of total usage (for prices with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as defined using the `tiers` and `tiers_mode` attributes.
            public enum BillingScheme: String, Codable, CaseIterable {
                case perUnit = "per_unit"
                case tiered
            }

            /// Inline_product_params
            ///
            /// These fields can be used to create a new product that this price will belong to.
            public struct ProductData: Encodable {
                public var isActive: Bool?
                public var id: String?
                public var metadata: [String: String]?
                public var name: String
                public var statementDescriptor: String?
                public var taxCode: String?
                public var unitLabel: String?

                public init(isActive: Bool? = nil, id: String? = nil, metadata: [String: String]? = nil, name: String, statementDescriptor: String? = nil, taxCode: String? = nil, unitLabel: String? = nil) {
                    self.isActive = isActive
                    self.id = id
                    self.metadata = metadata
                    self.name = name
                    self.statementDescriptor = statementDescriptor
                    self.taxCode = taxCode
                    self.unitLabel = unitLabel
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isActive, forKey: "active")
                    encoder.encode(id, forKey: "id")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(name, forKey: "name")
                    encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                    encoder.encode(taxCode, forKey: "tax_code")
                    encoder.encode(unitLabel, forKey: "unit_label")
                    return encoder.items
                }
            }

            /// The recurring components of a price such as `interval` and `usage_type`.
            public struct Recurring: Encodable {
                public var aggregateUsage: AggregateUsage?
                public var interval: Interval
                public var intervalCount: Int?
                public var usageType: UsageType?

                public enum AggregateUsage: String, Codable, CaseIterable {
                    case lastDuringPeriod = "last_during_period"
                    case lastEver = "last_ever"
                    case max
                    case sum
                }

                public enum Interval: String, Codable, CaseIterable {
                    case day
                    case month
                    case week
                    case year
                }

                public enum UsageType: String, Codable, CaseIterable {
                    case licensed
                    case metered
                }

                public init(aggregateUsage: AggregateUsage? = nil, interval: Interval, intervalCount: Int? = nil, usageType: UsageType? = nil) {
                    self.aggregateUsage = aggregateUsage
                    self.interval = interval
                    self.intervalCount = intervalCount
                    self.usageType = usageType
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(aggregateUsage, forKey: "aggregate_usage")
                    encoder.encode(interval, forKey: "interval")
                    encoder.encode(intervalCount, forKey: "interval_count")
                    encoder.encode(usageType, forKey: "usage_type")
                    return encoder.items
                }
            }

            /// Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it cannot be changed.
            public enum TaxBehavior: String, Codable, CaseIterable {
                case exclusive
                case inclusive
                case unspecified
            }

            public struct Tier: Encodable {
                public var flatAmount: Int?
                public var flatAmountDecimal: String?
                public var unitAmount: Int?
                public var unitAmountDecimal: String?
                public var upTo: UpTo

                public struct UpTo: Encodable {
                    public var object: Object?
                    public var int: Int?

                    public enum Object: String, Codable, CaseIterable {
                        case inf
                    }

                    public init(object: Object? = nil, int: Int? = nil) {
                        self.object = object
                        self.int = int
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object, forKey: "object")
                        encoder.encode(int, forKey: "int")
                        return encoder.items
                    }
                }

                public init(flatAmount: Int? = nil, flatAmountDecimal: String? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil, upTo: UpTo) {
                    self.flatAmount = flatAmount
                    self.flatAmountDecimal = flatAmountDecimal
                    self.unitAmount = unitAmount
                    self.unitAmountDecimal = unitAmountDecimal
                    self.upTo = upTo
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(flatAmount, forKey: "flat_amount")
                    encoder.encode(flatAmountDecimal, forKey: "flat_amount_decimal")
                    encoder.encode(unitAmount, forKey: "unit_amount")
                    encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                    encoder.encode(upTo, forKey: "up_to")
                    return encoder.items
                }
            }

            /// Defines if the tiering price should be `graduated` or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per unit price, in `graduated` tiering pricing can successively change as the quantity grows.
            public enum TiersMode: String, Codable, CaseIterable {
                case graduated
                case volume
            }

            /// Transform_usage_param
            ///
            /// Apply a transformation to the reported usage or set quantity before computing the billed price. Cannot be combined with `tiers`.
            public struct TransformQuantity: Encodable {
                public var divideBy: Int
                public var round: Round

                public enum Round: String, Codable, CaseIterable {
                    case down
                    case up
                }

                public init(divideBy: Int, round: Round) {
                    self.divideBy = divideBy
                    self.round = round
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(divideBy, forKey: "divide_by")
                    encoder.encode(round, forKey: "round")
                    return encoder.items
                }
            }

            public init(isActive: Bool? = nil, billingScheme: BillingScheme? = nil, currency: String, expand: [String]? = nil, lookupKey: String? = nil, metadata: [String: String]? = nil, nickname: String? = nil, product: String? = nil, productData: ProductData? = nil, recurring: Recurring? = nil, taxBehavior: TaxBehavior? = nil, tiers: [Tier]? = nil, tiersMode: TiersMode? = nil, isTransferLookupKey: Bool? = nil, transformQuantity: TransformQuantity? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                self.isActive = isActive
                self.billingScheme = billingScheme
                self.currency = currency
                self.expand = expand
                self.lookupKey = lookupKey
                self.metadata = metadata
                self.nickname = nickname
                self.product = product
                self.productData = productData
                self.recurring = recurring
                self.taxBehavior = taxBehavior
                self.tiers = tiers
                self.tiersMode = tiersMode
                self.isTransferLookupKey = isTransferLookupKey
                self.transformQuantity = transformQuantity
                self.unitAmount = unitAmount
                self.unitAmountDecimal = unitAmountDecimal
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(billingScheme, forKey: "billing_scheme")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(lookupKey, forKey: "lookup_key")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(nickname, forKey: "nickname")
                encoder.encode(product, forKey: "product")
                encoder.encode(productData, forKey: "product_data")
                encoder.encode(recurring, forKey: "recurring")
                encoder.encode(taxBehavior, forKey: "tax_behavior")
                encoder.encode(tiers, forKey: "tiers")
                encoder.encode(tiersMode, forKey: "tiers_mode")
                encoder.encode(isTransferLookupKey, forKey: "transfer_lookup_key")
                encoder.encode(transformQuantity, forKey: "transform_quantity")
                encoder.encode(unitAmount, forKey: "unit_amount")
                encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                return encoder.items
            }
        }
    }
}

extension Paths.Prices {
    public func price(_ price: String) -> WithPrice {
        WithPrice(path: "\(path)/\(price)")
    }

    public struct WithPrice {
        /// Path: `/v1/prices/{price}`
        public let path: String

        /// <p>Retrieves the price with the given ID.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Price> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the specified price by setting the values of the parameters passed. Any parameters not provided are left unchanged.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Price> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Whether the price can be used for new purchases. Defaults to `true`.
            public var isActive: Bool?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// A lookup key used to retrieve prices dynamically from a static string. This may be up to 200 characters.
            public var lookupKey: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// A brief description of the price, hidden from customers.
            public var nickname: String?
            /// Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it cannot be changed.
            public var taxBehavior: TaxBehavior?
            /// If set to true, will atomically remove the lookup key from the existing price, and assign it to this price.
            public var isTransferLookupKey: Bool?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it cannot be changed.
            public enum TaxBehavior: String, Codable, CaseIterable {
                case exclusive
                case inclusive
                case unspecified
            }

            public init(isActive: Bool? = nil, expand: [String]? = nil, lookupKey: String? = nil, metadata: Metadata? = nil, nickname: String? = nil, taxBehavior: TaxBehavior? = nil, isTransferLookupKey: Bool? = nil) {
                self.isActive = isActive
                self.expand = expand
                self.lookupKey = lookupKey
                self.metadata = metadata
                self.nickname = nickname
                self.taxBehavior = taxBehavior
                self.isTransferLookupKey = isTransferLookupKey
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(lookupKey, forKey: "lookup_key")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(nickname, forKey: "nickname")
                encoder.encode(taxBehavior, forKey: "tax_behavior")
                encoder.encode(isTransferLookupKey, forKey: "transfer_lookup_key")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var products: Products {
        Products(path: "/v1/products")
    }

    public struct Products {
        /// Path: `/v1/products`
        public let path: String

        /// <p>Returns a list of your products. The products are returned sorted by creation date, with the most recently created products appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// ProductList
        public struct GetResponse: Decodable {
            /// Details about each object.
            public var data: [StripeAPI.Product]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Product], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var isActive: Bool?
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var ids: [String]?
            public var limit: Int?
            public var isShippable: Bool?
            public var startingAfter: String?
            public var url: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(isActive: Bool? = nil, created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, ids: [String]? = nil, limit: Int? = nil, isShippable: Bool? = nil, startingAfter: String? = nil, url: String? = nil) {
                self.isActive = isActive
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.ids = ids
                self.limit = limit
                self.isShippable = isShippable
                self.startingAfter = startingAfter
                self.url = url
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(ids, forKey: "ids", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(isShippable, forKey: "shippable")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(url, forKey: "url")
                return encoder.items
            }
        }

        /// <p>Creates a new product object.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.Product> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Whether the product is currently available for purchase. Defaults to `true`.
            public var isActive: Bool?
            /// The product's description, meant to be displayable to the customer. Use this field to optionally store a long form explanation of the product being sold for your own rendering purposes.
            public var description: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// An identifier will be randomly generated by Stripe. You can optionally override this ID, but the ID must be unique across all products in your Stripe account.
            public var id: String?
            /// A list of up to 8 URLs of images for this product, meant to be displayable to the customer.
            public var images: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// The product's name, meant to be displayable to the customer. Whenever this product is sold via a subscription, name will show up on associated invoice line item descriptions.
            public var name: String
            /// Package_dimensions_specs
            ///
            /// The dimensions of this product for shipping purposes.
            public var packageDimensions: PackageDimensions?
            /// Whether this product is shipped (i.e., physical goods).
            public var isShippable: Bool?
            /// An arbitrary string to be displayed on your customer's credit card or bank statement. While most banks display this information consistently, some may display it incorrectly or not at all.
            /// 
            /// This may be up to 22 characters. The statement description may not include `<`, `>`, `\`, `"`, `'` characters, and will appear on your customer's statement in capital letters. Non-ASCII characters are automatically stripped.
            ///  It must contain at least one letter.
            public var statementDescriptor: String?
            /// A [tax code](https://stripe.com/docs/tax/tax-codes) ID.
            public var taxCode: String?
            /// A label that represents units of this product in Stripe and on customers’ receipts and invoices. When set, this will be included in associated invoice line item descriptions.
            public var unitLabel: String?
            /// A URL of a publicly-accessible webpage for this product.
            public var url: String?

            /// Package_dimensions_specs
            ///
            /// The dimensions of this product for shipping purposes.
            public struct PackageDimensions: Encodable {
                public var height: Double
                public var length: Double
                public var weight: Double
                public var width: Double

                public init(height: Double, length: Double, weight: Double, width: Double) {
                    self.height = height
                    self.length = length
                    self.weight = weight
                    self.width = width
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(height, forKey: "height")
                    encoder.encode(length, forKey: "length")
                    encoder.encode(weight, forKey: "weight")
                    encoder.encode(width, forKey: "width")
                    return encoder.items
                }
            }

            public init(isActive: Bool? = nil, description: String? = nil, expand: [String]? = nil, id: String? = nil, images: [String]? = nil, metadata: [String: String]? = nil, name: String, packageDimensions: PackageDimensions? = nil, isShippable: Bool? = nil, statementDescriptor: String? = nil, taxCode: String? = nil, unitLabel: String? = nil, url: String? = nil) {
                self.isActive = isActive
                self.description = description
                self.expand = expand
                self.id = id
                self.images = images
                self.metadata = metadata
                self.name = name
                self.packageDimensions = packageDimensions
                self.isShippable = isShippable
                self.statementDescriptor = statementDescriptor
                self.taxCode = taxCode
                self.unitLabel = unitLabel
                self.url = url
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(description, forKey: "description")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(id, forKey: "id")
                encoder.encode(images, forKey: "images")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(name, forKey: "name")
                encoder.encode(packageDimensions, forKey: "package_dimensions")
                encoder.encode(isShippable, forKey: "shippable")
                encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                encoder.encode(taxCode, forKey: "tax_code")
                encoder.encode(unitLabel, forKey: "unit_label")
                encoder.encode(url, forKey: "url")
                return encoder.items
            }
        }
    }
}

extension Paths.Products {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/products/{id}`
        public let path: String

        /// <p>Retrieves the details of an existing product. Supply the unique product ID from either a product creation request or the product list, and Stripe will return the corresponding product information.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Product> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the specific product by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Product> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Whether the product is available for purchase.
            public var isActive: Bool?
            /// The product's description, meant to be displayable to the customer. Use this field to optionally store a long form explanation of the product being sold for your own rendering purposes.
            public var description: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// A list of up to 8 URLs of images for this product, meant to be displayable to the customer.
            public var images: Images?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The product's name, meant to be displayable to the customer. Whenever this product is sold via a subscription, name will show up on associated invoice line item descriptions.
            public var name: String?
            /// The dimensions of this product for shipping purposes.
            public var packageDimensions: PackageDimensions?
            /// Whether this product is shipped (i.e., physical goods).
            public var isShippable: Bool?
            /// An arbitrary string to be displayed on your customer's credit card or bank statement. While most banks display this information consistently, some may display it incorrectly or not at all.
            /// 
            /// This may be up to 22 characters. The statement description may not include `<`, `>`, `\`, `"`, `'` characters, and will appear on your customer's statement in capital letters. Non-ASCII characters are automatically stripped.
            ///  It must contain at least one letter. May only be set if `type=service`.
            public var statementDescriptor: String?
            /// A [tax code](https://stripe.com/docs/tax/tax-codes) ID.
            public var taxCode: TaxCode?
            /// A label that represents units of this product in Stripe and on customers’ receipts and invoices. When set, this will be included in associated invoice line item descriptions. May only be set if `type=service`.
            public var unitLabel: String?
            /// A URL of a publicly-accessible webpage for this product.
            public var url: String?

            /// A list of up to 8 URLs of images for this product, meant to be displayable to the customer.
            public struct Images: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// The dimensions of this product for shipping purposes.
            public struct PackageDimensions: Encodable {
                /// Package_dimensions_specs
                public var a: A?
                public var b: B?

                /// Package_dimensions_specs
                public struct A: Encodable {
                    public var height: Double
                    public var length: Double
                    public var weight: Double
                    public var width: Double

                    public init(height: Double, length: Double, weight: Double, width: Double) {
                        self.height = height
                        self.length = length
                        self.weight = weight
                        self.width = width
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(height, forKey: "height")
                        encoder.encode(length, forKey: "length")
                        encoder.encode(weight, forKey: "weight")
                        encoder.encode(width, forKey: "width")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// A [tax code](https://stripe.com/docs/tax/tax-codes) ID.
            public struct TaxCode: Encodable {
                public var string: String?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(string: String? = nil, object: Object? = nil) {
                    self.string = string
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(string, forKey: "string")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(isActive: Bool? = nil, description: String? = nil, expand: [String]? = nil, images: Images? = nil, metadata: Metadata? = nil, name: String? = nil, packageDimensions: PackageDimensions? = nil, isShippable: Bool? = nil, statementDescriptor: String? = nil, taxCode: TaxCode? = nil, unitLabel: String? = nil, url: String? = nil) {
                self.isActive = isActive
                self.description = description
                self.expand = expand
                self.images = images
                self.metadata = metadata
                self.name = name
                self.packageDimensions = packageDimensions
                self.isShippable = isShippable
                self.statementDescriptor = statementDescriptor
                self.taxCode = taxCode
                self.unitLabel = unitLabel
                self.url = url
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(description, forKey: "description")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(images, forKey: "images")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(name, forKey: "name")
                encoder.encode(packageDimensions, forKey: "package_dimensions")
                encoder.encode(isShippable, forKey: "shippable")
                encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                encoder.encode(taxCode, forKey: "tax_code")
                encoder.encode(unitLabel, forKey: "unit_label")
                encoder.encode(url, forKey: "url")
                return encoder.items
            }
        }

        /// <p>Delete a product. Deleting a product is only possible if it has no prices associated with it. Additionally, deleting a product with <code>type=good</code> is only possible if it has no SKUs associated with it.</p>
        public var delete: Request<StripeAPI.DeletedProduct> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var promotionCodes: PromotionCodes {
        PromotionCodes(path: "/v1/promotion_codes")
    }

    public struct PromotionCodes {
        /// Path: `/v1/promotion_codes`
        public let path: String

        /// <p>Returns a list of your promotion codes.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.PromotionCode]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.PromotionCode], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var isActive: Bool?
            public var code: String?
            public var coupon: String?
            public var created: Created?
            public var customer: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(isActive: Bool? = nil, code: String? = nil, coupon: String? = nil, created: Created? = nil, customer: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.isActive = isActive
                self.code = code
                self.coupon = coupon
                self.created = created
                self.customer = customer
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(code, forKey: "code")
                encoder.encode(coupon, forKey: "coupon")
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(customer, forKey: "customer")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>A promotion code points to a coupon. You can optionally restrict the code to a specific customer, redemption limit, and expiration date.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.PromotionCode> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Whether the promotion code is currently active.
            public var isActive: Bool?
            /// The customer-facing code. Regardless of case, this code must be unique across all active promotion codes for a specific customer. If left blank, we will generate one automatically.
            public var code: String?
            /// The coupon for this promotion code.
            public var coupon: String
            /// The customer that this promotion code can be used by. If not set, the promotion code can be used by all customers.
            public var customer: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The timestamp at which this promotion code will expire. If the coupon has specified a `redeems_by`, then this value cannot be after the coupon's `redeems_by`.
            public var expiresAt: Int?
            /// A positive integer specifying the number of times the promotion code can be redeemed. If the coupon has specified a `max_redemptions`, then this value cannot be greater than the coupon's `max_redemptions`.
            public var maxRedemptions: Int?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// Restrictions_params
            ///
            /// Settings that restrict the redemption of the promotion code.
            public var restrictions: Restrictions?

            /// Restrictions_params
            ///
            /// Settings that restrict the redemption of the promotion code.
            public struct Restrictions: Encodable {
                public var isFirstTimeTransaction: Bool?
                public var minimumAmount: Int?
                public var minimumAmountCurrency: String?

                public init(isFirstTimeTransaction: Bool? = nil, minimumAmount: Int? = nil, minimumAmountCurrency: String? = nil) {
                    self.isFirstTimeTransaction = isFirstTimeTransaction
                    self.minimumAmount = minimumAmount
                    self.minimumAmountCurrency = minimumAmountCurrency
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isFirstTimeTransaction, forKey: "first_time_transaction")
                    encoder.encode(minimumAmount, forKey: "minimum_amount")
                    encoder.encode(minimumAmountCurrency, forKey: "minimum_amount_currency")
                    return encoder.items
                }
            }

            public init(isActive: Bool? = nil, code: String? = nil, coupon: String, customer: String? = nil, expand: [String]? = nil, expiresAt: Int? = nil, maxRedemptions: Int? = nil, metadata: [String: String]? = nil, restrictions: Restrictions? = nil) {
                self.isActive = isActive
                self.code = code
                self.coupon = coupon
                self.customer = customer
                self.expand = expand
                self.expiresAt = expiresAt
                self.maxRedemptions = maxRedemptions
                self.metadata = metadata
                self.restrictions = restrictions
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(code, forKey: "code")
                encoder.encode(coupon, forKey: "coupon")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(expiresAt, forKey: "expires_at")
                encoder.encode(maxRedemptions, forKey: "max_redemptions")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(restrictions, forKey: "restrictions")
                return encoder.items
            }
        }
    }
}

extension Paths.PromotionCodes {
    public func promotionCode(_ promotionCode: String) -> WithPromotionCode {
        WithPromotionCode(path: "\(path)/\(promotionCode)")
    }

    public struct WithPromotionCode {
        /// Path: `/v1/promotion_codes/{promotion_code}`
        public let path: String

        /// <p>Retrieves the promotion code with the given ID. In order to retrieve a promotion code by the customer-facing <code>code</code> use <a href="/docs/api/promotion_codes/list">list</a> with the desired <code>code</code>.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.PromotionCode> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the specified promotion code by setting the values of the parameters passed. Most fields are, by design, not editable.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.PromotionCode> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Whether the promotion code is currently active. A promotion code can only be reactivated when the coupon is still valid and the promotion code is otherwise redeemable.
            public var isActive: Bool?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(isActive: Bool? = nil, expand: [String]? = nil, metadata: Metadata? = nil) {
                self.isActive = isActive
                self.expand = expand
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var quotes: Quotes {
        Quotes(path: "/v1/quotes")
    }

    public struct Quotes {
        /// Path: `/v1/quotes`
        public let path: String

        /// <p>Returns a list of your quotes.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Quote]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Quote], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var customer: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?
            public var status: Status?

            public enum Status: String, Codable, CaseIterable {
                case accepted
                case canceled
                case draft
                case `open`
            }

            public init(customer: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil, status: Status? = nil) {
                self.customer = customer
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
                self.status = status
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(customer, forKey: "customer")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(status, forKey: "status")
                return encoder.items
            }
        }

        /// <p>A quote models prices and services for a customer. Default options for <code>header</code>, <code>description</code>, <code>footer</code>, and <code>expires_at</code> can be set in the dashboard via the <a href="https://dashboard.stripe.com/settings/billing/quote">quote template</a>.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Quote> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. There cannot be any line items with recurring prices when using this field.
            public var applicationFeeAmount: ApplicationFeeAmount?
            /// A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. There must be at least 1 line item with a recurring price to use this field.
            public var applicationFeePercent: ApplicationFeePercent?
            /// Automatic_tax_param
            ///
            /// Settings for automatic tax lookup for this quote and resulting invoices and subscriptions.
            public var automaticTax: AutomaticTax?
            /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay invoices at the end of the subscription cycle or at invoice finalization using the default payment method attached to the subscription or customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
            public var collectionMethod: CollectionMethod?
            /// The customer for which this quote belongs to. A customer is required before finalizing the quote. Once specified, it cannot be changed.
            public var customer: String?
            /// The tax rates that will apply to any line item that does not have `tax_rates` set.
            public var defaultTaxRates: DefaultTaxRates?
            /// A description that will be displayed on the quote PDF. If no value is passed, the default description configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
            public var description: String?
            /// The discounts applied to the quote. You can only set up to one discount.
            public var discounts: Discounts?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// A future timestamp on which the quote will be canceled if in `open` or `draft` status. Measured in seconds since the Unix epoch. If no value is passed, the default expiration date configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
            public var expiresAt: Int?
            /// A footer that will be displayed on the quote PDF. If no value is passed, the default footer configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
            public var footer: String?
            /// From_quote_params
            ///
            /// Clone an existing quote. The new quote will be created in `status=draft`. When using this parameter, you cannot specify any other parameters except for `expires_at`.
            public var fromQuote: FromQuote?
            /// A header that will be displayed on the quote PDF. If no value is passed, the default header configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
            public var header: String?
            /// Quote_param
            ///
            /// All invoices will be billed using the specified settings.
            public var invoiceSettings: InvoiceSettings?
            /// A list of line items the customer is being quoted for. Each line item includes information about the product, the quantity, and the resulting cost.
            public var lineItems: [LineItem]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// The account on behalf of which to charge.
            public var onBehalfOf: OnBehalfOf?
            /// Subscription_data_create_params
            ///
            /// When creating a subscription or subscription schedule, the specified configuration data will be used. There must be at least one line item with a recurring price for a subscription or subscription schedule to be created. A subscription schedule is created if `subscription_data[effective_date]` is present and in the future, otherwise a subscription is created.
            public var subscriptionData: SubscriptionData?
            /// The data with which to automatically create a Transfer for each of the invoices.
            public var transferData: TransferData?

            /// The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. There cannot be any line items with recurring prices when using this field.
            public struct ApplicationFeeAmount: Encodable {
                public var int: Int?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(int: Int? = nil, object: Object? = nil) {
                    self.int = int
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(int, forKey: "int")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. There must be at least 1 line item with a recurring price to use this field.
            public struct ApplicationFeePercent: Encodable {
                public var double: Double?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(double: Double? = nil, object: Object? = nil) {
                    self.double = double
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(double, forKey: "double")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Automatic_tax_param
            ///
            /// Settings for automatic tax lookup for this quote and resulting invoices and subscriptions.
            public struct AutomaticTax: Encodable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay invoices at the end of the subscription cycle or at invoice finalization using the default payment method attached to the subscription or customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
            public enum CollectionMethod: String, Codable, CaseIterable {
                case chargeAutomatically = "charge_automatically"
                case sendInvoice = "send_invoice"
            }

            /// The tax rates that will apply to any line item that does not have `tax_rates` set.
            public struct DefaultTaxRates: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// The discounts applied to the quote. You can only set up to one discount.
            public struct Discounts: Encodable {
                public var placeholderItems: [PlaceholderItem]?
                public var object: Object?

                /// Discounts_data_param
                public struct PlaceholderItem: Encodable {
                    public var coupon: String?
                    public var discount: String?

                    public init(coupon: String? = nil, discount: String? = nil) {
                        self.coupon = coupon
                        self.discount = discount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(coupon, forKey: "coupon")
                        encoder.encode(discount, forKey: "discount")
                        return encoder.items
                    }
                }

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                    self.placeholderItems = placeholderItems
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(placeholderItems, forKey: "placeholderItems")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// From_quote_params
            ///
            /// Clone an existing quote. The new quote will be created in `status=draft`. When using this parameter, you cannot specify any other parameters except for `expires_at`.
            public struct FromQuote: Encodable {
                public var isRevision: Bool?
                public var quote: String

                public init(isRevision: Bool? = nil, quote: String) {
                    self.isRevision = isRevision
                    self.quote = quote
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isRevision, forKey: "is_revision")
                    encoder.encode(quote, forKey: "quote")
                    return encoder.items
                }
            }

            /// Quote_param
            ///
            /// All invoices will be billed using the specified settings.
            public struct InvoiceSettings: Encodable {
                public var daysUntilDue: Int?

                public init(daysUntilDue: Int? = nil) {
                    self.daysUntilDue = daysUntilDue
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(daysUntilDue, forKey: "days_until_due")
                    return encoder.items
                }
            }

            /// Line_item_create_params
            public struct LineItem: Encodable {
                public var price: String?
                /// Price_data
                public var priceData: PriceData?
                public var quantity: Int?
                public var taxRates: TaxRates?

                /// Price_data
                public struct PriceData: Encodable {
                    public var currency: String
                    public var product: String
                    /// Recurring_adhoc
                    public var recurring: Recurring?
                    public var taxBehavior: TaxBehavior?
                    public var unitAmount: Int?
                    public var unitAmountDecimal: String?

                    /// Recurring_adhoc
                    public struct Recurring: Encodable {
                        public var interval: Interval
                        public var intervalCount: Int?

                        public enum Interval: String, Codable, CaseIterable {
                            case day
                            case month
                            case week
                            case year
                        }

                        public init(interval: Interval, intervalCount: Int? = nil) {
                            self.interval = interval
                            self.intervalCount = intervalCount
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(interval, forKey: "interval")
                            encoder.encode(intervalCount, forKey: "interval_count")
                            return encoder.items
                        }
                    }

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public init(currency: String, product: String, recurring: Recurring? = nil, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                        self.currency = currency
                        self.product = product
                        self.recurring = recurring
                        self.taxBehavior = taxBehavior
                        self.unitAmount = unitAmount
                        self.unitAmountDecimal = unitAmountDecimal
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(product, forKey: "product")
                        encoder.encode(recurring, forKey: "recurring")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(unitAmount, forKey: "unit_amount")
                        encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                        return encoder.items
                    }
                }

                public struct TaxRates: Encodable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                    self.price = price
                    self.priceData = priceData
                    self.quantity = quantity
                    self.taxRates = taxRates
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(price, forKey: "price")
                    encoder.encode(priceData, forKey: "price_data")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    return encoder.items
                }
            }

            /// The account on behalf of which to charge.
            public struct OnBehalfOf: Encodable {
                public var string: String?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(string: String? = nil, object: Object? = nil) {
                    self.string = string
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(string, forKey: "string")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Subscription_data_create_params
            ///
            /// When creating a subscription or subscription schedule, the specified configuration data will be used. There must be at least one line item with a recurring price for a subscription or subscription schedule to be created. A subscription schedule is created if `subscription_data[effective_date]` is present and in the future, otherwise a subscription is created.
            public struct SubscriptionData: Encodable {
                public var effectiveDate: EffectiveDate?
                public var trialPeriodDays: TrialPeriodDays?

                public struct EffectiveDate: Encodable {
                    public var object1: Object1?
                    public var int: Int?
                    public var object2: Object2?

                    public enum Object1: String, Codable, CaseIterable {
                        case currentPeriodEnd = "current_period_end"
                    }

                    public enum Object2: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(object1: Object1? = nil, int: Int? = nil, object2: Object2? = nil) {
                        self.object1 = object1
                        self.int = int
                        self.object2 = object2
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object1, forKey: "object1")
                        encoder.encode(int, forKey: "int")
                        encoder.encode(object2, forKey: "object2")
                        return encoder.items
                    }
                }

                public struct TrialPeriodDays: Encodable {
                    public var int: Int?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(int: Int? = nil, object: Object? = nil) {
                        self.int = int
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(int, forKey: "int")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(effectiveDate: EffectiveDate? = nil, trialPeriodDays: TrialPeriodDays? = nil) {
                    self.effectiveDate = effectiveDate
                    self.trialPeriodDays = trialPeriodDays
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(effectiveDate, forKey: "effective_date")
                    encoder.encode(trialPeriodDays, forKey: "trial_period_days")
                    return encoder.items
                }
            }

            /// The data with which to automatically create a Transfer for each of the invoices.
            public struct TransferData: Encodable {
                /// Transfer_data_specs
                public var a: A?
                public var b: B?

                /// Transfer_data_specs
                public struct A: Encodable {
                    public var amount: Int?
                    public var amountPercent: Double?
                    public var destination: String

                    public init(amount: Int? = nil, amountPercent: Double? = nil, destination: String) {
                        self.amount = amount
                        self.amountPercent = amountPercent
                        self.destination = destination
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amount, forKey: "amount")
                        encoder.encode(amountPercent, forKey: "amount_percent")
                        encoder.encode(destination, forKey: "destination")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            public init(applicationFeeAmount: ApplicationFeeAmount? = nil, applicationFeePercent: ApplicationFeePercent? = nil, automaticTax: AutomaticTax? = nil, collectionMethod: CollectionMethod? = nil, customer: String? = nil, defaultTaxRates: DefaultTaxRates? = nil, description: String? = nil, discounts: Discounts? = nil, expand: [String]? = nil, expiresAt: Int? = nil, footer: String? = nil, fromQuote: FromQuote? = nil, header: String? = nil, invoiceSettings: InvoiceSettings? = nil, lineItems: [LineItem]? = nil, metadata: [String: String]? = nil, onBehalfOf: OnBehalfOf? = nil, subscriptionData: SubscriptionData? = nil, transferData: TransferData? = nil) {
                self.applicationFeeAmount = applicationFeeAmount
                self.applicationFeePercent = applicationFeePercent
                self.automaticTax = automaticTax
                self.collectionMethod = collectionMethod
                self.customer = customer
                self.defaultTaxRates = defaultTaxRates
                self.description = description
                self.discounts = discounts
                self.expand = expand
                self.expiresAt = expiresAt
                self.footer = footer
                self.fromQuote = fromQuote
                self.header = header
                self.invoiceSettings = invoiceSettings
                self.lineItems = lineItems
                self.metadata = metadata
                self.onBehalfOf = onBehalfOf
                self.subscriptionData = subscriptionData
                self.transferData = transferData
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(applicationFeeAmount, forKey: "application_fee_amount")
                encoder.encode(applicationFeePercent, forKey: "application_fee_percent")
                encoder.encode(automaticTax, forKey: "automatic_tax")
                encoder.encode(collectionMethod, forKey: "collection_method")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(defaultTaxRates, forKey: "default_tax_rates")
                encoder.encode(description, forKey: "description")
                encoder.encode(discounts, forKey: "discounts")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(expiresAt, forKey: "expires_at")
                encoder.encode(footer, forKey: "footer")
                encoder.encode(fromQuote, forKey: "from_quote")
                encoder.encode(header, forKey: "header")
                encoder.encode(invoiceSettings, forKey: "invoice_settings")
                encoder.encode(lineItems, forKey: "line_items")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(onBehalfOf, forKey: "on_behalf_of")
                encoder.encode(subscriptionData, forKey: "subscription_data")
                encoder.encode(transferData, forKey: "transfer_data")
                return encoder.items
            }
        }
    }
}

extension Paths.Quotes {
    public func quote(_ quote: String) -> WithQuote {
        WithQuote(path: "\(path)/\(quote)")
    }

    public struct WithQuote {
        /// Path: `/v1/quotes/{quote}`
        public let path: String

        /// <p>Retrieves the quote with the given ID.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Quote> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>A quote models prices and services for a customer.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Quote> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. There cannot be any line items with recurring prices when using this field.
            public var applicationFeeAmount: ApplicationFeeAmount?
            /// A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. There must be at least 1 line item with a recurring price to use this field.
            public var applicationFeePercent: ApplicationFeePercent?
            /// Automatic_tax_param
            ///
            /// Settings for automatic tax lookup for this quote and resulting invoices and subscriptions.
            public var automaticTax: AutomaticTax?
            /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay invoices at the end of the subscription cycle or at invoice finalization using the default payment method attached to the subscription or customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
            public var collectionMethod: CollectionMethod?
            /// The customer for which this quote belongs to. A customer is required before finalizing the quote. Once specified, it cannot be changed.
            public var customer: String?
            /// The tax rates that will apply to any line item that does not have `tax_rates` set.
            public var defaultTaxRates: DefaultTaxRates?
            /// A description that will be displayed on the quote PDF.
            public var description: String?
            /// The discounts applied to the quote. You can only set up to one discount.
            public var discounts: Discounts?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// A future timestamp on which the quote will be canceled if in `open` or `draft` status. Measured in seconds since the Unix epoch.
            public var expiresAt: Int?
            /// A footer that will be displayed on the quote PDF.
            public var footer: String?
            /// A header that will be displayed on the quote PDF.
            public var header: String?
            /// Quote_param
            ///
            /// All invoices will be billed using the specified settings.
            public var invoiceSettings: InvoiceSettings?
            /// A list of line items the customer is being quoted for. Each line item includes information about the product, the quantity, and the resulting cost.
            public var lineItems: [LineItem]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// The account on behalf of which to charge.
            public var onBehalfOf: OnBehalfOf?
            /// Subscription_data_update_params
            ///
            /// When creating a subscription or subscription schedule, the specified configuration data will be used. There must be at least one line item with a recurring price for a subscription or subscription schedule to be created. A subscription schedule is created if `subscription_data[effective_date]` is present and in the future, otherwise a subscription is created.
            public var subscriptionData: SubscriptionData?
            /// The data with which to automatically create a Transfer for each of the invoices.
            public var transferData: TransferData?

            /// The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. There cannot be any line items with recurring prices when using this field.
            public struct ApplicationFeeAmount: Encodable {
                public var int: Int?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(int: Int? = nil, object: Object? = nil) {
                    self.int = int
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(int, forKey: "int")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. There must be at least 1 line item with a recurring price to use this field.
            public struct ApplicationFeePercent: Encodable {
                public var double: Double?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(double: Double? = nil, object: Object? = nil) {
                    self.double = double
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(double, forKey: "double")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Automatic_tax_param
            ///
            /// Settings for automatic tax lookup for this quote and resulting invoices and subscriptions.
            public struct AutomaticTax: Encodable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay invoices at the end of the subscription cycle or at invoice finalization using the default payment method attached to the subscription or customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
            public enum CollectionMethod: String, Codable, CaseIterable {
                case chargeAutomatically = "charge_automatically"
                case sendInvoice = "send_invoice"
            }

            /// The tax rates that will apply to any line item that does not have `tax_rates` set.
            public struct DefaultTaxRates: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// The discounts applied to the quote. You can only set up to one discount.
            public struct Discounts: Encodable {
                public var placeholderItems: [PlaceholderItem]?
                public var object: Object?

                /// Discounts_data_param
                public struct PlaceholderItem: Encodable {
                    public var coupon: String?
                    public var discount: String?

                    public init(coupon: String? = nil, discount: String? = nil) {
                        self.coupon = coupon
                        self.discount = discount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(coupon, forKey: "coupon")
                        encoder.encode(discount, forKey: "discount")
                        return encoder.items
                    }
                }

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                    self.placeholderItems = placeholderItems
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(placeholderItems, forKey: "placeholderItems")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Quote_param
            ///
            /// All invoices will be billed using the specified settings.
            public struct InvoiceSettings: Encodable {
                public var daysUntilDue: Int?

                public init(daysUntilDue: Int? = nil) {
                    self.daysUntilDue = daysUntilDue
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(daysUntilDue, forKey: "days_until_due")
                    return encoder.items
                }
            }

            /// Line_item_update_params
            public struct LineItem: Encodable {
                public var id: String?
                public var price: String?
                /// Price_data
                public var priceData: PriceData?
                public var quantity: Int?
                public var taxRates: TaxRates?

                /// Price_data
                public struct PriceData: Encodable {
                    public var currency: String
                    public var product: String
                    /// Recurring_adhoc
                    public var recurring: Recurring?
                    public var taxBehavior: TaxBehavior?
                    public var unitAmount: Int?
                    public var unitAmountDecimal: String?

                    /// Recurring_adhoc
                    public struct Recurring: Encodable {
                        public var interval: Interval
                        public var intervalCount: Int?

                        public enum Interval: String, Codable, CaseIterable {
                            case day
                            case month
                            case week
                            case year
                        }

                        public init(interval: Interval, intervalCount: Int? = nil) {
                            self.interval = interval
                            self.intervalCount = intervalCount
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(interval, forKey: "interval")
                            encoder.encode(intervalCount, forKey: "interval_count")
                            return encoder.items
                        }
                    }

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public init(currency: String, product: String, recurring: Recurring? = nil, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                        self.currency = currency
                        self.product = product
                        self.recurring = recurring
                        self.taxBehavior = taxBehavior
                        self.unitAmount = unitAmount
                        self.unitAmountDecimal = unitAmountDecimal
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(product, forKey: "product")
                        encoder.encode(recurring, forKey: "recurring")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(unitAmount, forKey: "unit_amount")
                        encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                        return encoder.items
                    }
                }

                public struct TaxRates: Encodable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(id: String? = nil, price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                    self.id = id
                    self.price = price
                    self.priceData = priceData
                    self.quantity = quantity
                    self.taxRates = taxRates
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(id, forKey: "id")
                    encoder.encode(price, forKey: "price")
                    encoder.encode(priceData, forKey: "price_data")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    return encoder.items
                }
            }

            /// The account on behalf of which to charge.
            public struct OnBehalfOf: Encodable {
                public var string: String?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(string: String? = nil, object: Object? = nil) {
                    self.string = string
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(string, forKey: "string")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Subscription_data_update_params
            ///
            /// When creating a subscription or subscription schedule, the specified configuration data will be used. There must be at least one line item with a recurring price for a subscription or subscription schedule to be created. A subscription schedule is created if `subscription_data[effective_date]` is present and in the future, otherwise a subscription is created.
            public struct SubscriptionData: Encodable {
                public var effectiveDate: EffectiveDate?
                public var trialPeriodDays: TrialPeriodDays?

                public struct EffectiveDate: Encodable {
                    public var object1: Object1?
                    public var int: Int?
                    public var object2: Object2?

                    public enum Object1: String, Codable, CaseIterable {
                        case currentPeriodEnd = "current_period_end"
                    }

                    public enum Object2: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(object1: Object1? = nil, int: Int? = nil, object2: Object2? = nil) {
                        self.object1 = object1
                        self.int = int
                        self.object2 = object2
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(object1, forKey: "object1")
                        encoder.encode(int, forKey: "int")
                        encoder.encode(object2, forKey: "object2")
                        return encoder.items
                    }
                }

                public struct TrialPeriodDays: Encodable {
                    public var int: Int?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(int: Int? = nil, object: Object? = nil) {
                        self.int = int
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(int, forKey: "int")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(effectiveDate: EffectiveDate? = nil, trialPeriodDays: TrialPeriodDays? = nil) {
                    self.effectiveDate = effectiveDate
                    self.trialPeriodDays = trialPeriodDays
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(effectiveDate, forKey: "effective_date")
                    encoder.encode(trialPeriodDays, forKey: "trial_period_days")
                    return encoder.items
                }
            }

            /// The data with which to automatically create a Transfer for each of the invoices.
            public struct TransferData: Encodable {
                /// Transfer_data_specs
                public var a: A?
                public var b: B?

                /// Transfer_data_specs
                public struct A: Encodable {
                    public var amount: Int?
                    public var amountPercent: Double?
                    public var destination: String

                    public init(amount: Int? = nil, amountPercent: Double? = nil, destination: String) {
                        self.amount = amount
                        self.amountPercent = amountPercent
                        self.destination = destination
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amount, forKey: "amount")
                        encoder.encode(amountPercent, forKey: "amount_percent")
                        encoder.encode(destination, forKey: "destination")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            public init(applicationFeeAmount: ApplicationFeeAmount? = nil, applicationFeePercent: ApplicationFeePercent? = nil, automaticTax: AutomaticTax? = nil, collectionMethod: CollectionMethod? = nil, customer: String? = nil, defaultTaxRates: DefaultTaxRates? = nil, description: String? = nil, discounts: Discounts? = nil, expand: [String]? = nil, expiresAt: Int? = nil, footer: String? = nil, header: String? = nil, invoiceSettings: InvoiceSettings? = nil, lineItems: [LineItem]? = nil, metadata: [String: String]? = nil, onBehalfOf: OnBehalfOf? = nil, subscriptionData: SubscriptionData? = nil, transferData: TransferData? = nil) {
                self.applicationFeeAmount = applicationFeeAmount
                self.applicationFeePercent = applicationFeePercent
                self.automaticTax = automaticTax
                self.collectionMethod = collectionMethod
                self.customer = customer
                self.defaultTaxRates = defaultTaxRates
                self.description = description
                self.discounts = discounts
                self.expand = expand
                self.expiresAt = expiresAt
                self.footer = footer
                self.header = header
                self.invoiceSettings = invoiceSettings
                self.lineItems = lineItems
                self.metadata = metadata
                self.onBehalfOf = onBehalfOf
                self.subscriptionData = subscriptionData
                self.transferData = transferData
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(applicationFeeAmount, forKey: "application_fee_amount")
                encoder.encode(applicationFeePercent, forKey: "application_fee_percent")
                encoder.encode(automaticTax, forKey: "automatic_tax")
                encoder.encode(collectionMethod, forKey: "collection_method")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(defaultTaxRates, forKey: "default_tax_rates")
                encoder.encode(description, forKey: "description")
                encoder.encode(discounts, forKey: "discounts")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(expiresAt, forKey: "expires_at")
                encoder.encode(footer, forKey: "footer")
                encoder.encode(header, forKey: "header")
                encoder.encode(invoiceSettings, forKey: "invoice_settings")
                encoder.encode(lineItems, forKey: "line_items")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(onBehalfOf, forKey: "on_behalf_of")
                encoder.encode(subscriptionData, forKey: "subscription_data")
                encoder.encode(transferData, forKey: "transfer_data")
                return encoder.items
            }
        }
    }
}

extension Paths.Quotes.WithQuote {
    public var accept: Accept {
        Accept(path: path + "/accept")
    }

    public struct Accept {
        /// Path: `/v1/quotes/{quote}/accept`
        public let path: String

        /// <p>Accepts the specified quote.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Quote> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(expand: [String]? = nil) {
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.Quotes.WithQuote {
    public var cancel: Cancel {
        Cancel(path: path + "/cancel")
    }

    public struct Cancel {
        /// Path: `/v1/quotes/{quote}/cancel`
        public let path: String

        /// <p>Cancels the quote.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Quote> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(expand: [String]? = nil) {
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.Quotes.WithQuote {
    public var computedUpfrontLineItems: ComputedUpfrontLineItems {
        ComputedUpfrontLineItems(path: path + "/computed_upfront_line_items")
    }

    public struct ComputedUpfrontLineItems {
        /// Path: `/v1/quotes/{quote}/computed_upfront_line_items`
        public let path: String

        /// <p>When retrieving a quote, there is an includable <a href="https://stripe.com/docs/api/quotes/object#quote_object-computed-upfront-line_items"><strong>computed.upfront.line_items</strong></a> property containing the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of upfront line items.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// QuotesResourceListLineItems
        public struct GetResponse: Decodable {
            /// Details about each object.
            public var data: [StripeAPI.Item]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Item], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }
    }
}

extension Paths.Quotes.WithQuote {
    public var finalize: Finalize {
        Finalize(path: path + "/finalize")
    }

    public struct Finalize {
        /// Path: `/v1/quotes/{quote}/finalize`
        public let path: String

        /// <p>Finalizes the quote.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Quote> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// A future timestamp on which the quote will be canceled if in `open` or `draft` status. Measured in seconds since the Unix epoch.
            public var expiresAt: Int?

            public init(expand: [String]? = nil, expiresAt: Int? = nil) {
                self.expand = expand
                self.expiresAt = expiresAt
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(expiresAt, forKey: "expires_at")
                return encoder.items
            }
        }
    }
}

extension Paths.Quotes.WithQuote {
    public var lineItems: LineItems {
        LineItems(path: path + "/line_items")
    }

    public struct LineItems {
        /// Path: `/v1/quotes/{quote}/line_items`
        public let path: String

        /// <p>When retrieving a quote, there is an includable <strong>line_items</strong> property containing the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// QuotesResourceListLineItems
        public struct GetResponse: Decodable {
            /// Details about each object.
            public var data: [StripeAPI.Item]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Item], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }
    }
}

extension Paths.Quotes.WithQuote {
    public var pdf: Pdf {
        Pdf(path: path + "/pdf")
    }

    public struct Pdf {
        /// Path: `/v1/quotes/{quote}/pdf`
        public let path: String

        /// <p>Download the PDF for a finalized quote</p>
        public func get(expand: [String]? = nil) -> Request<Data> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths {
    public static var radar: Radar {
        Radar(path: "/v1/radar")
    }

    public struct Radar {
        /// Path: `/v1/radar`
        public let path: String
    }
}

extension Paths.Radar {
    public var earlyFraudWarnings: EarlyFraudWarnings {
        EarlyFraudWarnings(path: path + "/early_fraud_warnings")
    }

    public struct EarlyFraudWarnings {
        /// Path: `/v1/radar/early_fraud_warnings`
        public let path: String

        /// <p>Returns a list of early fraud warnings.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// RadarEarlyFraudWarningList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.RadarEarlyFraudWarning]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.RadarEarlyFraudWarning], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var charge: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var paymentIntent: String?
            public var startingAfter: String?

            public init(charge: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, paymentIntent: String? = nil, startingAfter: String? = nil) {
                self.charge = charge
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.paymentIntent = paymentIntent
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(charge, forKey: "charge")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(paymentIntent, forKey: "payment_intent")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }
    }
}

extension Paths.Radar.EarlyFraudWarnings {
    public func earlyFraudWarning(_ earlyFraudWarning: String) -> WithEarlyFraudWarning {
        WithEarlyFraudWarning(path: "\(path)/\(earlyFraudWarning)")
    }

    public struct WithEarlyFraudWarning {
        /// Path: `/v1/radar/early_fraud_warnings/{early_fraud_warning}`
        public let path: String

        /// <p>Retrieves the details of an early fraud warning that has previously been created. </p>
        /// 
        /// <p>Please refer to the <a href="#early_fraud_warning_object">early fraud warning</a> object reference for more details.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.RadarEarlyFraudWarning> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths.Radar {
    public var valueListItems: ValueListItems {
        ValueListItems(path: path + "/value_list_items")
    }

    public struct ValueListItems {
        /// Path: `/v1/radar/value_list_items`
        public let path: String

        /// <p>Returns a list of <code>ValueListItem</code> objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.RadarValueListItem]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.RadarValueListItem], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?
            public var value: String?
            public var valueList: String

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil, value: String? = nil, valueList: String) {
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
                self.value = value
                self.valueList = valueList
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(value, forKey: "value")
                encoder.encode(valueList, forKey: "value_list")
                return encoder.items
            }
        }

        /// <p>Creates a new <code>ValueListItem</code> object, which is added to the specified parent value list.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.RadarValueListItem> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The value of the item (whose type must match the type of the parent value list).
            public var value: String
            /// The identifier of the value list which the created item will be added to.
            public var valueList: String

            public init(expand: [String]? = nil, value: String, valueList: String) {
                self.expand = expand
                self.value = value
                self.valueList = valueList
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(value, forKey: "value")
                encoder.encode(valueList, forKey: "value_list")
                return encoder.items
            }
        }
    }
}

extension Paths.Radar.ValueListItems {
    public func item(_ item: String) -> WithItem {
        WithItem(path: "\(path)/\(item)")
    }

    public struct WithItem {
        /// Path: `/v1/radar/value_list_items/{item}`
        public let path: String

        /// <p>Retrieves a <code>ValueListItem</code> object.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.RadarValueListItem> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Deletes a <code>ValueListItem</code> object, removing it from its parent value list.</p>
        public var delete: Request<StripeAPI.DeletedRadarValueListItem> {
            .delete(path)
        }
    }
}

extension Paths.Radar {
    public var valueLists: ValueLists {
        ValueLists(path: path + "/value_lists")
    }

    public struct ValueLists {
        /// Path: `/v1/radar/value_lists`
        public let path: String

        /// <p>Returns a list of <code>ValueList</code> objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.RadarValueList]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.RadarValueList], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var alias: String?
            public var contains: String?
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(alias: String? = nil, contains: String? = nil, created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.alias = alias
                self.contains = contains
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(alias, forKey: "alias")
                encoder.encode(contains, forKey: "contains")
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates a new <code>ValueList</code> object, which can then be referenced in rules.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.RadarValueList> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The name of the value list for use in rules.
            public var alias: String
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Type of the items in the value list. One of `card_fingerprint`, `card_bin`, `email`, `ip_address`, `country`, `string`, `case_sensitive_string`, or `customer_id`. Use `string` if the item type is unknown or mixed.
            public var itemType: ItemType?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// The human-readable name of the value list.
            public var name: String

            /// Type of the items in the value list. One of `card_fingerprint`, `card_bin`, `email`, `ip_address`, `country`, `string`, `case_sensitive_string`, or `customer_id`. Use `string` if the item type is unknown or mixed.
            public enum ItemType: String, Codable, CaseIterable {
                case cardBin = "card_bin"
                case cardFingerprint = "card_fingerprint"
                case caseSensitiveString = "case_sensitive_string"
                case country
                case customerID = "customer_id"
                case email
                case ipAddress = "ip_address"
                case string
            }

            public init(alias: String, expand: [String]? = nil, itemType: ItemType? = nil, metadata: [String: String]? = nil, name: String) {
                self.alias = alias
                self.expand = expand
                self.itemType = itemType
                self.metadata = metadata
                self.name = name
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(alias, forKey: "alias")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(itemType, forKey: "item_type")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(name, forKey: "name")
                return encoder.items
            }
        }
    }
}

extension Paths.Radar.ValueLists {
    public func valueList(_ valueList: String) -> WithValueList {
        WithValueList(path: "\(path)/\(valueList)")
    }

    public struct WithValueList {
        /// Path: `/v1/radar/value_lists/{value_list}`
        public let path: String

        /// <p>Retrieves a <code>ValueList</code> object.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.RadarValueList> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates a <code>ValueList</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged. Note that <code>item_type</code> is immutable.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.RadarValueList> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The name of the value list for use in rules.
            public var alias: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// The human-readable name of the value list.
            public var name: String?

            public init(alias: String? = nil, expand: [String]? = nil, metadata: [String: String]? = nil, name: String? = nil) {
                self.alias = alias
                self.expand = expand
                self.metadata = metadata
                self.name = name
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(alias, forKey: "alias")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(name, forKey: "name")
                return encoder.items
            }
        }

        /// <p>Deletes a <code>ValueList</code> object, also deleting any items contained within the value list. To be deleted, a value list must not be referenced in any rules.</p>
        public var delete: Request<StripeAPI.DeletedRadarValueList> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var recipients: Recipients {
        Recipients(path: "/v1/recipients")
    }

    public struct Recipients {
        /// Path: `/v1/recipients`
        public let path: String

        /// <p>Returns a list of your recipients. The recipients are returned sorted by creation date, with the most recently created recipients appearing first.</p>
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Recipient]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Recipient], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?
            public var type: `Type`?
            public var isVerified: Bool?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public enum `Type`: String, Codable, CaseIterable {
                case corporation
                case individual
            }

            public init(created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil, type: `Type`? = nil, isVerified: Bool? = nil) {
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
                self.type = type
                self.isVerified = isVerified
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(type, forKey: "type")
                encoder.encode(isVerified, forKey: "verified")
                return encoder.items
            }
        }

        /// <p>Creates a new <code>Recipient</code> object and verifies the recipient’s identity.
        /// Also verifies the recipient’s bank account information or debit card, if either is provided.</p>
        @available(*, deprecated, message: "Deprecated")
        public func post(_ body: PostRequest) -> Request<StripeAPI.Recipient> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// A bank account to attach to the recipient. You can provide either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details, with the options described below.
            public var bankAccount: String?
            /// A U.S. Visa or MasterCard debit card (_not_ prepaid) to attach to the recipient. If the debit card is not valid, recipient creation will fail. You can provide either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's debit card details, with the options described below. Although not all information is required, the extra info helps prevent fraud.
            public var card: String?
            /// An arbitrary string which you can attach to a `Recipient` object. It is displayed alongside the recipient in the web interface.
            public var description: String?
            /// The recipient's email address. It is displayed alongside the recipient in the web interface, and can be useful for searching and tracking.
            public var email: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The recipient's full, legal name. For type `individual`, should be in the format `First Last`, `First Middle Last`, or `First M Last` (no prefixes or suffixes). For `corporation`, the full, incorporated name.
            public var name: String
            /// The recipient's tax ID, as a string. For type `individual`, the full SSN; for type `corporation`, the full EIN.
            public var taxID: String?
            /// Type of the recipient: either `individual` or `corporation`.
            public var type: String

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(bankAccount: String? = nil, card: String? = nil, description: String? = nil, email: String? = nil, expand: [String]? = nil, metadata: Metadata? = nil, name: String, taxID: String? = nil, type: String) {
                self.bankAccount = bankAccount
                self.card = card
                self.description = description
                self.email = email
                self.expand = expand
                self.metadata = metadata
                self.name = name
                self.taxID = taxID
                self.type = type
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(bankAccount, forKey: "bank_account")
                encoder.encode(card, forKey: "card")
                encoder.encode(description, forKey: "description")
                encoder.encode(email, forKey: "email")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(name, forKey: "name")
                encoder.encode(taxID, forKey: "tax_id")
                encoder.encode(type, forKey: "type")
                return encoder.items
            }
        }
    }
}

extension Paths.Recipients {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/recipients/{id}`
        public let path: String

        /// <p>Retrieves the details of an existing recipient. You need only supply the unique recipient identifier that was returned upon recipient creation.</p>
        @available(*, deprecated, message: "Deprecated")
        public func get(expand: [String]? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var recipient: StripeAPI.Recipient?
            /// DeletedTransferRecipient
            public var deletedRecipient: StripeAPI.DeletedRecipient?

            public init(recipient: StripeAPI.Recipient? = nil, deletedRecipient: StripeAPI.DeletedRecipient? = nil) {
                self.recipient = recipient
                self.deletedRecipient = deletedRecipient
            }

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                self.recipient = try? container.decode(StripeAPI.Recipient.self)
                self.deletedRecipient = try? container.decode(StripeAPI.DeletedRecipient.self)
            }
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the specified recipient by setting the values of the parameters passed.
        /// Any parameters not provided will be left unchanged.</p>
        /// 
        /// <p>If you update the name or tax ID, the identity verification will automatically be rerun.
        /// If you update the bank account, the bank account validation will automatically be rerun.</p>
        @available(*, deprecated, message: "Deprecated")
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Recipient> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// A bank account to attach to the recipient. You can provide either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's bank account details, with the options described below.
            public var bankAccount: String?
            /// A U.S. Visa or MasterCard debit card (not prepaid) to attach to the recipient. You can provide either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary containing a user's debit card details, with the options described below. Passing `card` will create a new card, make it the new recipient default card, and delete the old recipient default (if one exists). If you want to add additional debit cards instead of replacing the existing default, use the [card creation API](https://stripe.com/docs/api#create_card). Whenever you attach a card to a recipient, Stripe will automatically validate the debit card.
            public var card: String?
            /// ID of the card to set as the recipient's new default for payouts.
            public var defaultCard: String?
            /// An arbitrary string which you can attach to a `Recipient` object. It is displayed alongside the recipient in the web interface.
            public var description: String?
            /// The recipient's email address. It is displayed alongside the recipient in the web interface, and can be useful for searching and tracking.
            public var email: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The recipient's full, legal name. For type `individual`, should be in the format `First Last`, `First Middle Last`, or `First M Last` (no prefixes or suffixes). For `corporation`, the full, incorporated name.
            public var name: String?
            /// The recipient's tax ID, as a string. For type `individual`, the full SSN; for type `corporation`, the full EIN.
            public var taxID: String?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(bankAccount: String? = nil, card: String? = nil, defaultCard: String? = nil, description: String? = nil, email: String? = nil, expand: [String]? = nil, metadata: Metadata? = nil, name: String? = nil, taxID: String? = nil) {
                self.bankAccount = bankAccount
                self.card = card
                self.defaultCard = defaultCard
                self.description = description
                self.email = email
                self.expand = expand
                self.metadata = metadata
                self.name = name
                self.taxID = taxID
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(bankAccount, forKey: "bank_account")
                encoder.encode(card, forKey: "card")
                encoder.encode(defaultCard, forKey: "default_card")
                encoder.encode(description, forKey: "description")
                encoder.encode(email, forKey: "email")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(name, forKey: "name")
                encoder.encode(taxID, forKey: "tax_id")
                return encoder.items
            }
        }

        /// <p>Permanently deletes a recipient. It cannot be undone.</p>
        @available(*, deprecated, message: "Deprecated")
        public var delete: Request<StripeAPI.DeletedRecipient> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var refunds: Refunds {
        Refunds(path: "/v1/refunds")
    }

    public struct Refunds {
        /// Path: `/v1/refunds`
        public let path: String

        /// <p>Returns a list of all refunds you’ve previously created. The refunds are returned in sorted order, with the most recent refunds appearing first. For convenience, the 10 most recent refunds are always available by default on the charge object.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Refund]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Refund], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var charge: String?
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var paymentIntent: String?
            public var startingAfter: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(charge: String? = nil, created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, paymentIntent: String? = nil, startingAfter: String? = nil) {
                self.charge = charge
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.paymentIntent = paymentIntent
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(charge, forKey: "charge")
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(paymentIntent, forKey: "payment_intent")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Create a refund.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Refund> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            public var amount: Int?
            public var charge: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            public var paymentIntent: String?
            public var reason: Reason?
            public var isRefundApplicationFee: Bool?
            public var isReverseTransfer: Bool?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public enum Reason: String, Codable, CaseIterable {
                case duplicate
                case fraudulent
                case requestedByCustomer = "requested_by_customer"
            }

            public init(amount: Int? = nil, charge: String? = nil, expand: [String]? = nil, metadata: Metadata? = nil, paymentIntent: String? = nil, reason: Reason? = nil, isRefundApplicationFee: Bool? = nil, isReverseTransfer: Bool? = nil) {
                self.amount = amount
                self.charge = charge
                self.expand = expand
                self.metadata = metadata
                self.paymentIntent = paymentIntent
                self.reason = reason
                self.isRefundApplicationFee = isRefundApplicationFee
                self.isReverseTransfer = isReverseTransfer
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(charge, forKey: "charge")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(paymentIntent, forKey: "payment_intent")
                encoder.encode(reason, forKey: "reason")
                encoder.encode(isRefundApplicationFee, forKey: "refund_application_fee")
                encoder.encode(isReverseTransfer, forKey: "reverse_transfer")
                return encoder.items
            }
        }
    }
}

extension Paths.Refunds {
    public func refund(_ refund: String) -> WithRefund {
        WithRefund(path: "\(path)/\(refund)")
    }

    public struct WithRefund {
        /// Path: `/v1/refunds/{refund}`
        public let path: String

        /// <p>Retrieves the details of an existing refund.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Refund> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the specified refund by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
        /// 
        /// <p>This request only accepts <code>metadata</code> as an argument.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Refund> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(expand: [String]? = nil, metadata: Metadata? = nil) {
                self.expand = expand
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var reporting: Reporting {
        Reporting(path: "/v1/reporting")
    }

    public struct Reporting {
        /// Path: `/v1/reporting`
        public let path: String
    }
}

extension Paths.Reporting {
    public var reportRuns: ReportRuns {
        ReportRuns(path: path + "/report_runs")
    }

    public struct ReportRuns {
        /// Path: `/v1/reporting/report_runs`
        public let path: String

        /// <p>Returns a list of Report Runs, with the most recent appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.ReportingReportRun]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.ReportingReportRun], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates a new object and begin running the report. (Certain report types require a <a href="https://stripe.com/docs/keys#test-live-modes">live-mode API key</a>.)</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.ReportingReportRun> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Run_parameter_specs
            ///
            /// Parameters specifying how the report should be run. Different Report Types have different required and optional parameters, listed in the [API Access to Reports](https://stripe.com/docs/reporting/statements/api) documentation.
            public var parameters: Parameters?
            /// The ID of the [report type](https://stripe.com/docs/reporting/statements/api#report-types) to run, such as `"balance.summary.1"`.
            public var reportType: String

            /// Run_parameter_specs
            ///
            /// Parameters specifying how the report should be run. Different Report Types have different required and optional parameters, listed in the [API Access to Reports](https://stripe.com/docs/reporting/statements/api) documentation.
            public struct Parameters: Encodable {
                public var columns: [String]?
                public var connectedAccount: String?
                public var currency: String?
                public var intervalEnd: Int?
                public var intervalStart: Int?
                public var payout: String?
                public var reportingCategory: ReportingCategory?
                public var timezone: Timezone?

                public enum ReportingCategory: String, Codable, CaseIterable {
                    case advance
                    case advanceFunding = "advance_funding"
                    case anticipationRepayment = "anticipation_repayment"
                    case charge
                    case chargeFailure = "charge_failure"
                    case connectCollectionTransfer = "connect_collection_transfer"
                    case connectReservedFunds = "connect_reserved_funds"
                    case contribution
                    case dispute
                    case disputeReversal = "dispute_reversal"
                    case fee
                    case financingPaydown = "financing_paydown"
                    case financingPaydownReversal = "financing_paydown_reversal"
                    case financingPayout = "financing_payout"
                    case financingPayoutReversal = "financing_payout_reversal"
                    case issuingAuthorizationHold = "issuing_authorization_hold"
                    case issuingAuthorizationRelease = "issuing_authorization_release"
                    case issuingDispute = "issuing_dispute"
                    case issuingTransaction = "issuing_transaction"
                    case networkCost = "network_cost"
                    case otherAdjustment = "other_adjustment"
                    case partialCaptureReversal = "partial_capture_reversal"
                    case payout
                    case payoutReversal = "payout_reversal"
                    case platformEarning = "platform_earning"
                    case platformEarningRefund = "platform_earning_refund"
                    case refund
                    case refundFailure = "refund_failure"
                    case riskReservedFunds = "risk_reserved_funds"
                    case tax
                    case topup
                    case topupReversal = "topup_reversal"
                    case transfer
                    case transferReversal = "transfer_reversal"
                }

                public enum Timezone: String, Codable, CaseIterable {
                    case africaAbidjan = "Africa/Abidjan"
                    case africaAccra = "Africa/Accra"
                    case africaAddisAbaba = "Africa/Addis_Ababa"
                    case africaAlgiers = "Africa/Algiers"
                    case africaAsmara = "Africa/Asmara"
                    case africaAsmera = "Africa/Asmera"
                    case africaBamako = "Africa/Bamako"
                    case africaBangui = "Africa/Bangui"
                    case africaBanjul = "Africa/Banjul"
                    case africaBissau = "Africa/Bissau"
                    case africaBlantyre = "Africa/Blantyre"
                    case africaBrazzaville = "Africa/Brazzaville"
                    case africaBujumbura = "Africa/Bujumbura"
                    case africaCairo = "Africa/Cairo"
                    case africaCasablanca = "Africa/Casablanca"
                    case africaCeuta = "Africa/Ceuta"
                    case africaConakry = "Africa/Conakry"
                    case africaDakar = "Africa/Dakar"
                    case africaDarEsSalaam = "Africa/Dar_es_Salaam"
                    case africaDjibouti = "Africa/Djibouti"
                    case africaDouala = "Africa/Douala"
                    case africaElAaiun = "Africa/El_Aaiun"
                    case africaFreetown = "Africa/Freetown"
                    case africaGaborone = "Africa/Gaborone"
                    case africaHarare = "Africa/Harare"
                    case africaJohannesburg = "Africa/Johannesburg"
                    case africaJuba = "Africa/Juba"
                    case africaKampala = "Africa/Kampala"
                    case africaKhartoum = "Africa/Khartoum"
                    case africaKigali = "Africa/Kigali"
                    case africaKinshasa = "Africa/Kinshasa"
                    case africaLagos = "Africa/Lagos"
                    case africaLibreville = "Africa/Libreville"
                    case africaLome = "Africa/Lome"
                    case africaLuanda = "Africa/Luanda"
                    case africaLubumbashi = "Africa/Lubumbashi"
                    case africaLusaka = "Africa/Lusaka"
                    case africaMalabo = "Africa/Malabo"
                    case africaMaputo = "Africa/Maputo"
                    case africaMaseru = "Africa/Maseru"
                    case africaMbabane = "Africa/Mbabane"
                    case africaMogadishu = "Africa/Mogadishu"
                    case africaMonrovia = "Africa/Monrovia"
                    case africaNairobi = "Africa/Nairobi"
                    case africaNdjamena = "Africa/Ndjamena"
                    case africaNiamey = "Africa/Niamey"
                    case africaNouakchott = "Africa/Nouakchott"
                    case africaOuagadougou = "Africa/Ouagadougou"
                    case africaPortoNovo = "Africa/Porto-Novo"
                    case africaSaoTome = "Africa/Sao_Tome"
                    case africaTimbuktu = "Africa/Timbuktu"
                    case africaTripoli = "Africa/Tripoli"
                    case africaTunis = "Africa/Tunis"
                    case africaWindhoek = "Africa/Windhoek"
                    case americaAdak = "America/Adak"
                    case americaAnchorage = "America/Anchorage"
                    case americaAnguilla = "America/Anguilla"
                    case americaAntigua = "America/Antigua"
                    case americaAraguaina = "America/Araguaina"
                    case americaArgentinaBuenosAires = "America/Argentina/Buenos_Aires"
                    case americaArgentinaCatamarca = "America/Argentina/Catamarca"
                    case americaArgentinaComodRivadavia = "America/Argentina/ComodRivadavia"
                    case americaArgentinaCordoba = "America/Argentina/Cordoba"
                    case americaArgentinaJujuy = "America/Argentina/Jujuy"
                    case americaArgentinaLaRioja = "America/Argentina/La_Rioja"
                    case americaArgentinaMendoza = "America/Argentina/Mendoza"
                    case americaArgentinaRioGallegos = "America/Argentina/Rio_Gallegos"
                    case americaArgentinaSalta = "America/Argentina/Salta"
                    case americaArgentinaSanJuan = "America/Argentina/San_Juan"
                    case americaArgentinaSanLuis = "America/Argentina/San_Luis"
                    case americaArgentinaTucuman = "America/Argentina/Tucuman"
                    case americaArgentinaUshuaia = "America/Argentina/Ushuaia"
                    case americaAruba = "America/Aruba"
                    case americaAsuncion = "America/Asuncion"
                    case americaAtikokan = "America/Atikokan"
                    case americaAtka = "America/Atka"
                    case americaBahia = "America/Bahia"
                    case americaBahiaBanderas = "America/Bahia_Banderas"
                    case americaBarbados = "America/Barbados"
                    case americaBelem = "America/Belem"
                    case americaBelize = "America/Belize"
                    case americaBlancSablon = "America/Blanc-Sablon"
                    case americaBoaVista = "America/Boa_Vista"
                    case americaBogota = "America/Bogota"
                    case americaBoise = "America/Boise"
                    case americaBuenosAires = "America/Buenos_Aires"
                    case americaCambridgeBay = "America/Cambridge_Bay"
                    case americaCampoGrande = "America/Campo_Grande"
                    case americaCancun = "America/Cancun"
                    case americaCaracas = "America/Caracas"
                    case americaCatamarca = "America/Catamarca"
                    case americaCayenne = "America/Cayenne"
                    case americaCayman = "America/Cayman"
                    case americaChicago = "America/Chicago"
                    case americaChihuahua = "America/Chihuahua"
                    case americaCoralHarbour = "America/Coral_Harbour"
                    case americaCordoba = "America/Cordoba"
                    case americaCostaRica = "America/Costa_Rica"
                    case americaCreston = "America/Creston"
                    case americaCuiaba = "America/Cuiaba"
                    case americaCuracao = "America/Curacao"
                    case americaDanmarkshavn = "America/Danmarkshavn"
                    case americaDawson = "America/Dawson"
                    case americaDawsonCreek = "America/Dawson_Creek"
                    case americaDenver = "America/Denver"
                    case americaDetroit = "America/Detroit"
                    case americaDominica = "America/Dominica"
                    case americaEdmonton = "America/Edmonton"
                    case americaEirunepe = "America/Eirunepe"
                    case americaElSalvador = "America/El_Salvador"
                    case americaEnsenada = "America/Ensenada"
                    case americaFortNelson = "America/Fort_Nelson"
                    case americaFortWayne = "America/Fort_Wayne"
                    case americaFortaleza = "America/Fortaleza"
                    case americaGlaceBay = "America/Glace_Bay"
                    case americaGodthab = "America/Godthab"
                    case americaGooseBay = "America/Goose_Bay"
                    case americaGrandTurk = "America/Grand_Turk"
                    case americaGrenada = "America/Grenada"
                    case americaGuadeloupe = "America/Guadeloupe"
                    case americaGuatemala = "America/Guatemala"
                    case americaGuayaquil = "America/Guayaquil"
                    case americaGuyana = "America/Guyana"
                    case americaHalifax = "America/Halifax"
                    case americaHavana = "America/Havana"
                    case americaHermosillo = "America/Hermosillo"
                    case americaIndianaIndianapolis = "America/Indiana/Indianapolis"
                    case americaIndianaKnox = "America/Indiana/Knox"
                    case americaIndianaMarengo = "America/Indiana/Marengo"
                    case americaIndianaPetersburg = "America/Indiana/Petersburg"
                    case americaIndianaTellCity = "America/Indiana/Tell_City"
                    case americaIndianaVevay = "America/Indiana/Vevay"
                    case americaIndianaVincennes = "America/Indiana/Vincennes"
                    case americaIndianaWinamac = "America/Indiana/Winamac"
                    case americaIndianapolis = "America/Indianapolis"
                    case americaInuvik = "America/Inuvik"
                    case americaIqaluit = "America/Iqaluit"
                    case americaJamaica = "America/Jamaica"
                    case americaJujuy = "America/Jujuy"
                    case americaJuneau = "America/Juneau"
                    case americaKentuckyLouisville = "America/Kentucky/Louisville"
                    case americaKentuckyMonticello = "America/Kentucky/Monticello"
                    case americaKnoxIN = "America/Knox_IN"
                    case americaKralendijk = "America/Kralendijk"
                    case americaLaPaz = "America/La_Paz"
                    case americaLima = "America/Lima"
                    case americaLosAngeles = "America/Los_Angeles"
                    case americaLouisville = "America/Louisville"
                    case americaLowerPrinces = "America/Lower_Princes"
                    case americaMaceio = "America/Maceio"
                    case americaManagua = "America/Managua"
                    case americaManaus = "America/Manaus"
                    case americaMarigot = "America/Marigot"
                    case americaMartinique = "America/Martinique"
                    case americaMatamoros = "America/Matamoros"
                    case americaMazatlan = "America/Mazatlan"
                    case americaMendoza = "America/Mendoza"
                    case americaMenominee = "America/Menominee"
                    case americaMerida = "America/Merida"
                    case americaMetlakatla = "America/Metlakatla"
                    case americaMexicoCity = "America/Mexico_City"
                    case americaMiquelon = "America/Miquelon"
                    case americaMoncton = "America/Moncton"
                    case americaMonterrey = "America/Monterrey"
                    case americaMontevideo = "America/Montevideo"
                    case americaMontreal = "America/Montreal"
                    case americaMontserrat = "America/Montserrat"
                    case americaNassau = "America/Nassau"
                    case americaNewYork = "America/New_York"
                    case americaNipigon = "America/Nipigon"
                    case americaNome = "America/Nome"
                    case americaNoronha = "America/Noronha"
                    case americaNorthDakotaBeulah = "America/North_Dakota/Beulah"
                    case americaNorthDakotaCenter = "America/North_Dakota/Center"
                    case americaNorthDakotaNewSalem = "America/North_Dakota/New_Salem"
                    case americaOjinaga = "America/Ojinaga"
                    case americaPanama = "America/Panama"
                    case americaPangnirtung = "America/Pangnirtung"
                    case americaParamaribo = "America/Paramaribo"
                    case americaPhoenix = "America/Phoenix"
                    case americaPortAuPrince = "America/Port-au-Prince"
                    case americaPortOfSpain = "America/Port_of_Spain"
                    case americaPortoAcre = "America/Porto_Acre"
                    case americaPortoVelho = "America/Porto_Velho"
                    case americaPuertoRico = "America/Puerto_Rico"
                    case americaPuntaArenas = "America/Punta_Arenas"
                    case americaRainyRiver = "America/Rainy_River"
                    case americaRankinInlet = "America/Rankin_Inlet"
                    case americaRecife = "America/Recife"
                    case americaRegina = "America/Regina"
                    case americaResolute = "America/Resolute"
                    case americaRioBranco = "America/Rio_Branco"
                    case americaRosario = "America/Rosario"
                    case americaSantaIsabel = "America/Santa_Isabel"
                    case americaSantarem = "America/Santarem"
                    case americaSantiago = "America/Santiago"
                    case americaSantoDomingo = "America/Santo_Domingo"
                    case americaSaoPaulo = "America/Sao_Paulo"
                    case americaScoresbysund = "America/Scoresbysund"
                    case americaShiprock = "America/Shiprock"
                    case americaSitka = "America/Sitka"
                    case americaStBarthelemy = "America/St_Barthelemy"
                    case americaStJohns = "America/St_Johns"
                    case americaStKitts = "America/St_Kitts"
                    case americaStLucia = "America/St_Lucia"
                    case americaStThomas = "America/St_Thomas"
                    case americaStVincent = "America/St_Vincent"
                    case americaSwiftCurrent = "America/Swift_Current"
                    case americaTegucigalpa = "America/Tegucigalpa"
                    case americaThule = "America/Thule"
                    case americaThunderBay = "America/Thunder_Bay"
                    case americaTijuana = "America/Tijuana"
                    case americaToronto = "America/Toronto"
                    case americaTortola = "America/Tortola"
                    case americaVancouver = "America/Vancouver"
                    case americaVirgin = "America/Virgin"
                    case americaWhitehorse = "America/Whitehorse"
                    case americaWinnipeg = "America/Winnipeg"
                    case americaYakutat = "America/Yakutat"
                    case americaYellowknife = "America/Yellowknife"
                    case antarcticaCasey = "Antarctica/Casey"
                    case antarcticaDavis = "Antarctica/Davis"
                    case antarcticaDumontDUrville = "Antarctica/DumontDUrville"
                    case antarcticaMacquarie = "Antarctica/Macquarie"
                    case antarcticaMawson = "Antarctica/Mawson"
                    case antarcticaMcMurdo = "Antarctica/McMurdo"
                    case antarcticaPalmer = "Antarctica/Palmer"
                    case antarcticaRothera = "Antarctica/Rothera"
                    case antarcticaSouthPole = "Antarctica/South_Pole"
                    case antarcticaSyowa = "Antarctica/Syowa"
                    case antarcticaTroll = "Antarctica/Troll"
                    case antarcticaVostok = "Antarctica/Vostok"
                    case arcticLongyearbyen = "Arctic/Longyearbyen"
                    case asiaAden = "Asia/Aden"
                    case asiaAlmaty = "Asia/Almaty"
                    case asiaAmman = "Asia/Amman"
                    case asiaAnadyr = "Asia/Anadyr"
                    case asiaAqtau = "Asia/Aqtau"
                    case asiaAqtobe = "Asia/Aqtobe"
                    case asiaAshgabat = "Asia/Ashgabat"
                    case asiaAshkhabad = "Asia/Ashkhabad"
                    case asiaAtyrau = "Asia/Atyrau"
                    case asiaBaghdad = "Asia/Baghdad"
                    case asiaBahrain = "Asia/Bahrain"
                    case asiaBaku = "Asia/Baku"
                    case asiaBangkok = "Asia/Bangkok"
                    case asiaBarnaul = "Asia/Barnaul"
                    case asiaBeirut = "Asia/Beirut"
                    case asiaBishkek = "Asia/Bishkek"
                    case asiaBrunei = "Asia/Brunei"
                    case asiaCalcutta = "Asia/Calcutta"
                    case asiaChita = "Asia/Chita"
                    case asiaChoibalsan = "Asia/Choibalsan"
                    case asiaChongqing = "Asia/Chongqing"
                    case asiaChungking = "Asia/Chungking"
                    case asiaColombo = "Asia/Colombo"
                    case asiaDacca = "Asia/Dacca"
                    case asiaDamascus = "Asia/Damascus"
                    case asiaDhaka = "Asia/Dhaka"
                    case asiaDili = "Asia/Dili"
                    case asiaDubai = "Asia/Dubai"
                    case asiaDushanbe = "Asia/Dushanbe"
                    case asiaFamagusta = "Asia/Famagusta"
                    case asiaGaza = "Asia/Gaza"
                    case asiaHarbin = "Asia/Harbin"
                    case asiaHebron = "Asia/Hebron"
                    case asiaHoChiMinh = "Asia/Ho_Chi_Minh"
                    case asiaHongKong = "Asia/Hong_Kong"
                    case asiaHovd = "Asia/Hovd"
                    case asiaIrkutsk = "Asia/Irkutsk"
                    case asiaIstanbul = "Asia/Istanbul"
                    case asiaJakarta = "Asia/Jakarta"
                    case asiaJayapura = "Asia/Jayapura"
                    case asiaJerusalem = "Asia/Jerusalem"
                    case asiaKabul = "Asia/Kabul"
                    case asiaKamchatka = "Asia/Kamchatka"
                    case asiaKarachi = "Asia/Karachi"
                    case asiaKashgar = "Asia/Kashgar"
                    case asiaKathmandu = "Asia/Kathmandu"
                    case asiaKatmandu = "Asia/Katmandu"
                    case asiaKhandyga = "Asia/Khandyga"
                    case asiaKolkata = "Asia/Kolkata"
                    case asiaKrasnoyarsk = "Asia/Krasnoyarsk"
                    case asiaKualaLumpur = "Asia/Kuala_Lumpur"
                    case asiaKuching = "Asia/Kuching"
                    case asiaKuwait = "Asia/Kuwait"
                    case asiaMacao = "Asia/Macao"
                    case asiaMacau = "Asia/Macau"
                    case asiaMagadan = "Asia/Magadan"
                    case asiaMakassar = "Asia/Makassar"
                    case asiaManila = "Asia/Manila"
                    case asiaMuscat = "Asia/Muscat"
                    case asiaNicosia = "Asia/Nicosia"
                    case asiaNovokuznetsk = "Asia/Novokuznetsk"
                    case asiaNovosibirsk = "Asia/Novosibirsk"
                    case asiaOmsk = "Asia/Omsk"
                    case asiaOral = "Asia/Oral"
                    case asiaPhnomPenh = "Asia/Phnom_Penh"
                    case asiaPontianak = "Asia/Pontianak"
                    case asiaPyongyang = "Asia/Pyongyang"
                    case asiaQatar = "Asia/Qatar"
                    case asiaQostanay = "Asia/Qostanay"
                    case asiaQyzylorda = "Asia/Qyzylorda"
                    case asiaRangoon = "Asia/Rangoon"
                    case asiaRiyadh = "Asia/Riyadh"
                    case asiaSaigon = "Asia/Saigon"
                    case asiaSakhalin = "Asia/Sakhalin"
                    case asiaSamarkand = "Asia/Samarkand"
                    case asiaSeoul = "Asia/Seoul"
                    case asiaShanghai = "Asia/Shanghai"
                    case asiaSingapore = "Asia/Singapore"
                    case asiaSrednekolymsk = "Asia/Srednekolymsk"
                    case asiaTaipei = "Asia/Taipei"
                    case asiaTashkent = "Asia/Tashkent"
                    case asiaTbilisi = "Asia/Tbilisi"
                    case asiaTehran = "Asia/Tehran"
                    case asiaTelAviv = "Asia/Tel_Aviv"
                    case asiaThimbu = "Asia/Thimbu"
                    case asiaThimphu = "Asia/Thimphu"
                    case asiaTokyo = "Asia/Tokyo"
                    case asiaTomsk = "Asia/Tomsk"
                    case asiaUjungPandang = "Asia/Ujung_Pandang"
                    case asiaUlaanbaatar = "Asia/Ulaanbaatar"
                    case asiaUlanBator = "Asia/Ulan_Bator"
                    case asiaUrumqi = "Asia/Urumqi"
                    case asiaUstNera = "Asia/Ust-Nera"
                    case asiaVientiane = "Asia/Vientiane"
                    case asiaVladivostok = "Asia/Vladivostok"
                    case asiaYakutsk = "Asia/Yakutsk"
                    case asiaYangon = "Asia/Yangon"
                    case asiaYekaterinburg = "Asia/Yekaterinburg"
                    case asiaYerevan = "Asia/Yerevan"
                    case atlanticAzores = "Atlantic/Azores"
                    case atlanticBermuda = "Atlantic/Bermuda"
                    case atlanticCanary = "Atlantic/Canary"
                    case atlanticCapeVerde = "Atlantic/Cape_Verde"
                    case atlanticFaeroe = "Atlantic/Faeroe"
                    case atlanticFaroe = "Atlantic/Faroe"
                    case atlanticJanMayen = "Atlantic/Jan_Mayen"
                    case atlanticMadeira = "Atlantic/Madeira"
                    case atlanticReykjavik = "Atlantic/Reykjavik"
                    case atlanticSouthGeorgia = "Atlantic/South_Georgia"
                    case atlanticStHelena = "Atlantic/St_Helena"
                    case atlanticStanley = "Atlantic/Stanley"
                    case australiaACT = "Australia/ACT"
                    case australiaAdelaide = "Australia/Adelaide"
                    case australiaBrisbane = "Australia/Brisbane"
                    case australiaBrokenHill = "Australia/Broken_Hill"
                    case australiaCanberra = "Australia/Canberra"
                    case australiaCurrie = "Australia/Currie"
                    case australiaDarwin = "Australia/Darwin"
                    case australiaEucla = "Australia/Eucla"
                    case australiaHobart = "Australia/Hobart"
                    case australiaLHI = "Australia/LHI"
                    case australiaLindeman = "Australia/Lindeman"
                    case australiaLordHowe = "Australia/Lord_Howe"
                    case australiaMelbourne = "Australia/Melbourne"
                    case australiaNSW = "Australia/NSW"
                    case australiaNorth = "Australia/North"
                    case australiaPerth = "Australia/Perth"
                    case australiaQueensland = "Australia/Queensland"
                    case australiaSouth = "Australia/South"
                    case australiaSydney = "Australia/Sydney"
                    case australiaTasmania = "Australia/Tasmania"
                    case australiaVictoria = "Australia/Victoria"
                    case australiaWest = "Australia/West"
                    case australiaYancowinna = "Australia/Yancowinna"
                    case brazilAcre = "Brazil/Acre"
                    case brazilDeNoronha = "Brazil/DeNoronha"
                    case brazilEast = "Brazil/East"
                    case brazilWest = "Brazil/West"
                    case cet = "CET"
                    case cst6cdt = "CST6CDT"
                    case canadaAtlantic = "Canada/Atlantic"
                    case canadaCentral = "Canada/Central"
                    case canadaEastern = "Canada/Eastern"
                    case canadaMountain = "Canada/Mountain"
                    case canadaNewfoundland = "Canada/Newfoundland"
                    case canadaPacific = "Canada/Pacific"
                    case canadaSaskatchewan = "Canada/Saskatchewan"
                    case canadaYukon = "Canada/Yukon"
                    case chileContinental = "Chile/Continental"
                    case chileEasterIsland = "Chile/EasterIsland"
                    case cuba = "Cuba"
                    case eet = "EET"
                    case est = "EST"
                    case est5edt = "EST5EDT"
                    case egypt = "Egypt"
                    case eire = "Eire"
                    case etcGMT = "Etc/GMT"
                    case etcGMT0 = "Etc/GMT+0"
                    case etcGMT1 = "Etc/GMT+1"
                    case etcGMT10 = "Etc/GMT+10"
                    case etcGMT11 = "Etc/GMT+11"
                    case etcGMT12 = "Etc/GMT+12"
                    case etcGMT2 = "Etc/GMT+2"
                    case etcGMT3 = "Etc/GMT+3"
                    case etcGMT4 = "Etc/GMT+4"
                    case etcGMT5 = "Etc/GMT+5"
                    case etcGMT6 = "Etc/GMT+6"
                    case etcGMT7 = "Etc/GMT+7"
                    case etcGMT8 = "Etc/GMT+8"
                    case etcGMT9 = "Etc/GMT+9"
                    case etcGMT02 = "Etc/GMT-0"
                    case etcGMT122 = "Etc/GMT-1"
                    case etcGMT102 = "Etc/GMT-10"
                    case etcGMT112 = "Etc/GMT-11"
                    case etcGMT123 = "Etc/GMT-12"
                    case etcGMT13 = "Etc/GMT-13"
                    case etcGMT14 = "Etc/GMT-14"
                    case etcGMT22 = "Etc/GMT-2"
                    case etcGMT32 = "Etc/GMT-3"
                    case etcGMT42 = "Etc/GMT-4"
                    case etcGMT52 = "Etc/GMT-5"
                    case etcGMT62 = "Etc/GMT-6"
                    case etcGMT72 = "Etc/GMT-7"
                    case etcGMT82 = "Etc/GMT-8"
                    case etcGMT92 = "Etc/GMT-9"
                    case etcGMT03 = "Etc/GMT0"
                    case etcGreenwich = "Etc/Greenwich"
                    case etcUCT = "Etc/UCT"
                    case etcUTC = "Etc/UTC"
                    case etcUniversal = "Etc/Universal"
                    case etcZulu = "Etc/Zulu"
                    case europeAmsterdam = "Europe/Amsterdam"
                    case europeAndorra = "Europe/Andorra"
                    case europeAstrakhan = "Europe/Astrakhan"
                    case europeAthens = "Europe/Athens"
                    case europeBelfast = "Europe/Belfast"
                    case europeBelgrade = "Europe/Belgrade"
                    case europeBerlin = "Europe/Berlin"
                    case europeBratislava = "Europe/Bratislava"
                    case europeBrussels = "Europe/Brussels"
                    case europeBucharest = "Europe/Bucharest"
                    case europeBudapest = "Europe/Budapest"
                    case europeBusingen = "Europe/Busingen"
                    case europeChisinau = "Europe/Chisinau"
                    case europeCopenhagen = "Europe/Copenhagen"
                    case europeDublin = "Europe/Dublin"
                    case europeGibraltar = "Europe/Gibraltar"
                    case europeGuernsey = "Europe/Guernsey"
                    case europeHelsinki = "Europe/Helsinki"
                    case europeIsleOfMan = "Europe/Isle_of_Man"
                    case europeIstanbul = "Europe/Istanbul"
                    case europeJersey = "Europe/Jersey"
                    case europeKaliningrad = "Europe/Kaliningrad"
                    case europeKiev = "Europe/Kiev"
                    case europeKirov = "Europe/Kirov"
                    case europeLisbon = "Europe/Lisbon"
                    case europeLjubljana = "Europe/Ljubljana"
                    case europeLondon = "Europe/London"
                    case europeLuxembourg = "Europe/Luxembourg"
                    case europeMadrid = "Europe/Madrid"
                    case europeMalta = "Europe/Malta"
                    case europeMariehamn = "Europe/Mariehamn"
                    case europeMinsk = "Europe/Minsk"
                    case europeMonaco = "Europe/Monaco"
                    case europeMoscow = "Europe/Moscow"
                    case europeNicosia = "Europe/Nicosia"
                    case europeOslo = "Europe/Oslo"
                    case europeParis = "Europe/Paris"
                    case europePodgorica = "Europe/Podgorica"
                    case europePrague = "Europe/Prague"
                    case europeRiga = "Europe/Riga"
                    case europeRome = "Europe/Rome"
                    case europeSamara = "Europe/Samara"
                    case europeSanMarino = "Europe/San_Marino"
                    case europeSarajevo = "Europe/Sarajevo"
                    case europeSaratov = "Europe/Saratov"
                    case europeSimferopol = "Europe/Simferopol"
                    case europeSkopje = "Europe/Skopje"
                    case europeSofia = "Europe/Sofia"
                    case europeStockholm = "Europe/Stockholm"
                    case europeTallinn = "Europe/Tallinn"
                    case europeTirane = "Europe/Tirane"
                    case europeTiraspol = "Europe/Tiraspol"
                    case europeUlyanovsk = "Europe/Ulyanovsk"
                    case europeUzhgorod = "Europe/Uzhgorod"
                    case europeVaduz = "Europe/Vaduz"
                    case europeVatican = "Europe/Vatican"
                    case europeVienna = "Europe/Vienna"
                    case europeVilnius = "Europe/Vilnius"
                    case europeVolgograd = "Europe/Volgograd"
                    case europeWarsaw = "Europe/Warsaw"
                    case europeZagreb = "Europe/Zagreb"
                    case europeZaporozhye = "Europe/Zaporozhye"
                    case europeZurich = "Europe/Zurich"
                    case factory = "Factory"
                    case gb = "GB"
                    case gBEire = "GB-Eire"
                    case gmt = "GMT"
                    case gmt0 = "GMT+0"
                    case gmt02 = "GMT-0"
                    case gmt03 = "GMT0"
                    case greenwich = "Greenwich"
                    case hst = "HST"
                    case hongkong = "Hongkong"
                    case iceland = "Iceland"
                    case indianAntananarivo = "Indian/Antananarivo"
                    case indianChagos = "Indian/Chagos"
                    case indianChristmas = "Indian/Christmas"
                    case indianCocos = "Indian/Cocos"
                    case indianComoro = "Indian/Comoro"
                    case indianKerguelen = "Indian/Kerguelen"
                    case indianMahe = "Indian/Mahe"
                    case indianMaldives = "Indian/Maldives"
                    case indianMauritius = "Indian/Mauritius"
                    case indianMayotte = "Indian/Mayotte"
                    case indianReunion = "Indian/Reunion"
                    case iran = "Iran"
                    case israel = "Israel"
                    case jamaica = "Jamaica"
                    case japan = "Japan"
                    case kwajalein = "Kwajalein"
                    case libya = "Libya"
                    case met = "MET"
                    case mst = "MST"
                    case mst7mdt = "MST7MDT"
                    case mexicoBajaNorte = "Mexico/BajaNorte"
                    case mexicoBajaSur = "Mexico/BajaSur"
                    case mexicoGeneral = "Mexico/General"
                    case nz = "NZ"
                    case nzChat = "NZ-CHAT"
                    case navajo = "Navajo"
                    case prc = "PRC"
                    case pst8pdt = "PST8PDT"
                    case pacificApia = "Pacific/Apia"
                    case pacificAuckland = "Pacific/Auckland"
                    case pacificBougainville = "Pacific/Bougainville"
                    case pacificChatham = "Pacific/Chatham"
                    case pacificChuuk = "Pacific/Chuuk"
                    case pacificEaster = "Pacific/Easter"
                    case pacificEfate = "Pacific/Efate"
                    case pacificEnderbury = "Pacific/Enderbury"
                    case pacificFakaofo = "Pacific/Fakaofo"
                    case pacificFiji = "Pacific/Fiji"
                    case pacificFunafuti = "Pacific/Funafuti"
                    case pacificGalapagos = "Pacific/Galapagos"
                    case pacificGambier = "Pacific/Gambier"
                    case pacificGuadalcanal = "Pacific/Guadalcanal"
                    case pacificGuam = "Pacific/Guam"
                    case pacificHonolulu = "Pacific/Honolulu"
                    case pacificJohnston = "Pacific/Johnston"
                    case pacificKiritimati = "Pacific/Kiritimati"
                    case pacificKosrae = "Pacific/Kosrae"
                    case pacificKwajalein = "Pacific/Kwajalein"
                    case pacificMajuro = "Pacific/Majuro"
                    case pacificMarquesas = "Pacific/Marquesas"
                    case pacificMidway = "Pacific/Midway"
                    case pacificNauru = "Pacific/Nauru"
                    case pacificNiue = "Pacific/Niue"
                    case pacificNorfolk = "Pacific/Norfolk"
                    case pacificNoumea = "Pacific/Noumea"
                    case pacificPagoPago = "Pacific/Pago_Pago"
                    case pacificPalau = "Pacific/Palau"
                    case pacificPitcairn = "Pacific/Pitcairn"
                    case pacificPohnpei = "Pacific/Pohnpei"
                    case pacificPonape = "Pacific/Ponape"
                    case pacificPortMoresby = "Pacific/Port_Moresby"
                    case pacificRarotonga = "Pacific/Rarotonga"
                    case pacificSaipan = "Pacific/Saipan"
                    case pacificSamoa = "Pacific/Samoa"
                    case pacificTahiti = "Pacific/Tahiti"
                    case pacificTarawa = "Pacific/Tarawa"
                    case pacificTongatapu = "Pacific/Tongatapu"
                    case pacificTruk = "Pacific/Truk"
                    case pacificWake = "Pacific/Wake"
                    case pacificWallis = "Pacific/Wallis"
                    case pacificYap = "Pacific/Yap"
                    case poland = "Poland"
                    case portugal = "Portugal"
                    case roc = "ROC"
                    case rok = "ROK"
                    case singapore = "Singapore"
                    case turkey = "Turkey"
                    case uct = "UCT"
                    case uSAlaska = "US/Alaska"
                    case uSAleutian = "US/Aleutian"
                    case uSArizona = "US/Arizona"
                    case uSCentral = "US/Central"
                    case uSEastIndiana = "US/East-Indiana"
                    case uSEastern = "US/Eastern"
                    case uSHawaii = "US/Hawaii"
                    case uSIndianaStarke = "US/Indiana-Starke"
                    case uSMichigan = "US/Michigan"
                    case uSMountain = "US/Mountain"
                    case uSPacific = "US/Pacific"
                    case uSPacificNew = "US/Pacific-New"
                    case uSSamoa = "US/Samoa"
                    case utc = "UTC"
                    case universal = "Universal"
                    case wSu = "W-SU"
                    case wet = "WET"
                    case zulu = "Zulu"
                }

                public init(columns: [String]? = nil, connectedAccount: String? = nil, currency: String? = nil, intervalEnd: Int? = nil, intervalStart: Int? = nil, payout: String? = nil, reportingCategory: ReportingCategory? = nil, timezone: Timezone? = nil) {
                    self.columns = columns
                    self.connectedAccount = connectedAccount
                    self.currency = currency
                    self.intervalEnd = intervalEnd
                    self.intervalStart = intervalStart
                    self.payout = payout
                    self.reportingCategory = reportingCategory
                    self.timezone = timezone
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(columns, forKey: "columns")
                    encoder.encode(connectedAccount, forKey: "connected_account")
                    encoder.encode(currency, forKey: "currency")
                    encoder.encode(intervalEnd, forKey: "interval_end")
                    encoder.encode(intervalStart, forKey: "interval_start")
                    encoder.encode(payout, forKey: "payout")
                    encoder.encode(reportingCategory, forKey: "reporting_category")
                    encoder.encode(timezone, forKey: "timezone")
                    return encoder.items
                }
            }

            public init(expand: [String]? = nil, parameters: Parameters? = nil, reportType: String) {
                self.expand = expand
                self.parameters = parameters
                self.reportType = reportType
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(parameters, forKey: "parameters")
                encoder.encode(reportType, forKey: "report_type")
                return encoder.items
            }
        }
    }
}

extension Paths.Reporting.ReportRuns {
    public func reportRun(_ reportRun: String) -> WithReportRun {
        WithReportRun(path: "\(path)/\(reportRun)")
    }

    public struct WithReportRun {
        /// Path: `/v1/reporting/report_runs/{report_run}`
        public let path: String

        /// <p>Retrieves the details of an existing Report Run.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.ReportingReportRun> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths.Reporting {
    public var reportTypes: ReportTypes {
        ReportTypes(path: path + "/report_types")
    }

    public struct ReportTypes {
        /// Path: `/v1/reporting/report_types`
        public let path: String

        /// <p>Returns a full list of Report Types.</p>
        public func get(expand: [String]? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        /// FinancialReportingFinanceReportTypeList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.ReportingReportType]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.ReportingReportType], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths.Reporting.ReportTypes {
    public func reportType(_ reportType: String) -> WithReportType {
        WithReportType(path: "\(path)/\(reportType)")
    }

    public struct WithReportType {
        /// Path: `/v1/reporting/report_types/{report_type}`
        public let path: String

        /// <p>Retrieves the details of a Report Type. (Certain report types require a <a href="https://stripe.com/docs/keys#test-live-modes">live-mode API key</a>.)</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.ReportingReportType> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths {
    public static var reviews: Reviews {
        Reviews(path: "/v1/reviews")
    }

    public struct Reviews {
        /// Path: `/v1/reviews`
        public let path: String

        /// <p>Returns a list of <code>Review</code> objects that have <code>open</code> set to <code>true</code>. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Review]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Review], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }
    }
}

extension Paths.Reviews {
    public func review(_ review: String) -> WithReview {
        WithReview(path: "\(path)/\(review)")
    }

    public struct WithReview {
        /// Path: `/v1/reviews/{review}`
        public let path: String

        /// <p>Retrieves a <code>Review</code> object.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Review> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths.Reviews.WithReview {
    public var approve: Approve {
        Approve(path: path + "/approve")
    }

    public struct Approve {
        /// Path: `/v1/reviews/{review}/approve`
        public let path: String

        /// <p>Approves a <code>Review</code> object, closing it and removing it from the list of reviews.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Review> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(expand: [String]? = nil) {
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var setupAttempts: SetupAttempts {
        SetupAttempts(path: "/v1/setup_attempts")
    }

    public struct SetupAttempts {
        /// Path: `/v1/setup_attempts`
        public let path: String

        /// <p>Returns a list of SetupAttempts associated with a provided SetupIntent.</p>
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        /// PaymentFlowsSetupIntentSetupAttemptList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.SetupAttempt]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.SetupAttempt], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var setupIntent: String
            public var startingAfter: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, setupIntent: String, startingAfter: String? = nil) {
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.setupIntent = setupIntent
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(setupIntent, forKey: "setup_intent")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var setupIntents: SetupIntents {
        SetupIntents(path: "/v1/setup_intents")
    }

    public struct SetupIntents {
        /// Path: `/v1/setup_intents`
        public let path: String

        /// <p>Returns a list of SetupIntents.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// PaymentFlowsSetupIntentList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.SetupIntent]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.SetupIntent], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var customer: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var paymentMethod: String?
            public var startingAfter: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(created: Created? = nil, customer: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, paymentMethod: String? = nil, startingAfter: String? = nil) {
                self.created = created
                self.customer = customer
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.paymentMethod = paymentMethod
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(customer, forKey: "customer")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(paymentMethod, forKey: "payment_method")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates a SetupIntent object.</p>
        /// 
        /// <p>After the SetupIntent is created, attach a payment method and <a href="/docs/api/setup_intents/confirm">confirm</a>
        /// to collect any required permissions to charge the payment method later.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.SetupIntent> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Set to `true` to attempt to confirm this SetupIntent immediately. This parameter defaults to `false`. If the payment method attached is a card, a return_url may be provided in case additional authentication is required.
            public var isConfirm: Bool?
            /// ID of the Customer this SetupIntent belongs to, if one exists.
            /// 
            /// If present, the SetupIntent's payment method will be attached to the Customer on successful setup. Payment methods attached to other Customers cannot be used with this SetupIntent.
            public var customer: String?
            /// An arbitrary string attached to the object. Often useful for displaying to users.
            public var description: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Secret_key_param
            ///
            /// This hash contains details about the Mandate to create. This parameter can only be used with [`confirm=true`](https://stripe.com/docs/api/setup_intents/create#create_setup_intent-confirm).
            public var mandateData: MandateData?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// The Stripe account ID for which this SetupIntent is created.
            public var onBehalfOf: String?
            /// ID of the payment method (a PaymentMethod, Card, or saved Source object) to attach to this SetupIntent.
            public var paymentMethod: String?
            /// Payment_method_options_param
            ///
            /// Payment-method-specific configuration for this SetupIntent.
            public var paymentMethodOptions: PaymentMethodOptions?
            /// The list of payment method types (e.g. card) that this SetupIntent is allowed to use. If this is not provided, defaults to ["card"].
            public var paymentMethodTypes: [String]?
            /// The URL to redirect your customer back to after they authenticate or cancel their payment on the payment method's app or site. If you'd prefer to redirect to a mobile application, you can alternatively supply an application URI scheme. This parameter can only be used with [`confirm=true`](https://stripe.com/docs/api/setup_intents/create#create_setup_intent-confirm).
            public var returnURL: String?
            /// Setup_intent_single_use_params
            ///
            /// If this hash is populated, this SetupIntent will generate a single_use Mandate on success.
            public var singleUse: SingleUse?
            /// Indicates how the payment method is intended to be used in the future. If not provided, this value defaults to `off_session`.
            public var usage: Usage?

            /// Secret_key_param
            ///
            /// This hash contains details about the Mandate to create. This parameter can only be used with [`confirm=true`](https://stripe.com/docs/api/setup_intents/create#create_setup_intent-confirm).
            public struct MandateData: Encodable {
                /// Customer_acceptance_param
                public var customerAcceptance: CustomerAcceptance

                /// Customer_acceptance_param
                public struct CustomerAcceptance: Encodable {
                    public var acceptedAt: Int?
                    /// Offline_param
                    public var offline: [String: AnyJSON]?
                    /// Online_param
                    public var online: Online?
                    public var type: `Type`

                    /// Online_param
                    public struct Online: Encodable {
                        public var ipAddress: String
                        public var userAgent: String

                        public init(ipAddress: String, userAgent: String) {
                            self.ipAddress = ipAddress
                            self.userAgent = userAgent
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(ipAddress, forKey: "ip_address")
                            encoder.encode(userAgent, forKey: "user_agent")
                            return encoder.items
                        }
                    }

                    public enum `Type`: String, Codable, CaseIterable {
                        case offline
                        case online
                    }

                    public init(acceptedAt: Int? = nil, offline: [String: AnyJSON]? = nil, online: Online? = nil, type: `Type`) {
                        self.acceptedAt = acceptedAt
                        self.offline = offline
                        self.online = online
                        self.type = type
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(acceptedAt, forKey: "accepted_at")
                        encoder.encode(offline, forKey: "offline")
                        encoder.encode(online, forKey: "online")
                        encoder.encode(type, forKey: "type")
                        return encoder.items
                    }
                }

                public init(customerAcceptance: CustomerAcceptance) {
                    self.customerAcceptance = customerAcceptance
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(customerAcceptance, forKey: "customer_acceptance")
                    return encoder.items
                }
            }

            /// Payment_method_options_param
            ///
            /// Payment-method-specific configuration for this SetupIntent.
            public struct PaymentMethodOptions: Encodable {
                /// Setup_intent_payment_method_options_param
                public var acssDebit: AcssDebit?
                /// Setup_intent_param
                public var card: Card?
                /// Setup_intent_payment_method_options_param
                public var sepaDebit: SepaDebit?

                /// Setup_intent_payment_method_options_param
                public struct AcssDebit: Encodable {
                    public var currency: Currency?
                    /// Setup_intent_payment_method_options_mandate_options_param
                    public var mandateOptions: MandateOptions?
                    public var verificationMethod: VerificationMethod?

                    public enum Currency: String, Codable, CaseIterable {
                        case cad
                        case usd
                    }

                    /// Setup_intent_payment_method_options_mandate_options_param
                    public struct MandateOptions: Encodable {
                        public var customMandateURL: CustomMandateURL?
                        public var defaultFor: [DefaultForItem]?
                        public var intervalDescription: String?
                        public var paymentSchedule: PaymentSchedule?
                        public var transactionType: TransactionType?

                        public struct CustomMandateURL: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public enum DefaultForItem: String, Codable, CaseIterable {
                            case invoice
                            case subscription
                        }

                        public enum PaymentSchedule: String, Codable, CaseIterable {
                            case combined
                            case interval
                            case sporadic
                        }

                        public enum TransactionType: String, Codable, CaseIterable {
                            case business
                            case personal
                        }

                        public init(customMandateURL: CustomMandateURL? = nil, defaultFor: [DefaultForItem]? = nil, intervalDescription: String? = nil, paymentSchedule: PaymentSchedule? = nil, transactionType: TransactionType? = nil) {
                            self.customMandateURL = customMandateURL
                            self.defaultFor = defaultFor
                            self.intervalDescription = intervalDescription
                            self.paymentSchedule = paymentSchedule
                            self.transactionType = transactionType
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(customMandateURL, forKey: "custom_mandate_url")
                            encoder.encode(defaultFor, forKey: "default_for")
                            encoder.encode(intervalDescription, forKey: "interval_description")
                            encoder.encode(paymentSchedule, forKey: "payment_schedule")
                            encoder.encode(transactionType, forKey: "transaction_type")
                            return encoder.items
                        }
                    }

                    public enum VerificationMethod: String, Codable, CaseIterable {
                        case automatic
                        case instant
                        case microdeposits
                    }

                    public init(currency: Currency? = nil, mandateOptions: MandateOptions? = nil, verificationMethod: VerificationMethod? = nil) {
                        self.currency = currency
                        self.mandateOptions = mandateOptions
                        self.verificationMethod = verificationMethod
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(mandateOptions, forKey: "mandate_options")
                        encoder.encode(verificationMethod, forKey: "verification_method")
                        return encoder.items
                    }
                }

                /// Setup_intent_param
                public struct Card: Encodable {
                    public var requestThreeDSecure: RequestThreeDSecure?

                    public enum RequestThreeDSecure: String, Codable, CaseIterable {
                        case any
                        case automatic
                    }

                    public init(requestThreeDSecure: RequestThreeDSecure? = nil) {
                        self.requestThreeDSecure = requestThreeDSecure
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(requestThreeDSecure, forKey: "request_three_d_secure")
                        return encoder.items
                    }
                }

                /// Setup_intent_payment_method_options_param
                public struct SepaDebit: Encodable {
                    /// Payment_method_options_mandate_options_param
                    public var mandateOptions: [String: AnyJSON]?

                    public init(mandateOptions: [String: AnyJSON]? = nil) {
                        self.mandateOptions = mandateOptions
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(mandateOptions, forKey: "mandate_options")
                        return encoder.items
                    }
                }

                public init(acssDebit: AcssDebit? = nil, card: Card? = nil, sepaDebit: SepaDebit? = nil) {
                    self.acssDebit = acssDebit
                    self.card = card
                    self.sepaDebit = sepaDebit
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(acssDebit, forKey: "acss_debit")
                    encoder.encode(card, forKey: "card")
                    encoder.encode(sepaDebit, forKey: "sepa_debit")
                    return encoder.items
                }
            }

            /// Setup_intent_single_use_params
            ///
            /// If this hash is populated, this SetupIntent will generate a single_use Mandate on success.
            public struct SingleUse: Encodable {
                public var amount: Int
                public var currency: String

                public init(amount: Int, currency: String) {
                    self.amount = amount
                    self.currency = currency
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(amount, forKey: "amount")
                    encoder.encode(currency, forKey: "currency")
                    return encoder.items
                }
            }

            /// Indicates how the payment method is intended to be used in the future. If not provided, this value defaults to `off_session`.
            public enum Usage: String, Codable, CaseIterable {
                case offSession = "off_session"
                case onSession = "on_session"
            }

            public init(isConfirm: Bool? = nil, customer: String? = nil, description: String? = nil, expand: [String]? = nil, mandateData: MandateData? = nil, metadata: [String: String]? = nil, onBehalfOf: String? = nil, paymentMethod: String? = nil, paymentMethodOptions: PaymentMethodOptions? = nil, paymentMethodTypes: [String]? = nil, returnURL: String? = nil, singleUse: SingleUse? = nil, usage: Usage? = nil) {
                self.isConfirm = isConfirm
                self.customer = customer
                self.description = description
                self.expand = expand
                self.mandateData = mandateData
                self.metadata = metadata
                self.onBehalfOf = onBehalfOf
                self.paymentMethod = paymentMethod
                self.paymentMethodOptions = paymentMethodOptions
                self.paymentMethodTypes = paymentMethodTypes
                self.returnURL = returnURL
                self.singleUse = singleUse
                self.usage = usage
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isConfirm, forKey: "confirm")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(description, forKey: "description")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(mandateData, forKey: "mandate_data")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(onBehalfOf, forKey: "on_behalf_of")
                encoder.encode(paymentMethod, forKey: "payment_method")
                encoder.encode(paymentMethodOptions, forKey: "payment_method_options")
                encoder.encode(paymentMethodTypes, forKey: "payment_method_types")
                encoder.encode(returnURL, forKey: "return_url")
                encoder.encode(singleUse, forKey: "single_use")
                encoder.encode(usage, forKey: "usage")
                return encoder.items
            }
        }
    }
}

extension Paths.SetupIntents {
    public func intent(_ intent: String) -> WithIntent {
        WithIntent(path: "\(path)/\(intent)")
    }

    public struct WithIntent {
        /// Path: `/v1/setup_intents/{intent}`
        public let path: String

        /// <p>Retrieves the details of a SetupIntent that has previously been created. </p>
        /// 
        /// <p>Client-side retrieval using a publishable key is allowed when the <code>client_secret</code> is provided in the query string. </p>
        /// 
        /// <p>When retrieved with a publishable key, only a subset of properties will be returned. Please refer to the <a href="#setup_intent_object">SetupIntent</a> object reference for more details.</p>
        public func get(clientSecret: String? = nil, expand: [String]? = nil) -> Request<StripeAPI.SetupIntent> {
            .get(path, query: makeGetQuery(clientSecret, expand))
        }

        private func makeGetQuery(_ clientSecret: String?, _ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(clientSecret, forKey: "client_secret")
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates a SetupIntent object.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.SetupIntent> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// ID of the Customer this SetupIntent belongs to, if one exists.
            /// 
            /// If present, the SetupIntent's payment method will be attached to the Customer on successful setup. Payment methods attached to other Customers cannot be used with this SetupIntent.
            public var customer: String?
            /// An arbitrary string attached to the object. Often useful for displaying to users.
            public var description: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// ID of the payment method (a PaymentMethod, Card, or saved Source object) to attach to this SetupIntent.
            public var paymentMethod: String?
            /// Payment_method_options_param
            ///
            /// Payment-method-specific configuration for this SetupIntent.
            public var paymentMethodOptions: PaymentMethodOptions?
            /// The list of payment method types (e.g. card) that this SetupIntent is allowed to set up. If this is not provided, defaults to ["card"].
            public var paymentMethodTypes: [String]?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Payment_method_options_param
            ///
            /// Payment-method-specific configuration for this SetupIntent.
            public struct PaymentMethodOptions: Encodable {
                /// Setup_intent_payment_method_options_param
                public var acssDebit: AcssDebit?
                /// Setup_intent_param
                public var card: Card?
                /// Setup_intent_payment_method_options_param
                public var sepaDebit: SepaDebit?

                /// Setup_intent_payment_method_options_param
                public struct AcssDebit: Encodable {
                    public var currency: Currency?
                    /// Setup_intent_payment_method_options_mandate_options_param
                    public var mandateOptions: MandateOptions?
                    public var verificationMethod: VerificationMethod?

                    public enum Currency: String, Codable, CaseIterable {
                        case cad
                        case usd
                    }

                    /// Setup_intent_payment_method_options_mandate_options_param
                    public struct MandateOptions: Encodable {
                        public var customMandateURL: CustomMandateURL?
                        public var defaultFor: [DefaultForItem]?
                        public var intervalDescription: String?
                        public var paymentSchedule: PaymentSchedule?
                        public var transactionType: TransactionType?

                        public struct CustomMandateURL: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public enum DefaultForItem: String, Codable, CaseIterable {
                            case invoice
                            case subscription
                        }

                        public enum PaymentSchedule: String, Codable, CaseIterable {
                            case combined
                            case interval
                            case sporadic
                        }

                        public enum TransactionType: String, Codable, CaseIterable {
                            case business
                            case personal
                        }

                        public init(customMandateURL: CustomMandateURL? = nil, defaultFor: [DefaultForItem]? = nil, intervalDescription: String? = nil, paymentSchedule: PaymentSchedule? = nil, transactionType: TransactionType? = nil) {
                            self.customMandateURL = customMandateURL
                            self.defaultFor = defaultFor
                            self.intervalDescription = intervalDescription
                            self.paymentSchedule = paymentSchedule
                            self.transactionType = transactionType
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(customMandateURL, forKey: "custom_mandate_url")
                            encoder.encode(defaultFor, forKey: "default_for")
                            encoder.encode(intervalDescription, forKey: "interval_description")
                            encoder.encode(paymentSchedule, forKey: "payment_schedule")
                            encoder.encode(transactionType, forKey: "transaction_type")
                            return encoder.items
                        }
                    }

                    public enum VerificationMethod: String, Codable, CaseIterable {
                        case automatic
                        case instant
                        case microdeposits
                    }

                    public init(currency: Currency? = nil, mandateOptions: MandateOptions? = nil, verificationMethod: VerificationMethod? = nil) {
                        self.currency = currency
                        self.mandateOptions = mandateOptions
                        self.verificationMethod = verificationMethod
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(mandateOptions, forKey: "mandate_options")
                        encoder.encode(verificationMethod, forKey: "verification_method")
                        return encoder.items
                    }
                }

                /// Setup_intent_param
                public struct Card: Encodable {
                    public var requestThreeDSecure: RequestThreeDSecure?

                    public enum RequestThreeDSecure: String, Codable, CaseIterable {
                        case any
                        case automatic
                    }

                    public init(requestThreeDSecure: RequestThreeDSecure? = nil) {
                        self.requestThreeDSecure = requestThreeDSecure
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(requestThreeDSecure, forKey: "request_three_d_secure")
                        return encoder.items
                    }
                }

                /// Setup_intent_payment_method_options_param
                public struct SepaDebit: Encodable {
                    /// Payment_method_options_mandate_options_param
                    public var mandateOptions: [String: AnyJSON]?

                    public init(mandateOptions: [String: AnyJSON]? = nil) {
                        self.mandateOptions = mandateOptions
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(mandateOptions, forKey: "mandate_options")
                        return encoder.items
                    }
                }

                public init(acssDebit: AcssDebit? = nil, card: Card? = nil, sepaDebit: SepaDebit? = nil) {
                    self.acssDebit = acssDebit
                    self.card = card
                    self.sepaDebit = sepaDebit
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(acssDebit, forKey: "acss_debit")
                    encoder.encode(card, forKey: "card")
                    encoder.encode(sepaDebit, forKey: "sepa_debit")
                    return encoder.items
                }
            }

            public init(customer: String? = nil, description: String? = nil, expand: [String]? = nil, metadata: Metadata? = nil, paymentMethod: String? = nil, paymentMethodOptions: PaymentMethodOptions? = nil, paymentMethodTypes: [String]? = nil) {
                self.customer = customer
                self.description = description
                self.expand = expand
                self.metadata = metadata
                self.paymentMethod = paymentMethod
                self.paymentMethodOptions = paymentMethodOptions
                self.paymentMethodTypes = paymentMethodTypes
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(customer, forKey: "customer")
                encoder.encode(description, forKey: "description")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(paymentMethod, forKey: "payment_method")
                encoder.encode(paymentMethodOptions, forKey: "payment_method_options")
                encoder.encode(paymentMethodTypes, forKey: "payment_method_types")
                return encoder.items
            }
        }
    }
}

extension Paths.SetupIntents.WithIntent {
    public var cancel: Cancel {
        Cancel(path: path + "/cancel")
    }

    public struct Cancel {
        /// Path: `/v1/setup_intents/{intent}/cancel`
        public let path: String

        /// <p>A SetupIntent object can be canceled when it is in one of these statuses: <code>requires_payment_method</code>, <code>requires_confirmation</code>, or <code>requires_action</code>. </p>
        /// 
        /// <p>Once canceled, setup is abandoned and any operations on the SetupIntent will fail with an error.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.SetupIntent> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Reason for canceling this SetupIntent. Possible values are `abandoned`, `requested_by_customer`, or `duplicate`
            public var cancellationReason: CancellationReason?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            /// Reason for canceling this SetupIntent. Possible values are `abandoned`, `requested_by_customer`, or `duplicate`
            public enum CancellationReason: String, Codable, CaseIterable {
                case abandoned
                case duplicate
                case requestedByCustomer = "requested_by_customer"
            }

            public init(cancellationReason: CancellationReason? = nil, expand: [String]? = nil) {
                self.cancellationReason = cancellationReason
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(cancellationReason, forKey: "cancellation_reason")
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.SetupIntents.WithIntent {
    public var confirm: Confirm {
        Confirm(path: path + "/confirm")
    }

    public struct Confirm {
        /// Path: `/v1/setup_intents/{intent}/confirm`
        public let path: String

        /// <p>Confirm that your customer intends to set up the current or
        /// provided payment method. For example, you would confirm a SetupIntent
        /// when a customer hits the “Save” button on a payment method management
        /// page on your website.</p>
        /// 
        /// <p>If the selected payment method does not require any additional
        /// steps from the customer, the SetupIntent will transition to the
        /// <code>succeeded</code> status.</p>
        /// 
        /// <p>Otherwise, it will transition to the <code>requires_action</code> status and
        /// suggest additional actions via <code>next_action</code>. If setup fails,
        /// the SetupIntent will transition to the
        /// <code>requires_payment_method</code> status.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.SetupIntent> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The client secret of the SetupIntent.
            public var clientSecret: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// This hash contains details about the Mandate to create
            public var mandateData: MandateData?
            /// ID of the payment method (a PaymentMethod, Card, or saved Source object) to attach to this SetupIntent.
            public var paymentMethod: String?
            /// Payment_method_options_param
            ///
            /// Payment-method-specific configuration for this SetupIntent.
            public var paymentMethodOptions: PaymentMethodOptions?
            /// The URL to redirect your customer back to after they authenticate on the payment method's app or site.
            /// If you'd prefer to redirect to a mobile application, you can alternatively supply an application URI scheme.
            /// This parameter is only used for cards and other redirect-based payment methods.
            public var returnURL: String?

            /// This hash contains details about the Mandate to create
            public struct MandateData: Encodable {
                /// Secret_key_param
                public var a: A?
                /// Client_key_param
                public var b: B?

                /// Secret_key_param
                public struct A: Encodable {
                    /// Customer_acceptance_param
                    public var customerAcceptance: CustomerAcceptance

                    /// Customer_acceptance_param
                    public struct CustomerAcceptance: Encodable {
                        public var acceptedAt: Int?
                        /// Offline_param
                        public var offline: [String: AnyJSON]?
                        /// Online_param
                        public var online: Online?
                        public var type: `Type`

                        /// Online_param
                        public struct Online: Encodable {
                            public var ipAddress: String
                            public var userAgent: String

                            public init(ipAddress: String, userAgent: String) {
                                self.ipAddress = ipAddress
                                self.userAgent = userAgent
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(ipAddress, forKey: "ip_address")
                                encoder.encode(userAgent, forKey: "user_agent")
                                return encoder.items
                            }
                        }

                        public enum `Type`: String, Codable, CaseIterable {
                            case offline
                            case online
                        }

                        public init(acceptedAt: Int? = nil, offline: [String: AnyJSON]? = nil, online: Online? = nil, type: `Type`) {
                            self.acceptedAt = acceptedAt
                            self.offline = offline
                            self.online = online
                            self.type = type
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(acceptedAt, forKey: "accepted_at")
                            encoder.encode(offline, forKey: "offline")
                            encoder.encode(online, forKey: "online")
                            encoder.encode(type, forKey: "type")
                            return encoder.items
                        }
                    }

                    public init(customerAcceptance: CustomerAcceptance) {
                        self.customerAcceptance = customerAcceptance
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(customerAcceptance, forKey: "customer_acceptance")
                        return encoder.items
                    }
                }

                /// Client_key_param
                public struct B: Encodable {
                    /// Customer_acceptance_param
                    public var customerAcceptance: CustomerAcceptance

                    /// Customer_acceptance_param
                    public struct CustomerAcceptance: Encodable {
                        /// Online_param
                        public var online: Online
                        public var type: `Type`

                        /// Online_param
                        public struct Online: Encodable {
                            public var ipAddress: String?
                            public var userAgent: String?

                            public init(ipAddress: String? = nil, userAgent: String? = nil) {
                                self.ipAddress = ipAddress
                                self.userAgent = userAgent
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(ipAddress, forKey: "ip_address")
                                encoder.encode(userAgent, forKey: "user_agent")
                                return encoder.items
                            }
                        }

                        public enum `Type`: String, Codable, CaseIterable {
                            case online
                        }

                        public init(online: Online, type: `Type`) {
                            self.online = online
                            self.type = type
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(online, forKey: "online")
                            encoder.encode(type, forKey: "type")
                            return encoder.items
                        }
                    }

                    public init(customerAcceptance: CustomerAcceptance) {
                        self.customerAcceptance = customerAcceptance
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(customerAcceptance, forKey: "customer_acceptance")
                        return encoder.items
                    }
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Payment_method_options_param
            ///
            /// Payment-method-specific configuration for this SetupIntent.
            public struct PaymentMethodOptions: Encodable {
                /// Setup_intent_payment_method_options_param
                public var acssDebit: AcssDebit?
                /// Setup_intent_param
                public var card: Card?
                /// Setup_intent_payment_method_options_param
                public var sepaDebit: SepaDebit?

                /// Setup_intent_payment_method_options_param
                public struct AcssDebit: Encodable {
                    public var currency: Currency?
                    /// Setup_intent_payment_method_options_mandate_options_param
                    public var mandateOptions: MandateOptions?
                    public var verificationMethod: VerificationMethod?

                    public enum Currency: String, Codable, CaseIterable {
                        case cad
                        case usd
                    }

                    /// Setup_intent_payment_method_options_mandate_options_param
                    public struct MandateOptions: Encodable {
                        public var customMandateURL: CustomMandateURL?
                        public var defaultFor: [DefaultForItem]?
                        public var intervalDescription: String?
                        public var paymentSchedule: PaymentSchedule?
                        public var transactionType: TransactionType?

                        public struct CustomMandateURL: Encodable {
                            public var string: String?
                            public var object: Object?

                            public enum Object: String, Codable, CaseIterable {
                                case empty = ""
                            }

                            public init(string: String? = nil, object: Object? = nil) {
                                self.string = string
                                self.object = object
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(string, forKey: "string")
                                encoder.encode(object, forKey: "object")
                                return encoder.items
                            }
                        }

                        public enum DefaultForItem: String, Codable, CaseIterable {
                            case invoice
                            case subscription
                        }

                        public enum PaymentSchedule: String, Codable, CaseIterable {
                            case combined
                            case interval
                            case sporadic
                        }

                        public enum TransactionType: String, Codable, CaseIterable {
                            case business
                            case personal
                        }

                        public init(customMandateURL: CustomMandateURL? = nil, defaultFor: [DefaultForItem]? = nil, intervalDescription: String? = nil, paymentSchedule: PaymentSchedule? = nil, transactionType: TransactionType? = nil) {
                            self.customMandateURL = customMandateURL
                            self.defaultFor = defaultFor
                            self.intervalDescription = intervalDescription
                            self.paymentSchedule = paymentSchedule
                            self.transactionType = transactionType
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(customMandateURL, forKey: "custom_mandate_url")
                            encoder.encode(defaultFor, forKey: "default_for")
                            encoder.encode(intervalDescription, forKey: "interval_description")
                            encoder.encode(paymentSchedule, forKey: "payment_schedule")
                            encoder.encode(transactionType, forKey: "transaction_type")
                            return encoder.items
                        }
                    }

                    public enum VerificationMethod: String, Codable, CaseIterable {
                        case automatic
                        case instant
                        case microdeposits
                    }

                    public init(currency: Currency? = nil, mandateOptions: MandateOptions? = nil, verificationMethod: VerificationMethod? = nil) {
                        self.currency = currency
                        self.mandateOptions = mandateOptions
                        self.verificationMethod = verificationMethod
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(mandateOptions, forKey: "mandate_options")
                        encoder.encode(verificationMethod, forKey: "verification_method")
                        return encoder.items
                    }
                }

                /// Setup_intent_param
                public struct Card: Encodable {
                    public var requestThreeDSecure: RequestThreeDSecure?

                    public enum RequestThreeDSecure: String, Codable, CaseIterable {
                        case any
                        case automatic
                    }

                    public init(requestThreeDSecure: RequestThreeDSecure? = nil) {
                        self.requestThreeDSecure = requestThreeDSecure
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(requestThreeDSecure, forKey: "request_three_d_secure")
                        return encoder.items
                    }
                }

                /// Setup_intent_payment_method_options_param
                public struct SepaDebit: Encodable {
                    /// Payment_method_options_mandate_options_param
                    public var mandateOptions: [String: AnyJSON]?

                    public init(mandateOptions: [String: AnyJSON]? = nil) {
                        self.mandateOptions = mandateOptions
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(mandateOptions, forKey: "mandate_options")
                        return encoder.items
                    }
                }

                public init(acssDebit: AcssDebit? = nil, card: Card? = nil, sepaDebit: SepaDebit? = nil) {
                    self.acssDebit = acssDebit
                    self.card = card
                    self.sepaDebit = sepaDebit
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(acssDebit, forKey: "acss_debit")
                    encoder.encode(card, forKey: "card")
                    encoder.encode(sepaDebit, forKey: "sepa_debit")
                    return encoder.items
                }
            }

            public init(clientSecret: String? = nil, expand: [String]? = nil, mandateData: MandateData? = nil, paymentMethod: String? = nil, paymentMethodOptions: PaymentMethodOptions? = nil, returnURL: String? = nil) {
                self.clientSecret = clientSecret
                self.expand = expand
                self.mandateData = mandateData
                self.paymentMethod = paymentMethod
                self.paymentMethodOptions = paymentMethodOptions
                self.returnURL = returnURL
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(clientSecret, forKey: "client_secret")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(mandateData, forKey: "mandate_data")
                encoder.encode(paymentMethod, forKey: "payment_method")
                encoder.encode(paymentMethodOptions, forKey: "payment_method_options")
                encoder.encode(returnURL, forKey: "return_url")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var shippingRates: ShippingRates {
        ShippingRates(path: "/v1/shipping_rates")
    }

    public struct ShippingRates {
        /// Path: `/v1/shipping_rates`
        public let path: String

        /// <p>Returns a list of your shipping rates.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// ShippingResourcesShippingRateList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.ShippingRate]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.ShippingRate], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var isActive: Bool?
            public var created: Created?
            public var currency: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(isActive: Bool? = nil, created: Created? = nil, currency: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.isActive = isActive
                self.created = created
                self.currency = currency
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(currency, forKey: "currency")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates a new shipping rate object.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.ShippingRate> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Delivery_estimate
            ///
            /// The estimated range for how long shipping will take, meant to be displayable to the customer. This will appear on CheckoutSessions.
            public var deliveryEstimate: DeliveryEstimate?
            /// The name of the shipping rate, meant to be displayable to the customer. This will appear on CheckoutSessions.
            public var displayName: String
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Fixed_amount
            ///
            /// Describes a fixed amount to charge for shipping. Must be present if type is `fixed_amount`.
            public var fixedAmount: FixedAmount?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// Specifies whether the rate is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`.
            public var taxBehavior: TaxBehavior?
            /// A [tax code](https://stripe.com/docs/tax/tax-codes) ID. The Shipping tax code is `txcd_92010001`.
            public var taxCode: String?
            /// The type of calculation to use on the shipping rate. Can only be `fixed_amount` for now.
            public var type: `Type`?

            /// Delivery_estimate
            ///
            /// The estimated range for how long shipping will take, meant to be displayable to the customer. This will appear on CheckoutSessions.
            public struct DeliveryEstimate: Encodable {
                /// Delivery_estimate_bound
                public var maximum: Maximum?
                /// Delivery_estimate_bound
                public var minimum: Minimum?

                /// Delivery_estimate_bound
                public struct Maximum: Encodable {
                    public var unit: Unit
                    public var value: Int

                    public enum Unit: String, Codable, CaseIterable {
                        case businessDay = "business_day"
                        case day
                        case hour
                        case month
                        case week
                    }

                    public init(unit: Unit, value: Int) {
                        self.unit = unit
                        self.value = value
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(unit, forKey: "unit")
                        encoder.encode(value, forKey: "value")
                        return encoder.items
                    }
                }

                /// Delivery_estimate_bound
                public struct Minimum: Encodable {
                    public var unit: Unit
                    public var value: Int

                    public enum Unit: String, Codable, CaseIterable {
                        case businessDay = "business_day"
                        case day
                        case hour
                        case month
                        case week
                    }

                    public init(unit: Unit, value: Int) {
                        self.unit = unit
                        self.value = value
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(unit, forKey: "unit")
                        encoder.encode(value, forKey: "value")
                        return encoder.items
                    }
                }

                public init(maximum: Maximum? = nil, minimum: Minimum? = nil) {
                    self.maximum = maximum
                    self.minimum = minimum
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(maximum, forKey: "maximum")
                    encoder.encode(minimum, forKey: "minimum")
                    return encoder.items
                }
            }

            /// Fixed_amount
            ///
            /// Describes a fixed amount to charge for shipping. Must be present if type is `fixed_amount`.
            public struct FixedAmount: Encodable {
                public var amount: Int
                public var currency: String

                public init(amount: Int, currency: String) {
                    self.amount = amount
                    self.currency = currency
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(amount, forKey: "amount")
                    encoder.encode(currency, forKey: "currency")
                    return encoder.items
                }
            }

            /// Specifies whether the rate is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`.
            public enum TaxBehavior: String, Codable, CaseIterable {
                case exclusive
                case inclusive
                case unspecified
            }

            /// The type of calculation to use on the shipping rate. Can only be `fixed_amount` for now.
            public enum `Type`: String, Codable, CaseIterable {
                case fixedAmount = "fixed_amount"
            }

            public init(deliveryEstimate: DeliveryEstimate? = nil, displayName: String, expand: [String]? = nil, fixedAmount: FixedAmount? = nil, metadata: [String: String]? = nil, taxBehavior: TaxBehavior? = nil, taxCode: String? = nil, type: `Type`? = nil) {
                self.deliveryEstimate = deliveryEstimate
                self.displayName = displayName
                self.expand = expand
                self.fixedAmount = fixedAmount
                self.metadata = metadata
                self.taxBehavior = taxBehavior
                self.taxCode = taxCode
                self.type = type
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(deliveryEstimate, forKey: "delivery_estimate")
                encoder.encode(displayName, forKey: "display_name")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(fixedAmount, forKey: "fixed_amount")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(taxBehavior, forKey: "tax_behavior")
                encoder.encode(taxCode, forKey: "tax_code")
                encoder.encode(type, forKey: "type")
                return encoder.items
            }
        }
    }
}

extension Paths.ShippingRates {
    public func shippingRateToken(_ shippingRateToken: String) -> WithShippingRateToken {
        WithShippingRateToken(path: "\(path)/\(shippingRateToken)")
    }

    public struct WithShippingRateToken {
        /// Path: `/v1/shipping_rates/{shipping_rate_token}`
        public let path: String

        /// <p>Returns the shipping rate object with the given ID.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.ShippingRate> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates an existing shipping rate object.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.ShippingRate> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Whether the shipping rate can be used for new purchases. Defaults to `true`.
            public var isActive: Bool?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(isActive: Bool? = nil, expand: [String]? = nil, metadata: Metadata? = nil) {
                self.isActive = isActive
                self.expand = expand
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var sigma: Sigma {
        Sigma(path: "/v1/sigma")
    }

    public struct Sigma {
        /// Path: `/v1/sigma`
        public let path: String
    }
}

extension Paths.Sigma {
    public var scheduledQueryRuns: ScheduledQueryRuns {
        ScheduledQueryRuns(path: path + "/scheduled_query_runs")
    }

    public struct ScheduledQueryRuns {
        /// Path: `/v1/sigma/scheduled_query_runs`
        public let path: String

        /// <p>Returns a list of scheduled query runs.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.ScheduledQueryRun]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.ScheduledQueryRun], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }
    }
}

extension Paths.Sigma.ScheduledQueryRuns {
    public func scheduledQueryRun(_ scheduledQueryRun: String) -> WithScheduledQueryRun {
        WithScheduledQueryRun(path: "\(path)/\(scheduledQueryRun)")
    }

    public struct WithScheduledQueryRun {
        /// Path: `/v1/sigma/scheduled_query_runs/{scheduled_query_run}`
        public let path: String

        /// <p>Retrieves the details of an scheduled query run.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.ScheduledQueryRun> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths {
    public static var skus: Skus {
        Skus(path: "/v1/skus")
    }

    public struct Skus {
        /// Path: `/v1/skus`
        public let path: String

        /// <p>Returns a list of your SKUs. The SKUs are returned sorted by creation date, with the most recently created SKUs appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Sku]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Sku], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var isActive: Bool?
            public var attributes: Attributes?
            public var endingBefore: String?
            public var expand: [String]?
            public var ids: [String]?
            public var isInStock: Bool?
            public var limit: Int?
            public var product: String?
            public var startingAfter: String?

            public typealias Attributes = [String: String]

            public init(isActive: Bool? = nil, attributes: Attributes? = nil, endingBefore: String? = nil, expand: [String]? = nil, ids: [String]? = nil, isInStock: Bool? = nil, limit: Int? = nil, product: String? = nil, startingAfter: String? = nil) {
                self.isActive = isActive
                self.attributes = attributes
                self.endingBefore = endingBefore
                self.expand = expand
                self.ids = ids
                self.isInStock = isInStock
                self.limit = limit
                self.product = product
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(attributes, forKey: "attributes", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(ids, forKey: "ids", isDeepObject: true)
                encoder.encode(isInStock, forKey: "in_stock")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(product, forKey: "product")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates a new SKU associated with a product.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.Sku> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Whether the SKU is available for purchase. Default to `true`.
            public var isActive: Bool?
            /// A dictionary of attributes and values for the attributes defined by the product. If, for example, a product's attributes are `["size", "gender"]`, a valid SKU has the following dictionary of attributes: `{"size": "Medium", "gender": "Unisex"}`.
            public var attributes: [String: String]?
            /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
            public var currency: String
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The identifier for the SKU. Must be unique. If not provided, an identifier will be randomly generated.
            public var id: String?
            /// The URL of an image for this SKU, meant to be displayable to the customer.
            public var image: String?
            /// Inventory_create_specs
            ///
            /// Description of the SKU's inventory.
            public var inventory: Inventory
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// Package_dimensions_specs
            ///
            /// The dimensions of this SKU for shipping purposes.
            public var packageDimensions: PackageDimensions?
            /// The cost of the item as a nonnegative integer in the smallest currency unit (that is, 100 cents to charge $1.00, or 100 to charge ¥100, Japanese Yen being a zero-decimal currency).
            public var price: Int
            /// The ID of the product this SKU is associated with. Must be a product with type `good`.
            public var product: String

            /// Inventory_create_specs
            ///
            /// Description of the SKU's inventory.
            public struct Inventory: Encodable {
                public var quantity: Int?
                public var type: `Type`
                public var value: Value?

                public enum `Type`: String, Codable, CaseIterable {
                    case bucket
                    case finite
                    case infinite
                }

                public enum Value: String, Codable, CaseIterable {
                    case empty = ""
                    case inStock = "in_stock"
                    case limited
                    case outOfStock = "out_of_stock"
                }

                public init(quantity: Int? = nil, type: `Type`, value: Value? = nil) {
                    self.quantity = quantity
                    self.type = type
                    self.value = value
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(type, forKey: "type")
                    encoder.encode(value, forKey: "value")
                    return encoder.items
                }
            }

            /// Package_dimensions_specs
            ///
            /// The dimensions of this SKU for shipping purposes.
            public struct PackageDimensions: Encodable {
                public var height: Double
                public var length: Double
                public var weight: Double
                public var width: Double

                public init(height: Double, length: Double, weight: Double, width: Double) {
                    self.height = height
                    self.length = length
                    self.weight = weight
                    self.width = width
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(height, forKey: "height")
                    encoder.encode(length, forKey: "length")
                    encoder.encode(weight, forKey: "weight")
                    encoder.encode(width, forKey: "width")
                    return encoder.items
                }
            }

            public init(isActive: Bool? = nil, attributes: [String: String]? = nil, currency: String, expand: [String]? = nil, id: String? = nil, image: String? = nil, inventory: Inventory, metadata: [String: String]? = nil, packageDimensions: PackageDimensions? = nil, price: Int, product: String) {
                self.isActive = isActive
                self.attributes = attributes
                self.currency = currency
                self.expand = expand
                self.id = id
                self.image = image
                self.inventory = inventory
                self.metadata = metadata
                self.packageDimensions = packageDimensions
                self.price = price
                self.product = product
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(attributes, forKey: "attributes")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(id, forKey: "id")
                encoder.encode(image, forKey: "image")
                encoder.encode(inventory, forKey: "inventory")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(packageDimensions, forKey: "package_dimensions")
                encoder.encode(price, forKey: "price")
                encoder.encode(product, forKey: "product")
                return encoder.items
            }
        }
    }
}

extension Paths.Skus {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/skus/{id}`
        public let path: String

        /// <p>Retrieves the details of an existing SKU. Supply the unique SKU identifier from either a SKU creation request or from the product, and Stripe will return the corresponding SKU information.</p>
        public func get(expand: [String]? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            /// Stores representations of [stock keeping units](http://en.wikipedia.org/wiki/Stock_keeping_unit).
            /// SKUs describe specific product variations, taking into account any combination of: attributes,
            /// currency, and cost. For example, a product may be a T-shirt, whereas a specific SKU represents
            /// the `size: large`, `color: red` version of that shirt.
            /// 
            /// Can also be used to manage inventory.
            /// 
            /// Related guide: [Tax, Shipping, and Inventory](https://stripe.com/docs/orders).
            public var sku: StripeAPI.Sku?
            public var deletedSku: StripeAPI.DeletedSku?

            public init(sku: StripeAPI.Sku? = nil, deletedSku: StripeAPI.DeletedSku? = nil) {
                self.sku = sku
                self.deletedSku = deletedSku
            }

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                self.sku = try? container.decode(StripeAPI.Sku.self)
                self.deletedSku = try? container.decode(StripeAPI.DeletedSku.self)
            }
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the specific SKU by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
        /// 
        /// <p>Note that a SKU’s <code>attributes</code> are not editable. Instead, you would need to deactivate the existing SKU and create a new one with the new attribute values.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Sku> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Whether this SKU is available for purchase.
            public var isActive: Bool?
            /// A dictionary of attributes and values for the attributes defined by the product. When specified, `attributes` will partially update the existing attributes dictionary on the product, with the postcondition that a value must be present for each attribute key on the product.
            public var attributes: [String: String]?
            /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
            public var currency: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The URL of an image for this SKU, meant to be displayable to the customer.
            public var image: String?
            /// Inventory_update_specs
            ///
            /// Description of the SKU's inventory.
            public var inventory: Inventory?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The dimensions of this SKU for shipping purposes.
            public var packageDimensions: PackageDimensions?
            /// The cost of the item as a positive integer in the smallest currency unit (that is, 100 cents to charge $1.00, or 100 to charge ¥100, Japanese Yen being a zero-decimal currency).
            public var price: Int?
            /// The ID of the product that this SKU should belong to. The product must exist, have the same set of attribute names as the SKU's current product, and be of type `good`.
            public var product: String?

            /// Inventory_update_specs
            ///
            /// Description of the SKU's inventory.
            public struct Inventory: Encodable {
                public var quantity: Int?
                public var type: `Type`?
                public var value: Value?

                public enum `Type`: String, Codable, CaseIterable {
                    case bucket
                    case finite
                    case infinite
                }

                public enum Value: String, Codable, CaseIterable {
                    case empty = ""
                    case inStock = "in_stock"
                    case limited
                    case outOfStock = "out_of_stock"
                }

                public init(quantity: Int? = nil, type: `Type`? = nil, value: Value? = nil) {
                    self.quantity = quantity
                    self.type = type
                    self.value = value
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(type, forKey: "type")
                    encoder.encode(value, forKey: "value")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// The dimensions of this SKU for shipping purposes.
            public struct PackageDimensions: Encodable {
                /// Package_dimensions_specs
                public var a: A?
                public var b: B?

                /// Package_dimensions_specs
                public struct A: Encodable {
                    public var height: Double
                    public var length: Double
                    public var weight: Double
                    public var width: Double

                    public init(height: Double, length: Double, weight: Double, width: Double) {
                        self.height = height
                        self.length = length
                        self.weight = weight
                        self.width = width
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(height, forKey: "height")
                        encoder.encode(length, forKey: "length")
                        encoder.encode(weight, forKey: "weight")
                        encoder.encode(width, forKey: "width")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            public init(isActive: Bool? = nil, attributes: [String: String]? = nil, currency: String? = nil, expand: [String]? = nil, image: String? = nil, inventory: Inventory? = nil, metadata: Metadata? = nil, packageDimensions: PackageDimensions? = nil, price: Int? = nil, product: String? = nil) {
                self.isActive = isActive
                self.attributes = attributes
                self.currency = currency
                self.expand = expand
                self.image = image
                self.inventory = inventory
                self.metadata = metadata
                self.packageDimensions = packageDimensions
                self.price = price
                self.product = product
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(attributes, forKey: "attributes")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(image, forKey: "image")
                encoder.encode(inventory, forKey: "inventory")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(packageDimensions, forKey: "package_dimensions")
                encoder.encode(price, forKey: "price")
                encoder.encode(product, forKey: "product")
                return encoder.items
            }
        }

        /// <p>Delete a SKU. Deleting a SKU is only possible until it has been used in an order.</p>
        public var delete: Request<StripeAPI.DeletedSku> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var sources: Sources {
        Sources(path: "/v1/sources")
    }

    public struct Sources {
        /// Path: `/v1/sources`
        public let path: String

        /// <p>Creates a new source object.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Source> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Amount associated with the source. This is the amount for which the source will be chargeable once ready. Required for `single_use` sources. Not supported for `receiver` type sources, where charge amount may not be specified until funds land.
            public var amount: Int?
            /// Three-letter [ISO code for the currency](https://stripe.com/docs/currencies) associated with the source. This is the currency for which the source will be chargeable once ready.
            public var currency: String?
            /// The `Customer` to whom the original source is attached to. Must be set when the original source is not a `Source` (e.g., `Card`).
            public var customer: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The authentication `flow` of the source to create. `flow` is one of `redirect`, `receiver`, `code_verification`, `none`. It is generally inferred unless a type supports multiple flows.
            public var flow: Flow?
            /// Mandate_params
            ///
            /// Information about a mandate possibility attached to a source object (generally for bank debits) as well as its acceptance status.
            public var mandate: Mandate?
            public var metadata: [String: String]?
            /// The source to share.
            public var originalSource: String?
            /// Information about the owner of the payment instrument that may be used or required by particular source types.
            public var owner: Owner?
            /// Receiver_params
            ///
            /// Optional parameters for the receiver flow. Can be set only if the source is a receiver (`flow` is `receiver`).
            public var receiver: Receiver?
            /// Redirect_params
            ///
            /// Parameters required for the redirect flow. Required if the source is authenticated by a redirect (`flow` is `redirect`).
            public var redirect: Redirect?
            /// Shallow_order_specs
            ///
            /// Information about the items and shipping associated with the source. Required for transactional credit (for example Klarna) sources before you can charge it.
            public var sourceOrder: SourceOrder?
            /// An arbitrary string to be displayed on your customer's statement. As an example, if your website is `RunClub` and the item you're charging for is a race ticket, you may want to specify a `statement_descriptor` of `RunClub 5K race ticket.` While many payment types will display this information, some may not display it at all.
            public var statementDescriptor: String?
            /// An optional token used to create the source. When passed, token properties will override source parameters.
            public var token: String?
            /// The `type` of the source to create. Required unless `customer` and `original_source` are specified (see the [Cloning card Sources](https://stripe.com/docs/sources/connect#cloning-card-sources) guide)
            public var type: String?
            public var usage: Usage?

            /// The authentication `flow` of the source to create. `flow` is one of `redirect`, `receiver`, `code_verification`, `none`. It is generally inferred unless a type supports multiple flows.
            public enum Flow: String, Codable, CaseIterable {
                case codeVerification = "code_verification"
                case `none`
                case receiver
                case redirect
            }

            /// Mandate_params
            ///
            /// Information about a mandate possibility attached to a source object (generally for bank debits) as well as its acceptance status.
            public struct Mandate: Encodable {
                /// Mandate_acceptance_params
                public var acceptance: Acceptance?
                public var amount: Amount?
                public var currency: String?
                public var interval: Interval?
                public var notificationMethod: NotificationMethod?

                /// Mandate_acceptance_params
                public struct Acceptance: Encodable {
                    public var date: Int?
                    public var ip: String?
                    /// Mandate_offline_acceptance_params
                    public var offline: Offline?
                    /// Mandate_online_acceptance_params
                    public var online: Online?
                    public var status: Status
                    public var type: `Type`?
                    public var userAgent: String?

                    /// Mandate_offline_acceptance_params
                    public struct Offline: Encodable {
                        public var contactEmail: String

                        public init(contactEmail: String) {
                            self.contactEmail = contactEmail
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(contactEmail, forKey: "contact_email")
                            return encoder.items
                        }
                    }

                    /// Mandate_online_acceptance_params
                    public struct Online: Encodable {
                        public var date: Int?
                        public var ip: String?
                        public var userAgent: String?

                        public init(date: Int? = nil, ip: String? = nil, userAgent: String? = nil) {
                            self.date = date
                            self.ip = ip
                            self.userAgent = userAgent
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(date, forKey: "date")
                            encoder.encode(ip, forKey: "ip")
                            encoder.encode(userAgent, forKey: "user_agent")
                            return encoder.items
                        }
                    }

                    public enum Status: String, Codable, CaseIterable {
                        case accepted
                        case pending
                        case refused
                        case revoked
                    }

                    public enum `Type`: String, Codable, CaseIterable {
                        case offline
                        case online
                    }

                    public init(date: Int? = nil, ip: String? = nil, offline: Offline? = nil, online: Online? = nil, status: Status, type: `Type`? = nil, userAgent: String? = nil) {
                        self.date = date
                        self.ip = ip
                        self.offline = offline
                        self.online = online
                        self.status = status
                        self.type = type
                        self.userAgent = userAgent
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(date, forKey: "date")
                        encoder.encode(ip, forKey: "ip")
                        encoder.encode(offline, forKey: "offline")
                        encoder.encode(online, forKey: "online")
                        encoder.encode(status, forKey: "status")
                        encoder.encode(type, forKey: "type")
                        encoder.encode(userAgent, forKey: "user_agent")
                        return encoder.items
                    }
                }

                public struct Amount: Encodable {
                    public var int: Int?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(int: Int? = nil, object: Object? = nil) {
                        self.int = int
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(int, forKey: "int")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public enum Interval: String, Codable, CaseIterable {
                    case oneTime = "one_time"
                    case scheduled
                    case variable
                }

                public enum NotificationMethod: String, Codable, CaseIterable {
                    case deprecatedNone = "deprecated_none"
                    case email
                    case manual
                    case `none`
                    case stripeEmail = "stripe_email"
                }

                public init(acceptance: Acceptance? = nil, amount: Amount? = nil, currency: String? = nil, interval: Interval? = nil, notificationMethod: NotificationMethod? = nil) {
                    self.acceptance = acceptance
                    self.amount = amount
                    self.currency = currency
                    self.interval = interval
                    self.notificationMethod = notificationMethod
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(acceptance, forKey: "acceptance")
                    encoder.encode(amount, forKey: "amount")
                    encoder.encode(currency, forKey: "currency")
                    encoder.encode(interval, forKey: "interval")
                    encoder.encode(notificationMethod, forKey: "notification_method")
                    return encoder.items
                }
            }

            /// Information about the owner of the payment instrument that may be used or required by particular source types.
            public struct Owner: Encodable {
                /// Source_address
                public var address: Address?
                public var email: String?
                public var name: String?
                public var phone: String?

                /// Source_address
                public struct Address: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                public init(address: Address? = nil, email: String? = nil, name: String? = nil, phone: String? = nil) {
                    self.address = address
                    self.email = email
                    self.name = name
                    self.phone = phone
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(email, forKey: "email")
                    encoder.encode(name, forKey: "name")
                    encoder.encode(phone, forKey: "phone")
                    return encoder.items
                }
            }

            /// Receiver_params
            ///
            /// Optional parameters for the receiver flow. Can be set only if the source is a receiver (`flow` is `receiver`).
            public struct Receiver: Encodable {
                public var refundAttributesMethod: RefundAttributesMethod?

                public enum RefundAttributesMethod: String, Codable, CaseIterable {
                    case email
                    case manual
                    case `none`
                }

                public init(refundAttributesMethod: RefundAttributesMethod? = nil) {
                    self.refundAttributesMethod = refundAttributesMethod
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(refundAttributesMethod, forKey: "refund_attributes_method")
                    return encoder.items
                }
            }

            /// Redirect_params
            ///
            /// Parameters required for the redirect flow. Required if the source is authenticated by a redirect (`flow` is `redirect`).
            public struct Redirect: Encodable {
                public var returnURL: String

                public init(returnURL: String) {
                    self.returnURL = returnURL
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(returnURL, forKey: "return_url")
                    return encoder.items
                }
            }

            /// Shallow_order_specs
            ///
            /// Information about the items and shipping associated with the source. Required for transactional credit (for example Klarna) sources before you can charge it.
            public struct SourceOrder: Encodable {
                public var items: [Item]?
                /// Order_shipping
                public var shipping: Shipping?

                /// Order_item_specs
                public struct Item: Encodable {
                    public var amount: Int?
                    public var currency: String?
                    public var description: String?
                    public var parent: String?
                    public var quantity: Int?
                    public var type: `Type`?

                    public enum `Type`: String, Codable, CaseIterable {
                        case discount
                        case shipping
                        case sku
                        case tax
                    }

                    public init(amount: Int? = nil, currency: String? = nil, description: String? = nil, parent: String? = nil, quantity: Int? = nil, type: `Type`? = nil) {
                        self.amount = amount
                        self.currency = currency
                        self.description = description
                        self.parent = parent
                        self.quantity = quantity
                        self.type = type
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amount, forKey: "amount")
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(description, forKey: "description")
                        encoder.encode(parent, forKey: "parent")
                        encoder.encode(quantity, forKey: "quantity")
                        encoder.encode(type, forKey: "type")
                        return encoder.items
                    }
                }

                /// Order_shipping
                public struct Shipping: Encodable {
                    public var address: Address
                    public var carrier: String?
                    public var name: String?
                    public var phone: String?
                    public var trackingNumber: String?

                    public struct Address: Encodable {
                        public var city: String?
                        public var country: String?
                        public var line1: String
                        public var line2: String?
                        public var postalCode: String?
                        public var state: String?

                        public init(city: String? = nil, country: String? = nil, line1: String, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                            self.city = city
                            self.country = country
                            self.line1 = line1
                            self.line2 = line2
                            self.postalCode = postalCode
                            self.state = state
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(city, forKey: "city")
                            encoder.encode(country, forKey: "country")
                            encoder.encode(line1, forKey: "line1")
                            encoder.encode(line2, forKey: "line2")
                            encoder.encode(postalCode, forKey: "postal_code")
                            encoder.encode(state, forKey: "state")
                            return encoder.items
                        }
                    }

                    public init(address: Address, carrier: String? = nil, name: String? = nil, phone: String? = nil, trackingNumber: String? = nil) {
                        self.address = address
                        self.carrier = carrier
                        self.name = name
                        self.phone = phone
                        self.trackingNumber = trackingNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(address, forKey: "address")
                        encoder.encode(carrier, forKey: "carrier")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(phone, forKey: "phone")
                        encoder.encode(trackingNumber, forKey: "tracking_number")
                        return encoder.items
                    }
                }

                public init(items: [Item]? = nil, shipping: Shipping? = nil) {
                    self.items = items
                    self.shipping = shipping
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(items, forKey: "items")
                    encoder.encode(shipping, forKey: "shipping")
                    return encoder.items
                }
            }

            public enum Usage: String, Codable, CaseIterable {
                case reusable
                case singleUse = "single_use"
            }

            public init(amount: Int? = nil, currency: String? = nil, customer: String? = nil, expand: [String]? = nil, flow: Flow? = nil, mandate: Mandate? = nil, metadata: [String: String]? = nil, originalSource: String? = nil, owner: Owner? = nil, receiver: Receiver? = nil, redirect: Redirect? = nil, sourceOrder: SourceOrder? = nil, statementDescriptor: String? = nil, token: String? = nil, type: String? = nil, usage: Usage? = nil) {
                self.amount = amount
                self.currency = currency
                self.customer = customer
                self.expand = expand
                self.flow = flow
                self.mandate = mandate
                self.metadata = metadata
                self.originalSource = originalSource
                self.owner = owner
                self.receiver = receiver
                self.redirect = redirect
                self.sourceOrder = sourceOrder
                self.statementDescriptor = statementDescriptor
                self.token = token
                self.type = type
                self.usage = usage
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(flow, forKey: "flow")
                encoder.encode(mandate, forKey: "mandate")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(originalSource, forKey: "original_source")
                encoder.encode(owner, forKey: "owner")
                encoder.encode(receiver, forKey: "receiver")
                encoder.encode(redirect, forKey: "redirect")
                encoder.encode(sourceOrder, forKey: "source_order")
                encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                encoder.encode(token, forKey: "token")
                encoder.encode(type, forKey: "type")
                encoder.encode(usage, forKey: "usage")
                return encoder.items
            }
        }
    }
}

extension Paths.Sources {
    public func source(_ source: String) -> WithSource {
        WithSource(path: "\(path)/\(source)")
    }

    public struct WithSource {
        /// Path: `/v1/sources/{source}`
        public let path: String

        /// <p>Retrieves an existing source object. Supply the unique source ID from a source creation request and Stripe will return the corresponding up-to-date source object information.</p>
        public func get(clientSecret: String? = nil, expand: [String]? = nil) -> Request<StripeAPI.Source> {
            .get(path, query: makeGetQuery(clientSecret, expand))
        }

        private func makeGetQuery(_ clientSecret: String?, _ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(clientSecret, forKey: "client_secret")
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the specified source by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
        /// 
        /// <p>This request accepts the <code>metadata</code> and <code>owner</code> as arguments. It is also possible to update type specific information for selected payment methods. Please refer to our <a href="/docs/sources">payment method guides</a> for more detail.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Source> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Amount associated with the source.
            public var amount: Int?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Mandate_params
            ///
            /// Information about a mandate possibility attached to a source object (generally for bank debits) as well as its acceptance status.
            public var mandate: Mandate?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// Information about the owner of the payment instrument that may be used or required by particular source types.
            public var owner: Owner?
            /// Order_params
            ///
            /// Information about the items and shipping associated with the source. Required for transactional credit (for example Klarna) sources before you can charge it.
            public var sourceOrder: SourceOrder?

            /// Mandate_params
            ///
            /// Information about a mandate possibility attached to a source object (generally for bank debits) as well as its acceptance status.
            public struct Mandate: Encodable {
                /// Mandate_acceptance_params
                public var acceptance: Acceptance?
                public var amount: Amount?
                public var currency: String?
                public var interval: Interval?
                public var notificationMethod: NotificationMethod?

                /// Mandate_acceptance_params
                public struct Acceptance: Encodable {
                    public var date: Int?
                    public var ip: String?
                    /// Mandate_offline_acceptance_params
                    public var offline: Offline?
                    /// Mandate_online_acceptance_params
                    public var online: Online?
                    public var status: Status
                    public var type: `Type`?
                    public var userAgent: String?

                    /// Mandate_offline_acceptance_params
                    public struct Offline: Encodable {
                        public var contactEmail: String

                        public init(contactEmail: String) {
                            self.contactEmail = contactEmail
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(contactEmail, forKey: "contact_email")
                            return encoder.items
                        }
                    }

                    /// Mandate_online_acceptance_params
                    public struct Online: Encodable {
                        public var date: Int?
                        public var ip: String?
                        public var userAgent: String?

                        public init(date: Int? = nil, ip: String? = nil, userAgent: String? = nil) {
                            self.date = date
                            self.ip = ip
                            self.userAgent = userAgent
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(date, forKey: "date")
                            encoder.encode(ip, forKey: "ip")
                            encoder.encode(userAgent, forKey: "user_agent")
                            return encoder.items
                        }
                    }

                    public enum Status: String, Codable, CaseIterable {
                        case accepted
                        case pending
                        case refused
                        case revoked
                    }

                    public enum `Type`: String, Codable, CaseIterable {
                        case offline
                        case online
                    }

                    public init(date: Int? = nil, ip: String? = nil, offline: Offline? = nil, online: Online? = nil, status: Status, type: `Type`? = nil, userAgent: String? = nil) {
                        self.date = date
                        self.ip = ip
                        self.offline = offline
                        self.online = online
                        self.status = status
                        self.type = type
                        self.userAgent = userAgent
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(date, forKey: "date")
                        encoder.encode(ip, forKey: "ip")
                        encoder.encode(offline, forKey: "offline")
                        encoder.encode(online, forKey: "online")
                        encoder.encode(status, forKey: "status")
                        encoder.encode(type, forKey: "type")
                        encoder.encode(userAgent, forKey: "user_agent")
                        return encoder.items
                    }
                }

                public struct Amount: Encodable {
                    public var int: Int?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(int: Int? = nil, object: Object? = nil) {
                        self.int = int
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(int, forKey: "int")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public enum Interval: String, Codable, CaseIterable {
                    case oneTime = "one_time"
                    case scheduled
                    case variable
                }

                public enum NotificationMethod: String, Codable, CaseIterable {
                    case deprecatedNone = "deprecated_none"
                    case email
                    case manual
                    case `none`
                    case stripeEmail = "stripe_email"
                }

                public init(acceptance: Acceptance? = nil, amount: Amount? = nil, currency: String? = nil, interval: Interval? = nil, notificationMethod: NotificationMethod? = nil) {
                    self.acceptance = acceptance
                    self.amount = amount
                    self.currency = currency
                    self.interval = interval
                    self.notificationMethod = notificationMethod
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(acceptance, forKey: "acceptance")
                    encoder.encode(amount, forKey: "amount")
                    encoder.encode(currency, forKey: "currency")
                    encoder.encode(interval, forKey: "interval")
                    encoder.encode(notificationMethod, forKey: "notification_method")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Information about the owner of the payment instrument that may be used or required by particular source types.
            public struct Owner: Encodable {
                /// Source_address
                public var address: Address?
                public var email: String?
                public var name: String?
                public var phone: String?

                /// Source_address
                public struct Address: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                public init(address: Address? = nil, email: String? = nil, name: String? = nil, phone: String? = nil) {
                    self.address = address
                    self.email = email
                    self.name = name
                    self.phone = phone
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(email, forKey: "email")
                    encoder.encode(name, forKey: "name")
                    encoder.encode(phone, forKey: "phone")
                    return encoder.items
                }
            }

            /// Order_params
            ///
            /// Information about the items and shipping associated with the source. Required for transactional credit (for example Klarna) sources before you can charge it.
            public struct SourceOrder: Encodable {
                public var items: [Item]?
                /// Order_shipping
                public var shipping: Shipping?

                /// Order_item_specs
                public struct Item: Encodable {
                    public var amount: Int?
                    public var currency: String?
                    public var description: String?
                    public var parent: String?
                    public var quantity: Int?
                    public var type: `Type`?

                    public enum `Type`: String, Codable, CaseIterable {
                        case discount
                        case shipping
                        case sku
                        case tax
                    }

                    public init(amount: Int? = nil, currency: String? = nil, description: String? = nil, parent: String? = nil, quantity: Int? = nil, type: `Type`? = nil) {
                        self.amount = amount
                        self.currency = currency
                        self.description = description
                        self.parent = parent
                        self.quantity = quantity
                        self.type = type
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amount, forKey: "amount")
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(description, forKey: "description")
                        encoder.encode(parent, forKey: "parent")
                        encoder.encode(quantity, forKey: "quantity")
                        encoder.encode(type, forKey: "type")
                        return encoder.items
                    }
                }

                /// Order_shipping
                public struct Shipping: Encodable {
                    public var address: Address
                    public var carrier: String?
                    public var name: String?
                    public var phone: String?
                    public var trackingNumber: String?

                    public struct Address: Encodable {
                        public var city: String?
                        public var country: String?
                        public var line1: String
                        public var line2: String?
                        public var postalCode: String?
                        public var state: String?

                        public init(city: String? = nil, country: String? = nil, line1: String, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                            self.city = city
                            self.country = country
                            self.line1 = line1
                            self.line2 = line2
                            self.postalCode = postalCode
                            self.state = state
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(city, forKey: "city")
                            encoder.encode(country, forKey: "country")
                            encoder.encode(line1, forKey: "line1")
                            encoder.encode(line2, forKey: "line2")
                            encoder.encode(postalCode, forKey: "postal_code")
                            encoder.encode(state, forKey: "state")
                            return encoder.items
                        }
                    }

                    public init(address: Address, carrier: String? = nil, name: String? = nil, phone: String? = nil, trackingNumber: String? = nil) {
                        self.address = address
                        self.carrier = carrier
                        self.name = name
                        self.phone = phone
                        self.trackingNumber = trackingNumber
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(address, forKey: "address")
                        encoder.encode(carrier, forKey: "carrier")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(phone, forKey: "phone")
                        encoder.encode(trackingNumber, forKey: "tracking_number")
                        return encoder.items
                    }
                }

                public init(items: [Item]? = nil, shipping: Shipping? = nil) {
                    self.items = items
                    self.shipping = shipping
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(items, forKey: "items")
                    encoder.encode(shipping, forKey: "shipping")
                    return encoder.items
                }
            }

            public init(amount: Int? = nil, expand: [String]? = nil, mandate: Mandate? = nil, metadata: Metadata? = nil, owner: Owner? = nil, sourceOrder: SourceOrder? = nil) {
                self.amount = amount
                self.expand = expand
                self.mandate = mandate
                self.metadata = metadata
                self.owner = owner
                self.sourceOrder = sourceOrder
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(mandate, forKey: "mandate")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(owner, forKey: "owner")
                encoder.encode(sourceOrder, forKey: "source_order")
                return encoder.items
            }
        }
    }
}

extension Paths.Sources.WithSource {
    public var mandateNotifications: MandateNotifications {
        MandateNotifications(path: path + "/mandate_notifications")
    }

    public struct MandateNotifications {
        /// Path: `/v1/sources/{source}/mandate_notifications`
        public let path: String
    }
}

extension Paths.Sources.WithSource.MandateNotifications {
    public func mandateNotification(_ mandateNotification: String) -> WithMandateNotification {
        WithMandateNotification(path: "\(path)/\(mandateNotification)")
    }

    public struct WithMandateNotification {
        /// Path: `/v1/sources/{source}/mandate_notifications/{mandate_notification}`
        public let path: String

        /// <p>Retrieves a new Source MandateNotification.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.SourceMandateNotification> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths.Sources.WithSource {
    public var sourceTransactions: SourceTransactions {
        SourceTransactions(path: path + "/source_transactions")
    }

    public struct SourceTransactions {
        /// Path: `/v1/sources/{source}/source_transactions`
        public let path: String

        /// <p>List source transactions for a given source.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// ApmsSourcesSourceTransactionList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.SourceTransaction]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.SourceTransaction], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }
    }
}

extension Paths.Sources.WithSource.SourceTransactions {
    public func sourceTransaction(_ sourceTransaction: String) -> WithSourceTransaction {
        WithSourceTransaction(path: "\(path)/\(sourceTransaction)")
    }

    public struct WithSourceTransaction {
        /// Path: `/v1/sources/{source}/source_transactions/{source_transaction}`
        public let path: String

        /// <p>Retrieve an existing source transaction object. Supply the unique source ID from a source creation request and the source transaction ID and Stripe will return the corresponding up-to-date source object information.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.SourceTransaction> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths.Sources.WithSource {
    public var verify: Verify {
        Verify(path: path + "/verify")
    }

    public struct Verify {
        /// Path: `/v1/sources/{source}/verify`
        public let path: String

        /// <p>Verify a given source.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.Source> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The values needed to verify the source.
            public var values: [String]

            public init(expand: [String]? = nil, values: [String]) {
                self.expand = expand
                self.values = values
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(values, forKey: "values")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var subscriptionItems: SubscriptionItems {
        SubscriptionItems(path: "/v1/subscription_items")
    }

    public struct SubscriptionItems {
        /// Path: `/v1/subscription_items`
        public let path: String

        /// <p>Returns a list of your subscription items for a given subscription.</p>
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.SubscriptionItem]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.SubscriptionItem], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?
            public var subscription: String

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil, subscription: String) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
                self.subscription = subscription
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(subscription, forKey: "subscription")
                return encoder.items
            }
        }

        /// <p>Adds a new item to an existing subscription. No existing items will be changed or replaced.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.SubscriptionItem> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period. When updating, pass an empty string to remove previously-defined thresholds.
            public var billingThresholds: BillingThresholds?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// Use `allow_incomplete` to transition the subscription to `status=past_due` if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.
            /// 
            /// Use `default_incomplete` to transition the subscription to `status=past_due` when payment is required and await explicit confirmation of the invoice's payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.
            /// 
            /// Use `pending_if_incomplete` to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use `pending_if_incomplete` you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).
            /// 
            /// Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
            public var paymentBehavior: PaymentBehavior?
            /// The ID of the price object.
            public var price: String?
            /// Recurring_price_data
            ///
            /// Data used to generate a new [Price](https://stripe.com/docs/api/prices) object inline.
            public var priceData: PriceData?
            /// Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes. Valid values are `create_prorations`, `none`, or `always_invoice`.
            /// 
            /// Passing `create_prorations` will cause proration invoice items to be created when applicable. These proration items will only be invoiced immediately under [certain conditions](https://stripe.com/docs/subscriptions/upgrading-downgrading#immediate-payment). In order to always invoice immediately for prorations, pass `always_invoice`.
            /// 
            /// Prorations can be disabled by passing `none`.
            public var prorationBehavior: ProrationBehavior?
            /// If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply the same proration that was previewed with the [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint.
            public var prorationDate: Int?
            /// The quantity you'd like to apply to the subscription item you're creating.
            public var quantity: Int?
            /// The identifier of the subscription to modify.
            public var subscription: String
            /// A list of [Tax Rate](https://stripe.com/docs/api/tax_rates) ids. These Tax Rates will override the [`default_tax_rates`](https://stripe.com/docs/api/subscriptions/create#create_subscription-default_tax_rates) on the Subscription. When updating, pass an empty string to remove previously-defined tax rates.
            public var taxRates: TaxRates?

            /// Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period. When updating, pass an empty string to remove previously-defined thresholds.
            public struct BillingThresholds: Encodable {
                /// Item_billing_thresholds_param
                public var a: A?
                public var b: B?

                /// Item_billing_thresholds_param
                public struct A: Encodable {
                    public var usageGte: Int

                    public init(usageGte: Int) {
                        self.usageGte = usageGte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(usageGte, forKey: "usage_gte")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Use `allow_incomplete` to transition the subscription to `status=past_due` if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.
            /// 
            /// Use `default_incomplete` to transition the subscription to `status=past_due` when payment is required and await explicit confirmation of the invoice's payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.
            /// 
            /// Use `pending_if_incomplete` to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use `pending_if_incomplete` you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).
            /// 
            /// Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
            public enum PaymentBehavior: String, Codable, CaseIterable {
                case allowIncomplete = "allow_incomplete"
                case defaultIncomplete = "default_incomplete"
                case errorIfIncomplete = "error_if_incomplete"
                case pendingIfIncomplete = "pending_if_incomplete"
            }

            /// Recurring_price_data
            ///
            /// Data used to generate a new [Price](https://stripe.com/docs/api/prices) object inline.
            public struct PriceData: Encodable {
                public var currency: String
                public var product: String
                /// Recurring_adhoc
                public var recurring: Recurring
                public var taxBehavior: TaxBehavior?
                public var unitAmount: Int?
                public var unitAmountDecimal: String?

                /// Recurring_adhoc
                public struct Recurring: Encodable {
                    public var interval: Interval
                    public var intervalCount: Int?

                    public enum Interval: String, Codable, CaseIterable {
                        case day
                        case month
                        case week
                        case year
                    }

                    public init(interval: Interval, intervalCount: Int? = nil) {
                        self.interval = interval
                        self.intervalCount = intervalCount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(interval, forKey: "interval")
                        encoder.encode(intervalCount, forKey: "interval_count")
                        return encoder.items
                    }
                }

                public enum TaxBehavior: String, Codable, CaseIterable {
                    case exclusive
                    case inclusive
                    case unspecified
                }

                public init(currency: String, product: String, recurring: Recurring, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                    self.currency = currency
                    self.product = product
                    self.recurring = recurring
                    self.taxBehavior = taxBehavior
                    self.unitAmount = unitAmount
                    self.unitAmountDecimal = unitAmountDecimal
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(currency, forKey: "currency")
                    encoder.encode(product, forKey: "product")
                    encoder.encode(recurring, forKey: "recurring")
                    encoder.encode(taxBehavior, forKey: "tax_behavior")
                    encoder.encode(unitAmount, forKey: "unit_amount")
                    encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                    return encoder.items
                }
            }

            /// Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes. Valid values are `create_prorations`, `none`, or `always_invoice`.
            /// 
            /// Passing `create_prorations` will cause proration invoice items to be created when applicable. These proration items will only be invoiced immediately under [certain conditions](https://stripe.com/docs/subscriptions/upgrading-downgrading#immediate-payment). In order to always invoice immediately for prorations, pass `always_invoice`.
            /// 
            /// Prorations can be disabled by passing `none`.
            public enum ProrationBehavior: String, Codable, CaseIterable {
                case alwaysInvoice = "always_invoice"
                case createProrations = "create_prorations"
                case `none`
            }

            /// A list of [Tax Rate](https://stripe.com/docs/api/tax_rates) ids. These Tax Rates will override the [`default_tax_rates`](https://stripe.com/docs/api/subscriptions/create#create_subscription-default_tax_rates) on the Subscription. When updating, pass an empty string to remove previously-defined tax rates.
            public struct TaxRates: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(billingThresholds: BillingThresholds? = nil, expand: [String]? = nil, metadata: [String: String]? = nil, paymentBehavior: PaymentBehavior? = nil, price: String? = nil, priceData: PriceData? = nil, prorationBehavior: ProrationBehavior? = nil, prorationDate: Int? = nil, quantity: Int? = nil, subscription: String, taxRates: TaxRates? = nil) {
                self.billingThresholds = billingThresholds
                self.expand = expand
                self.metadata = metadata
                self.paymentBehavior = paymentBehavior
                self.price = price
                self.priceData = priceData
                self.prorationBehavior = prorationBehavior
                self.prorationDate = prorationDate
                self.quantity = quantity
                self.subscription = subscription
                self.taxRates = taxRates
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(billingThresholds, forKey: "billing_thresholds")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(paymentBehavior, forKey: "payment_behavior")
                encoder.encode(price, forKey: "price")
                encoder.encode(priceData, forKey: "price_data")
                encoder.encode(prorationBehavior, forKey: "proration_behavior")
                encoder.encode(prorationDate, forKey: "proration_date")
                encoder.encode(quantity, forKey: "quantity")
                encoder.encode(subscription, forKey: "subscription")
                encoder.encode(taxRates, forKey: "tax_rates")
                return encoder.items
            }
        }
    }
}

extension Paths.SubscriptionItems {
    public func item(_ item: String) -> WithItem {
        WithItem(path: "\(path)/\(item)")
    }

    public struct WithItem {
        /// Path: `/v1/subscription_items/{item}`
        public let path: String

        /// <p>Retrieves the subscription item with the given ID.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.SubscriptionItem> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the plan or quantity of an item on a current subscription.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.SubscriptionItem> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period. When updating, pass an empty string to remove previously-defined thresholds.
            public var billingThresholds: BillingThresholds?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// Indicates if a customer is on or off-session while an invoice payment is attempted.
            public var isOffSession: Bool?
            /// Use `allow_incomplete` to transition the subscription to `status=past_due` if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.
            /// 
            /// Use `default_incomplete` to transition the subscription to `status=past_due` when payment is required and await explicit confirmation of the invoice's payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.
            /// 
            /// Use `pending_if_incomplete` to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use `pending_if_incomplete` you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).
            /// 
            /// Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
            public var paymentBehavior: PaymentBehavior?
            /// The ID of the price object. When changing a subscription item's price, `quantity` is set to 1 unless a `quantity` parameter is provided.
            public var price: String?
            /// Recurring_price_data
            ///
            /// Data used to generate a new [Price](https://stripe.com/docs/api/prices) object inline.
            public var priceData: PriceData?
            /// Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes. Valid values are `create_prorations`, `none`, or `always_invoice`.
            /// 
            /// Passing `create_prorations` will cause proration invoice items to be created when applicable. These proration items will only be invoiced immediately under [certain conditions](https://stripe.com/docs/subscriptions/upgrading-downgrading#immediate-payment). In order to always invoice immediately for prorations, pass `always_invoice`.
            /// 
            /// Prorations can be disabled by passing `none`.
            public var prorationBehavior: ProrationBehavior?
            /// If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply the same proration that was previewed with the [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint.
            public var prorationDate: Int?
            /// The quantity you'd like to apply to the subscription item you're creating.
            public var quantity: Int?
            /// A list of [Tax Rate](https://stripe.com/docs/api/tax_rates) ids. These Tax Rates will override the [`default_tax_rates`](https://stripe.com/docs/api/subscriptions/create#create_subscription-default_tax_rates) on the Subscription. When updating, pass an empty string to remove previously-defined tax rates.
            public var taxRates: TaxRates?

            /// Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period. When updating, pass an empty string to remove previously-defined thresholds.
            public struct BillingThresholds: Encodable {
                /// Item_billing_thresholds_param
                public var a: A?
                public var b: B?

                /// Item_billing_thresholds_param
                public struct A: Encodable {
                    public var usageGte: Int

                    public init(usageGte: Int) {
                        self.usageGte = usageGte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(usageGte, forKey: "usage_gte")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Use `allow_incomplete` to transition the subscription to `status=past_due` if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.
            /// 
            /// Use `default_incomplete` to transition the subscription to `status=past_due` when payment is required and await explicit confirmation of the invoice's payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.
            /// 
            /// Use `pending_if_incomplete` to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use `pending_if_incomplete` you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).
            /// 
            /// Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
            public enum PaymentBehavior: String, Codable, CaseIterable {
                case allowIncomplete = "allow_incomplete"
                case defaultIncomplete = "default_incomplete"
                case errorIfIncomplete = "error_if_incomplete"
                case pendingIfIncomplete = "pending_if_incomplete"
            }

            /// Recurring_price_data
            ///
            /// Data used to generate a new [Price](https://stripe.com/docs/api/prices) object inline.
            public struct PriceData: Encodable {
                public var currency: String
                public var product: String
                /// Recurring_adhoc
                public var recurring: Recurring
                public var taxBehavior: TaxBehavior?
                public var unitAmount: Int?
                public var unitAmountDecimal: String?

                /// Recurring_adhoc
                public struct Recurring: Encodable {
                    public var interval: Interval
                    public var intervalCount: Int?

                    public enum Interval: String, Codable, CaseIterable {
                        case day
                        case month
                        case week
                        case year
                    }

                    public init(interval: Interval, intervalCount: Int? = nil) {
                        self.interval = interval
                        self.intervalCount = intervalCount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(interval, forKey: "interval")
                        encoder.encode(intervalCount, forKey: "interval_count")
                        return encoder.items
                    }
                }

                public enum TaxBehavior: String, Codable, CaseIterable {
                    case exclusive
                    case inclusive
                    case unspecified
                }

                public init(currency: String, product: String, recurring: Recurring, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                    self.currency = currency
                    self.product = product
                    self.recurring = recurring
                    self.taxBehavior = taxBehavior
                    self.unitAmount = unitAmount
                    self.unitAmountDecimal = unitAmountDecimal
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(currency, forKey: "currency")
                    encoder.encode(product, forKey: "product")
                    encoder.encode(recurring, forKey: "recurring")
                    encoder.encode(taxBehavior, forKey: "tax_behavior")
                    encoder.encode(unitAmount, forKey: "unit_amount")
                    encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                    return encoder.items
                }
            }

            /// Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes. Valid values are `create_prorations`, `none`, or `always_invoice`.
            /// 
            /// Passing `create_prorations` will cause proration invoice items to be created when applicable. These proration items will only be invoiced immediately under [certain conditions](https://stripe.com/docs/subscriptions/upgrading-downgrading#immediate-payment). In order to always invoice immediately for prorations, pass `always_invoice`.
            /// 
            /// Prorations can be disabled by passing `none`.
            public enum ProrationBehavior: String, Codable, CaseIterable {
                case alwaysInvoice = "always_invoice"
                case createProrations = "create_prorations"
                case `none`
            }

            /// A list of [Tax Rate](https://stripe.com/docs/api/tax_rates) ids. These Tax Rates will override the [`default_tax_rates`](https://stripe.com/docs/api/subscriptions/create#create_subscription-default_tax_rates) on the Subscription. When updating, pass an empty string to remove previously-defined tax rates.
            public struct TaxRates: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(billingThresholds: BillingThresholds? = nil, expand: [String]? = nil, metadata: Metadata? = nil, isOffSession: Bool? = nil, paymentBehavior: PaymentBehavior? = nil, price: String? = nil, priceData: PriceData? = nil, prorationBehavior: ProrationBehavior? = nil, prorationDate: Int? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                self.billingThresholds = billingThresholds
                self.expand = expand
                self.metadata = metadata
                self.isOffSession = isOffSession
                self.paymentBehavior = paymentBehavior
                self.price = price
                self.priceData = priceData
                self.prorationBehavior = prorationBehavior
                self.prorationDate = prorationDate
                self.quantity = quantity
                self.taxRates = taxRates
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(billingThresholds, forKey: "billing_thresholds")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(isOffSession, forKey: "off_session")
                encoder.encode(paymentBehavior, forKey: "payment_behavior")
                encoder.encode(price, forKey: "price")
                encoder.encode(priceData, forKey: "price_data")
                encoder.encode(prorationBehavior, forKey: "proration_behavior")
                encoder.encode(prorationDate, forKey: "proration_date")
                encoder.encode(quantity, forKey: "quantity")
                encoder.encode(taxRates, forKey: "tax_rates")
                return encoder.items
            }
        }

        /// <p>Deletes an item from the subscription. Removing a subscription item from a subscription will not cancel the subscription.</p>
        public func delete(_ body: DeleteRequest? = nil) -> Request<StripeAPI.DeletedSubscriptionItem> {
            .delete(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct DeleteRequest: Encodable {
            /// Delete all usage for the given subscription item. Allowed only when the current plan's `usage_type` is `metered`.
            public var isClearUsage: Bool?
            /// Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes. Valid values are `create_prorations`, `none`, or `always_invoice`.
            /// 
            /// Passing `create_prorations` will cause proration invoice items to be created when applicable. These proration items will only be invoiced immediately under [certain conditions](https://stripe.com/docs/subscriptions/upgrading-downgrading#immediate-payment). In order to always invoice immediately for prorations, pass `always_invoice`.
            /// 
            /// Prorations can be disabled by passing `none`.
            public var prorationBehavior: ProrationBehavior?
            /// If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply the same proration that was previewed with the [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint.
            public var prorationDate: Int?

            /// Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes. Valid values are `create_prorations`, `none`, or `always_invoice`.
            /// 
            /// Passing `create_prorations` will cause proration invoice items to be created when applicable. These proration items will only be invoiced immediately under [certain conditions](https://stripe.com/docs/subscriptions/upgrading-downgrading#immediate-payment). In order to always invoice immediately for prorations, pass `always_invoice`.
            /// 
            /// Prorations can be disabled by passing `none`.
            public enum ProrationBehavior: String, Codable, CaseIterable {
                case alwaysInvoice = "always_invoice"
                case createProrations = "create_prorations"
                case `none`
            }

            public init(isClearUsage: Bool? = nil, prorationBehavior: ProrationBehavior? = nil, prorationDate: Int? = nil) {
                self.isClearUsage = isClearUsage
                self.prorationBehavior = prorationBehavior
                self.prorationDate = prorationDate
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isClearUsage, forKey: "clear_usage")
                encoder.encode(prorationBehavior, forKey: "proration_behavior")
                encoder.encode(prorationDate, forKey: "proration_date")
                return encoder.items
            }
        }
    }
}

extension Paths.SubscriptionItems {
    public func subscriptionItem(_ subscriptionItem: String) -> WithSubscriptionItem {
        WithSubscriptionItem(path: "\(path)/\(subscriptionItem)")
    }

    public struct WithSubscriptionItem {
        /// Path: `/v1/subscription_items/{subscription_item}`
        public let path: String
    }
}

extension Paths.SubscriptionItems.WithSubscriptionItem {
    public var usageRecordSummaries: UsageRecordSummaries {
        UsageRecordSummaries(path: path + "/usage_record_summaries")
    }

    public struct UsageRecordSummaries {
        /// Path: `/v1/subscription_items/{subscription_item}/usage_record_summaries`
        public let path: String

        /// <p>For the specified subscription item, returns a list of summary objects. Each object in the list provides usage information that’s been summarized from multiple usage records and over a subscription billing period (e.g., 15 usage records in the month of September).</p>
        /// 
        /// <p>The list is sorted in reverse-chronological order (newest first). The first list item represents the most current usage period that hasn’t ended yet. Since new usage records can still be added, the returned summary information for the subscription item’s ID should be seen as unstable until the subscription billing period ends.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.UsageRecordSummary]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.UsageRecordSummary], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }
    }
}

extension Paths.SubscriptionItems.WithSubscriptionItem {
    public var usageRecords: UsageRecords {
        UsageRecords(path: path + "/usage_records")
    }

    public struct UsageRecords {
        /// Path: `/v1/subscription_items/{subscription_item}/usage_records`
        public let path: String

        /// <p>Creates a usage record for a specified subscription item and date, and fills it with a quantity.</p>
        /// 
        /// <p>Usage records provide <code>quantity</code> information that Stripe uses to track how much a customer is using your service. With usage information and the pricing model set up by the <a href="https://stripe.com/docs/billing/subscriptions/metered-billing">metered billing</a> plan, Stripe helps you send accurate invoices to your customers.</p>
        /// 
        /// <p>The default calculation for usage is to add up all the <code>quantity</code> values of the usage records within a billing period. You can change this default behavior with the billing plan’s <code>aggregate_usage</code> <a href="/docs/api/plans/create#create_plan-aggregate_usage">parameter</a>. When there is more than one usage record with the same timestamp, Stripe adds the <code>quantity</code> values together. In most cases, this is the desired resolution, however, you can change this behavior with the <code>action</code> parameter.</p>
        /// 
        /// <p>The default pricing model for metered billing is <a href="/docs/api/plans/object#plan_object-billing_scheme">per-unit pricing</a>. For finer granularity, you can configure metered billing to have a <a href="https://stripe.com/docs/billing/subscriptions/tiers">tiered pricing</a> model.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.UsageRecord> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Valid values are `increment` (default) or `set`. When using `increment` the specified `quantity` will be added to the usage at the specified timestamp. The `set` action will overwrite the usage quantity at that timestamp. If the subscription has [billing thresholds](https://stripe.com/docs/api/subscriptions/object#subscription_object-billing_thresholds), `increment` is the only allowed value.
            public var action: Action?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The usage quantity for the specified timestamp.
            public var quantity: Int
            /// The timestamp for the usage event. This timestamp must be within the current billing period of the subscription of the provided `subscription_item`, and must not be in the future. When passing `"now"`, Stripe records usage for the current time. Default is `"now"` if a value is not provided.
            public var timestamp: Timestamp?

            /// Valid values are `increment` (default) or `set`. When using `increment` the specified `quantity` will be added to the usage at the specified timestamp. The `set` action will overwrite the usage quantity at that timestamp. If the subscription has [billing thresholds](https://stripe.com/docs/api/subscriptions/object#subscription_object-billing_thresholds), `increment` is the only allowed value.
            public enum Action: String, Codable, CaseIterable {
                case increment
                case set
            }

            /// The timestamp for the usage event. This timestamp must be within the current billing period of the subscription of the provided `subscription_item`, and must not be in the future. When passing `"now"`, Stripe records usage for the current time. Default is `"now"` if a value is not provided.
            public struct Timestamp: Encodable {
                public var object: Object?
                public var int: Int?

                public enum Object: String, Codable, CaseIterable {
                    case now
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(action: Action? = nil, expand: [String]? = nil, quantity: Int, timestamp: Timestamp? = nil) {
                self.action = action
                self.expand = expand
                self.quantity = quantity
                self.timestamp = timestamp
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(action, forKey: "action")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(quantity, forKey: "quantity")
                encoder.encode(timestamp, forKey: "timestamp")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var subscriptionSchedules: SubscriptionSchedules {
        SubscriptionSchedules(path: "/v1/subscription_schedules")
    }

    public struct SubscriptionSchedules {
        /// Path: `/v1/subscription_schedules`
        public let path: String

        /// <p>Retrieves the list of your subscription schedules.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.SubscriptionSchedule]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.SubscriptionSchedule], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var canceledAt: CanceledAt?
            public var completedAt: CompletedAt?
            public var created: Created?
            public var customer: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var releasedAt: ReleasedAt?
            public var isScheduled: Bool?
            public var startingAfter: String?

            public struct CanceledAt: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public struct CompletedAt: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public struct ReleasedAt: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(canceledAt: CanceledAt? = nil, completedAt: CompletedAt? = nil, created: Created? = nil, customer: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, releasedAt: ReleasedAt? = nil, isScheduled: Bool? = nil, startingAfter: String? = nil) {
                self.canceledAt = canceledAt
                self.completedAt = completedAt
                self.created = created
                self.customer = customer
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.releasedAt = releasedAt
                self.isScheduled = isScheduled
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(canceledAt, forKey: "canceled_at", isDeepObject: true)
                encoder.encode(completedAt, forKey: "completed_at", isDeepObject: true)
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(customer, forKey: "customer")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(releasedAt, forKey: "released_at", isDeepObject: true)
                encoder.encode(isScheduled, forKey: "scheduled")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates a new subscription schedule object. Each customer can have up to 500 active or scheduled subscriptions.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.SubscriptionSchedule> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// The identifier of the customer to create the subscription schedule for.
            public var customer: String?
            /// Default_settings_params
            ///
            /// Object representing the subscription schedule's default settings.
            public var defaultSettings: DefaultSettings?
            /// Configures how the subscription schedule behaves when it ends. Possible values are `release` or `cancel` with the default being `release`. `release` will end the subscription schedule and keep the underlying subscription running.`cancel` will end the subscription schedule and cancel the underlying subscription.
            public var endBehavior: EndBehavior?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Migrate an existing subscription to be managed by a subscription schedule. If this parameter is set, a subscription schedule will be created using the subscription's item(s), set to auto-renew using the subscription's interval. When using this parameter, other parameters (such as phase values) cannot be set. To create a subscription schedule with other modifications, we recommend making two separate API calls.
            public var fromSubscription: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// List representing phases of the subscription schedule. Each phase can be customized to have different durations, plans, and coupons. If there are multiple phases, the `end_date` of one phase will always equal the `start_date` of the next phase.
            public var phases: [Phase]?
            /// When the subscription schedule starts. We recommend using `now` so that it starts the subscription immediately. You can also use a Unix timestamp to backdate the subscription so that it starts on a past date, or set a future date for the subscription to start on.
            public var startDate: StartDate?

            /// Default_settings_params
            ///
            /// Object representing the subscription schedule's default settings.
            public struct DefaultSettings: Encodable {
                public var applicationFeePercent: Double?
                /// Automatic_tax_config
                public var automaticTax: AutomaticTax?
                public var billingCycleAnchor: BillingCycleAnchor?
                public var billingThresholds: BillingThresholds?
                public var collectionMethod: CollectionMethod?
                public var defaultPaymentMethod: String?
                /// Subscription_schedules_param
                public var invoiceSettings: InvoiceSettings?
                public var transferData: TransferData?

                /// Automatic_tax_config
                public struct AutomaticTax: Encodable {
                    public var isEnabled: Bool

                    public init(isEnabled: Bool) {
                        self.isEnabled = isEnabled
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isEnabled, forKey: "enabled")
                        return encoder.items
                    }
                }

                public enum BillingCycleAnchor: String, Codable, CaseIterable {
                    case automatic
                    case phaseStart = "phase_start"
                }

                public struct BillingThresholds: Encodable {
                    /// Billing_thresholds_param
                    public var a: A?
                    public var b: B?

                    /// Billing_thresholds_param
                    public struct A: Encodable {
                        public var amountGte: Int?
                        public var isResetBillingCycleAnchor: Bool?

                        public init(amountGte: Int? = nil, isResetBillingCycleAnchor: Bool? = nil) {
                            self.amountGte = amountGte
                            self.isResetBillingCycleAnchor = isResetBillingCycleAnchor
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(amountGte, forKey: "amount_gte")
                            encoder.encode(isResetBillingCycleAnchor, forKey: "reset_billing_cycle_anchor")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public enum CollectionMethod: String, Codable, CaseIterable {
                    case chargeAutomatically = "charge_automatically"
                    case sendInvoice = "send_invoice"
                }

                /// Subscription_schedules_param
                public struct InvoiceSettings: Encodable {
                    public var daysUntilDue: Int?

                    public init(daysUntilDue: Int? = nil) {
                        self.daysUntilDue = daysUntilDue
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(daysUntilDue, forKey: "days_until_due")
                        return encoder.items
                    }
                }

                public struct TransferData: Encodable {
                    /// Transfer_data_specs
                    public var a: A?
                    public var b: B?

                    /// Transfer_data_specs
                    public struct A: Encodable {
                        public var amountPercent: Double?
                        public var destination: String

                        public init(amountPercent: Double? = nil, destination: String) {
                            self.amountPercent = amountPercent
                            self.destination = destination
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(amountPercent, forKey: "amount_percent")
                            encoder.encode(destination, forKey: "destination")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public init(applicationFeePercent: Double? = nil, automaticTax: AutomaticTax? = nil, billingCycleAnchor: BillingCycleAnchor? = nil, billingThresholds: BillingThresholds? = nil, collectionMethod: CollectionMethod? = nil, defaultPaymentMethod: String? = nil, invoiceSettings: InvoiceSettings? = nil, transferData: TransferData? = nil) {
                    self.applicationFeePercent = applicationFeePercent
                    self.automaticTax = automaticTax
                    self.billingCycleAnchor = billingCycleAnchor
                    self.billingThresholds = billingThresholds
                    self.collectionMethod = collectionMethod
                    self.defaultPaymentMethod = defaultPaymentMethod
                    self.invoiceSettings = invoiceSettings
                    self.transferData = transferData
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(applicationFeePercent, forKey: "application_fee_percent")
                    encoder.encode(automaticTax, forKey: "automatic_tax")
                    encoder.encode(billingCycleAnchor, forKey: "billing_cycle_anchor")
                    encoder.encode(billingThresholds, forKey: "billing_thresholds")
                    encoder.encode(collectionMethod, forKey: "collection_method")
                    encoder.encode(defaultPaymentMethod, forKey: "default_payment_method")
                    encoder.encode(invoiceSettings, forKey: "invoice_settings")
                    encoder.encode(transferData, forKey: "transfer_data")
                    return encoder.items
                }
            }

            /// Configures how the subscription schedule behaves when it ends. Possible values are `release` or `cancel` with the default being `release`. `release` will end the subscription schedule and keep the underlying subscription running.`cancel` will end the subscription schedule and cancel the underlying subscription.
            public enum EndBehavior: String, Codable, CaseIterable {
                case cancel
                case `none`
                case release
                case renew
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Phase_configuration_params
            public struct Phase: Encodable {
                public var addInvoiceItems: [AddInvoiceItem]?
                public var applicationFeePercent: Double?
                /// Automatic_tax_config
                public var automaticTax: AutomaticTax?
                public var billingCycleAnchor: BillingCycleAnchor?
                public var billingThresholds: BillingThresholds?
                public var collectionMethod: CollectionMethod?
                public var coupon: String?
                public var defaultPaymentMethod: String?
                public var defaultTaxRates: DefaultTaxRates?
                public var endDate: Int?
                /// Subscription_schedules_param
                public var invoiceSettings: InvoiceSettings?
                public var items: [Item]
                public var iterations: Int?
                public var prorationBehavior: ProrationBehavior?
                /// Transfer_data_specs
                public var transferData: TransferData?
                public var isTrial: Bool?
                public var trialEnd: Int?

                /// Add_invoice_item_entry
                public struct AddInvoiceItem: Encodable {
                    public var price: String?
                    /// One_time_price_data
                    public var priceData: PriceData?
                    public var quantity: Int?
                    public var taxRates: TaxRates?

                    /// One_time_price_data
                    public struct PriceData: Encodable {
                        public var currency: String
                        public var product: String
                        public var taxBehavior: TaxBehavior?
                        public var unitAmount: Int?
                        public var unitAmountDecimal: String?

                        public enum TaxBehavior: String, Codable, CaseIterable {
                            case exclusive
                            case inclusive
                            case unspecified
                        }

                        public init(currency: String, product: String, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                            self.currency = currency
                            self.product = product
                            self.taxBehavior = taxBehavior
                            self.unitAmount = unitAmount
                            self.unitAmountDecimal = unitAmountDecimal
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(currency, forKey: "currency")
                            encoder.encode(product, forKey: "product")
                            encoder.encode(taxBehavior, forKey: "tax_behavior")
                            encoder.encode(unitAmount, forKey: "unit_amount")
                            encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                            return encoder.items
                        }
                    }

                    public struct TaxRates: Encodable {
                        public var strings: [String]?
                        public var object: Object?

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(strings: [String]? = nil, object: Object? = nil) {
                            self.strings = strings
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(strings, forKey: "strings")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public init(price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                        self.price = price
                        self.priceData = priceData
                        self.quantity = quantity
                        self.taxRates = taxRates
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(price, forKey: "price")
                        encoder.encode(priceData, forKey: "price_data")
                        encoder.encode(quantity, forKey: "quantity")
                        encoder.encode(taxRates, forKey: "tax_rates")
                        return encoder.items
                    }
                }

                /// Automatic_tax_config
                public struct AutomaticTax: Encodable {
                    public var isEnabled: Bool

                    public init(isEnabled: Bool) {
                        self.isEnabled = isEnabled
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isEnabled, forKey: "enabled")
                        return encoder.items
                    }
                }

                public enum BillingCycleAnchor: String, Codable, CaseIterable {
                    case automatic
                    case phaseStart = "phase_start"
                }

                public struct BillingThresholds: Encodable {
                    /// Billing_thresholds_param
                    public var a: A?
                    public var b: B?

                    /// Billing_thresholds_param
                    public struct A: Encodable {
                        public var amountGte: Int?
                        public var isResetBillingCycleAnchor: Bool?

                        public init(amountGte: Int? = nil, isResetBillingCycleAnchor: Bool? = nil) {
                            self.amountGte = amountGte
                            self.isResetBillingCycleAnchor = isResetBillingCycleAnchor
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(amountGte, forKey: "amount_gte")
                            encoder.encode(isResetBillingCycleAnchor, forKey: "reset_billing_cycle_anchor")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public enum CollectionMethod: String, Codable, CaseIterable {
                    case chargeAutomatically = "charge_automatically"
                    case sendInvoice = "send_invoice"
                }

                public struct DefaultTaxRates: Encodable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                /// Subscription_schedules_param
                public struct InvoiceSettings: Encodable {
                    public var daysUntilDue: Int?

                    public init(daysUntilDue: Int? = nil) {
                        self.daysUntilDue = daysUntilDue
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(daysUntilDue, forKey: "days_until_due")
                        return encoder.items
                    }
                }

                /// Configuration_item_params
                public struct Item: Encodable {
                    public var billingThresholds: BillingThresholds?
                    public var price: String?
                    /// Recurring_price_data
                    public var priceData: PriceData?
                    public var quantity: Int?
                    public var taxRates: TaxRates?

                    public struct BillingThresholds: Encodable {
                        /// Item_billing_thresholds_param
                        public var a: A?
                        public var b: B?

                        /// Item_billing_thresholds_param
                        public struct A: Encodable {
                            public var usageGte: Int

                            public init(usageGte: Int) {
                                self.usageGte = usageGte
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(usageGte, forKey: "usage_gte")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    /// Recurring_price_data
                    public struct PriceData: Encodable {
                        public var currency: String
                        public var product: String
                        /// Recurring_adhoc
                        public var recurring: Recurring
                        public var taxBehavior: TaxBehavior?
                        public var unitAmount: Int?
                        public var unitAmountDecimal: String?

                        /// Recurring_adhoc
                        public struct Recurring: Encodable {
                            public var interval: Interval
                            public var intervalCount: Int?

                            public enum Interval: String, Codable, CaseIterable {
                                case day
                                case month
                                case week
                                case year
                            }

                            public init(interval: Interval, intervalCount: Int? = nil) {
                                self.interval = interval
                                self.intervalCount = intervalCount
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(interval, forKey: "interval")
                                encoder.encode(intervalCount, forKey: "interval_count")
                                return encoder.items
                            }
                        }

                        public enum TaxBehavior: String, Codable, CaseIterable {
                            case exclusive
                            case inclusive
                            case unspecified
                        }

                        public init(currency: String, product: String, recurring: Recurring, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                            self.currency = currency
                            self.product = product
                            self.recurring = recurring
                            self.taxBehavior = taxBehavior
                            self.unitAmount = unitAmount
                            self.unitAmountDecimal = unitAmountDecimal
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(currency, forKey: "currency")
                            encoder.encode(product, forKey: "product")
                            encoder.encode(recurring, forKey: "recurring")
                            encoder.encode(taxBehavior, forKey: "tax_behavior")
                            encoder.encode(unitAmount, forKey: "unit_amount")
                            encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                            return encoder.items
                        }
                    }

                    public struct TaxRates: Encodable {
                        public var strings: [String]?
                        public var object: Object?

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(strings: [String]? = nil, object: Object? = nil) {
                            self.strings = strings
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(strings, forKey: "strings")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public init(billingThresholds: BillingThresholds? = nil, price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                        self.billingThresholds = billingThresholds
                        self.price = price
                        self.priceData = priceData
                        self.quantity = quantity
                        self.taxRates = taxRates
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(billingThresholds, forKey: "billing_thresholds")
                        encoder.encode(price, forKey: "price")
                        encoder.encode(priceData, forKey: "price_data")
                        encoder.encode(quantity, forKey: "quantity")
                        encoder.encode(taxRates, forKey: "tax_rates")
                        return encoder.items
                    }
                }

                public enum ProrationBehavior: String, Codable, CaseIterable {
                    case alwaysInvoice = "always_invoice"
                    case createProrations = "create_prorations"
                    case `none`
                }

                /// Transfer_data_specs
                public struct TransferData: Encodable {
                    public var amountPercent: Double?
                    public var destination: String

                    public init(amountPercent: Double? = nil, destination: String) {
                        self.amountPercent = amountPercent
                        self.destination = destination
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amountPercent, forKey: "amount_percent")
                        encoder.encode(destination, forKey: "destination")
                        return encoder.items
                    }
                }

                public init(addInvoiceItems: [AddInvoiceItem]? = nil, applicationFeePercent: Double? = nil, automaticTax: AutomaticTax? = nil, billingCycleAnchor: BillingCycleAnchor? = nil, billingThresholds: BillingThresholds? = nil, collectionMethod: CollectionMethod? = nil, coupon: String? = nil, defaultPaymentMethod: String? = nil, defaultTaxRates: DefaultTaxRates? = nil, endDate: Int? = nil, invoiceSettings: InvoiceSettings? = nil, items: [Item], iterations: Int? = nil, prorationBehavior: ProrationBehavior? = nil, transferData: TransferData? = nil, isTrial: Bool? = nil, trialEnd: Int? = nil) {
                    self.addInvoiceItems = addInvoiceItems
                    self.applicationFeePercent = applicationFeePercent
                    self.automaticTax = automaticTax
                    self.billingCycleAnchor = billingCycleAnchor
                    self.billingThresholds = billingThresholds
                    self.collectionMethod = collectionMethod
                    self.coupon = coupon
                    self.defaultPaymentMethod = defaultPaymentMethod
                    self.defaultTaxRates = defaultTaxRates
                    self.endDate = endDate
                    self.invoiceSettings = invoiceSettings
                    self.items = items
                    self.iterations = iterations
                    self.prorationBehavior = prorationBehavior
                    self.transferData = transferData
                    self.isTrial = isTrial
                    self.trialEnd = trialEnd
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(addInvoiceItems, forKey: "add_invoice_items")
                    encoder.encode(applicationFeePercent, forKey: "application_fee_percent")
                    encoder.encode(automaticTax, forKey: "automatic_tax")
                    encoder.encode(billingCycleAnchor, forKey: "billing_cycle_anchor")
                    encoder.encode(billingThresholds, forKey: "billing_thresholds")
                    encoder.encode(collectionMethod, forKey: "collection_method")
                    encoder.encode(coupon, forKey: "coupon")
                    encoder.encode(defaultPaymentMethod, forKey: "default_payment_method")
                    encoder.encode(defaultTaxRates, forKey: "default_tax_rates")
                    encoder.encode(endDate, forKey: "end_date")
                    encoder.encode(invoiceSettings, forKey: "invoice_settings")
                    encoder.encode(items, forKey: "items")
                    encoder.encode(iterations, forKey: "iterations")
                    encoder.encode(prorationBehavior, forKey: "proration_behavior")
                    encoder.encode(transferData, forKey: "transfer_data")
                    encoder.encode(isTrial, forKey: "trial")
                    encoder.encode(trialEnd, forKey: "trial_end")
                    return encoder.items
                }
            }

            /// When the subscription schedule starts. We recommend using `now` so that it starts the subscription immediately. You can also use a Unix timestamp to backdate the subscription so that it starts on a past date, or set a future date for the subscription to start on.
            public struct StartDate: Encodable {
                public var int: Int?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case now
                }

                public init(int: Int? = nil, object: Object? = nil) {
                    self.int = int
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(int, forKey: "int")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(customer: String? = nil, defaultSettings: DefaultSettings? = nil, endBehavior: EndBehavior? = nil, expand: [String]? = nil, fromSubscription: String? = nil, metadata: Metadata? = nil, phases: [Phase]? = nil, startDate: StartDate? = nil) {
                self.customer = customer
                self.defaultSettings = defaultSettings
                self.endBehavior = endBehavior
                self.expand = expand
                self.fromSubscription = fromSubscription
                self.metadata = metadata
                self.phases = phases
                self.startDate = startDate
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(customer, forKey: "customer")
                encoder.encode(defaultSettings, forKey: "default_settings")
                encoder.encode(endBehavior, forKey: "end_behavior")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(fromSubscription, forKey: "from_subscription")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(phases, forKey: "phases")
                encoder.encode(startDate, forKey: "start_date")
                return encoder.items
            }
        }
    }
}

extension Paths.SubscriptionSchedules {
    public func schedule(_ schedule: String) -> WithSchedule {
        WithSchedule(path: "\(path)/\(schedule)")
    }

    public struct WithSchedule {
        /// Path: `/v1/subscription_schedules/{schedule}`
        public let path: String

        /// <p>Retrieves the details of an existing subscription schedule. You only need to supply the unique subscription schedule identifier that was returned upon subscription schedule creation.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.SubscriptionSchedule> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates an existing subscription schedule.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.SubscriptionSchedule> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Default_settings_params
            ///
            /// Object representing the subscription schedule's default settings.
            public var defaultSettings: DefaultSettings?
            /// Configures how the subscription schedule behaves when it ends. Possible values are `release` or `cancel` with the default being `release`. `release` will end the subscription schedule and keep the underlying subscription running.`cancel` will end the subscription schedule and cancel the underlying subscription.
            public var endBehavior: EndBehavior?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// List representing phases of the subscription schedule. Each phase can be customized to have different durations, plans, and coupons. If there are multiple phases, the `end_date` of one phase will always equal the `start_date` of the next phase. Note that past phases can be omitted.
            public var phases: [Phase]?
            /// If the update changes the current phase, indicates if the changes should be prorated. Possible values are `create_prorations` or `none`, and the default value is `create_prorations`.
            public var prorationBehavior: ProrationBehavior?

            /// Default_settings_params
            ///
            /// Object representing the subscription schedule's default settings.
            public struct DefaultSettings: Encodable {
                public var applicationFeePercent: Double?
                /// Automatic_tax_config
                public var automaticTax: AutomaticTax?
                public var billingCycleAnchor: BillingCycleAnchor?
                public var billingThresholds: BillingThresholds?
                public var collectionMethod: CollectionMethod?
                public var defaultPaymentMethod: String?
                /// Subscription_schedules_param
                public var invoiceSettings: InvoiceSettings?
                public var transferData: TransferData?

                /// Automatic_tax_config
                public struct AutomaticTax: Encodable {
                    public var isEnabled: Bool

                    public init(isEnabled: Bool) {
                        self.isEnabled = isEnabled
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isEnabled, forKey: "enabled")
                        return encoder.items
                    }
                }

                public enum BillingCycleAnchor: String, Codable, CaseIterable {
                    case automatic
                    case phaseStart = "phase_start"
                }

                public struct BillingThresholds: Encodable {
                    /// Billing_thresholds_param
                    public var a: A?
                    public var b: B?

                    /// Billing_thresholds_param
                    public struct A: Encodable {
                        public var amountGte: Int?
                        public var isResetBillingCycleAnchor: Bool?

                        public init(amountGte: Int? = nil, isResetBillingCycleAnchor: Bool? = nil) {
                            self.amountGte = amountGte
                            self.isResetBillingCycleAnchor = isResetBillingCycleAnchor
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(amountGte, forKey: "amount_gte")
                            encoder.encode(isResetBillingCycleAnchor, forKey: "reset_billing_cycle_anchor")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public enum CollectionMethod: String, Codable, CaseIterable {
                    case chargeAutomatically = "charge_automatically"
                    case sendInvoice = "send_invoice"
                }

                /// Subscription_schedules_param
                public struct InvoiceSettings: Encodable {
                    public var daysUntilDue: Int?

                    public init(daysUntilDue: Int? = nil) {
                        self.daysUntilDue = daysUntilDue
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(daysUntilDue, forKey: "days_until_due")
                        return encoder.items
                    }
                }

                public struct TransferData: Encodable {
                    /// Transfer_data_specs
                    public var a: A?
                    public var b: B?

                    /// Transfer_data_specs
                    public struct A: Encodable {
                        public var amountPercent: Double?
                        public var destination: String

                        public init(amountPercent: Double? = nil, destination: String) {
                            self.amountPercent = amountPercent
                            self.destination = destination
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(amountPercent, forKey: "amount_percent")
                            encoder.encode(destination, forKey: "destination")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public init(applicationFeePercent: Double? = nil, automaticTax: AutomaticTax? = nil, billingCycleAnchor: BillingCycleAnchor? = nil, billingThresholds: BillingThresholds? = nil, collectionMethod: CollectionMethod? = nil, defaultPaymentMethod: String? = nil, invoiceSettings: InvoiceSettings? = nil, transferData: TransferData? = nil) {
                    self.applicationFeePercent = applicationFeePercent
                    self.automaticTax = automaticTax
                    self.billingCycleAnchor = billingCycleAnchor
                    self.billingThresholds = billingThresholds
                    self.collectionMethod = collectionMethod
                    self.defaultPaymentMethod = defaultPaymentMethod
                    self.invoiceSettings = invoiceSettings
                    self.transferData = transferData
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(applicationFeePercent, forKey: "application_fee_percent")
                    encoder.encode(automaticTax, forKey: "automatic_tax")
                    encoder.encode(billingCycleAnchor, forKey: "billing_cycle_anchor")
                    encoder.encode(billingThresholds, forKey: "billing_thresholds")
                    encoder.encode(collectionMethod, forKey: "collection_method")
                    encoder.encode(defaultPaymentMethod, forKey: "default_payment_method")
                    encoder.encode(invoiceSettings, forKey: "invoice_settings")
                    encoder.encode(transferData, forKey: "transfer_data")
                    return encoder.items
                }
            }

            /// Configures how the subscription schedule behaves when it ends. Possible values are `release` or `cancel` with the default being `release`. `release` will end the subscription schedule and keep the underlying subscription running.`cancel` will end the subscription schedule and cancel the underlying subscription.
            public enum EndBehavior: String, Codable, CaseIterable {
                case cancel
                case `none`
                case release
                case renew
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Phase_configuration_params
            public struct Phase: Encodable {
                public var addInvoiceItems: [AddInvoiceItem]?
                public var applicationFeePercent: Double?
                /// Automatic_tax_config
                public var automaticTax: AutomaticTax?
                public var billingCycleAnchor: BillingCycleAnchor?
                public var billingThresholds: BillingThresholds?
                public var collectionMethod: CollectionMethod?
                public var coupon: String?
                public var defaultPaymentMethod: String?
                public var defaultTaxRates: DefaultTaxRates?
                public var endDate: EndDate?
                /// Subscription_schedules_param
                public var invoiceSettings: InvoiceSettings?
                public var items: [Item]
                public var iterations: Int?
                public var prorationBehavior: ProrationBehavior?
                public var startDate: StartDate?
                /// Transfer_data_specs
                public var transferData: TransferData?
                public var isTrial: Bool?
                public var trialEnd: TrialEnd?

                /// Add_invoice_item_entry
                public struct AddInvoiceItem: Encodable {
                    public var price: String?
                    /// One_time_price_data
                    public var priceData: PriceData?
                    public var quantity: Int?
                    public var taxRates: TaxRates?

                    /// One_time_price_data
                    public struct PriceData: Encodable {
                        public var currency: String
                        public var product: String
                        public var taxBehavior: TaxBehavior?
                        public var unitAmount: Int?
                        public var unitAmountDecimal: String?

                        public enum TaxBehavior: String, Codable, CaseIterable {
                            case exclusive
                            case inclusive
                            case unspecified
                        }

                        public init(currency: String, product: String, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                            self.currency = currency
                            self.product = product
                            self.taxBehavior = taxBehavior
                            self.unitAmount = unitAmount
                            self.unitAmountDecimal = unitAmountDecimal
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(currency, forKey: "currency")
                            encoder.encode(product, forKey: "product")
                            encoder.encode(taxBehavior, forKey: "tax_behavior")
                            encoder.encode(unitAmount, forKey: "unit_amount")
                            encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                            return encoder.items
                        }
                    }

                    public struct TaxRates: Encodable {
                        public var strings: [String]?
                        public var object: Object?

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(strings: [String]? = nil, object: Object? = nil) {
                            self.strings = strings
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(strings, forKey: "strings")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public init(price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                        self.price = price
                        self.priceData = priceData
                        self.quantity = quantity
                        self.taxRates = taxRates
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(price, forKey: "price")
                        encoder.encode(priceData, forKey: "price_data")
                        encoder.encode(quantity, forKey: "quantity")
                        encoder.encode(taxRates, forKey: "tax_rates")
                        return encoder.items
                    }
                }

                /// Automatic_tax_config
                public struct AutomaticTax: Encodable {
                    public var isEnabled: Bool

                    public init(isEnabled: Bool) {
                        self.isEnabled = isEnabled
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isEnabled, forKey: "enabled")
                        return encoder.items
                    }
                }

                public enum BillingCycleAnchor: String, Codable, CaseIterable {
                    case automatic
                    case phaseStart = "phase_start"
                }

                public struct BillingThresholds: Encodable {
                    /// Billing_thresholds_param
                    public var a: A?
                    public var b: B?

                    /// Billing_thresholds_param
                    public struct A: Encodable {
                        public var amountGte: Int?
                        public var isResetBillingCycleAnchor: Bool?

                        public init(amountGte: Int? = nil, isResetBillingCycleAnchor: Bool? = nil) {
                            self.amountGte = amountGte
                            self.isResetBillingCycleAnchor = isResetBillingCycleAnchor
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(amountGte, forKey: "amount_gte")
                            encoder.encode(isResetBillingCycleAnchor, forKey: "reset_billing_cycle_anchor")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public enum CollectionMethod: String, Codable, CaseIterable {
                    case chargeAutomatically = "charge_automatically"
                    case sendInvoice = "send_invoice"
                }

                public struct DefaultTaxRates: Encodable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public struct EndDate: Encodable {
                    public var int: Int?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case now
                    }

                    public init(int: Int? = nil, object: Object? = nil) {
                        self.int = int
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(int, forKey: "int")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                /// Subscription_schedules_param
                public struct InvoiceSettings: Encodable {
                    public var daysUntilDue: Int?

                    public init(daysUntilDue: Int? = nil) {
                        self.daysUntilDue = daysUntilDue
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(daysUntilDue, forKey: "days_until_due")
                        return encoder.items
                    }
                }

                /// Configuration_item_params
                public struct Item: Encodable {
                    public var billingThresholds: BillingThresholds?
                    public var price: String?
                    /// Recurring_price_data
                    public var priceData: PriceData?
                    public var quantity: Int?
                    public var taxRates: TaxRates?

                    public struct BillingThresholds: Encodable {
                        /// Item_billing_thresholds_param
                        public var a: A?
                        public var b: B?

                        /// Item_billing_thresholds_param
                        public struct A: Encodable {
                            public var usageGte: Int

                            public init(usageGte: Int) {
                                self.usageGte = usageGte
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(usageGte, forKey: "usage_gte")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    /// Recurring_price_data
                    public struct PriceData: Encodable {
                        public var currency: String
                        public var product: String
                        /// Recurring_adhoc
                        public var recurring: Recurring
                        public var taxBehavior: TaxBehavior?
                        public var unitAmount: Int?
                        public var unitAmountDecimal: String?

                        /// Recurring_adhoc
                        public struct Recurring: Encodable {
                            public var interval: Interval
                            public var intervalCount: Int?

                            public enum Interval: String, Codable, CaseIterable {
                                case day
                                case month
                                case week
                                case year
                            }

                            public init(interval: Interval, intervalCount: Int? = nil) {
                                self.interval = interval
                                self.intervalCount = intervalCount
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(interval, forKey: "interval")
                                encoder.encode(intervalCount, forKey: "interval_count")
                                return encoder.items
                            }
                        }

                        public enum TaxBehavior: String, Codable, CaseIterable {
                            case exclusive
                            case inclusive
                            case unspecified
                        }

                        public init(currency: String, product: String, recurring: Recurring, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                            self.currency = currency
                            self.product = product
                            self.recurring = recurring
                            self.taxBehavior = taxBehavior
                            self.unitAmount = unitAmount
                            self.unitAmountDecimal = unitAmountDecimal
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(currency, forKey: "currency")
                            encoder.encode(product, forKey: "product")
                            encoder.encode(recurring, forKey: "recurring")
                            encoder.encode(taxBehavior, forKey: "tax_behavior")
                            encoder.encode(unitAmount, forKey: "unit_amount")
                            encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                            return encoder.items
                        }
                    }

                    public struct TaxRates: Encodable {
                        public var strings: [String]?
                        public var object: Object?

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(strings: [String]? = nil, object: Object? = nil) {
                            self.strings = strings
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(strings, forKey: "strings")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public init(billingThresholds: BillingThresholds? = nil, price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                        self.billingThresholds = billingThresholds
                        self.price = price
                        self.priceData = priceData
                        self.quantity = quantity
                        self.taxRates = taxRates
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(billingThresholds, forKey: "billing_thresholds")
                        encoder.encode(price, forKey: "price")
                        encoder.encode(priceData, forKey: "price_data")
                        encoder.encode(quantity, forKey: "quantity")
                        encoder.encode(taxRates, forKey: "tax_rates")
                        return encoder.items
                    }
                }

                public enum ProrationBehavior: String, Codable, CaseIterable {
                    case alwaysInvoice = "always_invoice"
                    case createProrations = "create_prorations"
                    case `none`
                }

                public struct StartDate: Encodable {
                    public var int: Int?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case now
                    }

                    public init(int: Int? = nil, object: Object? = nil) {
                        self.int = int
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(int, forKey: "int")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                /// Transfer_data_specs
                public struct TransferData: Encodable {
                    public var amountPercent: Double?
                    public var destination: String

                    public init(amountPercent: Double? = nil, destination: String) {
                        self.amountPercent = amountPercent
                        self.destination = destination
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amountPercent, forKey: "amount_percent")
                        encoder.encode(destination, forKey: "destination")
                        return encoder.items
                    }
                }

                public struct TrialEnd: Encodable {
                    public var int: Int?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case now
                    }

                    public init(int: Int? = nil, object: Object? = nil) {
                        self.int = int
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(int, forKey: "int")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(addInvoiceItems: [AddInvoiceItem]? = nil, applicationFeePercent: Double? = nil, automaticTax: AutomaticTax? = nil, billingCycleAnchor: BillingCycleAnchor? = nil, billingThresholds: BillingThresholds? = nil, collectionMethod: CollectionMethod? = nil, coupon: String? = nil, defaultPaymentMethod: String? = nil, defaultTaxRates: DefaultTaxRates? = nil, endDate: EndDate? = nil, invoiceSettings: InvoiceSettings? = nil, items: [Item], iterations: Int? = nil, prorationBehavior: ProrationBehavior? = nil, startDate: StartDate? = nil, transferData: TransferData? = nil, isTrial: Bool? = nil, trialEnd: TrialEnd? = nil) {
                    self.addInvoiceItems = addInvoiceItems
                    self.applicationFeePercent = applicationFeePercent
                    self.automaticTax = automaticTax
                    self.billingCycleAnchor = billingCycleAnchor
                    self.billingThresholds = billingThresholds
                    self.collectionMethod = collectionMethod
                    self.coupon = coupon
                    self.defaultPaymentMethod = defaultPaymentMethod
                    self.defaultTaxRates = defaultTaxRates
                    self.endDate = endDate
                    self.invoiceSettings = invoiceSettings
                    self.items = items
                    self.iterations = iterations
                    self.prorationBehavior = prorationBehavior
                    self.startDate = startDate
                    self.transferData = transferData
                    self.isTrial = isTrial
                    self.trialEnd = trialEnd
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(addInvoiceItems, forKey: "add_invoice_items")
                    encoder.encode(applicationFeePercent, forKey: "application_fee_percent")
                    encoder.encode(automaticTax, forKey: "automatic_tax")
                    encoder.encode(billingCycleAnchor, forKey: "billing_cycle_anchor")
                    encoder.encode(billingThresholds, forKey: "billing_thresholds")
                    encoder.encode(collectionMethod, forKey: "collection_method")
                    encoder.encode(coupon, forKey: "coupon")
                    encoder.encode(defaultPaymentMethod, forKey: "default_payment_method")
                    encoder.encode(defaultTaxRates, forKey: "default_tax_rates")
                    encoder.encode(endDate, forKey: "end_date")
                    encoder.encode(invoiceSettings, forKey: "invoice_settings")
                    encoder.encode(items, forKey: "items")
                    encoder.encode(iterations, forKey: "iterations")
                    encoder.encode(prorationBehavior, forKey: "proration_behavior")
                    encoder.encode(startDate, forKey: "start_date")
                    encoder.encode(transferData, forKey: "transfer_data")
                    encoder.encode(isTrial, forKey: "trial")
                    encoder.encode(trialEnd, forKey: "trial_end")
                    return encoder.items
                }
            }

            /// If the update changes the current phase, indicates if the changes should be prorated. Possible values are `create_prorations` or `none`, and the default value is `create_prorations`.
            public enum ProrationBehavior: String, Codable, CaseIterable {
                case alwaysInvoice = "always_invoice"
                case createProrations = "create_prorations"
                case `none`
            }

            public init(defaultSettings: DefaultSettings? = nil, endBehavior: EndBehavior? = nil, expand: [String]? = nil, metadata: Metadata? = nil, phases: [Phase]? = nil, prorationBehavior: ProrationBehavior? = nil) {
                self.defaultSettings = defaultSettings
                self.endBehavior = endBehavior
                self.expand = expand
                self.metadata = metadata
                self.phases = phases
                self.prorationBehavior = prorationBehavior
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(defaultSettings, forKey: "default_settings")
                encoder.encode(endBehavior, forKey: "end_behavior")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(phases, forKey: "phases")
                encoder.encode(prorationBehavior, forKey: "proration_behavior")
                return encoder.items
            }
        }
    }
}

extension Paths.SubscriptionSchedules.WithSchedule {
    public var cancel: Cancel {
        Cancel(path: path + "/cancel")
    }

    public struct Cancel {
        /// Path: `/v1/subscription_schedules/{schedule}/cancel`
        public let path: String

        /// <p>Cancels a subscription schedule and its associated subscription immediately (if the subscription schedule has an active subscription). A subscription schedule can only be canceled if its status is <code>not_started</code> or <code>active</code>.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.SubscriptionSchedule> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// If the subscription schedule is `active`, indicates if a final invoice will be generated that contains any un-invoiced metered usage and new/pending proration invoice items. Defaults to `true`.
            public var isInvoiceNow: Bool?
            /// If the subscription schedule is `active`, indicates if the cancellation should be prorated. Defaults to `true`.
            public var isProrate: Bool?

            public init(expand: [String]? = nil, isInvoiceNow: Bool? = nil, isProrate: Bool? = nil) {
                self.expand = expand
                self.isInvoiceNow = isInvoiceNow
                self.isProrate = isProrate
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(isInvoiceNow, forKey: "invoice_now")
                encoder.encode(isProrate, forKey: "prorate")
                return encoder.items
            }
        }
    }
}

extension Paths.SubscriptionSchedules.WithSchedule {
    public var release: Release {
        Release(path: path + "/release")
    }

    public struct Release {
        /// Path: `/v1/subscription_schedules/{schedule}/release`
        public let path: String

        /// <p>Releases the subscription schedule immediately, which will stop scheduling of its phases, but leave any existing subscription in place. A schedule can only be released if its status is <code>not_started</code> or <code>active</code>. If the subscription schedule is currently associated with a subscription, releasing it will remove its <code>subscription</code> property and set the subscription’s ID to the <code>released_subscription</code> property.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.SubscriptionSchedule> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Keep any cancellation on the subscription that the schedule has set
            public var isPreserveCancelDate: Bool?

            public init(expand: [String]? = nil, isPreserveCancelDate: Bool? = nil) {
                self.expand = expand
                self.isPreserveCancelDate = isPreserveCancelDate
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(isPreserveCancelDate, forKey: "preserve_cancel_date")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var subscriptions: Subscriptions {
        Subscriptions(path: "/v1/subscriptions")
    }

    public struct Subscriptions {
        /// Path: `/v1/subscriptions`
        public let path: String

        /// <p>By default, returns a list of subscriptions that have not been canceled. In order to list canceled subscriptions, specify <code>status=canceled</code>.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Subscription]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Subscription], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var collectionMethod: CollectionMethod?
            public var created: Created?
            public var currentPeriodEnd: CurrentPeriodEnd?
            public var currentPeriodStart: CurrentPeriodStart?
            public var customer: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var price: String?
            public var startingAfter: String?
            public var status: Status?

            public enum CollectionMethod: String, Codable, CaseIterable {
                case chargeAutomatically = "charge_automatically"
                case sendInvoice = "send_invoice"
            }

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public struct CurrentPeriodEnd: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public struct CurrentPeriodStart: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public enum Status: String, Codable, CaseIterable {
                case active
                case all
                case canceled
                case ended
                case incomplete
                case incompleteExpired = "incomplete_expired"
                case pastDue = "past_due"
                case trialing
                case unpaid
            }

            public init(collectionMethod: CollectionMethod? = nil, created: Created? = nil, currentPeriodEnd: CurrentPeriodEnd? = nil, currentPeriodStart: CurrentPeriodStart? = nil, customer: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, price: String? = nil, startingAfter: String? = nil, status: Status? = nil) {
                self.collectionMethod = collectionMethod
                self.created = created
                self.currentPeriodEnd = currentPeriodEnd
                self.currentPeriodStart = currentPeriodStart
                self.customer = customer
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.price = price
                self.startingAfter = startingAfter
                self.status = status
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(collectionMethod, forKey: "collection_method")
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(currentPeriodEnd, forKey: "current_period_end", isDeepObject: true)
                encoder.encode(currentPeriodStart, forKey: "current_period_start", isDeepObject: true)
                encoder.encode(customer, forKey: "customer")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(price, forKey: "price")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(status, forKey: "status")
                return encoder.items
            }
        }

        /// <p>Creates a new subscription on an existing customer. Each customer can have up to 500 active or scheduled subscriptions.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.Subscription> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// A list of prices and quantities that will generate invoice items appended to the first invoice for this subscription. You may pass up to 20 items.
            public var addInvoiceItems: [AddInvoiceItem]?
            /// A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. The request must be made by a platform account on a connected account in order to set an application fee percentage. For more information, see the application fees [documentation](https://stripe.com/docs/connect/subscriptions#collecting-fees-on-subscriptions).
            public var applicationFeePercent: Double?
            /// Automatic_tax_config
            ///
            /// Automatic tax settings for this subscription.
            public var automaticTax: AutomaticTax?
            /// For new subscriptions, a past timestamp to backdate the subscription's start date to. If set, the first invoice will contain a proration for the timespan between the start date and the current time. Can be combined with trials and the billing cycle anchor.
            public var backdateStartDate: Int?
            /// A future timestamp to anchor the subscription's [billing cycle](https://stripe.com/docs/subscriptions/billing-cycle). This is used to determine the date of the first full invoice, and, for plans with `month` or `year` intervals, the day of the month for subsequent invoices.
            public var billingCycleAnchor: Int?
            /// Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period. Pass an empty string to remove previously-defined thresholds.
            public var billingThresholds: BillingThresholds?
            /// A timestamp at which the subscription should cancel. If set to a date before the current period ends, this will cause a proration if prorations have been enabled using `proration_behavior`. If set during a future period, this will always cause a proration for that period.
            public var cancelAt: Int?
            /// Boolean indicating whether this subscription should cancel at the end of the current period.
            public var isCancelAtPeriodEnd: Bool?
            /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
            public var collectionMethod: CollectionMethod?
            /// The ID of the coupon to apply to this subscription. A coupon applied to a subscription will only affect invoices created for that particular subscription.
            public var coupon: String?
            /// The identifier of the customer to subscribe.
            public var customer: String
            /// Number of days a customer has to pay invoices generated by this subscription. Valid only for subscriptions where `collection_method` is set to `send_invoice`.
            public var daysUntilDue: Int?
            /// ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over `default_source`. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
            public var defaultPaymentMethod: String?
            /// ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If `default_payment_method` is also set, `default_payment_method` will take precedence. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
            public var defaultSource: String?
            /// The tax rates that will apply to any subscription item that does not have `tax_rates` set. Invoices created will have their `default_tax_rates` populated from the subscription.
            public var defaultTaxRates: DefaultTaxRates?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// A list of up to 20 subscription items, each with an attached price.
            public var items: [Item]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// Indicates if a customer is on or off-session while an invoice payment is attempted.
            public var isOffSession: Bool?
            /// Use `allow_incomplete` to create subscriptions with `status=incomplete` if the first invoice cannot be paid. Creating subscriptions with this status allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.
            /// 
            /// Use `default_incomplete` to create Subscriptions with `status=incomplete` when the first invoice requires payment, otherwise start as active. Subscriptions transition to `status=active` when successfully confirming the payment intent on the first invoice. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method. If the payment intent is not confirmed within 23 hours subscriptions transition to `status=incomplete_expired`, which is a terminal state.
            /// 
            /// Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's first invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not create a subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
            /// 
            /// `pending_if_incomplete` is only used with updates and cannot be passed when creating a subscription.
            public var paymentBehavior: PaymentBehavior?
            /// Payment_settings
            ///
            /// Payment settings to pass to invoices created by the subscription.
            public var paymentSettings: PaymentSettings?
            /// Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling [Create an invoice](https://stripe.com/docs/api#create_invoice) for the given subscription at the specified interval.
            public var pendingInvoiceItemInterval: PendingInvoiceItemInterval?
            /// The API ID of a promotion code to apply to this subscription. A promotion code applied to a subscription will only affect invoices created for that particular subscription.
            public var promotionCode: String?
            /// Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) resulting from the `billing_cycle_anchor`. Valid values are `create_prorations` or `none`.
            /// 
            /// Passing `create_prorations` will cause proration invoice items to be created when applicable. Prorations can be disabled by passing `none`. If no value is passed, the default is `create_prorations`.
            public var prorationBehavior: ProrationBehavior?
            /// Transfer_data_specs
            ///
            /// If specified, the funds from the subscription's invoices will be transferred to the destination and the ID of the resulting transfers will be found on the resulting charges.
            public var transferData: TransferData?
            /// Unix timestamp representing the end of the trial period the customer will get before being charged for the first time. This will always overwrite any trials that might apply via a subscribed plan. If set, trial_end will override the default trial period of the plan the customer is being subscribed to. The special value `now` can be provided to end the customer's trial immediately. Can be at most two years from `billing_cycle_anchor`. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
            public var trialEnd: TrialEnd?
            /// Indicates if a plan's `trial_period_days` should be applied to the subscription. Setting `trial_end` per subscription is preferred, and this defaults to `false`. Setting this flag to `true` together with `trial_end` is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
            public var isTrialFromPlan: Bool?
            /// Integer representing the number of trial period days before the customer is charged for the first time. This will always overwrite any trials that might apply via a subscribed plan. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
            public var trialPeriodDays: Int?

            /// Add_invoice_item_entry
            public struct AddInvoiceItem: Encodable {
                public var price: String?
                /// One_time_price_data
                public var priceData: PriceData?
                public var quantity: Int?
                public var taxRates: TaxRates?

                /// One_time_price_data
                public struct PriceData: Encodable {
                    public var currency: String
                    public var product: String
                    public var taxBehavior: TaxBehavior?
                    public var unitAmount: Int?
                    public var unitAmountDecimal: String?

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public init(currency: String, product: String, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                        self.currency = currency
                        self.product = product
                        self.taxBehavior = taxBehavior
                        self.unitAmount = unitAmount
                        self.unitAmountDecimal = unitAmountDecimal
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(product, forKey: "product")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(unitAmount, forKey: "unit_amount")
                        encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                        return encoder.items
                    }
                }

                public struct TaxRates: Encodable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                    self.price = price
                    self.priceData = priceData
                    self.quantity = quantity
                    self.taxRates = taxRates
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(price, forKey: "price")
                    encoder.encode(priceData, forKey: "price_data")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    return encoder.items
                }
            }

            /// Automatic_tax_config
            ///
            /// Automatic tax settings for this subscription.
            public struct AutomaticTax: Encodable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period. Pass an empty string to remove previously-defined thresholds.
            public struct BillingThresholds: Encodable {
                /// Billing_thresholds_param
                public var a: A?
                public var b: B?

                /// Billing_thresholds_param
                public struct A: Encodable {
                    public var amountGte: Int?
                    public var isResetBillingCycleAnchor: Bool?

                    public init(amountGte: Int? = nil, isResetBillingCycleAnchor: Bool? = nil) {
                        self.amountGte = amountGte
                        self.isResetBillingCycleAnchor = isResetBillingCycleAnchor
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amountGte, forKey: "amount_gte")
                        encoder.encode(isResetBillingCycleAnchor, forKey: "reset_billing_cycle_anchor")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
            public enum CollectionMethod: String, Codable, CaseIterable {
                case chargeAutomatically = "charge_automatically"
                case sendInvoice = "send_invoice"
            }

            /// The tax rates that will apply to any subscription item that does not have `tax_rates` set. Invoices created will have their `default_tax_rates` populated from the subscription.
            public struct DefaultTaxRates: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Subscription_item_create_params
            public struct Item: Encodable {
                public var billingThresholds: BillingThresholds?
                public var metadata: [String: String]?
                public var price: String?
                /// Recurring_price_data
                public var priceData: PriceData?
                public var quantity: Int?
                public var taxRates: TaxRates?

                public struct BillingThresholds: Encodable {
                    /// Item_billing_thresholds_param
                    public var a: A?
                    public var b: B?

                    /// Item_billing_thresholds_param
                    public struct A: Encodable {
                        public var usageGte: Int

                        public init(usageGte: Int) {
                            self.usageGte = usageGte
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(usageGte, forKey: "usage_gte")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                /// Recurring_price_data
                public struct PriceData: Encodable {
                    public var currency: String
                    public var product: String
                    /// Recurring_adhoc
                    public var recurring: Recurring
                    public var taxBehavior: TaxBehavior?
                    public var unitAmount: Int?
                    public var unitAmountDecimal: String?

                    /// Recurring_adhoc
                    public struct Recurring: Encodable {
                        public var interval: Interval
                        public var intervalCount: Int?

                        public enum Interval: String, Codable, CaseIterable {
                            case day
                            case month
                            case week
                            case year
                        }

                        public init(interval: Interval, intervalCount: Int? = nil) {
                            self.interval = interval
                            self.intervalCount = intervalCount
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(interval, forKey: "interval")
                            encoder.encode(intervalCount, forKey: "interval_count")
                            return encoder.items
                        }
                    }

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public init(currency: String, product: String, recurring: Recurring, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                        self.currency = currency
                        self.product = product
                        self.recurring = recurring
                        self.taxBehavior = taxBehavior
                        self.unitAmount = unitAmount
                        self.unitAmountDecimal = unitAmountDecimal
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(product, forKey: "product")
                        encoder.encode(recurring, forKey: "recurring")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(unitAmount, forKey: "unit_amount")
                        encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                        return encoder.items
                    }
                }

                public struct TaxRates: Encodable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(billingThresholds: BillingThresholds? = nil, metadata: [String: String]? = nil, price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                    self.billingThresholds = billingThresholds
                    self.metadata = metadata
                    self.price = price
                    self.priceData = priceData
                    self.quantity = quantity
                    self.taxRates = taxRates
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(billingThresholds, forKey: "billing_thresholds")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(price, forKey: "price")
                    encoder.encode(priceData, forKey: "price_data")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Use `allow_incomplete` to create subscriptions with `status=incomplete` if the first invoice cannot be paid. Creating subscriptions with this status allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.
            /// 
            /// Use `default_incomplete` to create Subscriptions with `status=incomplete` when the first invoice requires payment, otherwise start as active. Subscriptions transition to `status=active` when successfully confirming the payment intent on the first invoice. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method. If the payment intent is not confirmed within 23 hours subscriptions transition to `status=incomplete_expired`, which is a terminal state.
            /// 
            /// Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's first invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not create a subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
            /// 
            /// `pending_if_incomplete` is only used with updates and cannot be passed when creating a subscription.
            public enum PaymentBehavior: String, Codable, CaseIterable {
                case allowIncomplete = "allow_incomplete"
                case defaultIncomplete = "default_incomplete"
                case errorIfIncomplete = "error_if_incomplete"
                case pendingIfIncomplete = "pending_if_incomplete"
            }

            /// Payment_settings
            ///
            /// Payment settings to pass to invoices created by the subscription.
            public struct PaymentSettings: Encodable {
                /// Payment_method_options
                public var paymentMethodOptions: PaymentMethodOptions?
                public var paymentMethodTypes: PaymentMethodTypes?

                /// Payment_method_options
                public struct PaymentMethodOptions: Encodable {
                    public var acssDebit: AcssDebit?
                    public var bancontact: Bancontact?
                    public var card: Card?

                    public struct AcssDebit: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            /// Mandate_options_param
                            public var mandateOptions: MandateOptions?
                            public var verificationMethod: VerificationMethod?

                            /// Mandate_options_param
                            public struct MandateOptions: Encodable {
                                public var transactionType: TransactionType?

                                public enum TransactionType: String, Codable, CaseIterable {
                                    case business
                                    case personal
                                }

                                public init(transactionType: TransactionType? = nil) {
                                    self.transactionType = transactionType
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(transactionType, forKey: "transaction_type")
                                    return encoder.items
                                }
                            }

                            public enum VerificationMethod: String, Codable, CaseIterable {
                                case automatic
                                case instant
                                case microdeposits
                            }

                            public init(mandateOptions: MandateOptions? = nil, verificationMethod: VerificationMethod? = nil) {
                                self.mandateOptions = mandateOptions
                                self.verificationMethod = verificationMethod
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(mandateOptions, forKey: "mandate_options")
                                encoder.encode(verificationMethod, forKey: "verification_method")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct Bancontact: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            public var preferredLanguage: PreferredLanguage?

                            public enum PreferredLanguage: String, Codable, CaseIterable {
                                case de
                                case en
                                case fr
                                case nl
                            }

                            public init(preferredLanguage: PreferredLanguage? = nil) {
                                self.preferredLanguage = preferredLanguage
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(preferredLanguage, forKey: "preferred_language")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct Card: Encodable {
                        /// Subscription_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Subscription_payment_method_options_param
                        public struct A: Encodable {
                            public var requestThreeDSecure: RequestThreeDSecure?

                            public enum RequestThreeDSecure: String, Codable, CaseIterable {
                                case any
                                case automatic
                            }

                            public init(requestThreeDSecure: RequestThreeDSecure? = nil) {
                                self.requestThreeDSecure = requestThreeDSecure
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(requestThreeDSecure, forKey: "request_three_d_secure")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public init(acssDebit: AcssDebit? = nil, bancontact: Bancontact? = nil, card: Card? = nil) {
                        self.acssDebit = acssDebit
                        self.bancontact = bancontact
                        self.card = card
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(acssDebit, forKey: "acss_debit")
                        encoder.encode(bancontact, forKey: "bancontact")
                        encoder.encode(card, forKey: "card")
                        return encoder.items
                    }
                }

                public struct PaymentMethodTypes: Encodable {
                    public var placeholderItems: [PlaceholderItem]?
                    public var object: Object?

                    public enum PlaceholderItem: String, Codable, CaseIterable {
                        case achCreditTransfer = "ach_credit_transfer"
                        case achDebit = "ach_debit"
                        case acssDebit = "acss_debit"
                        case auBecsDebit = "au_becs_debit"
                        case bacsDebit = "bacs_debit"
                        case bancontact
                        case boleto
                        case card
                        case fpx
                        case giropay
                        case ideal
                        case sepaDebit = "sepa_debit"
                        case sofort
                        case wechatPay = "wechat_pay"
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                        self.placeholderItems = placeholderItems
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(placeholderItems, forKey: "placeholderItems")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(paymentMethodOptions: PaymentMethodOptions? = nil, paymentMethodTypes: PaymentMethodTypes? = nil) {
                    self.paymentMethodOptions = paymentMethodOptions
                    self.paymentMethodTypes = paymentMethodTypes
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(paymentMethodOptions, forKey: "payment_method_options")
                    encoder.encode(paymentMethodTypes, forKey: "payment_method_types")
                    return encoder.items
                }
            }

            /// Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling [Create an invoice](https://stripe.com/docs/api#create_invoice) for the given subscription at the specified interval.
            public struct PendingInvoiceItemInterval: Encodable {
                /// Pending_invoice_item_interval_params
                public var a: A?
                public var b: B?

                /// Pending_invoice_item_interval_params
                public struct A: Encodable {
                    public var interval: Interval
                    public var intervalCount: Int?

                    public enum Interval: String, Codable, CaseIterable {
                        case day
                        case month
                        case week
                        case year
                    }

                    public init(interval: Interval, intervalCount: Int? = nil) {
                        self.interval = interval
                        self.intervalCount = intervalCount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(interval, forKey: "interval")
                        encoder.encode(intervalCount, forKey: "interval_count")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) resulting from the `billing_cycle_anchor`. Valid values are `create_prorations` or `none`.
            /// 
            /// Passing `create_prorations` will cause proration invoice items to be created when applicable. Prorations can be disabled by passing `none`. If no value is passed, the default is `create_prorations`.
            public enum ProrationBehavior: String, Codable, CaseIterable {
                case alwaysInvoice = "always_invoice"
                case createProrations = "create_prorations"
                case `none`
            }

            /// Transfer_data_specs
            ///
            /// If specified, the funds from the subscription's invoices will be transferred to the destination and the ID of the resulting transfers will be found on the resulting charges.
            public struct TransferData: Encodable {
                public var amountPercent: Double?
                public var destination: String

                public init(amountPercent: Double? = nil, destination: String) {
                    self.amountPercent = amountPercent
                    self.destination = destination
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(amountPercent, forKey: "amount_percent")
                    encoder.encode(destination, forKey: "destination")
                    return encoder.items
                }
            }

            /// Unix timestamp representing the end of the trial period the customer will get before being charged for the first time. This will always overwrite any trials that might apply via a subscribed plan. If set, trial_end will override the default trial period of the plan the customer is being subscribed to. The special value `now` can be provided to end the customer's trial immediately. Can be at most two years from `billing_cycle_anchor`. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
            public struct TrialEnd: Encodable {
                public var object: Object?
                public var int: Int?

                public enum Object: String, Codable, CaseIterable {
                    case now
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(addInvoiceItems: [AddInvoiceItem]? = nil, applicationFeePercent: Double? = nil, automaticTax: AutomaticTax? = nil, backdateStartDate: Int? = nil, billingCycleAnchor: Int? = nil, billingThresholds: BillingThresholds? = nil, cancelAt: Int? = nil, isCancelAtPeriodEnd: Bool? = nil, collectionMethod: CollectionMethod? = nil, coupon: String? = nil, customer: String, daysUntilDue: Int? = nil, defaultPaymentMethod: String? = nil, defaultSource: String? = nil, defaultTaxRates: DefaultTaxRates? = nil, expand: [String]? = nil, items: [Item]? = nil, metadata: Metadata? = nil, isOffSession: Bool? = nil, paymentBehavior: PaymentBehavior? = nil, paymentSettings: PaymentSettings? = nil, pendingInvoiceItemInterval: PendingInvoiceItemInterval? = nil, promotionCode: String? = nil, prorationBehavior: ProrationBehavior? = nil, transferData: TransferData? = nil, trialEnd: TrialEnd? = nil, isTrialFromPlan: Bool? = nil, trialPeriodDays: Int? = nil) {
                self.addInvoiceItems = addInvoiceItems
                self.applicationFeePercent = applicationFeePercent
                self.automaticTax = automaticTax
                self.backdateStartDate = backdateStartDate
                self.billingCycleAnchor = billingCycleAnchor
                self.billingThresholds = billingThresholds
                self.cancelAt = cancelAt
                self.isCancelAtPeriodEnd = isCancelAtPeriodEnd
                self.collectionMethod = collectionMethod
                self.coupon = coupon
                self.customer = customer
                self.daysUntilDue = daysUntilDue
                self.defaultPaymentMethod = defaultPaymentMethod
                self.defaultSource = defaultSource
                self.defaultTaxRates = defaultTaxRates
                self.expand = expand
                self.items = items
                self.metadata = metadata
                self.isOffSession = isOffSession
                self.paymentBehavior = paymentBehavior
                self.paymentSettings = paymentSettings
                self.pendingInvoiceItemInterval = pendingInvoiceItemInterval
                self.promotionCode = promotionCode
                self.prorationBehavior = prorationBehavior
                self.transferData = transferData
                self.trialEnd = trialEnd
                self.isTrialFromPlan = isTrialFromPlan
                self.trialPeriodDays = trialPeriodDays
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(addInvoiceItems, forKey: "add_invoice_items")
                encoder.encode(applicationFeePercent, forKey: "application_fee_percent")
                encoder.encode(automaticTax, forKey: "automatic_tax")
                encoder.encode(backdateStartDate, forKey: "backdate_start_date")
                encoder.encode(billingCycleAnchor, forKey: "billing_cycle_anchor")
                encoder.encode(billingThresholds, forKey: "billing_thresholds")
                encoder.encode(cancelAt, forKey: "cancel_at")
                encoder.encode(isCancelAtPeriodEnd, forKey: "cancel_at_period_end")
                encoder.encode(collectionMethod, forKey: "collection_method")
                encoder.encode(coupon, forKey: "coupon")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(daysUntilDue, forKey: "days_until_due")
                encoder.encode(defaultPaymentMethod, forKey: "default_payment_method")
                encoder.encode(defaultSource, forKey: "default_source")
                encoder.encode(defaultTaxRates, forKey: "default_tax_rates")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(items, forKey: "items")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(isOffSession, forKey: "off_session")
                encoder.encode(paymentBehavior, forKey: "payment_behavior")
                encoder.encode(paymentSettings, forKey: "payment_settings")
                encoder.encode(pendingInvoiceItemInterval, forKey: "pending_invoice_item_interval")
                encoder.encode(promotionCode, forKey: "promotion_code")
                encoder.encode(prorationBehavior, forKey: "proration_behavior")
                encoder.encode(transferData, forKey: "transfer_data")
                encoder.encode(trialEnd, forKey: "trial_end")
                encoder.encode(isTrialFromPlan, forKey: "trial_from_plan")
                encoder.encode(trialPeriodDays, forKey: "trial_period_days")
                return encoder.items
            }
        }
    }
}

extension Paths.Subscriptions {
    public func subscriptionExposedID(_ subscriptionExposedID: String) -> WithSubscriptionExposedID {
        WithSubscriptionExposedID(path: "\(path)/\(subscriptionExposedID)")
    }

    public struct WithSubscriptionExposedID {
        /// Path: `/v1/subscriptions/{subscription_exposed_id}`
        public let path: String

        /// <p>Retrieves the subscription with the given ID.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Subscription> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates an existing subscription on a customer to match the specified parameters. When changing plans or quantities, we will optionally prorate the price we charge next month to make up for any price changes. To preview how the proration will be calculated, use the <a href="#upcoming_invoice">upcoming invoice</a> endpoint.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Subscription> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// A list of prices and quantities that will generate invoice items appended to the first invoice for this subscription. You may pass up to 20 items.
            public var addInvoiceItems: [AddInvoiceItem]?
            /// A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner's Stripe account. The request must be made by a platform account on a connected account in order to set an application fee percentage. For more information, see the application fees [documentation](https://stripe.com/docs/connect/subscriptions#collecting-fees-on-subscriptions).
            public var applicationFeePercent: Double?
            /// Automatic_tax_config
            ///
            /// Automatic tax settings for this subscription.
            public var automaticTax: AutomaticTax?
            /// Either `now` or `unchanged`. Setting the value to `now` resets the subscription's billing cycle anchor to the current time. For more information, see the billing cycle [documentation](https://stripe.com/docs/billing/subscriptions/billing-cycle).
            public var billingCycleAnchor: BillingCycleAnchor?
            /// Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period. Pass an empty string to remove previously-defined thresholds.
            public var billingThresholds: BillingThresholds?
            /// A timestamp at which the subscription should cancel. If set to a date before the current period ends, this will cause a proration if prorations have been enabled using `proration_behavior`. If set during a future period, this will always cause a proration for that period.
            public var cancelAt: CancelAt?
            /// Boolean indicating whether this subscription should cancel at the end of the current period.
            public var isCancelAtPeriodEnd: Bool?
            /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
            public var collectionMethod: CollectionMethod?
            /// The ID of the coupon to apply to this subscription. A coupon applied to a subscription will only affect invoices created for that particular subscription.
            public var coupon: String?
            /// Number of days a customer has to pay invoices generated by this subscription. Valid only for subscriptions where `collection_method` is set to `send_invoice`.
            public var daysUntilDue: Int?
            /// ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over `default_source`. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
            public var defaultPaymentMethod: String?
            /// ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If `default_payment_method` is also set, `default_payment_method` will take precedence. If neither are set, invoices will use the customer's [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
            public var defaultSource: String?
            /// The tax rates that will apply to any subscription item that does not have `tax_rates` set. Invoices created will have their `default_tax_rates` populated from the subscription. Pass an empty string to remove previously-defined tax rates.
            public var defaultTaxRates: DefaultTaxRates?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// A list of up to 20 subscription items, each with an attached price.
            public var items: [Item]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// Indicates if a customer is on or off-session while an invoice payment is attempted.
            public var isOffSession: Bool?
            /// If specified, payment collection for this subscription will be paused.
            public var pauseCollection: PauseCollection?
            /// Use `allow_incomplete` to transition the subscription to `status=past_due` if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.
            /// 
            /// Use `default_incomplete` to transition the subscription to `status=past_due` when payment is required and await explicit confirmation of the invoice's payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.
            /// 
            /// Use `pending_if_incomplete` to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use `pending_if_incomplete` you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).
            /// 
            /// Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
            public var paymentBehavior: PaymentBehavior?
            /// Payment_settings
            ///
            /// Payment settings to pass to invoices created by the subscription.
            public var paymentSettings: PaymentSettings?
            /// Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling [Create an invoice](https://stripe.com/docs/api#create_invoice) for the given subscription at the specified interval.
            public var pendingInvoiceItemInterval: PendingInvoiceItemInterval?
            /// The promotion code to apply to this subscription. A promotion code applied to a subscription will only affect invoices created for that particular subscription.
            public var promotionCode: String?
            /// Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes. Valid values are `create_prorations`, `none`, or `always_invoice`.
            /// 
            /// Passing `create_prorations` will cause proration invoice items to be created when applicable. These proration items will only be invoiced immediately under [certain conditions](https://stripe.com/docs/subscriptions/upgrading-downgrading#immediate-payment). In order to always invoice immediately for prorations, pass `always_invoice`.
            /// 
            /// Prorations can be disabled by passing `none`.
            public var prorationBehavior: ProrationBehavior?
            /// If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply exactly the same proration that was previewed with [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint. It can also be used to implement custom proration logic, such as prorating by day instead of by second, by providing the time that you wish to use for proration calculations.
            public var prorationDate: Int?
            /// If specified, the funds from the subscription's invoices will be transferred to the destination and the ID of the resulting transfers will be found on the resulting charges. This will be unset if you POST an empty value.
            public var transferData: TransferData?
            /// Unix timestamp representing the end of the trial period the customer will get before being charged for the first time. This will always overwrite any trials that might apply via a subscribed plan. If set, trial_end will override the default trial period of the plan the customer is being subscribed to. The special value `now` can be provided to end the customer's trial immediately. Can be at most two years from `billing_cycle_anchor`.
            public var trialEnd: TrialEnd?
            /// Indicates if a plan's `trial_period_days` should be applied to the subscription. Setting `trial_end` per subscription is preferred, and this defaults to `false`. Setting this flag to `true` together with `trial_end` is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
            public var isTrialFromPlan: Bool?

            /// Add_invoice_item_entry
            public struct AddInvoiceItem: Encodable {
                public var price: String?
                /// One_time_price_data
                public var priceData: PriceData?
                public var quantity: Int?
                public var taxRates: TaxRates?

                /// One_time_price_data
                public struct PriceData: Encodable {
                    public var currency: String
                    public var product: String
                    public var taxBehavior: TaxBehavior?
                    public var unitAmount: Int?
                    public var unitAmountDecimal: String?

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public init(currency: String, product: String, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                        self.currency = currency
                        self.product = product
                        self.taxBehavior = taxBehavior
                        self.unitAmount = unitAmount
                        self.unitAmountDecimal = unitAmountDecimal
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(product, forKey: "product")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(unitAmount, forKey: "unit_amount")
                        encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                        return encoder.items
                    }
                }

                public struct TaxRates: Encodable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                    self.price = price
                    self.priceData = priceData
                    self.quantity = quantity
                    self.taxRates = taxRates
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(price, forKey: "price")
                    encoder.encode(priceData, forKey: "price_data")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    return encoder.items
                }
            }

            /// Automatic_tax_config
            ///
            /// Automatic tax settings for this subscription.
            public struct AutomaticTax: Encodable {
                public var isEnabled: Bool

                public init(isEnabled: Bool) {
                    self.isEnabled = isEnabled
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(isEnabled, forKey: "enabled")
                    return encoder.items
                }
            }

            /// Either `now` or `unchanged`. Setting the value to `now` resets the subscription's billing cycle anchor to the current time. For more information, see the billing cycle [documentation](https://stripe.com/docs/billing/subscriptions/billing-cycle).
            public enum BillingCycleAnchor: String, Codable, CaseIterable {
                case now
                case unchanged
            }

            /// Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period. Pass an empty string to remove previously-defined thresholds.
            public struct BillingThresholds: Encodable {
                /// Billing_thresholds_param
                public var a: A?
                public var b: B?

                /// Billing_thresholds_param
                public struct A: Encodable {
                    public var amountGte: Int?
                    public var isResetBillingCycleAnchor: Bool?

                    public init(amountGte: Int? = nil, isResetBillingCycleAnchor: Bool? = nil) {
                        self.amountGte = amountGte
                        self.isResetBillingCycleAnchor = isResetBillingCycleAnchor
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amountGte, forKey: "amount_gte")
                        encoder.encode(isResetBillingCycleAnchor, forKey: "reset_billing_cycle_anchor")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// A timestamp at which the subscription should cancel. If set to a date before the current period ends, this will cause a proration if prorations have been enabled using `proration_behavior`. If set during a future period, this will always cause a proration for that period.
            public struct CancelAt: Encodable {
                public var int: Int?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(int: Int? = nil, object: Object? = nil) {
                    self.int = int
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(int, forKey: "int")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions. Defaults to `charge_automatically`.
            public enum CollectionMethod: String, Codable, CaseIterable {
                case chargeAutomatically = "charge_automatically"
                case sendInvoice = "send_invoice"
            }

            /// The tax rates that will apply to any subscription item that does not have `tax_rates` set. Invoices created will have their `default_tax_rates` populated from the subscription. Pass an empty string to remove previously-defined tax rates.
            public struct DefaultTaxRates: Encodable {
                public var strings: [String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(strings: [String]? = nil, object: Object? = nil) {
                    self.strings = strings
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(strings, forKey: "strings")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// Subscription_item_update_params
            public struct Item: Encodable {
                public var billingThresholds: BillingThresholds?
                public var isClearUsage: Bool?
                public var isDeleted: Bool?
                public var id: String?
                public var metadata: Metadata?
                public var price: String?
                /// Recurring_price_data
                public var priceData: PriceData?
                public var quantity: Int?
                public var taxRates: TaxRates?

                public struct BillingThresholds: Encodable {
                    /// Item_billing_thresholds_param
                    public var a: A?
                    public var b: B?

                    /// Item_billing_thresholds_param
                    public struct A: Encodable {
                        public var usageGte: Int

                        public init(usageGte: Int) {
                            self.usageGte = usageGte
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(usageGte, forKey: "usage_gte")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                public struct Metadata: Encodable {
                    public var stringString: [String: String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(stringString: [String: String]? = nil, object: Object? = nil) {
                        self.stringString = stringString
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(stringString, forKey: "stringString")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                /// Recurring_price_data
                public struct PriceData: Encodable {
                    public var currency: String
                    public var product: String
                    /// Recurring_adhoc
                    public var recurring: Recurring
                    public var taxBehavior: TaxBehavior?
                    public var unitAmount: Int?
                    public var unitAmountDecimal: String?

                    /// Recurring_adhoc
                    public struct Recurring: Encodable {
                        public var interval: Interval
                        public var intervalCount: Int?

                        public enum Interval: String, Codable, CaseIterable {
                            case day
                            case month
                            case week
                            case year
                        }

                        public init(interval: Interval, intervalCount: Int? = nil) {
                            self.interval = interval
                            self.intervalCount = intervalCount
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(interval, forKey: "interval")
                            encoder.encode(intervalCount, forKey: "interval_count")
                            return encoder.items
                        }
                    }

                    public enum TaxBehavior: String, Codable, CaseIterable {
                        case exclusive
                        case inclusive
                        case unspecified
                    }

                    public init(currency: String, product: String, recurring: Recurring, taxBehavior: TaxBehavior? = nil, unitAmount: Int? = nil, unitAmountDecimal: String? = nil) {
                        self.currency = currency
                        self.product = product
                        self.recurring = recurring
                        self.taxBehavior = taxBehavior
                        self.unitAmount = unitAmount
                        self.unitAmountDecimal = unitAmountDecimal
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(product, forKey: "product")
                        encoder.encode(recurring, forKey: "recurring")
                        encoder.encode(taxBehavior, forKey: "tax_behavior")
                        encoder.encode(unitAmount, forKey: "unit_amount")
                        encoder.encode(unitAmountDecimal, forKey: "unit_amount_decimal")
                        return encoder.items
                    }
                }

                public struct TaxRates: Encodable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(billingThresholds: BillingThresholds? = nil, isClearUsage: Bool? = nil, isDeleted: Bool? = nil, id: String? = nil, metadata: Metadata? = nil, price: String? = nil, priceData: PriceData? = nil, quantity: Int? = nil, taxRates: TaxRates? = nil) {
                    self.billingThresholds = billingThresholds
                    self.isClearUsage = isClearUsage
                    self.isDeleted = isDeleted
                    self.id = id
                    self.metadata = metadata
                    self.price = price
                    self.priceData = priceData
                    self.quantity = quantity
                    self.taxRates = taxRates
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(billingThresholds, forKey: "billing_thresholds")
                    encoder.encode(isClearUsage, forKey: "clear_usage")
                    encoder.encode(isDeleted, forKey: "deleted")
                    encoder.encode(id, forKey: "id")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(price, forKey: "price")
                    encoder.encode(priceData, forKey: "price_data")
                    encoder.encode(quantity, forKey: "quantity")
                    encoder.encode(taxRates, forKey: "tax_rates")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// If specified, payment collection for this subscription will be paused.
            public struct PauseCollection: Encodable {
                /// Pause_collection_param
                public var a: A?
                public var b: B?

                /// Pause_collection_param
                public struct A: Encodable {
                    public var behavior: Behavior
                    public var resumesAt: Int?

                    public enum Behavior: String, Codable, CaseIterable {
                        case keepAsDraft = "keep_as_draft"
                        case markUncollectible = "mark_uncollectible"
                        case void
                    }

                    public init(behavior: Behavior, resumesAt: Int? = nil) {
                        self.behavior = behavior
                        self.resumesAt = resumesAt
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(behavior, forKey: "behavior")
                        encoder.encode(resumesAt, forKey: "resumes_at")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Use `allow_incomplete` to transition the subscription to `status=past_due` if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription's invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.
            /// 
            /// Use `default_incomplete` to transition the subscription to `status=past_due` when payment is required and await explicit confirmation of the invoice's payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.
            /// 
            /// Use `pending_if_incomplete` to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use `pending_if_incomplete` you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).
            /// 
            /// Use `error_if_incomplete` if you want Stripe to return an HTTP 402 status code if a subscription's invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
            public enum PaymentBehavior: String, Codable, CaseIterable {
                case allowIncomplete = "allow_incomplete"
                case defaultIncomplete = "default_incomplete"
                case errorIfIncomplete = "error_if_incomplete"
                case pendingIfIncomplete = "pending_if_incomplete"
            }

            /// Payment_settings
            ///
            /// Payment settings to pass to invoices created by the subscription.
            public struct PaymentSettings: Encodable {
                /// Payment_method_options
                public var paymentMethodOptions: PaymentMethodOptions?
                public var paymentMethodTypes: PaymentMethodTypes?

                /// Payment_method_options
                public struct PaymentMethodOptions: Encodable {
                    public var acssDebit: AcssDebit?
                    public var bancontact: Bancontact?
                    public var card: Card?

                    public struct AcssDebit: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            /// Mandate_options_param
                            public var mandateOptions: MandateOptions?
                            public var verificationMethod: VerificationMethod?

                            /// Mandate_options_param
                            public struct MandateOptions: Encodable {
                                public var transactionType: TransactionType?

                                public enum TransactionType: String, Codable, CaseIterable {
                                    case business
                                    case personal
                                }

                                public init(transactionType: TransactionType? = nil) {
                                    self.transactionType = transactionType
                                }

                                public var asQuery: [(String, String?)] {
                                    let encoder = URLQueryEncoder()
                                    encoder.encode(transactionType, forKey: "transaction_type")
                                    return encoder.items
                                }
                            }

                            public enum VerificationMethod: String, Codable, CaseIterable {
                                case automatic
                                case instant
                                case microdeposits
                            }

                            public init(mandateOptions: MandateOptions? = nil, verificationMethod: VerificationMethod? = nil) {
                                self.mandateOptions = mandateOptions
                                self.verificationMethod = verificationMethod
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(mandateOptions, forKey: "mandate_options")
                                encoder.encode(verificationMethod, forKey: "verification_method")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct Bancontact: Encodable {
                        /// Invoice_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Invoice_payment_method_options_param
                        public struct A: Encodable {
                            public var preferredLanguage: PreferredLanguage?

                            public enum PreferredLanguage: String, Codable, CaseIterable {
                                case de
                                case en
                                case fr
                                case nl
                            }

                            public init(preferredLanguage: PreferredLanguage? = nil) {
                                self.preferredLanguage = preferredLanguage
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(preferredLanguage, forKey: "preferred_language")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct Card: Encodable {
                        /// Subscription_payment_method_options_param
                        public var a: A?
                        public var b: B?

                        /// Subscription_payment_method_options_param
                        public struct A: Encodable {
                            public var requestThreeDSecure: RequestThreeDSecure?

                            public enum RequestThreeDSecure: String, Codable, CaseIterable {
                                case any
                                case automatic
                            }

                            public init(requestThreeDSecure: RequestThreeDSecure? = nil) {
                                self.requestThreeDSecure = requestThreeDSecure
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(requestThreeDSecure, forKey: "request_three_d_secure")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public init(acssDebit: AcssDebit? = nil, bancontact: Bancontact? = nil, card: Card? = nil) {
                        self.acssDebit = acssDebit
                        self.bancontact = bancontact
                        self.card = card
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(acssDebit, forKey: "acss_debit")
                        encoder.encode(bancontact, forKey: "bancontact")
                        encoder.encode(card, forKey: "card")
                        return encoder.items
                    }
                }

                public struct PaymentMethodTypes: Encodable {
                    public var placeholderItems: [PlaceholderItem]?
                    public var object: Object?

                    public enum PlaceholderItem: String, Codable, CaseIterable {
                        case achCreditTransfer = "ach_credit_transfer"
                        case achDebit = "ach_debit"
                        case acssDebit = "acss_debit"
                        case auBecsDebit = "au_becs_debit"
                        case bacsDebit = "bacs_debit"
                        case bancontact
                        case boleto
                        case card
                        case fpx
                        case giropay
                        case ideal
                        case sepaDebit = "sepa_debit"
                        case sofort
                        case wechatPay = "wechat_pay"
                    }

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(placeholderItems: [PlaceholderItem]? = nil, object: Object? = nil) {
                        self.placeholderItems = placeholderItems
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(placeholderItems, forKey: "placeholderItems")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public init(paymentMethodOptions: PaymentMethodOptions? = nil, paymentMethodTypes: PaymentMethodTypes? = nil) {
                    self.paymentMethodOptions = paymentMethodOptions
                    self.paymentMethodTypes = paymentMethodTypes
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(paymentMethodOptions, forKey: "payment_method_options")
                    encoder.encode(paymentMethodTypes, forKey: "payment_method_types")
                    return encoder.items
                }
            }

            /// Specifies an interval for how often to bill for any pending invoice items. It is analogous to calling [Create an invoice](https://stripe.com/docs/api#create_invoice) for the given subscription at the specified interval.
            public struct PendingInvoiceItemInterval: Encodable {
                /// Pending_invoice_item_interval_params
                public var a: A?
                public var b: B?

                /// Pending_invoice_item_interval_params
                public struct A: Encodable {
                    public var interval: Interval
                    public var intervalCount: Int?

                    public enum Interval: String, Codable, CaseIterable {
                        case day
                        case month
                        case week
                        case year
                    }

                    public init(interval: Interval, intervalCount: Int? = nil) {
                        self.interval = interval
                        self.intervalCount = intervalCount
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(interval, forKey: "interval")
                        encoder.encode(intervalCount, forKey: "interval_count")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting `billing_cycle_anchor=now`, or starting a trial), or if an item's `quantity` changes. Valid values are `create_prorations`, `none`, or `always_invoice`.
            /// 
            /// Passing `create_prorations` will cause proration invoice items to be created when applicable. These proration items will only be invoiced immediately under [certain conditions](https://stripe.com/docs/subscriptions/upgrading-downgrading#immediate-payment). In order to always invoice immediately for prorations, pass `always_invoice`.
            /// 
            /// Prorations can be disabled by passing `none`.
            public enum ProrationBehavior: String, Codable, CaseIterable {
                case alwaysInvoice = "always_invoice"
                case createProrations = "create_prorations"
                case `none`
            }

            /// If specified, the funds from the subscription's invoices will be transferred to the destination and the ID of the resulting transfers will be found on the resulting charges. This will be unset if you POST an empty value.
            public struct TransferData: Encodable {
                /// Transfer_data_specs
                public var a: A?
                public var b: B?

                /// Transfer_data_specs
                public struct A: Encodable {
                    public var amountPercent: Double?
                    public var destination: String

                    public init(amountPercent: Double? = nil, destination: String) {
                        self.amountPercent = amountPercent
                        self.destination = destination
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(amountPercent, forKey: "amount_percent")
                        encoder.encode(destination, forKey: "destination")
                        return encoder.items
                    }
                }

                public enum B: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(a: A? = nil, b: B? = nil) {
                    self.a = a
                    self.b = b
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(a, forKey: "a")
                    encoder.encode(b, forKey: "b")
                    return encoder.items
                }
            }

            /// Unix timestamp representing the end of the trial period the customer will get before being charged for the first time. This will always overwrite any trials that might apply via a subscribed plan. If set, trial_end will override the default trial period of the plan the customer is being subscribed to. The special value `now` can be provided to end the customer's trial immediately. Can be at most two years from `billing_cycle_anchor`.
            public struct TrialEnd: Encodable {
                public var object: Object?
                public var int: Int?

                public enum Object: String, Codable, CaseIterable {
                    case now
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(addInvoiceItems: [AddInvoiceItem]? = nil, applicationFeePercent: Double? = nil, automaticTax: AutomaticTax? = nil, billingCycleAnchor: BillingCycleAnchor? = nil, billingThresholds: BillingThresholds? = nil, cancelAt: CancelAt? = nil, isCancelAtPeriodEnd: Bool? = nil, collectionMethod: CollectionMethod? = nil, coupon: String? = nil, daysUntilDue: Int? = nil, defaultPaymentMethod: String? = nil, defaultSource: String? = nil, defaultTaxRates: DefaultTaxRates? = nil, expand: [String]? = nil, items: [Item]? = nil, metadata: Metadata? = nil, isOffSession: Bool? = nil, pauseCollection: PauseCollection? = nil, paymentBehavior: PaymentBehavior? = nil, paymentSettings: PaymentSettings? = nil, pendingInvoiceItemInterval: PendingInvoiceItemInterval? = nil, promotionCode: String? = nil, prorationBehavior: ProrationBehavior? = nil, prorationDate: Int? = nil, transferData: TransferData? = nil, trialEnd: TrialEnd? = nil, isTrialFromPlan: Bool? = nil) {
                self.addInvoiceItems = addInvoiceItems
                self.applicationFeePercent = applicationFeePercent
                self.automaticTax = automaticTax
                self.billingCycleAnchor = billingCycleAnchor
                self.billingThresholds = billingThresholds
                self.cancelAt = cancelAt
                self.isCancelAtPeriodEnd = isCancelAtPeriodEnd
                self.collectionMethod = collectionMethod
                self.coupon = coupon
                self.daysUntilDue = daysUntilDue
                self.defaultPaymentMethod = defaultPaymentMethod
                self.defaultSource = defaultSource
                self.defaultTaxRates = defaultTaxRates
                self.expand = expand
                self.items = items
                self.metadata = metadata
                self.isOffSession = isOffSession
                self.pauseCollection = pauseCollection
                self.paymentBehavior = paymentBehavior
                self.paymentSettings = paymentSettings
                self.pendingInvoiceItemInterval = pendingInvoiceItemInterval
                self.promotionCode = promotionCode
                self.prorationBehavior = prorationBehavior
                self.prorationDate = prorationDate
                self.transferData = transferData
                self.trialEnd = trialEnd
                self.isTrialFromPlan = isTrialFromPlan
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(addInvoiceItems, forKey: "add_invoice_items")
                encoder.encode(applicationFeePercent, forKey: "application_fee_percent")
                encoder.encode(automaticTax, forKey: "automatic_tax")
                encoder.encode(billingCycleAnchor, forKey: "billing_cycle_anchor")
                encoder.encode(billingThresholds, forKey: "billing_thresholds")
                encoder.encode(cancelAt, forKey: "cancel_at")
                encoder.encode(isCancelAtPeriodEnd, forKey: "cancel_at_period_end")
                encoder.encode(collectionMethod, forKey: "collection_method")
                encoder.encode(coupon, forKey: "coupon")
                encoder.encode(daysUntilDue, forKey: "days_until_due")
                encoder.encode(defaultPaymentMethod, forKey: "default_payment_method")
                encoder.encode(defaultSource, forKey: "default_source")
                encoder.encode(defaultTaxRates, forKey: "default_tax_rates")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(items, forKey: "items")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(isOffSession, forKey: "off_session")
                encoder.encode(pauseCollection, forKey: "pause_collection")
                encoder.encode(paymentBehavior, forKey: "payment_behavior")
                encoder.encode(paymentSettings, forKey: "payment_settings")
                encoder.encode(pendingInvoiceItemInterval, forKey: "pending_invoice_item_interval")
                encoder.encode(promotionCode, forKey: "promotion_code")
                encoder.encode(prorationBehavior, forKey: "proration_behavior")
                encoder.encode(prorationDate, forKey: "proration_date")
                encoder.encode(transferData, forKey: "transfer_data")
                encoder.encode(trialEnd, forKey: "trial_end")
                encoder.encode(isTrialFromPlan, forKey: "trial_from_plan")
                return encoder.items
            }
        }

        /// <p>Cancels a customer’s subscription immediately. The customer will not be charged again for the subscription.</p>
        /// 
        /// <p>Note, however, that any pending invoice items that you’ve created will still be charged for at the end of the period, unless manually <a href="#delete_invoiceitem">deleted</a>. If you’ve set the subscription to cancel at the end of the period, any pending prorations will also be left in place and collected at the end of the period. But if the subscription is set to cancel immediately, pending prorations will be removed.</p>
        /// 
        /// <p>By default, upon subscription cancellation, Stripe will stop automatic collection of all finalized invoices for the customer. This is intended to prevent unexpected payment attempts after the customer has canceled a subscription. However, you can resume automatic collection of the invoices manually after subscription cancellation to have us proceed. Or, you could check for unpaid invoices before allowing the customer to cancel the subscription at all.</p>
        public func delete(_ body: DeleteRequest? = nil) -> Request<StripeAPI.Subscription> {
            .delete(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct DeleteRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Will generate a final invoice that invoices for any un-invoiced metered usage and new/pending proration invoice items.
            public var isInvoiceNow: Bool?
            /// Will generate a proration invoice item that credits remaining unused time until the subscription period end.
            public var isProrate: Bool?

            public init(expand: [String]? = nil, isInvoiceNow: Bool? = nil, isProrate: Bool? = nil) {
                self.expand = expand
                self.isInvoiceNow = isInvoiceNow
                self.isProrate = isProrate
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(isInvoiceNow, forKey: "invoice_now")
                encoder.encode(isProrate, forKey: "prorate")
                return encoder.items
            }
        }
    }
}

extension Paths.Subscriptions.WithSubscriptionExposedID {
    public var discount: Discount {
        Discount(path: path + "/discount")
    }

    public struct Discount {
        /// Path: `/v1/subscriptions/{subscription_exposed_id}/discount`
        public let path: String

        /// <p>Removes the currently applied discount on a subscription.</p>
        public var delete: Request<StripeAPI.DeletedDiscount> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var taxCodes: TaxCodes {
        TaxCodes(path: "/v1/tax_codes")
    }

    public struct TaxCodes {
        /// Path: `/v1/tax_codes`
        public let path: String

        /// <p>A list of <a href="https://stripe.com/docs/tax/tax-codes">all tax codes available</a> to add to Products in order to allow specific tax calculations.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// TaxProductResourceTaxCodeList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.TaxCode]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.TaxCode], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }
    }
}

extension Paths.TaxCodes {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/tax_codes/{id}`
        public let path: String

        /// <p>Retrieves the details of an existing tax code. Supply the unique tax code ID and Stripe will return the corresponding tax code information.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.TaxCode> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths {
    public static var taxRates: TaxRates {
        TaxRates(path: "/v1/tax_rates")
    }

    public struct TaxRates {
        /// Path: `/v1/tax_rates`
        public let path: String

        /// <p>Returns a list of your tax rates. Tax rates are returned sorted by creation date, with the most recently created tax rates appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.TaxRate]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.TaxRate], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var isActive: Bool?
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var isInclusive: Bool?
            public var limit: Int?
            public var startingAfter: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(isActive: Bool? = nil, created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, isInclusive: Bool? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.isActive = isActive
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.isInclusive = isInclusive
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(isInclusive, forKey: "inclusive")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates a new tax rate.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.TaxRate> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Flag determining whether the tax rate is active or inactive (archived). Inactive tax rates cannot be used with new applications or Checkout Sessions, but will still work for subscriptions and invoices that already have it set.
            public var isActive: Bool?
            /// Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
            public var country: String?
            /// An arbitrary string attached to the tax rate for your internal use only. It will not be visible to your customers.
            public var description: String?
            /// The display name of the tax rate, which will be shown to users.
            public var displayName: String
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// This specifies if the tax rate is inclusive or exclusive.
            public var isInclusive: Bool
            /// The jurisdiction for the tax rate. You can use this label field for tax reporting purposes. It also appears on your customer’s invoice.
            public var jurisdiction: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// This represents the tax rate percent out of 100.
            public var percentage: Double
            /// [ISO 3166-2 subdivision code](https://en.wikipedia.org/wiki/ISO_3166-2:US), without country prefix. For example, "NY" for New York, United States.
            public var state: String?
            /// The high-level tax type, such as `vat` or `sales_tax`.
            public var taxType: TaxType?

            /// The high-level tax type, such as `vat` or `sales_tax`.
            public enum TaxType: String, Codable, CaseIterable {
                case gst
                case hst
                case jct
                case pst
                case qst
                case rst
                case salesTax = "sales_tax"
                case vat
            }

            public init(isActive: Bool? = nil, country: String? = nil, description: String? = nil, displayName: String, expand: [String]? = nil, isInclusive: Bool, jurisdiction: String? = nil, metadata: [String: String]? = nil, percentage: Double, state: String? = nil, taxType: TaxType? = nil) {
                self.isActive = isActive
                self.country = country
                self.description = description
                self.displayName = displayName
                self.expand = expand
                self.isInclusive = isInclusive
                self.jurisdiction = jurisdiction
                self.metadata = metadata
                self.percentage = percentage
                self.state = state
                self.taxType = taxType
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(country, forKey: "country")
                encoder.encode(description, forKey: "description")
                encoder.encode(displayName, forKey: "display_name")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(isInclusive, forKey: "inclusive")
                encoder.encode(jurisdiction, forKey: "jurisdiction")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(percentage, forKey: "percentage")
                encoder.encode(state, forKey: "state")
                encoder.encode(taxType, forKey: "tax_type")
                return encoder.items
            }
        }
    }
}

extension Paths.TaxRates {
    public func taxRate(_ taxRate: String) -> WithTaxRate {
        WithTaxRate(path: "\(path)/\(taxRate)")
    }

    public struct WithTaxRate {
        /// Path: `/v1/tax_rates/{tax_rate}`
        public let path: String

        /// <p>Retrieves a tax rate with the given ID</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.TaxRate> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates an existing tax rate.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.TaxRate> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Flag determining whether the tax rate is active or inactive (archived). Inactive tax rates cannot be used with new applications or Checkout Sessions, but will still work for subscriptions and invoices that already have it set.
            public var isActive: Bool?
            /// Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
            public var country: String?
            /// An arbitrary string attached to the tax rate for your internal use only. It will not be visible to your customers.
            public var description: String?
            /// The display name of the tax rate, which will be shown to users.
            public var displayName: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The jurisdiction for the tax rate. You can use this label field for tax reporting purposes. It also appears on your customer’s invoice.
            public var jurisdiction: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// [ISO 3166-2 subdivision code](https://en.wikipedia.org/wiki/ISO_3166-2:US), without country prefix. For example, "NY" for New York, United States.
            public var state: String?
            /// The high-level tax type, such as `vat` or `sales_tax`.
            public var taxType: TaxType?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            /// The high-level tax type, such as `vat` or `sales_tax`.
            public enum TaxType: String, Codable, CaseIterable {
                case gst
                case hst
                case jct
                case pst
                case qst
                case rst
                case salesTax = "sales_tax"
                case vat
            }

            public init(isActive: Bool? = nil, country: String? = nil, description: String? = nil, displayName: String? = nil, expand: [String]? = nil, jurisdiction: String? = nil, metadata: Metadata? = nil, state: String? = nil, taxType: TaxType? = nil) {
                self.isActive = isActive
                self.country = country
                self.description = description
                self.displayName = displayName
                self.expand = expand
                self.jurisdiction = jurisdiction
                self.metadata = metadata
                self.state = state
                self.taxType = taxType
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isActive, forKey: "active")
                encoder.encode(country, forKey: "country")
                encoder.encode(description, forKey: "description")
                encoder.encode(displayName, forKey: "display_name")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(jurisdiction, forKey: "jurisdiction")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(state, forKey: "state")
                encoder.encode(taxType, forKey: "tax_type")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var terminal: Terminal {
        Terminal(path: "/v1/terminal")
    }

    public struct Terminal {
        /// Path: `/v1/terminal`
        public let path: String
    }
}

extension Paths.Terminal {
    public var connectionTokens: ConnectionTokens {
        ConnectionTokens(path: path + "/connection_tokens")
    }

    public struct ConnectionTokens {
        /// Path: `/v1/terminal/connection_tokens`
        public let path: String

        /// <p>To connect to a reader the Stripe Terminal SDK needs to retrieve a short-lived connection token from Stripe, proxied through your server. On your backend, add an endpoint that creates and returns a connection token.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.TerminalConnectionToken> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The id of the location that this connection token is scoped to. If specified the connection token will only be usable with readers assigned to that location, otherwise the connection token will be usable with all readers. Note that location scoping only applies to internet-connected readers. For more details, see [the docs on scoping connection tokens](https://stripe.com/docs/terminal/fleet/locations#connection-tokens).
            public var location: String?

            public init(expand: [String]? = nil, location: String? = nil) {
                self.expand = expand
                self.location = location
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(location, forKey: "location")
                return encoder.items
            }
        }
    }
}

extension Paths.Terminal {
    public var locations: Locations {
        Locations(path: path + "/locations")
    }

    public struct Locations {
        /// Path: `/v1/terminal/locations`
        public let path: String

        /// <p>Returns a list of <code>Location</code> objects.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// TerminalLocationLocationList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.TerminalLocation]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.TerminalLocation], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>Creates a new <code>Location</code> object.
        /// For further details, including which address fields are required in each country, see the <a href="/docs/terminal/fleet/locations">Manage locations</a> guide.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.TerminalLocation> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Create_location_address_param
            ///
            /// The full address of the location.
            public var address: Address
            /// A name for the location.
            public var displayName: String
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?

            /// Create_location_address_param
            ///
            /// The full address of the location.
            public struct Address: Encodable {
                public var city: String?
                public var country: String
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?

                public init(city: String? = nil, country: String, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(address: Address, displayName: String, expand: [String]? = nil, metadata: Metadata? = nil) {
                self.address = address
                self.displayName = displayName
                self.expand = expand
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(address, forKey: "address")
                encoder.encode(displayName, forKey: "display_name")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths.Terminal.Locations {
    public func location(_ location: String) -> WithLocation {
        WithLocation(path: "\(path)/\(location)")
    }

    public struct WithLocation {
        /// Path: `/v1/terminal/locations/{location}`
        public let path: String

        /// <p>Retrieves a <code>Location</code> object.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.TerminalLocation> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates a <code>Location</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.TerminalLocation> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Optional_fields_address
            ///
            /// The full address of the location.
            public var address: Address?
            /// A name for the location.
            public var displayName: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?

            /// Optional_fields_address
            ///
            /// The full address of the location.
            public struct Address: Encodable {
                public var city: String?
                public var country: String?
                public var line1: String?
                public var line2: String?
                public var postalCode: String?
                public var state: String?

                public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                    self.city = city
                    self.country = country
                    self.line1 = line1
                    self.line2 = line2
                    self.postalCode = postalCode
                    self.state = state
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(city, forKey: "city")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(line1, forKey: "line1")
                    encoder.encode(line2, forKey: "line2")
                    encoder.encode(postalCode, forKey: "postal_code")
                    encoder.encode(state, forKey: "state")
                    return encoder.items
                }
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(address: Address? = nil, displayName: String? = nil, expand: [String]? = nil, metadata: Metadata? = nil) {
                self.address = address
                self.displayName = displayName
                self.expand = expand
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(address, forKey: "address")
                encoder.encode(displayName, forKey: "display_name")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }

        /// <p>Deletes a <code>Location</code> object.</p>
        public var delete: Request<StripeAPI.DeletedTerminalLocation> {
            .delete(path)
        }
    }
}

extension Paths.Terminal {
    public var readers: Readers {
        Readers(path: path + "/readers")
    }

    public struct Readers {
        /// Path: `/v1/terminal/readers`
        public let path: String

        /// <p>Returns a list of <code>Reader</code> objects.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// TerminalReaderRetrieveReader
        public struct GetResponse: Decodable {
            /// A list of readers
            public var data: [StripeAPI.TerminalReader]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.TerminalReader], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var deviceType: DeviceType?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var location: String?
            public var startingAfter: String?
            public var status: Status?

            public enum DeviceType: String, Codable, CaseIterable {
                case bbposChipper2x = "bbpos_chipper2x"
                case bbposWiseposE = "bbpos_wisepos_e"
                case verifoneP400 = "verifone_P400"
            }

            public enum Status: String, Codable, CaseIterable {
                case offline
                case online
            }

            public init(deviceType: DeviceType? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, location: String? = nil, startingAfter: String? = nil, status: Status? = nil) {
                self.deviceType = deviceType
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.location = location
                self.startingAfter = startingAfter
                self.status = status
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(deviceType, forKey: "device_type")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(location, forKey: "location")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(status, forKey: "status")
                return encoder.items
            }
        }

        /// <p>Creates a new <code>Reader</code> object.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.TerminalReader> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Custom label given to the reader for easier identification. If no label is specified, the registration code will be used.
            public var label: String?
            /// The location to assign the reader to.
            public var location: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// A code generated by the reader used for registering to an account.
            public var registrationCode: String

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(expand: [String]? = nil, label: String? = nil, location: String? = nil, metadata: Metadata? = nil, registrationCode: String) {
                self.expand = expand
                self.label = label
                self.location = location
                self.metadata = metadata
                self.registrationCode = registrationCode
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(label, forKey: "label")
                encoder.encode(location, forKey: "location")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(registrationCode, forKey: "registration_code")
                return encoder.items
            }
        }
    }
}

extension Paths.Terminal.Readers {
    public func reader(_ reader: String) -> WithReader {
        WithReader(path: "\(path)/\(reader)")
    }

    public struct WithReader {
        /// Path: `/v1/terminal/readers/{reader}`
        public let path: String

        /// <p>Retrieves a <code>Reader</code> object.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.TerminalReader> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates a <code>Reader</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.TerminalReader> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// The new label of the reader.
            public var label: String?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(expand: [String]? = nil, label: String? = nil, metadata: Metadata? = nil) {
                self.expand = expand
                self.label = label
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(label, forKey: "label")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }

        /// <p>Deletes a <code>Reader</code> object.</p>
        public var delete: Request<StripeAPI.DeletedTerminalReader> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var tokens: Tokens {
        Tokens(path: "/v1/tokens")
    }

    public struct Tokens {
        /// Path: `/v1/tokens`
        public let path: String

        /// <p>Creates a single-use token that represents a bank account’s details.
        /// This token can be used with any API method in place of a bank account dictionary. This token can be used only once, by attaching it to a <a href="#accounts">Custom account</a>.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Token> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Connect_js_account_token_specs
            ///
            /// Information for the account this token will represent.
            public var account: Account?
            /// Token_create_bank_account
            ///
            /// The bank account this token will represent.
            public var bankAccount: BankAccount?
            public var card: Card?
            /// The customer (owned by the application's account) for which to create a token. This can be used only with an [OAuth access token](https://stripe.com/docs/connect/standard-accounts) or [Stripe-Account header](https://stripe.com/docs/connect/authentication). For more details, see [Cloning Saved Payment Methods](https://stripe.com/docs/connect/cloning-saved-payment-methods).
            public var customer: String?
            /// Cvc_params
            ///
            /// The updated CVC value this token will represent.
            public var cvcUpdate: CvcUpdate?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Person_token_specs
            ///
            /// Information for the person this token will represent.
            public var person: Person?
            /// Pii_token_specs
            ///
            /// The PII this token will represent.
            public var pii: Pii?

            /// Connect_js_account_token_specs
            ///
            /// Information for the account this token will represent.
            public struct Account: Encodable {
                public var businessType: BusinessType?
                /// Connect_js_account_token_company_specs
                public var company: Company?
                /// Individual_specs
                public var individual: Individual?
                public var isTosShownAndAccepted: Bool?

                public enum BusinessType: String, Codable, CaseIterable {
                    case company
                    case governmentEntity = "government_entity"
                    case individual
                    case nonProfit = "non_profit"
                }

                /// Connect_js_account_token_company_specs
                public struct Company: Encodable {
                    /// Address_specs
                    public var address: Address?
                    /// Japan_address_kana_specs
                    public var addressKana: AddressKana?
                    /// Japan_address_kanji_specs
                    public var addressKanji: AddressKanji?
                    public var isDirectorsProvided: Bool?
                    public var isExecutivesProvided: Bool?
                    public var name: String?
                    public var nameKana: String?
                    public var nameKanji: String?
                    public var isOwnersProvided: Bool?
                    /// Company_ownership_declaration
                    public var ownershipDeclaration: OwnershipDeclaration?
                    public var isOwnershipDeclarationShownAndSigned: Bool?
                    public var phone: String?
                    public var registrationNumber: String?
                    public var structure: Structure?
                    public var taxID: String?
                    public var taxIDRegistrar: String?
                    public var vatID: String?
                    /// Verification_specs
                    public var verification: Verification?

                    /// Address_specs
                    public struct Address: Encodable {
                        public var city: String?
                        public var country: String?
                        public var line1: String?
                        public var line2: String?
                        public var postalCode: String?
                        public var state: String?

                        public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                            self.city = city
                            self.country = country
                            self.line1 = line1
                            self.line2 = line2
                            self.postalCode = postalCode
                            self.state = state
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(city, forKey: "city")
                            encoder.encode(country, forKey: "country")
                            encoder.encode(line1, forKey: "line1")
                            encoder.encode(line2, forKey: "line2")
                            encoder.encode(postalCode, forKey: "postal_code")
                            encoder.encode(state, forKey: "state")
                            return encoder.items
                        }
                    }

                    /// Japan_address_kana_specs
                    public struct AddressKana: Encodable {
                        public var city: String?
                        public var country: String?
                        public var line1: String?
                        public var line2: String?
                        public var postalCode: String?
                        public var state: String?
                        public var town: String?

                        public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                            self.city = city
                            self.country = country
                            self.line1 = line1
                            self.line2 = line2
                            self.postalCode = postalCode
                            self.state = state
                            self.town = town
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(city, forKey: "city")
                            encoder.encode(country, forKey: "country")
                            encoder.encode(line1, forKey: "line1")
                            encoder.encode(line2, forKey: "line2")
                            encoder.encode(postalCode, forKey: "postal_code")
                            encoder.encode(state, forKey: "state")
                            encoder.encode(town, forKey: "town")
                            return encoder.items
                        }
                    }

                    /// Japan_address_kanji_specs
                    public struct AddressKanji: Encodable {
                        public var city: String?
                        public var country: String?
                        public var line1: String?
                        public var line2: String?
                        public var postalCode: String?
                        public var state: String?
                        public var town: String?

                        public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                            self.city = city
                            self.country = country
                            self.line1 = line1
                            self.line2 = line2
                            self.postalCode = postalCode
                            self.state = state
                            self.town = town
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(city, forKey: "city")
                            encoder.encode(country, forKey: "country")
                            encoder.encode(line1, forKey: "line1")
                            encoder.encode(line2, forKey: "line2")
                            encoder.encode(postalCode, forKey: "postal_code")
                            encoder.encode(state, forKey: "state")
                            encoder.encode(town, forKey: "town")
                            return encoder.items
                        }
                    }

                    /// Company_ownership_declaration
                    public struct OwnershipDeclaration: Encodable {
                        public var date: Int?
                        public var ip: String?
                        public var userAgent: String?

                        public init(date: Int? = nil, ip: String? = nil, userAgent: String? = nil) {
                            self.date = date
                            self.ip = ip
                            self.userAgent = userAgent
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(date, forKey: "date")
                            encoder.encode(ip, forKey: "ip")
                            encoder.encode(userAgent, forKey: "user_agent")
                            return encoder.items
                        }
                    }

                    public enum Structure: String, Codable, CaseIterable {
                        case empty = ""
                        case freeZoneEstablishment = "free_zone_establishment"
                        case freeZoneLlc = "free_zone_llc"
                        case governmentInstrumentality = "government_instrumentality"
                        case governmentalUnit = "governmental_unit"
                        case incorporatedNonProfit = "incorporated_non_profit"
                        case limitedLiabilityPartnership = "limited_liability_partnership"
                        case llc
                        case multiMemberLlc = "multi_member_llc"
                        case privateCompany = "private_company"
                        case privateCorporation = "private_corporation"
                        case privatePartnership = "private_partnership"
                        case publicCompany = "public_company"
                        case publicCorporation = "public_corporation"
                        case publicPartnership = "public_partnership"
                        case singleMemberLlc = "single_member_llc"
                        case soleEstablishment = "sole_establishment"
                        case soleProprietorship = "sole_proprietorship"
                        case taxExemptGovernmentInstrumentality = "tax_exempt_government_instrumentality"
                        case unincorporatedAssociation = "unincorporated_association"
                        case unincorporatedNonProfit = "unincorporated_non_profit"
                    }

                    /// Verification_specs
                    public struct Verification: Encodable {
                        /// Verification_document_specs
                        public var document: Document?

                        /// Verification_document_specs
                        public struct Document: Encodable {
                            public var back: String?
                            public var front: String?

                            public init(back: String? = nil, front: String? = nil) {
                                self.back = back
                                self.front = front
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(back, forKey: "back")
                                encoder.encode(front, forKey: "front")
                                return encoder.items
                            }
                        }

                        public init(document: Document? = nil) {
                            self.document = document
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(document, forKey: "document")
                            return encoder.items
                        }
                    }

                    public init(address: Address? = nil, addressKana: AddressKana? = nil, addressKanji: AddressKanji? = nil, isDirectorsProvided: Bool? = nil, isExecutivesProvided: Bool? = nil, name: String? = nil, nameKana: String? = nil, nameKanji: String? = nil, isOwnersProvided: Bool? = nil, ownershipDeclaration: OwnershipDeclaration? = nil, isOwnershipDeclarationShownAndSigned: Bool? = nil, phone: String? = nil, registrationNumber: String? = nil, structure: Structure? = nil, taxID: String? = nil, taxIDRegistrar: String? = nil, vatID: String? = nil, verification: Verification? = nil) {
                        self.address = address
                        self.addressKana = addressKana
                        self.addressKanji = addressKanji
                        self.isDirectorsProvided = isDirectorsProvided
                        self.isExecutivesProvided = isExecutivesProvided
                        self.name = name
                        self.nameKana = nameKana
                        self.nameKanji = nameKanji
                        self.isOwnersProvided = isOwnersProvided
                        self.ownershipDeclaration = ownershipDeclaration
                        self.isOwnershipDeclarationShownAndSigned = isOwnershipDeclarationShownAndSigned
                        self.phone = phone
                        self.registrationNumber = registrationNumber
                        self.structure = structure
                        self.taxID = taxID
                        self.taxIDRegistrar = taxIDRegistrar
                        self.vatID = vatID
                        self.verification = verification
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(address, forKey: "address")
                        encoder.encode(addressKana, forKey: "address_kana")
                        encoder.encode(addressKanji, forKey: "address_kanji")
                        encoder.encode(isDirectorsProvided, forKey: "directors_provided")
                        encoder.encode(isExecutivesProvided, forKey: "executives_provided")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(nameKana, forKey: "name_kana")
                        encoder.encode(nameKanji, forKey: "name_kanji")
                        encoder.encode(isOwnersProvided, forKey: "owners_provided")
                        encoder.encode(ownershipDeclaration, forKey: "ownership_declaration")
                        encoder.encode(isOwnershipDeclarationShownAndSigned, forKey: "ownership_declaration_shown_and_signed")
                        encoder.encode(phone, forKey: "phone")
                        encoder.encode(registrationNumber, forKey: "registration_number")
                        encoder.encode(structure, forKey: "structure")
                        encoder.encode(taxID, forKey: "tax_id")
                        encoder.encode(taxIDRegistrar, forKey: "tax_id_registrar")
                        encoder.encode(vatID, forKey: "vat_id")
                        encoder.encode(verification, forKey: "verification")
                        return encoder.items
                    }
                }

                /// Individual_specs
                public struct Individual: Encodable {
                    /// Address_specs
                    public var address: Address?
                    /// Japan_address_kana_specs
                    public var addressKana: AddressKana?
                    /// Japan_address_kanji_specs
                    public var addressKanji: AddressKanji?
                    public var dob: Dob?
                    public var email: String?
                    public var firstName: String?
                    public var firstNameKana: String?
                    public var firstNameKanji: String?
                    public var fullNameAliases: FullNameAliases?
                    public var gender: String?
                    public var idNumber: String?
                    public var lastName: String?
                    public var lastNameKana: String?
                    public var lastNameKanji: String?
                    public var maidenName: String?
                    public var metadata: Metadata?
                    public var phone: String?
                    public var politicalExposure: PoliticalExposure?
                    public var ssnLast4: String?
                    /// Person_verification_specs
                    public var verification: Verification?

                    /// Address_specs
                    public struct Address: Encodable {
                        public var city: String?
                        public var country: String?
                        public var line1: String?
                        public var line2: String?
                        public var postalCode: String?
                        public var state: String?

                        public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                            self.city = city
                            self.country = country
                            self.line1 = line1
                            self.line2 = line2
                            self.postalCode = postalCode
                            self.state = state
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(city, forKey: "city")
                            encoder.encode(country, forKey: "country")
                            encoder.encode(line1, forKey: "line1")
                            encoder.encode(line2, forKey: "line2")
                            encoder.encode(postalCode, forKey: "postal_code")
                            encoder.encode(state, forKey: "state")
                            return encoder.items
                        }
                    }

                    /// Japan_address_kana_specs
                    public struct AddressKana: Encodable {
                        public var city: String?
                        public var country: String?
                        public var line1: String?
                        public var line2: String?
                        public var postalCode: String?
                        public var state: String?
                        public var town: String?

                        public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                            self.city = city
                            self.country = country
                            self.line1 = line1
                            self.line2 = line2
                            self.postalCode = postalCode
                            self.state = state
                            self.town = town
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(city, forKey: "city")
                            encoder.encode(country, forKey: "country")
                            encoder.encode(line1, forKey: "line1")
                            encoder.encode(line2, forKey: "line2")
                            encoder.encode(postalCode, forKey: "postal_code")
                            encoder.encode(state, forKey: "state")
                            encoder.encode(town, forKey: "town")
                            return encoder.items
                        }
                    }

                    /// Japan_address_kanji_specs
                    public struct AddressKanji: Encodable {
                        public var city: String?
                        public var country: String?
                        public var line1: String?
                        public var line2: String?
                        public var postalCode: String?
                        public var state: String?
                        public var town: String?

                        public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                            self.city = city
                            self.country = country
                            self.line1 = line1
                            self.line2 = line2
                            self.postalCode = postalCode
                            self.state = state
                            self.town = town
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(city, forKey: "city")
                            encoder.encode(country, forKey: "country")
                            encoder.encode(line1, forKey: "line1")
                            encoder.encode(line2, forKey: "line2")
                            encoder.encode(postalCode, forKey: "postal_code")
                            encoder.encode(state, forKey: "state")
                            encoder.encode(town, forKey: "town")
                            return encoder.items
                        }
                    }

                    public struct Dob: Encodable {
                        /// Date_of_birth_specs
                        public var a: A?
                        public var b: B?

                        /// Date_of_birth_specs
                        public struct A: Encodable {
                            public var day: Int
                            public var month: Int
                            public var year: Int

                            public init(day: Int, month: Int, year: Int) {
                                self.day = day
                                self.month = month
                                self.year = year
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(day, forKey: "day")
                                encoder.encode(month, forKey: "month")
                                encoder.encode(year, forKey: "year")
                                return encoder.items
                            }
                        }

                        public enum B: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(a: A? = nil, b: B? = nil) {
                            self.a = a
                            self.b = b
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(a, forKey: "a")
                            encoder.encode(b, forKey: "b")
                            return encoder.items
                        }
                    }

                    public struct FullNameAliases: Encodable {
                        public var strings: [String]?
                        public var object: Object?

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(strings: [String]? = nil, object: Object? = nil) {
                            self.strings = strings
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(strings, forKey: "strings")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public struct Metadata: Encodable {
                        public var stringString: [String: String]?
                        public var object: Object?

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(stringString: [String: String]? = nil, object: Object? = nil) {
                            self.stringString = stringString
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(stringString, forKey: "stringString")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public enum PoliticalExposure: String, Codable, CaseIterable {
                        case existing
                        case `none`
                    }

                    /// Person_verification_specs
                    public struct Verification: Encodable {
                        /// Person_verification_document_specs
                        public var additionalDocument: AdditionalDocument?
                        /// Person_verification_document_specs
                        public var document: Document?

                        /// Person_verification_document_specs
                        public struct AdditionalDocument: Encodable {
                            public var back: String?
                            public var front: String?

                            public init(back: String? = nil, front: String? = nil) {
                                self.back = back
                                self.front = front
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(back, forKey: "back")
                                encoder.encode(front, forKey: "front")
                                return encoder.items
                            }
                        }

                        /// Person_verification_document_specs
                        public struct Document: Encodable {
                            public var back: String?
                            public var front: String?

                            public init(back: String? = nil, front: String? = nil) {
                                self.back = back
                                self.front = front
                            }

                            public var asQuery: [(String, String?)] {
                                let encoder = URLQueryEncoder()
                                encoder.encode(back, forKey: "back")
                                encoder.encode(front, forKey: "front")
                                return encoder.items
                            }
                        }

                        public init(additionalDocument: AdditionalDocument? = nil, document: Document? = nil) {
                            self.additionalDocument = additionalDocument
                            self.document = document
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(additionalDocument, forKey: "additional_document")
                            encoder.encode(document, forKey: "document")
                            return encoder.items
                        }
                    }

                    public init(address: Address? = nil, addressKana: AddressKana? = nil, addressKanji: AddressKanji? = nil, dob: Dob? = nil, email: String? = nil, firstName: String? = nil, firstNameKana: String? = nil, firstNameKanji: String? = nil, fullNameAliases: FullNameAliases? = nil, gender: String? = nil, idNumber: String? = nil, lastName: String? = nil, lastNameKana: String? = nil, lastNameKanji: String? = nil, maidenName: String? = nil, metadata: Metadata? = nil, phone: String? = nil, politicalExposure: PoliticalExposure? = nil, ssnLast4: String? = nil, verification: Verification? = nil) {
                        self.address = address
                        self.addressKana = addressKana
                        self.addressKanji = addressKanji
                        self.dob = dob
                        self.email = email
                        self.firstName = firstName
                        self.firstNameKana = firstNameKana
                        self.firstNameKanji = firstNameKanji
                        self.fullNameAliases = fullNameAliases
                        self.gender = gender
                        self.idNumber = idNumber
                        self.lastName = lastName
                        self.lastNameKana = lastNameKana
                        self.lastNameKanji = lastNameKanji
                        self.maidenName = maidenName
                        self.metadata = metadata
                        self.phone = phone
                        self.politicalExposure = politicalExposure
                        self.ssnLast4 = ssnLast4
                        self.verification = verification
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(address, forKey: "address")
                        encoder.encode(addressKana, forKey: "address_kana")
                        encoder.encode(addressKanji, forKey: "address_kanji")
                        encoder.encode(dob, forKey: "dob")
                        encoder.encode(email, forKey: "email")
                        encoder.encode(firstName, forKey: "first_name")
                        encoder.encode(firstNameKana, forKey: "first_name_kana")
                        encoder.encode(firstNameKanji, forKey: "first_name_kanji")
                        encoder.encode(fullNameAliases, forKey: "full_name_aliases")
                        encoder.encode(gender, forKey: "gender")
                        encoder.encode(idNumber, forKey: "id_number")
                        encoder.encode(lastName, forKey: "last_name")
                        encoder.encode(lastNameKana, forKey: "last_name_kana")
                        encoder.encode(lastNameKanji, forKey: "last_name_kanji")
                        encoder.encode(maidenName, forKey: "maiden_name")
                        encoder.encode(metadata, forKey: "metadata")
                        encoder.encode(phone, forKey: "phone")
                        encoder.encode(politicalExposure, forKey: "political_exposure")
                        encoder.encode(ssnLast4, forKey: "ssn_last_4")
                        encoder.encode(verification, forKey: "verification")
                        return encoder.items
                    }
                }

                public init(businessType: BusinessType? = nil, company: Company? = nil, individual: Individual? = nil, isTosShownAndAccepted: Bool? = nil) {
                    self.businessType = businessType
                    self.company = company
                    self.individual = individual
                    self.isTosShownAndAccepted = isTosShownAndAccepted
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(businessType, forKey: "business_type")
                    encoder.encode(company, forKey: "company")
                    encoder.encode(individual, forKey: "individual")
                    encoder.encode(isTosShownAndAccepted, forKey: "tos_shown_and_accepted")
                    return encoder.items
                }
            }

            /// Token_create_bank_account
            ///
            /// The bank account this token will represent.
            public struct BankAccount: Encodable {
                public var accountHolderName: String?
                public var accountHolderType: AccountHolderType?
                public var accountNumber: String
                public var accountType: AccountType?
                public var country: String
                public var currency: String?
                public var routingNumber: String?

                public enum AccountHolderType: String, Codable, CaseIterable {
                    case company
                    case individual
                }

                public enum AccountType: String, Codable, CaseIterable {
                    case checking
                    case futsu
                    case savings
                    case toza
                }

                public init(accountHolderName: String? = nil, accountHolderType: AccountHolderType? = nil, accountNumber: String, accountType: AccountType? = nil, country: String, currency: String? = nil, routingNumber: String? = nil) {
                    self.accountHolderName = accountHolderName
                    self.accountHolderType = accountHolderType
                    self.accountNumber = accountNumber
                    self.accountType = accountType
                    self.country = country
                    self.currency = currency
                    self.routingNumber = routingNumber
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(accountHolderName, forKey: "account_holder_name")
                    encoder.encode(accountHolderType, forKey: "account_holder_type")
                    encoder.encode(accountNumber, forKey: "account_number")
                    encoder.encode(accountType, forKey: "account_type")
                    encoder.encode(country, forKey: "country")
                    encoder.encode(currency, forKey: "currency")
                    encoder.encode(routingNumber, forKey: "routing_number")
                    return encoder.items
                }
            }

            public struct Card: Encodable {
                /// Credit_card_specs
                public var object: Object?
                public var string: String?

                /// Credit_card_specs
                public struct Object: Encodable {
                    public var addressCity: String?
                    public var addressCountry: String?
                    public var addressLine1: String?
                    public var addressLine2: String?
                    public var addressState: String?
                    public var addressZip: String?
                    public var currency: String?
                    public var cvc: String?
                    public var expMonth: String
                    public var expYear: String
                    public var name: String?
                    public var number: String

                    public init(addressCity: String? = nil, addressCountry: String? = nil, addressLine1: String? = nil, addressLine2: String? = nil, addressState: String? = nil, addressZip: String? = nil, currency: String? = nil, cvc: String? = nil, expMonth: String, expYear: String, name: String? = nil, number: String) {
                        self.addressCity = addressCity
                        self.addressCountry = addressCountry
                        self.addressLine1 = addressLine1
                        self.addressLine2 = addressLine2
                        self.addressState = addressState
                        self.addressZip = addressZip
                        self.currency = currency
                        self.cvc = cvc
                        self.expMonth = expMonth
                        self.expYear = expYear
                        self.name = name
                        self.number = number
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(addressCity, forKey: "address_city")
                        encoder.encode(addressCountry, forKey: "address_country")
                        encoder.encode(addressLine1, forKey: "address_line1")
                        encoder.encode(addressLine2, forKey: "address_line2")
                        encoder.encode(addressState, forKey: "address_state")
                        encoder.encode(addressZip, forKey: "address_zip")
                        encoder.encode(currency, forKey: "currency")
                        encoder.encode(cvc, forKey: "cvc")
                        encoder.encode(expMonth, forKey: "exp_month")
                        encoder.encode(expYear, forKey: "exp_year")
                        encoder.encode(name, forKey: "name")
                        encoder.encode(number, forKey: "number")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, string: String? = nil) {
                    self.object = object
                    self.string = string
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(string, forKey: "string")
                    return encoder.items
                }
            }

            /// Cvc_params
            ///
            /// The updated CVC value this token will represent.
            public struct CvcUpdate: Encodable {
                public var cvc: String

                public init(cvc: String) {
                    self.cvc = cvc
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(cvc, forKey: "cvc")
                    return encoder.items
                }
            }

            /// Person_token_specs
            ///
            /// Information for the person this token will represent.
            public struct Person: Encodable {
                /// Address_specs
                public var address: Address?
                /// Japan_address_kana_specs
                public var addressKana: AddressKana?
                /// Japan_address_kanji_specs
                public var addressKanji: AddressKanji?
                public var dob: Dob?
                /// Person_documents_specs
                public var documents: Documents?
                public var email: String?
                public var firstName: String?
                public var firstNameKana: String?
                public var firstNameKanji: String?
                public var fullNameAliases: FullNameAliases?
                public var gender: String?
                public var idNumber: String?
                public var lastName: String?
                public var lastNameKana: String?
                public var lastNameKanji: String?
                public var maidenName: String?
                public var metadata: Metadata?
                public var nationality: String?
                public var phone: String?
                public var politicalExposure: String?
                /// Relationship_specs
                public var relationship: Relationship?
                public var ssnLast4: String?
                /// Person_verification_specs
                public var verification: Verification?

                /// Address_specs
                public struct Address: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        return encoder.items
                    }
                }

                /// Japan_address_kana_specs
                public struct AddressKana: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?
                    public var town: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                        self.town = town
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        encoder.encode(town, forKey: "town")
                        return encoder.items
                    }
                }

                /// Japan_address_kanji_specs
                public struct AddressKanji: Encodable {
                    public var city: String?
                    public var country: String?
                    public var line1: String?
                    public var line2: String?
                    public var postalCode: String?
                    public var state: String?
                    public var town: String?

                    public init(city: String? = nil, country: String? = nil, line1: String? = nil, line2: String? = nil, postalCode: String? = nil, state: String? = nil, town: String? = nil) {
                        self.city = city
                        self.country = country
                        self.line1 = line1
                        self.line2 = line2
                        self.postalCode = postalCode
                        self.state = state
                        self.town = town
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(city, forKey: "city")
                        encoder.encode(country, forKey: "country")
                        encoder.encode(line1, forKey: "line1")
                        encoder.encode(line2, forKey: "line2")
                        encoder.encode(postalCode, forKey: "postal_code")
                        encoder.encode(state, forKey: "state")
                        encoder.encode(town, forKey: "town")
                        return encoder.items
                    }
                }

                public struct Dob: Encodable {
                    /// Date_of_birth_specs
                    public var a: A?
                    public var b: B?

                    /// Date_of_birth_specs
                    public struct A: Encodable {
                        public var day: Int
                        public var month: Int
                        public var year: Int

                        public init(day: Int, month: Int, year: Int) {
                            self.day = day
                            self.month = month
                            self.year = year
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(day, forKey: "day")
                            encoder.encode(month, forKey: "month")
                            encoder.encode(year, forKey: "year")
                            return encoder.items
                        }
                    }

                    public enum B: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(a: A? = nil, b: B? = nil) {
                        self.a = a
                        self.b = b
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(a, forKey: "a")
                        encoder.encode(b, forKey: "b")
                        return encoder.items
                    }
                }

                /// Person_documents_specs
                public struct Documents: Encodable {
                    /// Documents_param
                    public var companyAuthorization: CompanyAuthorization?
                    /// Documents_param
                    public var passport: Passport?
                    /// Documents_param
                    public var visa: Visa?

                    /// Documents_param
                    public struct CompanyAuthorization: Encodable {
                        public var files: [String]?

                        public init(files: [String]? = nil) {
                            self.files = files
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(files, forKey: "files")
                            return encoder.items
                        }
                    }

                    /// Documents_param
                    public struct Passport: Encodable {
                        public var files: [String]?

                        public init(files: [String]? = nil) {
                            self.files = files
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(files, forKey: "files")
                            return encoder.items
                        }
                    }

                    /// Documents_param
                    public struct Visa: Encodable {
                        public var files: [String]?

                        public init(files: [String]? = nil) {
                            self.files = files
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(files, forKey: "files")
                            return encoder.items
                        }
                    }

                    public init(companyAuthorization: CompanyAuthorization? = nil, passport: Passport? = nil, visa: Visa? = nil) {
                        self.companyAuthorization = companyAuthorization
                        self.passport = passport
                        self.visa = visa
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(companyAuthorization, forKey: "company_authorization")
                        encoder.encode(passport, forKey: "passport")
                        encoder.encode(visa, forKey: "visa")
                        return encoder.items
                    }
                }

                public struct FullNameAliases: Encodable {
                    public var strings: [String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(strings: [String]? = nil, object: Object? = nil) {
                        self.strings = strings
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(strings, forKey: "strings")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                public struct Metadata: Encodable {
                    public var stringString: [String: String]?
                    public var object: Object?

                    public enum Object: String, Codable, CaseIterable {
                        case empty = ""
                    }

                    public init(stringString: [String: String]? = nil, object: Object? = nil) {
                        self.stringString = stringString
                        self.object = object
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(stringString, forKey: "stringString")
                        encoder.encode(object, forKey: "object")
                        return encoder.items
                    }
                }

                /// Relationship_specs
                public struct Relationship: Encodable {
                    public var isDirector: Bool?
                    public var isExecutive: Bool?
                    public var isOwner: Bool?
                    public var percentOwnership: PercentOwnership?
                    public var isRepresentative: Bool?
                    public var title: String?

                    public struct PercentOwnership: Encodable {
                        public var double: Double?
                        public var object: Object?

                        public enum Object: String, Codable, CaseIterable {
                            case empty = ""
                        }

                        public init(double: Double? = nil, object: Object? = nil) {
                            self.double = double
                            self.object = object
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(double, forKey: "double")
                            encoder.encode(object, forKey: "object")
                            return encoder.items
                        }
                    }

                    public init(isDirector: Bool? = nil, isExecutive: Bool? = nil, isOwner: Bool? = nil, percentOwnership: PercentOwnership? = nil, isRepresentative: Bool? = nil, title: String? = nil) {
                        self.isDirector = isDirector
                        self.isExecutive = isExecutive
                        self.isOwner = isOwner
                        self.percentOwnership = percentOwnership
                        self.isRepresentative = isRepresentative
                        self.title = title
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(isDirector, forKey: "director")
                        encoder.encode(isExecutive, forKey: "executive")
                        encoder.encode(isOwner, forKey: "owner")
                        encoder.encode(percentOwnership, forKey: "percent_ownership")
                        encoder.encode(isRepresentative, forKey: "representative")
                        encoder.encode(title, forKey: "title")
                        return encoder.items
                    }
                }

                /// Person_verification_specs
                public struct Verification: Encodable {
                    /// Person_verification_document_specs
                    public var additionalDocument: AdditionalDocument?
                    /// Person_verification_document_specs
                    public var document: Document?

                    /// Person_verification_document_specs
                    public struct AdditionalDocument: Encodable {
                        public var back: String?
                        public var front: String?

                        public init(back: String? = nil, front: String? = nil) {
                            self.back = back
                            self.front = front
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(back, forKey: "back")
                            encoder.encode(front, forKey: "front")
                            return encoder.items
                        }
                    }

                    /// Person_verification_document_specs
                    public struct Document: Encodable {
                        public var back: String?
                        public var front: String?

                        public init(back: String? = nil, front: String? = nil) {
                            self.back = back
                            self.front = front
                        }

                        public var asQuery: [(String, String?)] {
                            let encoder = URLQueryEncoder()
                            encoder.encode(back, forKey: "back")
                            encoder.encode(front, forKey: "front")
                            return encoder.items
                        }
                    }

                    public init(additionalDocument: AdditionalDocument? = nil, document: Document? = nil) {
                        self.additionalDocument = additionalDocument
                        self.document = document
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(additionalDocument, forKey: "additional_document")
                        encoder.encode(document, forKey: "document")
                        return encoder.items
                    }
                }

                public init(address: Address? = nil, addressKana: AddressKana? = nil, addressKanji: AddressKanji? = nil, dob: Dob? = nil, documents: Documents? = nil, email: String? = nil, firstName: String? = nil, firstNameKana: String? = nil, firstNameKanji: String? = nil, fullNameAliases: FullNameAliases? = nil, gender: String? = nil, idNumber: String? = nil, lastName: String? = nil, lastNameKana: String? = nil, lastNameKanji: String? = nil, maidenName: String? = nil, metadata: Metadata? = nil, nationality: String? = nil, phone: String? = nil, politicalExposure: String? = nil, relationship: Relationship? = nil, ssnLast4: String? = nil, verification: Verification? = nil) {
                    self.address = address
                    self.addressKana = addressKana
                    self.addressKanji = addressKanji
                    self.dob = dob
                    self.documents = documents
                    self.email = email
                    self.firstName = firstName
                    self.firstNameKana = firstNameKana
                    self.firstNameKanji = firstNameKanji
                    self.fullNameAliases = fullNameAliases
                    self.gender = gender
                    self.idNumber = idNumber
                    self.lastName = lastName
                    self.lastNameKana = lastNameKana
                    self.lastNameKanji = lastNameKanji
                    self.maidenName = maidenName
                    self.metadata = metadata
                    self.nationality = nationality
                    self.phone = phone
                    self.politicalExposure = politicalExposure
                    self.relationship = relationship
                    self.ssnLast4 = ssnLast4
                    self.verification = verification
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(address, forKey: "address")
                    encoder.encode(addressKana, forKey: "address_kana")
                    encoder.encode(addressKanji, forKey: "address_kanji")
                    encoder.encode(dob, forKey: "dob")
                    encoder.encode(documents, forKey: "documents")
                    encoder.encode(email, forKey: "email")
                    encoder.encode(firstName, forKey: "first_name")
                    encoder.encode(firstNameKana, forKey: "first_name_kana")
                    encoder.encode(firstNameKanji, forKey: "first_name_kanji")
                    encoder.encode(fullNameAliases, forKey: "full_name_aliases")
                    encoder.encode(gender, forKey: "gender")
                    encoder.encode(idNumber, forKey: "id_number")
                    encoder.encode(lastName, forKey: "last_name")
                    encoder.encode(lastNameKana, forKey: "last_name_kana")
                    encoder.encode(lastNameKanji, forKey: "last_name_kanji")
                    encoder.encode(maidenName, forKey: "maiden_name")
                    encoder.encode(metadata, forKey: "metadata")
                    encoder.encode(nationality, forKey: "nationality")
                    encoder.encode(phone, forKey: "phone")
                    encoder.encode(politicalExposure, forKey: "political_exposure")
                    encoder.encode(relationship, forKey: "relationship")
                    encoder.encode(ssnLast4, forKey: "ssn_last_4")
                    encoder.encode(verification, forKey: "verification")
                    return encoder.items
                }
            }

            /// Pii_token_specs
            ///
            /// The PII this token will represent.
            public struct Pii: Encodable {
                public var idNumber: String?

                public init(idNumber: String? = nil) {
                    self.idNumber = idNumber
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(idNumber, forKey: "id_number")
                    return encoder.items
                }
            }

            public init(account: Account? = nil, bankAccount: BankAccount? = nil, card: Card? = nil, customer: String? = nil, cvcUpdate: CvcUpdate? = nil, expand: [String]? = nil, person: Person? = nil, pii: Pii? = nil) {
                self.account = account
                self.bankAccount = bankAccount
                self.card = card
                self.customer = customer
                self.cvcUpdate = cvcUpdate
                self.expand = expand
                self.person = person
                self.pii = pii
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(account, forKey: "account")
                encoder.encode(bankAccount, forKey: "bank_account")
                encoder.encode(card, forKey: "card")
                encoder.encode(customer, forKey: "customer")
                encoder.encode(cvcUpdate, forKey: "cvc_update")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(person, forKey: "person")
                encoder.encode(pii, forKey: "pii")
                return encoder.items
            }
        }
    }
}

extension Paths.Tokens {
    public func token(_ token: String) -> WithToken {
        WithToken(path: "\(path)/\(token)")
    }

    public struct WithToken {
        /// Path: `/v1/tokens/{token}`
        public let path: String

        /// <p>Retrieves the token with the given ID.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Token> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }
    }
}

extension Paths {
    public static var topups: Topups {
        Topups(path: "/v1/topups")
    }

    public struct Topups {
        /// Path: `/v1/topups`
        public let path: String

        /// <p>Returns a list of top-ups.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// TopupList
        public struct GetResponse: Decodable {
            public var data: [StripeAPI.Topup]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Topup], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var amount: Amount?
            public var created: Created?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?
            public var status: Status?

            public struct Amount: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public enum Status: String, Codable, CaseIterable {
                case canceled
                case failed
                case pending
                case succeeded
            }

            public init(amount: Amount? = nil, created: Created? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil, status: Status? = nil) {
                self.amount = amount
                self.created = created
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
                self.status = status
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount", isDeepObject: true)
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(status, forKey: "status")
                return encoder.items
            }
        }

        /// <p>Top up the balance of an account</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.Topup> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// A positive integer representing how much to transfer.
            public var amount: Int
            /// Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
            public var currency: String
            /// An arbitrary string attached to the object. Often useful for displaying to users.
            public var description: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The ID of a source to transfer funds from. For most users, this should be left unspecified which will use the bank account that was set up in the dashboard for the specified currency. In test mode, this can be a test bank token (see [Testing Top-ups](https://stripe.com/docs/connect/testing#testing-top-ups)).
            public var source: String?
            /// Extra information about a top-up for the source's bank statement. Limited to 15 ASCII characters.
            public var statementDescriptor: String?
            /// A string that identifies this top-up as part of a group.
            public var transferGroup: String?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(amount: Int, currency: String, description: String? = nil, expand: [String]? = nil, metadata: Metadata? = nil, source: String? = nil, statementDescriptor: String? = nil, transferGroup: String? = nil) {
                self.amount = amount
                self.currency = currency
                self.description = description
                self.expand = expand
                self.metadata = metadata
                self.source = source
                self.statementDescriptor = statementDescriptor
                self.transferGroup = transferGroup
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(description, forKey: "description")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(source, forKey: "source")
                encoder.encode(statementDescriptor, forKey: "statement_descriptor")
                encoder.encode(transferGroup, forKey: "transfer_group")
                return encoder.items
            }
        }
    }
}

extension Paths.Topups {
    public func topup(_ topup: String) -> WithTopup {
        WithTopup(path: "\(path)/\(topup)")
    }

    public struct WithTopup {
        /// Path: `/v1/topups/{topup}`
        public let path: String

        /// <p>Retrieves the details of a top-up that has previously been created. Supply the unique top-up ID that was returned from your previous request, and Stripe will return the corresponding top-up information.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Topup> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the metadata of a top-up. Other top-up details are not editable by design.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Topup> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// An arbitrary string attached to the object. Often useful for displaying to users.
            public var description: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(description: String? = nil, expand: [String]? = nil, metadata: Metadata? = nil) {
                self.description = description
                self.expand = expand
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(description, forKey: "description")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths.Topups.WithTopup {
    public var cancel: Cancel {
        Cancel(path: path + "/cancel")
    }

    public struct Cancel {
        /// Path: `/v1/topups/{topup}/cancel`
        public let path: String

        /// <p>Cancels a top-up. Only pending top-ups can be canceled.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Topup> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?

            public init(expand: [String]? = nil) {
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var transfers: Transfers {
        Transfers(path: "/v1/transfers")
    }

    public struct Transfers {
        /// Path: `/v1/transfers`
        public let path: String

        /// <p>Returns a list of existing transfers sent to connected accounts. The transfers are returned in sorted order, with the most recently created transfers appearing first.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// TransferList
        public struct GetResponse: Decodable {
            /// Details about each object.
            public var data: [StripeAPI.Transfer]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.Transfer], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var created: Created?
            public var destination: String?
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?
            public var transferGroup: String?

            public struct Created: Codable {
                /// Range_query_specs
                public var object: Object?
                public var int: Int?

                /// Range_query_specs
                public struct Object: Codable {
                    public var gt: Int?
                    public var gte: Int?
                    public var lt: Int?
                    public var lte: Int?

                    public init(gt: Int? = nil, gte: Int? = nil, lt: Int? = nil, lte: Int? = nil) {
                        self.gt = gt
                        self.gte = gte
                        self.lt = lt
                        self.lte = lte
                    }

                    public var asQuery: [(String, String?)] {
                        let encoder = URLQueryEncoder()
                        encoder.encode(gt, forKey: "gt")
                        encoder.encode(gte, forKey: "gte")
                        encoder.encode(lt, forKey: "lt")
                        encoder.encode(lte, forKey: "lte")
                        return encoder.items
                    }
                }

                public init(object: Object? = nil, int: Int? = nil) {
                    self.object = object
                    self.int = int
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(object, forKey: "object")
                    encoder.encode(int, forKey: "int")
                    return encoder.items
                }
            }

            public init(created: Created? = nil, destination: String? = nil, endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil, transferGroup: String? = nil) {
                self.created = created
                self.destination = destination
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
                self.transferGroup = transferGroup
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(created, forKey: "created", isDeepObject: true)
                encoder.encode(destination, forKey: "destination")
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                encoder.encode(transferGroup, forKey: "transfer_group")
                return encoder.items
            }
        }

        /// <p>To send funds from your Stripe account to a connected account, you create a new transfer object. Your <a href="#balance">Stripe balance</a> must be able to cover the transfer amount, or you’ll receive an “Insufficient Funds” error.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.Transfer> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// A positive integer in %s representing how much to transfer.
            public var amount: Int?
            /// 3-letter [ISO code for currency](https://stripe.com/docs/payouts).
            public var currency: String
            /// An arbitrary string attached to the object. Often useful for displaying to users.
            public var description: String?
            /// The ID of a connected Stripe account. <a href="/docs/connect/charges-transfers">See the Connect documentation</a> for details.
            public var destination: String
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: [String: String]?
            /// You can use this parameter to transfer funds from a charge before they are added to your available balance. A pending balance will transfer immediately but the funds will not become available until the original charge becomes available. [See the Connect documentation](https://stripe.com/docs/connect/charges-transfers#transfer-availability) for details.
            public var sourceTransaction: String?
            /// The source balance to use for this transfer. One of `bank_account`, `card`, or `fpx`. For most users, this will default to `card`.
            public var sourceType: SourceType?
            /// A string that identifies this transaction as part of a group. See the [Connect documentation](https://stripe.com/docs/connect/charges-transfers#transfer-options) for details.
            public var transferGroup: String?

            /// The source balance to use for this transfer. One of `bank_account`, `card`, or `fpx`. For most users, this will default to `card`.
            public enum SourceType: String, Codable, CaseIterable {
                case bankAccount = "bank_account"
                case card
                case fpx
            }

            public init(amount: Int? = nil, currency: String, description: String? = nil, destination: String, expand: [String]? = nil, metadata: [String: String]? = nil, sourceTransaction: String? = nil, sourceType: SourceType? = nil, transferGroup: String? = nil) {
                self.amount = amount
                self.currency = currency
                self.description = description
                self.destination = destination
                self.expand = expand
                self.metadata = metadata
                self.sourceTransaction = sourceTransaction
                self.sourceType = sourceType
                self.transferGroup = transferGroup
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(currency, forKey: "currency")
                encoder.encode(description, forKey: "description")
                encoder.encode(destination, forKey: "destination")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(sourceTransaction, forKey: "source_transaction")
                encoder.encode(sourceType, forKey: "source_type")
                encoder.encode(transferGroup, forKey: "transfer_group")
                return encoder.items
            }
        }
    }
}

extension Paths.Transfers {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/transfers/{id}`
        public let path: String
    }
}

extension Paths.Transfers.WithID {
    public var reversals: Reversals {
        Reversals(path: path + "/reversals")
    }

    public struct Reversals {
        /// Path: `/v1/transfers/{id}/reversals`
        public let path: String

        /// <p>You can see a list of the reversals belonging to a specific transfer. Note that the 10 most recent reversals are always available by default on the transfer object. If you need more than those 10, you can use this API method and the <code>limit</code> and <code>starting_after</code> parameters to page through additional reversals.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// TransferReversalList
        public struct GetResponse: Decodable {
            /// Details about each object.
            public var data: [StripeAPI.TransferReversal]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.TransferReversal], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>When you create a new reversal, you must specify a transfer to create it on.</p>
        /// 
        /// <p>When reversing transfers, you can optionally reverse part of the transfer. You can do so as many times as you wish until the entire transfer has been reversed.</p>
        /// 
        /// <p>Once entirely reversed, a transfer can’t be reversed again. This method will return an error when called on an already-reversed transfer, or when trying to reverse more money than is left on a transfer.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.TransferReversal> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// A positive integer in %s representing how much of this transfer to reverse. Can only reverse up to the unreversed amount remaining of the transfer. Partial transfer reversals are only allowed for transfers to Stripe Accounts. Defaults to the entire transfer amount.
            public var amount: Int?
            /// An arbitrary string which you can attach to a reversal object. It is displayed alongside the reversal in the Dashboard. This will be unset if you POST an empty value.
            public var description: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// Boolean indicating whether the application fee should be refunded when reversing this transfer. If a full transfer reversal is given, the full application fee will be refunded. Otherwise, the application fee will be refunded with an amount proportional to the amount of the transfer reversed.
            public var isRefundApplicationFee: Bool?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(amount: Int? = nil, description: String? = nil, expand: [String]? = nil, metadata: Metadata? = nil, isRefundApplicationFee: Bool? = nil) {
                self.amount = amount
                self.description = description
                self.expand = expand
                self.metadata = metadata
                self.isRefundApplicationFee = isRefundApplicationFee
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(amount, forKey: "amount")
                encoder.encode(description, forKey: "description")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(isRefundApplicationFee, forKey: "refund_application_fee")
                return encoder.items
            }
        }
    }
}

extension Paths.Transfers {
    public func transfer(_ transfer: String) -> WithTransfer {
        WithTransfer(path: "\(path)/\(transfer)")
    }

    public struct WithTransfer {
        /// Path: `/v1/transfers/{transfer}`
        public let path: String

        /// <p>Retrieves the details of an existing transfer. Supply the unique transfer ID from either a transfer creation request or the transfer list, and Stripe will return the corresponding transfer information.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.Transfer> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the specified transfer by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
        /// 
        /// <p>This request accepts only metadata as an argument.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.Transfer> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// An arbitrary string attached to the object. Often useful for displaying to users.
            public var description: String?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(description: String? = nil, expand: [String]? = nil, metadata: Metadata? = nil) {
                self.description = description
                self.expand = expand
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(description, forKey: "description")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths.Transfers.WithTransfer {
    public var reversals: Reversals {
        Reversals(path: path + "/reversals")
    }

    public struct Reversals {
        /// Path: `/v1/transfers/{transfer}/reversals`
        public let path: String
    }
}

extension Paths.Transfers.WithTransfer.Reversals {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/transfers/{transfer}/reversals/{id}`
        public let path: String

        /// <p>By default, you can see the 10 most recent reversals stored directly on the transfer object, but you can also retrieve details about a specific reversal stored on the transfer.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.TransferReversal> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the specified reversal by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
        /// 
        /// <p>This request only accepts metadata and description as arguments.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.TransferReversal> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(expand: [String]? = nil, metadata: Metadata? = nil) {
                self.expand = expand
                self.metadata = metadata
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var webhookEndpoints: WebhookEndpoints {
        WebhookEndpoints(path: "/v1/webhook_endpoints")
    }

    public struct WebhookEndpoints {
        /// Path: `/v1/webhook_endpoints`
        public let path: String

        /// <p>Returns a list of your webhook endpoints.</p>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [StripeAPI.WebhookEndpoint]
            /// True if this list has another page of items after this one that can be fetched.
            public var hasMore: Bool
            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public var object: Object
            /// The URL where this list can be accessed.
            public var url: String

            /// String representing the object's type. Objects of the same type share the same value. Always has the value `list`.
            public enum Object: String, Codable, CaseIterable {
                case list
            }

            public init(data: [StripeAPI.WebhookEndpoint], hasMore: Bool, object: Object, url: String) {
                self.data = data
                self.hasMore = hasMore
                self.object = object
                self.url = url
            }

            private enum CodingKeys: String, CodingKey {
                case data
                case hasMore = "has_more"
                case object
                case url
            }
        }

        public struct GetParameters {
            public var endingBefore: String?
            public var expand: [String]?
            public var limit: Int?
            public var startingAfter: String?

            public init(endingBefore: String? = nil, expand: [String]? = nil, limit: Int? = nil, startingAfter: String? = nil) {
                self.endingBefore = endingBefore
                self.expand = expand
                self.limit = limit
                self.startingAfter = startingAfter
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(endingBefore, forKey: "ending_before")
                encoder.encode(expand, forKey: "expand", isDeepObject: true)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(startingAfter, forKey: "starting_after")
                return encoder.items
            }
        }

        /// <p>A webhook endpoint must have a <code>url</code> and a list of <code>enabled_events</code>. You may optionally specify the Boolean <code>connect</code> parameter. If set to true, then a Connect webhook endpoint that notifies the specified <code>url</code> about events from all connected accounts is created; otherwise an account webhook endpoint that notifies the specified <code>url</code> only about events from your account is created. You can also create webhook endpoints in the <a href="https://dashboard.stripe.com/account/webhooks">webhooks settings</a> section of the Dashboard.</p>
        public func post(_ body: PostRequest) -> Request<StripeAPI.WebhookEndpoint> {
            .post(path, body: URLQueryEncoder.encode(body).percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// Events sent to this endpoint will be generated with this Stripe Version instead of your account's default Stripe Version.
            public var apiVersion: APIVersion?
            /// Whether this endpoint should receive events from connected accounts (`true`), or from your account (`false`). Defaults to `false`.
            public var isConnect: Bool?
            /// An optional description of what the webhook is used for.
            public var description: String?
            /// The list of events to enable for this endpoint. You may specify `['*']` to enable all events, except those that require explicit selection.
            public var enabledEvents: [EnabledEvent]
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The URL of the webhook endpoint.
            public var url: String

            /// Events sent to this endpoint will be generated with this Stripe Version instead of your account's default Stripe Version.
            public enum APIVersion: String, Codable, CaseIterable {
                case _20110101 = "2011-01-01"
                case _20110621 = "2011-06-21"
                case _20110628 = "2011-06-28"
                case _20110801 = "2011-08-01"
                case _20110915 = "2011-09-15"
                case _20111117 = "2011-11-17"
                case _20120223 = "2012-02-23"
                case _20120325 = "2012-03-25"
                case _20120618 = "2012-06-18"
                case _20120628 = "2012-06-28"
                case _20120709 = "2012-07-09"
                case _20120924 = "2012-09-24"
                case _20121026 = "2012-10-26"
                case _20121107 = "2012-11-07"
                case _20130211 = "2013-02-11"
                case _20130213 = "2013-02-13"
                case _20130705 = "2013-07-05"
                case _20130812 = "2013-08-12"
                case _20130813 = "2013-08-13"
                case _20131029 = "2013-10-29"
                case _20131203 = "2013-12-03"
                case _20140131 = "2014-01-31"
                case _20140313 = "2014-03-13"
                case _20140328 = "2014-03-28"
                case _20140519 = "2014-05-19"
                case _20140613 = "2014-06-13"
                case _20140617 = "2014-06-17"
                case _20140722 = "2014-07-22"
                case _20140726 = "2014-07-26"
                case _20140804 = "2014-08-04"
                case _20140820 = "2014-08-20"
                case _20140908 = "2014-09-08"
                case _20141007 = "2014-10-07"
                case _20141105 = "2014-11-05"
                case _20141120 = "2014-11-20"
                case _20141208 = "2014-12-08"
                case _20141217 = "2014-12-17"
                case _20141222 = "2014-12-22"
                case _20150111 = "2015-01-11"
                case _20150126 = "2015-01-26"
                case _20150210 = "2015-02-10"
                case _20150216 = "2015-02-16"
                case _20150218 = "2015-02-18"
                case _20150324 = "2015-03-24"
                case _20150407 = "2015-04-07"
                case _20150615 = "2015-06-15"
                case _20150707 = "2015-07-07"
                case _20150713 = "2015-07-13"
                case _20150728 = "2015-07-28"
                case _20150807 = "2015-08-07"
                case _20150819 = "2015-08-19"
                case _20150903 = "2015-09-03"
                case _20150908 = "2015-09-08"
                case _20150923 = "2015-09-23"
                case _20151001 = "2015-10-01"
                case _20151012 = "2015-10-12"
                case _20151016 = "2015-10-16"
                case _20160203 = "2016-02-03"
                case _20160219 = "2016-02-19"
                case _20160222 = "2016-02-22"
                case _20160223 = "2016-02-23"
                case _20160229 = "2016-02-29"
                case _20160307 = "2016-03-07"
                case _20160615 = "2016-06-15"
                case _20160706 = "2016-07-06"
                case _20161019 = "2016-10-19"
                case _20170127 = "2017-01-27"
                case _20170214 = "2017-02-14"
                case _20170406 = "2017-04-06"
                case _20170525 = "2017-05-25"
                case _20170605 = "2017-06-05"
                case _20170815 = "2017-08-15"
                case _20171214 = "2017-12-14"
                case _20180123 = "2018-01-23"
                case _20180205 = "2018-02-05"
                case _20180206 = "2018-02-06"
                case _20180228 = "2018-02-28"
                case _20180521 = "2018-05-21"
                case _20180727 = "2018-07-27"
                case _20180823 = "2018-08-23"
                case _20180906 = "2018-09-06"
                case _20180924 = "2018-09-24"
                case _20181031 = "2018-10-31"
                case _20181108 = "2018-11-08"
                case _20190211 = "2019-02-11"
                case _20190219 = "2019-02-19"
                case _20190314 = "2019-03-14"
                case _20190516 = "2019-05-16"
                case _20190814 = "2019-08-14"
                case _20190909 = "2019-09-09"
                case _20191008 = "2019-10-08"
                case _20191017 = "2019-10-17"
                case _20191105 = "2019-11-05"
                case _20191203 = "2019-12-03"
                case _20200302 = "2020-03-02"
                case _20200827 = "2020-08-27"
            }

            public enum EnabledEvent: String, Codable, CaseIterable {
                case asterisk = "*"
                case accountApplicationAuthorized = "account.application.authorized"
                case accountApplicationDeauthorized = "account.application.deauthorized"
                case accountExternalAccountCreated = "account.external_account.created"
                case accountExternalAccountDeleted = "account.external_account.deleted"
                case accountExternalAccountUpdated = "account.external_account.updated"
                case accountUpdated = "account.updated"
                case applicationFeeCreated = "application_fee.created"
                case applicationFeeRefundUpdated = "application_fee.refund.updated"
                case applicationFeeRefunded = "application_fee.refunded"
                case balanceAvailable = "balance.available"
                case billingPortalConfigurationCreated = "billing_portal.configuration.created"
                case billingPortalConfigurationUpdated = "billing_portal.configuration.updated"
                case capabilityUpdated = "capability.updated"
                case chargeCaptured = "charge.captured"
                case chargeDisputeClosed = "charge.dispute.closed"
                case chargeDisputeCreated = "charge.dispute.created"
                case chargeDisputeFundsReinstated = "charge.dispute.funds_reinstated"
                case chargeDisputeFundsWithdrawn = "charge.dispute.funds_withdrawn"
                case chargeDisputeUpdated = "charge.dispute.updated"
                case chargeExpired = "charge.expired"
                case chargeFailed = "charge.failed"
                case chargePending = "charge.pending"
                case chargeRefundUpdated = "charge.refund.updated"
                case chargeRefunded = "charge.refunded"
                case chargeSucceeded = "charge.succeeded"
                case chargeUpdated = "charge.updated"
                case checkoutSessionAsyncPaymentFailed = "checkout.session.async_payment_failed"
                case checkoutSessionAsyncPaymentSucceeded = "checkout.session.async_payment_succeeded"
                case checkoutSessionCompleted = "checkout.session.completed"
                case checkoutSessionExpired = "checkout.session.expired"
                case couponCreated = "coupon.created"
                case couponDeleted = "coupon.deleted"
                case couponUpdated = "coupon.updated"
                case creditNoteCreated = "credit_note.created"
                case creditNoteUpdated = "credit_note.updated"
                case creditNoteVoided = "credit_note.voided"
                case customerCreated = "customer.created"
                case customerDeleted = "customer.deleted"
                case customerDiscountCreated = "customer.discount.created"
                case customerDiscountDeleted = "customer.discount.deleted"
                case customerDiscountUpdated = "customer.discount.updated"
                case customerSourceCreated = "customer.source.created"
                case customerSourceDeleted = "customer.source.deleted"
                case customerSourceExpiring = "customer.source.expiring"
                case customerSourceUpdated = "customer.source.updated"
                case customerSubscriptionCreated = "customer.subscription.created"
                case customerSubscriptionDeleted = "customer.subscription.deleted"
                case customerSubscriptionPendingUpdateApplied = "customer.subscription.pending_update_applied"
                case customerSubscriptionPendingUpdateExpired = "customer.subscription.pending_update_expired"
                case customerSubscriptionTrialWillEnd = "customer.subscription.trial_will_end"
                case customerSubscriptionUpdated = "customer.subscription.updated"
                case customerTaxIDCreated = "customer.tax_id.created"
                case customerTaxIDDeleted = "customer.tax_id.deleted"
                case customerTaxIDUpdated = "customer.tax_id.updated"
                case customerUpdated = "customer.updated"
                case fileCreated = "file.created"
                case identityVerificationSessionCanceled = "identity.verification_session.canceled"
                case identityVerificationSessionCreated = "identity.verification_session.created"
                case identityVerificationSessionProcessing = "identity.verification_session.processing"
                case identityVerificationSessionRedacted = "identity.verification_session.redacted"
                case identityVerificationSessionRequiresInput = "identity.verification_session.requires_input"
                case identityVerificationSessionVerified = "identity.verification_session.verified"
                case invoiceCreated = "invoice.created"
                case invoiceDeleted = "invoice.deleted"
                case invoiceFinalizationFailed = "invoice.finalization_failed"
                case invoiceFinalized = "invoice.finalized"
                case invoiceMarkedUncollectible = "invoice.marked_uncollectible"
                case invoicePaid = "invoice.paid"
                case invoicePaymentActionRequired = "invoice.payment_action_required"
                case invoicePaymentFailed = "invoice.payment_failed"
                case invoicePaymentSucceeded = "invoice.payment_succeeded"
                case invoiceSent = "invoice.sent"
                case invoiceUpcoming = "invoice.upcoming"
                case invoiceUpdated = "invoice.updated"
                case invoiceVoided = "invoice.voided"
                case invoiceitemCreated = "invoiceitem.created"
                case invoiceitemDeleted = "invoiceitem.deleted"
                case invoiceitemUpdated = "invoiceitem.updated"
                case issuingAuthorizationCreated = "issuing_authorization.created"
                case issuingAuthorizationRequest = "issuing_authorization.request"
                case issuingAuthorizationUpdated = "issuing_authorization.updated"
                case issuingCardCreated = "issuing_card.created"
                case issuingCardUpdated = "issuing_card.updated"
                case issuingCardholderCreated = "issuing_cardholder.created"
                case issuingCardholderUpdated = "issuing_cardholder.updated"
                case issuingDisputeClosed = "issuing_dispute.closed"
                case issuingDisputeCreated = "issuing_dispute.created"
                case issuingDisputeFundsReinstated = "issuing_dispute.funds_reinstated"
                case issuingDisputeSubmitted = "issuing_dispute.submitted"
                case issuingDisputeUpdated = "issuing_dispute.updated"
                case issuingTransactionCreated = "issuing_transaction.created"
                case issuingTransactionUpdated = "issuing_transaction.updated"
                case mandateUpdated = "mandate.updated"
                case orderCreated = "order.created"
                case orderPaymentFailed = "order.payment_failed"
                case orderPaymentSucceeded = "order.payment_succeeded"
                case orderUpdated = "order.updated"
                case orderReturnCreated = "order_return.created"
                case paymentIntentAmountCapturableUpdated = "payment_intent.amount_capturable_updated"
                case paymentIntentCanceled = "payment_intent.canceled"
                case paymentIntentCreated = "payment_intent.created"
                case paymentIntentPaymentFailed = "payment_intent.payment_failed"
                case paymentIntentProcessing = "payment_intent.processing"
                case paymentIntentRequiresAction = "payment_intent.requires_action"
                case paymentIntentSucceeded = "payment_intent.succeeded"
                case paymentMethodAttached = "payment_method.attached"
                case paymentMethodAutomaticallyUpdated = "payment_method.automatically_updated"
                case paymentMethodDetached = "payment_method.detached"
                case paymentMethodUpdated = "payment_method.updated"
                case payoutCanceled = "payout.canceled"
                case payoutCreated = "payout.created"
                case payoutFailed = "payout.failed"
                case payoutPaid = "payout.paid"
                case payoutUpdated = "payout.updated"
                case personCreated = "person.created"
                case personDeleted = "person.deleted"
                case personUpdated = "person.updated"
                case planCreated = "plan.created"
                case planDeleted = "plan.deleted"
                case planUpdated = "plan.updated"
                case priceCreated = "price.created"
                case priceDeleted = "price.deleted"
                case priceUpdated = "price.updated"
                case productCreated = "product.created"
                case productDeleted = "product.deleted"
                case productUpdated = "product.updated"
                case promotionCodeCreated = "promotion_code.created"
                case promotionCodeUpdated = "promotion_code.updated"
                case quoteAccepted = "quote.accepted"
                case quoteCanceled = "quote.canceled"
                case quoteCreated = "quote.created"
                case quoteFinalized = "quote.finalized"
                case radarEarlyFraudWarningCreated = "radar.early_fraud_warning.created"
                case radarEarlyFraudWarningUpdated = "radar.early_fraud_warning.updated"
                case recipientCreated = "recipient.created"
                case recipientDeleted = "recipient.deleted"
                case recipientUpdated = "recipient.updated"
                case reportingReportRunFailed = "reporting.report_run.failed"
                case reportingReportRunSucceeded = "reporting.report_run.succeeded"
                case reportingReportTypeUpdated = "reporting.report_type.updated"
                case reviewClosed = "review.closed"
                case reviewOpened = "review.opened"
                case setupIntentCanceled = "setup_intent.canceled"
                case setupIntentCreated = "setup_intent.created"
                case setupIntentRequiresAction = "setup_intent.requires_action"
                case setupIntentSetupFailed = "setup_intent.setup_failed"
                case setupIntentSucceeded = "setup_intent.succeeded"
                case sigmaScheduledQueryRunCreated = "sigma.scheduled_query_run.created"
                case skuCreated = "sku.created"
                case skuDeleted = "sku.deleted"
                case skuUpdated = "sku.updated"
                case sourceCanceled = "source.canceled"
                case sourceChargeable = "source.chargeable"
                case sourceFailed = "source.failed"
                case sourceMandateNotification = "source.mandate_notification"
                case sourceRefundAttributesRequired = "source.refund_attributes_required"
                case sourceTransactionCreated = "source.transaction.created"
                case sourceTransactionUpdated = "source.transaction.updated"
                case subscriptionScheduleAborted = "subscription_schedule.aborted"
                case subscriptionScheduleCanceled = "subscription_schedule.canceled"
                case subscriptionScheduleCompleted = "subscription_schedule.completed"
                case subscriptionScheduleCreated = "subscription_schedule.created"
                case subscriptionScheduleExpiring = "subscription_schedule.expiring"
                case subscriptionScheduleReleased = "subscription_schedule.released"
                case subscriptionScheduleUpdated = "subscription_schedule.updated"
                case taxRateCreated = "tax_rate.created"
                case taxRateUpdated = "tax_rate.updated"
                case topupCanceled = "topup.canceled"
                case topupCreated = "topup.created"
                case topupFailed = "topup.failed"
                case topupReversed = "topup.reversed"
                case topupSucceeded = "topup.succeeded"
                case transferCreated = "transfer.created"
                case transferFailed = "transfer.failed"
                case transferPaid = "transfer.paid"
                case transferReversed = "transfer.reversed"
                case transferUpdated = "transfer.updated"
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(apiVersion: APIVersion? = nil, isConnect: Bool? = nil, description: String? = nil, enabledEvents: [EnabledEvent], expand: [String]? = nil, metadata: Metadata? = nil, url: String) {
                self.apiVersion = apiVersion
                self.isConnect = isConnect
                self.description = description
                self.enabledEvents = enabledEvents
                self.expand = expand
                self.metadata = metadata
                self.url = url
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(apiVersion, forKey: "api_version")
                encoder.encode(isConnect, forKey: "connect")
                encoder.encode(description, forKey: "description")
                encoder.encode(enabledEvents, forKey: "enabled_events")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(url, forKey: "url")
                return encoder.items
            }
        }
    }
}

extension Paths.WebhookEndpoints {
    public func webhookEndpoint(_ webhookEndpoint: String) -> WithWebhookEndpoint {
        WithWebhookEndpoint(path: "\(path)/\(webhookEndpoint)")
    }

    public struct WithWebhookEndpoint {
        /// Path: `/v1/webhook_endpoints/{webhook_endpoint}`
        public let path: String

        /// <p>Retrieves the webhook endpoint with the given ID.</p>
        public func get(expand: [String]? = nil) -> Request<StripeAPI.WebhookEndpoint> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand", isDeepObject: true)
            return encoder.items
        }

        /// <p>Updates the webhook endpoint. You may edit the <code>url</code>, the list of <code>enabled_events</code>, and the status of your endpoint.</p>
        public func post(_ body: PostRequest? = nil) -> Request<StripeAPI.WebhookEndpoint> {
            .post(path, body: body.map(URLQueryEncoder.encode)?.percentEncodedQuery)
        }

        public struct PostRequest: Encodable {
            /// An optional description of what the webhook is used for.
            public var description: String?
            /// Disable the webhook endpoint if set to true.
            public var isDisabled: Bool?
            /// The list of events to enable for this endpoint. You may specify `['*']` to enable all events, except those that require explicit selection.
            public var enabledEvents: [EnabledEvent]?
            /// Specifies which fields in the response should be expanded.
            public var expand: [String]?
            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public var metadata: Metadata?
            /// The URL of the webhook endpoint.
            public var url: String?

            public enum EnabledEvent: String, Codable, CaseIterable {
                case asterisk = "*"
                case accountApplicationAuthorized = "account.application.authorized"
                case accountApplicationDeauthorized = "account.application.deauthorized"
                case accountExternalAccountCreated = "account.external_account.created"
                case accountExternalAccountDeleted = "account.external_account.deleted"
                case accountExternalAccountUpdated = "account.external_account.updated"
                case accountUpdated = "account.updated"
                case applicationFeeCreated = "application_fee.created"
                case applicationFeeRefundUpdated = "application_fee.refund.updated"
                case applicationFeeRefunded = "application_fee.refunded"
                case balanceAvailable = "balance.available"
                case billingPortalConfigurationCreated = "billing_portal.configuration.created"
                case billingPortalConfigurationUpdated = "billing_portal.configuration.updated"
                case capabilityUpdated = "capability.updated"
                case chargeCaptured = "charge.captured"
                case chargeDisputeClosed = "charge.dispute.closed"
                case chargeDisputeCreated = "charge.dispute.created"
                case chargeDisputeFundsReinstated = "charge.dispute.funds_reinstated"
                case chargeDisputeFundsWithdrawn = "charge.dispute.funds_withdrawn"
                case chargeDisputeUpdated = "charge.dispute.updated"
                case chargeExpired = "charge.expired"
                case chargeFailed = "charge.failed"
                case chargePending = "charge.pending"
                case chargeRefundUpdated = "charge.refund.updated"
                case chargeRefunded = "charge.refunded"
                case chargeSucceeded = "charge.succeeded"
                case chargeUpdated = "charge.updated"
                case checkoutSessionAsyncPaymentFailed = "checkout.session.async_payment_failed"
                case checkoutSessionAsyncPaymentSucceeded = "checkout.session.async_payment_succeeded"
                case checkoutSessionCompleted = "checkout.session.completed"
                case checkoutSessionExpired = "checkout.session.expired"
                case couponCreated = "coupon.created"
                case couponDeleted = "coupon.deleted"
                case couponUpdated = "coupon.updated"
                case creditNoteCreated = "credit_note.created"
                case creditNoteUpdated = "credit_note.updated"
                case creditNoteVoided = "credit_note.voided"
                case customerCreated = "customer.created"
                case customerDeleted = "customer.deleted"
                case customerDiscountCreated = "customer.discount.created"
                case customerDiscountDeleted = "customer.discount.deleted"
                case customerDiscountUpdated = "customer.discount.updated"
                case customerSourceCreated = "customer.source.created"
                case customerSourceDeleted = "customer.source.deleted"
                case customerSourceExpiring = "customer.source.expiring"
                case customerSourceUpdated = "customer.source.updated"
                case customerSubscriptionCreated = "customer.subscription.created"
                case customerSubscriptionDeleted = "customer.subscription.deleted"
                case customerSubscriptionPendingUpdateApplied = "customer.subscription.pending_update_applied"
                case customerSubscriptionPendingUpdateExpired = "customer.subscription.pending_update_expired"
                case customerSubscriptionTrialWillEnd = "customer.subscription.trial_will_end"
                case customerSubscriptionUpdated = "customer.subscription.updated"
                case customerTaxIDCreated = "customer.tax_id.created"
                case customerTaxIDDeleted = "customer.tax_id.deleted"
                case customerTaxIDUpdated = "customer.tax_id.updated"
                case customerUpdated = "customer.updated"
                case fileCreated = "file.created"
                case identityVerificationSessionCanceled = "identity.verification_session.canceled"
                case identityVerificationSessionCreated = "identity.verification_session.created"
                case identityVerificationSessionProcessing = "identity.verification_session.processing"
                case identityVerificationSessionRedacted = "identity.verification_session.redacted"
                case identityVerificationSessionRequiresInput = "identity.verification_session.requires_input"
                case identityVerificationSessionVerified = "identity.verification_session.verified"
                case invoiceCreated = "invoice.created"
                case invoiceDeleted = "invoice.deleted"
                case invoiceFinalizationFailed = "invoice.finalization_failed"
                case invoiceFinalized = "invoice.finalized"
                case invoiceMarkedUncollectible = "invoice.marked_uncollectible"
                case invoicePaid = "invoice.paid"
                case invoicePaymentActionRequired = "invoice.payment_action_required"
                case invoicePaymentFailed = "invoice.payment_failed"
                case invoicePaymentSucceeded = "invoice.payment_succeeded"
                case invoiceSent = "invoice.sent"
                case invoiceUpcoming = "invoice.upcoming"
                case invoiceUpdated = "invoice.updated"
                case invoiceVoided = "invoice.voided"
                case invoiceitemCreated = "invoiceitem.created"
                case invoiceitemDeleted = "invoiceitem.deleted"
                case invoiceitemUpdated = "invoiceitem.updated"
                case issuingAuthorizationCreated = "issuing_authorization.created"
                case issuingAuthorizationRequest = "issuing_authorization.request"
                case issuingAuthorizationUpdated = "issuing_authorization.updated"
                case issuingCardCreated = "issuing_card.created"
                case issuingCardUpdated = "issuing_card.updated"
                case issuingCardholderCreated = "issuing_cardholder.created"
                case issuingCardholderUpdated = "issuing_cardholder.updated"
                case issuingDisputeClosed = "issuing_dispute.closed"
                case issuingDisputeCreated = "issuing_dispute.created"
                case issuingDisputeFundsReinstated = "issuing_dispute.funds_reinstated"
                case issuingDisputeSubmitted = "issuing_dispute.submitted"
                case issuingDisputeUpdated = "issuing_dispute.updated"
                case issuingTransactionCreated = "issuing_transaction.created"
                case issuingTransactionUpdated = "issuing_transaction.updated"
                case mandateUpdated = "mandate.updated"
                case orderCreated = "order.created"
                case orderPaymentFailed = "order.payment_failed"
                case orderPaymentSucceeded = "order.payment_succeeded"
                case orderUpdated = "order.updated"
                case orderReturnCreated = "order_return.created"
                case paymentIntentAmountCapturableUpdated = "payment_intent.amount_capturable_updated"
                case paymentIntentCanceled = "payment_intent.canceled"
                case paymentIntentCreated = "payment_intent.created"
                case paymentIntentPaymentFailed = "payment_intent.payment_failed"
                case paymentIntentProcessing = "payment_intent.processing"
                case paymentIntentRequiresAction = "payment_intent.requires_action"
                case paymentIntentSucceeded = "payment_intent.succeeded"
                case paymentMethodAttached = "payment_method.attached"
                case paymentMethodAutomaticallyUpdated = "payment_method.automatically_updated"
                case paymentMethodDetached = "payment_method.detached"
                case paymentMethodUpdated = "payment_method.updated"
                case payoutCanceled = "payout.canceled"
                case payoutCreated = "payout.created"
                case payoutFailed = "payout.failed"
                case payoutPaid = "payout.paid"
                case payoutUpdated = "payout.updated"
                case personCreated = "person.created"
                case personDeleted = "person.deleted"
                case personUpdated = "person.updated"
                case planCreated = "plan.created"
                case planDeleted = "plan.deleted"
                case planUpdated = "plan.updated"
                case priceCreated = "price.created"
                case priceDeleted = "price.deleted"
                case priceUpdated = "price.updated"
                case productCreated = "product.created"
                case productDeleted = "product.deleted"
                case productUpdated = "product.updated"
                case promotionCodeCreated = "promotion_code.created"
                case promotionCodeUpdated = "promotion_code.updated"
                case quoteAccepted = "quote.accepted"
                case quoteCanceled = "quote.canceled"
                case quoteCreated = "quote.created"
                case quoteFinalized = "quote.finalized"
                case radarEarlyFraudWarningCreated = "radar.early_fraud_warning.created"
                case radarEarlyFraudWarningUpdated = "radar.early_fraud_warning.updated"
                case recipientCreated = "recipient.created"
                case recipientDeleted = "recipient.deleted"
                case recipientUpdated = "recipient.updated"
                case reportingReportRunFailed = "reporting.report_run.failed"
                case reportingReportRunSucceeded = "reporting.report_run.succeeded"
                case reportingReportTypeUpdated = "reporting.report_type.updated"
                case reviewClosed = "review.closed"
                case reviewOpened = "review.opened"
                case setupIntentCanceled = "setup_intent.canceled"
                case setupIntentCreated = "setup_intent.created"
                case setupIntentRequiresAction = "setup_intent.requires_action"
                case setupIntentSetupFailed = "setup_intent.setup_failed"
                case setupIntentSucceeded = "setup_intent.succeeded"
                case sigmaScheduledQueryRunCreated = "sigma.scheduled_query_run.created"
                case skuCreated = "sku.created"
                case skuDeleted = "sku.deleted"
                case skuUpdated = "sku.updated"
                case sourceCanceled = "source.canceled"
                case sourceChargeable = "source.chargeable"
                case sourceFailed = "source.failed"
                case sourceMandateNotification = "source.mandate_notification"
                case sourceRefundAttributesRequired = "source.refund_attributes_required"
                case sourceTransactionCreated = "source.transaction.created"
                case sourceTransactionUpdated = "source.transaction.updated"
                case subscriptionScheduleAborted = "subscription_schedule.aborted"
                case subscriptionScheduleCanceled = "subscription_schedule.canceled"
                case subscriptionScheduleCompleted = "subscription_schedule.completed"
                case subscriptionScheduleCreated = "subscription_schedule.created"
                case subscriptionScheduleExpiring = "subscription_schedule.expiring"
                case subscriptionScheduleReleased = "subscription_schedule.released"
                case subscriptionScheduleUpdated = "subscription_schedule.updated"
                case taxRateCreated = "tax_rate.created"
                case taxRateUpdated = "tax_rate.updated"
                case topupCanceled = "topup.canceled"
                case topupCreated = "topup.created"
                case topupFailed = "topup.failed"
                case topupReversed = "topup.reversed"
                case topupSucceeded = "topup.succeeded"
                case transferCreated = "transfer.created"
                case transferFailed = "transfer.failed"
                case transferPaid = "transfer.paid"
                case transferReversed = "transfer.reversed"
                case transferUpdated = "transfer.updated"
            }

            /// Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to `metadata`.
            public struct Metadata: Encodable {
                public var stringString: [String: String]?
                public var object: Object?

                public enum Object: String, Codable, CaseIterable {
                    case empty = ""
                }

                public init(stringString: [String: String]? = nil, object: Object? = nil) {
                    self.stringString = stringString
                    self.object = object
                }

                public var asQuery: [(String, String?)] {
                    let encoder = URLQueryEncoder()
                    encoder.encode(stringString, forKey: "stringString")
                    encoder.encode(object, forKey: "object")
                    return encoder.items
                }
            }

            public init(description: String? = nil, isDisabled: Bool? = nil, enabledEvents: [EnabledEvent]? = nil, expand: [String]? = nil, metadata: Metadata? = nil, url: String? = nil) {
                self.description = description
                self.isDisabled = isDisabled
                self.enabledEvents = enabledEvents
                self.expand = expand
                self.metadata = metadata
                self.url = url
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(description, forKey: "description")
                encoder.encode(isDisabled, forKey: "disabled")
                encoder.encode(enabledEvents, forKey: "enabled_events")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(metadata, forKey: "metadata")
                encoder.encode(url, forKey: "url")
                return encoder.items
            }
        }

        /// <p>You can also delete webhook endpoints via the <a href="https://dashboard.stripe.com/account/webhooks">webhook endpoint management</a> page of the Stripe dashboard.</p>
        public var delete: Request<StripeAPI.DeletedWebhookEndpoint> {
            .delete(path)
        }
    }
}

public enum Paths {}
