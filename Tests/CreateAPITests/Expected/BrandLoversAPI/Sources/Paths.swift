// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var products: Products {
        Products(path: "/products")
    }

    public struct Products {
        /// Path: `/products`
        public let path: String

        /// Returns a list of products loaded into BrandLovers Marketplace
        ///
        /// Get a list of my products loaded into the Marketplace. This dosen't means that products are eligible for sale, just that they are loaded in the database.
        public func get(offset: Int? = nil, limit: Int? = nil) -> Request<BrandLoversAPI.GetProductsResponse> {
            .get(path, query: makeGetQuery(offset, limit))
        }

        private func makeGetQuery(_ offset: Int?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(offset, forKey: "offset")
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }

        /// Allows new products from the seller to be loaded into the marketplace
        ///
        /// This enpoint to creates new products in the Marketplace using `skuSellerId` as a primary key. This enpoint expects a json document with array of products. The server will load each product as an individual item that can be manipulated using your own `skuSellerId`. All requests to This endpoint are idenpontent with respect of the `skuSellerId`, this means that once a `skuSellerId` is created it cannot be re-created using this tool. In order to update use the PUT method with the correct `skuSellerId`. You can also use the POST /product to create a single product per request
        public func post(_ body: [BrandLoversAPI.Product]) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Product {
    public func skuSellerID(_ skuSellerID: String) -> WithSkuSellerID {
        WithSkuSellerID(path: "\(path)/\(skuSellerID)")
    }

    public struct WithSkuSellerID {
        /// Path: `/product/{skuSellerId}`
        public let path: String

        /// Returns details of a single product using the seller `skuSellerId`
        ///
        /// Returns detailed information of a single product with the seller `skuSellerId`. This service will return a json document with product detail, status, price, invetory among other infomarion availble in the Brand Lovers marketplace
        public var get: Request<BrandLoversAPI.GetProduct> {
            .get(path)
        }

        /// Update product details
        ///
        /// Update a single product information such as name, brand, attribute, dimension, etc. Please note that data from your request will be merged with existing data. This allows you to easliy update only certain fields without the need to re-inform the other unchanged fields. For example in order to update just the field `title` simply send just this field with new information, remaining fields will not be changed. In order to erase an item the field must be informed as its default value, for example in order to erase the `videos` field must be sent as videos:[]. The `skuSellerId` field is always mandatory in the path and in the product json Object.
        public func put(_ body: BrandLoversAPI.ProductUpdate) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths {
    public static var product: Product {
        Product(path: "/product")
    }

    public struct Product {
        /// Path: `/product`
        public let path: String

        /// Create a new product to the marketplace
        ///
        /// Use this enpoint to create a single new product to the Marketplace. This enpoint expects a json document with one product. If you whant to upload multiple products in a single API call use POST /products method. The server will load each product as an individual item that can be manipulated using your own `skuSellerId`. This system is idenpontent, this means that once a `skuSellerId` is created it cannot be re-created using this tool. In order to update, edit a product use the PUT method with the correct reference to your `skuSellerId`
        public func post(_ body: BrandLoversAPI.Product) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Products {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/products/status`
        public let path: String

        /// Returns seller products status in the marketplace
        ///
        /// Returns a list with seller products status. Please note that this endpoint will not return all details of each product, just the skuSellerId and status. Also please note that this endpoint will return 250 products per call. For full details of a given procuct use GET /product/{skuSellerId}
        public func get(offset: Int? = nil, limit: Int? = nil) -> Request<BrandLoversAPI.GetSellerProductsStatus> {
            .get(path, query: makeGetQuery(offset, limit))
        }

        private func makeGetQuery(_ offset: Int?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(offset, forKey: "offset")
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }

        /// Bulk enable/disable products in the marketplace
        ///
        /// Bulk enable/disable products in the marketplace. This endpoint requires an array of objects with the seller SKU `skuSellerId` and boolean value that defines if the product is enabled or not for sale. This endpoint can be used to set a single product or many products.
        public func put(_ body: [BrandLoversAPI.ProductStatusUpdate]) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.Products {
    public var prices: Prices {
        Prices(path: path + "/prices")
    }

    public struct Prices {
        /// Path: `/products/prices`
        public let path: String

        /// Allows bulk update of product prices.
        ///
        /// Allows bulk update of product prices. This endpoint expects a json document with an array of products with the `skuSellerId` and the new price. Server will process each new product update individually and will ackwlodge as much updates as possible, even if a single product update fails. After this request you can query product final status with GET /product/status
        public func put(_ body: [BrandLoversAPI.SellerItemPrices]) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.Products {
    public var stocks: Stocks {
        Stocks(path: path + "/stocks")
    }

    public struct Stocks {
        /// Path: `/products/stocks`
        public let path: String

        /// Bulk product stock update
        ///
        /// Bulk product stock update. This endpoint expect a array of products `skuSellerId` with new inventory data
        public func put(_ body: [BrandLoversAPI.ProductStock]) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.Product.WithSkuSellerID {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/product/{skuSellerId}/status`
        public let path: String

        /// Enable/disable a single product in the Marketplace
        ///
        /// Update product status in the Marketplace. Set to `true` to enable, `false` to disable sale.
        public func put(_ body: BrandLoversAPI.SellerItemStatus) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.Product.WithSkuSellerID {
    public var stock: Stock {
        Stock(path: path + "/stock")
    }

    public struct Stock {
        /// Path: `/product/{skuSellerId}/stock`
        public let path: String

        /// Update a single product stock
        ///
        /// Update a single product inventory information. Products with zero stock will not be eligible for sale.
        public func put(_ body: BrandLoversAPI.Stock) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.Product.WithSkuSellerID {
    public var prices: Prices {
        Prices(path: path + "/prices")
    }

    public struct Prices {
        /// Path: `/product/{skuSellerId}/prices`
        public let path: String

        /// Allows seller to update prices of a single SKU
        ///
        /// Allows seller to set the SKU prices (MSRP and/or offer price). All prices must be informed in cents. No commas or periods are accepeted. For example one dollar should be informed as 100. Same as $1,2345.67 must be informed solely as 1234567
        public func put(_ body: BrandLoversAPI.ProductPrice) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.Products.Status {
    public var selling: Selling {
        Selling(path: path + "/selling")
    }

    public struct Selling {
        /// Path: `/products/status/selling`
        public let path: String

        /// Returns products that are successfully listed for sale.
        public func get(offset: Int? = nil, limit: Int? = nil) -> Request<BrandLoversAPI.GetProductsStatusSelling> {
            .get(path, query: makeGetQuery(offset, limit))
        }

        private func makeGetQuery(_ offset: Int?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(offset, forKey: "offset")
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths {
    public static var orders: Orders {
        Orders(path: "/orders")
    }

    public struct Orders {
        /// Path: `/orders`
        public let path: String

        /// Returns orders details
        ///
        /// Retuns a list of orders associated with this seller. The list is ordered by dateCreated.
        public func get(offset: Int? = nil, limit: Int? = nil) -> Request<BrandLoversAPI.GetOrders> {
            .get(path, query: makeGetQuery(offset, limit))
        }

        private func makeGetQuery(_ offset: Int?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(offset, forKey: "offset")
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths.Orders {
    public var shipments: Shipments {
        Shipments(path: path + "/shipments")
    }

    public struct Shipments {
        /// Path: `/orders/shipments`
        public let path: String
    }
}

extension Paths.Orders.Shipments {
    public var delivered: Delivered {
        Delivered(path: path + "/delivered")
    }

    public struct Delivered {
        /// Path: `/orders/shipments/delivered`
        public let path: String

        /// Returns list of shipments
        ///
        /// Returns list of shipments. By default this will return list of the last shipments ordered by dateCreated, folowed by last update date.
        public func get(parameters: GetParameters? = nil) -> Request<BrandLoversAPI.GetOrdersShipments> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var status: String?
            public var offset: Int?
            public var limit: Int?

            public init(status: String? = nil, offset: Int? = nil, limit: Int? = nil) {
                self.status = status
                self.offset = offset
                self.limit = limit
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(status, forKey: "status")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(limit, forKey: "limit")
                return encoder.items
            }
        }

        /// Bulk update of order shipments
        ///
        /// Bulk update of order shipments status. This alows to inform multiple shipments status
        public func post(_ body: BrandLoversAPI.OrdersShipments) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Orders.Shipments {
    public var shipped: Shipped {
        Shipped(path: path + "/shipped")
    }

    public struct Shipped {
        /// Path: `/orders/shipments/shipped`
        public let path: String

        /// Returns a list of shipments shipped
        ///
        /// Returns a list of shipments shipped. By Default returns items ordered by dateCreated folowed by last update
        public func get(parameters: GetParameters? = nil) -> Request<BrandLoversAPI.GetOrdersShipments> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var status: Status?
            public var offset: Int?
            public var limit: Int?

            public enum Status: String, Codable, CaseIterable {
                case new = "NEW"
                case approved = "APPROVED"
                case declined = "DECLINED"
                case pending = "PENDING"
            }

            public init(status: Status? = nil, offset: Int? = nil, limit: Int? = nil) {
                self.status = status
                self.offset = offset
                self.limit = limit
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(status, forKey: "status")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(limit, forKey: "limit")
                return encoder.items
            }
        }

        /// Bulk update of order shipments
        ///
        /// Allows bulk updates of orders shippments.
        public func post(_ body: BrandLoversAPI.OrdersShipments) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Orders {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/orders/status`
        public let path: String
    }
}

extension Paths.Orders.Status {
    public var approved: Approved {
        Approved(path: path + "/approved")
    }

    public struct Approved {
        /// Path: `/orders/status/approved`
        public let path: String

        /// Return list of approved orders
        ///
        /// Returns a list of approved orders. Orders in the `approved` state must be fullfiled imediadetelly.
        public func get(offset: Int? = nil, limit: Int? = nil) -> Request<BrandLoversAPI.GetOrders> {
            .get(path, query: makeGetQuery(offset, limit))
        }

        private func makeGetQuery(_ offset: Int?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(offset, forKey: "offset")
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths.Orders.Status {
    public var canceled: Canceled {
        Canceled(path: path + "/canceled")
    }

    public struct Canceled {
        /// Path: `/orders/status/canceled`
        public let path: String

        /// Returns lists of canceled orders
        ///
        /// Returns a list with canceled orders. Canceled orders should not be fullfiled.
        public func get(offset: Int? = nil, limit: Int? = nil) -> Request<BrandLoversAPI.GetOrders> {
            .get(path, query: makeGetQuery(offset, limit))
        }

        private func makeGetQuery(_ offset: Int?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(offset, forKey: "offset")
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths.Orders.Status {
    public var delivered: Delivered {
        Delivered(path: path + "/delivered")
    }

    public struct Delivered {
        /// Path: `/orders/status/delivered`
        public let path: String

        /// Returns a list of orders successfully delivered associated with this seller.
        public func get(offset: Int? = nil, limit: Int? = nil) -> Request<BrandLoversAPI.GetOrders> {
            .get(path, query: makeGetQuery(offset, limit))
        }

        private func makeGetQuery(_ offset: Int?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(offset, forKey: "offset")
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths.Orders.Status {
    public var new: New {
        New(path: path + "/new")
    }

    public struct New {
        /// Path: `/orders/status/new`
        public let path: String

        /// Returns a list of orders flagged as new.
        ///
        /// Returns a list of orders flagged as new. New orders should not be fullfiled until marketplace flags them as approved.
        public func get(offset: Int? = nil, limit: Int? = nil) -> Request<BrandLoversAPI.GetOrders> {
            .get(path, query: makeGetQuery(offset, limit))
        }

        private func makeGetQuery(_ offset: Int?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(offset, forKey: "offset")
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths.Orders.Status {
    public var partiallyDelivered: PartiallyDelivered {
        PartiallyDelivered(path: path + "/partiallyDelivered")
    }

    public struct PartiallyDelivered {
        /// Path: `/orders/status/partiallyDelivered`
        public let path: String

        /// Returns a list of partially deliverd orders
        ///
        /// Returns a list of partially deliverd orders. This is a list of orders with items shipped but with not all items ackwlodged as deliverd
        public func get(offset: Int? = nil, limit: Int? = nil) -> Request<BrandLoversAPI.GetOrders> {
            .get(path, query: makeGetQuery(offset, limit))
        }

        private func makeGetQuery(_ offset: Int?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(offset, forKey: "offset")
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths.Orders.Status {
    public var partiallySent: PartiallySent {
        PartiallySent(path: path + "/partiallySent")
    }

    public struct PartiallySent {
        /// Path: `/orders/status/partiallySent`
        public let path: String

        /// Returns a list of orders partially fullfiled
        ///
        /// Returns a list of orders that contain one (or more) items that where not shipped. This will list the entire order as well the items with peding shipment. Use this service to track orders that need to be fullfiled.
        public func get(offset: Int? = nil, limit: Int? = nil) -> Request<BrandLoversAPI.GetOrders> {
            .get(path, query: makeGetQuery(offset, limit))
        }

        private func makeGetQuery(_ offset: Int?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(offset, forKey: "offset")
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths.Orders.Status {
    public var sent: Sent {
        Sent(path: path + "/sent")
    }

    public struct Sent {
        /// Path: `/orders/status/sent`
        public let path: String

        /// Returns a list with orders fully sent
        ///
        /// Returns a list with orders completely fullfiled, this means orders with all items sent. Orders will ordered by dateCreated fowllowed by last update
        public func get(offset: Int? = nil, limit: Int? = nil) -> Request<BrandLoversAPI.GetOrders> {
            .get(path, query: makeGetQuery(offset, limit))
        }

        private func makeGetQuery(_ offset: Int?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(offset, forKey: "offset")
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths {
    public static var order: Order {
        Order(path: "/order")
    }

    public struct Order {
        /// Path: `/order`
        public let path: String
    }
}

extension Paths.Order {
    public func orderID(_ orderID: String) -> WithOrderID {
        WithOrderID(path: "\(path)/\(orderID)")
    }

    public struct WithOrderID {
        /// Path: `/order/{orderId}`
        public let path: String

        /// Returns all details of a order
        ///
        /// Returns all details of a single order, including last status, items shipped or not.
        public var get: Request<BrandLoversAPI.Order> {
            .get(path)
        }
    }
}

extension Paths.Order.WithOrderID {
    public var shipment: Shipment {
        Shipment(path: path + "/shipment")
    }

    public struct Shipment {
        /// Path: `/order/{orderId}/shipment`
        public let path: String
    }
}

extension Paths.Order.WithOrderID.Shipment {
    public var cancel: Cancel {
        Cancel(path: path + "/cancel")
    }

    public struct Cancel {
        /// Path: `/order/{orderId}/shipment/cancel`
        public let path: String

        /// Confirm shipment canceletion (when requested by the customer) or failure to deliver
        ///
        /// Confirm shipment canceletion (when requested by the customer) or failure to deliver one shipment
        public func post(_ body: BrandLoversAPI.NewTrackingRefund) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Order.WithOrderID.Shipment {
    public var delivered: Delivered {
        Delivered(path: path + "/delivered")
    }

    public struct Delivered {
        /// Path: `/order/{orderId}/shipment/delivered`
        public let path: String

        /// Confirms that a shipment was delivered
        ///
        /// Confirms that a shipment was delivered. Must inform quantity of successfully deliverd items even if items deliverd was less than the original order
        public func post(_ body: BrandLoversAPI.Newshipmentstatus) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Order.WithOrderID.Shipment {
    public var exchange: Exchange {
        Exchange(path: path + "/exchange")
    }

    public struct Exchange {
        /// Path: `/order/{orderId}/shipment/exchange`
        public let path: String

        /// Confirm item exchange
        ///
        /// This enpoint to confirm item exchange when failure to deliver or requested by the customer. All customer requests are tracket via trouble tickets
        public func post(_ body: BrandLoversAPI.NewTrackingRefund) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Order.WithOrderID.Shipment {
    public var `return`: Return {
        Return(path: path + "/return")
    }

    public struct Return {
        /// Path: `/order/{orderId}/shipment/return`
        public let path: String

        /// Confirm order item return and refund
        ///
        /// Use this endpoint to return and refund items froma a order. In order to fully return an order list all items and applicate quantity.
        public func post(_ body: BrandLoversAPI.NewTrackingRefund) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Order.WithOrderID.Shipment {
    public var sent: Sent {
        Sent(path: path + "/sent")
    }

    public struct Sent {
        /// Path: `/order/{orderId}/shipment/sent`
        public let path: String

        /// Update new order to include shipment information
        ///
        /// Updates order to include shipment shiped information. This endpoint can be used to include a single or multiple shipments for any give order. In order to inform that all items of a order where shipped list all of them, including applicable quantities in the payload.
        public func post(_ body: BrandLoversAPI.Newshipmentstatus) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths {
    public static var tickets: Tickets {
        Tickets(path: "/tickets")
    }

    public struct Tickets {
        /// Path: `/tickets`
        public let path: String

        /// Get customers trouble tickets
        ///
        /// Allows seller to receive and status, queries, requests and complaints from customers. As well related messages
        public func get(parameters: GetParameters? = nil) -> Request<BrandLoversAPI.GetTickets> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var status: Status?
            public var offset: Int?
            public var limit: Int?

            public enum Status: String, Codable, CaseIterable {
                case `open` = "OPEN"
                case reopened = "REOPENED"
                case closed = "CLOSED"
            }

            public init(status: Status? = nil, offset: Int? = nil, limit: Int? = nil) {
                self.status = status
                self.offset = offset
                self.limit = limit
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(status, forKey: "status")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(limit, forKey: "limit")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var ticket: Ticket {
        Ticket(path: "/ticket")
    }

    public struct Ticket {
        /// Path: `/ticket`
        public let path: String

        /// Creates a new trouble ticket
        ///
        /// Use this service to create a new trouble ticket. Use this to include relevant information about the order, comunicate with the customer or marketplace team. Whenever possible message will be pushed to Mobile first. This is the primary mean of comunicaiton with the customer regarding orders, shippments, shippments status. New tickets will be automatically be set to 'OPEN'. Trouble tickets need to be associated with a orderId or customer. New tickets can optionally include a new message.
        public func post(_ body: BrandLoversAPI.NewTicket) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Ticket {
    public func ticketID(_ ticketID: String) -> WithTicketID {
        WithTicketID(path: "\(path)/\(ticketID)")
    }

    public struct WithTicketID {
        /// Path: `/ticket/{ticketId}`
        public let path: String
    }
}

extension Paths.Ticket.WithTicketID {
    public var messages: Messages {
        Messages(path: path + "/messages")
    }

    public struct Messages {
        /// Path: `/ticket/{ticketId}/messages`
        public let path: String

        /// Get trouble ticket messages
        ///
        /// Returns trouble ticket history with all messages exchanged. Only tickets related to your seller will be returned. Attempt to read other tickets will return 403 (acess denied).
        public func get(offset: Int? = nil, limit: Int? = nil) -> Request<BrandLoversAPI.GetTicketMessages> {
            .get(path, query: makeGetQuery(offset, limit))
        }

        private func makeGetQuery(_ offset: Int?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(offset, forKey: "offset")
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths.Ticket.WithTicketID {
    public var message: Message {
        Message(path: path + "/message")
    }

    public struct Message {
        /// Path: `/ticket/{ticketId}/message`
        public let path: String

        /// Add new message to trouble ticket
        ///
        /// Add a new message to this trouble ticket. Messages can be `CUSTOMER` (customer will be able to see it) or `INTERNAL`.
        public func post(_ body: BrandLoversAPI.NewTicketMessage) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Ticket.WithTicketID {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/ticket/{ticketId}/status`
        public let path: String

        /// Update trouble ticket status
        ///
        /// Alows the seller to update the status of a trouble ticket
        public func put(_ body: BrandLoversAPI.TicketStatus) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

public enum Paths {}
