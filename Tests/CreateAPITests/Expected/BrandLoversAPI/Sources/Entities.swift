// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

public struct Metadata: Codable {
    /// JSON attribute key
    public var key: String
    /// JSON object value
    public var value: String

    public init(key: String, value: String) {
        self.key = key
        self.value = value
    }
}

public struct Error: Codable {
    /// Error type
    public var type: String
    /// Friendly message describing the error
    public var message: String
    /// When applicabe will include `skuSellerId` related to this error
    public var skuSellerID: String?

    public init(type: String, message: String, skuSellerID: String? = nil) {
        self.type = type
        self.message = message
        self.skuSellerID = skuSellerID
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case message
        case skuSellerID = "skuSellerId"
    }
}

public struct GetProductsResponse: Codable {
    public var skus: [GetProduct]?
    /// Payload with response
    public var metadata: [Metadata]?

    public init(skus: [GetProduct]? = nil, metadata: [Metadata]? = nil) {
        self.skus = skus
        self.metadata = metadata
    }
}

public struct Product: Codable {
    /// Brand Lovers Product ID. Use this to suggest a product association. This field is optional.
    public var productID: String?
    /// Unique Product Id (SKU) in the seller system
    public var skuSellerID: String
    /// Unique Product Group ID. Products with the same `productGroupId` will be grouped and displayed as a unique entry. Use `productGroupId` to group diferent SKUs that represent diferent colors, sizes, capacities, etc..
    public var productGroupID: String?
    /// Product name as advertised by manufacturer. This how the product will be displayed in the Marketplace
    public var title: String
    /// Product description.
    public var description: String
    /// Brand name
    public var brand: String
    /// Array of product EAN and/or ISBN and/or ASIN codes
    public var gtin: [String]?
    /// Array of categories associated with this product
    public var categories: [String]
    /// List of valid Product image URLs. HTTP or HTTPS are valid. HTTPS is prefered.
    public var images: [String]
    /// List of videos de URLs associated with this product. HTTP or HTTPS are valid. HTTPS is prefered.
    public var videos: [String]?
    public var price: ProductPrice
    /// Number of products availble for sale from the seller. Each new successfull order will automatically reduce the number of products available.
    public var stock: Int
    public var dimensions: Dimensions?
    public var giftWrap: GiftWrap?
    /// List of `key` `value` attributes of this product. This is very important for search and SEO optmization. Include all relevant information
    public var attributes: [ProductAttribute]

    public init(productID: String? = nil, skuSellerID: String, productGroupID: String? = nil, title: String, description: String, brand: String, gtin: [String]? = nil, categories: [String], images: [String], videos: [String]? = nil, price: ProductPrice, stock: Int, dimensions: Dimensions? = nil, giftWrap: GiftWrap? = nil, attributes: [ProductAttribute]) {
        self.productID = productID
        self.skuSellerID = skuSellerID
        self.productGroupID = productGroupID
        self.title = title
        self.description = description
        self.brand = brand
        self.gtin = gtin
        self.categories = categories
        self.images = images
        self.videos = videos
        self.price = price
        self.stock = stock
        self.dimensions = dimensions
        self.giftWrap = giftWrap
        self.attributes = attributes
    }

    private enum CodingKeys: String, CodingKey {
        case productID = "productId"
        case skuSellerID = "skuSellerId"
        case productGroupID = "productGroupId"
        case title
        case description
        case brand
        case gtin
        case categories
        case images
        case videos
        case price
        case stock
        case dimensions
        case giftWrap
        case attributes
    }
}

public struct ProductUpdate: Codable {
    /// Brand Lovers Product Id. Use this to recommend a product association
    public var productID: String?
    /// Unique Product Id (SKU) in the seller system
    public var skuSellerID: String
    /// Unique Product Group ID. Products with the same `productGroupId` will be grouped and displayed as a unique entry. Use `productGroupId` to group diferent SKUs that represent diferent colors, sizes, capacities, etc..
    public var productGroupID: String?
    /// Product name as advertised by manufacturer. This how the product will be displayed in the Marketplace
    public var title: String?
    /// Product text description.
    public var description: String?
    /// Brand name
    public var brand: String?
    /// Array of product EAN and/or ISBN and/or ASIN codes
    public var gtin: [String]?
    /// Array of categories associated with this product
    public var categories: [String]?
    /// List of valid Product image URLs. HTTP or HTTPS are valid. HTTPS is prefered.
    public var images: [String]?
    /// List of videos de URLs associated with this product. HTTP or HTTPS are valid. HTTPS is prefered.
    public var videos: [String]?
    public var price: ProductPrice?
    /// Number of products availble for sale from the seller. Each new successfull order will automatically reduce the number of products available.
    public var stock: Int?
    public var dimensions: Dimensions?
    public var giftWrap: GiftWrap?
    /// List of `key` `value` attributes of this product. This is very important for search and SEO optmization. Include all relevant information
    public var attributes: [ProductAttribute]?

    public init(productID: String? = nil, skuSellerID: String, productGroupID: String? = nil, title: String? = nil, description: String? = nil, brand: String? = nil, gtin: [String]? = nil, categories: [String]? = nil, images: [String]? = nil, videos: [String]? = nil, price: ProductPrice? = nil, stock: Int? = nil, dimensions: Dimensions? = nil, giftWrap: GiftWrap? = nil, attributes: [ProductAttribute]? = nil) {
        self.productID = productID
        self.skuSellerID = skuSellerID
        self.productGroupID = productGroupID
        self.title = title
        self.description = description
        self.brand = brand
        self.gtin = gtin
        self.categories = categories
        self.images = images
        self.videos = videos
        self.price = price
        self.stock = stock
        self.dimensions = dimensions
        self.giftWrap = giftWrap
        self.attributes = attributes
    }

    private enum CodingKeys: String, CodingKey {
        case productID = "productId"
        case skuSellerID = "skuSellerId"
        case productGroupID = "productGroupId"
        case title
        case description
        case brand
        case gtin
        case categories
        case images
        case videos
        case price
        case stock
        case dimensions
        case giftWrap
        case attributes
    }
}

public struct GetProduct: Codable {
    /// Unique Product Id (SKU) in the seller system
    public var skuSellerID: String
    /// Unique Product Group ID. Products with the same `productGroupId` will be grouped and displayed as a unique entry. Use `productGroupId` to group diferent SKUs that represent diferent colors, sizes, capacities, etc..
    public var productGroupID: String?
    /// Product name as advertised by manufacturer. This how the product will be displayed in the Marketplace
    public var title: String
    /// Product text description.
    public var description: String
    /// Brand name
    public var brand: String
    /// Array of product EAN and/or ISBN and/or ASIN codes
    public var gtin: [String]?
    /// Array of categories associated with this product
    public var categories: [String]
    /// List of valid Product image URLs. HTTP or HTTPS are valid. HTTPS is prefered.
    public var images: [String]
    /// List of videos de URLs associated with this product. HTTP or HTTPS are valid. HTTPS is prefered.
    public var videos: [String]?
    public var price: ProductPrice
    /// Number of products availble for sale from the seller. Each new successfull order will automatically reduce the number of products available.
    public var stock: Int
    public var dimensions: Dimensions?
    public var giftWrap: GiftWrap?
    public var attributes: [ProductAttribute]
    /// Product status
    public var status: String
    public var errors: [Error]?

    public init(skuSellerID: String, productGroupID: String? = nil, title: String, description: String, brand: String, gtin: [String]? = nil, categories: [String], images: [String], videos: [String]? = nil, price: ProductPrice, stock: Int, dimensions: Dimensions? = nil, giftWrap: GiftWrap? = nil, attributes: [ProductAttribute], status: String, errors: [Error]? = nil) {
        self.skuSellerID = skuSellerID
        self.productGroupID = productGroupID
        self.title = title
        self.description = description
        self.brand = brand
        self.gtin = gtin
        self.categories = categories
        self.images = images
        self.videos = videos
        self.price = price
        self.stock = stock
        self.dimensions = dimensions
        self.giftWrap = giftWrap
        self.attributes = attributes
        self.status = status
        self.errors = errors
    }

    private enum CodingKeys: String, CodingKey {
        case skuSellerID = "skuSellerId"
        case productGroupID = "productGroupId"
        case title
        case description
        case brand
        case gtin
        case categories
        case images
        case videos
        case price
        case stock
        case dimensions
        case giftWrap
        case attributes
        case status
        case errors
    }
}

public struct ProductAttribute: Codable {
    /// Attribute name
    public var name: String
    /// Attribute value
    public var value: String

    public init(name: String, value: String) {
        self.name = name
        self.value = value
    }
}

public struct Dimensions: Codable {
    /// Product weight in Grams. No commas or periods are accepeted. For example one killo must be informed as 1000. Another example 1 Kilo and 234 grams should be informed solely as 1234
    public var weight: Int
    /// Product length in millimeters. No commas or periods are accepeted. For example one meter produc must be informed as 1000. Another example 1 meter and 23 centimeters should be informed solely as 1230
    public var length: Int
    /// Product width in millimeters. No commas or periods are accepeted. For example one meter produc must be informed as 1000. Another example 1 meter and 23 centimeters should be informed solely as 1230
    public var width: Int
    /// Product height in millimeters. No commas or periods are accepeted. For example one meter produc must be informed as 1000. Another example 1 meter and 23 centimeters should be informed solely as 1230
    public var height: Int

    public init(weight: Int, length: Int, width: Int, height: Int) {
        self.weight = weight
        self.length = length
        self.width = width
        self.height = height
    }
}

public struct GiftWrap: Codable {
    /// Flag that defines if this product is eligible for giftwrapping
    public var isAvailable: Bool
    /// Amount charged for gift wrap. All prices must be provided in cents. No commas or periods are accepeted. For example one dollar should be informed as 100. $1,2345.67 should be informed solely as 1234567
    public var value: Int
    /// Flag that defines if seller supports giftwrapp with a message
    public var isMessageSupport: Bool?

    public init(isAvailable: Bool, value: Int, isMessageSupport: Bool? = nil) {
        self.isAvailable = isAvailable
        self.value = value
        self.isMessageSupport = isMessageSupport
    }

    private enum CodingKeys: String, CodingKey {
        case isAvailable = "available"
        case value
        case isMessageSupport = "messageSupport"
    }
}

public struct GetOrdersShipments: Codable {
    /// Order Shippment Status
    public var shipments: [OrderShippmentStatus]?
    /// Response payload
    public var metadata: [Metadata]?

    public init(shipments: [OrderShippmentStatus]? = nil, metadata: [Metadata]? = nil) {
        self.shipments = shipments
        self.metadata = metadata
    }
}

public struct OrderShippmentStatus: Codable {
    /// Shippment unique Id
    public var shipmentID: String?
    /// Courier tracking URL
    public var trackingURL: String?
    public var items: [OrderItemReference]?
    /// Shipment status
    public var status: String?
    public var errors: [Error]?

    public init(shipmentID: String? = nil, trackingURL: String? = nil, items: [OrderItemReference]? = nil, status: String? = nil, errors: [Error]? = nil) {
        self.shipmentID = shipmentID
        self.trackingURL = trackingURL
        self.items = items
        self.status = status
        self.errors = errors
    }

    private enum CodingKeys: String, CodingKey {
        case shipmentID = "shipmentId"
        case trackingURL = "trackingUrl"
        case items
        case status
        case errors
    }
}

public struct OrdersShipments: Codable {
    public var shipments: [OrderShippment]?

    public init(shipments: [OrderShippment]? = nil) {
        self.shipments = shipments
    }
}

public struct OrderShippment: Codable {
    /// Order unique Id
    public var order: String?
    public var items: [OrderItemReference]?
    /// Shipment status.
    public var status: String?
    /// Date that this shippment was shiped
    public var occurredAt: Date?
    /// Courier tracking URL
    public var trackingURL: String?
    /// Courier unique trackign Id associated with this shipment
    public var number: String?
    /// Unique Seller shipment Id. This must be unique across all orders and shipments
    public var sellerShipmentID: String?
    /// Conhecimento de Transporte Eletôniconico
    public var cte: String?
    public var courier: Courier?
    public var invoice: Invoice?

    public init(order: String? = nil, items: [OrderItemReference]? = nil, status: String? = nil, occurredAt: Date? = nil, trackingURL: String? = nil, number: String? = nil, sellerShipmentID: String? = nil, cte: String? = nil, courier: Courier? = nil, invoice: Invoice? = nil) {
        self.order = order
        self.items = items
        self.status = status
        self.occurredAt = occurredAt
        self.trackingURL = trackingURL
        self.number = number
        self.sellerShipmentID = sellerShipmentID
        self.cte = cte
        self.courier = courier
        self.invoice = invoice
    }

    private enum CodingKeys: String, CodingKey {
        case order
        case items
        case status
        case occurredAt
        case trackingURL = "trackingUrl"
        case number
        case sellerShipmentID = "sellerShipmentId"
        case cte
        case courier
        case invoice
    }
}

public struct OrderItemReference: Codable {
    /// Unique Product Id (SKU) in the seller system. This is the key that defines witch product will be updated
    public var skuSellerID: String
    /// Quantity of items
    public var quantity: Int

    public init(skuSellerID: String, quantity: Int) {
        self.skuSellerID = skuSellerID
        self.quantity = quantity
    }

    private enum CodingKeys: String, CodingKey {
        case skuSellerID = "skuSellerId"
        case quantity
    }
}

public struct GetSellerProductsStatus: Codable {
    /// Status of the products from the seller
    public var skus: [GetSellerProductStatus]?
    /// Response payload
    public var metadata: [Metadata]?

    public init(skus: [GetSellerProductStatus]? = nil, metadata: [Metadata]? = nil) {
        self.skus = skus
        self.metadata = metadata
    }
}

public struct GetSellerProductStatus: Codable {
    /// Unique Product Id (SKU) in the seller system.
    public var skuSellerID: String
    /// Product status in the marketplace
    public var status: String
    public var price: ProductPrice
    /// Number of products availble for sale from the seller. Each new successfull order will automatically reduce the number of products available.
    public var stock: Int
    public var errors: [Error]?

    public init(skuSellerID: String, status: String, price: ProductPrice, stock: Int, errors: [Error]? = nil) {
        self.skuSellerID = skuSellerID
        self.status = status
        self.price = price
        self.stock = stock
        self.errors = errors
    }

    private enum CodingKeys: String, CodingKey {
        case skuSellerID = "skuSellerId"
        case status
        case price
        case stock
        case errors
    }
}

public struct ProductStatusUpdate: Codable {
    /// Seller product unique Id that will be updated
    public var skuSellerID: String
    /// Defines if this product is ready for sale. Active `true`, disabled `false`
    public var isActive: Bool

    public init(skuSellerID: String, isActive: Bool) {
        self.skuSellerID = skuSellerID
        self.isActive = isActive
    }

    private enum CodingKeys: String, CodingKey {
        case skuSellerID = "skuSellerId"
        case isActive = "active"
    }
}

public struct SellerItemStatus: Codable {
    /// Defines if this product is ready for sale. Active `true`, disabled `false`
    public var isActive: Bool

    public init(isActive: Bool) {
        self.isActive = isActive
    }

    private enum CodingKeys: String, CodingKey {
        case isActive = "active"
    }
}

public struct SellerItemPrices: Codable {
    /// Unique product Id from seller that will be updated
    public var skuSellerID: String
    public var price: ProductPrice

    public init(skuSellerID: String, price: ProductPrice) {
        self.skuSellerID = skuSellerID
        self.price = price
    }

    private enum CodingKeys: String, CodingKey {
        case skuSellerID = "skuSellerId"
        case price
    }
}

public struct ProductPrice: Codable {
    /// List price, also known as MSRP (Manufacturer Suggest Retail Price) or the recommended retail price (RRP). All prices must be provided in cents. No commas or periods are accepeted. For example one dollar should be informed as 100. $1,2345.67 should be informed solely as 1234567
    public var `default`: Int
    /// Product price. This is what will be offered to the customer. All prices must be provided in cents. No commas or periods are accepeted. For example one dollar should be informed as 100. $1,2345.67 should be informed solely as 1234567
    public var offer: Int

    public init(`default`: Int, offer: Int) {
        self.default = `default`
        self.offer = offer
    }

    private enum CodingKeys: String, CodingKey {
        case `default` = "default"
        case offer
    }
}

public struct ProductStock: Codable {
    /// Unique Product Id (SKU) in the seller system
    public var skuSellerID: String
    /// Invetory information
    public var stocks: [Stock]

    public init(skuSellerID: String, stocks: [Stock]) {
        self.skuSellerID = skuSellerID
        self.stocks = stocks
    }

    private enum CodingKeys: String, CodingKey {
        case skuSellerID = "skuSellerId"
        case stocks
    }
}

public struct Stock: Codable {
    /// Stock available
    public var quantity: Int
    /// Time it will take to manufacture, prepare or setup this product. Time must be provided in seconds. For example 1 day should be informed as 86400. This time will be included in the product ETA informed to the customer
    public var crossDockingTime: Int?

    public init(quantity: Int, crossDockingTime: Int? = nil) {
        self.quantity = quantity
        self.crossDockingTime = crossDockingTime
    }
}

public struct Courier: Codable {
    /// Courier name
    public var name: String
    /// Courier taxId information. For example CNPJ
    public var taxID: String?

    public init(name: String, taxID: String? = nil) {
        self.name = name
        self.taxID = taxID
    }
}

public struct Invoice: Codable {
    /// CNPJ responsável pelo envio dos produtos. Pode ser diferente caso a empresa possua diversos Centros de Distribuição (CDs)
    public var cnpj: String?
    /// Número da Nota Fiscal
    public var number: String
    /// Número de serie da Nota Fiscal
    public var serie: String
    /// Data de emissão da Nota Fiscal
    public var issuedAt: Date?
    /// Número da chave de acesso à nota fiscal. A chave possui 44 dígitos e contém todas as informações da DANFE
    public var accessKey: String
    /// Url para consulta da NFE
    public var linkXml: String?
    /// Url para consulta da DANFE
    public var linkDanfe: String?

    public init(cnpj: String? = nil, number: String, serie: String, issuedAt: Date? = nil, accessKey: String, linkXml: String? = nil, linkDanfe: String? = nil) {
        self.cnpj = cnpj
        self.number = number
        self.serie = serie
        self.issuedAt = issuedAt
        self.accessKey = accessKey
        self.linkXml = linkXml
        self.linkDanfe = linkDanfe
    }
}

public struct GetProductsStatusSelling: Codable {
    public var sellerItems: [SellerItem]
    public var metadata: [Metadata]

    public init(sellerItems: [SellerItem], metadata: [Metadata]) {
        self.sellerItems = sellerItems
        self.metadata = metadata
    }
}

public struct SellerItem: Codable {
    /// Unique Product Id (SKU) in the seller system
    public var skuSellerID: String
    /// Product name as advertised by manufacturer. This how the product will be displayed in the Marketplace
    public var title: String
    /// Brand name
    public var brand: String
    /// Array of product EAN and/or ISBN and/or ASIN codes
    public var gtin: [String]?
    /// Product status for each marketplace that this product is listed
    public var status: [SellerItemStatus]
    /// Price information for each marketplace that this product is listed
    public var prices: [ProductPrice]
    /// Invetory information for each marketplace that this product is listed
    public var stocks: [ControlledStock]
    /// List of URLs where the product is listed for sale
    public var urls: [ProductSiteReference]?
    /// List of valid Product image URLs.
    public var images: [Image]
    public var product: ProductReference
    public var dimensions: Dimensions
    public var giftWrap: GiftWrap?
    public var attributes: [ProductAttribute]

    public init(skuSellerID: String, title: String, brand: String, gtin: [String]? = nil, status: [SellerItemStatus], prices: [ProductPrice], stocks: [ControlledStock], urls: [ProductSiteReference]? = nil, images: [Image], product: ProductReference, dimensions: Dimensions, giftWrap: GiftWrap? = nil, attributes: [ProductAttribute]) {
        self.skuSellerID = skuSellerID
        self.title = title
        self.brand = brand
        self.gtin = gtin
        self.status = status
        self.prices = prices
        self.stocks = stocks
        self.urls = urls
        self.images = images
        self.product = product
        self.dimensions = dimensions
        self.giftWrap = giftWrap
        self.attributes = attributes
    }

    private enum CodingKeys: String, CodingKey {
        case skuSellerID = "skuSellerId"
        case title
        case brand
        case gtin
        case status
        case prices
        case stocks
        case urls
        case images
        case product
        case dimensions
        case giftWrap
        case attributes
    }
}

public struct ProductReference: Codable {
    /// ID do recurso
    public var id: String
    /// Link para acesso ao recurso
    public var href: String

    public init(id: String, href: String) {
        self.id = id
        self.href = href
    }
}

public struct ControlledStock: Codable {
    /// Quantity of product available for sale
    public var quantity: Int
    /// Locked product invetory for orders that are not approved and are not ready to fullfil.
    public var reserved: Int?
    /// Time it will take to manufacture, prepare or setup this product. Time must be provided in seconds. For example 1 day should be informed as 86400. This time will be included in the ETA informed to the customer
    public var crossDockingTime: Int?

    public init(quantity: Int, reserved: Int? = nil, crossDockingTime: Int? = nil) {
        self.quantity = quantity
        self.reserved = reserved
        self.crossDockingTime = crossDockingTime
    }
}

public struct Image: Codable {
    /// Image format
    public var type: String
    /// Sets as main image
    public var isMain: Bool
    /// Image URL
    public var url: String

    public init(type: String, isMain: Bool, url: String) {
        self.type = type
        self.isMain = isMain
        self.url = url
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case isMain = "main"
        case url
    }
}

public struct ProductSiteReference: Codable {
    /// Seller unique product Id
    public var skuSellerID: String
    /// Link do produto no site
    public var url: String

    public init(skuSellerID: String, url: String) {
        self.skuSellerID = skuSellerID
        self.url = url
    }

    private enum CodingKeys: String, CodingKey {
        case skuSellerID = "skuSellerId"
        case url
    }
}

public struct GetOrders: Codable {
    public var orders: [Order]
    public var metadata: [Metadata]

    public init(orders: [Order], metadata: [Metadata]) {
        self.orders = orders
        self.metadata = metadata
    }
}

public struct Order: Codable {
    /// Unique order Id (related to this seller)
    public var orderID: String
    /// Unique Order Id that will be displayed to the customer. This Id is not the same as `orderId`
    public var orderMarketplaceID: String
    /// Date that this order was created
    public var createdAt: Date
    /// Date that this order was approved for fullfilment
    public var approvedAt: Date?
    /// Last update data of this order
    public var updatedAt: Date
    /// Order status
    public var status: String
    /// Order total in cents, this is what the customer will be charged for. No commas or periods are accepeted. For example one dollar should be informed as 100. $1,2345.67 should be informed solely as 1234567
    public var totalAmount: Int
    /// Order items total amount in cents. No commas or periods are accepeted. For example one dollar should be informed as 100. $1,2345.67 should be informed solely as 1234567
    public var totalItemsAmount: Int
    /// Total shipments amount items. No commas or periods are accepeted. For example one dollar should be informed as 100. $1,2345.67 should be informed solely as 1234567
    public var totalShippingAmount: Int
    /// Total order discounts in cents. No commas or periods are accepeted. For example one dollar should be informed as 100. $1,2345.67 should be informed solely as 1234567
    public var totalDiscountAmount: Int
    public var billingAddress: Address
    public var customer: Customer
    public var freight: Freight
    public var items: [OrderItem]
    public var shippingAddress: Address
    public var shipments: [Shippment]
    public var seller: Seller?

    public init(orderID: String, orderMarketplaceID: String, createdAt: Date, approvedAt: Date? = nil, updatedAt: Date, status: String, totalAmount: Int, totalItemsAmount: Int, totalShippingAmount: Int, totalDiscountAmount: Int, billingAddress: Address, customer: Customer, freight: Freight, items: [OrderItem], shippingAddress: Address, shipments: [Shippment], seller: Seller? = nil) {
        self.orderID = orderID
        self.orderMarketplaceID = orderMarketplaceID
        self.createdAt = createdAt
        self.approvedAt = approvedAt
        self.updatedAt = updatedAt
        self.status = status
        self.totalAmount = totalAmount
        self.totalItemsAmount = totalItemsAmount
        self.totalShippingAmount = totalShippingAmount
        self.totalDiscountAmount = totalDiscountAmount
        self.billingAddress = billingAddress
        self.customer = customer
        self.freight = freight
        self.items = items
        self.shippingAddress = shippingAddress
        self.shipments = shipments
        self.seller = seller
    }

    private enum CodingKeys: String, CodingKey {
        case orderID = "orderId"
        case orderMarketplaceID = "orderMarketplaceId"
        case createdAt
        case approvedAt
        case updatedAt
        case status
        case totalAmount
        case totalItemsAmount
        case totalShippingAmount
        case totalDiscountAmount
        case billingAddress
        case customer
        case freight
        case items
        case shippingAddress
        case shipments
        case seller
    }
}

public struct Seller: Codable {
    /// Seller unique Id in the Brand Lovers Marketplace
    public var id: String?
    /// Seller name in the Brand Lovers Marketplace
    public var name: String?

    public init(id: String? = nil, name: String? = nil) {
        self.id = id
        self.name = name
    }
}

public struct Customer: Codable {
    /// Customer unqiue Id
    public var id: String
    /// Customer Name
    public var name: String
    /// Customer tax information
    public var documentNumber: String
    /// Customer type: Enterprise or Consumer
    public var type: String
    /// Customer Email (when available). Please note: Email is not a mandatory field
    public var email: String?
    /// Customer phone number
    public var phones: [Phone]

    public init(id: String, name: String, documentNumber: String, type: String, email: String? = nil, phones: [Phone]) {
        self.id = id
        self.name = name
        self.documentNumber = documentNumber
        self.type = type
        self.email = email
        self.phones = phones
    }
}

public struct Phone: Codable {
    /// Phone number
    public var number: String
    /// Phone number type, home, office, mobile, etc
    public var type: String

    public init(number: String, type: String) {
        self.number = number
        self.type = type
    }
}

public struct OrderItem: Codable {
    /// Unique Id representing this item
    public var id: String
    /// Unique Product Id (SKU) in the seller system
    public var skuSellerID: String
    /// Product name
    public var name: String
    /// Product unit price
    public var salePrice: Int
    /// Flag if product was already shipped
    public var isSent: Bool
    public var freight: Freight
    public var giftWrap: OrderGiftWrap?
    /// Promotions array
    public var promotions: [Promotion]?

    public init(id: String, skuSellerID: String, name: String, salePrice: Int, isSent: Bool, freight: Freight, giftWrap: OrderGiftWrap? = nil, promotions: [Promotion]? = nil) {
        self.id = id
        self.skuSellerID = skuSellerID
        self.name = name
        self.salePrice = salePrice
        self.isSent = isSent
        self.freight = freight
        self.giftWrap = giftWrap
        self.promotions = promotions
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case skuSellerID = "skuSellerId"
        case name
        case salePrice
        case isSent = "sent"
        case freight
        case giftWrap
        case promotions
    }
}

public struct Promotion: Codable {
    /// Promotion unique idenfitcation number
    public var id: String
    /// Promotion name
    public var name: String?
    /// Total discount in cents. No commas or periods are accepeted. For example one dollar should be informed as 100. $1,2345.67 should be informed solely as 1234567
    public var amount: Int?
    /// Promotion type
    public var type: String?

    public init(id: String, name: String? = nil, amount: Int? = nil, type: String? = nil) {
        self.id = id
        self.name = name
        self.amount = amount
        self.type = type
    }
}

public struct OrderGiftWrap: Codable {
    /// Defines if giftwrpping is available for this product.
    public var isAvailable: Bool
    /// Amount charged for gift wrap. All prices must be provided in cents. No commas or periods are accepeted. For example one dollar should be informed as 100. $1,2345.67 should be informed solely as 1234567
    public var value: Int
    /// Defines if giftwrpping is available for this product.
    public var isMessageSupport: Bool?
    public var giftCard: GiftCard?

    public init(isAvailable: Bool, value: Int, isMessageSupport: Bool? = nil, giftCard: GiftCard? = nil) {
        self.isAvailable = isAvailable
        self.value = value
        self.isMessageSupport = isMessageSupport
        self.giftCard = giftCard
    }

    private enum CodingKeys: String, CodingKey {
        case isAvailable = "available"
        case value
        case isMessageSupport = "messageSupport"
        case giftCard
    }
}

public struct GiftCard: Codable {
    /// Giftcard `from` field
    public var from: String
    /// Giftcard `to` field
    public var to: String
    /// Giftcard `body` message
    public var message: String

    public init(from: String, to: String, message: String) {
        self.from = from
        self.to = to
        self.message = message
    }
}

public struct Freight: Codable {
    /// Default value of this shippment.
    public var defaultAmount: Int
    /// Shipment cost. Must be informed in cents. No commas or periods are accepeted. For example one dollar should be informed as 100. Same as $1,2345.67 must be informed solely as 1234567
    public var chargedAmount: Int
    /// Deliver time in seconds. Time must be provided in seconds. For example 1 day should be informed as 86400. This time will be included in the product ETA informed to the customer
    public var transitTime: Int
    /// Time it will take to manufacture, prepare or setup this product. Time must be provided in seconds. For example 1 day should be informed as 86400. This time will be included in the product ETA informed to the customer
    public var crossDockingTime: Int
    /// Aditional information for the courier
    public var additionalInfo: String
    /// Freight type
    public var type: String?
    /// Estimated time of arrival
    public var eta: Date?
    /// Scheduled period
    public var scheduledPeriod: String?

    public init(defaultAmount: Int, chargedAmount: Int, transitTime: Int, crossDockingTime: Int, additionalInfo: String, type: String? = nil, eta: Date? = nil, scheduledPeriod: String? = nil) {
        self.defaultAmount = defaultAmount
        self.chargedAmount = chargedAmount
        self.transitTime = transitTime
        self.crossDockingTime = crossDockingTime
        self.additionalInfo = additionalInfo
        self.type = type
        self.eta = eta
        self.scheduledPeriod = scheduledPeriod
    }

    private enum CodingKeys: String, CodingKey {
        case defaultAmount
        case chargedAmount
        case transitTime
        case crossDockingTime
        case additionalInfo
        case type
        case eta = "ETA"
        case scheduledPeriod
    }
}

public struct Shippment: Codable {
    /// List of items of this shippment
    public var items: [OrderItemReference]
    /// Shipment status
    public var status: String
    /// Additinal shipment tracking information
    public var description: String?
    /// Date time when this shippment happened
    public var occurredAt: Date
    /// Courier tracking URL
    public var trackingURL: String?
    /// Courier unique trackign Id associated with this shipment
    public var number: String?
    /// Shipment Id associated with this shippment used to group diferent item or items from a single order
    public var id: String?
    /// Unique Seller shipment Id. This must be unique across all orders and shipments
    public var sellerShipmentID: String
    /// Conhecimento de Transporte Eletrônico
    public var cte: String?
    public var courier: Courier
    public var invoice: Invoice

    public init(items: [OrderItemReference], status: String, description: String? = nil, occurredAt: Date, trackingURL: String? = nil, number: String? = nil, id: String? = nil, sellerShipmentID: String, cte: String? = nil, courier: Courier, invoice: Invoice) {
        self.items = items
        self.status = status
        self.description = description
        self.occurredAt = occurredAt
        self.trackingURL = trackingURL
        self.number = number
        self.id = id
        self.sellerShipmentID = sellerShipmentID
        self.cte = cte
        self.courier = courier
        self.invoice = invoice
    }

    private enum CodingKeys: String, CodingKey {
        case items
        case status
        case description
        case occurredAt
        case trackingURL = "trackingUrl"
        case number
        case id
        case sellerShipmentID = "sellerShipmentId"
        case cte
        case courier
        case invoice
    }
}

public struct Newshipmentstatus: Codable {
    /// List of Order IDs of this items from this order that will be updated in this shipment
    public var items: [String]
    /// Data da ocorrência
    public var occurredAt: Date
    /// Courier tracking URL
    public var trackingURL: String?
    /// Unique id shipment Id in the courier system
    public var number: String?
    /// Unique Seller shipment Id. This must be unique across all orders and shipmnents
    public var sellerShipmentID: String
    /// Conhecimento do Transporte Eletrônico
    public var cte: String?
    public var courier: Courier
    public var invoice: Invoice

    public init(items: [String], occurredAt: Date, trackingURL: String? = nil, number: String? = nil, sellerShipmentID: String, cte: String? = nil, courier: Courier, invoice: Invoice) {
        self.items = items
        self.occurredAt = occurredAt
        self.trackingURL = trackingURL
        self.number = number
        self.sellerShipmentID = sellerShipmentID
        self.cte = cte
        self.courier = courier
        self.invoice = invoice
    }

    private enum CodingKeys: String, CodingKey {
        case items
        case occurredAt
        case trackingURL = "trackingUrl"
        case number
        case sellerShipmentID = "sellerShipmentId"
        case cte
        case courier
        case invoice
    }
}

public struct NewTrackingRefund: Codable {
    public var items: [OrderItemReference]
    /// Aditional information about this shippment
    public var info: String
    /// Date time that this was created
    public var occurredAt: Date?
    /// Courier tracking URL
    public var tranckingURL: String?
    /// Tracking Id in the courier
    public var number: String?
    /// Unique Seller shipment Id. This must be unique across all orders and shipments
    public var sellerShipmentID: String?
    /// Conhecimento do Transporte Eletrônico
    public var cte: String?
    public var courier: Courier?

    public init(items: [OrderItemReference], info: String, occurredAt: Date? = nil, tranckingURL: String? = nil, number: String? = nil, sellerShipmentID: String? = nil, cte: String? = nil, courier: Courier? = nil) {
        self.items = items
        self.info = info
        self.occurredAt = occurredAt
        self.tranckingURL = tranckingURL
        self.number = number
        self.sellerShipmentID = sellerShipmentID
        self.cte = cte
        self.courier = courier
    }

    private enum CodingKeys: String, CodingKey {
        case items
        case info
        case occurredAt
        case tranckingURL = "tranckingUrl"
        case number
        case sellerShipmentID = "sellerShipmentId"
        case cte
        case courier
    }
}

public struct Address: Codable {
    /// Address first line (ave, street name, etc..)
    public var address: String
    /// Address number
    public var number: String
    /// Complementary info (aptartament number, building name, suite)
    public var complement: String
    /// Address neighbourhood
    public var neighbourhood: String
    /// Pontos de referência
    public var reference: String?
    /// City
    public var city: String
    /// State
    public var state: String
    /// Contry code using aplpha ISO-3166, Example: BR, US, AR, GB, CN
    public var countryID: String
    /// Zip Code
    public var zipCode: String
    /// Recipient Name
    public var recipientName: String?

    public init(address: String, number: String, complement: String, neighbourhood: String, reference: String? = nil, city: String, state: String, countryID: String, zipCode: String, recipientName: String? = nil) {
        self.address = address
        self.number = number
        self.complement = complement
        self.neighbourhood = neighbourhood
        self.reference = reference
        self.city = city
        self.state = state
        self.countryID = countryID
        self.zipCode = zipCode
        self.recipientName = recipientName
    }

    private enum CodingKeys: String, CodingKey {
        case address
        case number
        case complement
        case neighbourhood
        case reference
        case city
        case state
        case countryID = "countryId"
        case zipCode
        case recipientName
    }
}

public struct NewTicket: Codable {
    /// Unique order Id that this trouble ticket belongs to
    public var orderID: String
    /// Friendly name of the person sending this message, if not provided the seller `name` will be used
    public var from: String
    /// Message to the customer
    public var body: String
    public var message: NewTicketMessage?
    /// Trouble ticket type.
    public var type: String
    /// Trouble ticked brief description
    public var description: String?
    public var customer: CustomerReference?

    public init(orderID: String, from: String, body: String, message: NewTicketMessage? = nil, type: String, description: String? = nil, customer: CustomerReference? = nil) {
        self.orderID = orderID
        self.from = from
        self.body = body
        self.message = message
        self.type = type
        self.description = description
        self.customer = customer
    }

    private enum CodingKeys: String, CodingKey {
        case orderID = "orderId"
        case from
        case body
        case message
        case type
        case description
        case customer
    }
}

public struct GetTickets: Codable {
    public var tickets: [Ticket]?
    public var metadata: [Metadata]?

    public init(tickets: [Ticket]? = nil, metadata: [Metadata]? = nil) {
        self.tickets = tickets
        self.metadata = metadata
    }
}

public struct Ticket: Codable {
    /// Trouble Ticket unique identification Id
    public var ticketID: String?
    /// Trouble Ticket status. 'OPEN','CLOSED','REOPENED'
    public var status: String?
    /// Trouble ticket type.
    public var type: String?
    /// Trouble ticked brief description
    public var description: String?
    /// Date time that ticket was created
    public var createdAt: Date?
    /// Date-time with last update of this ticket
    public var updatedAt: Date?
    /// Date-time when ticket was closed
    public var closedAt: Date?
    /// Trouble ticket priority
    public var priority: String?
    public var customer: CustomerReference?
    /// Short one line title describing ticket.
    public var subject: String?
    /// Date-time with a promisse for the customer when this ticket will be resolved
    public var sla: Date?
    public var metadata: [Metadata]?

    public init(ticketID: String? = nil, status: String? = nil, type: String? = nil, description: String? = nil, createdAt: Date? = nil, updatedAt: Date? = nil, closedAt: Date? = nil, priority: String? = nil, customer: CustomerReference? = nil, subject: String? = nil, sla: Date? = nil, metadata: [Metadata]? = nil) {
        self.ticketID = ticketID
        self.status = status
        self.type = type
        self.description = description
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.closedAt = closedAt
        self.priority = priority
        self.customer = customer
        self.subject = subject
        self.sla = sla
        self.metadata = metadata
    }

    private enum CodingKeys: String, CodingKey {
        case ticketID = "ticketId"
        case status
        case type
        case description
        case createdAt
        case updatedAt
        case closedAt
        case priority
        case customer
        case subject
        case sla
        case metadata
    }
}

public struct CustomerReference: Codable {
    /// Customer name
    public var name: String?
    /// Customer phone mumber
    public var phoneNumber: String?

    public init(name: String? = nil, phoneNumber: String? = nil) {
        self.name = name
        self.phoneNumber = phoneNumber
    }
}

public struct NewTicketMessage: Codable {
    /// Defines if this message is `CUSTOMER` (customer will receive a copy) or `INTERNAL`
    public var visibility: String
    /// Message text
    public var body: String

    public init(visibility: String, body: String) {
        self.visibility = visibility
        self.body = body
    }
}

public struct GetTicketMessages: Codable {
    public var messages: [TicketMessage]?
    public var metadata: [Metadata]

    public init(messages: [TicketMessage]? = nil, metadata: [Metadata]) {
        self.messages = messages
        self.metadata = metadata
    }
}

public struct TicketMessage: Codable {
    /// Date created
    public var createdAt: Date
    /// Trouble Ticket Id.
    public var id: String
    /// Message text
    public var body: String
    /// Defines if this message is `CUSTOMER` (customer will receive a copy) or `INTERNAL`
    public var visibility: String

    public init(createdAt: Date, id: String, body: String, visibility: String) {
        self.createdAt = createdAt
        self.id = id
        self.body = body
        self.visibility = visibility
    }
}

public struct TicketStatus: Codable {
    /// New trouble ticket status. Valid options are `REOPENED`, `CLOSED`
    public var ticketStatus: String

    public init(ticketStatus: String) {
        self.ticketStatus = ticketStatus
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
