// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get

extension Paths {
    public static var users: Users {
        Users(path: "/2/users")
    }

    public struct Users {
        /// Path: `/2/users`
        public let path: String

        /// User lookup by IDs
        ///
        /// This endpoint returns information about users. Specify users by their ID.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.MultiUserLookupResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The list of fields you can expand for a [User](#User) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["pinned_tweet_id"]
            public var expansions: [Expansions]?
            /// The list of fields you can display for a [Tweet](#Tweet) object.
            ///
            /// Example: ["created_at", "author_id", "entities", "conversation_id", "reply_settings", "public_metrics"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can display for a [User](#User) object.
            ///
            /// Example: ["username", "verified", "profile_image_url"]
            public var userFields: [UserFields]?

            public enum Expansions: String, Codable, CaseIterable {
                case pinnedTweetID = "pinned_tweet_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case text
                case authorID = "author_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweets = "referenced_tweets"
                case attachments
                case withheld
                case geo
                case entities
                case publicMetrics = "public_metrics"
                case possiblySensitive = "possibly_sensitive"
                case source
                case lang
                case contextAnnotations = "context_annotations"
                case nonPublicMetrics = "non_public_metrics"
                case promotedMetrics = "promoted_metrics"
                case organicMetrics = "organic_metrics"
                case conversationID = "conversation_id"
                case replySettings = "reply_settings"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case name
                case username
                case protected
                case verified
                case withheld
                case profileImageURL = "profile_image_url"
                case location
                case url
                case description
                case entities
                case pinnedTweetID = "pinned_tweet_id"
                case publicMetrics = "public_metrics"
            }

            public init(expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil, userFields: [UserFields]? = nil) {
                self.expansions = expansions
                self.tweetFields = tweetFields
                self.userFields = userFields
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("tweet.fields", tweetFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("user.fields", userFields?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.Users {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/2/users/{id}`
        public let path: String

        /// User lookup by ID
        ///
        /// This endpoint returns information about a user. Specify user by ID.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.SingleUserLookupResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The list of fields you can expand for a [User](#User) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["pinned_tweet_id"]
            public var expansions: [Expansions]?
            /// The list of fields you can display for a [Tweet](#Tweet) object.
            ///
            /// Example: ["created_at", "author_id", "entities", "conversation_id", "reply_settings", "public_metrics"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can display for a [User](#User) object.
            ///
            /// Example: ["username", "verified", "profile_image_url"]
            public var userFields: [UserFields]?

            public enum Expansions: String, Codable, CaseIterable {
                case pinnedTweetID = "pinned_tweet_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case text
                case authorID = "author_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweets = "referenced_tweets"
                case attachments
                case withheld
                case geo
                case entities
                case publicMetrics = "public_metrics"
                case possiblySensitive = "possibly_sensitive"
                case source
                case lang
                case contextAnnotations = "context_annotations"
                case nonPublicMetrics = "non_public_metrics"
                case promotedMetrics = "promoted_metrics"
                case organicMetrics = "organic_metrics"
                case conversationID = "conversation_id"
                case replySettings = "reply_settings"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case name
                case username
                case protected
                case verified
                case withheld
                case profileImageURL = "profile_image_url"
                case location
                case url
                case description
                case entities
                case pinnedTweetID = "pinned_tweet_id"
                case publicMetrics = "public_metrics"
            }

            public init(expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil, userFields: [UserFields]? = nil) {
                self.expansions = expansions
                self.tweetFields = tweetFields
                self.userFields = userFields
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("tweet.fields", tweetFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("user.fields", userFields?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.Users {
    public var by: By {
        By(path: path + "/by")
    }

    public struct By {
        /// Path: `/2/users/by`
        public let path: String

        /// User lookup by usernames
        ///
        /// This endpoint returns information about users. Specify users by their username.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.MultiUserLookupResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The list of fields you can expand for a [User](#User) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["pinned_tweet_id"]
            public var expansions: [Expansions]?
            /// The list of fields you can display for a [Tweet](#Tweet) object.
            ///
            /// Example: ["created_at", "author_id", "entities", "conversation_id", "reply_settings", "public_metrics"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can display for a [User](#User) object.
            ///
            /// Example: ["username", "verified", "profile_image_url"]
            public var userFields: [UserFields]?

            public enum Expansions: String, Codable, CaseIterable {
                case pinnedTweetID = "pinned_tweet_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case text
                case authorID = "author_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweets = "referenced_tweets"
                case attachments
                case withheld
                case geo
                case entities
                case publicMetrics = "public_metrics"
                case possiblySensitive = "possibly_sensitive"
                case source
                case lang
                case contextAnnotations = "context_annotations"
                case nonPublicMetrics = "non_public_metrics"
                case promotedMetrics = "promoted_metrics"
                case organicMetrics = "organic_metrics"
                case conversationID = "conversation_id"
                case replySettings = "reply_settings"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case name
                case username
                case protected
                case verified
                case withheld
                case profileImageURL = "profile_image_url"
                case location
                case url
                case description
                case entities
                case pinnedTweetID = "pinned_tweet_id"
                case publicMetrics = "public_metrics"
            }

            public init(expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil, userFields: [UserFields]? = nil) {
                self.expansions = expansions
                self.tweetFields = tweetFields
                self.userFields = userFields
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("tweet.fields", tweetFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("user.fields", userFields?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.Users {
    public var me: Me {
        Me(path: path + "/me")
    }

    public struct Me {
        /// Path: `/2/users/me`
        public let path: String

        /// User lookup me
        ///
        /// This endpoint returns information about the requesting user.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.SingleUserLookupResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The list of fields you can expand for a [User](#User) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["pinned_tweet_id"]
            public var expansions: [Expansions]?
            /// The list of fields you can display for a [Tweet](#Tweet) object.
            ///
            /// Example: ["created_at", "author_id", "entities", "conversation_id", "reply_settings", "public_metrics"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can display for a [User](#User) object.
            ///
            /// Example: ["username", "verified", "profile_image_url"]
            public var userFields: [UserFields]?

            public enum Expansions: String, Codable, CaseIterable {
                case pinnedTweetID = "pinned_tweet_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case text
                case authorID = "author_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweets = "referenced_tweets"
                case attachments
                case withheld
                case geo
                case entities
                case publicMetrics = "public_metrics"
                case possiblySensitive = "possibly_sensitive"
                case source
                case lang
                case contextAnnotations = "context_annotations"
                case nonPublicMetrics = "non_public_metrics"
                case promotedMetrics = "promoted_metrics"
                case organicMetrics = "organic_metrics"
                case conversationID = "conversation_id"
                case replySettings = "reply_settings"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case name
                case username
                case protected
                case verified
                case withheld
                case profileImageURL = "profile_image_url"
                case location
                case url
                case description
                case entities
                case pinnedTweetID = "pinned_tweet_id"
                case publicMetrics = "public_metrics"
            }

            public init(expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil, userFields: [UserFields]? = nil) {
                self.expansions = expansions
                self.tweetFields = tweetFields
                self.userFields = userFields
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("tweet.fields", tweetFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("user.fields", userFields?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.Users.By {
    public var username: Username {
        Username(path: path + "/username")
    }

    public struct Username {
        /// Path: `/2/users/by/username`
        public let path: String
    }
}

extension Paths.Users.By.Username {
    public func username(_ username: String) -> WithUsername {
        WithUsername(path: "\(path)/\(username)")
    }

    public struct WithUsername {
        /// Path: `/2/users/by/username/{username}`
        public let path: String

        /// User lookup by username
        ///
        /// This endpoint returns information about a user. Specify user by username.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.SingleUserLookupResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The list of fields you can expand for a [User](#User) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["pinned_tweet_id"]
            public var expansions: [Expansions]?
            /// The list of fields you can display for a [Tweet](#Tweet) object.
            ///
            /// Example: ["created_at", "author_id", "entities", "conversation_id", "reply_settings", "public_metrics"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can display for a [User](#User) object.
            ///
            /// Example: ["username", "verified", "profile_image_url"]
            public var userFields: [UserFields]?

            public enum Expansions: String, Codable, CaseIterable {
                case pinnedTweetID = "pinned_tweet_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case text
                case authorID = "author_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweets = "referenced_tweets"
                case attachments
                case withheld
                case geo
                case entities
                case publicMetrics = "public_metrics"
                case possiblySensitive = "possibly_sensitive"
                case source
                case lang
                case contextAnnotations = "context_annotations"
                case nonPublicMetrics = "non_public_metrics"
                case promotedMetrics = "promoted_metrics"
                case organicMetrics = "organic_metrics"
                case conversationID = "conversation_id"
                case replySettings = "reply_settings"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case name
                case username
                case protected
                case verified
                case withheld
                case profileImageURL = "profile_image_url"
                case location
                case url
                case description
                case entities
                case pinnedTweetID = "pinned_tweet_id"
                case publicMetrics = "public_metrics"
            }

            public init(expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil, userFields: [UserFields]? = nil) {
                self.expansions = expansions
                self.tweetFields = tweetFields
                self.userFields = userFields
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("tweet.fields", tweetFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("user.fields", userFields?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.Users.WithID {
    public var blocking: Blocking {
        Blocking(path: path + "/blocking")
    }

    public struct Blocking {
        /// Path: `/2/users/{id}/blocking`
        public let path: String

        /// Returns user objects that are blocked by provided user ID
        ///
        /// Returns a list of users that are blocked by the provided user ID
        public func get(maxResults: Int? = nil, paginationToken: String? = nil) -> Request<TwitterAPI.GenericMultipleUsersLookupResponse> {
            .get(path, query: makeGetQuery(maxResults, paginationToken))
        }

        private func makeGetQuery(_ maxResults: Int?, _ paginationToken: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("max_results", maxResults)
            query.addQueryItem("pagination_token", paginationToken)
            return query
        }

        /// Block User by User ID
        ///
        /// Causes the user (in the path) to block the target user. The user (in the path) must match the user context authorizing the request
        public func post(targetUserID: String) -> Request<TwitterAPI.UsersBlockingMutationResponse> {
            .post(path, body: ["target_user_id": targetUserID])
        }
    }
}

extension Paths.Users {
    public func sourceUserID(_ sourceUserID: String) -> WithSourceUserID {
        WithSourceUserID(path: "\(path)/\(sourceUserID)")
    }

    public struct WithSourceUserID {
        /// Path: `/2/users/{source_user_id}`
        public let path: String
    }
}

extension Paths.Users.WithSourceUserID {
    public var blocking: Blocking {
        Blocking(path: path + "/blocking")
    }

    public struct Blocking {
        /// Path: `/2/users/{source_user_id}/blocking`
        public let path: String
    }
}

extension Paths.Users.WithSourceUserID.Blocking {
    public func targetUserID(_ targetUserID: String) -> WithTargetUserID {
        WithTargetUserID(path: "\(path)/\(targetUserID)")
    }

    public struct WithTargetUserID {
        /// Path: `/2/users/{source_user_id}/blocking/{target_user_id}`
        public let path: String

        /// Unblock User by User ID
        ///
        /// Causes the source user to unblock the target user. The source user must match the user context authorizing the request
        public var delete: Request<TwitterAPI.UsersBlockingMutationResponse> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithSourceUserID {
    public var muting: Muting {
        Muting(path: path + "/muting")
    }

    public struct Muting {
        /// Path: `/2/users/{source_user_id}/muting`
        public let path: String
    }
}

extension Paths.Users.WithSourceUserID.Muting {
    public func targetUserID(_ targetUserID: String) -> WithTargetUserID {
        WithTargetUserID(path: "\(path)/\(targetUserID)")
    }

    public struct WithTargetUserID {
        /// Path: `/2/users/{source_user_id}/muting/{target_user_id}`
        public let path: String

        /// Unmute User by User ID
        ///
        /// Causes the source user to unmute the target user. The source user must match the user context authorizing the request
        public var delete: Request<TwitterAPI.UsersMutingMutationResponse> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithID {
    public var muting: Muting {
        Muting(path: path + "/muting")
    }

    public struct Muting {
        /// Path: `/2/users/{id}/muting`
        public let path: String

        /// Returns user objects that are muted by the provided user ID
        ///
        /// Returns a list of users that are muted by the provided user ID
        public func get(maxResults: Int? = nil, paginationToken: String? = nil) -> Request<TwitterAPI.GenericMultipleUsersLookupResponse> {
            .get(path, query: makeGetQuery(maxResults, paginationToken))
        }

        private func makeGetQuery(_ maxResults: Int?, _ paginationToken: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("max_results", maxResults)
            query.addQueryItem("pagination_token", paginationToken)
            return query
        }

        /// Mute User by User ID
        ///
        /// Causes the user (in the path) to mute the target user. The user (in the path) must match the user context authorizing the request
        public func post(targetUserID: String) -> Request<TwitterAPI.UsersMutingMutationResponse> {
            .post(path, body: ["target_user_id": targetUserID])
        }
    }
}

extension Paths.Users.WithID {
    public var followers: Followers {
        Followers(path: path + "/followers")
    }

    public struct Followers {
        /// Path: `/2/users/{id}/followers`
        public let path: String

        /// Returns user objects that follow the provided user ID
        ///
        /// Returns a list of users that follow the provided user ID
        public func get(maxResults: Int? = nil, paginationToken: String? = nil) -> Request<TwitterAPI.GenericMultipleUsersLookupResponse> {
            .get(path, query: makeGetQuery(maxResults, paginationToken))
        }

        private func makeGetQuery(_ maxResults: Int?, _ paginationToken: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("max_results", maxResults)
            query.addQueryItem("pagination_token", paginationToken)
            return query
        }
    }
}

extension Paths.Users.WithID {
    public var following: Following {
        Following(path: path + "/following")
    }

    public struct Following {
        /// Path: `/2/users/{id}/following`
        public let path: String

        /// Following by User ID
        ///
        /// Returns a list of users that are being followed by the provided user ID
        public func get(maxResults: Int? = nil, paginationToken: String? = nil) -> Request<TwitterAPI.UsersFollowingLookupResponse> {
            .get(path, query: makeGetQuery(maxResults, paginationToken))
        }

        private func makeGetQuery(_ maxResults: Int?, _ paginationToken: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("max_results", maxResults)
            query.addQueryItem("pagination_token", paginationToken)
            return query
        }

        /// Follow User
        ///
        /// Causes the user(in the path) to follow, or “request to follow” for protected users, the target user. The user(in the path) must match the user context authorizing the request
        public func post(targetUserID: String) -> Request<TwitterAPI.UsersFollowingCreateResponse> {
            .post(path, body: ["target_user_id": targetUserID])
        }
    }
}

extension Paths.Users.WithSourceUserID {
    public var following: Following {
        Following(path: path + "/following")
    }

    public struct Following {
        /// Path: `/2/users/{source_user_id}/following`
        public let path: String
    }
}

extension Paths.Users.WithSourceUserID.Following {
    public func targetUserID(_ targetUserID: String) -> WithTargetUserID {
        WithTargetUserID(path: "\(path)/\(targetUserID)")
    }

    public struct WithTargetUserID {
        /// Path: `/2/users/{source_user_id}/following/{target_user_id}`
        public let path: String

        /// Unfollow User
        ///
        /// Causes the source user to unfollow the target user. The source user must match the user context authorizing the request
        public var delete: Request<TwitterAPI.UsersFollowingDeleteResponse> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithID {
    public var followedLists: FollowedLists {
        FollowedLists(path: path + "/followed_lists")
    }

    public struct FollowedLists {
        /// Path: `/2/users/{id}/followed_lists`
        public let path: String

        /// Get User's Followed Lists
        ///
        /// Returns a user's followed Lists.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.MultiListResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxResults: Int?
            public var paginationToken: Int?
            /// The fields available for a List object.
            ///
            /// Example: ["created_at", "description", "follower_count", "member_count", "name", "private"]
            public var listFields: [ListFields]?
            /// The list of fields you can expand for a [List](#List) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["owner_id"]
            public var expansions: [Expansions]?
            /// The list of fields you can display for a [User](#User) object.
            ///
            /// Example: ["username", "verified", "profile_image_url"]
            public var userFields: [UserFields]?

            public enum ListFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case followerCount = "follower_count"
                case id
                case memberCount = "member_count"
                case name
                case ownerID = "owner_id"
                case `private`
            }

            public enum Expansions: String, Codable, CaseIterable {
                case ownerID = "owner_id"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case name
                case username
                case protected
                case verified
                case withheld
                case profileImageURL = "profile_image_url"
                case location
                case url
                case description
                case entities
                case pinnedTweetID = "pinned_tweet_id"
                case publicMetrics = "public_metrics"
            }

            public init(maxResults: Int? = nil, paginationToken: Int? = nil, listFields: [ListFields]? = nil, expansions: [Expansions]? = nil, userFields: [UserFields]? = nil) {
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.listFields = listFields
                self.expansions = expansions
                self.userFields = userFields
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("max_results", maxResults)
                query.addQueryItem("pagination_token", paginationToken)
                query.addQueryItem("list.fields", listFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("user.fields", userFields?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }

        /// Follow a List
        ///
        /// Causes a user to follow a List.
        public func post(_ body: TwitterAPI.ListFollowRequest? = nil) -> Request<TwitterAPI.ListFollowedResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Users.WithID.FollowedLists {
    public func listID(_ listID: String) -> WithListID {
        WithListID(path: "\(path)/\(listID)")
    }

    public struct WithListID {
        /// Path: `/2/users/{id}/followed_lists/{list_id}`
        public let path: String

        /// Unfollow a List
        ///
        /// Causes a user to unfollow a List.
        public var delete: Request<TwitterAPI.ListFollowedResponse> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithID {
    public var listMemberships: ListMemberships {
        ListMemberships(path: path + "/list_memberships")
    }

    public struct ListMemberships {
        /// Path: `/2/users/{id}/list_memberships`
        public let path: String

        /// Get a User's List Memberships
        ///
        /// Get a User's List Memberships.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.MultiListResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxResults: Int?
            public var paginationToken: Int?
            /// The fields available for a List object.
            ///
            /// Example: ["created_at", "description", "follower_count", "member_count", "name", "private"]
            public var listFields: [ListFields]?
            /// The list of fields you can expand for a [List](#List) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["owner_id"]
            public var expansions: [Expansions]?
            /// The list of fields you can display for a [User](#User) object.
            ///
            /// Example: ["username", "verified", "profile_image_url"]
            public var userFields: [UserFields]?

            public enum ListFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case followerCount = "follower_count"
                case id
                case memberCount = "member_count"
                case name
                case ownerID = "owner_id"
                case `private`
            }

            public enum Expansions: String, Codable, CaseIterable {
                case ownerID = "owner_id"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case name
                case username
                case protected
                case verified
                case withheld
                case profileImageURL = "profile_image_url"
                case location
                case url
                case description
                case entities
                case pinnedTweetID = "pinned_tweet_id"
                case publicMetrics = "public_metrics"
            }

            public init(maxResults: Int? = nil, paginationToken: Int? = nil, listFields: [ListFields]? = nil, expansions: [Expansions]? = nil, userFields: [UserFields]? = nil) {
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.listFields = listFields
                self.expansions = expansions
                self.userFields = userFields
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("max_results", maxResults)
                query.addQueryItem("pagination_token", paginationToken)
                query.addQueryItem("list.fields", listFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("user.fields", userFields?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.Users.WithID {
    public var ownedLists: OwnedLists {
        OwnedLists(path: path + "/owned_lists")
    }

    public struct OwnedLists {
        /// Path: `/2/users/{id}/owned_lists`
        public let path: String

        /// Get a User's Owned Lists
        ///
        /// Get a User's Owned Lists.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.MultiListResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxResults: Int?
            public var paginationToken: Int?
            /// The fields available for a List object.
            ///
            /// Example: ["created_at", "description", "follower_count", "member_count", "name", "private"]
            public var listFields: [ListFields]?
            /// The list of fields you can expand for a [List](#List) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["owner_id"]
            public var expansions: [Expansions]?
            /// The list of fields you can display for a [User](#User) object.
            ///
            /// Example: ["username", "verified", "profile_image_url"]
            public var userFields: [UserFields]?

            public enum ListFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case followerCount = "follower_count"
                case id
                case memberCount = "member_count"
                case name
                case ownerID = "owner_id"
                case `private`
            }

            public enum Expansions: String, Codable, CaseIterable {
                case ownerID = "owner_id"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case name
                case username
                case protected
                case verified
                case withheld
                case profileImageURL = "profile_image_url"
                case location
                case url
                case description
                case entities
                case pinnedTweetID = "pinned_tweet_id"
                case publicMetrics = "public_metrics"
            }

            public init(maxResults: Int? = nil, paginationToken: Int? = nil, listFields: [ListFields]? = nil, expansions: [Expansions]? = nil, userFields: [UserFields]? = nil) {
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.listFields = listFields
                self.expansions = expansions
                self.userFields = userFields
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("max_results", maxResults)
                query.addQueryItem("pagination_token", paginationToken)
                query.addQueryItem("list.fields", listFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("user.fields", userFields?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.Users.WithID {
    public var pinnedLists: PinnedLists {
        PinnedLists(path: path + "/pinned_lists")
    }

    public struct PinnedLists {
        /// Path: `/2/users/{id}/pinned_lists`
        public let path: String

        /// Get a User's Pinned Lists
        ///
        /// Get a User's Pinned Lists.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.MultiListNoPaginationResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The fields available for a List object.
            ///
            /// Example: ["created_at", "description", "follower_count", "member_count", "name", "private"]
            public var listFields: [ListFields]?
            /// The list of fields you can expand for a [List](#List) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["owner_id"]
            public var expansions: [Expansions]?
            /// The list of fields you can display for a [User](#User) object.
            ///
            /// Example: ["username", "verified", "profile_image_url"]
            public var userFields: [UserFields]?

            public enum ListFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case followerCount = "follower_count"
                case id
                case memberCount = "member_count"
                case name
                case ownerID = "owner_id"
                case `private`
            }

            public enum Expansions: String, Codable, CaseIterable {
                case ownerID = "owner_id"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case name
                case username
                case protected
                case verified
                case withheld
                case profileImageURL = "profile_image_url"
                case location
                case url
                case description
                case entities
                case pinnedTweetID = "pinned_tweet_id"
                case publicMetrics = "public_metrics"
            }

            public init(listFields: [ListFields]? = nil, expansions: [Expansions]? = nil, userFields: [UserFields]? = nil) {
                self.listFields = listFields
                self.expansions = expansions
                self.userFields = userFields
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("list.fields", listFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("user.fields", userFields?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }

        /// Pin a List
        ///
        /// Causes a user to pin a List.
        public func post(_ body: TwitterAPI.ListPinRequest? = nil) -> Request<TwitterAPI.ListPinnedResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Users.WithID.PinnedLists {
    public func listID(_ listID: String) -> WithListID {
        WithListID(path: "\(path)/\(listID)")
    }

    public struct WithListID {
        /// Path: `/2/users/{id}/pinned_lists/{list_id}`
        public let path: String

        /// Unpin a List
        ///
        /// Causes a user to remove a pinned List.
        public var delete: Request<TwitterAPI.ListPinnedResponse> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var tweets: Tweets {
        Tweets(path: "/2/tweets")
    }

    public struct Tweets {
        /// Path: `/2/tweets`
        public let path: String

        /// Tweet lookup by Tweet IDs
        ///
        /// Returns a variety of information about the Tweet specified by the requested ID.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.MultiTweetLookupResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["author_id", "referenced_tweets.id", "in_reply_to_user_id", "geo.place_id", "attachments.media_keys", "attachments.poll_ids", "entities.mentions.username", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The list of fields you can display for a [Tweet](#Tweet) object.
            ///
            /// Example: ["created_at", "author_id", "entities", "conversation_id", "reply_settings", "public_metrics"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can display for a [User](#User) object.
            ///
            /// Example: ["username", "verified", "profile_image_url"]
            public var userFields: [UserFields]?
            /// The list of fields you can display for a Media object.
            ///
            /// Example: ["media_key", "duration_ms", "height", "preview_image_url", "type", "url", "width", "public_metrics"]
            public var mediaFields: [MediaFields]?
            /// The list of fields you can display for a Place object.
            ///
            /// Example: ["id", "name", "country_code", "place_type", "full_name", "country", "contained_within", "geo"]
            public var placeFields: [PlaceFields]?
            /// The list of fields you can display for a Poll object.
            ///
            /// Example: ["duration_minutes", "options", "voting_status", "end_datetime"]
            public var pollFields: [PollFields]?

            public enum Expansions: String, Codable, CaseIterable {
                case authorID = "author_id"
                case referencedTweetsID = "referenced_tweets.id"
                case inReplyToUserID = "in_reply_to_user_id"
                case geoPlaceID = "geo.place_id"
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case entitiesMentionsUsername = "entities.mentions.username"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case text
                case authorID = "author_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweets = "referenced_tweets"
                case attachments
                case withheld
                case geo
                case entities
                case publicMetrics = "public_metrics"
                case possiblySensitive = "possibly_sensitive"
                case source
                case lang
                case contextAnnotations = "context_annotations"
                case nonPublicMetrics = "non_public_metrics"
                case promotedMetrics = "promoted_metrics"
                case organicMetrics = "organic_metrics"
                case conversationID = "conversation_id"
                case replySettings = "reply_settings"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case name
                case username
                case protected
                case verified
                case withheld
                case profileImageURL = "profile_image_url"
                case location
                case url
                case description
                case entities
                case pinnedTweetID = "pinned_tweet_id"
                case publicMetrics = "public_metrics"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case mediaKey = "media_key"
                case durationMs = "duration_ms"
                case height
                case previewImageURL = "preview_image_url"
                case type
                case url
                case width
                case publicMetrics = "public_metrics"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case promotedMetrics = "promoted_metrics"
                case altText = "alt_text"
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case id
                case name
                case countryCode = "country_code"
                case placeType = "place_type"
                case fullName = "full_name"
                case country
                case containedWithin = "contained_within"
                case geo
            }

            public enum PollFields: String, Codable, CaseIterable {
                case id
                case options
                case votingStatus = "voting_status"
                case endDatetime = "end_datetime"
                case durationMinutes = "duration_minutes"
            }

            public init(expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil, userFields: [UserFields]? = nil, mediaFields: [MediaFields]? = nil, placeFields: [PlaceFields]? = nil, pollFields: [PollFields]? = nil) {
                self.expansions = expansions
                self.tweetFields = tweetFields
                self.userFields = userFields
                self.mediaFields = mediaFields
                self.placeFields = placeFields
                self.pollFields = pollFields
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("tweet.fields", tweetFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("user.fields", userFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("media.fields", mediaFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("place.fields", placeFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("poll.fields", pollFields?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }

        /// Creation of a Tweet
        ///
        /// Causes the user to create a tweet under the authorized account.
        public func post(_ body: PostRequest? = nil) -> Request<TwitterAPI.TweetCreateResponse> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The content of the Tweet.
            ///
            /// Example: "Learn how to use the user Tweet timeline and user mention timeline endpoints in the Twitter API v2 to explore Tweet\u2026 https:\/\/t.co\/56a0vZUx7i"
            public var text: String?
            /// Link to take the conversation from the public timeline to a private Direct Message.
            public var directMessageDeepLink: String?
            /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
            ///
            /// Example: "1346889436626259968"
            public var quoteTweetID: String?
            /// Exclusive Tweet for super followers.
            public var isForSuperFollowersOnly: Bool?
            /// Tweet information of the Tweet being replied to.
            public var reply: Reply?
            /// Media information being attached to created Tweet. This is mutually exclusive from Quote Tweet Id and Poll.
            public var media: Media?
            /// Poll options for a Tweet with a poll. This is mutually exclusive from Media and Quote Tweet Id.
            public var poll: Poll?
            /// Settings to indicate who can reply to the Tweet.
            public var replySettings: ReplySettings?
            /// Place ID being attached to the Tweet for geo location.
            public var geo: Geo?

            /// Tweet information of the Tweet being replied to.
            public struct Reply: Encodable {
                /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
                ///
                /// Example: "1346889436626259968"
                public var inReplyToTweetID: String?
                /// A list of User Ids to be excluded from the reply Tweet.
                public var excludeReplyUserIDs: [String]?

                public init(inReplyToTweetID: String? = nil, excludeReplyUserIDs: [String]? = nil) {
                    self.inReplyToTweetID = inReplyToTweetID
                    self.excludeReplyUserIDs = excludeReplyUserIDs
                }

                private enum CodingKeys: String, CodingKey {
                    case inReplyToTweetID = "in_reply_to_tweet_id"
                    case excludeReplyUserIDs = "exclude_reply_user_ids"
                }
            }

            /// Media information being attached to created Tweet. This is mutually exclusive from Quote Tweet Id and Poll.
            public struct Media: Encodable {
                /// A list of Media Ids to be attached to a created Tweet.
                public var mediaIDs: [String]?
                /// A list of User Ids to be tagged in the media for created Tweet.
                public var taggedUserIDs: [String]?

                public init(mediaIDs: [String]? = nil, taggedUserIDs: [String]? = nil) {
                    self.mediaIDs = mediaIDs
                    self.taggedUserIDs = taggedUserIDs
                }

                private enum CodingKeys: String, CodingKey {
                    case mediaIDs = "media_ids"
                    case taggedUserIDs = "tagged_user_ids"
                }
            }

            /// Poll options for a Tweet with a poll. This is mutually exclusive from Media and Quote Tweet Id.
            public struct Poll: Encodable {
                public var options: [String]?
                /// Duration of the poll in minutes.
                public var durationMinutes: Int?

                public init(options: [String]? = nil, durationMinutes: Int? = nil) {
                    self.options = options
                    self.durationMinutes = durationMinutes
                }

                private enum CodingKeys: String, CodingKey {
                    case options
                    case durationMinutes = "duration_minutes"
                }
            }

            /// Settings to indicate who can reply to the Tweet.
            public enum ReplySettings: String, Codable, CaseIterable {
                case following
                case mentionedUsers
            }

            /// Place ID being attached to the Tweet for geo location.
            public struct Geo: Encodable {
                public var placeID: String?

                public init(placeID: String? = nil) {
                    self.placeID = placeID
                }

                private enum CodingKeys: String, CodingKey {
                    case placeID = "place_id"
                }
            }

            public init(text: String? = nil, directMessageDeepLink: String? = nil, quoteTweetID: String? = nil, isForSuperFollowersOnly: Bool? = nil, reply: Reply? = nil, media: Media? = nil, poll: Poll? = nil, replySettings: ReplySettings? = nil, geo: Geo? = nil) {
                self.text = text
                self.directMessageDeepLink = directMessageDeepLink
                self.quoteTweetID = quoteTweetID
                self.isForSuperFollowersOnly = isForSuperFollowersOnly
                self.reply = reply
                self.media = media
                self.poll = poll
                self.replySettings = replySettings
                self.geo = geo
            }

            private enum CodingKeys: String, CodingKey {
                case text
                case directMessageDeepLink = "direct_message_deep_link"
                case quoteTweetID = "quote_tweet_id"
                case isForSuperFollowersOnly = "for_super_followers_only"
                case reply
                case media
                case poll
                case replySettings = "reply_settings"
                case geo
            }
        }
    }
}

extension Paths.Tweets {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/2/tweets/{id}`
        public let path: String

        /// Tweet lookup by Tweet ID
        ///
        /// Returns a variety of information about the Tweet specified by the requested ID.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.SingleTweetLookupResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["author_id", "referenced_tweets.id", "in_reply_to_user_id", "geo.place_id", "attachments.media_keys", "attachments.poll_ids", "entities.mentions.username", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The list of fields you can display for a [Tweet](#Tweet) object.
            ///
            /// Example: ["created_at", "author_id", "entities", "conversation_id", "reply_settings", "public_metrics"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can display for a [User](#User) object.
            ///
            /// Example: ["username", "verified", "profile_image_url"]
            public var userFields: [UserFields]?
            /// The list of fields you can display for a Media object.
            ///
            /// Example: ["media_key", "duration_ms", "height", "preview_image_url", "type", "url", "width", "public_metrics"]
            public var mediaFields: [MediaFields]?
            /// The list of fields you can display for a Place object.
            ///
            /// Example: ["id", "name", "country_code", "place_type", "full_name", "country", "contained_within", "geo"]
            public var placeFields: [PlaceFields]?
            /// The list of fields you can display for a Poll object.
            ///
            /// Example: ["duration_minutes", "options", "voting_status", "end_datetime"]
            public var pollFields: [PollFields]?

            public enum Expansions: String, Codable, CaseIterable {
                case authorID = "author_id"
                case referencedTweetsID = "referenced_tweets.id"
                case inReplyToUserID = "in_reply_to_user_id"
                case geoPlaceID = "geo.place_id"
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case entitiesMentionsUsername = "entities.mentions.username"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case text
                case authorID = "author_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweets = "referenced_tweets"
                case attachments
                case withheld
                case geo
                case entities
                case publicMetrics = "public_metrics"
                case possiblySensitive = "possibly_sensitive"
                case source
                case lang
                case contextAnnotations = "context_annotations"
                case nonPublicMetrics = "non_public_metrics"
                case promotedMetrics = "promoted_metrics"
                case organicMetrics = "organic_metrics"
                case conversationID = "conversation_id"
                case replySettings = "reply_settings"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case name
                case username
                case protected
                case verified
                case withheld
                case profileImageURL = "profile_image_url"
                case location
                case url
                case description
                case entities
                case pinnedTweetID = "pinned_tweet_id"
                case publicMetrics = "public_metrics"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case mediaKey = "media_key"
                case durationMs = "duration_ms"
                case height
                case previewImageURL = "preview_image_url"
                case type
                case url
                case width
                case publicMetrics = "public_metrics"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case promotedMetrics = "promoted_metrics"
                case altText = "alt_text"
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case id
                case name
                case countryCode = "country_code"
                case placeType = "place_type"
                case fullName = "full_name"
                case country
                case containedWithin = "contained_within"
                case geo
            }

            public enum PollFields: String, Codable, CaseIterable {
                case id
                case options
                case votingStatus = "voting_status"
                case endDatetime = "end_datetime"
                case durationMinutes = "duration_minutes"
            }

            public init(expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil, userFields: [UserFields]? = nil, mediaFields: [MediaFields]? = nil, placeFields: [PlaceFields]? = nil, pollFields: [PollFields]? = nil) {
                self.expansions = expansions
                self.tweetFields = tweetFields
                self.userFields = userFields
                self.mediaFields = mediaFields
                self.placeFields = placeFields
                self.pollFields = pollFields
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("tweet.fields", tweetFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("user.fields", userFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("media.fields", mediaFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("place.fields", placeFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("poll.fields", pollFields?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }

        /// Tweet delete by Tweet ID
        ///
        /// Delete specified Tweet (in the path) by ID.
        public var delete: Request<TwitterAPI.TweetDeleteResponse> {
            .delete(path)
        }
    }
}

extension Paths.Tweets.WithID {
    public var hidden: Hidden {
        Hidden(path: path + "/hidden")
    }

    public struct Hidden {
        /// Path: `/2/tweets/{id}/hidden`
        public let path: String

        /// Hide replies
        ///
        /// Hides or unhides a reply to an owned conversation.
        public func put(isHidden: Bool? = nil) -> Request<PutResponse> {
            .put(path, body: ["hidden": isHidden])
        }

        public struct PutResponse: Decodable {
            public var data: Data?

            public struct Data: Decodable {
                public var isHidden: Bool?

                public init(isHidden: Bool? = nil) {
                    self.isHidden = isHidden
                }

                private enum CodingKeys: String, CodingKey {
                    case isHidden = "hidden"
                }
            }

            public init(data: Data? = nil) {
                self.data = data
            }
        }
    }
}

extension Paths.Tweets {
    public var search: Search {
        Search(path: path + "/search")
    }

    public struct Search {
        /// Path: `/2/tweets/search`
        public let path: String
    }
}

extension Paths.Tweets.Search {
    public var recent: Recent {
        Recent(path: path + "/recent")
    }

    public struct Recent {
        /// Path: `/2/tweets/search/recent`
        public let path: String

        /// Recent search
        ///
        /// Returns Tweets from the last 7 days that match a search query.
        public func get(parameters: GetParameters) -> Request<TwitterAPI.TweetSearchResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            /// Example: "(from:TwitterDev OR from:TwitterAPI) has:media -is:retweet"
            public var query: String
            public var startTime: Date?
            public var endTime: Date?
            public var maxResults: Int?
            public var nextToken: String?
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["author_id", "referenced_tweets.id", "in_reply_to_user_id", "geo.place_id", "attachments.media_keys", "attachments.poll_ids", "entities.mentions.username", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The list of fields you can display for a [Tweet](#Tweet) object.
            ///
            /// Example: ["created_at", "author_id", "entities", "conversation_id", "reply_settings", "public_metrics"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can display for a [User](#User) object.
            ///
            /// Example: ["username", "verified", "profile_image_url"]
            public var userFields: [UserFields]?
            /// The list of fields you can display for a Media object.
            ///
            /// Example: ["media_key", "duration_ms", "height", "preview_image_url", "type", "url", "width", "public_metrics"]
            public var mediaFields: [MediaFields]?
            /// The list of fields you can display for a Place object.
            ///
            /// Example: ["id", "name", "country_code", "place_type", "full_name", "country", "contained_within", "geo"]
            public var placeFields: [PlaceFields]?
            /// The list of fields you can display for a Poll object.
            ///
            /// Example: ["duration_minutes", "options", "voting_status", "end_datetime"]
            public var pollFields: [PollFields]?

            public enum Expansions: String, Codable, CaseIterable {
                case authorID = "author_id"
                case referencedTweetsID = "referenced_tweets.id"
                case inReplyToUserID = "in_reply_to_user_id"
                case geoPlaceID = "geo.place_id"
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case entitiesMentionsUsername = "entities.mentions.username"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case text
                case authorID = "author_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweets = "referenced_tweets"
                case attachments
                case withheld
                case geo
                case entities
                case publicMetrics = "public_metrics"
                case possiblySensitive = "possibly_sensitive"
                case source
                case lang
                case contextAnnotations = "context_annotations"
                case nonPublicMetrics = "non_public_metrics"
                case promotedMetrics = "promoted_metrics"
                case organicMetrics = "organic_metrics"
                case conversationID = "conversation_id"
                case replySettings = "reply_settings"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case name
                case username
                case protected
                case verified
                case withheld
                case profileImageURL = "profile_image_url"
                case location
                case url
                case description
                case entities
                case pinnedTweetID = "pinned_tweet_id"
                case publicMetrics = "public_metrics"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case mediaKey = "media_key"
                case durationMs = "duration_ms"
                case height
                case previewImageURL = "preview_image_url"
                case type
                case url
                case width
                case publicMetrics = "public_metrics"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case promotedMetrics = "promoted_metrics"
                case altText = "alt_text"
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case id
                case name
                case countryCode = "country_code"
                case placeType = "place_type"
                case fullName = "full_name"
                case country
                case containedWithin = "contained_within"
                case geo
            }

            public enum PollFields: String, Codable, CaseIterable {
                case id
                case options
                case votingStatus = "voting_status"
                case endDatetime = "end_datetime"
                case durationMinutes = "duration_minutes"
            }

            public init(query: String, startTime: Date? = nil, endTime: Date? = nil, maxResults: Int? = nil, nextToken: String? = nil, expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil, userFields: [UserFields]? = nil, mediaFields: [MediaFields]? = nil, placeFields: [PlaceFields]? = nil, pollFields: [PollFields]? = nil) {
                self.query = query
                self.startTime = startTime
                self.endTime = endTime
                self.maxResults = maxResults
                self.nextToken = nextToken
                self.expansions = expansions
                self.tweetFields = tweetFields
                self.userFields = userFields
                self.mediaFields = mediaFields
                self.placeFields = placeFields
                self.pollFields = pollFields
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("query", self.query)
                query.addQueryItem("start_time", startTime)
                query.addQueryItem("end_time", endTime)
                query.addQueryItem("max_results", maxResults)
                query.addQueryItem("next_token", nextToken)
                query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("tweet.fields", tweetFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("user.fields", userFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("media.fields", mediaFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("place.fields", placeFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("poll.fields", pollFields?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.Tweets.Search {
    public var all: All {
        All(path: path + "/all")
    }

    public struct All {
        /// Path: `/2/tweets/search/all`
        public let path: String

        /// Full-archive search
        ///
        /// Returns Tweets that match a search query.
        public func get(parameters: GetParameters) -> Request<TwitterAPI.TweetSearchResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            /// Example: "(from:TwitterDev OR from:TwitterAPI) has:media -is:retweet"
            public var query: String
            public var startTime: Date?
            public var endTime: Date?
            public var maxResults: Int?
            public var nextToken: String?
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["author_id", "referenced_tweets.id", "in_reply_to_user_id", "geo.place_id", "attachments.media_keys", "attachments.poll_ids", "entities.mentions.username", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The list of fields you can display for a [Tweet](#Tweet) object.
            ///
            /// Example: ["created_at", "author_id", "entities", "conversation_id", "reply_settings", "public_metrics"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can display for a [User](#User) object.
            ///
            /// Example: ["username", "verified", "profile_image_url"]
            public var userFields: [UserFields]?
            /// The list of fields you can display for a Media object.
            ///
            /// Example: ["media_key", "duration_ms", "height", "preview_image_url", "type", "url", "width", "public_metrics"]
            public var mediaFields: [MediaFields]?
            /// The list of fields you can display for a Place object.
            ///
            /// Example: ["id", "name", "country_code", "place_type", "full_name", "country", "contained_within", "geo"]
            public var placeFields: [PlaceFields]?
            /// The list of fields you can display for a Poll object.
            ///
            /// Example: ["duration_minutes", "options", "voting_status", "end_datetime"]
            public var pollFields: [PollFields]?

            public enum Expansions: String, Codable, CaseIterable {
                case authorID = "author_id"
                case referencedTweetsID = "referenced_tweets.id"
                case inReplyToUserID = "in_reply_to_user_id"
                case geoPlaceID = "geo.place_id"
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case entitiesMentionsUsername = "entities.mentions.username"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case text
                case authorID = "author_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweets = "referenced_tweets"
                case attachments
                case withheld
                case geo
                case entities
                case publicMetrics = "public_metrics"
                case possiblySensitive = "possibly_sensitive"
                case source
                case lang
                case contextAnnotations = "context_annotations"
                case nonPublicMetrics = "non_public_metrics"
                case promotedMetrics = "promoted_metrics"
                case organicMetrics = "organic_metrics"
                case conversationID = "conversation_id"
                case replySettings = "reply_settings"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case name
                case username
                case protected
                case verified
                case withheld
                case profileImageURL = "profile_image_url"
                case location
                case url
                case description
                case entities
                case pinnedTweetID = "pinned_tweet_id"
                case publicMetrics = "public_metrics"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case mediaKey = "media_key"
                case durationMs = "duration_ms"
                case height
                case previewImageURL = "preview_image_url"
                case type
                case url
                case width
                case publicMetrics = "public_metrics"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case promotedMetrics = "promoted_metrics"
                case altText = "alt_text"
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case id
                case name
                case countryCode = "country_code"
                case placeType = "place_type"
                case fullName = "full_name"
                case country
                case containedWithin = "contained_within"
                case geo
            }

            public enum PollFields: String, Codable, CaseIterable {
                case id
                case options
                case votingStatus = "voting_status"
                case endDatetime = "end_datetime"
                case durationMinutes = "duration_minutes"
            }

            public init(query: String, startTime: Date? = nil, endTime: Date? = nil, maxResults: Int? = nil, nextToken: String? = nil, expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil, userFields: [UserFields]? = nil, mediaFields: [MediaFields]? = nil, placeFields: [PlaceFields]? = nil, pollFields: [PollFields]? = nil) {
                self.query = query
                self.startTime = startTime
                self.endTime = endTime
                self.maxResults = maxResults
                self.nextToken = nextToken
                self.expansions = expansions
                self.tweetFields = tweetFields
                self.userFields = userFields
                self.mediaFields = mediaFields
                self.placeFields = placeFields
                self.pollFields = pollFields
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("query", self.query)
                query.addQueryItem("start_time", startTime)
                query.addQueryItem("end_time", endTime)
                query.addQueryItem("max_results", maxResults)
                query.addQueryItem("next_token", nextToken)
                query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("tweet.fields", tweetFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("user.fields", userFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("media.fields", mediaFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("place.fields", placeFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("poll.fields", pollFields?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.Tweets.Search {
    public var stream: Stream {
        Stream(path: path + "/stream")
    }

    public struct Stream {
        /// Path: `/2/tweets/search/stream`
        public let path: String

        /// Filtered stream
        ///
        /// Streams Tweets matching the stream's active rule set.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.FilteredStreamingTweet> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["author_id", "referenced_tweets.id", "in_reply_to_user_id", "geo.place_id", "attachments.media_keys", "attachments.poll_ids", "entities.mentions.username", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The list of fields you can display for a [Tweet](#Tweet) object.
            ///
            /// Example: ["created_at", "author_id", "entities", "conversation_id", "reply_settings", "public_metrics"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can display for a [User](#User) object.
            ///
            /// Example: ["username", "verified", "profile_image_url"]
            public var userFields: [UserFields]?
            /// The list of fields you can display for a Media object.
            ///
            /// Example: ["media_key", "duration_ms", "height", "preview_image_url", "type", "url", "width", "public_metrics"]
            public var mediaFields: [MediaFields]?
            /// The list of fields you can display for a Place object.
            ///
            /// Example: ["id", "name", "country_code", "place_type", "full_name", "country", "contained_within", "geo"]
            public var placeFields: [PlaceFields]?
            /// The list of fields you can display for a Poll object.
            ///
            /// Example: ["duration_minutes", "options", "voting_status", "end_datetime"]
            public var pollFields: [PollFields]?
            public var backfillMinutes: Int?

            public enum Expansions: String, Codable, CaseIterable {
                case authorID = "author_id"
                case referencedTweetsID = "referenced_tweets.id"
                case inReplyToUserID = "in_reply_to_user_id"
                case geoPlaceID = "geo.place_id"
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case entitiesMentionsUsername = "entities.mentions.username"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case text
                case authorID = "author_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweets = "referenced_tweets"
                case attachments
                case withheld
                case geo
                case entities
                case publicMetrics = "public_metrics"
                case possiblySensitive = "possibly_sensitive"
                case source
                case lang
                case contextAnnotations = "context_annotations"
                case nonPublicMetrics = "non_public_metrics"
                case promotedMetrics = "promoted_metrics"
                case organicMetrics = "organic_metrics"
                case conversationID = "conversation_id"
                case replySettings = "reply_settings"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case name
                case username
                case protected
                case verified
                case withheld
                case profileImageURL = "profile_image_url"
                case location
                case url
                case description
                case entities
                case pinnedTweetID = "pinned_tweet_id"
                case publicMetrics = "public_metrics"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case mediaKey = "media_key"
                case durationMs = "duration_ms"
                case height
                case previewImageURL = "preview_image_url"
                case type
                case url
                case width
                case publicMetrics = "public_metrics"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case promotedMetrics = "promoted_metrics"
                case altText = "alt_text"
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case id
                case name
                case countryCode = "country_code"
                case placeType = "place_type"
                case fullName = "full_name"
                case country
                case containedWithin = "contained_within"
                case geo
            }

            public enum PollFields: String, Codable, CaseIterable {
                case id
                case options
                case votingStatus = "voting_status"
                case endDatetime = "end_datetime"
                case durationMinutes = "duration_minutes"
            }

            public init(expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil, userFields: [UserFields]? = nil, mediaFields: [MediaFields]? = nil, placeFields: [PlaceFields]? = nil, pollFields: [PollFields]? = nil, backfillMinutes: Int? = nil) {
                self.expansions = expansions
                self.tweetFields = tweetFields
                self.userFields = userFields
                self.mediaFields = mediaFields
                self.placeFields = placeFields
                self.pollFields = pollFields
                self.backfillMinutes = backfillMinutes
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("tweet.fields", tweetFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("user.fields", userFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("media.fields", mediaFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("place.fields", placeFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("poll.fields", pollFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("backfill_minutes", backfillMinutes)
                return query
            }
        }
    }
}

extension Paths.Tweets.Search.Stream {
    public var rules: Rules {
        Rules(path: path + "/rules")
    }

    public struct Rules {
        /// Path: `/2/tweets/search/stream/rules`
        public let path: String

        /// Rules lookup
        ///
        /// Returns rules from a user's active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
        public func get(maxResults: Int? = nil, paginationToken: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(maxResults, paginationToken))
        }

        public struct GetResponse: Decodable {
            public var data: [TwitterAPI.Rule]
            public var meta: TwitterAPI.RulesResponseMetadata

            public init(data: [TwitterAPI.Rule], meta: TwitterAPI.RulesResponseMetadata) {
                self.data = data
                self.meta = meta
            }
        }

        private func makeGetQuery(_ maxResults: Int?, _ paginationToken: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("max_results", maxResults)
            query.addQueryItem("pagination_token", paginationToken)
            return query
        }

        /// Add/Delete rules
        ///
        /// Add or delete rules from a user's active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
        public func post(isDryRun: Bool? = nil, _ body: TwitterAPI.AddOrDeleteRulesRequest) -> Request<TwitterAPI.AddOrDeleteRulesResponse> {
            .post(path, query: makePostQuery(isDryRun), body: body)
        }

        private func makePostQuery(_ isDryRun: Bool?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("dry_run", isDryRun)
            return query
        }
    }
}

extension Paths.Tweets {
    public var sample: Sample {
        Sample(path: path + "/sample")
    }

    public struct Sample {
        /// Path: `/2/tweets/sample`
        public let path: String
    }
}

extension Paths.Tweets.Sample {
    public var stream: Stream {
        Stream(path: path + "/stream")
    }

    public struct Stream {
        /// Path: `/2/tweets/sample/stream`
        public let path: String

        /// Sample stream
        ///
        /// Streams a deterministic 1% of public Tweets.
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.StreamingTweet> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["author_id", "referenced_tweets.id", "in_reply_to_user_id", "geo.place_id", "attachments.media_keys", "attachments.poll_ids", "entities.mentions.username", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The list of fields you can display for a [Tweet](#Tweet) object.
            ///
            /// Example: ["created_at", "author_id", "entities", "conversation_id", "reply_settings", "public_metrics"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can display for a [User](#User) object.
            ///
            /// Example: ["username", "verified", "profile_image_url"]
            public var userFields: [UserFields]?
            /// The list of fields you can display for a Media object.
            ///
            /// Example: ["media_key", "duration_ms", "height", "preview_image_url", "type", "url", "width", "public_metrics"]
            public var mediaFields: [MediaFields]?
            /// The list of fields you can display for a Place object.
            ///
            /// Example: ["id", "name", "country_code", "place_type", "full_name", "country", "contained_within", "geo"]
            public var placeFields: [PlaceFields]?
            /// The list of fields you can display for a Poll object.
            ///
            /// Example: ["duration_minutes", "options", "voting_status", "end_datetime"]
            public var pollFields: [PollFields]?
            public var backfillMinutes: Int?

            public enum Expansions: String, Codable, CaseIterable {
                case authorID = "author_id"
                case referencedTweetsID = "referenced_tweets.id"
                case inReplyToUserID = "in_reply_to_user_id"
                case geoPlaceID = "geo.place_id"
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case entitiesMentionsUsername = "entities.mentions.username"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case text
                case authorID = "author_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweets = "referenced_tweets"
                case attachments
                case withheld
                case geo
                case entities
                case publicMetrics = "public_metrics"
                case possiblySensitive = "possibly_sensitive"
                case source
                case lang
                case contextAnnotations = "context_annotations"
                case nonPublicMetrics = "non_public_metrics"
                case promotedMetrics = "promoted_metrics"
                case organicMetrics = "organic_metrics"
                case conversationID = "conversation_id"
                case replySettings = "reply_settings"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case name
                case username
                case protected
                case verified
                case withheld
                case profileImageURL = "profile_image_url"
                case location
                case url
                case description
                case entities
                case pinnedTweetID = "pinned_tweet_id"
                case publicMetrics = "public_metrics"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case mediaKey = "media_key"
                case durationMs = "duration_ms"
                case height
                case previewImageURL = "preview_image_url"
                case type
                case url
                case width
                case publicMetrics = "public_metrics"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case promotedMetrics = "promoted_metrics"
                case altText = "alt_text"
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case id
                case name
                case countryCode = "country_code"
                case placeType = "place_type"
                case fullName = "full_name"
                case country
                case containedWithin = "contained_within"
                case geo
            }

            public enum PollFields: String, Codable, CaseIterable {
                case id
                case options
                case votingStatus = "voting_status"
                case endDatetime = "end_datetime"
                case durationMinutes = "duration_minutes"
            }

            public init(expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil, userFields: [UserFields]? = nil, mediaFields: [MediaFields]? = nil, placeFields: [PlaceFields]? = nil, pollFields: [PollFields]? = nil, backfillMinutes: Int? = nil) {
                self.expansions = expansions
                self.tweetFields = tweetFields
                self.userFields = userFields
                self.mediaFields = mediaFields
                self.placeFields = placeFields
                self.pollFields = pollFields
                self.backfillMinutes = backfillMinutes
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("tweet.fields", tweetFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("user.fields", userFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("media.fields", mediaFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("place.fields", placeFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("poll.fields", pollFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("backfill_minutes", backfillMinutes)
                return query
            }
        }
    }
}

extension Paths {
    public static var openapiJSON: OpenapiJSON {
        OpenapiJSON(path: "/2/openapi.json")
    }

    public struct OpenapiJSON {
        /// Path: `/2/openapi.json`
        public let path: String

        /// Returns the open api spec document.
        ///
        /// Full open api spec in JSON format. (See https://github.com/OAI/OpenAPI-Specification/blob/master/README.md)
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Users.WithID {
    public var tweets: Tweets {
        Tweets(path: path + "/tweets")
    }

    public struct Tweets {
        /// Path: `/2/users/{id}/tweets`
        public let path: String

        /// User Tweets timeline by User ID
        ///
        /// Returns a list of Tweets authored by the provided User ID
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.GenericTweetsTimelineResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxResults: Int?
            /// The set of entities to exclude (e.g. 'replies' or 'retweets')
            ///
            /// Example: ["replies", "retweets"]
            public var exclude: [Exclude]?
            public var paginationToken: String?
            public var startTime: Date?
            public var endTime: Date?
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["author_id", "referenced_tweets.id", "in_reply_to_user_id", "geo.place_id", "attachments.media_keys", "attachments.poll_ids", "entities.mentions.username", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The list of fields you can display for a [Tweet](#Tweet) object.
            ///
            /// Example: ["created_at", "author_id", "entities", "conversation_id", "reply_settings", "public_metrics"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can display for a [User](#User) object.
            ///
            /// Example: ["username", "verified", "profile_image_url"]
            public var userFields: [UserFields]?
            /// The list of fields you can display for a Media object.
            ///
            /// Example: ["media_key", "duration_ms", "height", "preview_image_url", "type", "url", "width", "public_metrics"]
            public var mediaFields: [MediaFields]?
            /// The list of fields you can display for a Place object.
            ///
            /// Example: ["id", "name", "country_code", "place_type", "full_name", "country", "contained_within", "geo"]
            public var placeFields: [PlaceFields]?
            /// The list of fields you can display for a Poll object.
            ///
            /// Example: ["duration_minutes", "options", "voting_status", "end_datetime"]
            public var pollFields: [PollFields]?

            public enum Exclude: String, Codable, CaseIterable {
                case replies
                case retweets
            }

            public enum Expansions: String, Codable, CaseIterable {
                case authorID = "author_id"
                case referencedTweetsID = "referenced_tweets.id"
                case inReplyToUserID = "in_reply_to_user_id"
                case geoPlaceID = "geo.place_id"
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case entitiesMentionsUsername = "entities.mentions.username"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case text
                case authorID = "author_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweets = "referenced_tweets"
                case attachments
                case withheld
                case geo
                case entities
                case publicMetrics = "public_metrics"
                case possiblySensitive = "possibly_sensitive"
                case source
                case lang
                case contextAnnotations = "context_annotations"
                case nonPublicMetrics = "non_public_metrics"
                case promotedMetrics = "promoted_metrics"
                case organicMetrics = "organic_metrics"
                case conversationID = "conversation_id"
                case replySettings = "reply_settings"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case name
                case username
                case protected
                case verified
                case withheld
                case profileImageURL = "profile_image_url"
                case location
                case url
                case description
                case entities
                case pinnedTweetID = "pinned_tweet_id"
                case publicMetrics = "public_metrics"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case mediaKey = "media_key"
                case durationMs = "duration_ms"
                case height
                case previewImageURL = "preview_image_url"
                case type
                case url
                case width
                case publicMetrics = "public_metrics"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case promotedMetrics = "promoted_metrics"
                case altText = "alt_text"
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case id
                case name
                case countryCode = "country_code"
                case placeType = "place_type"
                case fullName = "full_name"
                case country
                case containedWithin = "contained_within"
                case geo
            }

            public enum PollFields: String, Codable, CaseIterable {
                case id
                case options
                case votingStatus = "voting_status"
                case endDatetime = "end_datetime"
                case durationMinutes = "duration_minutes"
            }

            public init(maxResults: Int? = nil, exclude: [Exclude]? = nil, paginationToken: String? = nil, startTime: Date? = nil, endTime: Date? = nil, expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil, userFields: [UserFields]? = nil, mediaFields: [MediaFields]? = nil, placeFields: [PlaceFields]? = nil, pollFields: [PollFields]? = nil) {
                self.maxResults = maxResults
                self.exclude = exclude
                self.paginationToken = paginationToken
                self.startTime = startTime
                self.endTime = endTime
                self.expansions = expansions
                self.tweetFields = tweetFields
                self.userFields = userFields
                self.mediaFields = mediaFields
                self.placeFields = placeFields
                self.pollFields = pollFields
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("max_results", maxResults)
                query.addQueryItem("exclude", exclude?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("pagination_token", paginationToken)
                query.addQueryItem("start_time", startTime)
                query.addQueryItem("end_time", endTime)
                query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("tweet.fields", tweetFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("user.fields", userFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("media.fields", mediaFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("place.fields", placeFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("poll.fields", pollFields?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.Users.WithID {
    public var mentions: Mentions {
        Mentions(path: path + "/mentions")
    }

    public struct Mentions {
        /// Path: `/2/users/{id}/mentions`
        public let path: String

        /// User mention timeline by User ID
        ///
        /// Returns Tweet objects that mention username associated to the provided User ID
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.GenericTweetsTimelineResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxResults: Int?
            public var paginationToken: String?
            public var startTime: Date?
            public var endTime: Date?
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["author_id", "referenced_tweets.id", "in_reply_to_user_id", "geo.place_id", "attachments.media_keys", "attachments.poll_ids", "entities.mentions.username", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The list of fields you can display for a [Tweet](#Tweet) object.
            ///
            /// Example: ["created_at", "author_id", "entities", "conversation_id", "reply_settings", "public_metrics"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can display for a [User](#User) object.
            ///
            /// Example: ["username", "verified", "profile_image_url"]
            public var userFields: [UserFields]?
            /// The list of fields you can display for a Media object.
            ///
            /// Example: ["media_key", "duration_ms", "height", "preview_image_url", "type", "url", "width", "public_metrics"]
            public var mediaFields: [MediaFields]?
            /// The list of fields you can display for a Place object.
            ///
            /// Example: ["id", "name", "country_code", "place_type", "full_name", "country", "contained_within", "geo"]
            public var placeFields: [PlaceFields]?
            /// The list of fields you can display for a Poll object.
            ///
            /// Example: ["duration_minutes", "options", "voting_status", "end_datetime"]
            public var pollFields: [PollFields]?

            public enum Expansions: String, Codable, CaseIterable {
                case authorID = "author_id"
                case referencedTweetsID = "referenced_tweets.id"
                case inReplyToUserID = "in_reply_to_user_id"
                case geoPlaceID = "geo.place_id"
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case entitiesMentionsUsername = "entities.mentions.username"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case text
                case authorID = "author_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweets = "referenced_tweets"
                case attachments
                case withheld
                case geo
                case entities
                case publicMetrics = "public_metrics"
                case possiblySensitive = "possibly_sensitive"
                case source
                case lang
                case contextAnnotations = "context_annotations"
                case nonPublicMetrics = "non_public_metrics"
                case promotedMetrics = "promoted_metrics"
                case organicMetrics = "organic_metrics"
                case conversationID = "conversation_id"
                case replySettings = "reply_settings"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case name
                case username
                case protected
                case verified
                case withheld
                case profileImageURL = "profile_image_url"
                case location
                case url
                case description
                case entities
                case pinnedTweetID = "pinned_tweet_id"
                case publicMetrics = "public_metrics"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case mediaKey = "media_key"
                case durationMs = "duration_ms"
                case height
                case previewImageURL = "preview_image_url"
                case type
                case url
                case width
                case publicMetrics = "public_metrics"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case promotedMetrics = "promoted_metrics"
                case altText = "alt_text"
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case id
                case name
                case countryCode = "country_code"
                case placeType = "place_type"
                case fullName = "full_name"
                case country
                case containedWithin = "contained_within"
                case geo
            }

            public enum PollFields: String, Codable, CaseIterable {
                case id
                case options
                case votingStatus = "voting_status"
                case endDatetime = "end_datetime"
                case durationMinutes = "duration_minutes"
            }

            public init(maxResults: Int? = nil, paginationToken: String? = nil, startTime: Date? = nil, endTime: Date? = nil, expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil, userFields: [UserFields]? = nil, mediaFields: [MediaFields]? = nil, placeFields: [PlaceFields]? = nil, pollFields: [PollFields]? = nil) {
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.startTime = startTime
                self.endTime = endTime
                self.expansions = expansions
                self.tweetFields = tweetFields
                self.userFields = userFields
                self.mediaFields = mediaFields
                self.placeFields = placeFields
                self.pollFields = pollFields
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("max_results", maxResults)
                query.addQueryItem("pagination_token", paginationToken)
                query.addQueryItem("start_time", startTime)
                query.addQueryItem("end_time", endTime)
                query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("tweet.fields", tweetFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("user.fields", userFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("media.fields", mediaFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("place.fields", placeFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("poll.fields", pollFields?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.Users.WithID {
    public var likes: Likes {
        Likes(path: path + "/likes")
    }

    public struct Likes {
        /// Path: `/2/users/{id}/likes`
        public let path: String

        /// Causes the user (in the path) to like the specified tweet
        ///
        /// Causes the user (in the path) to like the specified tweet. The user in the path must match the user context authorizing the request.
        public func post(_ body: TwitterAPI.UsersLikesCreateRequest? = nil) -> Request<TwitterAPI.UsersLikesCreateResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Users.WithID.Likes {
    public func tweetID(_ tweetID: String) -> WithTweetID {
        WithTweetID(path: "\(path)/\(tweetID)")
    }

    public struct WithTweetID {
        /// Path: `/2/users/{id}/likes/{tweet_id}`
        public let path: String

        /// Causes the user (in the path) to unlike the specified tweet
        ///
        /// Causes the user (in the path) to unlike the specified tweet. The user must match the user context authorizing the request
        public var delete: Request<TwitterAPI.UsersLikesDeleteResponse> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithID {
    public var likedTweets: LikedTweets {
        LikedTweets(path: path + "/liked_tweets")
    }

    public struct LikedTweets {
        /// Path: `/2/users/{id}/liked_tweets`
        public let path: String

        /// Returns Tweet objects liked by the provided User ID
        ///
        /// Returns a list of Tweets liked by the provided User ID
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [TwitterAPI.Tweet]?
            public var includes: TwitterAPI.Expansions?
            public var errors: [TwitterAPI.Problem]?
            public var meta: Meta?

            public struct Meta: Decodable {
                /// The previous token
                public var previousToken: String?
                /// The next token
                public var nextToken: String?
                /// Number of Tweets in result set
                public var resultCount: Int?

                public init(previousToken: String? = nil, nextToken: String? = nil, resultCount: Int? = nil) {
                    self.previousToken = previousToken
                    self.nextToken = nextToken
                    self.resultCount = resultCount
                }

                private enum CodingKeys: String, CodingKey {
                    case previousToken = "previous_token"
                    case nextToken = "next_token"
                    case resultCount = "result_count"
                }
            }

            public init(data: [TwitterAPI.Tweet]? = nil, includes: TwitterAPI.Expansions? = nil, errors: [TwitterAPI.Problem]? = nil, meta: Meta? = nil) {
                self.data = data
                self.includes = includes
                self.errors = errors
                self.meta = meta
            }
        }

        public struct GetParameters {
            public var maxResults: Int?
            public var paginationToken: String?
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["author_id", "referenced_tweets.id", "in_reply_to_user_id", "geo.place_id", "attachments.media_keys", "attachments.poll_ids", "entities.mentions.username", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The list of fields you can display for a [Tweet](#Tweet) object.
            ///
            /// Example: ["created_at", "author_id", "entities", "conversation_id", "reply_settings", "public_metrics"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can display for a [User](#User) object.
            ///
            /// Example: ["username", "verified", "profile_image_url"]
            public var userFields: [UserFields]?
            /// The list of fields you can display for a Media object.
            ///
            /// Example: ["media_key", "duration_ms", "height", "preview_image_url", "type", "url", "width", "public_metrics"]
            public var mediaFields: [MediaFields]?
            /// The list of fields you can display for a Place object.
            ///
            /// Example: ["id", "name", "country_code", "place_type", "full_name", "country", "contained_within", "geo"]
            public var placeFields: [PlaceFields]?
            /// The list of fields you can display for a Poll object.
            ///
            /// Example: ["duration_minutes", "options", "voting_status", "end_datetime"]
            public var pollFields: [PollFields]?

            public enum Expansions: String, Codable, CaseIterable {
                case authorID = "author_id"
                case referencedTweetsID = "referenced_tweets.id"
                case inReplyToUserID = "in_reply_to_user_id"
                case geoPlaceID = "geo.place_id"
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case entitiesMentionsUsername = "entities.mentions.username"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case text
                case authorID = "author_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweets = "referenced_tweets"
                case attachments
                case withheld
                case geo
                case entities
                case publicMetrics = "public_metrics"
                case possiblySensitive = "possibly_sensitive"
                case source
                case lang
                case contextAnnotations = "context_annotations"
                case nonPublicMetrics = "non_public_metrics"
                case promotedMetrics = "promoted_metrics"
                case organicMetrics = "organic_metrics"
                case conversationID = "conversation_id"
                case replySettings = "reply_settings"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case name
                case username
                case protected
                case verified
                case withheld
                case profileImageURL = "profile_image_url"
                case location
                case url
                case description
                case entities
                case pinnedTweetID = "pinned_tweet_id"
                case publicMetrics = "public_metrics"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case mediaKey = "media_key"
                case durationMs = "duration_ms"
                case height
                case previewImageURL = "preview_image_url"
                case type
                case url
                case width
                case publicMetrics = "public_metrics"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case promotedMetrics = "promoted_metrics"
                case altText = "alt_text"
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case id
                case name
                case countryCode = "country_code"
                case placeType = "place_type"
                case fullName = "full_name"
                case country
                case containedWithin = "contained_within"
                case geo
            }

            public enum PollFields: String, Codable, CaseIterable {
                case id
                case options
                case votingStatus = "voting_status"
                case endDatetime = "end_datetime"
                case durationMinutes = "duration_minutes"
            }

            public init(maxResults: Int? = nil, paginationToken: String? = nil, expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil, userFields: [UserFields]? = nil, mediaFields: [MediaFields]? = nil, placeFields: [PlaceFields]? = nil, pollFields: [PollFields]? = nil) {
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.expansions = expansions
                self.tweetFields = tweetFields
                self.userFields = userFields
                self.mediaFields = mediaFields
                self.placeFields = placeFields
                self.pollFields = pollFields
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("max_results", maxResults)
                query.addQueryItem("pagination_token", paginationToken)
                query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("tweet.fields", tweetFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("user.fields", userFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("media.fields", mediaFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("place.fields", placeFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("poll.fields", pollFields?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.Tweets.WithID {
    public var likingUsers: LikingUsers {
        LikingUsers(path: path + "/liking_users")
    }

    public struct LikingUsers {
        /// Path: `/2/tweets/{id}/liking_users`
        public let path: String

        /// Returns user objects that have liked the provided Tweet ID
        ///
        /// Returns a list of users that have liked the provided Tweet ID
        public var get: Request<TwitterAPI.GenericMultipleUsersLookupResponse> {
            .get(path)
        }
    }
}

extension Paths.Tweets.WithID {
    public var retweetedBy: RetweetedBy {
        RetweetedBy(path: path + "/retweeted_by")
    }

    public struct RetweetedBy {
        /// Path: `/2/tweets/{id}/retweeted_by`
        public let path: String

        /// Returns user objects that have retweeted the provided Tweet ID
        ///
        /// Returns a list of users that have retweeted the provided Tweet ID
        public var get: Request<TwitterAPI.GenericMultipleUsersLookupResponse> {
            .get(path)
        }
    }
}

extension Paths.Users.WithID {
    public var retweets: Retweets {
        Retweets(path: path + "/retweets")
    }

    public struct Retweets {
        /// Path: `/2/users/{id}/retweets`
        public let path: String

        /// Causes the user (in the path) to retweet the specified tweet
        ///
        /// Causes the user (in the path) to retweet the specified tweet. The user in the path must match the user context authorizing the request.
        public func post(_ body: TwitterAPI.UsersRetweetsCreateRequest? = nil) -> Request<TwitterAPI.UsersRetweetsCreateResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Users.WithID.Retweets {
    public func sourceTweetID(_ sourceTweetID: String) -> WithSourceTweetID {
        WithSourceTweetID(path: "\(path)/\(sourceTweetID)")
    }

    public struct WithSourceTweetID {
        /// Path: `/2/users/{id}/retweets/{source_tweet_id}`
        public let path: String

        /// Causes the user (in the path) to unretweet the specified tweet
        ///
        /// Causes the user (in the path) to unretweet the specified tweet. The user must match the user context authorizing the request
        public var delete: Request<TwitterAPI.UsersRetweetsDeleteResponse> {
            .delete(path)
        }
    }
}

extension Paths.Tweets {
    public var counts: Counts {
        Counts(path: path + "/counts")
    }

    public struct Counts {
        /// Path: `/2/tweets/counts`
        public let path: String
    }
}

extension Paths.Tweets.Counts {
    public var recent: Recent {
        Recent(path: path + "/recent")
    }

    public struct Recent {
        /// Path: `/2/tweets/counts/recent`
        public let path: String

        /// Recent search counts
        ///
        /// Returns Tweet Counts from the last 7 days that match a search query.
        public func get(parameters: GetParameters) -> Request<TwitterAPI.TweetCountsResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            /// Example: "(from:TwitterDev OR from:TwitterAPI) has:media -is:retweet"
            public var query: String
            public var startTime: Date?
            public var endTime: Date?
            public var nextToken: String?

            public init(query: String, startTime: Date? = nil, endTime: Date? = nil, nextToken: String? = nil) {
                self.query = query
                self.startTime = startTime
                self.endTime = endTime
                self.nextToken = nextToken
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("query", self.query)
                query.addQueryItem("start_time", startTime)
                query.addQueryItem("end_time", endTime)
                query.addQueryItem("next_token", nextToken)
                return query
            }
        }
    }
}

extension Paths.Tweets.Counts {
    public var all: All {
        All(path: path + "/all")
    }

    public struct All {
        /// Path: `/2/tweets/counts/all`
        public let path: String

        /// Full archive search counts
        ///
        /// Returns Tweet Counts that match a search query.
        public func get(parameters: GetParameters) -> Request<TwitterAPI.TweetCountsResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            /// Example: "(from:TwitterDev OR from:TwitterAPI) has:media -is:retweet"
            public var query: String
            public var startTime: Date?
            public var endTime: Date?
            public var nextToken: String?

            public init(query: String, startTime: Date? = nil, endTime: Date? = nil, nextToken: String? = nil) {
                self.query = query
                self.startTime = startTime
                self.endTime = endTime
                self.nextToken = nextToken
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("query", self.query)
                query.addQueryItem("start_time", startTime)
                query.addQueryItem("end_time", endTime)
                query.addQueryItem("next_token", nextToken)
                return query
            }
        }
    }
}

extension Paths {
    public static var compliance: Compliance {
        Compliance(path: "/2/compliance")
    }

    public struct Compliance {
        /// Path: `/2/compliance`
        public let path: String
    }
}

extension Paths.Compliance {
    public var jobs: Jobs {
        Jobs(path: path + "/jobs")
    }

    public struct Jobs {
        /// Path: `/2/compliance/jobs`
        public let path: String

        /// List compliance jobs
        ///
        /// Returns recent compliance jobs for a given job type and optional job status
        public var get: Request<TwitterAPI.MultiComplianceJobResponse> {
            .get(path)
        }

        /// Create compliance job
        ///
        /// Creates a compliance for the given job type
        public func post(_ body: PostRequest) -> Request<TwitterAPI.SingleComplianceJobResponse> {
            .post(path, body: body)
        }

        /// A request to create a new batch compliance job.
        public struct PostRequest: Encodable {
            /// Type of compliance job to list.
            public var type: TwitterAPI.ComplianceJobType
            /// If true, this endpoint will return a pre-signed URL with resumable uploads enabled
            public var isResumable: Bool?
            /// User-provided name for a compliance job
            ///
            /// Example: "my-job"
            public var name: String?

            public init(type: TwitterAPI.ComplianceJobType, isResumable: Bool? = nil, name: String? = nil) {
                self.type = type
                self.isResumable = isResumable
                self.name = name
            }

            private enum CodingKeys: String, CodingKey {
                case type
                case isResumable = "resumable"
                case name
            }
        }
    }
}

extension Paths.Compliance.Jobs {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/2/compliance/jobs/{id}`
        public let path: String

        /// Get compliance job
        ///
        /// Returns a single compliance job by ID
        public var get: Request<TwitterAPI.SingleComplianceJobResponse> {
            .get(path)
        }
    }
}

extension Paths {
    public static var lists: Lists {
        Lists(path: "/2/lists")
    }

    public struct Lists {
        /// Path: `/2/lists`
        public let path: String

        /// Create List
        ///
        /// Creates a new List.
        public func post(_ body: TwitterAPI.ListCreateRequest? = nil) -> Request<TwitterAPI.ListCreateResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Lists {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/2/lists/{id}`
        public let path: String

        /// List lookup by List ID
        ///
        /// Returns a List
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.SingleListLookupResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            /// The fields available for a List object.
            ///
            /// Example: ["created_at", "description", "follower_count", "member_count", "name", "private"]
            public var listFields: [ListFields]?
            /// The list of fields you can expand for a [List](#List) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["owner_id"]
            public var expansions: [Expansions]?
            /// The list of fields you can display for a [User](#User) object.
            ///
            /// Example: ["username", "verified", "profile_image_url"]
            public var userFields: [UserFields]?

            public enum ListFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case description
                case followerCount = "follower_count"
                case id
                case memberCount = "member_count"
                case name
                case ownerID = "owner_id"
                case `private`
            }

            public enum Expansions: String, Codable, CaseIterable {
                case ownerID = "owner_id"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case name
                case username
                case protected
                case verified
                case withheld
                case profileImageURL = "profile_image_url"
                case location
                case url
                case description
                case entities
                case pinnedTweetID = "pinned_tweet_id"
                case publicMetrics = "public_metrics"
            }

            public init(listFields: [ListFields]? = nil, expansions: [Expansions]? = nil, userFields: [UserFields]? = nil) {
                self.listFields = listFields
                self.expansions = expansions
                self.userFields = userFields
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("list.fields", listFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("user.fields", userFields?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }

        /// Update List
        ///
        /// Update a List that you own.
        public func put(_ body: TwitterAPI.ListUpdateRequest? = nil) -> Request<TwitterAPI.ListUpdateResponse> {
            .put(path, body: body)
        }

        /// Delete List
        ///
        /// Delete a List that you own.
        public var delete: Request<TwitterAPI.ListDeleteResponse> {
            .delete(path)
        }
    }
}

extension Paths.Lists.WithID {
    public var followers: Followers {
        Followers(path: path + "/followers")
    }

    public struct Followers {
        /// Path: `/2/lists/{id}/followers`
        public let path: String

        /// Returns user objects that follow a List by the provided List ID
        ///
        /// Returns a list of users that follow a List by the provided List ID
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.ListLookupMultipleUsersLookupResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxResults: Int?
            public var paginationToken: Int?
            /// The list of fields you can expand for a [User](#User) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["pinned_tweet_id"]
            public var expansions: [Expansions]?
            /// The list of fields you can display for a [Tweet](#Tweet) object.
            ///
            /// Example: ["created_at", "author_id", "entities", "conversation_id", "reply_settings", "public_metrics"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can display for a [User](#User) object.
            ///
            /// Example: ["username", "verified", "profile_image_url"]
            public var userFields: [UserFields]?

            public enum Expansions: String, Codable, CaseIterable {
                case pinnedTweetID = "pinned_tweet_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case text
                case authorID = "author_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweets = "referenced_tweets"
                case attachments
                case withheld
                case geo
                case entities
                case publicMetrics = "public_metrics"
                case possiblySensitive = "possibly_sensitive"
                case source
                case lang
                case contextAnnotations = "context_annotations"
                case nonPublicMetrics = "non_public_metrics"
                case promotedMetrics = "promoted_metrics"
                case organicMetrics = "organic_metrics"
                case conversationID = "conversation_id"
                case replySettings = "reply_settings"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case name
                case username
                case protected
                case verified
                case withheld
                case profileImageURL = "profile_image_url"
                case location
                case url
                case description
                case entities
                case pinnedTweetID = "pinned_tweet_id"
                case publicMetrics = "public_metrics"
            }

            public init(maxResults: Int? = nil, paginationToken: Int? = nil, expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil, userFields: [UserFields]? = nil) {
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.expansions = expansions
                self.tweetFields = tweetFields
                self.userFields = userFields
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("max_results", maxResults)
                query.addQueryItem("pagination_token", paginationToken)
                query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("tweet.fields", tweetFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("user.fields", userFields?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.Lists.WithID {
    public var members: Members {
        Members(path: path + "/members")
    }

    public struct Members {
        /// Path: `/2/lists/{id}/members`
        public let path: String

        /// Returns user objects that are members of a List by the provided List ID
        ///
        /// Returns a list of users that are members of a List by the provided List ID
        public func get(parameters: GetParameters? = nil) -> Request<TwitterAPI.ListLookupMultipleUsersLookupResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxResults: Int?
            public var paginationToken: Int?
            /// The list of fields you can expand for a [User](#User) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["pinned_tweet_id"]
            public var expansions: [Expansions]?
            /// The list of fields you can display for a [Tweet](#Tweet) object.
            ///
            /// Example: ["created_at", "author_id", "entities", "conversation_id", "reply_settings", "public_metrics"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can display for a [User](#User) object.
            ///
            /// Example: ["username", "verified", "profile_image_url"]
            public var userFields: [UserFields]?

            public enum Expansions: String, Codable, CaseIterable {
                case pinnedTweetID = "pinned_tweet_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case text
                case authorID = "author_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweets = "referenced_tweets"
                case attachments
                case withheld
                case geo
                case entities
                case publicMetrics = "public_metrics"
                case possiblySensitive = "possibly_sensitive"
                case source
                case lang
                case contextAnnotations = "context_annotations"
                case nonPublicMetrics = "non_public_metrics"
                case promotedMetrics = "promoted_metrics"
                case organicMetrics = "organic_metrics"
                case conversationID = "conversation_id"
                case replySettings = "reply_settings"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case name
                case username
                case protected
                case verified
                case withheld
                case profileImageURL = "profile_image_url"
                case location
                case url
                case description
                case entities
                case pinnedTweetID = "pinned_tweet_id"
                case publicMetrics = "public_metrics"
            }

            public init(maxResults: Int? = nil, paginationToken: Int? = nil, expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil, userFields: [UserFields]? = nil) {
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.expansions = expansions
                self.tweetFields = tweetFields
                self.userFields = userFields
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("max_results", maxResults)
                query.addQueryItem("pagination_token", paginationToken)
                query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("tweet.fields", tweetFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("user.fields", userFields?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }

        /// Add a List member
        ///
        /// Causes a user to become a member of a List.
        public func post(_ body: TwitterAPI.ListAddMemberRequest? = nil) -> Request<TwitterAPI.ListMemberResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Lists.WithID.Members {
    public func userID(_ userID: String) -> WithUserID {
        WithUserID(path: "\(path)/\(userID)")
    }

    public struct WithUserID {
        /// Path: `/2/lists/{id}/members/{user_id}`
        public let path: String

        /// Remove a List member
        ///
        /// Causes a user to be removed from the members of a List.
        public var delete: Request<TwitterAPI.ListMemberResponse> {
            .delete(path)
        }
    }
}

extension Paths.Lists.WithID {
    public var tweets: Tweets {
        Tweets(path: path + "/tweets")
    }

    public struct Tweets {
        /// Path: `/2/lists/{id}/tweets`
        public let path: String

        /// List Tweets timeline by List ID
        ///
        /// Returns a list of Tweets associated with the provided List ID
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var data: [TwitterAPI.Tweet]?
            public var includes: TwitterAPI.Expansions?
            public var errors: [TwitterAPI.Problem]?
            public var meta: Meta?

            public struct Meta: Decodable {
                /// The previous token
                public var previousToken: String?
                /// The next token
                public var nextToken: String?
                /// Number of Tweets in result set
                public var resultCount: Int?

                public init(previousToken: String? = nil, nextToken: String? = nil, resultCount: Int? = nil) {
                    self.previousToken = previousToken
                    self.nextToken = nextToken
                    self.resultCount = resultCount
                }

                private enum CodingKeys: String, CodingKey {
                    case previousToken = "previous_token"
                    case nextToken = "next_token"
                    case resultCount = "result_count"
                }
            }

            public init(data: [TwitterAPI.Tweet]? = nil, includes: TwitterAPI.Expansions? = nil, errors: [TwitterAPI.Problem]? = nil, meta: Meta? = nil) {
                self.data = data
                self.includes = includes
                self.errors = errors
                self.meta = meta
            }
        }

        public struct GetParameters {
            public var maxResults: Int?
            public var paginationToken: String?
            /// The list of fields you can expand for a [Tweet](#Tweet) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["author_id", "referenced_tweets.id", "in_reply_to_user_id", "geo.place_id", "attachments.media_keys", "attachments.poll_ids", "entities.mentions.username", "referenced_tweets.id.author_id"]
            public var expansions: [Expansions]?
            /// The list of fields you can display for a [Tweet](#Tweet) object.
            ///
            /// Example: ["created_at", "author_id", "entities", "conversation_id", "reply_settings", "public_metrics"]
            public var tweetFields: [TweetFields]?
            /// The list of fields you can display for a [User](#User) object.
            ///
            /// Example: ["username", "verified", "profile_image_url"]
            public var userFields: [UserFields]?
            /// The list of fields you can display for a Media object.
            ///
            /// Example: ["media_key", "duration_ms", "height", "preview_image_url", "type", "url", "width", "public_metrics"]
            public var mediaFields: [MediaFields]?
            /// The list of fields you can display for a Place object.
            ///
            /// Example: ["id", "name", "country_code", "place_type", "full_name", "country", "contained_within", "geo"]
            public var placeFields: [PlaceFields]?
            /// The list of fields you can display for a Poll object.
            ///
            /// Example: ["duration_minutes", "options", "voting_status", "end_datetime"]
            public var pollFields: [PollFields]?

            public enum Expansions: String, Codable, CaseIterable {
                case authorID = "author_id"
                case referencedTweetsID = "referenced_tweets.id"
                case inReplyToUserID = "in_reply_to_user_id"
                case geoPlaceID = "geo.place_id"
                case attachmentsMediaKeys = "attachments.media_keys"
                case attachmentsPollIDs = "attachments.poll_ids"
                case entitiesMentionsUsername = "entities.mentions.username"
                case referencedTweetsIDAuthorId = "referenced_tweets.id.author_id"
            }

            public enum TweetFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case text
                case authorID = "author_id"
                case inReplyToUserID = "in_reply_to_user_id"
                case referencedTweets = "referenced_tweets"
                case attachments
                case withheld
                case geo
                case entities
                case publicMetrics = "public_metrics"
                case possiblySensitive = "possibly_sensitive"
                case source
                case lang
                case contextAnnotations = "context_annotations"
                case nonPublicMetrics = "non_public_metrics"
                case promotedMetrics = "promoted_metrics"
                case organicMetrics = "organic_metrics"
                case conversationID = "conversation_id"
                case replySettings = "reply_settings"
            }

            public enum UserFields: String, Codable, CaseIterable {
                case id
                case createdAt = "created_at"
                case name
                case username
                case protected
                case verified
                case withheld
                case profileImageURL = "profile_image_url"
                case location
                case url
                case description
                case entities
                case pinnedTweetID = "pinned_tweet_id"
                case publicMetrics = "public_metrics"
            }

            public enum MediaFields: String, Codable, CaseIterable {
                case mediaKey = "media_key"
                case durationMs = "duration_ms"
                case height
                case previewImageURL = "preview_image_url"
                case type
                case url
                case width
                case publicMetrics = "public_metrics"
                case nonPublicMetrics = "non_public_metrics"
                case organicMetrics = "organic_metrics"
                case promotedMetrics = "promoted_metrics"
                case altText = "alt_text"
            }

            public enum PlaceFields: String, Codable, CaseIterable {
                case id
                case name
                case countryCode = "country_code"
                case placeType = "place_type"
                case fullName = "full_name"
                case country
                case containedWithin = "contained_within"
                case geo
            }

            public enum PollFields: String, Codable, CaseIterable {
                case id
                case options
                case votingStatus = "voting_status"
                case endDatetime = "end_datetime"
                case durationMinutes = "duration_minutes"
            }

            public init(maxResults: Int? = nil, paginationToken: String? = nil, expansions: [Expansions]? = nil, tweetFields: [TweetFields]? = nil, userFields: [UserFields]? = nil, mediaFields: [MediaFields]? = nil, placeFields: [PlaceFields]? = nil, pollFields: [PollFields]? = nil) {
                self.maxResults = maxResults
                self.paginationToken = paginationToken
                self.expansions = expansions
                self.tweetFields = tweetFields
                self.userFields = userFields
                self.mediaFields = mediaFields
                self.placeFields = placeFields
                self.pollFields = pollFields
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("max_results", maxResults)
                query.addQueryItem("pagination_token", paginationToken)
                query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("tweet.fields", tweetFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("user.fields", userFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("media.fields", mediaFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("place.fields", placeFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("poll.fields", pollFields?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.Spaces {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/2/spaces/{id}`
        public let path: String

        /// Space lookup by Space ID
        ///
        /// Returns a variety of information about the Space specified by the requested ID
        public func get(spaceFields: [SpaceFields]? = nil, expansions: [Expansions]? = nil) -> Request<TwitterAPI.SingleSpaceLookupResponse> {
            .get(path, query: makeGetQuery(spaceFields, expansions))
        }

        private func makeGetQuery(_ spaceFields: [SpaceFields]?, _ expansions: [Expansions]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("space.fields", spaceFields?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum SpaceFields: String, Codable, CaseIterable {
            case createdAt = "created_at"
            case creatorID = "creator_id"
            case hostIDs = "host_ids"
            case invitedUserIDs = "invited_user_ids"
            case isTicketed = "is_ticketed"
            case lang
            case participantCount = "participant_count"
            case scheduledStart = "scheduled_start"
            case speakerIDs = "speaker_ids"
            case startedAt = "started_at"
            case title
            case updatedAt = "updated_at"
        }

        public enum Expansions: String, Codable, CaseIterable {
            case creatorID = "creator_id"
            case hostIDs = "host_ids"
            case invitedUserIDs = "invited_user_ids"
            case speakerIDs = "speaker_ids"
        }
    }
}

extension Paths {
    public static var spaces: Spaces {
        Spaces(path: "/2/spaces")
    }

    public struct Spaces {
        /// Path: `/2/spaces`
        public let path: String

        /// Space lookup up Space IDs
        ///
        /// Returns a variety of information about the Spaces specified by the requested IDs
        public func get(spaceFields: [SpaceFields]? = nil, expansions: [Expansions]? = nil) -> Request<TwitterAPI.MultiSpaceLookupResponse> {
            .get(path, query: makeGetQuery(spaceFields, expansions))
        }

        private func makeGetQuery(_ spaceFields: [SpaceFields]?, _ expansions: [Expansions]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("space.fields", spaceFields?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum SpaceFields: String, Codable, CaseIterable {
            case createdAt = "created_at"
            case creatorID = "creator_id"
            case hostIDs = "host_ids"
            case invitedUserIDs = "invited_user_ids"
            case isTicketed = "is_ticketed"
            case lang
            case participantCount = "participant_count"
            case scheduledStart = "scheduled_start"
            case speakerIDs = "speaker_ids"
            case startedAt = "started_at"
            case title
            case updatedAt = "updated_at"
        }

        public enum Expansions: String, Codable, CaseIterable {
            case creatorID = "creator_id"
            case hostIDs = "host_ids"
            case invitedUserIDs = "invited_user_ids"
            case speakerIDs = "speaker_ids"
        }
    }
}

extension Paths.Spaces {
    public var by: By {
        By(path: path + "/by")
    }

    public struct By {
        /// Path: `/2/spaces/by`
        public let path: String
    }
}

extension Paths.Spaces.By {
    public var creatorIDs: CreatorIDs {
        CreatorIDs(path: path + "/creator_ids")
    }

    public struct CreatorIDs {
        /// Path: `/2/spaces/by/creator_ids`
        public let path: String

        /// Space lookup by their creators
        ///
        /// Returns a variety of information about the Spaces created by the provided User IDs
        public func get(spaceFields: [SpaceFields]? = nil, expansions: [Expansions]? = nil) -> Request<TwitterAPI.MultiSpaceLookupResponse> {
            .get(path, query: makeGetQuery(spaceFields, expansions))
        }

        private func makeGetQuery(_ spaceFields: [SpaceFields]?, _ expansions: [Expansions]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("space.fields", spaceFields?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum SpaceFields: String, Codable, CaseIterable {
            case createdAt = "created_at"
            case creatorID = "creator_id"
            case hostIDs = "host_ids"
            case invitedUserIDs = "invited_user_ids"
            case isTicketed = "is_ticketed"
            case lang
            case participantCount = "participant_count"
            case scheduledStart = "scheduled_start"
            case speakerIDs = "speaker_ids"
            case startedAt = "started_at"
            case title
            case updatedAt = "updated_at"
        }

        public enum Expansions: String, Codable, CaseIterable {
            case creatorID = "creator_id"
            case hostIDs = "host_ids"
            case invitedUserIDs = "invited_user_ids"
            case speakerIDs = "speaker_ids"
        }
    }
}

extension Paths.Spaces {
    public var search: Search {
        Search(path: path + "/search")
    }

    public struct Search {
        /// Path: `/2/spaces/search`
        public let path: String

        /// Search for Spaces
        ///
        /// Returns Spaces that match the provided query.
        public func get(parameters: GetParameters) -> Request<TwitterAPI.MultiSpaceLookupResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            /// The query to use in the Spaces search endpoint
            ///
            /// Example: "crypto"
            public var query: String
            /// The current state of the space.
            ///
            /// Example: "live"
            public var state: State?
            /// The fields available for a Space object.
            ///
            /// Example: ["created_at", "creator_id", "host_ids", "invited_user_ids", "is_ticketed", "lang", "participant_count", "scheduled_start", "speaker_ids", "started_at", "title", "updated_at"]
            public var spaceFields: [SpaceFields]?
            /// The list of fields you can expand for a [Space](#Space) object. If the field has an ID, it can be expanded into a full object.
            ///
            /// Example: ["creator_id", "host_ids", "invited_user_ids", "speaker_ids"]
            public var expansions: [Expansions]?

            /// The current state of the space.
            ///
            /// Example: "live"
            public enum State: String, Codable, CaseIterable {
                case live
                case scheduled
                case all
            }

            public enum SpaceFields: String, Codable, CaseIterable {
                case createdAt = "created_at"
                case creatorID = "creator_id"
                case hostIDs = "host_ids"
                case invitedUserIDs = "invited_user_ids"
                case isTicketed = "is_ticketed"
                case lang
                case participantCount = "participant_count"
                case scheduledStart = "scheduled_start"
                case speakerIDs = "speaker_ids"
                case startedAt = "started_at"
                case title
                case updatedAt = "updated_at"
            }

            public enum Expansions: String, Codable, CaseIterable {
                case creatorID = "creator_id"
                case hostIDs = "host_ids"
                case invitedUserIDs = "invited_user_ids"
                case speakerIDs = "speaker_ids"
            }

            public init(query: String, state: State? = nil, spaceFields: [SpaceFields]? = nil, expansions: [Expansions]? = nil) {
                self.query = query
                self.state = state
                self.spaceFields = spaceFields
                self.expansions = expansions
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("query", self.query)
                query.addQueryItem("state", state)
                query.addQueryItem("space.fields", spaceFields?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("expansions", expansions?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.Spaces.WithID {
    public var buyers: Buyers {
        Buyers(path: path + "/buyers")
    }

    public struct Buyers {
        /// Path: `/2/spaces/{id}/buyers`
        public let path: String

        /// Retrieve the list of users who purchased a ticket to the given space
        ///
        /// Retrieves the list of users who purchased a ticket to the given space
        public func get(userFields: [UserFields]? = nil) -> Request<TwitterAPI.MultiUserLookupResponse> {
            .get(path, query: makeGetQuery(userFields))
        }

        private func makeGetQuery(_ userFields: [UserFields]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("user.fields", userFields?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum UserFields: String, Codable, CaseIterable {
            case id
            case createdAt = "created_at"
            case name
            case username
            case protected
            case verified
            case withheld
            case profileImageURL = "profile_image_url"
            case location
            case url
            case description
            case entities
            case pinnedTweetID = "pinned_tweet_id"
            case publicMetrics = "public_metrics"
        }
    }
}

public enum Paths {}

protocol QueryEncodable {
    var asQueryValue: String { get }
}

extension Bool: QueryEncodable {
    var asQueryValue: String {
        self ? "true" : "false"
    }
}

extension Date: QueryEncodable {
    var asQueryValue: String {
        ISO8601DateFormatter().string(from: self)
    }
}

extension Double: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int32: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int64: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension String: QueryEncodable {
    var asQueryValue: String {
        self
    }
}

extension URL: QueryEncodable {
    var asQueryValue: String {
        absoluteString
    }
}

extension RawRepresentable where RawValue == String {
    var asQueryValue: String {
        rawValue
    }
}

extension Array where Element == (String, String?) {
    mutating func addQueryItem<T: RawRepresentable>(_ name: String, _ value: T?) where T.RawValue == String {
        addQueryItem(name, value?.rawValue)
    }
    
    mutating func addQueryItem(_ name: String, _ value: QueryEncodable?) {
        guard let value = value?.asQueryValue, !value.isEmpty else { return }
        append((name, value))
    }
    
    mutating func addDeepObject(_ name: String, _ query: [(String, String?)]) {
        for (key, value) in query {
            addQueryItem("\(name)[\(key)]", value)
        }
    }

    var asPercentEncodedQuery: String {
        var components = URLComponents()
        components.queryItems = self.map(URLQueryItem.init)
        return components.percentEncodedQuery ?? ""
    }
    
    // [("role", "admin"), ("name": "kean)] -> "role,admin,name,kean"
    var asCompactQuery: String {
        flatMap { [$0, $1] }.compactMap { $0 }.joined(separator: ",")
    }
}
