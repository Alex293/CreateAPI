// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

/// Annotation inferred from the tweet text.
public struct ContextAnnotation: Codable {
    /// Represents the data for the context annotation domain.
    public var domain: ContextAnnotationDomainFields
    /// Represents the data for the context annotation entity.
    public var entity: ContextAnnotationEntityFields

    public init(domain: ContextAnnotationDomainFields, entity: ContextAnnotationEntityFields) {
        self.domain = domain
        self.entity = entity
    }
}

/// Represents the data for the context annotation domain.
public struct ContextAnnotationDomainFields: Codable {
    /// The unique id for a context annotation domain.
    public var id: String
    /// Name of the context annotation domain.
    public var name: String?
    /// Description of the context annotation domain.
    public var description: String?

    public init(id: String, name: String? = nil, description: String? = nil) {
        self.id = id
        self.name = name
        self.description = description
    }
}

/// Represents the data for the context annotation entity.
public struct ContextAnnotationEntityFields: Codable {
    /// The unique id for a context annotation entity.
    public var id: String
    /// Name of the context annotation entity.
    public var name: String?
    /// Description of the context annotation entity.
    public var description: String?

    public init(id: String, name: String? = nil, description: String? = nil) {
        self.id = id
        self.name = name
        self.description = description
    }
}

/// Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is exclusive.
public struct EntityIndicesInclusiveExclusive: Codable {
    /// Index (zero-based) at which position this entity starts.  The index is inclusive.
    ///
    /// Example: 50
    public var start: Int
    /// Index (zero-based) at which position this entity ends.  The index is exclusive.
    ///
    /// Example: 61
    public var end: Int

    public init(start: Int, end: Int) {
        self.start = start
        self.end = end
    }
}

/// Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is inclusive.
public struct EntityIndicesInclusiveInclusive: Codable {
    /// Index (zero-based) at which position this entity starts.  The index is inclusive.
    ///
    /// Example: 50
    public var start: Int
    /// Index (zero-based) at which position this entity ends.  The index is inclusive.
    ///
    /// Example: 61
    public var end: Int

    public init(start: Int, end: Int) {
        self.start = start
        self.end = end
    }
}

/// Represent the portion of text recognized as a URL.
public struct URLFields: Codable {
    /// A validly formatted URL.
    ///
    /// Example: "https://developer.twitter.com/en/docs/twitter-api"
    public var url: URL
    /// A validly formatted URL.
    ///
    /// Example: "https://developer.twitter.com/en/docs/twitter-api"
    public var expandedURL: URL?
    /// The URL as displayed in the Twitter client.
    ///
    /// Example: "twittercommunity.com/t/introducing-â€¦"
    public var displayURL: String?
    /// Fully resolved url
    ///
    /// Example: "https://twittercommunity.com/t/introducing-the-v2-follow-lookup-endpoints/147118"
    public var unwoundURL: URL?
    /// HTTP Status Code.
    public var status: Int?
    /// Title of the page the URL points to.
    ///
    /// Example: "Introducing the v2 follow lookup endpoints"
    public var title: String?
    /// Description of the URL landing page.
    ///
    /// Example: "This is a description of the website."
    public var description: String?
    public var images: [URLImage]?

    public init(url: URL, expandedURL: URL? = nil, displayURL: String? = nil, unwoundURL: URL? = nil, status: Int? = nil, title: String? = nil, description: String? = nil, images: [URLImage]? = nil) {
        self.url = url
        self.expandedURL = expandedURL
        self.displayURL = displayURL
        self.unwoundURL = unwoundURL
        self.status = status
        self.title = title
        self.description = description
        self.images = images
    }

    private enum CodingKeys: String, CodingKey {
        case url
        case expandedURL = "expanded_url"
        case displayURL = "display_url"
        case unwoundURL = "unwound_url"
        case status
        case title
        case description
        case images
    }
}

/// Represent the portion of text recognized as a URL, and its start and end position within the text.
public struct URLEntity: Codable {
    /// Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is exclusive.
    public var entityIndicesInclusiveExclusive: EntityIndicesInclusiveExclusive
    /// Represent the portion of text recognized as a URL.
    public var urlFields: URLFields

    public init(entityIndicesInclusiveExclusive: EntityIndicesInclusiveExclusive, urlFields: URLFields) {
        self.entityIndicesInclusiveExclusive = entityIndicesInclusiveExclusive
        self.urlFields = urlFields
    }

    public init(from decoder: Decoder) throws {
        self.entityIndicesInclusiveExclusive = try EntityIndicesInclusiveExclusive(from: decoder)
        self.urlFields = try URLFields(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(entityIndicesInclusiveExclusive, forKey: "entityIndicesInclusiveExclusive")
        try values.encode(urlFields, forKey: "urlFields")
    }
}

/// Represent the information for the URL image
public struct URLImage: Codable {
    /// A validly formatted URL.
    ///
    /// Example: "https://developer.twitter.com/en/docs/twitter-api"
    public var url: URL?
    /// The height of the media in pixels
    public var height: Int?
    /// The width of the media in pixels
    public var width: Int?

    public init(url: URL? = nil, height: Int? = nil, width: Int? = nil) {
        self.url = url
        self.height = height
        self.width = width
    }
}

/// Represent the portion of text recognized as a Hashtag, and its start and end position within the text.
public struct HashtagFields: Codable {
    /// The text of the Hashtag
    ///
    /// Example: "MondayMotivation"
    public var tag: String

    public init(tag: String) {
        self.tag = tag
    }
}

public struct HashtagEntity: Codable {
    /// Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is exclusive.
    public var entityIndicesInclusiveExclusive: EntityIndicesInclusiveExclusive
    /// Represent the portion of text recognized as a Hashtag, and its start and end position within the text.
    public var hashtagFields: HashtagFields

    public init(entityIndicesInclusiveExclusive: EntityIndicesInclusiveExclusive, hashtagFields: HashtagFields) {
        self.entityIndicesInclusiveExclusive = entityIndicesInclusiveExclusive
        self.hashtagFields = hashtagFields
    }

    public init(from decoder: Decoder) throws {
        self.entityIndicesInclusiveExclusive = try EntityIndicesInclusiveExclusive(from: decoder)
        self.hashtagFields = try HashtagFields(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(entityIndicesInclusiveExclusive, forKey: "entityIndicesInclusiveExclusive")
        try values.encode(hashtagFields, forKey: "hashtagFields")
    }
}

/// Represent the portion of text recognized as a Cashtag, and its start and end position within the text.
public struct CashtagFields: Codable {
    /// Example: "TWTR"
    public var tag: String

    public init(tag: String) {
        self.tag = tag
    }
}

public struct CashtagEntity: Codable {
    /// Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is exclusive.
    public var entityIndicesInclusiveExclusive: EntityIndicesInclusiveExclusive
    /// Represent the portion of text recognized as a Cashtag, and its start and end position within the text.
    public var cashtagFields: CashtagFields

    public init(entityIndicesInclusiveExclusive: EntityIndicesInclusiveExclusive, cashtagFields: CashtagFields) {
        self.entityIndicesInclusiveExclusive = entityIndicesInclusiveExclusive
        self.cashtagFields = cashtagFields
    }

    public init(from decoder: Decoder) throws {
        self.entityIndicesInclusiveExclusive = try EntityIndicesInclusiveExclusive(from: decoder)
        self.cashtagFields = try CashtagFields(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(entityIndicesInclusiveExclusive, forKey: "entityIndicesInclusiveExclusive")
        try values.encode(cashtagFields, forKey: "cashtagFields")
    }
}

/// Represent the portion of text recognized as a User mention, and its start and end position within the text.
public struct MentionFields: Codable {
    /// The Twitter handle (screen name) of this user.
    public var username: String
    /// Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "2244994945"
    public var id: String

    public init(username: String, id: String) {
        self.username = username
        self.id = id
    }
}

public struct MentionEntity: Codable {
    /// Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is exclusive.
    public var entityIndicesInclusiveExclusive: EntityIndicesInclusiveExclusive
    /// Represent the portion of text recognized as a User mention, and its start and end position within the text.
    public var mentionFields: MentionFields

    public init(entityIndicesInclusiveExclusive: EntityIndicesInclusiveExclusive, mentionFields: MentionFields) {
        self.entityIndicesInclusiveExclusive = entityIndicesInclusiveExclusive
        self.mentionFields = mentionFields
    }

    public init(from decoder: Decoder) throws {
        self.entityIndicesInclusiveExclusive = try EntityIndicesInclusiveExclusive(from: decoder)
        self.mentionFields = try MentionFields(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(entityIndicesInclusiveExclusive, forKey: "entityIndicesInclusiveExclusive")
        try values.encode(mentionFields, forKey: "mentionFields")
    }
}

public struct FullTextEntities: Codable {
    public var urls: [URLEntity]?
    public var hashtags: [HashtagEntity]?
    public var mentions: [MentionEntity]?
    public var cashtags: [CashtagEntity]?

    public init(urls: [URLEntity]? = nil, hashtags: [HashtagEntity]? = nil, mentions: [MentionEntity]? = nil, cashtags: [CashtagEntity]? = nil) {
        self.urls = urls
        self.hashtags = hashtags
        self.mentions = mentions
        self.cashtags = cashtags
    }
}

/// Shows who can reply a Tweet. Fields returned are everyone, mentioned_users, and following.
public enum ReplySettings: String, Codable, CaseIterable {
    case everyone
    case mentionedUsers
    case following
    case other
}

public struct Error: Codable {
    public var code: Int
    public var message: String

    public init(code: Int, message: String) {
        self.code = code
        self.message = message
    }
}

public struct Expansions: Codable {
    public var users: [User]?
    public var tweets: [Tweet]?
    public var places: [Place]?
    public var media: [Media]?
    public var polls: [Poll]?

    public init(users: [User]? = nil, tweets: [Tweet]? = nil, places: [Place]? = nil, media: [Media]? = nil, polls: [Poll]? = nil) {
        self.users = users
        self.tweets = tweets
        self.places = places
        self.media = media
        self.polls = polls
    }
}

/// Example:
///
/// {
///   "author_id" : "2244994945",
///   "created_at" : "Wed Jan 06 18:40:40 +0000 2021",
///   "id" : "1346889436626259968",
///   "text" : "Learn how to use the user Tweet timeline and user mention timeline endpoints in the Twitter API v2 to explore Tweet\\u2026 https:\\\/\\\/t.co\\\/56a0vZUx7i"
/// }
public struct Tweet: Codable {
    /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "1346889436626259968"
    public var id: String
    /// Creation time of the Tweet.
    ///
    /// Example: "2021-01-06T18:40:40.000Z"
    public var createdAt: Date?
    /// The content of the Tweet.
    ///
    /// Example: "Learn how to use the user Tweet timeline and user mention timeline endpoints in the Twitter API v2 to explore Tweet\u2026 https:\/\/t.co\/56a0vZUx7i"
    public var text: String
    /// Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "2244994945"
    public var authorID: String?
    /// Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "2244994945"
    public var inReplyToUserID: String?
    /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "1346889436626259968"
    public var conversationID: String?
    /// Shows who can reply a Tweet. Fields returned are everyone, mentioned_users, and following.
    public var replySettings: ReplySettings?
    /// A list of Tweets this Tweet refers to. For example, if the parent Tweet is a Retweet, a Quoted Tweet or a Reply, it will include the related Tweet referenced to by its parent.
    public var referencedTweets: [ReferencedTweet]?
    /// Specifies the type of attachments (if any) present in this Tweet.
    public var attachments: Attachments?
    public var contextAnnotations: [ContextAnnotation]?
    /// Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country).
    public var withheld: TweetWithheld?
    /// The location tagged on the Tweet, if the user provided one.
    public var geo: Geo?
    public var entities: FullTextEntities?
    /// Engagement metrics for the Tweet at the time of the request.
    public var publicMetrics: PublicMetrics?
    /// Indicates if this Tweet contains URLs marked as sensitive, for example content suitable for mature audiences.
    ///
    /// Example: false
    public var isPossiblySensitive: Bool?
    /// Language of the Tweet, if detected by Twitter. Returned as a BCP47 language tag.
    ///
    /// Example: "en"
    public var lang: String?
    /// The name of the app the user Tweeted from.
    public var source: String?
    /// Nonpublic engagement metrics for the Tweet at the time of the request.
    public var nonPublicMetrics: NonPublicMetrics?
    /// Promoted nonpublic engagement metrics for the Tweet at the time of the request.
    public var promotedMetrics: PromotedMetrics?
    /// Organic nonpublic engagement metrics for the Tweet at the time of the request.
    public var organicMetrics: OrganicMetrics?

    public struct ReferencedTweet: Codable {
        public var type: `Type`
        /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
        ///
        /// Example: "1346889436626259968"
        public var id: String

        public enum `Type`: String, Codable, CaseIterable {
            case retweeted
            case quoted
            case repliedTo = "replied_to"
        }

        public init(type: `Type`, id: String) {
            self.type = type
            self.id = id
        }
    }

    /// Specifies the type of attachments (if any) present in this Tweet.
    public struct Attachments: Codable {
        /// A list of Media Keys for each one of the media attachments (if media are attached).
        public var mediaKeys: [String]?
        /// A list of poll IDs (if polls are attached).
        public var pollIDs: [String]?

        public init(mediaKeys: [String]? = nil, pollIDs: [String]? = nil) {
            self.mediaKeys = mediaKeys
            self.pollIDs = pollIDs
        }

        private enum CodingKeys: String, CodingKey {
            case mediaKeys = "media_keys"
            case pollIDs = "poll_ids"
        }
    }

    /// The location tagged on the Tweet, if the user provided one.
    public struct Geo: Codable {
        /// A [GeoJson Point](https://tools.ietf.org/html/rfc7946#section-3.1.2) geometry object.
        public var coordinates: Point?
        /// The identifier for this place
        ///
        /// Example: "f7eb2fa2fea288b1"
        public var placeID: String?

        public init(coordinates: Point? = nil, placeID: String? = nil) {
            self.coordinates = coordinates
            self.placeID = placeID
        }

        private enum CodingKeys: String, CodingKey {
            case coordinates
            case placeID = "place_id"
        }
    }

    /// Engagement metrics for the Tweet at the time of the request.
    public struct PublicMetrics: Codable {
        /// Number of times this Tweet has been Retweeted.
        public var retweetCount: Int
        /// Number of times this Tweet has been replied to.
        public var replyCount: Int
        /// Number of times this Tweet has been liked.
        public var likeCount: Int
        /// Number of times this Tweet has been quoted.
        public var quoteCount: Int?

        public init(retweetCount: Int, replyCount: Int, likeCount: Int, quoteCount: Int? = nil) {
            self.retweetCount = retweetCount
            self.replyCount = replyCount
            self.likeCount = likeCount
            self.quoteCount = quoteCount
        }

        private enum CodingKeys: String, CodingKey {
            case retweetCount = "retweet_count"
            case replyCount = "reply_count"
            case likeCount = "like_count"
            case quoteCount = "quote_count"
        }
    }

    /// Nonpublic engagement metrics for the Tweet at the time of the request.
    public struct NonPublicMetrics: Codable {
        /// Number of times this Tweet has been viewed.
        public var impressionCount: Int?

        public init(impressionCount: Int? = nil) {
            self.impressionCount = impressionCount
        }

        private enum CodingKeys: String, CodingKey {
            case impressionCount = "impression_count"
        }
    }

    /// Promoted nonpublic engagement metrics for the Tweet at the time of the request.
    public struct PromotedMetrics: Codable {
        /// Number of times this Tweet has been viewed.
        public var impressionCount: Int?
        /// Number of times this Tweet has been liked.
        public var likeCount: Int?
        /// Number of times this Tweet has been replied to.
        public var replyCount: Int?
        /// Number of times this Tweet has been Retweeted.
        public var retweetCount: Int?

        public init(impressionCount: Int? = nil, likeCount: Int? = nil, replyCount: Int? = nil, retweetCount: Int? = nil) {
            self.impressionCount = impressionCount
            self.likeCount = likeCount
            self.replyCount = replyCount
            self.retweetCount = retweetCount
        }

        private enum CodingKeys: String, CodingKey {
            case impressionCount = "impression_count"
            case likeCount = "like_count"
            case replyCount = "reply_count"
            case retweetCount = "retweet_count"
        }
    }

    /// Organic nonpublic engagement metrics for the Tweet at the time of the request.
    public struct OrganicMetrics: Codable {
        /// Number of times this Tweet has been viewed.
        public var impressionCount: Int
        /// Number of times this Tweet has been Retweeted.
        public var retweetCount: Int
        /// Number of times this Tweet has been replied to.
        public var replyCount: Int
        /// Number of times this Tweet has been liked.
        public var likeCount: Int

        public init(impressionCount: Int, retweetCount: Int, replyCount: Int, likeCount: Int) {
            self.impressionCount = impressionCount
            self.retweetCount = retweetCount
            self.replyCount = replyCount
            self.likeCount = likeCount
        }

        private enum CodingKeys: String, CodingKey {
            case impressionCount = "impression_count"
            case retweetCount = "retweet_count"
            case replyCount = "reply_count"
            case likeCount = "like_count"
        }
    }

    public init(id: String, createdAt: Date? = nil, text: String, authorID: String? = nil, inReplyToUserID: String? = nil, conversationID: String? = nil, replySettings: ReplySettings? = nil, referencedTweets: [ReferencedTweet]? = nil, attachments: Attachments? = nil, contextAnnotations: [ContextAnnotation]? = nil, withheld: TweetWithheld? = nil, geo: Geo? = nil, entities: FullTextEntities? = nil, publicMetrics: PublicMetrics? = nil, isPossiblySensitive: Bool? = nil, lang: String? = nil, source: String? = nil, nonPublicMetrics: NonPublicMetrics? = nil, promotedMetrics: PromotedMetrics? = nil, organicMetrics: OrganicMetrics? = nil) {
        self.id = id
        self.createdAt = createdAt
        self.text = text
        self.authorID = authorID
        self.inReplyToUserID = inReplyToUserID
        self.conversationID = conversationID
        self.replySettings = replySettings
        self.referencedTweets = referencedTweets
        self.attachments = attachments
        self.contextAnnotations = contextAnnotations
        self.withheld = withheld
        self.geo = geo
        self.entities = entities
        self.publicMetrics = publicMetrics
        self.isPossiblySensitive = isPossiblySensitive
        self.lang = lang
        self.source = source
        self.nonPublicMetrics = nonPublicMetrics
        self.promotedMetrics = promotedMetrics
        self.organicMetrics = organicMetrics
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case createdAt = "created_at"
        case text
        case authorID = "author_id"
        case inReplyToUserID = "in_reply_to_user_id"
        case conversationID = "conversation_id"
        case replySettings = "reply_settings"
        case referencedTweets = "referenced_tweets"
        case attachments
        case contextAnnotations = "context_annotations"
        case withheld
        case geo
        case entities
        case publicMetrics = "public_metrics"
        case isPossiblySensitive = "possibly_sensitive"
        case lang
        case source
        case nonPublicMetrics = "non_public_metrics"
        case promotedMetrics = "promoted_metrics"
        case organicMetrics = "organic_metrics"
    }
}

/// The Twitter User object
///
/// Example:
///
/// {
///   "created_at" : "2013-12-14T04:35:55Z",
///   "id" : "2244994945",
///   "name" : "Twitter Dev",
///   "protected" : false,
///   "username" : "TwitterDev"
/// }
public struct User: Codable {
    /// Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "2244994945"
    public var id: String
    /// Creation time of this user.
    public var createdAt: Date?
    /// The friendly name of this user, as shown on their profile.
    public var name: String
    /// The Twitter handle (screen name) of this user.
    public var username: String
    /// Indicates if this user has chosen to protect their Tweets (in other words, if this user's Tweets are private).
    public var isProtected: Bool?
    /// Indicate if this user is a verified Twitter User.
    public var isVerified: Bool?
    /// Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country).
    public var withheld: UserWithheld?
    /// The URL to the profile image for this user.
    public var profileImageURL: URL?
    /// The location specified in the user's profile, if the user provided one. As this is a freeform value, it may not indicate a valid location, but it may be fuzzily evaluated when performing searches with location queries.
    public var location: String?
    /// The URL specified in the user's profile.
    public var url: String?
    /// The text of this user's profile description (also known as bio), if the user provided one.
    public var description: String?
    /// A list of metadata found in the user's profile description.
    public var entities: Entities?
    /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "1346889436626259968"
    public var pinnedTweetID: String?
    /// A list of metrics for this user
    public var publicMetrics: PublicMetrics?

    /// A list of metadata found in the user's profile description.
    public struct Entities: Codable {
        /// Expanded details for the URL specified in the user's profile, with start and end indices.
        public var url: URL?
        public var description: FullTextEntities?

        /// Expanded details for the URL specified in the user's profile, with start and end indices.
        public struct URL: Codable {
            public var urls: [URLEntity]?

            public init(urls: [URLEntity]? = nil) {
                self.urls = urls
            }
        }

        public init(url: URL? = nil, description: FullTextEntities? = nil) {
            self.url = url
            self.description = description
        }
    }

    /// A list of metrics for this user
    public struct PublicMetrics: Codable {
        /// Number of users who are following this user.
        public var followersCount: Int
        /// Number of users this user is following.
        public var followingCount: Int
        /// The number of Tweets (including Retweets) posted by this user.
        public var tweetCount: Int
        /// The number of lists that include this user.
        public var listedCount: Int

        public init(followersCount: Int, followingCount: Int, tweetCount: Int, listedCount: Int) {
            self.followersCount = followersCount
            self.followingCount = followingCount
            self.tweetCount = tweetCount
            self.listedCount = listedCount
        }

        private enum CodingKeys: String, CodingKey {
            case followersCount = "followers_count"
            case followingCount = "following_count"
            case tweetCount = "tweet_count"
            case listedCount = "listed_count"
        }
    }

    public init(id: String, createdAt: Date? = nil, name: String, username: String, isProtected: Bool? = nil, isVerified: Bool? = nil, withheld: UserWithheld? = nil, profileImageURL: URL? = nil, location: String? = nil, url: String? = nil, description: String? = nil, entities: Entities? = nil, pinnedTweetID: String? = nil, publicMetrics: PublicMetrics? = nil) {
        self.id = id
        self.createdAt = createdAt
        self.name = name
        self.username = username
        self.isProtected = isProtected
        self.isVerified = isVerified
        self.withheld = withheld
        self.profileImageURL = profileImageURL
        self.location = location
        self.url = url
        self.description = description
        self.entities = entities
        self.pinnedTweetID = pinnedTweetID
        self.publicMetrics = publicMetrics
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case createdAt = "created_at"
        case name
        case username
        case isProtected = "protected"
        case isVerified = "verified"
        case withheld
        case profileImageURL = "profile_image_url"
        case location
        case url
        case description
        case entities
        case pinnedTweetID = "pinned_tweet_id"
        case publicMetrics = "public_metrics"
    }
}

public struct MultiUserLookupResponse: Codable {
    public var data: [User]?
    public var includes: Expansions?
    public var errors: [Problem]?

    public init(data: [User]? = nil, includes: Expansions? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.includes = includes
        self.errors = errors
    }
}

public struct SingleUserLookupResponse: Codable {
    /// The Twitter User object
    ///
    /// Example:
    ///
    /// {
    ///   "created_at" : "2013-12-14T04:35:55Z",
    ///   "id" : "2244994945",
    ///   "name" : "Twitter Dev",
    ///   "protected" : false,
    ///   "username" : "TwitterDev"
    /// }
    public var data: User?
    public var includes: Expansions?
    public var errors: [Problem]?

    public init(data: User? = nil, includes: Expansions? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.includes = includes
        self.errors = errors
    }
}

public struct MultiTweetLookupResponse: Codable {
    public var data: [Tweet]?
    public var includes: Expansions?
    public var errors: [Problem]?

    public init(data: [Tweet]? = nil, includes: Expansions? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.includes = includes
        self.errors = errors
    }
}

public struct SingleTweetLookupResponse: Codable {
    /// Example:
    ///
    /// {
    ///   "author_id" : "2244994945",
    ///   "created_at" : "Wed Jan 06 18:40:40 +0000 2021",
    ///   "id" : "1346889436626259968",
    ///   "text" : "Learn how to use the user Tweet timeline and user mention timeline endpoints in the Twitter API v2 to explore Tweet\\u2026 https:\\\/\\\/t.co\\\/56a0vZUx7i"
    /// }
    public var data: Tweet?
    public var includes: Expansions?
    public var errors: [Problem]?

    public init(data: Tweet? = nil, includes: Expansions? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.includes = includes
        self.errors = errors
    }
}

/// A [GeoJson Point](https://tools.ietf.org/html/rfc7946#section-3.1.2) geometry object.
public struct Point: Codable {
    /// Example: "Point"
    public var type: `Type`
    /// A [GeoJson Position](https://tools.ietf.org/html/rfc7946#section-3.1.1) in the format `[longitude,latitude]`.
    ///
    /// Example:
    ///
    /// [
    ///   -105.18816086351444,
    ///   40.247749999999996
    /// ]
    public var coordinates: [Double]

    /// Example: "Point"
    public enum `Type`: String, Codable, CaseIterable {
        case point = "Point"
    }

    public init(type: `Type`, coordinates: [Double]) {
        self.type = type
        self.coordinates = coordinates
    }
}

public struct Geo: Codable {
    public var type: `Type`
    /// Example:
    ///
    /// [
    ///   -105.19347500000001,
    ///   39.609729999999999,
    ///   -105.053164,
    ///   39.761974000000002
    /// ]
    public var bbox: [Double]
    /// A [GeoJson Point](https://tools.ietf.org/html/rfc7946#section-3.1.2) geometry object.
    public var geometry: Point?
    public var properties: Properties

    public enum `Type`: String, Codable, CaseIterable {
        case feature = "Feature"
    }

    public struct Properties: Codable {
        public init() {}
    }

    public init(type: `Type`, bbox: [Double], geometry: Point? = nil, properties: Properties) {
        self.type = type
        self.bbox = bbox
        self.geometry = geometry
        self.properties = properties
    }
}

public struct Place: Codable {
    /// The identifier for this place
    ///
    /// Example: "f7eb2fa2fea288b1"
    public var id: String
    /// The human readable name of this place.
    ///
    /// Example: "Lakewood"
    public var name: String?
    /// A two-letter ISO 3166-1 alpha-2 country code
    ///
    /// Example: "US"
    public var countryCode: String?
    /// Example: "city"
    public var placeType: PlaceType?
    /// The full name of this place.
    ///
    /// Example: "Lakewood, CO"
    public var fullName: String
    /// The full name of the county in which this place exists.
    ///
    /// Example: "United States"
    public var country: String?
    public var containedWithin: [String]?
    public var geo: Geo?

    public init(id: String, name: String? = nil, countryCode: String? = nil, placeType: PlaceType? = nil, fullName: String, country: String? = nil, containedWithin: [String]? = nil, geo: Geo? = nil) {
        self.id = id
        self.name = name
        self.countryCode = countryCode
        self.placeType = placeType
        self.fullName = fullName
        self.country = country
        self.containedWithin = containedWithin
        self.geo = geo
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case countryCode = "country_code"
        case placeType = "place_type"
        case fullName = "full_name"
        case country
        case containedWithin = "contained_within"
        case geo
    }
}

/// Example: "city"
public enum PlaceType: String, Codable, CaseIterable {
    case poi
    case neighborhood
    case city
    case admin
    case country
    case unknown
}

/// Represent a Poll attached to a Tweet
public struct Poll: Codable {
    /// Unique identifier of this poll.
    ///
    /// Example: "1365059861688410112"
    public var id: String
    public var options: [PollOption]
    public var votingStatus: VotingStatus?
    public var endDatetime: Date?
    public var durationMinutes: Int?

    public enum VotingStatus: String, Codable, CaseIterable {
        case `open`
        case closed
    }

    public init(id: String, options: [PollOption], votingStatus: VotingStatus? = nil, endDatetime: Date? = nil, durationMinutes: Int? = nil) {
        self.id = id
        self.options = options
        self.votingStatus = votingStatus
        self.endDatetime = endDatetime
        self.durationMinutes = durationMinutes
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case options
        case votingStatus = "voting_status"
        case endDatetime = "end_datetime"
        case durationMinutes = "duration_minutes"
    }
}

/// Describes a choice in a Poll object.
public struct PollOption: Codable {
    /// Position of this choice in the poll.
    public var position: Int
    /// The text of a poll choice.
    public var label: String
    /// Number of users who voted for this choice.
    public var votes: Int

    public init(position: Int, label: String, votes: Int) {
        self.position = position
        self.label = label
        self.votes = votes
    }
}

/// A Twitter List is a curated group of accounts.
public struct List: Codable {
    /// The unique identifier of this List.
    ///
    /// Example: "1146654567674912769"
    public var id: String
    /// The name of this List.
    public var name: String
    public var createdAt: Date?
    public var description: String?
    public var followerCount: Int?
    public var memberCount: Int?
    /// Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "2244994945"
    public var ownerID: String?
    public var isPrivate: Bool?

    public init(id: String, name: String, createdAt: Date? = nil, description: String? = nil, followerCount: Int? = nil, memberCount: Int? = nil, ownerID: String? = nil, isPrivate: Bool? = nil) {
        self.id = id
        self.name = name
        self.createdAt = createdAt
        self.description = description
        self.followerCount = followerCount
        self.memberCount = memberCount
        self.ownerID = ownerID
        self.isPrivate = isPrivate
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case createdAt = "created_at"
        case description
        case followerCount = "follower_count"
        case memberCount = "member_count"
        case ownerID = "owner_id"
        case isPrivate = "private"
    }
}

public struct ListCreateRequest: Codable {
    public var name: String
    public var description: String?
    public var isPrivate: Bool?

    public init(name: String, description: String? = nil, isPrivate: Bool? = nil) {
        self.name = name
        self.description = description
        self.isPrivate = isPrivate
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case description
        case isPrivate = "private"
    }
}

public struct ListCreateResponse: Codable {
    /// A Twitter List is a curated group of accounts.
    public var data: List?
    public var errors: [Problem]?

    public init(data: List? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct ListDeleteResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isDeleted: Bool?

        public init(isDeleted: Bool? = nil) {
            self.isDeleted = isDeleted
        }

        private enum CodingKeys: String, CodingKey {
            case isDeleted = "deleted"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct ListUpdateRequest: Codable {
    public var name: String?
    public var description: String?
    public var isPrivate: Bool?

    public init(name: String? = nil, description: String? = nil, isPrivate: Bool? = nil) {
        self.name = name
        self.description = description
        self.isPrivate = isPrivate
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case description
        case isPrivate = "private"
    }
}

public struct ListUpdateResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isUpdated: Bool?

        public init(isUpdated: Bool? = nil) {
            self.isUpdated = isUpdated
        }

        private enum CodingKeys: String, CodingKey {
            case isUpdated = "updated"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct ListAddMemberRequest: Codable {
    /// Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "2244994945"
    public var userID: String?

    public init(userID: String? = nil) {
        self.userID = userID
    }

    private enum CodingKeys: String, CodingKey {
        case userID = "user_id"
    }
}

public struct ListMemberResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isMember: Bool?

        public init(isMember: Bool? = nil) {
            self.isMember = isMember
        }

        private enum CodingKeys: String, CodingKey {
            case isMember = "member"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct ListFollowRequest: Codable {
    /// The unique identifier of this List.
    ///
    /// Example: "1146654567674912769"
    public var listID: String?

    public init(listID: String? = nil) {
        self.listID = listID
    }

    private enum CodingKeys: String, CodingKey {
        case listID = "list_id"
    }
}

public struct ListFollowedResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isFollowing: Bool?

        public init(isFollowing: Bool? = nil) {
            self.isFollowing = isFollowing
        }

        private enum CodingKeys: String, CodingKey {
            case isFollowing = "following"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct ListPinRequest: Codable {
    /// The unique identifier of this List.
    ///
    /// Example: "1146654567674912769"
    public var listID: String?

    public init(listID: String? = nil) {
        self.listID = listID
    }

    private enum CodingKeys: String, CodingKey {
        case listID = "list_id"
    }
}

public struct ListPinnedResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isPinned: Bool?

        public init(isPinned: Bool? = nil) {
            self.isPinned = isPinned
        }

        private enum CodingKeys: String, CodingKey {
            case isPinned = "pinned"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct SingleListLookupResponse: Codable {
    /// A Twitter List is a curated group of accounts.
    public var data: List?
    public var errors: [Problem]?

    public init(data: List? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct MultiListResponse: Codable {
    public var data: [List]?
    public var meta: Meta?
    public var errors: [Problem]?

    public struct Meta: Codable {
        /// The previous token
        public var previousToken: String?
        /// The next token
        public var nextToken: String?
        /// The number of list results returned in this response
        public var resultCount: Int?

        public init(previousToken: String? = nil, nextToken: String? = nil, resultCount: Int? = nil) {
            self.previousToken = previousToken
            self.nextToken = nextToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case previousToken = "previous_token"
            case nextToken = "next_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [List]? = nil, meta: Meta? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.meta = meta
        self.errors = errors
    }
}

public struct MultiListNoPaginationResponse: Codable {
    public var data: [List]?
    public var meta: Meta?
    public var errors: [Problem]?

    public struct Meta: Codable {
        /// The number of list results returned in this response
        public var resultCount: Int?

        public init(resultCount: Int? = nil) {
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case resultCount = "result_count"
        }
    }

    public init(data: [List]? = nil, meta: Meta? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.meta = meta
        self.errors = errors
    }
}

public struct TweetDeleteResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isDeleted: Bool

        public init(isDeleted: Bool) {
            self.isDeleted = isDeleted
        }

        private enum CodingKeys: String, CodingKey {
            case isDeleted = "deleted"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct TweetCreateResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
        ///
        /// Example: "1346889436626259968"
        public var id: String
        /// The content of the Tweet.
        ///
        /// Example: "Learn how to use the user Tweet timeline and user mention timeline endpoints in the Twitter API v2 to explore Tweet\u2026 https:\/\/t.co\/56a0vZUx7i"
        public var text: String

        public init(id: String, text: String) {
            self.id = id
            self.text = text
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct CommonMediaFields: Codable {
    /// The Media Key identifier for this attachment.
    public var mediaKey: String?
    /// The height of the media in pixels
    public var height: Int?
    /// The width of the media in pixels
    public var width: Int?

    public init(mediaKey: String? = nil, height: Int? = nil, width: Int? = nil) {
        self.mediaKey = mediaKey
        self.height = height
        self.width = width
    }

    private enum CodingKeys: String, CodingKey {
        case mediaKey = "media_key"
        case height
        case width
    }
}

public enum Media: Codable {
    case photo(Photo)
    case video(Video)
    case animatedGif(AnimatedGif)

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(Photo.self) {
            self = .photo(value)
        } else if let value = try? container.decode(Video.self) {
            self = .video(value)
        } else if let value = try? container.decode(AnimatedGif.self) {
            self = .animatedGif(value)
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .photo(let value): try container.encode(value)
        case .video(let value): try container.encode(value)
        case .animatedGif(let value): try container.encode(value)
        }
    }
}

public struct Photo: Codable {
    public var commonMediaFields: CommonMediaFields
    public var type: `Type`?
    public var url: URL?
    public var altText: String?

    public enum `Type`: String, Codable, CaseIterable {
        case photo
    }

    public init(commonMediaFields: CommonMediaFields, type: `Type`? = nil, url: URL? = nil, altText: String? = nil) {
        self.commonMediaFields = commonMediaFields
        self.type = type
        self.url = url
        self.altText = altText
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.commonMediaFields = try CommonMediaFields(from: decoder)
        self.type = try `Type`(from: decoder)
        self.url = try values.decodeIfPresent(URL.self, forKey: "url")
        self.altText = try values.decodeIfPresent(String.self, forKey: "alt_text")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(commonMediaFields, forKey: "commonMediaFields")
        try values.encodeIfPresent(type, forKey: "type")
        try values.encodeIfPresent(url, forKey: "url")
        try values.encodeIfPresent(altText, forKey: "alt_text")
    }
}

public struct Video: Codable {
    public var commonMediaFields: CommonMediaFields
    public var type: `Type`?
    public var previewImageURL: URL?
    public var durationMs: Int?
    /// Engagement metrics for the Media at the time of the request.
    public var publicMetrics: PublicMetrics?
    /// Nonpublic engagement metrics for the Media at the time of the request.
    public var nonPublicMetrics: NonPublicMetrics?
    /// Organic nonpublic engagement metrics for the Media at the time of the request.
    public var organicMetrics: OrganicMetrics?
    /// Promoted nonpublic engagement metrics for the Media at the time of the request.
    public var promotedMetrics: PromotedMetrics?

    public enum `Type`: String, Codable, CaseIterable {
        case video
    }

    /// Engagement metrics for the Media at the time of the request.
    public struct PublicMetrics: Codable {
        /// Number of times this video has been viewed.
        public var viewCount: Int?

        public init(viewCount: Int? = nil) {
            self.viewCount = viewCount
        }

        private enum CodingKeys: String, CodingKey {
            case viewCount = "view_count"
        }
    }

    /// Nonpublic engagement metrics for the Media at the time of the request.
    public struct NonPublicMetrics: Codable {
        /// Number of users who made it through 0% of the video.
        public var playback0Count: Int?
        /// Number of users who made it through 25% of the video.
        public var playback25Count: Int?
        /// Number of users who made it through 50% of the video.
        public var playback50Count: Int?
        /// Number of users who made it through 75% of the video.
        public var playback75Count: Int?
        /// Number of users who made it through 100% of the video.
        public var playback100Count: Int?

        public init(playback0Count: Int? = nil, playback25Count: Int? = nil, playback50Count: Int? = nil, playback75Count: Int? = nil, playback100Count: Int? = nil) {
            self.playback0Count = playback0Count
            self.playback25Count = playback25Count
            self.playback50Count = playback50Count
            self.playback75Count = playback75Count
            self.playback100Count = playback100Count
        }

        private enum CodingKeys: String, CodingKey {
            case playback0Count = "playback_0_count"
            case playback25Count = "playback_25_count"
            case playback50Count = "playback_50_count"
            case playback75Count = "playback_75_count"
            case playback100Count = "playback_100_count"
        }
    }

    /// Organic nonpublic engagement metrics for the Media at the time of the request.
    public struct OrganicMetrics: Codable {
        /// Number of users who made it through 0% of the video.
        public var playback0Count: Int?
        /// Number of users who made it through 25% of the video.
        public var playback25Count: Int?
        /// Number of users who made it through 50% of the video.
        public var playback50Count: Int?
        /// Number of users who made it through 75% of the video.
        public var playback75Count: Int?
        /// Number of users who made it through 100% of the video.
        public var playback100Count: Int?
        /// Number of times this video has been viewed.
        public var viewCount: Int?

        public init(playback0Count: Int? = nil, playback25Count: Int? = nil, playback50Count: Int? = nil, playback75Count: Int? = nil, playback100Count: Int? = nil, viewCount: Int? = nil) {
            self.playback0Count = playback0Count
            self.playback25Count = playback25Count
            self.playback50Count = playback50Count
            self.playback75Count = playback75Count
            self.playback100Count = playback100Count
            self.viewCount = viewCount
        }

        private enum CodingKeys: String, CodingKey {
            case playback0Count = "playback_0_count"
            case playback25Count = "playback_25_count"
            case playback50Count = "playback_50_count"
            case playback75Count = "playback_75_count"
            case playback100Count = "playback_100_count"
            case viewCount = "view_count"
        }
    }

    /// Promoted nonpublic engagement metrics for the Media at the time of the request.
    public struct PromotedMetrics: Codable {
        /// Number of users who made it through 0% of the video.
        public var playback0Count: Int?
        /// Number of users who made it through 25% of the video.
        public var playback25Count: Int?
        /// Number of users who made it through 50% of the video.
        public var playback50Count: Int?
        /// Number of users who made it through 75% of the video.
        public var playback75Count: Int?
        /// Number of users who made it through 100% of the video.
        public var playback100Count: Int?
        /// Number of times this video has been viewed.
        public var viewCount: Int?

        public init(playback0Count: Int? = nil, playback25Count: Int? = nil, playback50Count: Int? = nil, playback75Count: Int? = nil, playback100Count: Int? = nil, viewCount: Int? = nil) {
            self.playback0Count = playback0Count
            self.playback25Count = playback25Count
            self.playback50Count = playback50Count
            self.playback75Count = playback75Count
            self.playback100Count = playback100Count
            self.viewCount = viewCount
        }

        private enum CodingKeys: String, CodingKey {
            case playback0Count = "playback_0_count"
            case playback25Count = "playback_25_count"
            case playback50Count = "playback_50_count"
            case playback75Count = "playback_75_count"
            case playback100Count = "playback_100_count"
            case viewCount = "view_count"
        }
    }

    public init(commonMediaFields: CommonMediaFields, type: `Type`? = nil, previewImageURL: URL? = nil, durationMs: Int? = nil, publicMetrics: PublicMetrics? = nil, nonPublicMetrics: NonPublicMetrics? = nil, organicMetrics: OrganicMetrics? = nil, promotedMetrics: PromotedMetrics? = nil) {
        self.commonMediaFields = commonMediaFields
        self.type = type
        self.previewImageURL = previewImageURL
        self.durationMs = durationMs
        self.publicMetrics = publicMetrics
        self.nonPublicMetrics = nonPublicMetrics
        self.organicMetrics = organicMetrics
        self.promotedMetrics = promotedMetrics
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.commonMediaFields = try CommonMediaFields(from: decoder)
        self.type = try `Type`(from: decoder)
        self.previewImageURL = try values.decodeIfPresent(URL.self, forKey: "preview_image_url")
        self.durationMs = try values.decodeIfPresent(Int.self, forKey: "duration_ms")
        self.publicMetrics = try PublicMetrics(from: decoder)
        self.nonPublicMetrics = try NonPublicMetrics(from: decoder)
        self.organicMetrics = try OrganicMetrics(from: decoder)
        self.promotedMetrics = try PromotedMetrics(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(commonMediaFields, forKey: "commonMediaFields")
        try values.encodeIfPresent(type, forKey: "type")
        try values.encodeIfPresent(previewImageURL, forKey: "preview_image_url")
        try values.encodeIfPresent(durationMs, forKey: "duration_ms")
        try values.encodeIfPresent(publicMetrics, forKey: "public_metrics")
        try values.encodeIfPresent(nonPublicMetrics, forKey: "non_public_metrics")
        try values.encodeIfPresent(organicMetrics, forKey: "organic_metrics")
        try values.encodeIfPresent(promotedMetrics, forKey: "promoted_metrics")
    }
}

public struct AnimatedGif: Codable {
    public var commonMediaFields: CommonMediaFields
    public var type: `Type`?
    public var previewImageURL: URL?

    public enum `Type`: String, Codable, CaseIterable {
        case animatedGif = "animated_gif"
    }

    public init(commonMediaFields: CommonMediaFields, type: `Type`? = nil, previewImageURL: URL? = nil) {
        self.commonMediaFields = commonMediaFields
        self.type = type
        self.previewImageURL = previewImageURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.commonMediaFields = try CommonMediaFields(from: decoder)
        self.type = try `Type`(from: decoder)
        self.previewImageURL = try values.decodeIfPresent(URL.self, forKey: "preview_image_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(commonMediaFields, forKey: "commonMediaFields")
        try values.encodeIfPresent(type, forKey: "type")
        try values.encodeIfPresent(previewImageURL, forKey: "preview_image_url")
    }
}

/// Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country).
public struct TweetWithheld: Codable {
    /// Indicates if the content is being withheld for on the basis of copyright infringement.
    public var isCopyright: Bool
    /// Provides a list of countries where this content is not available.
    public var countryCodes: [String]
    /// Indicates whether the content being withheld is the `tweet` or a `user`.
    public var scope: Scope?

    /// Indicates whether the content being withheld is the `tweet` or a `user`.
    public enum Scope: String, Codable, CaseIterable {
        case tweet
        case user
    }

    public init(isCopyright: Bool, countryCodes: [String], scope: Scope? = nil) {
        self.isCopyright = isCopyright
        self.countryCodes = countryCodes
        self.scope = scope
    }

    private enum CodingKeys: String, CodingKey {
        case isCopyright = "copyright"
        case countryCodes = "country_codes"
        case scope
    }
}

/// Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country).
public struct UserWithheld: Codable {
    /// Provides a list of countries where this content is not available.
    public var countryCodes: [String]
    /// Indicates that the content being withheld is a `user`.
    public var scope: Scope?

    /// Indicates that the content being withheld is a `user`.
    public enum Scope: String, Codable, CaseIterable {
        case user
    }

    public init(countryCodes: [String], scope: Scope? = nil) {
        self.countryCodes = countryCodes
        self.scope = scope
    }

    private enum CodingKeys: String, CodingKey {
        case countryCodes = "country_codes"
        case scope
    }
}

public struct ProblemFields: Codable {
    public var title: String
    public var detail: String

    public init(title: String, detail: String) {
        self.title = title
        self.detail = detail
    }
}

/// A generic problem with no additional information beyond that provided by the HTTP status code.
public struct GenericProblem: Codable {
    public var problemFields: ProblemFields
    public var type: `Type`?
    public var status: Int

    public enum `Type`: String, Codable, CaseIterable {
        case aboutBlank = "about:blank"
    }

    public init(problemFields: ProblemFields, type: `Type`? = nil, status: Int) {
        self.problemFields = problemFields
        self.type = type
        self.status = status
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.problemFields = try ProblemFields(from: decoder)
        self.type = try `Type`(from: decoder)
        self.status = try values.decode(Int.self, forKey: "status")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problemFields, forKey: "problemFields")
        try values.encodeIfPresent(type, forKey: "type")
        try values.encode(status, forKey: "status")
    }
}

/// A problem that indicates this request is invalid.
public struct InvalidRequestProblem: Codable {
    public var problemFields: ProblemFields
    public var type: `Type`?
    public var errors: [Error]?

    public enum `Type`: String, Codable, CaseIterable {
        case httpsAPITwitterCom2ProblemsInvalidRequest = "https://api.twitter.com/2/problems/invalid-request"
    }

    public struct Error: Codable {
        public var parameters: [String: [String]]?
        public var message: String?

        public init(parameters: [String: [String]]? = nil, message: String? = nil) {
            self.parameters = parameters
            self.message = message
        }
    }

    public init(problemFields: ProblemFields, type: `Type`? = nil, errors: [Error]? = nil) {
        self.problemFields = problemFields
        self.type = type
        self.errors = errors
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.problemFields = try ProblemFields(from: decoder)
        self.type = try `Type`(from: decoder)
        self.errors = try values.decodeIfPresent([Error].self, forKey: "errors")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problemFields, forKey: "problemFields")
        try values.encodeIfPresent(type, forKey: "type")
        try values.encodeIfPresent(errors, forKey: "errors")
    }
}

/// A problem that indicates that a given Tweet, User, etc. does not exist.
public struct ResourceNotFoundProblem: Codable {
    public var problemFields: ProblemFields
    public var type: `Type`?
    public var parameter: String
    /// Value will match the schema of the field.
    public var value: AnyJSON
    public var resourceID: String
    public var resourceType: ResourceType

    public enum `Type`: String, Codable, CaseIterable {
        case httpsAPITwitterCom2ProblemsResourceNotFound = "https://api.twitter.com/2/problems/resource-not-found"
    }

    public enum ResourceType: String, Codable, CaseIterable {
        case user
        case tweet
        case media
    }

    public init(problemFields: ProblemFields, type: `Type`? = nil, parameter: String, value: AnyJSON, resourceID: String, resourceType: ResourceType) {
        self.problemFields = problemFields
        self.type = type
        self.parameter = parameter
        self.value = value
        self.resourceID = resourceID
        self.resourceType = resourceType
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.problemFields = try ProblemFields(from: decoder)
        self.type = try `Type`(from: decoder)
        self.parameter = try values.decode(String.self, forKey: "parameter")
        self.value = try AnyJSON(from: decoder)
        self.resourceID = try values.decode(String.self, forKey: "resource_id")
        self.resourceType = try ResourceType(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problemFields, forKey: "problemFields")
        try values.encodeIfPresent(type, forKey: "type")
        try values.encode(parameter, forKey: "parameter")
        try values.encode(value, forKey: "value")
        try values.encode(resourceID, forKey: "resource_id")
        try values.encode(resourceType, forKey: "resource_type")
    }
}

/// A problem that indicates you are not allowed to see a particular Tweet, User, etc.
public struct ResourceUnauthorizedProblem: Codable {
    public var problemFields: ProblemFields
    public var type: `Type`?
    public var value: String
    public var parameter: String
    public var section: Section
    public var resourceID: String
    public var resourceType: ResourceType

    public enum `Type`: String, Codable, CaseIterable {
        case httpsAPITwitterCom2ProblemsNotAuthorizedForResource = "https://api.twitter.com/2/problems/not-authorized-for-resource"
    }

    public enum Section: String, Codable, CaseIterable {
        case data
        case includes
    }

    public enum ResourceType: String, Codable, CaseIterable {
        case tweet
        case user
        case media
    }

    public init(problemFields: ProblemFields, type: `Type`? = nil, value: String, parameter: String, section: Section, resourceID: String, resourceType: ResourceType) {
        self.problemFields = problemFields
        self.type = type
        self.value = value
        self.parameter = parameter
        self.section = section
        self.resourceID = resourceID
        self.resourceType = resourceType
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.problemFields = try ProblemFields(from: decoder)
        self.type = try `Type`(from: decoder)
        self.value = try values.decode(String.self, forKey: "value")
        self.parameter = try values.decode(String.self, forKey: "parameter")
        self.section = try Section(from: decoder)
        self.resourceID = try values.decode(String.self, forKey: "resource_id")
        self.resourceType = try ResourceType(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problemFields, forKey: "problemFields")
        try values.encodeIfPresent(type, forKey: "type")
        try values.encode(value, forKey: "value")
        try values.encode(parameter, forKey: "parameter")
        try values.encode(section, forKey: "section")
        try values.encode(resourceID, forKey: "resource_id")
        try values.encode(resourceType, forKey: "resource_type")
    }
}

/// A problem that indicates a particular Tweet, User, etc. is not available to you.
public struct ResourceUnavailableProblem: Codable {
    public var problemFields: ProblemFields
    public var type: `Type`?
    public var parameter: String
    public var resourceID: String
    public var resourceType: ResourceType

    public enum `Type`: String, Codable, CaseIterable {
        case httpsAPITwitterCom2ProblemsResourceUnavailable = "https://api.twitter.com/2/problems/resource-unavailable"
    }

    public enum ResourceType: String, Codable, CaseIterable {
        case user
        case tweet
        case media
    }

    public init(problemFields: ProblemFields, type: `Type`? = nil, parameter: String, resourceID: String, resourceType: ResourceType) {
        self.problemFields = problemFields
        self.type = type
        self.parameter = parameter
        self.resourceID = resourceID
        self.resourceType = resourceType
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.problemFields = try ProblemFields(from: decoder)
        self.type = try `Type`(from: decoder)
        self.parameter = try values.decode(String.self, forKey: "parameter")
        self.resourceID = try values.decode(String.self, forKey: "resource_id")
        self.resourceType = try ResourceType(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problemFields, forKey: "problemFields")
        try values.encodeIfPresent(type, forKey: "type")
        try values.encode(parameter, forKey: "parameter")
        try values.encode(resourceID, forKey: "resource_id")
        try values.encode(resourceType, forKey: "resource_type")
    }
}

/// A problem that indicates that you are not allowed to see a particular field on a Tweet, User, etc.
public struct FieldUnauthorizedProblem: Codable {
    public var problemFields: ProblemFields
    public var type: `Type`?
    public var section: Section
    public var resourceType: ResourceType
    public var field: String

    public enum `Type`: String, Codable, CaseIterable {
        case httpsAPITwitterCom2ProblemsNotAuthorizedForField = "https://api.twitter.com/2/problems/not-authorized-for-field"
    }

    public enum Section: String, Codable, CaseIterable {
        case data
        case includes
    }

    public enum ResourceType: String, Codable, CaseIterable {
        case tweet
        case media
    }

    public init(problemFields: ProblemFields, type: `Type`? = nil, section: Section, resourceType: ResourceType, field: String) {
        self.problemFields = problemFields
        self.type = type
        self.section = section
        self.resourceType = resourceType
        self.field = field
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.problemFields = try ProblemFields(from: decoder)
        self.type = try `Type`(from: decoder)
        self.section = try Section(from: decoder)
        self.resourceType = try ResourceType(from: decoder)
        self.field = try values.decode(String.self, forKey: "field")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problemFields, forKey: "problemFields")
        try values.encodeIfPresent(type, forKey: "type")
        try values.encode(section, forKey: "section")
        try values.encode(resourceType, forKey: "resource_type")
        try values.encode(field, forKey: "field")
    }
}

/// A problem that indicates your client is forbidden from making this request.
public struct ClientForbiddenProblem: Codable {
    public var problemFields: ProblemFields
    public var type: `Type`?
    public var reason: Reason?
    public var registrationURL: URL?

    public enum `Type`: String, Codable, CaseIterable {
        case httpsAPITwitterCom2ProblemsClientForbidden = "https://api.twitter.com/2/problems/client-forbidden"
    }

    public enum Reason: String, Codable, CaseIterable {
        case officialClientForbidden = "official-client-forbidden"
        case clientNotEnrolled = "client-not-enrolled"
    }

    public init(problemFields: ProblemFields, type: `Type`? = nil, reason: Reason? = nil, registrationURL: URL? = nil) {
        self.problemFields = problemFields
        self.type = type
        self.reason = reason
        self.registrationURL = registrationURL
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.problemFields = try ProblemFields(from: decoder)
        self.type = try `Type`(from: decoder)
        self.reason = try Reason(from: decoder)
        self.registrationURL = try values.decodeIfPresent(URL.self, forKey: "registration_url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problemFields, forKey: "problemFields")
        try values.encodeIfPresent(type, forKey: "type")
        try values.encodeIfPresent(reason, forKey: "reason")
        try values.encodeIfPresent(registrationURL, forKey: "registration_url")
    }
}

/// A problem that indicates that the resource requested violates the precepts of this API.
public struct DisallowedResourceProblem: Codable {
    public var problemFields: ProblemFields
    public var type: `Type`?
    public var resourceID: String
    public var resourceType: ResourceType
    public var section: Section

    public enum `Type`: String, Codable, CaseIterable {
        case httpsAPITwitterCom2ProblemsDisallowedResource = "https://api.twitter.com/2/problems/disallowed-resource"
    }

    public enum ResourceType: String, Codable, CaseIterable {
        case tweet
        case media
    }

    public enum Section: String, Codable, CaseIterable {
        case data
        case includes
    }

    public init(problemFields: ProblemFields, type: `Type`? = nil, resourceID: String, resourceType: ResourceType, section: Section) {
        self.problemFields = problemFields
        self.type = type
        self.resourceID = resourceID
        self.resourceType = resourceType
        self.section = section
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.problemFields = try ProblemFields(from: decoder)
        self.type = try `Type`(from: decoder)
        self.resourceID = try values.decode(String.self, forKey: "resource_id")
        self.resourceType = try ResourceType(from: decoder)
        self.section = try Section(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problemFields, forKey: "problemFields")
        try values.encodeIfPresent(type, forKey: "type")
        try values.encode(resourceID, forKey: "resource_id")
        try values.encode(resourceType, forKey: "resource_type")
        try values.encode(section, forKey: "section")
    }
}

/// A problem that indicates that the authentication used is not supported.
public struct UnsupportedAuthenticationProblem: Codable {
    public var problemFields: ProblemFields
    public var type: `Type`?

    public enum `Type`: String, Codable, CaseIterable {
        case httpsAPITwitterCom2ProblemsUnsupportedAuthentication = "https://api.twitter.com/2/problems/unsupported-authentication"
    }

    public init(problemFields: ProblemFields, type: `Type`? = nil) {
        self.problemFields = problemFields
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        self.problemFields = try ProblemFields(from: decoder)
        self.type = try `Type`(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problemFields, forKey: "problemFields")
        try values.encodeIfPresent(type, forKey: "type")
    }
}

/// A problem that indicates that a usage cap has been exceeded.
public struct UsageCapExceededProblem: Codable {
    public var problemFields: ProblemFields
    public var type: `Type`?
    public var period: Period?
    public var scope: Scope?

    public enum `Type`: String, Codable, CaseIterable {
        case httpsAPITwitterCom2ProblemsUsageCapped = "https://api.twitter.com/2/problems/usage-capped"
    }

    public enum Period: String, Codable, CaseIterable {
        case daily = "Daily"
        case monthly = "Monthly"
    }

    public enum Scope: String, Codable, CaseIterable {
        case account = "Account"
        case product = "Product"
    }

    public init(problemFields: ProblemFields, type: `Type`? = nil, period: Period? = nil, scope: Scope? = nil) {
        self.problemFields = problemFields
        self.type = type
        self.period = period
        self.scope = scope
    }

    public init(from decoder: Decoder) throws {
        self.problemFields = try ProblemFields(from: decoder)
        self.type = try `Type`(from: decoder)
        self.period = try Period(from: decoder)
        self.scope = try Scope(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problemFields, forKey: "problemFields")
        try values.encodeIfPresent(type, forKey: "type")
        try values.encodeIfPresent(period, forKey: "period")
        try values.encodeIfPresent(scope, forKey: "scope")
    }
}

/// A problem that indicates something is wrong with the connection
public struct ConnectionExceptionProblem: Codable {
    public var problemFields: ProblemFields
    public var type: `Type`?
    public var connectionIssue: ConnectionIssue?

    public enum `Type`: String, Codable, CaseIterable {
        case httpsAPITwitterCom2ProblemsStreamingConnection = "https://api.twitter.com/2/problems/streaming-connection"
    }

    public enum ConnectionIssue: String, Codable, CaseIterable {
        case tooManyConnections = "TooManyConnections"
        case provisioningSubscription = "ProvisioningSubscription"
        case ruleConfigurationIssue = "RuleConfigurationIssue"
        case rulesInvalidIssue = "RulesInvalidIssue"
    }

    public init(problemFields: ProblemFields, type: `Type`? = nil, connectionIssue: ConnectionIssue? = nil) {
        self.problemFields = problemFields
        self.type = type
        self.connectionIssue = connectionIssue
    }

    public init(from decoder: Decoder) throws {
        self.problemFields = try ProblemFields(from: decoder)
        self.type = try `Type`(from: decoder)
        self.connectionIssue = try ConnectionIssue(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problemFields, forKey: "problemFields")
        try values.encodeIfPresent(type, forKey: "type")
        try values.encodeIfPresent(connectionIssue, forKey: "connection_issue")
    }
}

/// Your client has gone away.
public struct ClientDisconnectedProblem: Codable {
    public var problemFields: ProblemFields
    public var type: `Type`?

    public enum `Type`: String, Codable, CaseIterable {
        case httpsAPITwitterCom2ProblemsClientDisconnected = "https://api.twitter.com/2/problems/client-disconnected"
    }

    public init(problemFields: ProblemFields, type: `Type`? = nil) {
        self.problemFields = problemFields
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        self.problemFields = try ProblemFields(from: decoder)
        self.type = try `Type`(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problemFields, forKey: "problemFields")
        try values.encodeIfPresent(type, forKey: "type")
    }
}

/// You have been disconnected for operational reasons.
public struct OperationalDisconnectProblem: Codable {
    public var problemFields: ProblemFields
    public var type: `Type`?
    public var disconnectType: DisconnectType?

    public enum `Type`: String, Codable, CaseIterable {
        case httpsAPITwitterCom2ProblemsOperationalDisconnect = "https://api.twitter.com/2/problems/operational-disconnect"
    }

    public enum DisconnectType: String, Codable, CaseIterable {
        case operationalDisconnect = "OperationalDisconnect"
        case upstreamOperationalDisconnect = "UpstreamOperationalDisconnect"
        case forceDisconnect = "ForceDisconnect"
        case upstreamUncleanDisconnect = "UpstreamUncleanDisconnect"
        case slowReader = "SlowReader"
        case internalError = "InternalError"
        case clientApplicationStateDegraded = "ClientApplicationStateDegraded"
        case invalidRules = "InvalidRules"
    }

    public init(problemFields: ProblemFields, type: `Type`? = nil, disconnectType: DisconnectType? = nil) {
        self.problemFields = problemFields
        self.type = type
        self.disconnectType = disconnectType
    }

    public init(from decoder: Decoder) throws {
        self.problemFields = try ProblemFields(from: decoder)
        self.type = try `Type`(from: decoder)
        self.disconnectType = try DisconnectType(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problemFields, forKey: "problemFields")
        try values.encodeIfPresent(type, forKey: "type")
        try values.encodeIfPresent(disconnectType, forKey: "disconnect_type")
    }
}

/// You have exceeded the maximum number of rules.
public struct RulesCapProblem: Codable {
    public var problemFields: ProblemFields
    public var type: `Type`?

    public enum `Type`: String, Codable, CaseIterable {
        case httpsAPITwitterCom2ProblemsRuleCap = "https://api.twitter.com/2/problems/rule-cap"
    }

    public init(problemFields: ProblemFields, type: `Type`? = nil) {
        self.problemFields = problemFields
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        self.problemFields = try ProblemFields(from: decoder)
        self.type = try `Type`(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problemFields, forKey: "problemFields")
        try values.encodeIfPresent(type, forKey: "type")
    }
}

/// The rule you have submitted is invalid.
public struct InvalidRuleProblem: Codable {
    public var problemFields: ProblemFields
    public var type: `Type`?

    public enum `Type`: String, Codable, CaseIterable {
        case httpsAPITwitterCom2ProblemsInvalidRules = "https://api.twitter.com/2/problems/invalid-rules"
    }

    public init(problemFields: ProblemFields, type: `Type`? = nil) {
        self.problemFields = problemFields
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        self.problemFields = try ProblemFields(from: decoder)
        self.type = try `Type`(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problemFields, forKey: "problemFields")
        try values.encodeIfPresent(type, forKey: "type")
    }
}

/// The rule you have submitted is a duplicate.
public struct DuplicateRuleProblem: Codable {
    public var problemFields: ProblemFields
    public var type: `Type`?

    public enum `Type`: String, Codable, CaseIterable {
        case httpsAPITwitterCom2ProblemsDuplicateRules = "https://api.twitter.com/2/problems/duplicate-rules"
    }

    public init(problemFields: ProblemFields, type: `Type`? = nil) {
        self.problemFields = problemFields
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        self.problemFields = try ProblemFields(from: decoder)
        self.type = try `Type`(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problemFields, forKey: "problemFields")
        try values.encodeIfPresent(type, forKey: "type")
    }
}

/// You cannot create a new job if one is already in progress.
public struct ConflictProblem: Codable {
    public var problemFields: ProblemFields
    public var type: `Type`?

    public enum `Type`: String, Codable, CaseIterable {
        case httpsAPITwitterCom2ProblemsConflict = "https://api.twitter.com/2/problems/conflict"
    }

    public init(problemFields: ProblemFields, type: `Type`? = nil) {
        self.problemFields = problemFields
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        self.problemFields = try ProblemFields(from: decoder)
        self.type = try `Type`(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problemFields, forKey: "problemFields")
        try values.encodeIfPresent(type, forKey: "type")
    }
}

/// A problem that indicates the user's rule set is not compliant.
public struct NonCompliantRulesProblem: Codable {
    public var problemFields: ProblemFields
    public var type: `Type`?

    public enum `Type`: String, Codable, CaseIterable {
        case httpsAPITwitterCom2ProblemsNoncompliantRules = "https://api.twitter.com/2/problems/noncompliant-rules"
    }

    public init(problemFields: ProblemFields, type: `Type`? = nil) {
        self.problemFields = problemFields
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        self.problemFields = try ProblemFields(from: decoder)
        self.type = try `Type`(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(problemFields, forKey: "problemFields")
        try values.encodeIfPresent(type, forKey: "type")
    }
}

public enum Problem: Codable {
    case genericProblem(GenericProblem)
    case invalidRequestProblem(InvalidRequestProblem)
    case clientForbiddenProblem(ClientForbiddenProblem)
    case resourceNotFoundProblem(ResourceNotFoundProblem)
    case resourceUnavailableProblem(ResourceUnavailableProblem)
    case resourceUnauthorizedProblem(ResourceUnauthorizedProblem)
    case fieldUnauthorizedProblem(FieldUnauthorizedProblem)
    case disallowedResourceProblem(DisallowedResourceProblem)
    case unsupportedAuthenticationProblem(UnsupportedAuthenticationProblem)
    case usageCapExceededProblem(UsageCapExceededProblem)
    case connectionExceptionProblem(ConnectionExceptionProblem)
    case clientDisconnectedProblem(ClientDisconnectedProblem)
    case operationalDisconnectProblem(OperationalDisconnectProblem)
    case rulesCapProblem(RulesCapProblem)
    case invalidRuleProblem(InvalidRuleProblem)
    case duplicateRuleProblem(DuplicateRuleProblem)
    case conflictProblem(ConflictProblem)
    case nonCompliantRulesProblem(NonCompliantRulesProblem)

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(GenericProblem.self) {
            self = .genericProblem(value)
        } else if let value = try? container.decode(InvalidRequestProblem.self) {
            self = .invalidRequestProblem(value)
        } else if let value = try? container.decode(ClientForbiddenProblem.self) {
            self = .clientForbiddenProblem(value)
        } else if let value = try? container.decode(ResourceNotFoundProblem.self) {
            self = .resourceNotFoundProblem(value)
        } else if let value = try? container.decode(ResourceUnavailableProblem.self) {
            self = .resourceUnavailableProblem(value)
        } else if let value = try? container.decode(ResourceUnauthorizedProblem.self) {
            self = .resourceUnauthorizedProblem(value)
        } else if let value = try? container.decode(FieldUnauthorizedProblem.self) {
            self = .fieldUnauthorizedProblem(value)
        } else if let value = try? container.decode(DisallowedResourceProblem.self) {
            self = .disallowedResourceProblem(value)
        } else if let value = try? container.decode(UnsupportedAuthenticationProblem.self) {
            self = .unsupportedAuthenticationProblem(value)
        } else if let value = try? container.decode(UsageCapExceededProblem.self) {
            self = .usageCapExceededProblem(value)
        } else if let value = try? container.decode(ConnectionExceptionProblem.self) {
            self = .connectionExceptionProblem(value)
        } else if let value = try? container.decode(ClientDisconnectedProblem.self) {
            self = .clientDisconnectedProblem(value)
        } else if let value = try? container.decode(OperationalDisconnectProblem.self) {
            self = .operationalDisconnectProblem(value)
        } else if let value = try? container.decode(RulesCapProblem.self) {
            self = .rulesCapProblem(value)
        } else if let value = try? container.decode(InvalidRuleProblem.self) {
            self = .invalidRuleProblem(value)
        } else if let value = try? container.decode(DuplicateRuleProblem.self) {
            self = .duplicateRuleProblem(value)
        } else if let value = try? container.decode(ConflictProblem.self) {
            self = .conflictProblem(value)
        } else if let value = try? container.decode(NonCompliantRulesProblem.self) {
            self = .nonCompliantRulesProblem(value)
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .genericProblem(let value): try container.encode(value)
        case .invalidRequestProblem(let value): try container.encode(value)
        case .clientForbiddenProblem(let value): try container.encode(value)
        case .resourceNotFoundProblem(let value): try container.encode(value)
        case .resourceUnavailableProblem(let value): try container.encode(value)
        case .resourceUnauthorizedProblem(let value): try container.encode(value)
        case .fieldUnauthorizedProblem(let value): try container.encode(value)
        case .disallowedResourceProblem(let value): try container.encode(value)
        case .unsupportedAuthenticationProblem(let value): try container.encode(value)
        case .usageCapExceededProblem(let value): try container.encode(value)
        case .connectionExceptionProblem(let value): try container.encode(value)
        case .clientDisconnectedProblem(let value): try container.encode(value)
        case .operationalDisconnectProblem(let value): try container.encode(value)
        case .rulesCapProblem(let value): try container.encode(value)
        case .invalidRuleProblem(let value): try container.encode(value)
        case .duplicateRuleProblem(let value): try container.encode(value)
        case .conflictProblem(let value): try container.encode(value)
        case .nonCompliantRulesProblem(let value): try container.encode(value)
        }
    }
}

public struct TweetSearchResponse: Codable {
    public var data: [Tweet]?
    public var includes: Expansions?
    public var errors: [Problem]?
    public var meta: Meta?

    public struct Meta: Codable {
        /// Most recent Tweet Id returned by search query
        public var newestID: String?
        /// Oldest Tweet Id returned by search query
        public var oldestID: String?
        /// This value is used to get the next 'page' of results by providing it to the next_token parameter.
        public var nextToken: String?
        /// Number of search query results
        public var resultCount: Int?

        public init(newestID: String? = nil, oldestID: String? = nil, nextToken: String? = nil, resultCount: Int? = nil) {
            self.newestID = newestID
            self.oldestID = oldestID
            self.nextToken = nextToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case newestID = "newest_id"
            case oldestID = "oldest_id"
            case nextToken = "next_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [Tweet]? = nil, includes: Expansions? = nil, errors: [Problem]? = nil, meta: Meta? = nil) {
        self.data = data
        self.includes = includes
        self.errors = errors
        self.meta = meta
    }
}

public enum StreamingTweet: Codable {
    case singleTweetLookupResponse(SingleTweetLookupResponse)
    case object(Object)

    public struct Object: Codable {
        public var errors: [Problem]

        public init(errors: [Problem]) {
            self.errors = errors
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(SingleTweetLookupResponse.self) {
            self = .singleTweetLookupResponse(value)
        } else if let value = try? container.decode(Object.self) {
            self = .object(value)
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .singleTweetLookupResponse(let value): try container.encode(value)
        case .object(let value): try container.encode(value)
        }
    }
}

public enum FilteredStreamingTweet: Codable {
    case a(A)
    case b(B)

    /// The values returned with a successful streamed tweet. Includes the user provided rules that the tweet matched.
    public struct A: Codable {
        /// Example:
        ///
        /// {
        ///   "author_id" : "2244994945",
        ///   "created_at" : "Wed Jan 06 18:40:40 +0000 2021",
        ///   "id" : "1346889436626259968",
        ///   "text" : "Learn how to use the user Tweet timeline and user mention timeline endpoints in the Twitter API v2 to explore Tweet\\u2026 https:\\\/\\\/t.co\\\/56a0vZUx7i"
        /// }
        public var data: Tweet
        /// The list of rules which matched the tweet
        public var matchingRules: [MatchingRule]
        public var includes: Expansions?

        public struct MatchingRule: Codable {
            /// Unique identifier of this rule.
            ///
            /// Example: "120897978112909812"
            public var id: String
            /// The user-supplied tag assigned to the rule which matched
            public var tag: String?

            public init(id: String, tag: String? = nil) {
                self.id = id
                self.tag = tag
            }
        }

        public init(data: Tweet, matchingRules: [MatchingRule], includes: Expansions? = nil) {
            self.data = data
            self.matchingRules = matchingRules
            self.includes = includes
        }

        private enum CodingKeys: String, CodingKey {
            case data
            case matchingRules = "matching_rules"
            case includes
        }
    }

    public struct B: Codable {
        public var errors: [Problem]

        public init(errors: [Problem]) {
            self.errors = errors
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(A.self) {
            self = .a(value)
        } else if let value = try? container.decode(B.self) {
            self = .b(value)
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .a(let value): try container.encode(value)
        case .b(let value): try container.encode(value)
        }
    }
}

/// A user-provided stream filtering rule.
public struct Rule: Codable {
    /// The filterlang value of the rule.
    ///
    /// Example: "coffee -is:retweet"
    public var value: String
    /// A tag meant for the labeling of user provided rules.
    ///
    /// Example: "Non-retweeted coffee tweets"
    public var tag: String?
    /// Unique identifier of this rule.
    ///
    /// Example: "120897978112909812"
    public var id: String?

    public init(value: String, tag: String? = nil, id: String? = nil) {
        self.value = value
        self.tag = tag
        self.id = id
    }
}

/// A user-provided stream filtering rule.
public struct RuleNoID: Codable {
    /// The filterlang value of the rule.
    ///
    /// Example: "coffee -is:retweet"
    public var value: String
    /// A tag meant for the labeling of user provided rules.
    ///
    /// Example: "Non-retweeted coffee tweets"
    public var tag: String?

    public init(value: String, tag: String? = nil) {
        self.value = value
        self.tag = tag
    }
}

public struct RulesResponseMetadata: Codable {
    public var sent: String
    public var summary: RulesRequestSummary?

    public init(sent: String, summary: RulesRequestSummary? = nil) {
        self.sent = sent
        self.summary = summary
    }
}

public enum RulesRequestSummary: Codable {
    case a(A)
    case b(B)

    /// A summary of the results of the addition of user-specified stream filtering rules.
    public struct A: Codable {
        /// Number of user-specified stream filtering rules that were created.
        public var created: Int
        /// Number of user-specified stream filtering rules that were not created.
        public var notCreated: Int
        /// Number of valid user-specified stream filtering rules.
        public var valid: Int
        /// Number of invalid user-specified stream filtering rules.
        public var invalid: Int

        public init(created: Int, notCreated: Int, valid: Int, invalid: Int) {
            self.created = created
            self.notCreated = notCreated
            self.valid = valid
            self.invalid = invalid
        }

        private enum CodingKeys: String, CodingKey {
            case created
            case notCreated = "not_created"
            case valid
            case invalid
        }
    }

    public struct B: Codable {
        /// Number of user-specified stream filtering rules that were deleted.
        public var deleted: Int
        /// Number of user-specified stream filtering rules that were not deleted.
        public var notDeleted: Int

        public init(deleted: Int, notDeleted: Int) {
            self.deleted = deleted
            self.notDeleted = notDeleted
        }

        private enum CodingKeys: String, CodingKey {
            case deleted
            case notDeleted = "not_deleted"
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(A.self) {
            self = .a(value)
        } else if let value = try? container.decode(B.self) {
            self = .b(value)
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .a(let value): try container.encode(value)
        case .b(let value): try container.encode(value)
        }
    }
}

public enum AddOrDeleteRulesRequest: Codable {
    case addRulesRequest(AddRulesRequest)
    case deleteRulesRequest(DeleteRulesRequest)

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(AddRulesRequest.self) {
            self = .addRulesRequest(value)
        } else if let value = try? container.decode(DeleteRulesRequest.self) {
            self = .deleteRulesRequest(value)
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .addRulesRequest(let value): try container.encode(value)
        case .deleteRulesRequest(let value): try container.encode(value)
        }
    }
}

public enum AddOrDeleteRulesResponse: Codable {
    case addRulesResponse(AddRulesResponse)
    case deleteRulesResponse(DeleteRulesResponse)

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(AddRulesResponse.self) {
            self = .addRulesResponse(value)
        } else if let value = try? container.decode(DeleteRulesResponse.self) {
            self = .deleteRulesResponse(value)
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .addRulesResponse(let value): try container.encode(value)
        case .deleteRulesResponse(let value): try container.encode(value)
        }
    }
}

/// A request to add a user-specified stream filtering rule.
public struct AddRulesRequest: Codable {
    public var add: [RuleNoID]

    public init(add: [RuleNoID]) {
        self.add = add
    }
}

/// A response from adding user-specified stream filtering rules.
public struct AddRulesResponse: Codable {
    /// All user-specified stream filtering rules that were created.
    public var data: [Rule]
    public var meta: RulesResponseMetadata

    public init(data: [Rule], meta: RulesResponseMetadata) {
        self.data = data
        self.meta = meta
    }
}

/// A response from deleting user-specified stream filtering rules.
public struct DeleteRulesRequest: Codable {
    /// IDs and values of all deleted user-specified stream filtering rules.
    public var delete: Delete

    /// IDs and values of all deleted user-specified stream filtering rules.
    public struct Delete: Codable {
        /// IDs of all deleted user-specified stream filtering rules.
        public var ids: [String]?
        /// Values of all deleted user-specified stream filtering rules.
        public var values: [String]?

        public init(ids: [String]? = nil, values: [String]? = nil) {
            self.ids = ids
            self.values = values
        }
    }

    public init(delete: Delete) {
        self.delete = delete
    }
}

public struct DeleteRulesResponse: Codable {
    public var meta: RulesResponseMetadata

    public init(meta: RulesResponseMetadata) {
        self.meta = meta
    }
}

public struct GenericTweetsTimelineResponse: Codable {
    public var data: [Tweet]?
    public var includes: Expansions?
    public var errors: [Problem]?
    public var meta: Meta?

    public struct Meta: Codable {
        /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
        ///
        /// Example: "1346889436626259968"
        public var newestID: String?
        /// Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
        ///
        /// Example: "1346889436626259968"
        public var oldestID: String?
        /// The previous token
        public var previousToken: String?
        /// The next token
        public var nextToken: String?
        /// Number of Tweets in result set
        public var resultCount: Int?

        public init(newestID: String? = nil, oldestID: String? = nil, previousToken: String? = nil, nextToken: String? = nil, resultCount: Int? = nil) {
            self.newestID = newestID
            self.oldestID = oldestID
            self.previousToken = previousToken
            self.nextToken = nextToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case newestID = "newest_id"
            case oldestID = "oldest_id"
            case previousToken = "previous_token"
            case nextToken = "next_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [Tweet]? = nil, includes: Expansions? = nil, errors: [Problem]? = nil, meta: Meta? = nil) {
        self.data = data
        self.includes = includes
        self.errors = errors
        self.meta = meta
    }
}

public struct UsersBlockingMutationResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isBlocking: Bool?

        public init(isBlocking: Bool? = nil) {
            self.isBlocking = isBlocking
        }

        private enum CodingKeys: String, CodingKey {
            case isBlocking = "blocking"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct GenericMultipleUsersLookupResponse: Codable {
    public var data: [User]?
    public var includes: Expansions?
    public var errors: [Problem]?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The previous token
        public var previousToken: String?
        /// The next token
        public var nextToken: String?
        /// The number of user results returned in this response
        public var resultCount: Int?

        public init(previousToken: String? = nil, nextToken: String? = nil, resultCount: Int? = nil) {
            self.previousToken = previousToken
            self.nextToken = nextToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case previousToken = "previous_token"
            case nextToken = "next_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [User]? = nil, includes: Expansions? = nil, errors: [Problem]? = nil, meta: Meta? = nil) {
        self.data = data
        self.includes = includes
        self.errors = errors
        self.meta = meta
    }
}

public struct ListLookupMultipleUsersLookupResponse: Codable {
    public var data: [User]?
    public var includes: Expansions?
    public var errors: [Problem]?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The previous token
        public var previousToken: String?
        /// The next token
        public var nextToken: String?
        /// The number of user results returned in this response
        public var resultCount: Int?

        public init(previousToken: String? = nil, nextToken: String? = nil, resultCount: Int? = nil) {
            self.previousToken = previousToken
            self.nextToken = nextToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case previousToken = "previous_token"
            case nextToken = "next_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [User]? = nil, includes: Expansions? = nil, errors: [Problem]? = nil, meta: Meta? = nil) {
        self.data = data
        self.includes = includes
        self.errors = errors
        self.meta = meta
    }
}

public struct UsersMutingMutationResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isMuting: Bool?

        public init(isMuting: Bool? = nil) {
            self.isMuting = isMuting
        }

        private enum CodingKeys: String, CodingKey {
            case isMuting = "muting"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct UsersFollowingLookupResponse: Codable {
    public var data: [User]?
    public var includes: Expansions?
    public var errors: [Problem]?
    public var meta: Meta?

    public struct Meta: Codable {
        /// The previous token
        public var previousToken: String?
        /// The next token
        public var nextToken: String?
        /// The number of user results returned in this response
        public var resultCount: Int?

        public init(previousToken: String? = nil, nextToken: String? = nil, resultCount: Int? = nil) {
            self.previousToken = previousToken
            self.nextToken = nextToken
            self.resultCount = resultCount
        }

        private enum CodingKeys: String, CodingKey {
            case previousToken = "previous_token"
            case nextToken = "next_token"
            case resultCount = "result_count"
        }
    }

    public init(data: [User]? = nil, includes: Expansions? = nil, errors: [Problem]? = nil, meta: Meta? = nil) {
        self.data = data
        self.includes = includes
        self.errors = errors
        self.meta = meta
    }
}

public struct UsersFollowingCreateResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isFollowing: Bool?
        public var isPendingFollow: Bool?

        public init(isFollowing: Bool? = nil, isPendingFollow: Bool? = nil) {
            self.isFollowing = isFollowing
            self.isPendingFollow = isPendingFollow
        }

        private enum CodingKeys: String, CodingKey {
            case isFollowing = "following"
            case isPendingFollow = "pending_follow"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct UsersFollowingDeleteResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isFollowing: Bool?

        public init(isFollowing: Bool? = nil) {
            self.isFollowing = isFollowing
        }

        private enum CodingKeys: String, CodingKey {
            case isFollowing = "following"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct UsersLikesCreateRequest: Codable {
    public var tweetID: String

    public init(tweetID: String) {
        self.tweetID = tweetID
    }

    private enum CodingKeys: String, CodingKey {
        case tweetID = "tweet_id"
    }
}

public struct UsersLikesCreateResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isLiked: Bool?

        public init(isLiked: Bool? = nil) {
            self.isLiked = isLiked
        }

        private enum CodingKeys: String, CodingKey {
            case isLiked = "liked"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct UsersLikesDeleteResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isLiked: Bool?

        public init(isLiked: Bool? = nil) {
            self.isLiked = isLiked
        }

        private enum CodingKeys: String, CodingKey {
            case isLiked = "liked"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct UsersRetweetsCreateRequest: Codable {
    public var tweetID: String

    public init(tweetID: String) {
        self.tweetID = tweetID
    }

    private enum CodingKeys: String, CodingKey {
        case tweetID = "tweet_id"
    }
}

public struct UsersRetweetsCreateResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isRetweeted: Bool?

        public init(isRetweeted: Bool? = nil) {
            self.isRetweeted = isRetweeted
        }

        private enum CodingKeys: String, CodingKey {
            case isRetweeted = "retweeted"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct UsersRetweetsDeleteResponse: Codable {
    public var data: Data?
    public var errors: [Problem]?

    public struct Data: Codable {
        public var isRetweeted: Bool?

        public init(isRetweeted: Bool? = nil) {
            self.isRetweeted = isRetweeted
        }

        private enum CodingKeys: String, CodingKey {
            case isRetweeted = "retweeted"
        }
    }

    public init(data: Data? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct TweetCountsResponse: Codable {
    public var data: [SearchCount]?
    public var errors: [Problem]?
    public var meta: Meta?

    public struct Meta: Codable {
        /// This value is used to get the next 'page' of results by providing it to the next_token parameter.
        public var nextToken: String?
        /// Sum of search query count results
        public var totalTweetCount: Int?

        public init(nextToken: String? = nil, totalTweetCount: Int? = nil) {
            self.nextToken = nextToken
            self.totalTweetCount = totalTweetCount
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "next_token"
            case totalTweetCount = "total_tweet_count"
        }
    }

    public init(data: [SearchCount]? = nil, errors: [Problem]? = nil, meta: Meta? = nil) {
        self.data = data
        self.errors = errors
        self.meta = meta
    }
}

/// Represent a Search Count Result
public struct SearchCount: Codable {
    /// The end time of the bucket
    public var end: Date
    /// The start time of the bucket
    public var start: Date
    /// The count for the bucket
    public var tweetCount: Int

    public init(end: Date, start: Date, tweetCount: Int) {
        self.end = end
        self.start = start
        self.tweetCount = tweetCount
    }

    private enum CodingKeys: String, CodingKey {
        case end
        case start
        case tweetCount = "tweet_count"
    }
}

public enum Granularity: String, Codable, CaseIterable {
    case minute
    case hour
    case day
}

/// Status of a compliance job
public enum ComplianceJobStatus: String, Codable, CaseIterable {
    case created
    case inProgress = "in_progress"
    case failed
    case complete
}

/// Type of compliance job to list.
public enum ComplianceJobType: String, Codable, CaseIterable {
    case tweets
    case users
}

public struct ComplianceJob: Codable {
    /// Compliance Job ID
    ///
    /// Example: "1372966999991541762"
    public var id: String
    /// Type of compliance job to list.
    public var type: ComplianceJobType
    /// Creation time of the compliance job.
    ///
    /// Example: "2021-01-06T18:40:40.000Z"
    public var createdAt: Date
    /// URL to which the user will upload their tweet or user IDs
    public var uploadURL: URL
    /// Expiration time of the upload URL
    ///
    /// Example: "2021-01-06T18:40:40.000Z"
    public var uploadExpiresAt: Date
    /// URL from which the user will retrieve their compliance results
    public var downloadURL: URL
    /// Expiration time of the download URL
    ///
    /// Example: "2021-01-06T18:40:40.000Z"
    public var downloadExpiresAt: Date
    /// User-provided name for a compliance job
    ///
    /// Example: "my-job"
    public var name: String?
    /// Status of a compliance job
    public var status: ComplianceJobStatus

    public init(id: String, type: ComplianceJobType, createdAt: Date, uploadURL: URL, uploadExpiresAt: Date, downloadURL: URL, downloadExpiresAt: Date, name: String? = nil, status: ComplianceJobStatus) {
        self.id = id
        self.type = type
        self.createdAt = createdAt
        self.uploadURL = uploadURL
        self.uploadExpiresAt = uploadExpiresAt
        self.downloadURL = downloadURL
        self.downloadExpiresAt = downloadExpiresAt
        self.name = name
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case type
        case createdAt = "created_at"
        case uploadURL = "upload_url"
        case uploadExpiresAt = "upload_expires_at"
        case downloadURL = "download_url"
        case downloadExpiresAt = "download_expires_at"
        case name
        case status
    }
}

public struct SingleComplianceJobResponse: Codable {
    public var data: ComplianceJob?
    public var errors: [Problem]?

    public init(data: ComplianceJob? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct MultiComplianceJobResponse: Codable {
    public var data: [ComplianceJob]?
    public var errors: [Problem]?

    public init(data: [ComplianceJob]? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.errors = errors
    }
}

public struct Space: Codable {
    /// The unique identifier of this Space.
    ///
    /// Example: "1SLjjRYNejbKM"
    public var id: String
    /// The current state of the space.
    ///
    /// Example: "live"
    public var state: State
    /// When the space was started as a date string
    ///
    /// Example: "2021-7-14T04:35:55Z"
    public var startedAt: Date?
    /// Denotes if the space is a ticketed space
    ///
    /// Example: false
    public var isTicketed: Bool?
    /// The number of participants in a space
    ///
    /// Example: 10
    public var participantCount: Int?
    /// The title of the space
    ///
    /// Example: "Spaces are Awesome"
    public var title: String?
    /// The user ids for the hosts of the space
    public var hostIDs: [String]?
    /// When the space was last updated
    ///
    /// Example: "2021-7-14T04:35:55Z"
    public var updatedAt: Date?
    /// Creation time of the space
    ///
    /// Example: "2021-07-06T18:40:40.000Z"
    public var createdAt: Date?
    /// Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
    ///
    /// Example: "2244994945"
    public var creatorID: String?
    /// The language of the space
    ///
    /// Example: "en"
    public var lang: String?
    /// An array of user ids for people who were speakers in a space
    public var speakerIDs: [String]?
    /// An array of user ids for people who were invited to a space
    public var invitedUserIDs: [String]?
    /// A date time stamp for when a space is scheduled to begin
    ///
    /// Example: "2021-07-06T18:40:40.000Z"
    public var scheduledStart: Date?
    /// End time of the space
    ///
    /// Example: "2021-07-06T18:40:40.000Z"
    public var endedAt: Date?
    /// The topics of a space, as selected by its creator
    public var topics: [Topic]?

    /// The current state of the space.
    ///
    /// Example: "live"
    public enum State: String, Codable, CaseIterable {
        case live
        case scheduled
        case ended
    }

    /// The Twitter Topic object
    ///
    /// Example:
    ///
    /// {
    ///   "description" : "All about technology",
    ///   "id" : "848920371311001600",
    ///   "name" : "Technology"
    /// }
    public struct Topic: Codable {
        /// An ID suitable for use in the REST API.
        public var id: String
        /// The description of the given topic.
        public var description: String?
        /// The name of the given topic.
        public var name: String

        public init(id: String, description: String? = nil, name: String) {
            self.id = id
            self.description = description
            self.name = name
        }
    }

    public init(id: String, state: State, startedAt: Date? = nil, isTicketed: Bool? = nil, participantCount: Int? = nil, title: String? = nil, hostIDs: [String]? = nil, updatedAt: Date? = nil, createdAt: Date? = nil, creatorID: String? = nil, lang: String? = nil, speakerIDs: [String]? = nil, invitedUserIDs: [String]? = nil, scheduledStart: Date? = nil, endedAt: Date? = nil, topics: [Topic]? = nil) {
        self.id = id
        self.state = state
        self.startedAt = startedAt
        self.isTicketed = isTicketed
        self.participantCount = participantCount
        self.title = title
        self.hostIDs = hostIDs
        self.updatedAt = updatedAt
        self.createdAt = createdAt
        self.creatorID = creatorID
        self.lang = lang
        self.speakerIDs = speakerIDs
        self.invitedUserIDs = invitedUserIDs
        self.scheduledStart = scheduledStart
        self.endedAt = endedAt
        self.topics = topics
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case state
        case startedAt = "started_at"
        case isTicketed = "is_ticketed"
        case participantCount = "participant_count"
        case title
        case hostIDs = "host_ids"
        case updatedAt = "updated_at"
        case createdAt = "created_at"
        case creatorID = "creator_id"
        case lang
        case speakerIDs = "speaker_ids"
        case invitedUserIDs = "invited_user_ids"
        case scheduledStart = "scheduled_start"
        case endedAt = "ended_at"
        case topics
    }
}

public struct SingleSpaceLookupResponse: Codable {
    public var data: Space?
    public var includes: Expansions?
    public var errors: [Problem]?

    public init(data: Space? = nil, includes: Expansions? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.includes = includes
        self.errors = errors
    }
}

public struct MultiSpaceLookupResponse: Codable {
    public var data: [Space]?
    public var includes: Expansions?
    public var errors: [Problem]?

    public init(data: [Space]? = nil, includes: Expansions? = nil, errors: [Problem]? = nil) {
        self.data = data
        self.includes = includes
        self.errors = errors
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
