// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension Paths {
    public static var containers: Containers {
        Containers(path: "/containers")
    }

    public struct Containers {
        /// Path: `/containers`
        public let path: String
    }
}

extension Paths.Containers {
    public var json: JSON {
        JSON(path: path + "/json")
    }

    public struct JSON {
        /// Path: `/containers/json`
        public let path: String

        /// List containers
        ///
        /// Returns a list of containers. For details on the format, see [the inspect endpoint](#operation/ContainerInspect).
        /// 
        /// Note that it uses a different, smaller representation of a container than inspecting a single container. For example,
        /// the list of linked containers is not propagated .
        public func get(parameters: GetParameters? = nil) -> Request<[ContainerSummaryItem]> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isAll: Bool?
            public var limit: Int?
            public var isSize: Bool?
            public var filters: String?

            public init(isAll: Bool? = nil, limit: Int? = nil, isSize: Bool? = nil, filters: String? = nil) {
                self.isAll = isAll
                self.limit = limit
                self.isSize = isSize
                self.filters = filters
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isAll, forKey: "all")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(isSize, forKey: "size")
                encoder.encode(filters, forKey: "filters")
                return encoder.items
            }
        }
    }
}

extension Paths.Containers {
    public var create: Create {
        Create(path: path + "/create")
    }

    public struct Create {
        /// Path: `/containers/create`
        public let path: String

        /// Create a container
        public func post(name: String? = nil, _ body: PostRequest) -> Request<PostResponse> {
            .post(path, query: makePostQuery(name), body: body)
        }

        public struct PostResponse: Decodable {
            /// The ID of the created container
            public var id: String
            /// Warnings encountered when creating the container
            public var warnings: [String]

            public init(id: String, warnings: [String]) {
                self.id = id
                self.warnings = warnings
            }

            private enum CodingKeys: String, CodingKey {
                case id = "Id"
                case warnings = "Warnings"
            }
        }

        private func makePostQuery(_ name: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(name, forKey: "name")
            return encoder.items
        }

        public struct PostRequest: Encodable {
            /// Configuration for a container that is portable between hosts
            public var containerConfig: DockerEngineAPI.ContainerConfig
            /// Container configuration that depends on the host we are running on
            public var hostConfig: DockerEngineAPI.HostConfig?
            /// This container's networking configuration.
            public var networkingConfig: NetworkingConfig?

            /// This container's networking configuration.
            public struct NetworkingConfig: Encodable {
                /// A mapping of network name to endpoint configuration for that network.
                public var endpointsConfig: [String: DockerEngineAPI.EndpointSettings]?

                public init(endpointsConfig: [String: DockerEngineAPI.EndpointSettings]? = nil) {
                    self.endpointsConfig = endpointsConfig
                }

                private enum CodingKeys: String, CodingKey {
                    case endpointsConfig = "EndpointsConfig"
                }
            }

            public init(containerConfig: DockerEngineAPI.ContainerConfig, hostConfig: DockerEngineAPI.HostConfig? = nil, networkingConfig: NetworkingConfig? = nil) {
                self.containerConfig = containerConfig
                self.hostConfig = hostConfig
                self.networkingConfig = networkingConfig
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(containerConfig, forKey: "containerConfig")
                try values.encodeIfPresent(hostConfig, forKey: "HostConfig")
                try values.encodeIfPresent(networkingConfig, forKey: "NetworkingConfig")
            }
        }
    }
}

extension Paths.Containers.WithID {
    public var json: JSON {
        JSON(path: path + "/json")
    }

    public struct JSON {
        /// Path: `/containers/{id}/json`
        public let path: String

        /// Inspect a container
        ///
        /// Return low-level information about a container.
        public func get(isSize: Bool? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(isSize))
        }

        public struct GetResponse: Decodable {
            /// The ID of the container
            public var id: String?
            /// The time the container was created
            public var created: String?
            /// The path to the command being run
            public var path: String?
            /// The arguments to the command being run
            public var args: [String]?
            /// The state of the container.
            public var state: State?
            /// The container's image
            public var image: String?
            public var resolvConfPath: String?
            public var hostnamePath: String?
            public var hostsPath: String?
            public var logPath: String?
            /// TODO
            public var node: [String: AnyJSON]?
            public var name: String?
            public var restartCount: Int?
            public var driver: String?
            public var mountLabel: String?
            public var processLabel: String?
            public var appArmorProfile: String?
            public var execIDs: String?
            /// Container configuration that depends on the host we are running on
            public var hostConfig: DockerEngineAPI.HostConfig?
            /// Information about a container's graph driver.
            public var graphDriver: DockerEngineAPI.GraphDriverData?
            /// The size of files that have been created or changed by this container.
            public var sizeRw: Int?
            /// The total size of all the files in this container.
            public var sizeRootFs: Int?
            public var mounts: [DockerEngineAPI.MountPoint]?
            /// Configuration for a container that is portable between hosts
            public var config: DockerEngineAPI.ContainerConfig?
            /// NetworkSettings exposes the network settings in the API
            public var networkSettings: DockerEngineAPI.NetworkSettings?

            /// The state of the container.
            public struct State: Decodable {
                /// The status of the container. For example, `"running"` or `"exited"`.
                public var status: Status?
                /// Whether this container is running.
                /// 
                /// Note that a running container can be _paused_. The `Running` and `Paused`
                /// booleans are not mutually exclusive:
                /// 
                /// When pausing a container (on Linux), the cgroups freezer is used to suspend
                /// all processes in the container. Freezing the process requires the process to
                /// be running. As a result, paused containers are both `Running` _and_ `Paused`.
                /// 
                /// Use the `Status` field instead to determine if a container's state is "running".
                public var isRunning: Bool?
                /// Whether this container is paused.
                public var isPaused: Bool?
                /// Whether this container is restarting.
                public var isRestarting: Bool?
                /// Whether this container has been killed because it ran out of memory.
                public var isOOMKilled: Bool?
                public var isDead: Bool?
                /// The process ID of this container
                public var pid: Int?
                /// The last exit code of this container
                public var exitCode: Int?
                public var error: String?
                /// The time when this container was last started.
                public var startedAt: String?
                /// The time when this container last exited.
                public var finishedAt: String?

                /// The status of the container. For example, `"running"` or `"exited"`.
                public enum Status: String, Codable, CaseIterable {
                    case created
                    case running
                    case paused
                    case restarting
                    case removing
                    case exited
                    case dead
                }

                public init(status: Status? = nil, isRunning: Bool? = nil, isPaused: Bool? = nil, isRestarting: Bool? = nil, isOOMKilled: Bool? = nil, isDead: Bool? = nil, pid: Int? = nil, exitCode: Int? = nil, error: String? = nil, startedAt: String? = nil, finishedAt: String? = nil) {
                    self.status = status
                    self.isRunning = isRunning
                    self.isPaused = isPaused
                    self.isRestarting = isRestarting
                    self.isOOMKilled = isOOMKilled
                    self.isDead = isDead
                    self.pid = pid
                    self.exitCode = exitCode
                    self.error = error
                    self.startedAt = startedAt
                    self.finishedAt = finishedAt
                }

                private enum CodingKeys: String, CodingKey {
                    case status = "Status"
                    case isRunning = "Running"
                    case isPaused = "Paused"
                    case isRestarting = "Restarting"
                    case isOOMKilled = "OOMKilled"
                    case isDead = "Dead"
                    case pid = "Pid"
                    case exitCode = "ExitCode"
                    case error = "Error"
                    case startedAt = "StartedAt"
                    case finishedAt = "FinishedAt"
                }
            }

            public init(id: String? = nil, created: String? = nil, path: String? = nil, args: [String]? = nil, state: State? = nil, image: String? = nil, resolvConfPath: String? = nil, hostnamePath: String? = nil, hostsPath: String? = nil, logPath: String? = nil, node: [String: AnyJSON]? = nil, name: String? = nil, restartCount: Int? = nil, driver: String? = nil, mountLabel: String? = nil, processLabel: String? = nil, appArmorProfile: String? = nil, execIDs: String? = nil, hostConfig: DockerEngineAPI.HostConfig? = nil, graphDriver: DockerEngineAPI.GraphDriverData? = nil, sizeRw: Int? = nil, sizeRootFs: Int? = nil, mounts: [DockerEngineAPI.MountPoint]? = nil, config: DockerEngineAPI.ContainerConfig? = nil, networkSettings: DockerEngineAPI.NetworkSettings? = nil) {
                self.id = id
                self.created = created
                self.path = path
                self.args = args
                self.state = state
                self.image = image
                self.resolvConfPath = resolvConfPath
                self.hostnamePath = hostnamePath
                self.hostsPath = hostsPath
                self.logPath = logPath
                self.node = node
                self.name = name
                self.restartCount = restartCount
                self.driver = driver
                self.mountLabel = mountLabel
                self.processLabel = processLabel
                self.appArmorProfile = appArmorProfile
                self.execIDs = execIDs
                self.hostConfig = hostConfig
                self.graphDriver = graphDriver
                self.sizeRw = sizeRw
                self.sizeRootFs = sizeRootFs
                self.mounts = mounts
                self.config = config
                self.networkSettings = networkSettings
            }

            private enum CodingKeys: String, CodingKey {
                case id = "Id"
                case created = "Created"
                case path = "Path"
                case args = "Args"
                case state = "State"
                case image = "Image"
                case resolvConfPath = "ResolvConfPath"
                case hostnamePath = "HostnamePath"
                case hostsPath = "HostsPath"
                case logPath = "LogPath"
                case node = "Node"
                case name = "Name"
                case restartCount = "RestartCount"
                case driver = "Driver"
                case mountLabel = "MountLabel"
                case processLabel = "ProcessLabel"
                case appArmorProfile = "AppArmorProfile"
                case execIDs = "ExecIDs"
                case hostConfig = "HostConfig"
                case graphDriver = "GraphDriver"
                case sizeRw = "SizeRw"
                case sizeRootFs = "SizeRootFs"
                case mounts = "Mounts"
                case config = "Config"
                case networkSettings = "NetworkSettings"
            }
        }

        private func makeGetQuery(_ isSize: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isSize, forKey: "size")
            return encoder.items
        }
    }
}

extension Paths.Containers.WithID {
    public var top: Top {
        Top(path: path + "/top")
    }

    public struct Top {
        /// Path: `/containers/{id}/top`
        public let path: String

        /// List processes running inside a container
        ///
        /// On Unix systems, this is done by running the `ps` command. This endpoint is not supported on Windows.
        public func get(psArgs: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(psArgs))
        }

        public struct GetResponse: Decodable {
            /// The ps column titles
            public var titles: [String]?
            /// Each process running in the container, where each is process is an array of values corresponding to the titles
            public var processes: [[String]]?

            public init(titles: [String]? = nil, processes: [[String]]? = nil) {
                self.titles = titles
                self.processes = processes
            }

            private enum CodingKeys: String, CodingKey {
                case titles = "Titles"
                case processes = "Processes"
            }
        }

        private func makeGetQuery(_ psArgs: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(psArgs, forKey: "ps_args")
            return encoder.items
        }
    }
}

extension Paths.Containers.WithID {
    public var logs: Logs {
        Logs(path: path + "/logs")
    }

    public struct Logs {
        /// Path: `/containers/{id}/logs`
        public let path: String

        /// Get container logs
        ///
        /// Get `stdout` and `stderr` logs from a container.
        /// 
        /// Note: This endpoint works only for containers with the `json-file` or `journald` logging driver.
        public func get(parameters: GetParameters? = nil) -> Request<String> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isFollow: Bool?
            public var isStdout: Bool?
            public var isStderr: Bool?
            public var since: Int?
            public var isTimestamps: Bool?
            public var tail: String?

            public init(isFollow: Bool? = nil, isStdout: Bool? = nil, isStderr: Bool? = nil, since: Int? = nil, isTimestamps: Bool? = nil, tail: String? = nil) {
                self.isFollow = isFollow
                self.isStdout = isStdout
                self.isStderr = isStderr
                self.since = since
                self.isTimestamps = isTimestamps
                self.tail = tail
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isFollow, forKey: "follow")
                encoder.encode(isStdout, forKey: "stdout")
                encoder.encode(isStderr, forKey: "stderr")
                encoder.encode(since, forKey: "since")
                encoder.encode(isTimestamps, forKey: "timestamps")
                encoder.encode(tail, forKey: "tail")
                return encoder.items
            }
        }
    }
}

extension Paths.Containers.WithID {
    public var changes: Changes {
        Changes(path: path + "/changes")
    }

    public struct Changes {
        /// Path: `/containers/{id}/changes`
        public let path: String

        /// Get changes on a container’s filesystem
        ///
        /// Returns which files in a container's filesystem have been added, deleted,
        /// or modified. The `Kind` of modification can be one of:
        /// 
        /// - `0`: Modified
        /// - `1`: Added
        /// - `2`: Deleted
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            /// Path to file that has changed
            public var path: String
            /// Kind of change
            public var kind: Int

            public init(path: String, kind: Int) {
                self.path = path
                self.kind = kind
            }

            private enum CodingKeys: String, CodingKey {
                case path = "Path"
                case kind = "Kind"
            }
        }
    }
}

extension Paths.Containers.WithID {
    public var export: Export {
        Export(path: path + "/export")
    }

    public struct Export {
        /// Path: `/containers/{id}/export`
        public let path: String

        /// Export a container
        ///
        /// Export the contents of a container as a tarball.
        public var get: Request<Void> {
            .get(path)
        }
    }
}

extension Paths.Containers.WithID {
    public var stats: Stats {
        Stats(path: path + "/stats")
    }

    public struct Stats {
        /// Path: `/containers/{id}/stats`
        public let path: String

        /// Get container stats based on resource usage
        ///
        /// This endpoint returns a live stream of a container’s resource usage
        /// statistics.
        /// 
        /// The `precpu_stats` is the CPU statistic of last read, which is used
        /// for calculating the CPU usage percentage. It is not the same as the
        /// `cpu_stats` field.
        /// 
        /// If either `precpu_stats.online_cpus` or `cpu_stats.online_cpus` is
        /// nil then for compatibility with older daemons the length of the
        /// corresponding `cpu_usage.percpu_usage` array should be used.
        public func get(isStream: Bool? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(isStream))
        }

        private func makeGetQuery(_ isStream: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isStream, forKey: "stream")
            return encoder.items
        }
    }
}

extension Paths.Containers.WithID {
    public var resize: Resize {
        Resize(path: path + "/resize")
    }

    public struct Resize {
        /// Path: `/containers/{id}/resize`
        public let path: String

        /// Resize a container TTY
        ///
        /// Resize the TTY for a container. You must restart the container for the resize to take effect.
        public func post(h: Int? = nil, w: Int? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(h, w))
        }

        private func makePostQuery(_ h: Int?, _ w: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(h, forKey: "h")
            encoder.encode(w, forKey: "w")
            return encoder.items
        }
    }
}

extension Paths.Containers.WithID {
    public var start: Start {
        Start(path: path + "/start")
    }

    public struct Start {
        /// Path: `/containers/{id}/start`
        public let path: String

        /// Start a container
        public func post(detachKeys: String? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(detachKeys))
        }

        private func makePostQuery(_ detachKeys: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(detachKeys, forKey: "detachKeys")
            return encoder.items
        }
    }
}

extension Paths.Containers.WithID {
    public var stop: Stop {
        Stop(path: path + "/stop")
    }

    public struct Stop {
        /// Path: `/containers/{id}/stop`
        public let path: String

        /// Stop a container
        public func post(t: Int? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(t))
        }

        private func makePostQuery(_ t: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(t, forKey: "t")
            return encoder.items
        }
    }
}

extension Paths.Containers.WithID {
    public var restart: Restart {
        Restart(path: path + "/restart")
    }

    public struct Restart {
        /// Path: `/containers/{id}/restart`
        public let path: String

        /// Restart a container
        public func post(t: Int? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(t))
        }

        private func makePostQuery(_ t: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(t, forKey: "t")
            return encoder.items
        }
    }
}

extension Paths.Containers.WithID {
    public var kill: Kill {
        Kill(path: path + "/kill")
    }

    public struct Kill {
        /// Path: `/containers/{id}/kill`
        public let path: String

        /// Kill a container
        ///
        /// Send a POSIX signal to a container, defaulting to killing to the container.
        public func post(signal: String? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(signal))
        }

        private func makePostQuery(_ signal: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(signal, forKey: "signal")
            return encoder.items
        }
    }
}

extension Paths.Containers.WithID {
    public var update: Update {
        Update(path: path + "/update")
    }

    public struct Update {
        /// Path: `/containers/{id}/update`
        public let path: String

        /// Update a container
        ///
        /// Change various configuration options of a container without having to recreate it.
        public func post(_ body: PostRequest) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            public var warnings: [String]?

            public init(warnings: [String]? = nil) {
                self.warnings = warnings
            }

            private enum CodingKeys: String, CodingKey {
                case warnings = "Warnings"
            }
        }

        public struct PostRequest: Encodable {
            /// A container's resources (cgroups config, ulimits, etc)
            public var resources: DockerEngineAPI.Resources
            /// The behavior to apply when the container exits. The default is not to restart.
            /// 
            /// An ever increasing delay (double the previous delay, starting at 100ms) is added before each restart to prevent flooding the server.
            public var restartPolicy: DockerEngineAPI.RestartPolicy?

            public init(resources: DockerEngineAPI.Resources, restartPolicy: DockerEngineAPI.RestartPolicy? = nil) {
                self.resources = resources
                self.restartPolicy = restartPolicy
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(resources, forKey: "resources")
                try values.encodeIfPresent(restartPolicy, forKey: "RestartPolicy")
            }
        }
    }
}

extension Paths.Containers.WithID {
    public var rename: Rename {
        Rename(path: path + "/rename")
    }

    public struct Rename {
        /// Path: `/containers/{id}/rename`
        public let path: String

        /// Rename a container
        public func post(name: String) -> Request<Void> {
            .post(path, query: [("name", name)])
        }
    }
}

extension Paths.Containers.WithID {
    public var pause: Pause {
        Pause(path: path + "/pause")
    }

    public struct Pause {
        /// Path: `/containers/{id}/pause`
        public let path: String

        /// Pause a container
        ///
        /// Use the cgroups freezer to suspend all processes in a container.
        /// 
        /// Traditionally, when suspending a process the `SIGSTOP` signal is used, which is observable by the process being suspended. With the cgroups freezer the process is unaware, and unable to capture, that it is being suspended, and subsequently resumed.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Containers.WithID {
    public var unpause: Unpause {
        Unpause(path: path + "/unpause")
    }

    public struct Unpause {
        /// Path: `/containers/{id}/unpause`
        public let path: String

        /// Unpause a container
        ///
        /// Resume a container which has been paused.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Containers.WithID {
    public var attach: Attach {
        Attach(path: path + "/attach")
    }

    public struct Attach {
        /// Path: `/containers/{id}/attach`
        public let path: String

        /// Attach to a container
        ///
        /// Attach to a container to read its output or send it input. You can attach to the same container multiple times and you can reattach to containers that have been detached.
        /// 
        /// Either the `stream` or `logs` parameter must be `true` for this endpoint to do anything.
        /// 
        /// See [the documentation for the `docker attach` command](https://docs.docker.com/engine/reference/commandline/attach/) for more details.
        /// 
        /// ### Hijacking
        /// 
        /// This endpoint hijacks the HTTP connection to transport `stdin`, `stdout`, and `stderr` on the same socket.
        /// 
        /// This is the response from the daemon for an attach request:
        /// 
        /// ```
        /// HTTP/1.1 200 OK
        /// Content-Type: application/vnd.docker.raw-stream
        /// 
        /// [STREAM]
        /// ```
        /// 
        /// After the headers and two new lines, the TCP connection can now be used for raw, bidirectional communication between the client and server.
        /// 
        /// To hint potential proxies about connection hijacking, the Docker client can also optionally send connection upgrade headers.
        /// 
        /// For example, the client sends this request to upgrade the connection:
        /// 
        /// ```
        /// POST /containers/16253994b7c4/attach?stream=1&stdout=1 HTTP/1.1
        /// Upgrade: tcp
        /// Connection: Upgrade
        /// ```
        /// 
        /// The Docker daemon will respond with a `101 UPGRADED` response, and will similarly follow with the raw stream:
        /// 
        /// ```
        /// HTTP/1.1 101 UPGRADED
        /// Content-Type: application/vnd.docker.raw-stream
        /// Connection: Upgrade
        /// Upgrade: tcp
        /// 
        /// [STREAM]
        /// ```
        /// 
        /// ### Stream format
        /// 
        /// When the TTY setting is disabled in [`POST /containers/create`](#operation/ContainerCreate), the stream over the hijacked connected is multiplexed to separate out `stdout` and `stderr`. The stream consists of a series of frames, each containing a header and a payload.
        /// 
        /// The header contains the information which the stream writes (`stdout` or `stderr`). It also contains the size of the associated frame encoded in the last four bytes (`uint32`).
        /// 
        /// It is encoded on the first eight bytes like this:
        /// 
        /// ```go
        /// header := [8]byte{STREAM_TYPE, 0, 0, 0, SIZE1, SIZE2, SIZE3, SIZE4}
        /// ```
        /// 
        /// `STREAM_TYPE` can be:
        /// 
        /// - 0: `stdin` (is written on `stdout`)
        /// - 1: `stdout`
        /// - 2: `stderr`
        /// 
        /// `SIZE1, SIZE2, SIZE3, SIZE4` are the four bytes of the `uint32` size encoded as big endian.
        /// 
        /// Following the header is the payload, which is the specified number of bytes of `STREAM_TYPE`.
        /// 
        /// The simplest way to implement this protocol is the following:
        /// 
        /// 1. Read 8 bytes.
        /// 2. Choose `stdout` or `stderr` depending on the first byte.
        /// 3. Extract the frame size from the last four bytes.
        /// 4. Read the extracted size and output it on the correct output.
        /// 5. Goto 1.
        /// 
        /// ### Stream format when using a TTY
        /// 
        /// When the TTY setting is enabled in [`POST /containers/create`](#operation/ContainerCreate), the stream is not multiplexed. The data exchanged over the hijacked connection is simply the raw data from the process PTY and client's `stdin`.
        public func post(parameters: PostParameters? = nil) -> Request<Void> {
            .post(path, query: parameters?.asQuery)
        }

        public struct PostParameters {
            public var detachKeys: String?
            public var isLogs: Bool?
            public var isStream: Bool?
            public var isStdin: Bool?
            public var isStdout: Bool?
            public var isStderr: Bool?

            public init(detachKeys: String? = nil, isLogs: Bool? = nil, isStream: Bool? = nil, isStdin: Bool? = nil, isStdout: Bool? = nil, isStderr: Bool? = nil) {
                self.detachKeys = detachKeys
                self.isLogs = isLogs
                self.isStream = isStream
                self.isStdin = isStdin
                self.isStdout = isStdout
                self.isStderr = isStderr
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(detachKeys, forKey: "detachKeys")
                encoder.encode(isLogs, forKey: "logs")
                encoder.encode(isStream, forKey: "stream")
                encoder.encode(isStdin, forKey: "stdin")
                encoder.encode(isStdout, forKey: "stdout")
                encoder.encode(isStderr, forKey: "stderr")
                return encoder.items
            }
        }
    }
}

extension Paths.Containers.WithID.Attach {
    public var ws: Ws {
        Ws(path: path + "/ws")
    }

    public struct Ws {
        /// Path: `/containers/{id}/attach/ws`
        public let path: String

        /// Attach to a container via a websocket
        public func get(parameters: GetParameters? = nil) -> Request<Void> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var detachKeys: String?
            public var isLogs: Bool?
            public var isStream: Bool?
            public var isStdin: Bool?
            public var isStdout: Bool?
            public var isStderr: Bool?

            public init(detachKeys: String? = nil, isLogs: Bool? = nil, isStream: Bool? = nil, isStdin: Bool? = nil, isStdout: Bool? = nil, isStderr: Bool? = nil) {
                self.detachKeys = detachKeys
                self.isLogs = isLogs
                self.isStream = isStream
                self.isStdin = isStdin
                self.isStdout = isStdout
                self.isStderr = isStderr
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(detachKeys, forKey: "detachKeys")
                encoder.encode(isLogs, forKey: "logs")
                encoder.encode(isStream, forKey: "stream")
                encoder.encode(isStdin, forKey: "stdin")
                encoder.encode(isStdout, forKey: "stdout")
                encoder.encode(isStderr, forKey: "stderr")
                return encoder.items
            }
        }
    }
}

extension Paths.Containers.WithID {
    public var wait: Wait {
        Wait(path: path + "/wait")
    }

    public struct Wait {
        /// Path: `/containers/{id}/wait`
        public let path: String

        /// Wait for a container
        ///
        /// Block until a container stops, then returns the exit code.
        public func post(condition: String? = nil) -> Request<PostResponse> {
            .post(path, query: makePostQuery(condition))
        }

        public struct PostResponse: Decodable {
            /// Exit code of the container
            public var statusCode: Int

            public init(statusCode: Int) {
                self.statusCode = statusCode
            }

            private enum CodingKeys: String, CodingKey {
                case statusCode = "StatusCode"
            }
        }

        private func makePostQuery(_ condition: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(condition, forKey: "condition")
            return encoder.items
        }
    }
}

extension Paths.Containers {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/containers/{id}`
        public let path: String

        /// Remove a container
        public func delete(parameters: DeleteParameters? = nil) -> Request<Void> {
            .delete(path, query: parameters?.asQuery)
        }

        public struct DeleteParameters {
            public var isV: Bool?
            public var isForce: Bool?
            public var isLink: Bool?

            public init(isV: Bool? = nil, isForce: Bool? = nil, isLink: Bool? = nil) {
                self.isV = isV
                self.isForce = isForce
                self.isLink = isLink
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isV, forKey: "v")
                encoder.encode(isForce, forKey: "force")
                encoder.encode(isLink, forKey: "link")
                return encoder.items
            }
        }
    }
}

extension Paths.Containers.WithID {
    public var archive: Archive {
        Archive(path: path + "/archive")
    }

    public struct Archive {
        /// Path: `/containers/{id}/archive`
        public let path: String

        /// Get an archive of a filesystem resource in a container
        ///
        /// Get a tar archive of a resource in the filesystem of container id.
        public func get(path: String) -> Request<Void> {
            .get(self.path, query: [("path", path)])
        }

        /// Extract an archive of files or folders to a directory in a container
        ///
        /// Upload a tar archive to be extracted to a path in the filesystem of container id.
        public func put(path: String, noOverwriteDirNonDir: String? = nil, _ body: Data) -> Request<Void> {
            .put(self.path, query: makePutQuery(path, noOverwriteDirNonDir), body: body)
        }

        private func makePutQuery(_ path: String, _ noOverwriteDirNonDir: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(path, forKey: "path")
            encoder.encode(noOverwriteDirNonDir, forKey: "noOverwriteDirNonDir")
            return encoder.items
        }

        /// Get information about files in a container
        ///
        /// A response header `X-Docker-Container-Path-Stat` is return containing a base64 - encoded JSON object with some filesystem header information about the path.
        public func head(path: String) -> Request<Void> {
            .head(self.path, query: [("path", path)])
        }

        public enum HeadResponseHeaders {
            /// TODO
            public static let dockerContainerPathStat = HTTPHeader<String>(field: "X-Docker-Container-Path-Stat")
        }
    }
}

extension Paths.Containers {
    public var prune: Prune {
        Prune(path: path + "/prune")
    }

    public struct Prune {
        /// Path: `/containers/prune`
        public let path: String

        /// Delete stopped containers
        public func post(filters: String? = nil) -> Request<PostResponse> {
            .post(path, query: makePostQuery(filters))
        }

        public struct PostResponse: Decodable {
            /// Container IDs that were deleted
            public var containersDeleted: [String]?
            /// Disk space reclaimed in bytes
            public var spaceReclaimed: Int?

            public init(containersDeleted: [String]? = nil, spaceReclaimed: Int? = nil) {
                self.containersDeleted = containersDeleted
                self.spaceReclaimed = spaceReclaimed
            }

            private enum CodingKeys: String, CodingKey {
                case containersDeleted = "ContainersDeleted"
                case spaceReclaimed = "SpaceReclaimed"
            }
        }

        private func makePostQuery(_ filters: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(filters, forKey: "filters")
            return encoder.items
        }
    }
}

extension Paths {
    public static var images: Images {
        Images(path: "/images")
    }

    public struct Images {
        /// Path: `/images`
        public let path: String
    }
}

extension Paths.Images {
    public var json: JSON {
        JSON(path: path + "/json")
    }

    public struct JSON {
        /// Path: `/images/json`
        public let path: String

        /// List Images
        ///
        /// Returns a list of images on the server. Note that it uses a different, smaller representation of an image than inspecting a single image.
        public func get(parameters: GetParameters? = nil) -> Request<[DockerEngineAPI.ImageSummary]> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isAll: Bool?
            public var filters: String?
            public var isDigests: Bool?

            public init(isAll: Bool? = nil, filters: String? = nil, isDigests: Bool? = nil) {
                self.isAll = isAll
                self.filters = filters
                self.isDigests = isDigests
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isAll, forKey: "all")
                encoder.encode(filters, forKey: "filters")
                encoder.encode(isDigests, forKey: "digests")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var build: Build {
        Build(path: "/build")
    }

    public struct Build {
        /// Path: `/build`
        public let path: String

        /// Build an image
        ///
        /// Build an image from a tar archive with a `Dockerfile` in it.
        /// 
        /// The `Dockerfile` specifies how the image is built from the tar archive. It is typically in the archive's root, but can be at a different path or have a different name by specifying the `dockerfile` parameter. [See the `Dockerfile` reference for more information](https://docs.docker.com/engine/reference/builder/).
        /// 
        /// The Docker daemon performs a preliminary validation of the `Dockerfile` before starting the build, and returns an error if the syntax is incorrect. After that, each instruction is run one-by-one until the ID of the new image is output.
        /// 
        /// The build is canceled if the client drops the connection by quitting or being killed.
        public func post(parameters: PostParameters? = nil, _ body: Data? = nil) -> Request<Void> {
            .post(path, query: parameters?.asQuery, body: body)
        }

        public struct PostParameters {
            public var dockerfile: String?
            public var t: String?
            public var extrahosts: String?
            public var remote: String?
            public var isQ: Bool?
            public var isNocache: Bool?
            public var cachefrom: String?
            public var pull: String?
            public var isRm: Bool?
            public var isForcerm: Bool?
            public var memory: Int?
            public var memswap: Int?
            public var cpushares: Int?
            public var cpusetcpus: String?
            public var cpuperiod: Int?
            public var cpuquota: Int?
            public var buildargs: Int?
            public var shmsize: Int?
            public var isSquash: Bool?
            public var labels: String?
            public var networkmode: String?

            public init(dockerfile: String? = nil, t: String? = nil, extrahosts: String? = nil, remote: String? = nil, isQ: Bool? = nil, isNocache: Bool? = nil, cachefrom: String? = nil, pull: String? = nil, isRm: Bool? = nil, isForcerm: Bool? = nil, memory: Int? = nil, memswap: Int? = nil, cpushares: Int? = nil, cpusetcpus: String? = nil, cpuperiod: Int? = nil, cpuquota: Int? = nil, buildargs: Int? = nil, shmsize: Int? = nil, isSquash: Bool? = nil, labels: String? = nil, networkmode: String? = nil) {
                self.dockerfile = dockerfile
                self.t = t
                self.extrahosts = extrahosts
                self.remote = remote
                self.isQ = isQ
                self.isNocache = isNocache
                self.cachefrom = cachefrom
                self.pull = pull
                self.isRm = isRm
                self.isForcerm = isForcerm
                self.memory = memory
                self.memswap = memswap
                self.cpushares = cpushares
                self.cpusetcpus = cpusetcpus
                self.cpuperiod = cpuperiod
                self.cpuquota = cpuquota
                self.buildargs = buildargs
                self.shmsize = shmsize
                self.isSquash = isSquash
                self.labels = labels
                self.networkmode = networkmode
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(dockerfile, forKey: "dockerfile")
                encoder.encode(t, forKey: "t")
                encoder.encode(extrahosts, forKey: "extrahosts")
                encoder.encode(remote, forKey: "remote")
                encoder.encode(isQ, forKey: "q")
                encoder.encode(isNocache, forKey: "nocache")
                encoder.encode(cachefrom, forKey: "cachefrom")
                encoder.encode(pull, forKey: "pull")
                encoder.encode(isRm, forKey: "rm")
                encoder.encode(isForcerm, forKey: "forcerm")
                encoder.encode(memory, forKey: "memory")
                encoder.encode(memswap, forKey: "memswap")
                encoder.encode(cpushares, forKey: "cpushares")
                encoder.encode(cpusetcpus, forKey: "cpusetcpus")
                encoder.encode(cpuperiod, forKey: "cpuperiod")
                encoder.encode(cpuquota, forKey: "cpuquota")
                encoder.encode(buildargs, forKey: "buildargs")
                encoder.encode(shmsize, forKey: "shmsize")
                encoder.encode(isSquash, forKey: "squash")
                encoder.encode(labels, forKey: "labels")
                encoder.encode(networkmode, forKey: "networkmode")
                return encoder.items
            }
        }
    }
}

extension Paths.Build {
    public var prune: Prune {
        Prune(path: path + "/prune")
    }

    public struct Prune {
        /// Path: `/build/prune`
        public let path: String

        /// Delete builder cache
        public var post: Request<PostResponse> {
            .post(path)
        }

        public struct PostResponse: Decodable {
            /// Disk space reclaimed in bytes
            public var spaceReclaimed: Int?

            public init(spaceReclaimed: Int? = nil) {
                self.spaceReclaimed = spaceReclaimed
            }

            private enum CodingKeys: String, CodingKey {
                case spaceReclaimed = "SpaceReclaimed"
            }
        }
    }
}

extension Paths.Images {
    public var create: Create {
        Create(path: path + "/create")
    }

    public struct Create {
        /// Path: `/images/create`
        public let path: String

        /// Create an image
        ///
        /// Create an image by either pulling it from a registry or importing it.
        public func post(parameters: PostParameters? = nil, _ body: String? = nil) -> Request<Void> {
            .post(path, query: parameters?.asQuery, body: body)
        }

        public struct PostParameters {
            public var fromImage: String?
            public var fromSrc: String?
            public var repo: String?
            public var tag: String?

            public init(fromImage: String? = nil, fromSrc: String? = nil, repo: String? = nil, tag: String? = nil) {
                self.fromImage = fromImage
                self.fromSrc = fromSrc
                self.repo = repo
                self.tag = tag
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fromImage, forKey: "fromImage")
                encoder.encode(fromSrc, forKey: "fromSrc")
                encoder.encode(repo, forKey: "repo")
                encoder.encode(tag, forKey: "tag")
                return encoder.items
            }
        }
    }
}

extension Paths.Images.WithName {
    public var json: JSON {
        JSON(path: path + "/json")
    }

    public struct JSON {
        /// Path: `/images/{name}/json`
        public let path: String

        /// Inspect an image
        ///
        /// Return low-level information about an image.
        public var get: Request<DockerEngineAPI.Image> {
            .get(path)
        }
    }
}

extension Paths.Images.WithName {
    public var history: History {
        History(path: path + "/history")
    }

    public struct History {
        /// Path: `/images/{name}/history`
        public let path: String

        /// Get the history of an image
        ///
        /// Return parent layers of an image.
        public var get: Request<[GetResponseItem]> {
            .get(path)
        }

        public struct GetResponseItem: Decodable {
            public var id: String
            public var created: Int
            public var createdBy: String
            public var tags: [String]
            public var size: Int
            public var comment: String

            public init(id: String, created: Int, createdBy: String, tags: [String], size: Int, comment: String) {
                self.id = id
                self.created = created
                self.createdBy = createdBy
                self.tags = tags
                self.size = size
                self.comment = comment
            }

            private enum CodingKeys: String, CodingKey {
                case id = "Id"
                case created = "Created"
                case createdBy = "CreatedBy"
                case tags = "Tags"
                case size = "Size"
                case comment = "Comment"
            }
        }
    }
}

extension Paths.Images.WithName {
    public var push: Push {
        Push(path: path + "/push")
    }

    public struct Push {
        /// Path: `/images/{name}/push`
        public let path: String

        /// Push an image
        ///
        /// Push an image to a registry.
        /// 
        /// If you wish to push an image on to a private registry, that image must already have a tag which references the registry. For example, `registry.example.com/myimage:latest`.
        /// 
        /// The push is cancelled if the HTTP connection is closed.
        public func post(tag: String? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(tag))
        }

        private func makePostQuery(_ tag: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tag, forKey: "tag")
            return encoder.items
        }
    }
}

extension Paths.Images.WithName {
    public var tag: Tag {
        Tag(path: path + "/tag")
    }

    public struct Tag {
        /// Path: `/images/{name}/tag`
        public let path: String

        /// Tag an image
        ///
        /// Tag an image so that it becomes part of a repository.
        public func post(repo: String? = nil, tag: String? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(repo, tag))
        }

        private func makePostQuery(_ repo: String?, _ tag: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(repo, forKey: "repo")
            encoder.encode(tag, forKey: "tag")
            return encoder.items
        }
    }
}

extension Paths.Images {
    public func name(_ name: String) -> WithName {
        WithName(path: "\(path)/\(name)")
    }

    public struct WithName {
        /// Path: `/images/{name}`
        public let path: String

        /// Remove an image
        ///
        /// Remove an image, along with any untagged parent images that were
        /// referenced by that image.
        /// 
        /// Images can't be removed if they have descendant images, are being
        /// used by a running container or are being used by a build.
        public func delete(isForce: Bool? = nil, isNoprune: Bool? = nil) -> Request<[DockerEngineAPI.ImageDeleteResponseItem]> {
            .delete(path, query: makeDeleteQuery(isForce, isNoprune))
        }

        private func makeDeleteQuery(_ isForce: Bool?, _ isNoprune: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isForce, forKey: "force")
            encoder.encode(isNoprune, forKey: "noprune")
            return encoder.items
        }
    }
}

extension Paths.Images {
    public var search: Search {
        Search(path: path + "/search")
    }

    public struct Search {
        /// Path: `/images/search`
        public let path: String

        /// Search images
        ///
        /// Search for an image on Docker Hub.
        public func get(parameters: GetParameters) -> Request<[GetResponseItem]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponseItem: Decodable {
            public var description: String?
            public var isOfficial: Bool?
            public var isAutomated: Bool?
            public var name: String?
            public var starCount: Int?

            public init(description: String? = nil, isOfficial: Bool? = nil, isAutomated: Bool? = nil, name: String? = nil, starCount: Int? = nil) {
                self.description = description
                self.isOfficial = isOfficial
                self.isAutomated = isAutomated
                self.name = name
                self.starCount = starCount
            }

            private enum CodingKeys: String, CodingKey {
                case description
                case isOfficial = "is_official"
                case isAutomated = "is_automated"
                case name
                case starCount = "star_count"
            }
        }

        public struct GetParameters {
            public var term: String
            public var limit: Int?
            public var filters: String?

            public init(term: String, limit: Int? = nil, filters: String? = nil) {
                self.term = term
                self.limit = limit
                self.filters = filters
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(term, forKey: "term")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(filters, forKey: "filters")
                return encoder.items
            }
        }
    }
}

extension Paths.Images {
    public var prune: Prune {
        Prune(path: path + "/prune")
    }

    public struct Prune {
        /// Path: `/images/prune`
        public let path: String

        /// Delete unused images
        public func post(filters: String? = nil) -> Request<PostResponse> {
            .post(path, query: makePostQuery(filters))
        }

        public struct PostResponse: Decodable {
            /// Images that were deleted
            public var imagesDeleted: [DockerEngineAPI.ImageDeleteResponseItem]?
            /// Disk space reclaimed in bytes
            public var spaceReclaimed: Int?

            public init(imagesDeleted: [DockerEngineAPI.ImageDeleteResponseItem]? = nil, spaceReclaimed: Int? = nil) {
                self.imagesDeleted = imagesDeleted
                self.spaceReclaimed = spaceReclaimed
            }

            private enum CodingKeys: String, CodingKey {
                case imagesDeleted = "ImagesDeleted"
                case spaceReclaimed = "SpaceReclaimed"
            }
        }

        private func makePostQuery(_ filters: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(filters, forKey: "filters")
            return encoder.items
        }
    }
}

extension Paths {
    public static var auth: Auth {
        Auth(path: "/auth")
    }

    public struct Auth {
        /// Path: `/auth`
        public let path: String

        /// Check auth configuration
        ///
        /// Validate credentials for a registry and, if available, get an identity token for accessing the registry without password.
        public func post(_ body: DockerEngineAPI.AuthConfig? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            /// The status of the authentication
            public var status: String
            /// An opaque token used to authenticate a user after a successful login
            public var identityToken: String?

            public init(status: String, identityToken: String? = nil) {
                self.status = status
                self.identityToken = identityToken
            }

            private enum CodingKeys: String, CodingKey {
                case status = "Status"
                case identityToken = "IdentityToken"
            }
        }
    }
}

extension Paths {
    public static var info: Info {
        Info(path: "/info")
    }

    public struct Info {
        /// Path: `/info`
        public let path: String

        /// Get system information
        public var get: Request<DockerEngineAPI.SystemInfo> {
            .get(path)
        }
    }
}

extension Paths {
    public static var version: Version {
        Version(path: "/version")
    }

    public struct Version {
        /// Path: `/version`
        public let path: String

        /// Get version
        ///
        /// Returns the version of Docker that is running and various information about the system that Docker is running on.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var version: String?
            public var apiVersion: String?
            public var minAPIVersion: String?
            public var gitCommit: String?
            public var goVersion: String?
            public var os: String?
            public var arch: String?
            public var kernelVersion: String?
            public var isExperimental: Bool?
            public var buildTime: String?

            public init(version: String? = nil, apiVersion: String? = nil, minAPIVersion: String? = nil, gitCommit: String? = nil, goVersion: String? = nil, os: String? = nil, arch: String? = nil, kernelVersion: String? = nil, isExperimental: Bool? = nil, buildTime: String? = nil) {
                self.version = version
                self.apiVersion = apiVersion
                self.minAPIVersion = minAPIVersion
                self.gitCommit = gitCommit
                self.goVersion = goVersion
                self.os = os
                self.arch = arch
                self.kernelVersion = kernelVersion
                self.isExperimental = isExperimental
                self.buildTime = buildTime
            }

            private enum CodingKeys: String, CodingKey {
                case version = "Version"
                case apiVersion = "ApiVersion"
                case minAPIVersion = "MinAPIVersion"
                case gitCommit = "GitCommit"
                case goVersion = "GoVersion"
                case os = "Os"
                case arch = "Arch"
                case kernelVersion = "KernelVersion"
                case isExperimental = "Experimental"
                case buildTime = "BuildTime"
            }
        }
    }
}

extension Paths {
    public static var ping: Ping {
        Ping(path: "/_ping")
    }

    public struct Ping {
        /// Path: `/_ping`
        public let path: String

        /// Ping
        ///
        /// This is a dummy endpoint you can use to test if the server is accessible.
        public var get: Request<String> {
            .get(path)
        }

        public enum GetResponseHeaders {
            /// If the server is running with experimental mode enabled
            public static let isDockerExperimental = HTTPHeader<Bool>(field: "Docker-Experimental")
            /// Max API Version the server supports
            public static let apiVersion = HTTPHeader<String>(field: "API-Version")
        }
    }
}

extension Paths {
    public static var commit: Commit {
        Commit(path: "/commit")
    }

    public struct Commit {
        /// Path: `/commit`
        public let path: String

        /// Create a new image from a container
        public func post(parameters: PostParameters? = nil, _ body: DockerEngineAPI.ContainerConfig? = nil) -> Request<DockerEngineAPI.IDResponse> {
            .post(path, query: parameters?.asQuery, body: body)
        }

        public struct PostParameters {
            public var container: String?
            public var repo: String?
            public var tag: String?
            public var comment: String?
            public var author: String?
            public var isPause: Bool?
            public var changes: String?

            public init(container: String? = nil, repo: String? = nil, tag: String? = nil, comment: String? = nil, author: String? = nil, isPause: Bool? = nil, changes: String? = nil) {
                self.container = container
                self.repo = repo
                self.tag = tag
                self.comment = comment
                self.author = author
                self.isPause = isPause
                self.changes = changes
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(container, forKey: "container")
                encoder.encode(repo, forKey: "repo")
                encoder.encode(tag, forKey: "tag")
                encoder.encode(comment, forKey: "comment")
                encoder.encode(author, forKey: "author")
                encoder.encode(isPause, forKey: "pause")
                encoder.encode(changes, forKey: "changes")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var events: Events {
        Events(path: "/events")
    }

    public struct Events {
        /// Path: `/events`
        public let path: String

        /// Monitor events
        ///
        /// Stream real-time events from the server.
        /// 
        /// Various objects within Docker report events when something happens to them.
        /// 
        /// Containers report these events: `attach`, `commit`, `copy`, `create`, `destroy`, `detach`, `die`, `exec_create`, `exec_detach`, `exec_start`, `export`, `health_status`, `kill`, `oom`, `pause`, `rename`, `resize`, `restart`, `start`, `stop`, `top`, `unpause`, and `update`
        /// 
        /// Images report these events: `delete`, `import`, `load`, `pull`, `push`, `save`, `tag`, and `untag`
        /// 
        /// Volumes report these events: `create`, `mount`, `unmount`, and `destroy`
        /// 
        /// Networks report these events: `create`, `connect`, `disconnect`, `destroy`, `update`, and `remove`
        /// 
        /// The Docker daemon reports these events: `reload`
        /// 
        /// Services report these events: `create`, `update`, and `remove`
        /// 
        /// Nodes report these events: `create`, `update`, and `remove`
        /// 
        /// Secrets report these events: `create`, `update`, and `remove`
        /// 
        /// Configs report these events: `create`, `update`, and `remove`
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The type of object emitting the event
            public var type: String?
            /// The type of event
            public var action: String?
            public var actor: Actor?
            /// Timestamp of event
            public var time: Int?
            /// Timestamp of event, with nanosecond accuracy
            public var timeNano: Int?

            public struct Actor: Decodable {
                /// The ID of the object emitting the event
                public var id: String?
                /// Various key/value attributes of the object, depending on its type
                public var attributes: [String: String]?

                public init(id: String? = nil, attributes: [String: String]? = nil) {
                    self.id = id
                    self.attributes = attributes
                }

                private enum CodingKeys: String, CodingKey {
                    case id = "ID"
                    case attributes = "Attributes"
                }
            }

            public init(type: String? = nil, action: String? = nil, actor: Actor? = nil, time: Int? = nil, timeNano: Int? = nil) {
                self.type = type
                self.action = action
                self.actor = actor
                self.time = time
                self.timeNano = timeNano
            }

            private enum CodingKeys: String, CodingKey {
                case type = "Type"
                case action = "Action"
                case actor = "Actor"
                case time
                case timeNano
            }
        }

        public struct GetParameters {
            public var since: String?
            public var until: String?
            public var filters: String?

            public init(since: String? = nil, until: String? = nil, filters: String? = nil) {
                self.since = since
                self.until = until
                self.filters = filters
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(since, forKey: "since")
                encoder.encode(until, forKey: "until")
                encoder.encode(filters, forKey: "filters")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var system: System {
        System(path: "/system")
    }

    public struct System {
        /// Path: `/system`
        public let path: String
    }
}

extension Paths.System {
    public var df: Df {
        Df(path: path + "/df")
    }

    public struct Df {
        /// Path: `/system/df`
        public let path: String

        /// Get data usage information
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// Example:
        ///
        /// {
        ///   "Containers" : [
        ///     {
        ///       "Command" : "top",
        ///       "Created" : 1472592424,
        ///       "HostConfig" : {
        ///         "NetworkMode" : "default"
        ///       },
        ///       "Id" : "e575172ed11dc01bfce087fb27bee502db149e1a0fad7c296ad300bbff178148",
        ///       "Image" : "busybox",
        ///       "ImageID" : "sha256:2b8fd9751c4c0f5dd266fcae00707e67a2545ef34f9a29354585f93dac906749",
        ///       "Labels" : {
        /// 
        ///       },
        ///       "Mounts" : [
        /// 
        ///       ],
        ///       "Names" : [
        ///         "\/top"
        ///       ],
        ///       "NetworkSettings" : {
        ///         "Networks" : {
        ///           "bridge" : {
        ///             "EndpointID" : "8ed5115aeaad9abb174f68dcf135b49f11daf597678315231a32ca28441dec6a",
        ///             "Gateway" : "172.18.0.1",
        ///             "GlobalIPv6Address" : null,
        ///             "GlobalIPv6PrefixLen" : 0,
        ///             "IPAddress" : "172.18.0.2",
        ///             "IPPrefixLen" : 16,
        ///             "IPv6Gateway" : null,
        ///             "MacAddress" : "02:42:ac:12:00:02",
        ///             "NetworkID" : "d687bc59335f0e5c9ee8193e5612e8aee000c8c62ea170cfb99c098f95899d92"
        ///           }
        ///         }
        ///       },
        ///       "Ports" : [
        /// 
        ///       ],
        ///       "SizeRootFs" : 1092588,
        ///       "State" : "exited",
        ///       "Status" : "Exited (0) 56 minutes ago"
        ///     }
        ///   ],
        ///   "Images" : [
        ///     {
        ///       "Containers" : 1,
        ///       "Created" : 1466724217,
        ///       "Id" : "sha256:2b8fd9751c4c0f5dd266fcae00707e67a2545ef34f9a29354585f93dac906749",
        ///       "Labels" : {
        /// 
        ///       },
        ///       "ParentId" : null,
        ///       "RepoDigests" : [
        ///         "busybox@sha256:a59906e33509d14c036c8678d687bd4eec81ed7c4b8ce907b888c607f6a1e0e6"
        ///       ],
        ///       "RepoTags" : [
        ///         "busybox:latest"
        ///       ],
        ///       "SharedSize" : 0,
        ///       "Size" : 1092588,
        ///       "VirtualSize" : 1092588
        ///     }
        ///   ],
        ///   "LayersSize" : 1092588,
        ///   "Volumes" : [
        ///     {
        ///       "Driver" : "local",
        ///       "Mountpoint" : "\/var\/lib\/docker\/volumes\/my-volume\/_data",
        ///       "Name" : "my-volume",
        ///       "Scope" : "local",
        ///       "UsageData" : {
        ///         "RefCount" : 2,
        ///         "Size" : 10920104
        ///       }
        ///     }
        ///   ]
        /// }
        public struct GetResponse: Decodable {
            public var layersSize: Int?
            public var images: [DockerEngineAPI.ImageSummary]?
            public var containers: [[ContainerSummaryItem]]?
            public var volumes: [DockerEngineAPI.Volume]?

            public init(layersSize: Int? = nil, images: [DockerEngineAPI.ImageSummary]? = nil, containers: [[ContainerSummaryItem]]? = nil, volumes: [DockerEngineAPI.Volume]? = nil) {
                self.layersSize = layersSize
                self.images = images
                self.containers = containers
                self.volumes = volumes
            }

            private enum CodingKeys: String, CodingKey {
                case layersSize = "LayersSize"
                case images = "Images"
                case containers = "Containers"
                case volumes = "Volumes"
            }
        }
    }
}

extension Paths.Images.WithName {
    public var get: Get {
        Get(path: path + "/get")
    }

    public struct Get {
        /// Path: `/images/{name}/get`
        public let path: String

        /// Export an image
        ///
        /// Get a tarball containing all images and metadata for a repository.
        /// 
        /// If `name` is a specific name and tag (e.g. `ubuntu:latest`), then only that image (and its parents) are returned. If `name` is an image ID, similarly only that image (and its parents) are returned, but with the exclusion of the `repositories` file in the tarball, as there were no image names referenced.
        /// 
        /// ### Image tarball format
        /// 
        /// An image tarball contains one directory per image layer (named using its long ID), each containing these files:
        /// 
        /// - `VERSION`: currently `1.0` - the file format version
        /// - `json`: detailed layer information, similar to `docker inspect layer_id`
        /// - `layer.tar`: A tarfile containing the filesystem changes in this layer
        /// 
        /// The `layer.tar` file contains `aufs` style `.wh..wh.aufs` files and directories for storing attribute changes and deletions.
        /// 
        /// If the tarball defines a repository, the tarball should also include a `repositories` file at the root that contains a list of repository and tag names mapped to layer IDs.
        /// 
        /// ```json
        /// {
        ///   "hello-world": {
        ///     "latest": "565a9d68a73f6706862bfe8409a7f659776d4d60a8d096eb4a3cbce6999cc2a1"
        ///   }
        /// }
        /// ```
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.Images {
    public var get: Get {
        Get(path: path + "/get")
    }

    public struct Get {
        /// Path: `/images/get`
        public let path: String

        /// Export several images
        ///
        /// Get a tarball containing all images and metadata for several image repositories.
        /// 
        /// For each value of the `names` parameter: if it is a specific name and tag (e.g. `ubuntu:latest`), then only that image (and its parents) are returned; if it is an image ID, similarly only that image (and its parents) are returned and there would be no names referenced in the 'repositories' file for this image ID.
        /// 
        /// For details on the format, see [the export image endpoint](#operation/ImageGet).
        public func get(names: [String]? = nil) -> Request<Data> {
            .get(path, query: makeGetQuery(names))
        }

        private func makeGetQuery(_ names: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(names, forKey: "names", explode: false)
            return encoder.items
        }
    }
}

extension Paths.Images {
    public var load: Load {
        Load(path: path + "/load")
    }

    public struct Load {
        /// Path: `/images/load`
        public let path: String

        /// Import images
        ///
        /// Load a set of images and tags into a repository.
        /// 
        /// For details on the format, see [the export image endpoint](#operation/ImageGet).
        public func post(isQuiet: Bool? = nil, _ body: Data? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(isQuiet), body: body)
        }

        private func makePostQuery(_ isQuiet: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isQuiet, forKey: "quiet")
            return encoder.items
        }
    }
}

extension Paths.Containers.WithID {
    public var exec: Exec {
        Exec(path: path + "/exec")
    }

    public struct Exec {
        /// Path: `/containers/{id}/exec`
        public let path: String

        /// Create an exec instance
        ///
        /// Run a command inside a running container.
        public func post(_ body: PostRequest) -> Request<DockerEngineAPI.IDResponse> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "AttachStderr" : true,
        ///   "AttachStdin" : false,
        ///   "AttachStdout" : true,
        ///   "Cmd" : [
        ///     "date"
        ///   ],
        ///   "DetachKeys" : "ctrl-p,ctrl-q",
        ///   "Env" : [
        ///     "FOO=bar",
        ///     "BAZ=quux"
        ///   ],
        ///   "Tty" : false
        /// }
        public struct PostRequest: Encodable {
            /// Attach to `stdin` of the exec command.
            public var isAttachStdin: Bool?
            /// Attach to `stdout` of the exec command.
            public var isAttachStdout: Bool?
            /// Attach to `stderr` of the exec command.
            public var isAttachStderr: Bool?
            /// Override the key sequence for detaching a container. Format is a single character `[a-Z]` or `ctrl-<value>` where `<value>` is one of: `a-z`, `@`, `^`, `[`, `,` or `_`.
            public var detachKeys: String?
            /// Allocate a pseudo-TTY.
            public var isTty: Bool?
            /// A list of environment variables in the form `["VAR=value", ...]`.
            public var env: [String]?
            /// Command to run, as a string or array of strings.
            public var cmd: [String]?
            /// Runs the exec process with extended privileges.
            public var isPrivileged: Bool
            /// The user, and optionally, group to run the exec process inside the container. Format is one of: `user`, `user:group`, `uid`, or `uid:gid`.
            public var user: String?

            public init(isAttachStdin: Bool? = nil, isAttachStdout: Bool? = nil, isAttachStderr: Bool? = nil, detachKeys: String? = nil, isTty: Bool? = nil, env: [String]? = nil, cmd: [String]? = nil, isPrivileged: Bool? = nil, user: String? = nil) {
                self.isAttachStdin = isAttachStdin
                self.isAttachStdout = isAttachStdout
                self.isAttachStderr = isAttachStderr
                self.detachKeys = detachKeys
                self.isTty = isTty
                self.env = env
                self.cmd = cmd
                self.isPrivileged = isPrivileged ?? false
                self.user = user
            }

            private enum CodingKeys: String, CodingKey {
                case isAttachStdin = "AttachStdin"
                case isAttachStdout = "AttachStdout"
                case isAttachStderr = "AttachStderr"
                case detachKeys = "DetachKeys"
                case isTty = "Tty"
                case env = "Env"
                case cmd = "Cmd"
                case isPrivileged = "Privileged"
                case user = "User"
            }
        }
    }
}

extension Paths {
    public static var exec: Exec {
        Exec(path: "/exec")
    }

    public struct Exec {
        /// Path: `/exec`
        public let path: String
    }
}

extension Paths.Exec {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/exec/{id}`
        public let path: String
    }
}

extension Paths.Exec.WithID {
    public var start: Start {
        Start(path: path + "/start")
    }

    public struct Start {
        /// Path: `/exec/{id}/start`
        public let path: String

        /// Start an exec instance
        ///
        /// Starts a previously set up exec instance. If detach is true, this endpoint returns immediately after starting the command. Otherwise, it sets up an interactive session with the command.
        public func post(_ body: PostRequest? = nil) -> Request<Void> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "Detach" : false,
        ///   "Tty" : false
        /// }
        public struct PostRequest: Encodable {
            /// Detach from the command.
            public var isDetach: Bool?
            /// Allocate a pseudo-TTY.
            public var isTty: Bool?

            public init(isDetach: Bool? = nil, isTty: Bool? = nil) {
                self.isDetach = isDetach
                self.isTty = isTty
            }

            private enum CodingKeys: String, CodingKey {
                case isDetach = "Detach"
                case isTty = "Tty"
            }
        }
    }
}

extension Paths.Exec.WithID {
    public var resize: Resize {
        Resize(path: path + "/resize")
    }

    public struct Resize {
        /// Path: `/exec/{id}/resize`
        public let path: String

        /// Resize an exec instance
        ///
        /// Resize the TTY session used by an exec instance. This endpoint only works if `tty` was specified as part of creating and starting the exec instance.
        public func post(h: Int? = nil, w: Int? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(h, w))
        }

        private func makePostQuery(_ h: Int?, _ w: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(h, forKey: "h")
            encoder.encode(w, forKey: "w")
            return encoder.items
        }
    }
}

extension Paths.Exec.WithID {
    public var json: JSON {
        JSON(path: path + "/json")
    }

    public struct JSON {
        /// Path: `/exec/{id}/json`
        public let path: String

        /// Inspect an exec instance
        ///
        /// Return low-level information about an exec instance.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var id: String?
            public var isRunning: Bool?
            public var exitCode: Int?
            public var processConfig: DockerEngineAPI.ProcessConfig?
            public var isOpenStdin: Bool?
            public var isOpenStderr: Bool?
            public var isOpenStdout: Bool?
            public var containerID: String?
            /// The system process ID for the exec process.
            public var pid: Int?

            public init(id: String? = nil, isRunning: Bool? = nil, exitCode: Int? = nil, processConfig: DockerEngineAPI.ProcessConfig? = nil, isOpenStdin: Bool? = nil, isOpenStderr: Bool? = nil, isOpenStdout: Bool? = nil, containerID: String? = nil, pid: Int? = nil) {
                self.id = id
                self.isRunning = isRunning
                self.exitCode = exitCode
                self.processConfig = processConfig
                self.isOpenStdin = isOpenStdin
                self.isOpenStderr = isOpenStderr
                self.isOpenStdout = isOpenStdout
                self.containerID = containerID
                self.pid = pid
            }

            private enum CodingKeys: String, CodingKey {
                case id = "ID"
                case isRunning = "Running"
                case exitCode = "ExitCode"
                case processConfig = "ProcessConfig"
                case isOpenStdin = "OpenStdin"
                case isOpenStderr = "OpenStderr"
                case isOpenStdout = "OpenStdout"
                case containerID = "ContainerID"
                case pid = "Pid"
            }
        }
    }
}

extension Paths {
    public static var volumes: Volumes {
        Volumes(path: "/volumes")
    }

    public struct Volumes {
        /// Path: `/volumes`
        public let path: String

        /// List volumes
        public func get(filters: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(filters))
        }

        public struct GetResponse: Decodable {
            /// List of volumes
            public var volumes: [DockerEngineAPI.Volume]
            /// Warnings that occurred when fetching the list of volumes
            public var warnings: [String]

            public init(volumes: [DockerEngineAPI.Volume], warnings: [String]) {
                self.volumes = volumes
                self.warnings = warnings
            }

            private enum CodingKeys: String, CodingKey {
                case volumes = "Volumes"
                case warnings = "Warnings"
            }
        }

        private func makeGetQuery(_ filters: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(filters, forKey: "filters")
            return encoder.items
        }
    }
}

extension Paths.Volumes {
    public var create: Create {
        Create(path: path + "/create")
    }

    public struct Create {
        /// Path: `/volumes/create`
        public let path: String

        /// Create a volume
        public func post(_ body: PostRequest) -> Request<DockerEngineAPI.Volume> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "Driver" : "custom",
        ///   "Labels" : {
        ///     "com.example.some-label" : "some-value",
        ///     "com.example.some-other-label" : "some-other-value"
        ///   },
        ///   "Name" : "tardis"
        /// }
        public struct PostRequest: Encodable {
            /// The new volume's name. If not specified, Docker generates a name.
            public var name: String?
            /// Name of the volume driver to use.
            public var driver: String?
            /// A mapping of driver options and values. These options are passed directly to the driver and are driver specific.
            public var driverOpts: [String: String]?
            /// User-defined key/value metadata.
            public var labels: [String: String]?

            public init(name: String? = nil, driver: String? = nil, driverOpts: [String: String]? = nil, labels: [String: String]? = nil) {
                self.name = name
                self.driver = driver
                self.driverOpts = driverOpts
                self.labels = labels
            }

            private enum CodingKeys: String, CodingKey {
                case name = "Name"
                case driver = "Driver"
                case driverOpts = "DriverOpts"
                case labels = "Labels"
            }
        }
    }
}

extension Paths.Volumes {
    public func name(_ name: String) -> WithName {
        WithName(path: "\(path)/\(name)")
    }

    public struct WithName {
        /// Path: `/volumes/{name}`
        public let path: String

        /// Inspect a volume
        public var get: Request<DockerEngineAPI.Volume> {
            .get(path)
        }

        /// Remove a volume
        ///
        /// Instruct the driver to remove the volume.
        public func delete(isForce: Bool? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(isForce))
        }

        private func makeDeleteQuery(_ isForce: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isForce, forKey: "force")
            return encoder.items
        }
    }
}

extension Paths.Volumes {
    public var prune: Prune {
        Prune(path: path + "/prune")
    }

    public struct Prune {
        /// Path: `/volumes/prune`
        public let path: String

        /// Delete unused volumes
        public func post(filters: String? = nil) -> Request<PostResponse> {
            .post(path, query: makePostQuery(filters))
        }

        public struct PostResponse: Decodable {
            /// Volumes that were deleted
            public var volumesDeleted: [String]?
            /// Disk space reclaimed in bytes
            public var spaceReclaimed: Int?

            public init(volumesDeleted: [String]? = nil, spaceReclaimed: Int? = nil) {
                self.volumesDeleted = volumesDeleted
                self.spaceReclaimed = spaceReclaimed
            }

            private enum CodingKeys: String, CodingKey {
                case volumesDeleted = "VolumesDeleted"
                case spaceReclaimed = "SpaceReclaimed"
            }
        }

        private func makePostQuery(_ filters: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(filters, forKey: "filters")
            return encoder.items
        }
    }
}

extension Paths {
    public static var networks: Networks {
        Networks(path: "/networks")
    }

    public struct Networks {
        /// Path: `/networks`
        public let path: String

        /// List networks
        ///
        /// Returns a list of networks. For details on the format, see [the network inspect endpoint](#operation/NetworkInspect).
        /// 
        /// Note that it uses a different, smaller representation of a network than inspecting a single network. For example,
        /// the list of containers attached to the network is not propagated in API versions 1.28 and up.
        public func get(filters: String? = nil) -> Request<[DockerEngineAPI.Network]> {
            .get(path, query: makeGetQuery(filters))
        }

        private func makeGetQuery(_ filters: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(filters, forKey: "filters")
            return encoder.items
        }
    }
}

extension Paths.Networks {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/networks/{id}`
        public let path: String

        /// Inspect a network
        public func get(isVerbose: Bool? = nil, scope: String? = nil) -> Request<DockerEngineAPI.Network> {
            .get(path, query: makeGetQuery(isVerbose, scope))
        }

        private func makeGetQuery(_ isVerbose: Bool?, _ scope: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isVerbose, forKey: "verbose")
            encoder.encode(scope, forKey: "scope")
            return encoder.items
        }

        /// Remove a network
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Networks {
    public var create: Create {
        Create(path: path + "/create")
    }

    public struct Create {
        /// Path: `/networks/create`
        public let path: String

        /// Create a network
        public func post(_ body: PostRequest) -> Request<PostResponse> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "Id" : "22be93d5babb089c5aab8dbc369042fad48ff791584ca2da2100db837a1c7c30",
        ///   "Warning" : null
        /// }
        public struct PostResponse: Decodable {
            /// The ID of the created network.
            public var id: String?
            public var warning: String?

            public init(id: String? = nil, warning: String? = nil) {
                self.id = id
                self.warning = warning
            }

            private enum CodingKeys: String, CodingKey {
                case id = "Id"
                case warning = "Warning"
            }
        }

        /// Example:
        ///
        /// {
        ///   "Attachable" : false,
        ///   "CheckDuplicate" : false,
        ///   "Driver" : "bridge",
        ///   "EnableIPv6" : true,
        ///   "Ingress" : false,
        ///   "Internal" : true,
        ///   "IPAM" : {
        ///     "Config" : [
        ///       {
        ///         "Gateway" : "172.20.10.11",
        ///         "IPRange" : "172.20.10.0\/24",
        ///         "Subnet" : "172.20.0.0\/16"
        ///       },
        ///       {
        ///         "Gateway" : "2001:db8:abcd::1011",
        ///         "Subnet" : "2001:db8:abcd::\/64"
        ///       }
        ///     ],
        ///     "Driver" : "default",
        ///     "Options" : {
        ///       "foo" : "bar"
        ///     }
        ///   },
        ///   "Labels" : {
        ///     "com.example.some-label" : "some-value",
        ///     "com.example.some-other-label" : "some-other-value"
        ///   },
        ///   "Name" : "isolated_nw",
        ///   "Options" : {
        ///     "com.docker.network.bridge.default_bridge" : true,
        ///     "com.docker.network.bridge.enable_icc" : true,
        ///     "com.docker.network.bridge.enable_ip_masquerade" : true,
        ///     "com.docker.network.bridge.host_binding_ipv4" : "0.0.0.0",
        ///     "com.docker.network.bridge.name" : "docker0",
        ///     "com.docker.network.driver.mtu" : "1500"
        ///   }
        /// }
        public struct PostRequest: Encodable {
            /// The network's name.
            public var name: String
            /// Check for networks with duplicate names. Since Network is primarily keyed based on a random ID and not on the name, and network name is strictly a user-friendly alias to the network which is uniquely identified using ID, there is no guaranteed way to check for duplicates. CheckDuplicate is there to provide a best effort checking of any networks which has the same name but it is not guaranteed to catch all name collisions.
            public var isCheckDuplicate: Bool?
            /// Name of the network driver plugin to use.
            public var driver: String?
            /// Restrict external access to the network.
            public var isInternal: Bool?
            /// Globally scoped network is manually attachable by regular containers from workers in swarm mode.
            public var isAttachable: Bool?
            /// Ingress network is the network which provides the routing-mesh in swarm mode.
            public var isIngress: Bool?
            public var ipam: DockerEngineAPI.Ipam?
            /// Enable IPv6 on the network.
            public var enableIPv6: Bool?
            /// Network specific options to be used by the drivers.
            public var options: [String: String]?
            /// User-defined key/value metadata.
            public var labels: [String: String]?

            public init(name: String, isCheckDuplicate: Bool? = nil, driver: String? = nil, isInternal: Bool? = nil, isAttachable: Bool? = nil, isIngress: Bool? = nil, ipam: DockerEngineAPI.Ipam? = nil, enableIPv6: Bool? = nil, options: [String: String]? = nil, labels: [String: String]? = nil) {
                self.name = name
                self.isCheckDuplicate = isCheckDuplicate
                self.driver = driver
                self.isInternal = isInternal
                self.isAttachable = isAttachable
                self.isIngress = isIngress
                self.ipam = ipam
                self.enableIPv6 = enableIPv6
                self.options = options
                self.labels = labels
            }

            private enum CodingKeys: String, CodingKey {
                case name = "Name"
                case isCheckDuplicate = "CheckDuplicate"
                case driver = "Driver"
                case isInternal = "Internal"
                case isAttachable = "Attachable"
                case isIngress = "Ingress"
                case ipam = "IPAM"
                case enableIPv6 = "EnableIPv6"
                case options = "Options"
                case labels = "Labels"
            }
        }
    }
}

extension Paths.Networks.WithID {
    public var connect: Connect {
        Connect(path: path + "/connect")
    }

    public struct Connect {
        /// Path: `/networks/{id}/connect`
        public let path: String

        /// Connect a container to a network
        public func post(_ body: Data) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Networks.WithID {
    public var disconnect: Disconnect {
        Disconnect(path: path + "/disconnect")
    }

    public struct Disconnect {
        /// Path: `/networks/{id}/disconnect`
        public let path: String

        /// Disconnect a container from a network
        public func post(_ body: PostRequest) -> Request<Void> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The ID or name of the container to disconnect from the network.
            public var container: String?
            /// Force the container to disconnect from the network.
            public var isForce: Bool?

            public init(container: String? = nil, isForce: Bool? = nil) {
                self.container = container
                self.isForce = isForce
            }

            private enum CodingKeys: String, CodingKey {
                case container = "Container"
                case isForce = "Force"
            }
        }
    }
}

extension Paths.Networks {
    public var prune: Prune {
        Prune(path: path + "/prune")
    }

    public struct Prune {
        /// Path: `/networks/prune`
        public let path: String

        /// Delete unused networks
        public func post(filters: String? = nil) -> Request<PostResponse> {
            .post(path, query: makePostQuery(filters))
        }

        public struct PostResponse: Decodable {
            /// Networks that were deleted
            public var networksDeleted: [String]?

            public init(networksDeleted: [String]? = nil) {
                self.networksDeleted = networksDeleted
            }

            private enum CodingKeys: String, CodingKey {
                case networksDeleted = "NetworksDeleted"
            }
        }

        private func makePostQuery(_ filters: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(filters, forKey: "filters")
            return encoder.items
        }
    }
}

extension Paths {
    public static var plugins: Plugins {
        Plugins(path: "/plugins")
    }

    public struct Plugins {
        /// Path: `/plugins`
        public let path: String

        /// List plugins
        ///
        /// Returns information about installed plugins.
        public func get(filters: String? = nil) -> Request<[DockerEngineAPI.Plugin]> {
            .get(path, query: makeGetQuery(filters))
        }

        private func makeGetQuery(_ filters: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(filters, forKey: "filters")
            return encoder.items
        }
    }
}

extension Paths.Plugins {
    public var privileges: Privileges {
        Privileges(path: path + "/privileges")
    }

    public struct Privileges {
        /// Path: `/plugins/privileges`
        public let path: String

        /// Get plugin privileges
        public func get(remote: String) -> Request<[GetResponseItem]> {
            .get(path, query: [("remote", remote)])
        }

        /// Describes a permission the user has to accept upon installing the plugin.
        public struct GetResponseItem: Decodable {
            public var name: String?
            public var description: String?
            public var value: [String]?

            public init(name: String? = nil, description: String? = nil, value: [String]? = nil) {
                self.name = name
                self.description = description
                self.value = value
            }

            private enum CodingKeys: String, CodingKey {
                case name = "Name"
                case description = "Description"
                case value = "Value"
            }
        }
    }
}

extension Paths.Plugins {
    public var pull: Pull {
        Pull(path: path + "/pull")
    }

    public struct Pull {
        /// Path: `/plugins/pull`
        public let path: String

        /// Install a plugin
        ///
        /// Pulls and installs a plugin. After the plugin is installed, it can be enabled using the [`POST /plugins/{name}/enable` endpoint](#operation/PostPluginsEnable).
        public func post(remote: String, name: String? = nil, _ body: [PostRequestItem]? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(remote, name), body: body)
        }

        private func makePostQuery(_ remote: String, _ name: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(remote, forKey: "remote")
            encoder.encode(name, forKey: "name")
            return encoder.items
        }

        /// Describes a permission accepted by the user upon installing the plugin.
        public struct PostRequestItem: Encodable {
            public var name: String?
            public var description: String?
            public var value: [String]?

            public init(name: String? = nil, description: String? = nil, value: [String]? = nil) {
                self.name = name
                self.description = description
                self.value = value
            }

            private enum CodingKeys: String, CodingKey {
                case name = "Name"
                case description = "Description"
                case value = "Value"
            }
        }
    }
}

extension Paths.Plugins.WithName {
    public var json: JSON {
        JSON(path: path + "/json")
    }

    public struct JSON {
        /// Path: `/plugins/{name}/json`
        public let path: String

        /// Inspect a plugin
        public var get: Request<DockerEngineAPI.Plugin> {
            .get(path)
        }
    }
}

extension Paths.Plugins {
    public func name(_ name: String) -> WithName {
        WithName(path: "\(path)/\(name)")
    }

    public struct WithName {
        /// Path: `/plugins/{name}`
        public let path: String

        /// Remove a plugin
        public func delete(isForce: Bool? = nil) -> Request<DockerEngineAPI.Plugin> {
            .delete(path, query: makeDeleteQuery(isForce))
        }

        private func makeDeleteQuery(_ isForce: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isForce, forKey: "force")
            return encoder.items
        }
    }
}

extension Paths.Plugins.WithName {
    public var enable: Enable {
        Enable(path: path + "/enable")
    }

    public struct Enable {
        /// Path: `/plugins/{name}/enable`
        public let path: String

        /// Enable a plugin
        public func post(timeout: Int? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(timeout))
        }

        private func makePostQuery(_ timeout: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(timeout, forKey: "timeout")
            return encoder.items
        }
    }
}

extension Paths.Plugins.WithName {
    public var disable: Disable {
        Disable(path: path + "/disable")
    }

    public struct Disable {
        /// Path: `/plugins/{name}/disable`
        public let path: String

        /// Disable a plugin
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Plugins.WithName {
    public var upgrade: Upgrade {
        Upgrade(path: path + "/upgrade")
    }

    public struct Upgrade {
        /// Path: `/plugins/{name}/upgrade`
        public let path: String

        /// Upgrade a plugin
        public func post(remote: String, _ body: [PostRequestItem]? = nil) -> Request<Void> {
            .post(path, query: [("remote", remote)], body: body)
        }

        /// Describes a permission accepted by the user upon installing the plugin.
        public struct PostRequestItem: Encodable {
            public var name: String?
            public var description: String?
            public var value: [String]?

            public init(name: String? = nil, description: String? = nil, value: [String]? = nil) {
                self.name = name
                self.description = description
                self.value = value
            }

            private enum CodingKeys: String, CodingKey {
                case name = "Name"
                case description = "Description"
                case value = "Value"
            }
        }
    }
}

extension Paths.Plugins {
    public var create: Create {
        Create(path: path + "/create")
    }

    public struct Create {
        /// Path: `/plugins/create`
        public let path: String

        /// Create a plugin
        public func post(name: String, _ body: Data? = nil) -> Request<Void> {
            .post(path, query: [("name", name)], body: body)
        }
    }
}

extension Paths.Plugins.WithName {
    public var push: Push {
        Push(path: path + "/push")
    }

    public struct Push {
        /// Path: `/plugins/{name}/push`
        public let path: String

        /// Push a plugin
        ///
        /// Push a plugin to the registry.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Plugins.WithName {
    public var set: Set {
        Set(path: path + "/set")
    }

    public struct Set {
        /// Path: `/plugins/{name}/set`
        public let path: String

        /// Configure a plugin
        public func post(_ body: [String]? = nil) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths {
    public static var nodes: Nodes {
        Nodes(path: "/nodes")
    }

    public struct Nodes {
        /// Path: `/nodes`
        public let path: String

        /// List nodes
        public func get(filters: String? = nil) -> Request<[DockerEngineAPI.Node]> {
            .get(path, query: makeGetQuery(filters))
        }

        private func makeGetQuery(_ filters: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(filters, forKey: "filters")
            return encoder.items
        }
    }
}

extension Paths.Nodes {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/nodes/{id}`
        public let path: String

        /// Inspect a node
        public var get: Request<DockerEngineAPI.Node> {
            .get(path)
        }

        /// Delete a node
        public func delete(isForce: Bool? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(isForce))
        }

        private func makeDeleteQuery(_ isForce: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isForce, forKey: "force")
            return encoder.items
        }
    }
}

extension Paths.Nodes.WithID {
    public var update: Update {
        Update(path: path + "/update")
    }

    public struct Update {
        /// Path: `/nodes/{id}/update`
        public let path: String

        /// Update a node
        public func post(version: Int, _ body: DockerEngineAPI.NodeSpec? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(version), body: body)
        }

        private func makePostQuery(_ version: Int) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(version, forKey: "version")
            return encoder.items
        }
    }
}

extension Paths {
    public static var swarm: Swarm {
        Swarm(path: "/swarm")
    }

    public struct Swarm {
        /// Path: `/swarm`
        public let path: String

        /// Inspect swarm
        public var get: Request<DockerEngineAPI.Swarm> {
            .get(path)
        }
    }
}

extension Paths.Swarm {
    public var `init`: Init {
        Init(path: path + "/init")
    }

    public struct Init {
        /// Path: `/swarm/init`
        public let path: String

        /// Initialize a new swarm
        public func post(_ body: PostRequest) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "AdvertiseAddr" : "192.168.1.1:2377",
        ///   "ForceNewCluster" : false,
        ///   "ListenAddr" : "0.0.0.0:2377",
        ///   "Spec" : {
        ///     "CAConfig" : {
        /// 
        ///     },
        ///     "Dispatcher" : {
        /// 
        ///     },
        ///     "EncryptionConfig" : {
        ///       "AutoLockManagers" : false
        ///     },
        ///     "Orchestration" : {
        /// 
        ///     },
        ///     "Raft" : {
        /// 
        ///     }
        ///   }
        /// }
        public struct PostRequest: Encodable {
            /// Listen address used for inter-manager communication, as well as determining the networking interface used for the VXLAN Tunnel Endpoint (VTEP). This can either be an address/port combination in the form `192.168.1.1:4567`, or an interface followed by a port number, like `eth0:4567`. If the port number is omitted, the default swarm listening port is used.
            public var listenAddr: String?
            /// Externally reachable address advertised to other nodes. This can either be an address/port combination in the form `192.168.1.1:4567`, or an interface followed by a port number, like `eth0:4567`. If the port number is omitted, the port number from the listen address is used. If `AdvertiseAddr` is not specified, it will be automatically detected when possible.
            public var advertiseAddr: String?
            /// Address or interface to use for data path traffic (format: `<ip|interface>`), for example,  `192.168.1.1`,
            /// or an interface, like `eth0`. If `DataPathAddr` is unspecified, the same address as `AdvertiseAddr`
            /// is used.
            /// 
            /// The `DataPathAddr` specifies the address that global scope network drivers will publish towards other
            /// nodes in order to reach the containers running on this node. Using this parameter it is possible to
            /// separate the container data traffic from the management traffic of the cluster.
            public var dataPathAddr: String?
            /// Force creation of a new swarm.
            public var isForceNewCluster: Bool?
            /// User modifiable swarm configuration.
            public var spec: DockerEngineAPI.SwarmSpec?

            public init(listenAddr: String? = nil, advertiseAddr: String? = nil, dataPathAddr: String? = nil, isForceNewCluster: Bool? = nil, spec: DockerEngineAPI.SwarmSpec? = nil) {
                self.listenAddr = listenAddr
                self.advertiseAddr = advertiseAddr
                self.dataPathAddr = dataPathAddr
                self.isForceNewCluster = isForceNewCluster
                self.spec = spec
            }

            private enum CodingKeys: String, CodingKey {
                case listenAddr = "ListenAddr"
                case advertiseAddr = "AdvertiseAddr"
                case dataPathAddr = "DataPathAddr"
                case isForceNewCluster = "ForceNewCluster"
                case spec = "Spec"
            }
        }
    }
}

extension Paths.Swarm {
    public var join: Join {
        Join(path: path + "/join")
    }

    public struct Join {
        /// Path: `/swarm/join`
        public let path: String

        /// Join an existing swarm
        public func post(_ body: PostRequest) -> Request<Void> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "AdvertiseAddr" : "192.168.1.1:2377",
        ///   "JoinToken" : "SWMTKN-1-3pu6hszjas19xyp7ghgosyx9k8atbfcr8p2is99znpy26u2lkl-7p73s1dx5in4tatdymyhg9hu2",
        ///   "ListenAddr" : "0.0.0.0:2377",
        ///   "RemoteAddrs" : [
        ///     "node1:2377"
        ///   ]
        /// }
        public struct PostRequest: Encodable {
            /// Listen address used for inter-manager communication if the node gets promoted to manager, as well as determining the networking interface used for the VXLAN Tunnel Endpoint (VTEP).
            public var listenAddr: String?
            /// Externally reachable address advertised to other nodes. This can either be an address/port combination in the form `192.168.1.1:4567`, or an interface followed by a port number, like `eth0:4567`. If the port number is omitted, the port number from the listen address is used. If `AdvertiseAddr` is not specified, it will be automatically detected when possible.
            public var advertiseAddr: String?
            /// Address or interface to use for data path traffic (format: `<ip|interface>`), for example,  `192.168.1.1`,
            /// or an interface, like `eth0`. If `DataPathAddr` is unspecified, the same address as `AdvertiseAddr`
            /// is used.
            /// 
            /// The `DataPathAddr` specifies the address that global scope network drivers will publish towards other
            /// nodes in order to reach the containers running on this node. Using this parameter it is possible to
            /// separate the container data traffic from the management traffic of the cluster.
            public var dataPathAddr: String?
            /// Addresses of manager nodes already participating in the swarm.
            public var remoteAddrs: String?
            /// Secret token for joining this swarm.
            public var joinToken: String?

            public init(listenAddr: String? = nil, advertiseAddr: String? = nil, dataPathAddr: String? = nil, remoteAddrs: String? = nil, joinToken: String? = nil) {
                self.listenAddr = listenAddr
                self.advertiseAddr = advertiseAddr
                self.dataPathAddr = dataPathAddr
                self.remoteAddrs = remoteAddrs
                self.joinToken = joinToken
            }

            private enum CodingKeys: String, CodingKey {
                case listenAddr = "ListenAddr"
                case advertiseAddr = "AdvertiseAddr"
                case dataPathAddr = "DataPathAddr"
                case remoteAddrs = "RemoteAddrs"
                case joinToken = "JoinToken"
            }
        }
    }
}

extension Paths.Swarm {
    public var leave: Leave {
        Leave(path: path + "/leave")
    }

    public struct Leave {
        /// Path: `/swarm/leave`
        public let path: String

        /// Leave a swarm
        public func post(isForce: Bool? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(isForce))
        }

        private func makePostQuery(_ isForce: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isForce, forKey: "force")
            return encoder.items
        }
    }
}

extension Paths.Swarm {
    public var update: Update {
        Update(path: path + "/update")
    }

    public struct Update {
        /// Path: `/swarm/update`
        public let path: String

        /// Update a swarm
        public func post(parameters: PostParameters, _ body: DockerEngineAPI.SwarmSpec) -> Request<Void> {
            .post(path, query: parameters.asQuery, body: body)
        }

        public struct PostParameters {
            public var version: Int
            public var isRotateWorkerToken: Bool?
            public var isRotateManagerToken: Bool?
            public var isRotateManagerUnlockKey: Bool?

            public init(version: Int, isRotateWorkerToken: Bool? = nil, isRotateManagerToken: Bool? = nil, isRotateManagerUnlockKey: Bool? = nil) {
                self.version = version
                self.isRotateWorkerToken = isRotateWorkerToken
                self.isRotateManagerToken = isRotateManagerToken
                self.isRotateManagerUnlockKey = isRotateManagerUnlockKey
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(version, forKey: "version")
                encoder.encode(isRotateWorkerToken, forKey: "rotateWorkerToken")
                encoder.encode(isRotateManagerToken, forKey: "rotateManagerToken")
                encoder.encode(isRotateManagerUnlockKey, forKey: "rotateManagerUnlockKey")
                return encoder.items
            }
        }
    }
}

extension Paths.Swarm {
    public var unlockkey: Unlockkey {
        Unlockkey(path: path + "/unlockkey")
    }

    public struct Unlockkey {
        /// Path: `/swarm/unlockkey`
        public let path: String

        /// Get the unlock key
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// Example:
        ///
        /// {
        ///   "UnlockKey" : "SWMKEY-1-7c37Cc8654o6p38HnroywCi19pllOnGtbdZEgtKxZu8"
        /// }
        public struct GetResponse: Decodable {
            /// The swarm's unlock key.
            public var unlockKey: String?

            public init(unlockKey: String? = nil) {
                self.unlockKey = unlockKey
            }

            private enum CodingKeys: String, CodingKey {
                case unlockKey = "UnlockKey"
            }
        }
    }
}

extension Paths.Swarm {
    public var unlock: Unlock {
        Unlock(path: path + "/unlock")
    }

    public struct Unlock {
        /// Path: `/swarm/unlock`
        public let path: String

        /// Unlock a locked manager
        public func post(unlockKey: String? = nil) -> Request<Void> {
            .post(path, body: ["UnlockKey": unlockKey])
        }
    }
}

extension Paths {
    public static var services: Services {
        Services(path: "/services")
    }

    public struct Services {
        /// Path: `/services`
        public let path: String

        /// List services
        public func get(filters: String? = nil) -> Request<[DockerEngineAPI.Service]> {
            .get(path, query: makeGetQuery(filters))
        }

        private func makeGetQuery(_ filters: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(filters, forKey: "filters")
            return encoder.items
        }
    }
}

extension Paths.Services {
    public var create: Create {
        Create(path: path + "/create")
    }

    public struct Create {
        /// Path: `/services/create`
        public let path: String

        /// Create a service
        public func post(_ body: DockerEngineAPI.ServiceSpec) -> Request<PostResponse> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "ID" : "ak7w3gjqoa3kuz8xcpnyy0pvl",
        ///   "Warning" : "unable to pin image doesnotexist:latest to digest: image library\/doesnotexist:latest not found"
        /// }
        public struct PostResponse: Decodable {
            /// The ID of the created service.
            public var id: String?
            /// Optional warning message
            public var warning: String?

            public init(id: String? = nil, warning: String? = nil) {
                self.id = id
                self.warning = warning
            }

            private enum CodingKeys: String, CodingKey {
                case id = "ID"
                case warning = "Warning"
            }
        }
    }
}

extension Paths.Services {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/services/{id}`
        public let path: String

        /// Inspect a service
        public func get(isInsertDefaults: Bool? = nil) -> Request<DockerEngineAPI.Service> {
            .get(path, query: makeGetQuery(isInsertDefaults))
        }

        private func makeGetQuery(_ isInsertDefaults: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isInsertDefaults, forKey: "insertDefaults")
            return encoder.items
        }

        /// Delete a service
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Services.WithID {
    public var update: Update {
        Update(path: path + "/update")
    }

    public struct Update {
        /// Path: `/services/{id}/update`
        public let path: String

        /// Update a service
        public func post(parameters: PostParameters, _ body: DockerEngineAPI.ServiceSpec) -> Request<DockerEngineAPI.ServiceUpdateResponse> {
            .post(path, query: parameters.asQuery, body: body)
        }

        public struct PostParameters {
            public var version: Int
            public var registryAuthFrom: String?
            public var rollback: String?

            public init(version: Int, registryAuthFrom: String? = nil, rollback: String? = nil) {
                self.version = version
                self.registryAuthFrom = registryAuthFrom
                self.rollback = rollback
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(version, forKey: "version")
                encoder.encode(registryAuthFrom, forKey: "registryAuthFrom")
                encoder.encode(rollback, forKey: "rollback")
                return encoder.items
            }
        }
    }
}

extension Paths.Services.WithID {
    public var logs: Logs {
        Logs(path: path + "/logs")
    }

    public struct Logs {
        /// Path: `/services/{id}/logs`
        public let path: String

        /// Get service logs
        ///
        /// Get `stdout` and `stderr` logs from a service.
        /// 
        /// **Note**: This endpoint works only for services with the `json-file` or `journald` logging drivers.
        public func get(parameters: GetParameters? = nil) -> Request<String> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isDetails: Bool?
            public var isFollow: Bool?
            public var isStdout: Bool?
            public var isStderr: Bool?
            public var since: Int?
            public var isTimestamps: Bool?
            public var tail: String?

            public init(isDetails: Bool? = nil, isFollow: Bool? = nil, isStdout: Bool? = nil, isStderr: Bool? = nil, since: Int? = nil, isTimestamps: Bool? = nil, tail: String? = nil) {
                self.isDetails = isDetails
                self.isFollow = isFollow
                self.isStdout = isStdout
                self.isStderr = isStderr
                self.since = since
                self.isTimestamps = isTimestamps
                self.tail = tail
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isDetails, forKey: "details")
                encoder.encode(isFollow, forKey: "follow")
                encoder.encode(isStdout, forKey: "stdout")
                encoder.encode(isStderr, forKey: "stderr")
                encoder.encode(since, forKey: "since")
                encoder.encode(isTimestamps, forKey: "timestamps")
                encoder.encode(tail, forKey: "tail")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var tasks: Tasks {
        Tasks(path: "/tasks")
    }

    public struct Tasks {
        /// Path: `/tasks`
        public let path: String

        /// List tasks
        public func get(filters: String? = nil) -> Request<[DockerEngineAPI.Task]> {
            .get(path, query: makeGetQuery(filters))
        }

        private func makeGetQuery(_ filters: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(filters, forKey: "filters")
            return encoder.items
        }
    }
}

extension Paths.Tasks {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/tasks/{id}`
        public let path: String

        /// Inspect a task
        public var get: Request<DockerEngineAPI.Task> {
            .get(path)
        }
    }
}

extension Paths.Tasks.WithID {
    public var logs: Logs {
        Logs(path: path + "/logs")
    }

    public struct Logs {
        /// Path: `/tasks/{id}/logs`
        public let path: String

        /// Get task logs
        ///
        /// Get `stdout` and `stderr` logs from a task.
        /// 
        /// **Note**: This endpoint works only for services with the `json-file` or `journald` logging drivers.
        public func get(parameters: GetParameters? = nil) -> Request<String> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var isDetails: Bool?
            public var isFollow: Bool?
            public var isStdout: Bool?
            public var isStderr: Bool?
            public var since: Int?
            public var isTimestamps: Bool?
            public var tail: String?

            public init(isDetails: Bool? = nil, isFollow: Bool? = nil, isStdout: Bool? = nil, isStderr: Bool? = nil, since: Int? = nil, isTimestamps: Bool? = nil, tail: String? = nil) {
                self.isDetails = isDetails
                self.isFollow = isFollow
                self.isStdout = isStdout
                self.isStderr = isStderr
                self.since = since
                self.isTimestamps = isTimestamps
                self.tail = tail
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isDetails, forKey: "details")
                encoder.encode(isFollow, forKey: "follow")
                encoder.encode(isStdout, forKey: "stdout")
                encoder.encode(isStderr, forKey: "stderr")
                encoder.encode(since, forKey: "since")
                encoder.encode(isTimestamps, forKey: "timestamps")
                encoder.encode(tail, forKey: "tail")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var secrets: Secrets {
        Secrets(path: "/secrets")
    }

    public struct Secrets {
        /// Path: `/secrets`
        public let path: String

        /// List secrets
        public func get(filters: String? = nil) -> Request<[DockerEngineAPI.Secret]> {
            .get(path, query: makeGetQuery(filters))
        }

        private func makeGetQuery(_ filters: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(filters, forKey: "filters")
            return encoder.items
        }
    }
}

extension Paths.Secrets {
    public var create: Create {
        Create(path: path + "/create")
    }

    public struct Create {
        /// Path: `/secrets/create`
        public let path: String

        /// Create a secret
        public func post(_ body: DockerEngineAPI.SecretSpec? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "ID" : "ktnbjxoalbkvbvedmg1urrz8h"
        /// }
        public struct PostResponse: Decodable {
            /// The ID of the created secret.
            public var id: String?

            public init(id: String? = nil) {
                self.id = id
            }

            private enum CodingKeys: String, CodingKey {
                case id = "ID"
            }
        }
    }
}

extension Paths.Secrets {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/secrets/{id}`
        public let path: String

        /// Inspect a secret
        public var get: Request<DockerEngineAPI.Secret> {
            .get(path)
        }

        /// Delete a secret
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Secrets.WithID {
    public var update: Update {
        Update(path: path + "/update")
    }

    public struct Update {
        /// Path: `/secrets/{id}/update`
        public let path: String

        /// Update a Secret
        public func post(version: Int, _ body: DockerEngineAPI.SecretSpec? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(version), body: body)
        }

        private func makePostQuery(_ version: Int) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(version, forKey: "version")
            return encoder.items
        }
    }
}

extension Paths {
    public static var configs: Configs {
        Configs(path: "/configs")
    }

    public struct Configs {
        /// Path: `/configs`
        public let path: String

        /// List configs
        public func get(filters: String? = nil) -> Request<[DockerEngineAPI.Config]> {
            .get(path, query: makeGetQuery(filters))
        }

        private func makeGetQuery(_ filters: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(filters, forKey: "filters")
            return encoder.items
        }
    }
}

extension Paths.Configs {
    public var create: Create {
        Create(path: path + "/create")
    }

    public struct Create {
        /// Path: `/configs/create`
        public let path: String

        /// Create a config
        public func post(_ body: DockerEngineAPI.ConfigSpec? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "ID" : "ktnbjxoalbkvbvedmg1urrz8h"
        /// }
        public struct PostResponse: Decodable {
            /// The ID of the created config.
            public var id: String?

            public init(id: String? = nil) {
                self.id = id
            }

            private enum CodingKeys: String, CodingKey {
                case id = "ID"
            }
        }
    }
}

extension Paths.Configs {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/configs/{id}`
        public let path: String

        /// Inspect a config
        public var get: Request<DockerEngineAPI.Config> {
            .get(path)
        }

        /// Delete a config
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Configs.WithID {
    public var update: Update {
        Update(path: path + "/update")
    }

    public struct Update {
        /// Path: `/configs/{id}/update`
        public let path: String

        /// Update a Config
        public func post(version: Int, _ body: DockerEngineAPI.ConfigSpec? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(version), body: body)
        }

        private func makePostQuery(_ version: Int) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(version, forKey: "version")
            return encoder.items
        }
    }
}

extension Paths {
    public static var distribution: Distribution {
        Distribution(path: "/distribution")
    }

    public struct Distribution {
        /// Path: `/distribution`
        public let path: String
    }
}

extension Paths.Distribution {
    public func name(_ name: String) -> WithName {
        WithName(path: "\(path)/\(name)")
    }

    public struct WithName {
        /// Path: `/distribution/{name}`
        public let path: String
    }
}

extension Paths.Distribution.WithName {
    public var json: JSON {
        JSON(path: path + "/json")
    }

    public struct JSON {
        /// Path: `/distribution/{name}/json`
        public let path: String

        /// Get image information from the registry
        ///
        /// Return image digest and platform information by contacting the registry.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// A descriptor struct containing digest, media type, and size
            public var descriptor: Descriptor
            /// An array containing all platforms supported by the image
            public var platforms: [Platform]

            /// A descriptor struct containing digest, media type, and size
            public struct Descriptor: Decodable {
                public var mediaType: String?
                public var size: Int?
                public var digest: String?
                public var urls: [String]?

                public init(mediaType: String? = nil, size: Int? = nil, digest: String? = nil, urls: [String]? = nil) {
                    self.mediaType = mediaType
                    self.size = size
                    self.digest = digest
                    self.urls = urls
                }

                private enum CodingKeys: String, CodingKey {
                    case mediaType = "MediaType"
                    case size = "Size"
                    case digest = "Digest"
                    case urls = "URLs"
                }
            }

            public struct Platform: Decodable {
                public var architecture: String?
                public var os: String?
                public var oSVersion: String?
                public var oSFeatures: [String]?
                public var variant: String?
                public var features: [String]?

                public init(architecture: String? = nil, os: String? = nil, oSVersion: String? = nil, oSFeatures: [String]? = nil, variant: String? = nil, features: [String]? = nil) {
                    self.architecture = architecture
                    self.os = os
                    self.oSVersion = oSVersion
                    self.oSFeatures = oSFeatures
                    self.variant = variant
                    self.features = features
                }

                private enum CodingKeys: String, CodingKey {
                    case architecture = "Architecture"
                    case os = "OS"
                    case oSVersion = "OSVersion"
                    case oSFeatures = "OSFeatures"
                    case variant = "Variant"
                    case features = "Features"
                }
            }

            public init(descriptor: Descriptor, platforms: [Platform]) {
                self.descriptor = descriptor
                self.platforms = platforms
            }

            private enum CodingKeys: String, CodingKey {
                case descriptor = "Descriptor"
                case platforms = "Platforms"
            }
        }
    }
}

extension Paths {
    public static var session: Session {
        Session(path: "/session")
    }

    public struct Session {
        /// Path: `/session`
        public let path: String

        /// Initialize interactive session
        ///
        /// Start a new interactive session with a server. Session allows server to call back to the client for advanced capabilities.
        /// 
        /// > **Note**: This endpoint is *experimental* and only available if the daemon is started with experimental
        /// > features enabled. The specifications for this endpoint may still change in a future version of the API.
        /// 
        /// ### Hijacking
        /// 
        /// This endpoint hijacks the HTTP connection to HTTP2 transport that allows the client to expose gPRC services on that connection.
        /// 
        /// For example, the client sends this request to upgrade the connection:
        /// 
        /// ```
        /// POST /session HTTP/1.1
        /// Upgrade: h2c
        /// Connection: Upgrade
        /// ```
        /// 
        /// The Docker daemon will respond with a `101 UPGRADED` response follow with the raw stream:
        /// 
        /// ```
        /// HTTP/1.1 101 UPGRADED
        /// Connection: Upgrade
        /// Upgrade: h2c
        /// ```
        public var post: Request<Void> {
            .post(path)
        }
    }
}

public enum Paths {}
