// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

public struct InstallStatus: Codable {
    public var status: Status?

    public struct Status: Codable {
        public var isFinished: Bool?
        public var itemCount: Int?

        public init(isFinished: Bool? = nil, itemCount: Int? = nil) {
            self.isFinished = isFinished
            self.itemCount = itemCount
        }

        private enum CodingKeys: String, CodingKey {
            case isFinished = "finished"
            case itemCount
        }
    }

    public init(status: Status? = nil) {
        self.status = status
    }
}

public struct KeystoreInfo: Codable {
    public var aliases: [KeystoreItems]?
    /// False if truststore don't exist
    public var isExists: Bool?

    public init(aliases: [KeystoreItems]? = nil, isExists: Bool? = nil) {
        self.aliases = aliases
        self.isExists = isExists
    }

    private enum CodingKeys: String, CodingKey {
        case aliases
        case isExists = "exists"
    }
}

public struct TruststoreInfo: Codable {
    public var aliases: [TruststoreItems]?
    /// False if truststore don't exist
    public var isExists: Bool?

    public init(aliases: [TruststoreItems]? = nil, isExists: Bool? = nil) {
        self.aliases = aliases
        self.isExists = isExists
    }

    private enum CodingKeys: String, CodingKey {
        case aliases
        case isExists = "exists"
    }
}

public struct KeystoreItems: Codable {
    /// Keystore alias name
    public var alias: String?
    /// E.g. "privateKey"
    public var entryType: String?
    /// E.g. "RSA"
    public var algorithm: String?
    /// E.g. "PKCS#8"
    public var format: String?
    public var chain: [KeystoreChainItems]?

    public init(alias: String? = nil, entryType: String? = nil, algorithm: String? = nil, format: String? = nil, chain: [KeystoreChainItems]? = nil) {
        self.alias = alias
        self.entryType = entryType
        self.algorithm = algorithm
        self.format = format
        self.chain = chain
    }
}

public struct KeystoreChainItems: Codable {
    /// E.g. "CN=localhost"
    public var subject: String?
    /// E.g. "CN=Admin"
    public var issuer: String?
    /// E.g. "Sun Jul 01 12:00:00 AEST 2018"
    public var notBefore: String?
    /// E.g. "Sun Jun 30 23:59:50 AEST 2019"
    public var notAfter: String?
    /// 18165099476682912368
    public var serialNumber: Int?

    public init(subject: String? = nil, issuer: String? = nil, notBefore: String? = nil, notAfter: String? = nil, serialNumber: Int? = nil) {
        self.subject = subject
        self.issuer = issuer
        self.notBefore = notBefore
        self.notAfter = notAfter
        self.serialNumber = serialNumber
    }
}

public struct TruststoreItems: Codable {
    /// Truststore alias name
    public var alias: String?
    public var entryType: String?
    /// E.g. "CN=localhost"
    public var subject: String?
    /// E.g. "CN=Admin"
    public var issuer: String?
    /// E.g. "Sun Jul 01 12:00:00 AEST 2018"
    public var notBefore: String?
    /// E.g. "Sun Jun 30 23:59:50 AEST 2019"
    public var notAfter: String?
    /// 18165099476682912368
    public var serialNumber: Int?

    public init(alias: String? = nil, entryType: String? = nil, subject: String? = nil, issuer: String? = nil, notBefore: String? = nil, notAfter: String? = nil, serialNumber: Int? = nil) {
        self.alias = alias
        self.entryType = entryType
        self.subject = subject
        self.issuer = issuer
        self.notBefore = notBefore
        self.notAfter = notAfter
        self.serialNumber = serialNumber
    }
}

public struct SamlConfigurationInfo: Codable {
    /// Persistent Identity (PID)
    public var pid: String?
    /// Title
    public var title: String?
    /// Title
    public var description: String?
    /// Needed for configuration binding
    public var bundleLocation: String?
    /// Needed for configuraiton binding
    public var serviceLocation: String?
    public var properties: SamlConfigurationProperties?

    public init(pid: String? = nil, title: String? = nil, description: String? = nil, bundleLocation: String? = nil, serviceLocation: String? = nil, properties: SamlConfigurationProperties? = nil) {
        self.pid = pid
        self.title = title
        self.description = description
        self.bundleLocation = bundleLocation
        self.serviceLocation = serviceLocation
        self.properties = properties
    }

    private enum CodingKeys: String, CodingKey {
        case pid
        case title
        case description
        case bundleLocation = "bundle_location"
        case serviceLocation = "service_location"
        case properties
    }
}

public struct SamlConfigurationProperties: Codable {
    public var path: SamlConfigurationPropertyItemsArray?
    public var serviceRanking: SamlConfigurationPropertyItemsLong?
    public var idpURL: SamlConfigurationPropertyItemsString?
    public var idpCertAlias: SamlConfigurationPropertyItemsString?
    public var idpHTTPRedirect: SamlConfigurationPropertyItemsBoolean?
    public var serviceProviderEntityID: SamlConfigurationPropertyItemsString?
    public var assertionConsumerServiceURL: SamlConfigurationPropertyItemsString?
    public var spPrivateKeyAlias: SamlConfigurationPropertyItemsString?
    public var keyStorePassword: SamlConfigurationPropertyItemsString?
    public var defaultRedirectURL: SamlConfigurationPropertyItemsString?
    public var userIDAttribute: SamlConfigurationPropertyItemsString?
    public var useEncryption: SamlConfigurationPropertyItemsBoolean?
    public var createUser: SamlConfigurationPropertyItemsBoolean?
    public var addGroupMemberships: SamlConfigurationPropertyItemsBoolean?
    public var groupMembershipAttribute: SamlConfigurationPropertyItemsString?
    public var defaultGroups: SamlConfigurationPropertyItemsArray?
    public var nameIDFormat: SamlConfigurationPropertyItemsString?
    public var synchronizeAttributes: SamlConfigurationPropertyItemsArray?
    public var handleLogout: SamlConfigurationPropertyItemsBoolean?
    public var logoutURL: SamlConfigurationPropertyItemsString?
    public var clockTolerance: SamlConfigurationPropertyItemsLong?
    public var digestMethod: SamlConfigurationPropertyItemsString?
    public var signatureMethod: SamlConfigurationPropertyItemsString?
    public var userIntermediatePath: SamlConfigurationPropertyItemsString?

    public init(path: SamlConfigurationPropertyItemsArray? = nil, serviceRanking: SamlConfigurationPropertyItemsLong? = nil, idpURL: SamlConfigurationPropertyItemsString? = nil, idpCertAlias: SamlConfigurationPropertyItemsString? = nil, idpHTTPRedirect: SamlConfigurationPropertyItemsBoolean? = nil, serviceProviderEntityID: SamlConfigurationPropertyItemsString? = nil, assertionConsumerServiceURL: SamlConfigurationPropertyItemsString? = nil, spPrivateKeyAlias: SamlConfigurationPropertyItemsString? = nil, keyStorePassword: SamlConfigurationPropertyItemsString? = nil, defaultRedirectURL: SamlConfigurationPropertyItemsString? = nil, userIDAttribute: SamlConfigurationPropertyItemsString? = nil, useEncryption: SamlConfigurationPropertyItemsBoolean? = nil, createUser: SamlConfigurationPropertyItemsBoolean? = nil, addGroupMemberships: SamlConfigurationPropertyItemsBoolean? = nil, groupMembershipAttribute: SamlConfigurationPropertyItemsString? = nil, defaultGroups: SamlConfigurationPropertyItemsArray? = nil, nameIDFormat: SamlConfigurationPropertyItemsString? = nil, synchronizeAttributes: SamlConfigurationPropertyItemsArray? = nil, handleLogout: SamlConfigurationPropertyItemsBoolean? = nil, logoutURL: SamlConfigurationPropertyItemsString? = nil, clockTolerance: SamlConfigurationPropertyItemsLong? = nil, digestMethod: SamlConfigurationPropertyItemsString? = nil, signatureMethod: SamlConfigurationPropertyItemsString? = nil, userIntermediatePath: SamlConfigurationPropertyItemsString? = nil) {
        self.path = path
        self.serviceRanking = serviceRanking
        self.idpURL = idpURL
        self.idpCertAlias = idpCertAlias
        self.idpHTTPRedirect = idpHTTPRedirect
        self.serviceProviderEntityID = serviceProviderEntityID
        self.assertionConsumerServiceURL = assertionConsumerServiceURL
        self.spPrivateKeyAlias = spPrivateKeyAlias
        self.keyStorePassword = keyStorePassword
        self.defaultRedirectURL = defaultRedirectURL
        self.userIDAttribute = userIDAttribute
        self.useEncryption = useEncryption
        self.createUser = createUser
        self.addGroupMemberships = addGroupMemberships
        self.groupMembershipAttribute = groupMembershipAttribute
        self.defaultGroups = defaultGroups
        self.nameIDFormat = nameIDFormat
        self.synchronizeAttributes = synchronizeAttributes
        self.handleLogout = handleLogout
        self.logoutURL = logoutURL
        self.clockTolerance = clockTolerance
        self.digestMethod = digestMethod
        self.signatureMethod = signatureMethod
        self.userIntermediatePath = userIntermediatePath
    }

    private enum CodingKeys: String, CodingKey {
        case path
        case serviceRanking = "service.ranking"
        case idpURL = "idpUrl"
        case idpCertAlias
        case idpHTTPRedirect = "idpHttpRedirect"
        case serviceProviderEntityID = "serviceProviderEntityId"
        case assertionConsumerServiceURL
        case spPrivateKeyAlias
        case keyStorePassword
        case defaultRedirectURL = "defaultRedirectUrl"
        case userIDAttribute
        case useEncryption
        case createUser
        case addGroupMemberships
        case groupMembershipAttribute
        case defaultGroups
        case nameIDFormat = "nameIdFormat"
        case synchronizeAttributes
        case handleLogout
        case logoutURL = "logoutUrl"
        case clockTolerance
        case digestMethod
        case signatureMethod
        case userIntermediatePath
    }
}

public struct SamlConfigurationPropertyItemsArray: Codable {
    /// Property name
    public var name: String?
    /// True if optional
    public var isOptional: Bool?
    /// True if property is set
    public var isSet: Bool?
    /// Property type, 1=String, 3=long, 11=boolean, 12=Password
    public var type: Int?
    /// Property value
    public var values: [String]?
    /// Property description
    public var description: String?

    public init(name: String? = nil, isOptional: Bool? = nil, isSet: Bool? = nil, type: Int? = nil, values: [String]? = nil, description: String? = nil) {
        self.name = name
        self.isOptional = isOptional
        self.isSet = isSet
        self.type = type
        self.values = values
        self.description = description
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case isOptional = "optional"
        case isSet = "is_set"
        case type
        case values
        case description
    }
}

public struct SamlConfigurationPropertyItemsBoolean: Codable {
    /// Property name
    public var name: String?
    /// True if optional
    public var isOptional: Bool?
    /// True if property is set
    public var isSet: Bool?
    /// Property type, 1=String, 3=long, 11=boolean, 12=Password
    public var type: Int?
    /// Property value
    public var isValue: Bool?
    /// Property description
    public var description: String?

    public init(name: String? = nil, isOptional: Bool? = nil, isSet: Bool? = nil, type: Int? = nil, isValue: Bool? = nil, description: String? = nil) {
        self.name = name
        self.isOptional = isOptional
        self.isSet = isSet
        self.type = type
        self.isValue = isValue
        self.description = description
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case isOptional = "optional"
        case isSet = "is_set"
        case type
        case isValue = "value"
        case description
    }
}

public struct SamlConfigurationPropertyItemsLong: Codable {
    /// Property name
    public var name: String?
    /// True if optional
    public var isOptional: Bool?
    /// True if property is set
    public var isSet: Bool?
    /// Property type, 1=String, 3=long, 11=boolean, 12=Password
    public var type: Int?
    /// Property value
    public var value: Int?
    /// Property description
    public var description: String?

    public init(name: String? = nil, isOptional: Bool? = nil, isSet: Bool? = nil, type: Int? = nil, value: Int? = nil, description: String? = nil) {
        self.name = name
        self.isOptional = isOptional
        self.isSet = isSet
        self.type = type
        self.value = value
        self.description = description
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case isOptional = "optional"
        case isSet = "is_set"
        case type
        case value
        case description
    }
}

public struct SamlConfigurationPropertyItemsString: Codable {
    /// Property name
    public var name: String?
    /// True if optional
    public var isOptional: Bool?
    /// True if property is set
    public var isSet: Bool?
    /// Property type, 1=String, 3=long, 11=boolean, 12=Password
    public var type: Int?
    /// Property value
    public var value: String?
    /// Property description
    public var description: String?

    public init(name: String? = nil, isOptional: Bool? = nil, isSet: Bool? = nil, type: Int? = nil, value: String? = nil, description: String? = nil) {
        self.name = name
        self.isOptional = isOptional
        self.isSet = isSet
        self.type = type
        self.value = value
        self.description = description
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case isOptional = "optional"
        case isSet = "is_set"
        case type
        case value
        case description
    }
}

public struct BundleInfo: Codable {
    /// Status description of all bundles
    public var status: String?
    public var s: [Int]?
    public var data: [BundleData]?

    public init(status: String? = nil, s: [Int]? = nil, data: [BundleData]? = nil) {
        self.status = status
        self.s = s
        self.data = data
    }
}

public struct BundleData: Codable {
    /// Bundle ID
    public var id: Int?
    /// Bundle name
    public var name: String?
    /// Is bundle a fragment
    public var isFragment: Bool?
    /// Numeric raw bundle state value
    public var stateRaw: Int?
    /// Bundle state value
    public var state: String?
    /// Bundle version
    public var version: String?
    /// Bundle symbolic name
    public var symbolicName: String?
    /// Bundle category
    public var category: String?
    public var props: [BundleDataProp]?

    public init(id: Int? = nil, name: String? = nil, isFragment: Bool? = nil, stateRaw: Int? = nil, state: String? = nil, version: String? = nil, symbolicName: String? = nil, category: String? = nil, props: [BundleDataProp]? = nil) {
        self.id = id
        self.name = name
        self.isFragment = isFragment
        self.stateRaw = stateRaw
        self.state = state
        self.version = version
        self.symbolicName = symbolicName
        self.category = category
        self.props = props
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case isFragment = "fragment"
        case stateRaw
        case state
        case version
        case symbolicName
        case category
        case props
    }
}

public struct BundleDataProp: Codable {
    /// Bundle data key
    public var key: String?
    /// Bundle data value
    public var value: String?

    public init(key: String? = nil, value: String? = nil) {
        self.key = key
        self.value = value
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
