// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var system: System {
        System(path: "/system")
    }

    public struct System {
        /// Path: `/system`
        public let path: String
    }
}

extension Paths.System {
    public var console: Console {
        Console(path: path + "/console")
    }

    public struct Console {
        /// Path: `/system/console`
        public let path: String
    }
}

extension Paths.System.Console {
    public var configMgr: ConfigMgr {
        ConfigMgr(path: path + "/configMgr")
    }

    public struct ConfigMgr {
        /// Path: `/system/console/configMgr`
        public let path: String

        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths {
    public static var libs: Libs {
        Libs(path: "/libs")
    }

    public struct Libs {
        /// Path: `/libs`
        public let path: String
    }
}

extension Paths.Libs {
    public var granite: Granite {
        Granite(path: path + "/granite")
    }

    public struct Granite {
        /// Path: `/libs/granite`
        public let path: String
    }
}

extension Paths.Libs.Granite {
    public var core: Core {
        Core(path: path + "/core")
    }

    public struct Core {
        /// Path: `/libs/granite/core`
        public let path: String
    }
}

extension Paths.Libs.Granite.Core {
    public var content: Content {
        Content(path: path + "/content")
    }

    public struct Content {
        /// Path: `/libs/granite/core/content`
        public let path: String
    }
}

extension Paths.Libs.Granite.Core.Content {
    public var loginHTML: LoginHTML {
        LoginHTML(path: path + "/login.html")
    }

    public struct LoginHTML {
        /// Path: `/libs/granite/core/content/login.html`
        public let path: String

        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths {
    public static var cqactionsHTML: CqactionsHTML {
        CqactionsHTML(path: "/.cqactions.html")
    }

    public struct CqactionsHTML {
        /// Path: `/.cqactions.html`
        public let path: String

        public func post(authorizableID: String, changelog: String) -> Request<Void> {
            .post(path, query: [("authorizableId", authorizableID), ("changelog", changelog)])
        }
    }
}

extension Paths {
    public static func path(_ path: String) -> WithPath {
        WithPath(path: "/\(path)")
    }

    public struct WithPath {
        /// Path: `/{path}`
        public let path: String

        public func post(jcrPrimaryType: String, name: String) -> Request<Void> {
            .post(path, query: [("jcr:primaryType", jcrPrimaryType), (":name", name)])
        }
    }
}

extension Paths.WithPath {
    public func name(_ name: String) -> WithName {
        WithName(path: "\(path)/\(name)")
    }

    public struct WithName {
        /// Path: `/{path}/{name}`
        public let path: String

        public var get: Request<Void> {
            .get(path)
        }

        public func post(operation: String? = nil, deleteAuthorizable: String? = nil, _ body: Data? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(operation, deleteAuthorizable), body: body)
        }

        private func makePostQuery(_ operation: String?, _ deleteAuthorizable: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(operation, forKey: ":operation")
            encoder.encode(deleteAuthorizable, forKey: "deleteAuthorizable")
            return encoder.items
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.WithPath {
    public func name(_ name: String) -> WithRwHTML {
        WithRwHTML(path: "\(path)/\(name).rw.html")
    }

    public struct WithRwHTML {
        /// Path: `/{path}/{name}.rw.html`
        public let path: String

        public func post(addMembers: String? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(addMembers))
        }

        private func makePostQuery(_ addMembers: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(addMembers, forKey: "addMembers")
            return encoder.items
        }
    }
}

extension Paths {
    public static var apps: Apps {
        Apps(path: "/apps")
    }

    public struct Apps {
        /// Path: `/apps`
        public let path: String
    }
}

extension Paths.Apps {
    public var system: System {
        System(path: path + "/system")
    }

    public struct System {
        /// Path: `/apps/system`
        public let path: String
    }
}

extension Paths.Apps.System {
    public var config: Config {
        Config(path: path + "/config")
    }

    public struct Config {
        /// Path: `/apps/system/config`
        public let path: String
    }
}

extension Paths.Apps.System.Config {
    public func configNodeName(_ configNodeName: String) -> WithConfigNodeName {
        WithConfigNodeName(path: "\(path)/\(configNodeName)")
    }

    public struct WithConfigNodeName {
        /// Path: `/apps/system/config/{configNodeName}`
        public let path: String

        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Apps.System.Config {
    public var orgApacheFelixHTTP: OrgApacheFelixHTTP {
        OrgApacheFelixHTTP(path: path + "/org.apache.felix.http")
    }

    public struct OrgApacheFelixHTTP {
        /// Path: `/apps/system/config/org.apache.felix.http`
        public let path: String

        public func post(parameters: PostParameters? = nil) -> Request<Void> {
            .post(path, query: parameters?.asQuery)
        }

        public struct PostParameters {
            public var isOrgApacheFelixHTTPSNio: Bool?
            public var orgApacheFelixHTTPSNioTypeHint: String?
            public var orgApacheFelixHTTPSKeystore: String?
            public var orgApacheFelixHTTPSKeystoreTypeHint: String?
            public var orgApacheFelixHTTPSKeystorePassword: String?
            public var orgApacheFelixHTTPSKeystorePasswordTypeHint: String?
            public var orgApacheFelixHTTPSKeystoreKey: String?
            public var orgApacheFelixHTTPSKeystoreKeyTypeHint: String?
            public var orgApacheFelixHTTPSKeystoreKeyPassword: String?
            public var orgApacheFelixHTTPSKeystoreKeyPasswordTypeHint: String?
            public var orgApacheFelixHTTPSTruststore: String?
            public var orgApacheFelixHTTPSTruststoreTypeHint: String?
            public var orgApacheFelixHTTPSTruststorePassword: String?
            public var orgApacheFelixHTTPSTruststorePasswordTypeHint: String?
            public var orgApacheFelixHTTPSClientcertificate: String?
            public var orgApacheFelixHTTPSClientcertificateTypeHint: String?
            public var orgApacheFelixHTTPSEnable: Bool?
            public var orgApacheFelixHTTPSEnableTypeHint: String?
            public var orgOsgiServiceHTTPPortSecure: String?
            public var orgOsgiServiceHTTPPortSecureTypeHint: String?

            public init(isOrgApacheFelixHTTPSNio: Bool? = nil, orgApacheFelixHTTPSNioTypeHint: String? = nil, orgApacheFelixHTTPSKeystore: String? = nil, orgApacheFelixHTTPSKeystoreTypeHint: String? = nil, orgApacheFelixHTTPSKeystorePassword: String? = nil, orgApacheFelixHTTPSKeystorePasswordTypeHint: String? = nil, orgApacheFelixHTTPSKeystoreKey: String? = nil, orgApacheFelixHTTPSKeystoreKeyTypeHint: String? = nil, orgApacheFelixHTTPSKeystoreKeyPassword: String? = nil, orgApacheFelixHTTPSKeystoreKeyPasswordTypeHint: String? = nil, orgApacheFelixHTTPSTruststore: String? = nil, orgApacheFelixHTTPSTruststoreTypeHint: String? = nil, orgApacheFelixHTTPSTruststorePassword: String? = nil, orgApacheFelixHTTPSTruststorePasswordTypeHint: String? = nil, orgApacheFelixHTTPSClientcertificate: String? = nil, orgApacheFelixHTTPSClientcertificateTypeHint: String? = nil, orgApacheFelixHTTPSEnable: Bool? = nil, orgApacheFelixHTTPSEnableTypeHint: String? = nil, orgOsgiServiceHTTPPortSecure: String? = nil, orgOsgiServiceHTTPPortSecureTypeHint: String? = nil) {
                self.isOrgApacheFelixHTTPSNio = isOrgApacheFelixHTTPSNio
                self.orgApacheFelixHTTPSNioTypeHint = orgApacheFelixHTTPSNioTypeHint
                self.orgApacheFelixHTTPSKeystore = orgApacheFelixHTTPSKeystore
                self.orgApacheFelixHTTPSKeystoreTypeHint = orgApacheFelixHTTPSKeystoreTypeHint
                self.orgApacheFelixHTTPSKeystorePassword = orgApacheFelixHTTPSKeystorePassword
                self.orgApacheFelixHTTPSKeystorePasswordTypeHint = orgApacheFelixHTTPSKeystorePasswordTypeHint
                self.orgApacheFelixHTTPSKeystoreKey = orgApacheFelixHTTPSKeystoreKey
                self.orgApacheFelixHTTPSKeystoreKeyTypeHint = orgApacheFelixHTTPSKeystoreKeyTypeHint
                self.orgApacheFelixHTTPSKeystoreKeyPassword = orgApacheFelixHTTPSKeystoreKeyPassword
                self.orgApacheFelixHTTPSKeystoreKeyPasswordTypeHint = orgApacheFelixHTTPSKeystoreKeyPasswordTypeHint
                self.orgApacheFelixHTTPSTruststore = orgApacheFelixHTTPSTruststore
                self.orgApacheFelixHTTPSTruststoreTypeHint = orgApacheFelixHTTPSTruststoreTypeHint
                self.orgApacheFelixHTTPSTruststorePassword = orgApacheFelixHTTPSTruststorePassword
                self.orgApacheFelixHTTPSTruststorePasswordTypeHint = orgApacheFelixHTTPSTruststorePasswordTypeHint
                self.orgApacheFelixHTTPSClientcertificate = orgApacheFelixHTTPSClientcertificate
                self.orgApacheFelixHTTPSClientcertificateTypeHint = orgApacheFelixHTTPSClientcertificateTypeHint
                self.orgApacheFelixHTTPSEnable = orgApacheFelixHTTPSEnable
                self.orgApacheFelixHTTPSEnableTypeHint = orgApacheFelixHTTPSEnableTypeHint
                self.orgOsgiServiceHTTPPortSecure = orgOsgiServiceHTTPPortSecure
                self.orgOsgiServiceHTTPPortSecureTypeHint = orgOsgiServiceHTTPPortSecureTypeHint
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isOrgApacheFelixHTTPSNio, forKey: "org.apache.felix.https.nio")
                encoder.encode(orgApacheFelixHTTPSNioTypeHint, forKey: "org.apache.felix.https.nio@TypeHint")
                encoder.encode(orgApacheFelixHTTPSKeystore, forKey: "org.apache.felix.https.keystore")
                encoder.encode(orgApacheFelixHTTPSKeystoreTypeHint, forKey: "org.apache.felix.https.keystore@TypeHint")
                encoder.encode(orgApacheFelixHTTPSKeystorePassword, forKey: "org.apache.felix.https.keystore.password")
                encoder.encode(orgApacheFelixHTTPSKeystorePasswordTypeHint, forKey: "org.apache.felix.https.keystore.password@TypeHint")
                encoder.encode(orgApacheFelixHTTPSKeystoreKey, forKey: "org.apache.felix.https.keystore.key")
                encoder.encode(orgApacheFelixHTTPSKeystoreKeyTypeHint, forKey: "org.apache.felix.https.keystore.key@TypeHint")
                encoder.encode(orgApacheFelixHTTPSKeystoreKeyPassword, forKey: "org.apache.felix.https.keystore.key.password")
                encoder.encode(orgApacheFelixHTTPSKeystoreKeyPasswordTypeHint, forKey: "org.apache.felix.https.keystore.key.password@TypeHint")
                encoder.encode(orgApacheFelixHTTPSTruststore, forKey: "org.apache.felix.https.truststore")
                encoder.encode(orgApacheFelixHTTPSTruststoreTypeHint, forKey: "org.apache.felix.https.truststore@TypeHint")
                encoder.encode(orgApacheFelixHTTPSTruststorePassword, forKey: "org.apache.felix.https.truststore.password")
                encoder.encode(orgApacheFelixHTTPSTruststorePasswordTypeHint, forKey: "org.apache.felix.https.truststore.password@TypeHint")
                encoder.encode(orgApacheFelixHTTPSClientcertificate, forKey: "org.apache.felix.https.clientcertificate")
                encoder.encode(orgApacheFelixHTTPSClientcertificateTypeHint, forKey: "org.apache.felix.https.clientcertificate@TypeHint")
                encoder.encode(orgApacheFelixHTTPSEnable, forKey: "org.apache.felix.https.enable")
                encoder.encode(orgApacheFelixHTTPSEnableTypeHint, forKey: "org.apache.felix.https.enable@TypeHint")
                encoder.encode(orgOsgiServiceHTTPPortSecure, forKey: "org.osgi.service.http.port.secure")
                encoder.encode(orgOsgiServiceHTTPPortSecureTypeHint, forKey: "org.osgi.service.http.port.secure@TypeHint")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.System.Config {
    public var orgApacheSlingServletsGetDefaultGetServlet: OrgApacheSlingServletsGetDefaultGetServlet {
        OrgApacheSlingServletsGetDefaultGetServlet(path: path + "/org.apache.sling.servlets.get.DefaultGetServlet")
    }

    public struct OrgApacheSlingServletsGetDefaultGetServlet {
        /// Path: `/apps/system/config/org.apache.sling.servlets.get.DefaultGetServlet`
        public let path: String

        public func post(parameters: PostParameters? = nil) -> Request<Void> {
            .post(path, query: parameters?.asQuery)
        }

        public struct PostParameters {
            public var jsonMaximumresults: String?
            public var jsonMaximumresultsTypeHint: String?
            public var enableHTML: Bool?
            public var enableHTMLTypeHint: String?
            public var enableTxt: Bool?
            public var enableTxtTypeHint: String?
            public var enableXml: Bool?
            public var enableXmlTypeHint: String?

            public init(jsonMaximumresults: String? = nil, jsonMaximumresultsTypeHint: String? = nil, enableHTML: Bool? = nil, enableHTMLTypeHint: String? = nil, enableTxt: Bool? = nil, enableTxtTypeHint: String? = nil, enableXml: Bool? = nil, enableXmlTypeHint: String? = nil) {
                self.jsonMaximumresults = jsonMaximumresults
                self.jsonMaximumresultsTypeHint = jsonMaximumresultsTypeHint
                self.enableHTML = enableHTML
                self.enableHTMLTypeHint = enableHTMLTypeHint
                self.enableTxt = enableTxt
                self.enableTxtTypeHint = enableTxtTypeHint
                self.enableXml = enableXml
                self.enableXmlTypeHint = enableXmlTypeHint
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(jsonMaximumresults, forKey: "json.maximumresults")
                encoder.encode(jsonMaximumresultsTypeHint, forKey: "json.maximumresults@TypeHint")
                encoder.encode(enableHTML, forKey: "enable.html")
                encoder.encode(enableHTMLTypeHint, forKey: "enable.html@TypeHint")
                encoder.encode(enableTxt, forKey: "enable.txt")
                encoder.encode(enableTxtTypeHint, forKey: "enable.txt@TypeHint")
                encoder.encode(enableXml, forKey: "enable.xml")
                encoder.encode(enableXmlTypeHint, forKey: "enable.xml@TypeHint")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.System.Config {
    public var orgApacheSlingSecurityImplReferrerFilter: OrgApacheSlingSecurityImplReferrerFilter {
        OrgApacheSlingSecurityImplReferrerFilter(path: path + "/org.apache.sling.security.impl.ReferrerFilter")
    }

    public struct OrgApacheSlingSecurityImplReferrerFilter {
        /// Path: `/apps/system/config/org.apache.sling.security.impl.ReferrerFilter`
        public let path: String

        public func post(parameters: PostParameters? = nil) -> Request<Void> {
            .post(path, query: parameters?.asQuery)
        }

        public struct PostParameters {
            public var allowEmpty: Bool?
            public var allowEmptyTypeHint: String?
            public var allowHosts: String?
            public var allowHostsTypeHint: String?
            public var allowHostsRegexp: String?
            public var allowHostsRegexpTypeHint: String?
            public var filterMethods: String?
            public var filterMethodsTypeHint: String?

            public init(allowEmpty: Bool? = nil, allowEmptyTypeHint: String? = nil, allowHosts: String? = nil, allowHostsTypeHint: String? = nil, allowHostsRegexp: String? = nil, allowHostsRegexpTypeHint: String? = nil, filterMethods: String? = nil, filterMethodsTypeHint: String? = nil) {
                self.allowEmpty = allowEmpty
                self.allowEmptyTypeHint = allowEmptyTypeHint
                self.allowHosts = allowHosts
                self.allowHostsTypeHint = allowHostsTypeHint
                self.allowHostsRegexp = allowHostsRegexp
                self.allowHostsRegexpTypeHint = allowHostsRegexpTypeHint
                self.filterMethods = filterMethods
                self.filterMethodsTypeHint = filterMethodsTypeHint
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(allowEmpty, forKey: "allow.empty")
                encoder.encode(allowEmptyTypeHint, forKey: "allow.empty@TypeHint")
                encoder.encode(allowHosts, forKey: "allow.hosts")
                encoder.encode(allowHostsTypeHint, forKey: "allow.hosts@TypeHint")
                encoder.encode(allowHostsRegexp, forKey: "allow.hosts.regexp")
                encoder.encode(allowHostsRegexpTypeHint, forKey: "allow.hosts.regexp@TypeHint")
                encoder.encode(filterMethods, forKey: "filter.methods")
                encoder.encode(filterMethodsTypeHint, forKey: "filter.methods@TypeHint")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.System.Config {
    public var orgApacheSlingJcrDavexImplServletsSlingDavExServlet: OrgApacheSlingJcrDavexImplServletsSlingDavExServlet {
        OrgApacheSlingJcrDavexImplServletsSlingDavExServlet(path: path + "/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet")
    }

    public struct OrgApacheSlingJcrDavexImplServletsSlingDavExServlet {
        /// Path: `/apps/system/config/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet`
        public let path: String

        public func post(parameters: PostParameters? = nil) -> Request<Void> {
            .post(path, query: parameters?.asQuery)
        }

        public struct PostParameters {
            public var alias: String?
            public var aliasTypeHint: String?
            public var isDavCreateAbsoluteUri: Bool?
            public var davCreateAbsoluteUriTypeHint: String?

            public init(alias: String? = nil, aliasTypeHint: String? = nil, isDavCreateAbsoluteUri: Bool? = nil, davCreateAbsoluteUriTypeHint: String? = nil) {
                self.alias = alias
                self.aliasTypeHint = aliasTypeHint
                self.isDavCreateAbsoluteUri = isDavCreateAbsoluteUri
                self.davCreateAbsoluteUriTypeHint = davCreateAbsoluteUriTypeHint
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(alias, forKey: "alias")
                encoder.encode(aliasTypeHint, forKey: "alias@TypeHint")
                encoder.encode(isDavCreateAbsoluteUri, forKey: "dav.create-absolute-uri")
                encoder.encode(davCreateAbsoluteUriTypeHint, forKey: "dav.create-absolute-uri@TypeHint")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.System.Config {
    public var comShinesolutionsAemPasswordresetActivator: ComShinesolutionsAemPasswordresetActivator {
        ComShinesolutionsAemPasswordresetActivator(path: path + "/com.shinesolutions.aem.passwordreset.Activator")
    }

    public struct ComShinesolutionsAemPasswordresetActivator {
        /// Path: `/apps/system/config/com.shinesolutions.aem.passwordreset.Activator`
        public let path: String

        public func post(pwdresetAuthorizables: [String]? = nil, pwdresetAuthorizablesTypeHint: String? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(pwdresetAuthorizables, pwdresetAuthorizablesTypeHint))
        }

        private func makePostQuery(_ pwdresetAuthorizables: [String]?, _ pwdresetAuthorizablesTypeHint: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(pwdresetAuthorizables, forKey: "pwdreset.authorizables")
            encoder.encode(pwdresetAuthorizablesTypeHint, forKey: "pwdreset.authorizables@TypeHint")
            return encoder.items
        }
    }
}

extension Paths.Apps.System.Config {
    public var comShinesolutionsHealthcheckHcImplActiveBundleHealthCheck: ComShinesolutionsHealthcheckHcImplActiveBundleHealthCheck {
        ComShinesolutionsHealthcheckHcImplActiveBundleHealthCheck(path: path + "/com.shinesolutions.healthcheck.hc.impl.ActiveBundleHealthCheck")
    }

    public struct ComShinesolutionsHealthcheckHcImplActiveBundleHealthCheck {
        /// Path: `/apps/system/config/com.shinesolutions.healthcheck.hc.impl.ActiveBundleHealthCheck`
        public let path: String

        public func post(bundlesIgnored: [String]? = nil, bundlesIgnoredTypeHint: String? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(bundlesIgnored, bundlesIgnoredTypeHint))
        }

        private func makePostQuery(_ bundlesIgnored: [String]?, _ bundlesIgnoredTypeHint: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(bundlesIgnored, forKey: "bundles.ignored")
            encoder.encode(bundlesIgnoredTypeHint, forKey: "bundles.ignored@TypeHint")
            return encoder.items
        }
    }
}

extension Paths {
    public static var bin: Bin {
        Bin(path: "/bin")
    }

    public struct Bin {
        /// Path: `/bin`
        public let path: String
    }
}

extension Paths.Bin {
    public var querybuilderJSON: QuerybuilderJSON {
        QuerybuilderJSON(path: path + "/querybuilder.json")
    }

    public struct QuerybuilderJSON {
        /// Path: `/bin/querybuilder.json`
        public let path: String

        public func get(parameters: GetParameters) -> Request<String> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var path: String
            public var pLimit: Double
            public var _1Property: String
            public var _1PropertyValue: String

            public init(path: String, pLimit: Double, _1Property: String, _1PropertyValue: String) {
                self.path = path
                self.pLimit = pLimit
                self._1Property = _1Property
                self._1PropertyValue = _1PropertyValue
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(path, forKey: "path")
                encoder.encode(pLimit, forKey: "p.limit")
                encoder.encode(_1Property, forKey: "1_property")
                encoder.encode(_1PropertyValue, forKey: "1_property.value")
                return encoder.items
            }
        }

        public func post(parameters: PostParameters) -> Request<String> {
            .post(path, query: parameters.asQuery)
        }

        public struct PostParameters {
            public var path: String
            public var pLimit: Double
            public var _1Property: String
            public var _1PropertyValue: String

            public init(path: String, pLimit: Double, _1Property: String, _1PropertyValue: String) {
                self.path = path
                self.pLimit = pLimit
                self._1Property = _1Property
                self._1PropertyValue = _1PropertyValue
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(path, forKey: "path")
                encoder.encode(pLimit, forKey: "p.limit")
                encoder.encode(_1Property, forKey: "1_property")
                encoder.encode(_1PropertyValue, forKey: "1_property.value")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var etc: Etc {
        Etc(path: "/etc")
    }

    public struct Etc {
        /// Path: `/etc`
        public let path: String
    }
}

extension Paths.Etc {
    public var packages: Packages {
        Packages(path: path + "/packages")
    }

    public struct Packages {
        /// Path: `/etc/packages`
        public let path: String
    }
}

extension Paths.Etc.Packages {
    public func group(_ group: String) -> WithGroup {
        WithGroup(path: "\(path)/\(group)")
    }

    public struct WithGroup {
        /// Path: `/etc/packages/{group}`
        public let path: String
    }
}

extension Paths.Etc.Packages.WithGroup {
    public func name(_ name: String) -> WithMinusVersionZip {
        WithMinusVersionZip(path: "\(path)/\(name)-{version}.zip")
    }

    public struct WithMinusVersionZip {
        /// Path: `/etc/packages/{group}/{name}-{version}.zip`
        public let path: String

        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.Etc.Packages.WithGroup.WithMinusVersionZip {
    public var jcrContent: JcrContent {
        JcrContent(path: path + "/jcr:content")
    }

    public struct JcrContent {
        /// Path: `/etc/packages/{group}/{name}-{version}.zip/jcr:content`
        public let path: String
    }
}

extension Paths.Etc.Packages.WithGroup.WithMinusVersionZip.JcrContent {
    public var vltDefinition: VltDefinition {
        VltDefinition(path: path + "/vlt:definition")
    }

    public struct VltDefinition {
        /// Path: `/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition`
        public let path: String
    }
}

extension Paths.Etc.Packages.WithGroup.WithMinusVersionZip.JcrContent.VltDefinition {
    public var filterTidy2JSON: FilterTidy2JSON {
        FilterTidy2JSON(path: path + "/filter.tidy.2.json")
    }

    public struct FilterTidy2JSON {
        /// Path: `/etc/packages/{group}/{name}-{version}.zip/jcr:content/vlt:definition/filter.tidy.2.json`
        public let path: String

        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Etc {
    public var replication: Replication {
        Replication(path: path + "/replication")
    }

    public struct Replication {
        /// Path: `/etc/replication`
        public let path: String
    }
}

extension Paths.Etc.Replication {
    public func runmode(_ runmode: String) -> WithAgents1JSON {
        WithAgents1JSON(path: "\(path)/agents.\(runmode).-1.json")
    }

    public struct WithAgents1JSON {
        /// Path: `/etc/replication/agents.{runmode}.-1.json`
        public let path: String

        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Etc.Replication {
    public func runmode(_ runmode: String) -> WithAgents {
        WithAgents(path: "\(path)/agents.\(runmode)")
    }

    public struct WithAgents {
        /// Path: `/etc/replication/agents.{runmode}`
        public let path: String
    }
}

extension Paths.Etc.Replication.WithAgents {
    public func name(_ name: String) -> WithName {
        WithName(path: "\(path)/\(name)")
    }

    public struct WithName {
        /// Path: `/etc/replication/agents.{runmode}/{name}`
        public let path: String

        public var get: Request<Void> {
            .get(path)
        }

        public func post(parameters: PostParameters? = nil) -> Request<Void> {
            .post(path, query: parameters?.asQuery)
        }

        public struct PostParameters {
            public var isJcrContentCqDistribute: Bool?
            public var jcrContentCqDistributeTypeHint: String?
            public var jcrContentCqName: String?
            public var jcrContentCqTemplate: String?
            public var isJcrContentEnabled: Bool?
            public var jcrContentJcrDescription: String?
            public var jcrContentJcrLastModified: String?
            public var jcrContentJcrLastModifiedBy: String?
            public var jcrContentJcrMixinTypes: String?
            public var jcrContentJcrTitle: String?
            public var jcrContentLogLevel: String?
            public var isJcrContentNoStatusUpdate: Bool?
            public var isJcrContentNoVersioning: Bool?
            public var jcrContentProtocolConnectTimeout: Double?
            public var isJcrContentProtocolHTTPConnectionClosed: Bool?
            public var jcrContentProtocolHTTPExpired: String?
            public var jcrContentProtocolHTTPHeaders: [String]?
            public var jcrContentProtocolHTTPHeadersTypeHint: String?
            public var jcrContentProtocolHTTPMethod: String?
            public var isJcrContentProtocolHTTPSRelaxed: Bool?
            public var jcrContentProtocolInterface: String?
            public var jcrContentProtocolSocketTimeout: Double?
            public var jcrContentProtocolVersion: String?
            public var jcrContentProxyNTLMDomain: String?
            public var jcrContentProxyNTLMHost: String?
            public var jcrContentProxyHost: String?
            public var jcrContentProxyPassword: String?
            public var jcrContentProxyPort: Double?
            public var jcrContentProxyUser: String?
            public var jcrContentQueueBatchMaxSize: Double?
            public var jcrContentQueueBatchMode: String?
            public var jcrContentQueueBatchWaitTime: Double?
            public var jcrContentRetryDelay: String?
            public var isJcrContentReverseReplication: Bool?
            public var jcrContentSerializationType: String?
            public var jcrContentSlingResourceType: String?
            public var jcrContentSSL: String?
            public var jcrContentTransportNTLMDomain: String?
            public var jcrContentTransportNTLMHost: String?
            public var jcrContentTransportPassword: String?
            public var jcrContentTransportUri: String?
            public var jcrContentTransportUser: String?
            public var isJcrContentTriggerDistribute: Bool?
            public var isJcrContentTriggerModified: Bool?
            public var isJcrContentTriggerOnOffTime: Bool?
            public var isJcrContentTriggerReceive: Bool?
            public var isJcrContentTriggerSpecific: Bool?
            public var jcrContentUserID: String?
            public var jcrPrimaryType: String?
            public var operation: String?

            public init(isJcrContentCqDistribute: Bool? = nil, jcrContentCqDistributeTypeHint: String? = nil, jcrContentCqName: String? = nil, jcrContentCqTemplate: String? = nil, isJcrContentEnabled: Bool? = nil, jcrContentJcrDescription: String? = nil, jcrContentJcrLastModified: String? = nil, jcrContentJcrLastModifiedBy: String? = nil, jcrContentJcrMixinTypes: String? = nil, jcrContentJcrTitle: String? = nil, jcrContentLogLevel: String? = nil, isJcrContentNoStatusUpdate: Bool? = nil, isJcrContentNoVersioning: Bool? = nil, jcrContentProtocolConnectTimeout: Double? = nil, isJcrContentProtocolHTTPConnectionClosed: Bool? = nil, jcrContentProtocolHTTPExpired: String? = nil, jcrContentProtocolHTTPHeaders: [String]? = nil, jcrContentProtocolHTTPHeadersTypeHint: String? = nil, jcrContentProtocolHTTPMethod: String? = nil, isJcrContentProtocolHTTPSRelaxed: Bool? = nil, jcrContentProtocolInterface: String? = nil, jcrContentProtocolSocketTimeout: Double? = nil, jcrContentProtocolVersion: String? = nil, jcrContentProxyNTLMDomain: String? = nil, jcrContentProxyNTLMHost: String? = nil, jcrContentProxyHost: String? = nil, jcrContentProxyPassword: String? = nil, jcrContentProxyPort: Double? = nil, jcrContentProxyUser: String? = nil, jcrContentQueueBatchMaxSize: Double? = nil, jcrContentQueueBatchMode: String? = nil, jcrContentQueueBatchWaitTime: Double? = nil, jcrContentRetryDelay: String? = nil, isJcrContentReverseReplication: Bool? = nil, jcrContentSerializationType: String? = nil, jcrContentSlingResourceType: String? = nil, jcrContentSSL: String? = nil, jcrContentTransportNTLMDomain: String? = nil, jcrContentTransportNTLMHost: String? = nil, jcrContentTransportPassword: String? = nil, jcrContentTransportUri: String? = nil, jcrContentTransportUser: String? = nil, isJcrContentTriggerDistribute: Bool? = nil, isJcrContentTriggerModified: Bool? = nil, isJcrContentTriggerOnOffTime: Bool? = nil, isJcrContentTriggerReceive: Bool? = nil, isJcrContentTriggerSpecific: Bool? = nil, jcrContentUserID: String? = nil, jcrPrimaryType: String? = nil, operation: String? = nil) {
                self.isJcrContentCqDistribute = isJcrContentCqDistribute
                self.jcrContentCqDistributeTypeHint = jcrContentCqDistributeTypeHint
                self.jcrContentCqName = jcrContentCqName
                self.jcrContentCqTemplate = jcrContentCqTemplate
                self.isJcrContentEnabled = isJcrContentEnabled
                self.jcrContentJcrDescription = jcrContentJcrDescription
                self.jcrContentJcrLastModified = jcrContentJcrLastModified
                self.jcrContentJcrLastModifiedBy = jcrContentJcrLastModifiedBy
                self.jcrContentJcrMixinTypes = jcrContentJcrMixinTypes
                self.jcrContentJcrTitle = jcrContentJcrTitle
                self.jcrContentLogLevel = jcrContentLogLevel
                self.isJcrContentNoStatusUpdate = isJcrContentNoStatusUpdate
                self.isJcrContentNoVersioning = isJcrContentNoVersioning
                self.jcrContentProtocolConnectTimeout = jcrContentProtocolConnectTimeout
                self.isJcrContentProtocolHTTPConnectionClosed = isJcrContentProtocolHTTPConnectionClosed
                self.jcrContentProtocolHTTPExpired = jcrContentProtocolHTTPExpired
                self.jcrContentProtocolHTTPHeaders = jcrContentProtocolHTTPHeaders
                self.jcrContentProtocolHTTPHeadersTypeHint = jcrContentProtocolHTTPHeadersTypeHint
                self.jcrContentProtocolHTTPMethod = jcrContentProtocolHTTPMethod
                self.isJcrContentProtocolHTTPSRelaxed = isJcrContentProtocolHTTPSRelaxed
                self.jcrContentProtocolInterface = jcrContentProtocolInterface
                self.jcrContentProtocolSocketTimeout = jcrContentProtocolSocketTimeout
                self.jcrContentProtocolVersion = jcrContentProtocolVersion
                self.jcrContentProxyNTLMDomain = jcrContentProxyNTLMDomain
                self.jcrContentProxyNTLMHost = jcrContentProxyNTLMHost
                self.jcrContentProxyHost = jcrContentProxyHost
                self.jcrContentProxyPassword = jcrContentProxyPassword
                self.jcrContentProxyPort = jcrContentProxyPort
                self.jcrContentProxyUser = jcrContentProxyUser
                self.jcrContentQueueBatchMaxSize = jcrContentQueueBatchMaxSize
                self.jcrContentQueueBatchMode = jcrContentQueueBatchMode
                self.jcrContentQueueBatchWaitTime = jcrContentQueueBatchWaitTime
                self.jcrContentRetryDelay = jcrContentRetryDelay
                self.isJcrContentReverseReplication = isJcrContentReverseReplication
                self.jcrContentSerializationType = jcrContentSerializationType
                self.jcrContentSlingResourceType = jcrContentSlingResourceType
                self.jcrContentSSL = jcrContentSSL
                self.jcrContentTransportNTLMDomain = jcrContentTransportNTLMDomain
                self.jcrContentTransportNTLMHost = jcrContentTransportNTLMHost
                self.jcrContentTransportPassword = jcrContentTransportPassword
                self.jcrContentTransportUri = jcrContentTransportUri
                self.jcrContentTransportUser = jcrContentTransportUser
                self.isJcrContentTriggerDistribute = isJcrContentTriggerDistribute
                self.isJcrContentTriggerModified = isJcrContentTriggerModified
                self.isJcrContentTriggerOnOffTime = isJcrContentTriggerOnOffTime
                self.isJcrContentTriggerReceive = isJcrContentTriggerReceive
                self.isJcrContentTriggerSpecific = isJcrContentTriggerSpecific
                self.jcrContentUserID = jcrContentUserID
                self.jcrPrimaryType = jcrPrimaryType
                self.operation = operation
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isJcrContentCqDistribute, forKey: "jcr:content/cq:distribute")
                encoder.encode(jcrContentCqDistributeTypeHint, forKey: "jcr:content/cq:distribute@TypeHint")
                encoder.encode(jcrContentCqName, forKey: "jcr:content/cq:name")
                encoder.encode(jcrContentCqTemplate, forKey: "jcr:content/cq:template")
                encoder.encode(isJcrContentEnabled, forKey: "jcr:content/enabled")
                encoder.encode(jcrContentJcrDescription, forKey: "jcr:content/jcr:description")
                encoder.encode(jcrContentJcrLastModified, forKey: "jcr:content/jcr:lastModified")
                encoder.encode(jcrContentJcrLastModifiedBy, forKey: "jcr:content/jcr:lastModifiedBy")
                encoder.encode(jcrContentJcrMixinTypes, forKey: "jcr:content/jcr:mixinTypes")
                encoder.encode(jcrContentJcrTitle, forKey: "jcr:content/jcr:title")
                encoder.encode(jcrContentLogLevel, forKey: "jcr:content/logLevel")
                encoder.encode(isJcrContentNoStatusUpdate, forKey: "jcr:content/noStatusUpdate")
                encoder.encode(isJcrContentNoVersioning, forKey: "jcr:content/noVersioning")
                encoder.encode(jcrContentProtocolConnectTimeout, forKey: "jcr:content/protocolConnectTimeout")
                encoder.encode(isJcrContentProtocolHTTPConnectionClosed, forKey: "jcr:content/protocolHTTPConnectionClosed")
                encoder.encode(jcrContentProtocolHTTPExpired, forKey: "jcr:content/protocolHTTPExpired")
                encoder.encode(jcrContentProtocolHTTPHeaders, forKey: "jcr:content/protocolHTTPHeaders")
                encoder.encode(jcrContentProtocolHTTPHeadersTypeHint, forKey: "jcr:content/protocolHTTPHeaders@TypeHint")
                encoder.encode(jcrContentProtocolHTTPMethod, forKey: "jcr:content/protocolHTTPMethod")
                encoder.encode(isJcrContentProtocolHTTPSRelaxed, forKey: "jcr:content/protocolHTTPSRelaxed")
                encoder.encode(jcrContentProtocolInterface, forKey: "jcr:content/protocolInterface")
                encoder.encode(jcrContentProtocolSocketTimeout, forKey: "jcr:content/protocolSocketTimeout")
                encoder.encode(jcrContentProtocolVersion, forKey: "jcr:content/protocolVersion")
                encoder.encode(jcrContentProxyNTLMDomain, forKey: "jcr:content/proxyNTLMDomain")
                encoder.encode(jcrContentProxyNTLMHost, forKey: "jcr:content/proxyNTLMHost")
                encoder.encode(jcrContentProxyHost, forKey: "jcr:content/proxyHost")
                encoder.encode(jcrContentProxyPassword, forKey: "jcr:content/proxyPassword")
                encoder.encode(jcrContentProxyPort, forKey: "jcr:content/proxyPort")
                encoder.encode(jcrContentProxyUser, forKey: "jcr:content/proxyUser")
                encoder.encode(jcrContentQueueBatchMaxSize, forKey: "jcr:content/queueBatchMaxSize")
                encoder.encode(jcrContentQueueBatchMode, forKey: "jcr:content/queueBatchMode")
                encoder.encode(jcrContentQueueBatchWaitTime, forKey: "jcr:content/queueBatchWaitTime")
                encoder.encode(jcrContentRetryDelay, forKey: "jcr:content/retryDelay")
                encoder.encode(isJcrContentReverseReplication, forKey: "jcr:content/reverseReplication")
                encoder.encode(jcrContentSerializationType, forKey: "jcr:content/serializationType")
                encoder.encode(jcrContentSlingResourceType, forKey: "jcr:content/sling:resourceType")
                encoder.encode(jcrContentSSL, forKey: "jcr:content/ssl")
                encoder.encode(jcrContentTransportNTLMDomain, forKey: "jcr:content/transportNTLMDomain")
                encoder.encode(jcrContentTransportNTLMHost, forKey: "jcr:content/transportNTLMHost")
                encoder.encode(jcrContentTransportPassword, forKey: "jcr:content/transportPassword")
                encoder.encode(jcrContentTransportUri, forKey: "jcr:content/transportUri")
                encoder.encode(jcrContentTransportUser, forKey: "jcr:content/transportUser")
                encoder.encode(isJcrContentTriggerDistribute, forKey: "jcr:content/triggerDistribute")
                encoder.encode(isJcrContentTriggerModified, forKey: "jcr:content/triggerModified")
                encoder.encode(isJcrContentTriggerOnOffTime, forKey: "jcr:content/triggerOnOffTime")
                encoder.encode(isJcrContentTriggerReceive, forKey: "jcr:content/triggerReceive")
                encoder.encode(isJcrContentTriggerSpecific, forKey: "jcr:content/triggerSpecific")
                encoder.encode(jcrContentUserID, forKey: "jcr:content/userId")
                encoder.encode(jcrPrimaryType, forKey: "jcr:primaryType")
                encoder.encode(operation, forKey: ":operation")
                return encoder.items
            }
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Etc.Replication {
    public var treeactivationHTML: TreeactivationHTML {
        TreeactivationHTML(path: path + "/treeactivation.html")
    }

    public struct TreeactivationHTML {
        /// Path: `/etc/replication/treeactivation.html`
        public let path: String

        public func post(parameters: PostParameters) -> Request<Void> {
            .post(path, query: parameters.asQuery)
        }

        public struct PostParameters {
            public var isIgnoredeactivated: Bool
            public var isOnlymodified: Bool
            public var path: String

            public init(isIgnoredeactivated: Bool, isOnlymodified: Bool, path: String) {
                self.isIgnoredeactivated = isIgnoredeactivated
                self.isOnlymodified = isOnlymodified
                self.path = path
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isIgnoredeactivated, forKey: "ignoredeactivated")
                encoder.encode(isOnlymodified, forKey: "onlymodified")
                encoder.encode(path, forKey: "path")
                return encoder.items
            }
        }
    }
}

extension Paths.Libs.Granite {
    public var security: Security {
        Security(path: path + "/security")
    }

    public struct Security {
        /// Path: `/libs/granite/security`
        public let path: String
    }
}

extension Paths.Libs.Granite.Security {
    public var post: Post {
        Post(path: path + "/post")
    }

    public struct Post {
        /// Path: `/libs/granite/security/post`
        public let path: String
    }
}

extension Paths.Libs.Granite.Security.Post {
    public var authorizables: Authorizables {
        Authorizables(path: path + "/authorizables")
    }

    public struct Authorizables {
        /// Path: `/libs/granite/security/post/authorizables`
        public let path: String

        public func post(parameters: PostParameters) -> Request<String> {
            .post(path, query: parameters.asQuery)
        }

        public struct PostParameters {
            public var authorizableID: String
            public var intermediatePath: String
            public var createUser: String?
            public var createGroup: String?
            public var repPassword: String?
            public var profileGivenName: String?

            public init(authorizableID: String, intermediatePath: String, createUser: String? = nil, createGroup: String? = nil, repPassword: String? = nil, profileGivenName: String? = nil) {
                self.authorizableID = authorizableID
                self.intermediatePath = intermediatePath
                self.createUser = createUser
                self.createGroup = createGroup
                self.repPassword = repPassword
                self.profileGivenName = profileGivenName
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(authorizableID, forKey: "authorizableId")
                encoder.encode(intermediatePath, forKey: "intermediatePath")
                encoder.encode(createUser, forKey: "createUser")
                encoder.encode(createGroup, forKey: "createGroup")
                encoder.encode(repPassword, forKey: "rep:password")
                encoder.encode(profileGivenName, forKey: "profile/givenName")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var crx: Crx {
        Crx(path: "/crx")
    }

    public struct Crx {
        /// Path: `/crx`
        public let path: String
    }
}

extension Paths.Crx {
    public var explorer: Explorer {
        Explorer(path: path + "/explorer")
    }

    public struct Explorer {
        /// Path: `/crx/explorer`
        public let path: String
    }
}

extension Paths.Crx.Explorer {
    public var ui: Ui {
        Ui(path: path + "/ui")
    }

    public struct Ui {
        /// Path: `/crx/explorer/ui`
        public let path: String
    }
}

extension Paths.Crx.Explorer.Ui {
    public var setpasswordJsp: SetpasswordJsp {
        SetpasswordJsp(path: path + "/setpassword.jsp")
    }

    public struct SetpasswordJsp {
        /// Path: `/crx/explorer/ui/setpassword.jsp`
        public let path: String

        public func post(parameters: PostParameters) -> Request<String> {
            .post(path, query: parameters.asQuery)
        }

        public struct PostParameters {
            public var old: String
            public var plain: String
            public var verify: String

            public init(old: String, plain: String, verify: String) {
                self.old = old
                self.plain = plain
                self.verify = verify
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(old, forKey: "old")
                encoder.encode(plain, forKey: "plain")
                encoder.encode(verify, forKey: "verify")
                return encoder.items
            }
        }
    }
}

extension Paths.Crx {
    public var packmgr: Packmgr {
        Packmgr(path: path + "/packmgr")
    }

    public struct Packmgr {
        /// Path: `/crx/packmgr`
        public let path: String
    }
}

extension Paths.Crx.Packmgr {
    public var installstatusJsp: InstallstatusJsp {
        InstallstatusJsp(path: path + "/installstatus.jsp")
    }

    public struct InstallstatusJsp {
        /// Path: `/crx/packmgr/installstatus.jsp`
        public let path: String

        public var get: Request<AEMAPI.InstallStatus> {
            .get(path)
        }
    }
}

extension Paths.Crx.Packmgr {
    public var serviceJsp: ServiceJsp {
        ServiceJsp(path: path + "/service.jsp")
    }

    public struct ServiceJsp {
        /// Path: `/crx/packmgr/service.jsp`
        public let path: String

        public func post(cmd: String) -> Request<String> {
            .post(path, query: [("cmd", cmd)])
        }
    }
}

extension Paths.Crx.Packmgr {
    public var updateJsp: UpdateJsp {
        UpdateJsp(path: path + "/update.jsp")
    }

    public struct UpdateJsp {
        /// Path: `/crx/packmgr/update.jsp`
        public let path: String

        public func post(parameters: PostParameters) -> Request<String> {
            .post(path, query: parameters.asQuery)
        }

        public struct PostParameters {
            public var groupName: String
            public var packageName: String
            public var version: String
            public var path: String
            public var filter: String?
            public var charset: String?

            public init(groupName: String, packageName: String, version: String, path: String, filter: String? = nil, charset: String? = nil) {
                self.groupName = groupName
                self.packageName = packageName
                self.version = version
                self.path = path
                self.filter = filter
                self.charset = charset
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(groupName, forKey: "groupName")
                encoder.encode(packageName, forKey: "packageName")
                encoder.encode(version, forKey: "version")
                encoder.encode(path, forKey: "path")
                encoder.encode(filter, forKey: "filter")
                encoder.encode(charset, forKey: "_charset_")
                return encoder.items
            }
        }
    }
}

extension Paths.Crx.Packmgr {
    public var service: Service {
        Service(path: path + "/service")
    }

    public struct Service {
        /// Path: `/crx/packmgr/service`
        public let path: String
    }
}

extension Paths.Crx.Packmgr.Service {
    public var json: JSON {
        JSON(path: path + "/.json")
    }

    public struct JSON {
        /// Path: `/crx/packmgr/service/.json`
        public let path: String
    }
}

extension Paths.Crx.Packmgr.Service.JSON {
    public func path(_ path: String) -> WithPath {
        WithPath(path: "\(path)/\(path)")
    }

    public struct WithPath {
        /// Path: `/crx/packmgr/service/.json/{path}`
        public let path: String

        public func post(parameters: PostParameters, _ body: Data? = nil) -> Request<String> {
            .post(path, query: parameters.asQuery, body: body)
        }

        public struct PostParameters {
            public var cmd: String
            public var groupName: String?
            public var packageName: String?
            public var packageVersion: String?
            public var charset: String?
            public var isForce: Bool?
            public var isRecursive: Bool?

            public init(cmd: String, groupName: String? = nil, packageName: String? = nil, packageVersion: String? = nil, charset: String? = nil, isForce: Bool? = nil, isRecursive: Bool? = nil) {
                self.cmd = cmd
                self.groupName = groupName
                self.packageName = packageName
                self.packageVersion = packageVersion
                self.charset = charset
                self.isForce = isForce
                self.isRecursive = isRecursive
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(cmd, forKey: "cmd")
                encoder.encode(groupName, forKey: "groupName")
                encoder.encode(packageName, forKey: "packageName")
                encoder.encode(packageVersion, forKey: "packageVersion")
                encoder.encode(charset, forKey: "_charset_")
                encoder.encode(isForce, forKey: "force")
                encoder.encode(isRecursive, forKey: "recursive")
                return encoder.items
            }
        }
    }
}

extension Paths.Crx.Packmgr.Service {
    public var scriptHTML: ScriptHTML {
        ScriptHTML(path: path + "/script.html")
    }

    public struct ScriptHTML {
        /// Path: `/crx/packmgr/service/script.html`
        public let path: String

        public var get: Request<Void> {
            .get(path)
        }
    }
}

extension Paths.Crx {
    public var server: Server {
        Server(path: path + "/server")
    }

    public struct Server {
        /// Path: `/crx/server`
        public let path: String
    }
}

extension Paths.Crx.Server {
    public var crxDefault: CrxDefault {
        CrxDefault(path: path + "/crx.default")
    }

    public struct CrxDefault {
        /// Path: `/crx/server/crx.default`
        public let path: String
    }
}

extension Paths.Crx.Server.CrxDefault {
    public var jcrRoot: JcrRoot {
        JcrRoot(path: path + "/jcr:root")
    }

    public struct JcrRoot {
        /// Path: `/crx/server/crx.default/jcr:root`
        public let path: String
    }
}

extension Paths.Crx.Server.CrxDefault.JcrRoot {
    public var _1json: __1JSON {
        __1JSON(path: path + "/.1.json")
    }

    public struct __1JSON {
        /// Path: `/crx/server/crx.default/jcr:root/.1.json`
        public let path: String

        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.System.Console {
    public var bundles: Bundles {
        Bundles(path: path + "/bundles")
    }

    public struct Bundles {
        /// Path: `/system/console/bundles`
        public let path: String
    }
}

extension Paths.System.Console.Bundles {
    public func name(_ name: String) -> WithJSON {
        WithJSON(path: "\(path)/\(name).json")
    }

    public struct WithJSON {
        /// Path: `/system/console/bundles/{name}.json`
        public let path: String

        public var get: Request<AEMAPI.BundleInfo> {
            .get(path)
        }
    }
}

extension Paths.System.Console.Bundles {
    public func name(_ name: String) -> WithName {
        WithName(path: "\(path)/\(name)")
    }

    public struct WithName {
        /// Path: `/system/console/bundles/{name}`
        public let path: String

        public func post(action: String) -> Request<Void> {
            .post(path, query: [("action", action)])
        }
    }
}

extension Paths.System.Console {
    public var jmx: Jmx {
        Jmx(path: path + "/jmx")
    }

    public struct Jmx {
        /// Path: `/system/console/jmx`
        public let path: String
    }
}

extension Paths.System.Console.Jmx {
    public var comAdobeGraniteTypeRepository: ComAdobeGraniteTypeRepository {
        ComAdobeGraniteTypeRepository(path: path + "/com.adobe.granite:type=Repository")
    }

    public struct ComAdobeGraniteTypeRepository {
        /// Path: `/system/console/jmx/com.adobe.granite:type=Repository`
        public let path: String
    }
}

extension Paths.System.Console.Jmx.ComAdobeGraniteTypeRepository {
    public var op: Op {
        Op(path: path + "/op")
    }

    public struct Op {
        /// Path: `/system/console/jmx/com.adobe.granite:type=Repository/op`
        public let path: String
    }
}

extension Paths.System.Console.Jmx.ComAdobeGraniteTypeRepository.Op {
    public func action(_ action: String) -> WithAction {
        WithAction(path: "\(path)/\(action)")
    }

    public struct WithAction {
        /// Path: `/system/console/jmx/com.adobe.granite:type=Repository/op/{action}`
        public let path: String

        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.System {
    public var health: Health {
        Health(path: path + "/health")
    }

    public struct Health {
        /// Path: `/system/health`
        public let path: String

        public func get(tags: String? = nil, isCombineTagsOr: Bool? = nil) -> Request<String> {
            .get(path, query: makeGetQuery(tags, isCombineTagsOr))
        }

        private func makeGetQuery(_ tags: String?, _ isCombineTagsOr: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tags, forKey: "tags")
            encoder.encode(isCombineTagsOr, forKey: "combineTagsOr")
            return encoder.items
        }
    }
}

extension Paths.Apps.System.Config {
    public var comAdobeGraniteAuthSamlSamlAuthenticationHandlerConfig: ComAdobeGraniteAuthSamlSamlAuthenticationHandlerConfig {
        ComAdobeGraniteAuthSamlSamlAuthenticationHandlerConfig(path: path + "/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config")
    }

    public struct ComAdobeGraniteAuthSamlSamlAuthenticationHandlerConfig {
        /// Path: `/apps/system/config/com.adobe.granite.auth.saml.SamlAuthenticationHandler.config`
        public let path: String

        public func post(parameters: PostParameters? = nil) -> Request<Void> {
            .post(path, query: parameters?.asQuery)
        }

        public struct PostParameters {
            public var keyStorePassword: String?
            public var keyStorePasswordTypeHint: String?
            public var serviceRanking: Int?
            public var serviceRankingTypeHint: String?
            public var isIdpHTTPRedirect: Bool?
            public var idpHTTPRedirectTypeHint: String?
            public var isCreateUser: Bool?
            public var createUserTypeHint: String?
            public var defaultRedirectURL: String?
            public var defaultRedirectURLTypeHint: String?
            public var userIDAttribute: String?
            public var userIDAttributeTypeHint: String?
            public var defaultGroups: [String]?
            public var defaultGroupsTypeHint: String?
            public var idpCertAlias: String?
            public var idpCertAliasTypeHint: String?
            public var isAddGroupMemberships: Bool?
            public var addGroupMembershipsTypeHint: String?
            public var path: [String]?
            public var pathTypeHint: String?
            public var synchronizeAttributes: [String]?
            public var synchronizeAttributesTypeHint: String?
            public var clockTolerance: Int?
            public var clockToleranceTypeHint: String?
            public var groupMembershipAttribute: String?
            public var groupMembershipAttributeTypeHint: String?
            public var idpURL: String?
            public var idpURLTypeHint: String?
            public var logoutURL: String?
            public var logoutURLTypeHint: String?
            public var serviceProviderEntityID: String?
            public var serviceProviderEntityIDTypeHint: String?
            public var assertionConsumerServiceURL: String?
            public var assertionConsumerServiceURLTypeHint: String?
            public var isHandleLogout: Bool?
            public var handleLogoutTypeHint: String?
            public var spPrivateKeyAlias: String?
            public var spPrivateKeyAliasTypeHint: String?
            public var useEncryption: Bool?
            public var useEncryptionTypeHint: String?
            public var nameIDFormat: String?
            public var nameIDFormatTypeHint: String?
            public var digestMethod: String?
            public var digestMethodTypeHint: String?
            public var signatureMethod: String?
            public var signatureMethodTypeHint: String?
            public var userIntermediatePath: String?
            public var userIntermediatePathTypeHint: String?

            public init(keyStorePassword: String? = nil, keyStorePasswordTypeHint: String? = nil, serviceRanking: Int? = nil, serviceRankingTypeHint: String? = nil, isIdpHTTPRedirect: Bool? = nil, idpHTTPRedirectTypeHint: String? = nil, isCreateUser: Bool? = nil, createUserTypeHint: String? = nil, defaultRedirectURL: String? = nil, defaultRedirectURLTypeHint: String? = nil, userIDAttribute: String? = nil, userIDAttributeTypeHint: String? = nil, defaultGroups: [String]? = nil, defaultGroupsTypeHint: String? = nil, idpCertAlias: String? = nil, idpCertAliasTypeHint: String? = nil, isAddGroupMemberships: Bool? = nil, addGroupMembershipsTypeHint: String? = nil, path: [String]? = nil, pathTypeHint: String? = nil, synchronizeAttributes: [String]? = nil, synchronizeAttributesTypeHint: String? = nil, clockTolerance: Int? = nil, clockToleranceTypeHint: String? = nil, groupMembershipAttribute: String? = nil, groupMembershipAttributeTypeHint: String? = nil, idpURL: String? = nil, idpURLTypeHint: String? = nil, logoutURL: String? = nil, logoutURLTypeHint: String? = nil, serviceProviderEntityID: String? = nil, serviceProviderEntityIDTypeHint: String? = nil, assertionConsumerServiceURL: String? = nil, assertionConsumerServiceURLTypeHint: String? = nil, isHandleLogout: Bool? = nil, handleLogoutTypeHint: String? = nil, spPrivateKeyAlias: String? = nil, spPrivateKeyAliasTypeHint: String? = nil, useEncryption: Bool? = nil, useEncryptionTypeHint: String? = nil, nameIDFormat: String? = nil, nameIDFormatTypeHint: String? = nil, digestMethod: String? = nil, digestMethodTypeHint: String? = nil, signatureMethod: String? = nil, signatureMethodTypeHint: String? = nil, userIntermediatePath: String? = nil, userIntermediatePathTypeHint: String? = nil) {
                self.keyStorePassword = keyStorePassword
                self.keyStorePasswordTypeHint = keyStorePasswordTypeHint
                self.serviceRanking = serviceRanking
                self.serviceRankingTypeHint = serviceRankingTypeHint
                self.isIdpHTTPRedirect = isIdpHTTPRedirect
                self.idpHTTPRedirectTypeHint = idpHTTPRedirectTypeHint
                self.isCreateUser = isCreateUser
                self.createUserTypeHint = createUserTypeHint
                self.defaultRedirectURL = defaultRedirectURL
                self.defaultRedirectURLTypeHint = defaultRedirectURLTypeHint
                self.userIDAttribute = userIDAttribute
                self.userIDAttributeTypeHint = userIDAttributeTypeHint
                self.defaultGroups = defaultGroups
                self.defaultGroupsTypeHint = defaultGroupsTypeHint
                self.idpCertAlias = idpCertAlias
                self.idpCertAliasTypeHint = idpCertAliasTypeHint
                self.isAddGroupMemberships = isAddGroupMemberships
                self.addGroupMembershipsTypeHint = addGroupMembershipsTypeHint
                self.path = path
                self.pathTypeHint = pathTypeHint
                self.synchronizeAttributes = synchronizeAttributes
                self.synchronizeAttributesTypeHint = synchronizeAttributesTypeHint
                self.clockTolerance = clockTolerance
                self.clockToleranceTypeHint = clockToleranceTypeHint
                self.groupMembershipAttribute = groupMembershipAttribute
                self.groupMembershipAttributeTypeHint = groupMembershipAttributeTypeHint
                self.idpURL = idpURL
                self.idpURLTypeHint = idpURLTypeHint
                self.logoutURL = logoutURL
                self.logoutURLTypeHint = logoutURLTypeHint
                self.serviceProviderEntityID = serviceProviderEntityID
                self.serviceProviderEntityIDTypeHint = serviceProviderEntityIDTypeHint
                self.assertionConsumerServiceURL = assertionConsumerServiceURL
                self.assertionConsumerServiceURLTypeHint = assertionConsumerServiceURLTypeHint
                self.isHandleLogout = isHandleLogout
                self.handleLogoutTypeHint = handleLogoutTypeHint
                self.spPrivateKeyAlias = spPrivateKeyAlias
                self.spPrivateKeyAliasTypeHint = spPrivateKeyAliasTypeHint
                self.useEncryption = useEncryption
                self.useEncryptionTypeHint = useEncryptionTypeHint
                self.nameIDFormat = nameIDFormat
                self.nameIDFormatTypeHint = nameIDFormatTypeHint
                self.digestMethod = digestMethod
                self.digestMethodTypeHint = digestMethodTypeHint
                self.signatureMethod = signatureMethod
                self.signatureMethodTypeHint = signatureMethodTypeHint
                self.userIntermediatePath = userIntermediatePath
                self.userIntermediatePathTypeHint = userIntermediatePathTypeHint
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(keyStorePassword, forKey: "keyStorePassword")
                encoder.encode(keyStorePasswordTypeHint, forKey: "keyStorePassword@TypeHint")
                encoder.encode(serviceRanking, forKey: "service.ranking")
                encoder.encode(serviceRankingTypeHint, forKey: "service.ranking@TypeHint")
                encoder.encode(isIdpHTTPRedirect, forKey: "idpHttpRedirect")
                encoder.encode(idpHTTPRedirectTypeHint, forKey: "idpHttpRedirect@TypeHint")
                encoder.encode(isCreateUser, forKey: "createUser")
                encoder.encode(createUserTypeHint, forKey: "createUser@TypeHint")
                encoder.encode(defaultRedirectURL, forKey: "defaultRedirectUrl")
                encoder.encode(defaultRedirectURLTypeHint, forKey: "defaultRedirectUrl@TypeHint")
                encoder.encode(userIDAttribute, forKey: "userIDAttribute")
                encoder.encode(userIDAttributeTypeHint, forKey: "userIDAttribute@TypeHint")
                encoder.encode(defaultGroups, forKey: "defaultGroups")
                encoder.encode(defaultGroupsTypeHint, forKey: "defaultGroups@TypeHint")
                encoder.encode(idpCertAlias, forKey: "idpCertAlias")
                encoder.encode(idpCertAliasTypeHint, forKey: "idpCertAlias@TypeHint")
                encoder.encode(isAddGroupMemberships, forKey: "addGroupMemberships")
                encoder.encode(addGroupMembershipsTypeHint, forKey: "addGroupMemberships@TypeHint")
                encoder.encode(path, forKey: "path")
                encoder.encode(pathTypeHint, forKey: "path@TypeHint")
                encoder.encode(synchronizeAttributes, forKey: "synchronizeAttributes")
                encoder.encode(synchronizeAttributesTypeHint, forKey: "synchronizeAttributes@TypeHint")
                encoder.encode(clockTolerance, forKey: "clockTolerance")
                encoder.encode(clockToleranceTypeHint, forKey: "clockTolerance@TypeHint")
                encoder.encode(groupMembershipAttribute, forKey: "groupMembershipAttribute")
                encoder.encode(groupMembershipAttributeTypeHint, forKey: "groupMembershipAttribute@TypeHint")
                encoder.encode(idpURL, forKey: "idpUrl")
                encoder.encode(idpURLTypeHint, forKey: "idpUrl@TypeHint")
                encoder.encode(logoutURL, forKey: "logoutUrl")
                encoder.encode(logoutURLTypeHint, forKey: "logoutUrl@TypeHint")
                encoder.encode(serviceProviderEntityID, forKey: "serviceProviderEntityId")
                encoder.encode(serviceProviderEntityIDTypeHint, forKey: "serviceProviderEntityId@TypeHint")
                encoder.encode(assertionConsumerServiceURL, forKey: "assertionConsumerServiceURL")
                encoder.encode(assertionConsumerServiceURLTypeHint, forKey: "assertionConsumerServiceURL@TypeHint")
                encoder.encode(isHandleLogout, forKey: "handleLogout")
                encoder.encode(handleLogoutTypeHint, forKey: "handleLogout@TypeHint")
                encoder.encode(spPrivateKeyAlias, forKey: "spPrivateKeyAlias")
                encoder.encode(spPrivateKeyAliasTypeHint, forKey: "spPrivateKeyAlias@TypeHint")
                encoder.encode(useEncryption, forKey: "useEncryption")
                encoder.encode(useEncryptionTypeHint, forKey: "useEncryption@TypeHint")
                encoder.encode(nameIDFormat, forKey: "nameIdFormat")
                encoder.encode(nameIDFormatTypeHint, forKey: "nameIdFormat@TypeHint")
                encoder.encode(digestMethod, forKey: "digestMethod")
                encoder.encode(digestMethodTypeHint, forKey: "digestMethod@TypeHint")
                encoder.encode(signatureMethod, forKey: "signatureMethod")
                encoder.encode(signatureMethodTypeHint, forKey: "signatureMethod@TypeHint")
                encoder.encode(userIntermediatePath, forKey: "userIntermediatePath")
                encoder.encode(userIntermediatePathTypeHint, forKey: "userIntermediatePath@TypeHint")
                return encoder.items
            }
        }
    }
}

extension Paths.Apps.System.Config {
    public var orgApacheHTTPProxyconfiguratorConfig: OrgApacheHTTPProxyconfiguratorConfig {
        OrgApacheHTTPProxyconfiguratorConfig(path: path + "/org.apache.http.proxyconfigurator.config")
    }

    public struct OrgApacheHTTPProxyconfiguratorConfig {
        /// Path: `/apps/system/config/org.apache.http.proxyconfigurator.config`
        public let path: String

        public func post(parameters: PostParameters? = nil) -> Request<Void> {
            .post(path, query: parameters?.asQuery)
        }

        public struct PostParameters {
            public var proxyHost: String?
            public var proxyHostTypeHint: String?
            public var proxyPort: Int?
            public var proxyPortTypeHint: String?
            public var proxyExceptions: [String]?
            public var proxyExceptionsTypeHint: String?
            public var isProxyEnabled: Bool?
            public var proxyEnabledTypeHint: String?
            public var proxyUser: String?
            public var proxyUserTypeHint: String?
            public var proxyPassword: String?
            public var proxyPasswordTypeHint: String?

            public init(proxyHost: String? = nil, proxyHostTypeHint: String? = nil, proxyPort: Int? = nil, proxyPortTypeHint: String? = nil, proxyExceptions: [String]? = nil, proxyExceptionsTypeHint: String? = nil, isProxyEnabled: Bool? = nil, proxyEnabledTypeHint: String? = nil, proxyUser: String? = nil, proxyUserTypeHint: String? = nil, proxyPassword: String? = nil, proxyPasswordTypeHint: String? = nil) {
                self.proxyHost = proxyHost
                self.proxyHostTypeHint = proxyHostTypeHint
                self.proxyPort = proxyPort
                self.proxyPortTypeHint = proxyPortTypeHint
                self.proxyExceptions = proxyExceptions
                self.proxyExceptionsTypeHint = proxyExceptionsTypeHint
                self.isProxyEnabled = isProxyEnabled
                self.proxyEnabledTypeHint = proxyEnabledTypeHint
                self.proxyUser = proxyUser
                self.proxyUserTypeHint = proxyUserTypeHint
                self.proxyPassword = proxyPassword
                self.proxyPasswordTypeHint = proxyPasswordTypeHint
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(proxyHost, forKey: "proxy.host")
                encoder.encode(proxyHostTypeHint, forKey: "proxy.host@TypeHint")
                encoder.encode(proxyPort, forKey: "proxy.port")
                encoder.encode(proxyPortTypeHint, forKey: "proxy.port@TypeHint")
                encoder.encode(proxyExceptions, forKey: "proxy.exceptions")
                encoder.encode(proxyExceptionsTypeHint, forKey: "proxy.exceptions@TypeHint")
                encoder.encode(isProxyEnabled, forKey: "proxy.enabled")
                encoder.encode(proxyEnabledTypeHint, forKey: "proxy.enabled@TypeHint")
                encoder.encode(proxyUser, forKey: "proxy.user")
                encoder.encode(proxyUserTypeHint, forKey: "proxy.user@TypeHint")
                encoder.encode(proxyPassword, forKey: "proxy.password")
                encoder.encode(proxyPasswordTypeHint, forKey: "proxy.password@TypeHint")
                return encoder.items
            }
        }
    }
}

extension Paths.Libs.Granite.Security.Post {
    public var truststore: Truststore {
        Truststore(path: path + "/truststore")
    }

    public struct Truststore {
        /// Path: `/libs/granite/security/post/truststore`
        public let path: String

        public func post(parameters: PostParameters? = nil, _ body: Data? = nil) -> Request<String> {
            .post(path, query: parameters?.asQuery, body: body)
        }

        public struct PostParameters {
            public var operation: String?
            public var newPassword: String?
            public var rePassword: String?
            public var keyStoreType: String?
            public var removeAlias: String?

            public init(operation: String? = nil, newPassword: String? = nil, rePassword: String? = nil, keyStoreType: String? = nil, removeAlias: String? = nil) {
                self.operation = operation
                self.newPassword = newPassword
                self.rePassword = rePassword
                self.keyStoreType = keyStoreType
                self.removeAlias = removeAlias
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(operation, forKey: ":operation")
                encoder.encode(newPassword, forKey: "newPassword")
                encoder.encode(rePassword, forKey: "rePassword")
                encoder.encode(keyStoreType, forKey: "keyStoreType")
                encoder.encode(removeAlias, forKey: "removeAlias")
                return encoder.items
            }
        }
    }
}

extension Paths.Libs.Granite.Security {
    public var truststoreJSON: TruststoreJSON {
        TruststoreJSON(path: path + "/truststore.json")
    }

    public struct TruststoreJSON {
        /// Path: `/libs/granite/security/truststore.json`
        public let path: String

        public var get: Request<AEMAPI.TruststoreInfo> {
            .get(path)
        }
    }
}

extension Paths.Etc.Truststore {
    public var truststoreP12: TruststoreP12 {
        TruststoreP12(path: path + "/truststore.p12")
    }

    public struct TruststoreP12 {
        /// Path: `/etc/truststore/truststore.p12`
        public let path: String

        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.Etc {
    public var truststore: Truststore {
        Truststore(path: path + "/truststore")
    }

    public struct Truststore {
        /// Path: `/etc/truststore`
        public let path: String

        public func post(_ body: Data? = nil) -> Request<String> {
            .post(path, body: body)
        }
    }
}

extension Paths.System.Console.ConfigMgr {
    public var comAdobeGraniteAuthSamlSamlAuthenticationHandler: ComAdobeGraniteAuthSamlSamlAuthenticationHandler {
        ComAdobeGraniteAuthSamlSamlAuthenticationHandler(path: path + "/com.adobe.granite.auth.saml.SamlAuthenticationHandler")
    }

    public struct ComAdobeGraniteAuthSamlSamlAuthenticationHandler {
        /// Path: `/system/console/configMgr/com.adobe.granite.auth.saml.SamlAuthenticationHandler`
        public let path: String

        public func post(parameters: PostParameters? = nil) -> Request<String> {
            .post(path, query: parameters?.asQuery)
        }

        public struct PostParameters {
            public var isPost: Bool?
            public var isApply: Bool?
            public var delete: Bool?
            public var action: String?
            public var location: String?
            public var path: [String]?
            public var serviceRanking: Int?
            public var idpURL: String?
            public var idpCertAlias: String?
            public var isIdpHTTPRedirect: Bool?
            public var serviceProviderEntityID: String?
            public var assertionConsumerServiceURL: String?
            public var spPrivateKeyAlias: String?
            public var keyStorePassword: String?
            public var defaultRedirectURL: String?
            public var userIDAttribute: String?
            public var useEncryption: Bool?
            public var isCreateUser: Bool?
            public var isAddGroupMemberships: Bool?
            public var groupMembershipAttribute: String?
            public var defaultGroups: [String]?
            public var nameIDFormat: String?
            public var synchronizeAttributes: [String]?
            public var isHandleLogout: Bool?
            public var logoutURL: String?
            public var clockTolerance: Int?
            public var digestMethod: String?
            public var signatureMethod: String?
            public var userIntermediatePath: String?
            public var propertylist: [String]?

            public init(isPost: Bool? = nil, isApply: Bool? = nil, delete: Bool? = nil, action: String? = nil, location: String? = nil, path: [String]? = nil, serviceRanking: Int? = nil, idpURL: String? = nil, idpCertAlias: String? = nil, isIdpHTTPRedirect: Bool? = nil, serviceProviderEntityID: String? = nil, assertionConsumerServiceURL: String? = nil, spPrivateKeyAlias: String? = nil, keyStorePassword: String? = nil, defaultRedirectURL: String? = nil, userIDAttribute: String? = nil, useEncryption: Bool? = nil, isCreateUser: Bool? = nil, isAddGroupMemberships: Bool? = nil, groupMembershipAttribute: String? = nil, defaultGroups: [String]? = nil, nameIDFormat: String? = nil, synchronizeAttributes: [String]? = nil, isHandleLogout: Bool? = nil, logoutURL: String? = nil, clockTolerance: Int? = nil, digestMethod: String? = nil, signatureMethod: String? = nil, userIntermediatePath: String? = nil, propertylist: [String]? = nil) {
                self.isPost = isPost
                self.isApply = isApply
                self.delete = delete
                self.action = action
                self.location = location
                self.path = path
                self.serviceRanking = serviceRanking
                self.idpURL = idpURL
                self.idpCertAlias = idpCertAlias
                self.isIdpHTTPRedirect = isIdpHTTPRedirect
                self.serviceProviderEntityID = serviceProviderEntityID
                self.assertionConsumerServiceURL = assertionConsumerServiceURL
                self.spPrivateKeyAlias = spPrivateKeyAlias
                self.keyStorePassword = keyStorePassword
                self.defaultRedirectURL = defaultRedirectURL
                self.userIDAttribute = userIDAttribute
                self.useEncryption = useEncryption
                self.isCreateUser = isCreateUser
                self.isAddGroupMemberships = isAddGroupMemberships
                self.groupMembershipAttribute = groupMembershipAttribute
                self.defaultGroups = defaultGroups
                self.nameIDFormat = nameIDFormat
                self.synchronizeAttributes = synchronizeAttributes
                self.isHandleLogout = isHandleLogout
                self.logoutURL = logoutURL
                self.clockTolerance = clockTolerance
                self.digestMethod = digestMethod
                self.signatureMethod = signatureMethod
                self.userIntermediatePath = userIntermediatePath
                self.propertylist = propertylist
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isPost, forKey: "post")
                encoder.encode(isApply, forKey: "apply")
                encoder.encode(delete, forKey: "delete")
                encoder.encode(action, forKey: "action")
                encoder.encode(location, forKey: "$location")
                encoder.encode(path, forKey: "path")
                encoder.encode(serviceRanking, forKey: "service.ranking")
                encoder.encode(idpURL, forKey: "idpUrl")
                encoder.encode(idpCertAlias, forKey: "idpCertAlias")
                encoder.encode(isIdpHTTPRedirect, forKey: "idpHttpRedirect")
                encoder.encode(serviceProviderEntityID, forKey: "serviceProviderEntityId")
                encoder.encode(assertionConsumerServiceURL, forKey: "assertionConsumerServiceURL")
                encoder.encode(spPrivateKeyAlias, forKey: "spPrivateKeyAlias")
                encoder.encode(keyStorePassword, forKey: "keyStorePassword")
                encoder.encode(defaultRedirectURL, forKey: "defaultRedirectUrl")
                encoder.encode(userIDAttribute, forKey: "userIDAttribute")
                encoder.encode(useEncryption, forKey: "useEncryption")
                encoder.encode(isCreateUser, forKey: "createUser")
                encoder.encode(isAddGroupMemberships, forKey: "addGroupMemberships")
                encoder.encode(groupMembershipAttribute, forKey: "groupMembershipAttribute")
                encoder.encode(defaultGroups, forKey: "defaultGroups")
                encoder.encode(nameIDFormat, forKey: "nameIdFormat")
                encoder.encode(synchronizeAttributes, forKey: "synchronizeAttributes")
                encoder.encode(isHandleLogout, forKey: "handleLogout")
                encoder.encode(logoutURL, forKey: "logoutUrl")
                encoder.encode(clockTolerance, forKey: "clockTolerance")
                encoder.encode(digestMethod, forKey: "digestMethod")
                encoder.encode(signatureMethod, forKey: "signatureMethod")
                encoder.encode(userIntermediatePath, forKey: "userIntermediatePath")
                encoder.encode(propertylist, forKey: "propertylist", explode: false)
                return encoder.items
            }
        }
    }
}

extension Paths.System.Console {
    public var statusProductinfoJSON: StatusProductinfoJSON {
        StatusProductinfoJSON(path: path + "/status-productinfo.json")
    }

    public struct StatusProductinfoJSON {
        /// Path: `/system/console/status-productinfo.json`
        public let path: String

        public var get: Request<[String]> {
            .get(path)
        }
    }
}

extension Paths {
    public static func intermediatePath(_ intermediatePath: String) -> WithIntermediatePath {
        WithIntermediatePath(path: "/\(intermediatePath)")
    }

    public struct WithIntermediatePath {
        /// Path: `/{intermediatePath}`
        public let path: String
    }
}

extension Paths.WithIntermediatePath {
    public func authorizableID(_ authorizableID: String) -> WithKsHTML {
        WithKsHTML(path: "\(path)/\(authorizableID).ks.html")
    }

    public struct WithKsHTML {
        /// Path: `/{intermediatePath}/{authorizableId}.ks.html`
        public let path: String

        public func post(parameters: PostParameters? = nil, _ body: Data? = nil) -> Request<String> {
            .post(path, query: parameters?.asQuery, body: body)
        }

        public struct PostParameters {
            public var operation: String?
            public var currentPassword: String?
            public var newPassword: String?
            public var rePassword: String?
            public var keyPassword: String?
            public var keyStorePass: String?
            public var alias: String?
            public var newAlias: String?
            public var removeAlias: String?

            public init(operation: String? = nil, currentPassword: String? = nil, newPassword: String? = nil, rePassword: String? = nil, keyPassword: String? = nil, keyStorePass: String? = nil, alias: String? = nil, newAlias: String? = nil, removeAlias: String? = nil) {
                self.operation = operation
                self.currentPassword = currentPassword
                self.newPassword = newPassword
                self.rePassword = rePassword
                self.keyPassword = keyPassword
                self.keyStorePass = keyStorePass
                self.alias = alias
                self.newAlias = newAlias
                self.removeAlias = removeAlias
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(operation, forKey: ":operation")
                encoder.encode(currentPassword, forKey: "currentPassword")
                encoder.encode(newPassword, forKey: "newPassword")
                encoder.encode(rePassword, forKey: "rePassword")
                encoder.encode(keyPassword, forKey: "keyPassword")
                encoder.encode(keyStorePass, forKey: "keyStorePass")
                encoder.encode(alias, forKey: "alias")
                encoder.encode(newAlias, forKey: "newAlias")
                encoder.encode(removeAlias, forKey: "removeAlias")
                return encoder.items
            }
        }
    }
}

extension Paths.WithIntermediatePath {
    public func authorizableID(_ authorizableID: String) -> WithKsJSON {
        WithKsJSON(path: "\(path)/\(authorizableID).ks.json")
    }

    public struct WithKsJSON {
        /// Path: `/{intermediatePath}/{authorizableId}.ks.json`
        public let path: String

        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.WithIntermediatePath {
    public func authorizableID(_ authorizableID: String) -> WithAuthorizableID {
        WithAuthorizableID(path: "\(path)/\(authorizableID)")
    }

    public struct WithAuthorizableID {
        /// Path: `/{intermediatePath}/{authorizableId}`
        public let path: String
    }
}

extension Paths.WithIntermediatePath.WithAuthorizableID {
    public var keystore: Keystore {
        Keystore(path: path + "/keystore")
    }

    public struct Keystore {
        /// Path: `/{intermediatePath}/{authorizableId}/keystore`
        public let path: String
    }
}

extension Paths.WithIntermediatePath.WithAuthorizableID.Keystore {
    public var storeP12: StoreP12 {
        StoreP12(path: path + "/store.p12")
    }

    public struct StoreP12 {
        /// Path: `/{intermediatePath}/{authorizableId}/keystore/store.p12`
        public let path: String

        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.Libs.Granite.Security.Post {
    public var sslSetupHTML: SSLSetupHTML {
        SSLSetupHTML(path: path + "/sslSetup.html")
    }

    public struct SSLSetupHTML {
        /// Path: `/libs/granite/security/post/sslSetup.html`
        public let path: String

        public func post(parameters: PostParameters, _ body: Data? = nil) -> Request<String> {
            .post(path, query: parameters.asQuery, body: body)
        }

        public struct PostParameters {
            public var keystorePassword: String
            public var keystorePasswordConfirm: String
            public var truststorePassword: String
            public var truststorePasswordConfirm: String
            public var httpsHostname: String
            public var httpsPort: String

            public init(keystorePassword: String, keystorePasswordConfirm: String, truststorePassword: String, truststorePasswordConfirm: String, httpsHostname: String, httpsPort: String) {
                self.keystorePassword = keystorePassword
                self.keystorePasswordConfirm = keystorePasswordConfirm
                self.truststorePassword = truststorePassword
                self.truststorePasswordConfirm = truststorePasswordConfirm
                self.httpsHostname = httpsHostname
                self.httpsPort = httpsPort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(keystorePassword, forKey: "keystorePassword")
                encoder.encode(keystorePasswordConfirm, forKey: "keystorePasswordConfirm")
                encoder.encode(truststorePassword, forKey: "truststorePassword")
                encoder.encode(truststorePasswordConfirm, forKey: "truststorePasswordConfirm")
                encoder.encode(httpsHostname, forKey: "httpsHostname")
                encoder.encode(httpsPort, forKey: "httpsPort")
                return encoder.items
            }
        }
    }
}

public enum Paths {}
