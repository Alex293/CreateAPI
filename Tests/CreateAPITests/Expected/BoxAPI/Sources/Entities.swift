// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

/// A token that can be used to make authenticated API calls.
public struct AccessToken: Codable {
    /// The requested access token.
    ///
    /// Example: "c3FIOG9vSGV4VHo4QzAyg5T1JvNnJoZ3ExaVNyQWw6WjRsanRKZG5lQk9qUE1BVQ"
    public var accessToken: String?
    /// The time in seconds in seconds by which this token will expire.
    ///
    /// Example: 3600
    public var expiresIn: Int?
    /// The type of downscoped access token returned. This is only
    /// returned if an access token has been downscoped.
    ///
    /// Example: "urn:ietf:params:oauth:token-type:access_token"
    public var issuedTokenType: IssuedTokenType?
    /// The refresh token for this access token, which can be used
    /// to request a new access token when the current one expires.
    ///
    /// Example: "c3FIOG9vSGV4VHo4QzAyg5T1JvNnJoZ3ExaVNyQWw6WjRsanRKZG5lQk9qUE1BVQ"
    public var refreshToken: String?
    /// The permissions that this access token permits,
    /// providing a list of resources (files, folders, etc)
    /// and the scopes permitted for each of those resources.
    public var restrictedTo: [FileScope]?
    /// The type of access token returned.
    ///
    /// Example: "bearer"
    public var tokenType: TokenType?

    /// The type of downscoped access token returned. This is only
    /// returned if an access token has been downscoped.
    ///
    /// Example: "urn:ietf:params:oauth:token-type:access_token"
    public enum IssuedTokenType: String, Codable, CaseIterable {
        case urnIetfParamsOauthTokenTypeAccessToken = "urn:ietf:params:oauth:token-type:access_token"
    }

    /// The type of access token returned.
    ///
    /// Example: "bearer"
    public enum TokenType: String, Codable, CaseIterable {
        case bearer
    }

    public init(accessToken: String? = nil, expiresIn: Int? = nil, issuedTokenType: IssuedTokenType? = nil, refreshToken: String? = nil, restrictedTo: [FileScope]? = nil, tokenType: TokenType? = nil) {
        self.accessToken = accessToken
        self.expiresIn = expiresIn
        self.issuedTokenType = issuedTokenType
        self.refreshToken = refreshToken
        self.restrictedTo = restrictedTo
        self.tokenType = tokenType
    }

    private enum CodingKeys: String, CodingKey {
        case accessToken = "access_token"
        case expiresIn = "expires_in"
        case issuedTokenType = "issued_token_type"
        case refreshToken = "refresh_token"
        case restrictedTo = "restricted_to"
        case tokenType = "token_type"
    }
}

/// An instance of the classification metadata template, containing
/// the classification applied to the file or folder.
/// 
/// To get more details about the classification applied to an item,
/// request the classification metadata template.
public struct Classification: Codable {
    /// Whether an end user can change the classification.
    ///
    /// Example: true
    public var canEdit: Bool?
    /// The identifier of the item that this metadata instance
    /// has been attached to. This combines the `type` and the `id`
    /// of the parent in the form `{type}_{id}`.
    ///
    /// Example: "folder_59449484661,"
    public var parent: String?
    /// The scope of the enterprise that this classification has been
    /// applied for.
    /// 
    /// This will be in the format `enterprise_{enterprise_id}`.
    ///
    /// Example: "enterprise_27335"
    public var scope: String?
    /// `securityClassification-6VMVochwUWo`
    ///
    /// Example: "securityClassification-6VMVochwUWo"
    public var template: Template?
    /// The unique ID of this classification instance. This will be include
    /// the name of the classification template and a unique ID.
    ///
    /// Example: "securityClassification-6VMVochwUWo-fd31537a-0f95-4d86-9f2b-5974a29978f8"
    public var type: String?
    /// The version of the metadata template. This version starts at 0 and
    /// increases every time the template is updated. This is mostly for internal
    /// use.
    public var typeVersion: Double?
    /// The version of the metadata instance. This version starts at 0 and
    /// increases every time a classification is updated.
    public var version: Int?
    /// The name of the classification applied to the item.
    ///
    /// Example: "Sensitive"
    public var boxSecurityClassificationKey: String?

    /// `securityClassification-6VMVochwUWo`
    ///
    /// Example: "securityClassification-6VMVochwUWo"
    public enum Template: String, Codable, CaseIterable {
        case securityClassification6VMVochwUWo = "securityClassification-6VMVochwUWo"
    }

    public init(canEdit: Bool? = nil, parent: String? = nil, scope: String? = nil, template: Template? = nil, type: String? = nil, typeVersion: Double? = nil, version: Int? = nil, boxSecurityClassificationKey: String? = nil) {
        self.canEdit = canEdit
        self.parent = parent
        self.scope = scope
        self.template = template
        self.type = type
        self.typeVersion = typeVersion
        self.version = version
        self.boxSecurityClassificationKey = boxSecurityClassificationKey
    }

    private enum CodingKeys: String, CodingKey {
        case canEdit = "$canEdit"
        case parent = "$parent"
        case scope = "$scope"
        case template = "$template"
        case type = "$type"
        case typeVersion = "$typeVersion"
        case version = "$version"
        case boxSecurityClassificationKey = "Box__Security__Classification__Key"
    }
}

/// A metadata template that holds the security classifications
/// defined by an enterprise.
public struct ClassificationTemplate: Codable {
    /// Classifications are always copied along when the file or folder is
    /// copied.
    ///
    /// Example: true
    public var isCopyInstanceOnItemCopy: Bool?
    /// The name of this template as shown in web and mobile interfaces.
    ///
    /// Example: "Classification"
    public var displayName: DisplayName?
    /// A list of fields for this classification template. This includes
    /// only one field, the `Box__Security__Classification__Key`, which defines
    /// the different classifications available in this enterprise.
    public var fields: [Field]?
    /// This template is always available in web and mobile interfaces.
    ///
    /// Example: false
    public var isHidden: Bool?
    /// The ID of the classification template.
    ///
    /// Example: "58063d82-4128-7b43-bba9-92f706befcdf"
    public var id: String?
    /// The scope of the classification template. This is in the format
    /// `enterprise_{id}` where the `id` is the enterprise ID.
    ///
    /// Example: "enterprise_123456"
    public var scope: String?
    /// `securityClassification-6VMVochwUWo`
    ///
    /// Example: "securityClassification-6VMVochwUWo"
    public var templateKey: TemplateKey?
    /// `metadata_template`
    ///
    /// Example: "metadata_template"
    public var type: `Type`?

    /// The name of this template as shown in web and mobile interfaces.
    ///
    /// Example: "Classification"
    public enum DisplayName: String, Codable, CaseIterable {
        case classification = "Classification"
    }

    /// The metadata template field that represents the available
    /// classifications.
    public struct Field: Codable {
        /// `Classification`
        ///
        /// Example: "Classification"
        public var displayName: DisplayName?
        /// Classifications are always visible to web and mobile users.
        ///
        /// Example: false
        public var isHidden: Bool?
        /// The unique ID of the field.
        ///
        /// Example: "822227e0-47a5-921b-88a8-494760b2e6d2"
        public var id: String?
        /// `Box__Security__Classification__Key`
        ///
        /// Example: "Box__Security__Classification__Key"
        public var key: Key?
        /// A list of classifications available in this enterprise.
        public var options: [Option]?
        /// `enum`
        ///
        /// Example: "enum"
        public var type: `Type`?

        /// `Classification`
        ///
        /// Example: "Classification"
        public enum DisplayName: String, Codable, CaseIterable {
            case classification = "Classification"
        }

        /// `Box__Security__Classification__Key`
        ///
        /// Example: "Box__Security__Classification__Key"
        public enum Key: String, Codable, CaseIterable {
            case boxSecurityClassificationKey = "Box__Security__Classification__Key"
        }

        /// A single classification available in this enterprise.
        public struct Option: Codable {
            /// The unique ID of this classification.
            ///
            /// Example: "46aea176-3483-4431-856c-6b5b13d1cc50"
            public var id: String?
            /// The display name and key for this classification.
            ///
            /// Example: "Sensitive"
            public var key: String?
            /// Additional information about the classification.
            public var staticConfig: StaticConfig?

            /// Additional information about the classification.
            public struct StaticConfig: Codable {
                /// Additional information about the classification.
                /// 
                /// This is not an exclusive list of properties, and
                /// more object fields might be returned. These fields
                /// are used for internal Box Shield and Box Governance
                /// purposes and no additional value must be derived from
                /// these fields.
                public var classification: Classification?

                /// Additional information about the classification.
                /// 
                /// This is not an exclusive list of properties, and
                /// more object fields might be returned. These fields
                /// are used for internal Box Shield and Box Governance
                /// purposes and no additional value must be derived from
                /// these fields.
                public struct Classification: Codable {
                    /// A longer description of the classification.
                    ///
                    /// Example: "Sensitive information"
                    public var classificationDefinition: String?
                    /// An internal Box identifier used to assign a color to
                    /// a classification label.
                    /// 
                    /// Mapping between a `colorID` and a color may change
                    /// without notice. Currently, the color mappings are as
                    /// follows.
                    /// 
                    /// * `0`: Yellow
                    /// * `1`: Orange
                    /// * `2`: Watermelon red
                    /// * `3`: Purple rain
                    /// * `4`: Light blue
                    /// * `5`: Dark blue
                    /// * `6`: Light green
                    /// * `7`: Gray
                    public var colorID: Double?

                    public init(classificationDefinition: String? = nil, colorID: Double? = nil) {
                        self.classificationDefinition = classificationDefinition
                        self.colorID = colorID
                    }
                }

                public init(classification: Classification? = nil) {
                    self.classification = classification
                }
            }

            public init(id: String? = nil, key: String? = nil, staticConfig: StaticConfig? = nil) {
                self.id = id
                self.key = key
                self.staticConfig = staticConfig
            }
        }

        /// `enum`
        ///
        /// Example: "enum"
        public enum `Type`: String, Codable, CaseIterable {
            case `enum`
        }

        public init(displayName: DisplayName? = nil, isHidden: Bool? = nil, id: String? = nil, key: Key? = nil, options: [Option]? = nil, type: `Type`? = nil) {
            self.displayName = displayName
            self.isHidden = isHidden
            self.id = id
            self.key = key
            self.options = options
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case displayName
            case isHidden = "hidden"
            case id
            case key
            case options
            case type
        }
    }

    /// `securityClassification-6VMVochwUWo`
    ///
    /// Example: "securityClassification-6VMVochwUWo"
    public enum TemplateKey: String, Codable, CaseIterable {
        case securityClassification6VMVochwUWo = "securityClassification-6VMVochwUWo"
    }

    /// `metadata_template`
    ///
    /// Example: "metadata_template"
    public enum `Type`: String, Codable, CaseIterable {
        case metadataTemplate = "metadata_template"
    }

    public init(isCopyInstanceOnItemCopy: Bool? = nil, displayName: DisplayName? = nil, fields: [Field]? = nil, isHidden: Bool? = nil, id: String? = nil, scope: String? = nil, templateKey: TemplateKey? = nil, type: `Type`? = nil) {
        self.isCopyInstanceOnItemCopy = isCopyInstanceOnItemCopy
        self.displayName = displayName
        self.fields = fields
        self.isHidden = isHidden
        self.id = id
        self.scope = scope
        self.templateKey = templateKey
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case isCopyInstanceOnItemCopy = "copyInstanceOnItemCopy"
        case displayName
        case fields
        case isHidden = "hidden"
        case id
        case scope
        case templateKey
        case type
    }
}

/// A generic error
public struct ClientError: Codable {
    /// A Box-specific error code
    ///
    /// Example: "item_name_invalid"
    public var code: Code?
    /// A free-form object that contains additional context
    /// about the error. The possible fields are defined on
    /// a per-endpoint basis.
    public var contextInfo: [String: AnyJSON]?
    /// A URL that links to more information about why this error occurred.
    ///
    /// Example: "http://developers.box.com/docs/#errors"
    public var helpURL: String?
    /// A short message describing the error.
    ///
    /// Example: "Method Not Allowed"
    public var message: String?
    /// A unique identifier for this response, which can be used
    /// when contacting Box support.
    ///
    /// Example: "abcdef123456"
    public var requestID: String?
    /// The HTTP status of the response.
    ///
    /// Example: 400
    public var status: Int?
    /// `error`
    ///
    /// Example: "error"
    public var type: `Type`?

    /// A Box-specific error code
    ///
    /// Example: "item_name_invalid"
    public enum Code: String, Codable, CaseIterable {
        case created
        case accepted
        case noContent = "no_content"
        case redirect
        case notModified = "not_modified"
        case badRequest = "bad_request"
        case unauthorized
        case forbidden
        case notFound = "not_found"
        case methodNotAllowed = "method_not_allowed"
        case conflict
        case preconditionFailed = "precondition_failed"
        case tooManyRequests = "too_many_requests"
        case internalServerError = "internal_server_error"
        case unavailable
        case itemNameInvalid = "item_name_invalid"
        case insufficientScope = "insufficient_scope"
    }

    /// `error`
    ///
    /// Example: "error"
    public enum `Type`: String, Codable, CaseIterable {
        case error
    }

    public init(code: Code? = nil, contextInfo: [String: AnyJSON]? = nil, helpURL: String? = nil, message: String? = nil, requestID: String? = nil, status: Int? = nil, type: `Type`? = nil) {
        self.code = code
        self.contextInfo = contextInfo
        self.helpURL = helpURL
        self.message = message
        self.requestID = requestID
        self.status = status
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case code
        case contextInfo = "context_info"
        case helpURL = "help_url"
        case message
        case requestID = "request_id"
        case status
        case type
    }
}

/// Collaborations define access permissions for users and groups to files and
/// folders, similar to access control lists. A collaboration object grants a
/// user or group access to a file or folder with permissions defined by a
/// specific role.
public struct Collaboration: Codable {
    public var acceptanceRequirementsStatus: AcceptanceRequirementsStatus?
    public var accessibleBy: AccessibleBy?
    /// When the `status` of the collaboration object changed to
    /// `accepted` or `rejected`
    ///
    /// Example: "2012-12-12T10:55:20-08:00"
    public var acknowledgedAt: Date?
    /// When the collaboration object was created
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var createdAt: Date?
    public var createdBy: CreatedBy?
    /// When the collaboration will expire, or `null` if no expiration
    /// date is set.
    ///
    /// Example: "2012-12-26T10:53:43-08:00"
    public var expiresAt: Date?
    /// The unique identifier for this collaboration.
    ///
    /// Example: "12345678"
    public var id: String?
    /// The email address used to invite an unregistered collaborator, if
    /// they are not a registered user.
    ///
    /// Example: "john@example.com"
    public var inviteEmail: String?
    public var item: Item?
    /// When the collaboration object was last modified
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var modifiedAt: Date?
    /// The level of access granted.
    ///
    /// Example: "editor"
    public var role: Role?
    /// The status of the collaboration invitation.
    ///
    /// Example: "accepted"
    public var status: Status?
    /// `collaboration`
    ///
    /// Example: "collaboration"
    public var type: `Type`?

    public struct AcceptanceRequirementsStatus: Codable {
        public var strongPasswordRequirement: StrongPasswordRequirement?
        public var termsOfServiceRequirement: TermsOfServiceRequirement?
        public var twoFactorAuthenticationRequirement: TwoFactorAuthenticationRequirement?

        public struct StrongPasswordRequirement: Codable {
            /// Whether or not the enterprise that owns the content requires
            /// a strong password to collaborate on the content.
            ///
            /// Example: true
            public var enterpriseHasStrongPasswordRequiredForExternalUsers: Bool?
            /// Whether or not the user has a strong password set for their
            /// account. The field is `null` when a strong password is not
            /// required.
            ///
            /// Example: true
            public var userHasStrongPassword: Bool?

            public init(enterpriseHasStrongPasswordRequiredForExternalUsers: Bool? = nil, userHasStrongPassword: Bool? = nil) {
                self.enterpriseHasStrongPasswordRequiredForExternalUsers = enterpriseHasStrongPasswordRequiredForExternalUsers
                self.userHasStrongPassword = userHasStrongPassword
            }

            private enum CodingKeys: String, CodingKey {
                case enterpriseHasStrongPasswordRequiredForExternalUsers = "enterprise_has_strong_password_required_for_external_users"
                case userHasStrongPassword = "user_has_strong_password"
            }
        }

        public struct TermsOfServiceRequirement: Codable {
            /// Whether or not the terms of service have been accepted.  The
            /// field is `null` when there is no terms of service required.
            ///
            /// Example: true
            public var isAccepted: Bool?
            public var termsOfService: TermsOfService?

            public struct TermsOfService: Codable {
                /// Terms of service (Mini)
                ///
                /// The root-level record that is supposed to represent a
                /// single Terms of Service.
                public var termsOfServiceMini: TermsOfServiceMini
                /// The terms of service that must be accepted before the
                /// collaboration can be accepted. The field is `null` when
                /// there is no terms of service required.
                public var anyJSON: AnyJSON

                public init(termsOfServiceMini: TermsOfServiceMini, anyJSON: AnyJSON) {
                    self.termsOfServiceMini = termsOfServiceMini
                    self.anyJSON = anyJSON
                }

                public init(from decoder: Decoder) throws {
                    self.termsOfServiceMini = try TermsOfServiceMini(from: decoder)
                    self.anyJSON = try AnyJSON(from: decoder)
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encode(termsOfServiceMini, forKey: "termsOfServiceMini")
                    try values.encode(anyJSON, forKey: "anyJSON")
                }
            }

            public init(isAccepted: Bool? = nil, termsOfService: TermsOfService? = nil) {
                self.isAccepted = isAccepted
                self.termsOfService = termsOfService
            }

            private enum CodingKeys: String, CodingKey {
                case isAccepted = "is_accepted"
                case termsOfService = "terms_of_service"
            }
        }

        public struct TwoFactorAuthenticationRequirement: Codable {
            /// Whether or not the enterprise that owns the content requires
            /// two-factor authentication to be enabled in order to
            /// collaborate on the content.
            ///
            /// Example: true
            public var enterpriseHasTwoFactorAuthEnabled: Bool?
            /// Whether or not the user has two-factor authentication
            /// enabled. The field is `null` when two-factor
            /// authentication is not required.
            ///
            /// Example: true
            public var userHasTwoFactorAuthenticationEnabled: Bool?

            public init(enterpriseHasTwoFactorAuthEnabled: Bool? = nil, userHasTwoFactorAuthenticationEnabled: Bool? = nil) {
                self.enterpriseHasTwoFactorAuthEnabled = enterpriseHasTwoFactorAuthEnabled
                self.userHasTwoFactorAuthenticationEnabled = userHasTwoFactorAuthenticationEnabled
            }

            private enum CodingKeys: String, CodingKey {
                case enterpriseHasTwoFactorAuthEnabled = "enterprise_has_two_factor_auth_enabled"
                case userHasTwoFactorAuthenticationEnabled = "user_has_two_factor_authentication_enabled"
            }
        }

        public init(strongPasswordRequirement: StrongPasswordRequirement? = nil, termsOfServiceRequirement: TermsOfServiceRequirement? = nil, twoFactorAuthenticationRequirement: TwoFactorAuthenticationRequirement? = nil) {
            self.strongPasswordRequirement = strongPasswordRequirement
            self.termsOfServiceRequirement = termsOfServiceRequirement
            self.twoFactorAuthenticationRequirement = twoFactorAuthenticationRequirement
        }

        private enum CodingKeys: String, CodingKey {
            case strongPasswordRequirement = "strong_password_requirement"
            case termsOfServiceRequirement = "terms_of_service_requirement"
            case twoFactorAuthenticationRequirement = "two_factor_authentication_requirement"
        }
    }

    public struct AccessibleBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user or group that is granted access
        public var anyJSON: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct CreatedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user who created the collaboration object
        public var anyJSON: AnyJSON
        /// Example:
        ///
        /// [
        ///   {
        ///     "id" : 33224412
        ///   },
        ///   {
        ///     "type" : "user"
        ///   },
        ///   {
        ///     "login" : "dylan@example.com"
        ///   },
        ///   {
        ///     "name" : "Dylan Smith"
        ///   }
        /// ]
        public var anyJSON2: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON, anyJSON2: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
            self.anyJSON2 = anyJSON2
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
            self.anyJSON2 = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
            try values.encode(anyJSON2, forKey: "anyJSON2")
        }
    }

    public struct Item: Codable {
        public var object: Object
        /// The file or folder to which access is granted. The field is
        /// `null` when the collaboration `status` is `pending`.
        public var anyJSON: AnyJSON

        public enum Object: Codable {
            case file(File)
            case folder(Folder)
            case webLink(WebLink)

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(File.self) {
                    self = .file(value)
                } else if let value = try? container.decode(Folder.self) {
                    self = .folder(value)
                } else if let value = try? container.decode(WebLink.self) {
                    self = .webLink(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .file(let value): try container.encode(value)
                case .folder(let value): try container.encode(value)
                case .webLink(let value): try container.encode(value)
                }
            }
        }

        public init(object: Object, anyJSON: AnyJSON) {
            self.object = object
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.object = try Object(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(object, forKey: "object")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// The level of access granted.
    ///
    /// Example: "editor"
    public enum Role: String, Codable, CaseIterable {
        case editor
        case viewer
        case previewer
        case uploader
        case previewerUploader = "previewer uploader"
        case viewerUploader = "viewer uploader"
        case coOwner = "co-owner"
        case owner
    }

    /// The status of the collaboration invitation.
    ///
    /// Example: "accepted"
    public enum Status: String, Codable, CaseIterable {
        case accepted
        case pending
        case rejected
    }

    /// `collaboration`
    ///
    /// Example: "collaboration"
    public enum `Type`: String, Codable, CaseIterable {
        case collaboration
    }

    public init(acceptanceRequirementsStatus: AcceptanceRequirementsStatus? = nil, accessibleBy: AccessibleBy? = nil, acknowledgedAt: Date? = nil, createdAt: Date? = nil, createdBy: CreatedBy? = nil, expiresAt: Date? = nil, id: String? = nil, inviteEmail: String? = nil, item: Item? = nil, modifiedAt: Date? = nil, role: Role? = nil, status: Status? = nil, type: `Type`? = nil) {
        self.acceptanceRequirementsStatus = acceptanceRequirementsStatus
        self.accessibleBy = accessibleBy
        self.acknowledgedAt = acknowledgedAt
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.expiresAt = expiresAt
        self.id = id
        self.inviteEmail = inviteEmail
        self.item = item
        self.modifiedAt = modifiedAt
        self.role = role
        self.status = status
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case acceptanceRequirementsStatus = "acceptance_requirements_status"
        case accessibleBy = "accessible_by"
        case acknowledgedAt = "acknowledged_at"
        case createdAt = "created_at"
        case createdBy = "created_by"
        case expiresAt = "expires_at"
        case id
        case inviteEmail = "invite_email"
        case item
        case modifiedAt = "modified_at"
        case role
        case status
        case type
    }
}

/// Allowed collaboration domains
///
/// A list of allowed domains for collaboration.
public struct CollaborationAllowlistEntries: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The marker for the start of the next page of results.
    ///
    /// Example: 3000
    public var nextMarker: Int?
    /// The marker for the start of the previous page of results.
    ///
    /// Example: 1000
    public var prevMarker: Int?
    public var entries: [CollaborationAllowlistEntry]?

    public init(limit: Int? = nil, nextMarker: Int? = nil, prevMarker: Int? = nil, entries: [CollaborationAllowlistEntry]? = nil) {
        self.limit = limit
        self.nextMarker = nextMarker
        self.prevMarker = prevMarker
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.nextMarker = try values.decodeIfPresent(Int.self, forKey: "next_marker")
        self.prevMarker = try values.decodeIfPresent(Int.self, forKey: "prev_marker")
        self.entries = try values.decodeIfPresent([CollaborationAllowlistEntry].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(nextMarker, forKey: "next_marker")
        try values.encodeIfPresent(prevMarker, forKey: "prev_marker")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// Allowed collaboration domain
///
/// An entry that describes an approved domain for which users can collaborate
/// with files and folders in your enterprise or vice versa.
public struct CollaborationAllowlistEntry: Codable {
    /// The time the entry was created at
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var createdAt: Date?
    /// The direction of the collaborations to allow.
    ///
    /// Example: "both"
    public var direction: Direction?
    /// The whitelisted domain
    ///
    /// Example: "example.com"
    public var domain: String?
    public var enterprise: Enterprise?
    /// The unique identifier for this entry
    ///
    /// Example: "11446498"
    public var id: String?
    /// `collaboration_whitelist_entry`
    ///
    /// Example: "collaboration_whitelist_entry"
    public var type: `Type`?

    /// The direction of the collaborations to allow.
    ///
    /// Example: "both"
    public enum Direction: String, Codable, CaseIterable {
        case inbound
        case outbound
        case both
    }

    public struct Enterprise: Codable {
        /// The unique identifier for this enterprise.
        ///
        /// Example: "11446498"
        public var id: String?
        /// The name of the enterprise
        ///
        /// Example: "Acme Inc."
        public var name: String?
        /// `enterprise`
        ///
        /// Example: "enterprise"
        public var type: `Type`?
        /// The enterprise this list is applied to
        public var anyJSON: AnyJSON

        /// `enterprise`
        ///
        /// Example: "enterprise"
        public enum `Type`: String, Codable, CaseIterable {
            case enterprise
        }

        public init(id: String? = nil, name: String? = nil, type: `Type`? = nil, anyJSON: AnyJSON) {
            self.id = id
            self.name = name
            self.type = type
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.type = try `Type`(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(type, forKey: "type")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// `collaboration_whitelist_entry`
    ///
    /// Example: "collaboration_whitelist_entry"
    public enum `Type`: String, Codable, CaseIterable {
        case collaborationWhitelistEntry = "collaboration_whitelist_entry"
    }

    public init(createdAt: Date? = nil, direction: Direction? = nil, domain: String? = nil, enterprise: Enterprise? = nil, id: String? = nil, type: `Type`? = nil) {
        self.createdAt = createdAt
        self.direction = direction
        self.domain = domain
        self.enterprise = enterprise
        self.id = id
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case direction
        case domain
        case enterprise
        case id
        case type
    }
}

/// Allowed collaboration domains user exemption
///
/// The user that is exempt from any of the restrictions
/// imposed by the list of allowed collaboration domains for this enterprise.
public struct CollaborationAllowlistExemptTarget: Codable {
    /// The time the entry was created
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var createdAt: Date?
    public var enterprise: Enterprise?
    /// The unique identifier for this exemption
    ///
    /// Example: "11446498"
    public var id: String?
    /// The time the entry was modified
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var modifiedAt: Date?
    /// `collaboration_whitelist`
    ///
    /// Example: "collaboration_whitelist"
    public var type: `Type`?
    public var user: User?

    public struct Enterprise: Codable {
        /// The unique identifier for this enterprise.
        ///
        /// Example: "11446498"
        public var id: String?
        /// The name of the enterprise
        ///
        /// Example: "Acme Inc."
        public var name: String?
        /// `enterprise`
        ///
        /// Example: "enterprise"
        public var type: `Type`?
        /// The enterprise this entry belongs to
        public var anyJSON: AnyJSON

        /// `enterprise`
        ///
        /// Example: "enterprise"
        public enum `Type`: String, Codable, CaseIterable {
            case enterprise
        }

        public init(id: String? = nil, name: String? = nil, type: `Type`? = nil, anyJSON: AnyJSON) {
            self.id = id
            self.name = name
            self.type = type
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.type = try `Type`(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(type, forKey: "type")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// `collaboration_whitelist`
    ///
    /// Example: "collaboration_whitelist"
    public enum `Type`: String, Codable, CaseIterable {
        case collaborationWhitelist = "collaboration_whitelist"
    }

    public struct User: Codable {
        /// The unique identifier for this enterprise.
        ///
        /// Example: "11446498"
        public var id: String?
        /// The name of the enterprise
        ///
        /// Example: "Acme Inc."
        public var name: String?
        /// `enterprise`
        ///
        /// Example: "enterprise"
        public var type: `Type`?
        /// The user that has been exempt
        public var anyJSON: AnyJSON

        /// `enterprise`
        ///
        /// Example: "enterprise"
        public enum `Type`: String, Codable, CaseIterable {
            case enterprise
        }

        public init(id: String? = nil, name: String? = nil, type: `Type`? = nil, anyJSON: AnyJSON) {
            self.id = id
            self.name = name
            self.type = type
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.type = try `Type`(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(type, forKey: "type")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(createdAt: Date? = nil, enterprise: Enterprise? = nil, id: String? = nil, modifiedAt: Date? = nil, type: `Type`? = nil, user: User? = nil) {
        self.createdAt = createdAt
        self.enterprise = enterprise
        self.id = id
        self.modifiedAt = modifiedAt
        self.type = type
        self.user = user
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case enterprise
        case id
        case modifiedAt = "modified_at"
        case type
        case user
    }
}

/// Allowed collaboration domains user exemptions
///
/// A list of users that is exempt from any of the restrictions
/// imposed by the list of allowed collaboration domains for this enterprise.
public struct CollaborationAllowlistExemptTargets: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The marker for the start of the next page of results.
    ///
    /// Example: 3000
    public var nextMarker: Int?
    /// The marker for the start of the previous page of results.
    ///
    /// Example: 1000
    public var prevMarker: Int?
    public var entries: [CollaborationAllowlistExemptTarget]?

    public init(limit: Int? = nil, nextMarker: Int? = nil, prevMarker: Int? = nil, entries: [CollaborationAllowlistExemptTarget]? = nil) {
        self.limit = limit
        self.nextMarker = nextMarker
        self.prevMarker = prevMarker
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.nextMarker = try values.decodeIfPresent(Int.self, forKey: "next_marker")
        self.prevMarker = try values.decodeIfPresent(Int.self, forKey: "prev_marker")
        self.entries = try values.decodeIfPresent([CollaborationAllowlistExemptTarget].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(nextMarker, forKey: "next_marker")
        try values.encodeIfPresent(prevMarker, forKey: "prev_marker")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// A list of collaborations
public struct Collaborations: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The 0-based offset of the first entry in this set. This will be the same
    /// as the `offset` query parameter.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    ///
    /// Example: 2000
    public var offset: Int?
    /// The order by which items are returned.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    public var order: [OrderItem]?
    /// One greater than the offset of the last entry in the entire collection.
    /// The total number of entries in the collection may be less than
    /// `total_count`.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    ///
    /// Example: 5000
    public var totalCount: Int?
    public var entries: [Collaboration]?

    /// The order in which a pagination is ordered
    public struct OrderItem: Codable {
        /// The field to order by
        ///
        /// Example: "type"
        public var by: String?
        /// The direction to order by, either ascending or descending
        ///
        /// Example: "ASC"
        public var direction: Direction?

        /// The direction to order by, either ascending or descending
        ///
        /// Example: "ASC"
        public enum Direction: String, Codable, CaseIterable {
            case asc = "ASC"
            case desc = "DESC"
        }

        public init(by: String? = nil, direction: Direction? = nil) {
            self.by = by
            self.direction = direction
        }
    }

    public init(limit: Int? = nil, offset: Int? = nil, order: [OrderItem]? = nil, totalCount: Int? = nil, entries: [Collaboration]? = nil) {
        self.limit = limit
        self.offset = offset
        self.order = order
        self.totalCount = totalCount
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.offset = try values.decodeIfPresent(Int.self, forKey: "offset")
        self.order = try values.decodeIfPresent([OrderItem].self, forKey: "order")
        self.totalCount = try values.decodeIfPresent(Int.self, forKey: "total_count")
        self.entries = try values.decodeIfPresent([Collaboration].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(offset, forKey: "offset")
        try values.encodeIfPresent(order, forKey: "order")
        try values.encodeIfPresent(totalCount, forKey: "total_count")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// A collection of items, including files and folders.
/// 
/// Currently, the only collection available
/// is the `favorites` collection.
/// 
/// The contents of a collection can be explored in a
/// similar way to which the contents of a folder is
/// explored.
public struct Collection: Codable {
    /// The type of the collection. This is used to
    /// determine the proper visual treatment for
    /// collections.
    ///
    /// Example: "favorites"
    public var collectionType: CollectionType?
    /// The unique identifier for this collection.
    ///
    /// Example: "11446498"
    public var id: String?
    /// The name of the collection.
    ///
    /// Example: "Favorites"
    public var name: Name?
    /// `collection`
    ///
    /// Example: "collection"
    public var type: `Type`?

    /// The type of the collection. This is used to
    /// determine the proper visual treatment for
    /// collections.
    ///
    /// Example: "favorites"
    public enum CollectionType: String, Codable, CaseIterable {
        case favorites
    }

    /// The name of the collection.
    ///
    /// Example: "Favorites"
    public enum Name: String, Codable, CaseIterable {
        case favorites = "Favorites"
    }

    /// `collection`
    ///
    /// Example: "collection"
    public enum `Type`: String, Codable, CaseIterable {
        case collection
    }

    public init(collectionType: CollectionType? = nil, id: String? = nil, name: Name? = nil, type: `Type`? = nil) {
        self.collectionType = collectionType
        self.id = id
        self.name = name
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case collectionType = "collection_type"
        case id
        case name
        case type
    }
}

/// A list of collections
public struct Collections: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The 0-based offset of the first entry in this set. This will be the same
    /// as the `offset` query parameter.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    ///
    /// Example: 2000
    public var offset: Int?
    /// The order by which items are returned.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    public var order: [OrderItem]?
    /// One greater than the offset of the last entry in the entire collection.
    /// The total number of entries in the collection may be less than
    /// `total_count`.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    ///
    /// Example: 5000
    public var totalCount: Int?
    public var entries: [Collection]?

    /// The order in which a pagination is ordered
    public struct OrderItem: Codable {
        /// The field to order by
        ///
        /// Example: "type"
        public var by: String?
        /// The direction to order by, either ascending or descending
        ///
        /// Example: "ASC"
        public var direction: Direction?

        /// The direction to order by, either ascending or descending
        ///
        /// Example: "ASC"
        public enum Direction: String, Codable, CaseIterable {
            case asc = "ASC"
            case desc = "DESC"
        }

        public init(by: String? = nil, direction: Direction? = nil) {
            self.by = by
            self.direction = direction
        }
    }

    public init(limit: Int? = nil, offset: Int? = nil, order: [OrderItem]? = nil, totalCount: Int? = nil, entries: [Collection]? = nil) {
        self.limit = limit
        self.offset = offset
        self.order = order
        self.totalCount = totalCount
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.offset = try values.decodeIfPresent(Int.self, forKey: "offset")
        self.order = try values.decodeIfPresent([OrderItem].self, forKey: "order")
        self.totalCount = try values.decodeIfPresent(Int.self, forKey: "total_count")
        self.entries = try values.decodeIfPresent([Collection].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(offset, forKey: "offset")
        try values.encodeIfPresent(order, forKey: "order")
        try values.encodeIfPresent(totalCount, forKey: "total_count")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// Standard representation of a comment.
public struct Comment: Codable {
    /// Comment (Base)
    ///
    /// Base representation of a comment.
    public var commentBase: CommentBase
    /// The time this comment was created
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var createdAt: Date?
    public var createdBy: CreatedBy?
    /// Whether or not this comment is a reply to another
    /// comment
    ///
    /// Example: true
    public var isReplyComment: Bool?
    public var item: Item?
    /// The text of the comment, as provided by the user
    ///
    /// Example: "@Aaron Levie these tigers are cool!"
    public var message: String?
    /// The time this comment was last modified
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var modifiedAt: Date?

    public struct CreatedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// A mini user object representing the author of the
        /// comment
        public var anyJSON: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Item: Codable {
        /// The unique identifier for this object
        ///
        /// Example: "11446498"
        public var id: String?
        /// The type for this object
        ///
        /// Example: "file"
        public var type: String?
        /// The file this comment was placed on
        public var anyJSON: AnyJSON

        public init(id: String? = nil, type: String? = nil, anyJSON: AnyJSON) {
            self.id = id
            self.type = type
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.type = try values.decodeIfPresent(String.self, forKey: "type")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(type, forKey: "type")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(commentBase: CommentBase, createdAt: Date? = nil, createdBy: CreatedBy? = nil, isReplyComment: Bool? = nil, item: Item? = nil, message: String? = nil, modifiedAt: Date? = nil) {
        self.commentBase = commentBase
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.isReplyComment = isReplyComment
        self.item = item
        self.message = message
        self.modifiedAt = modifiedAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.commentBase = try CommentBase(from: decoder)
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
        self.createdBy = try CreatedBy(from: decoder)
        self.isReplyComment = try values.decodeIfPresent(Bool.self, forKey: "is_reply_comment")
        self.item = try Item(from: decoder)
        self.message = try values.decodeIfPresent(String.self, forKey: "message")
        self.modifiedAt = try values.decodeIfPresent(Date.self, forKey: "modified_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(commentBase, forKey: "commentBase")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(createdBy, forKey: "created_by")
        try values.encodeIfPresent(isReplyComment, forKey: "is_reply_comment")
        try values.encodeIfPresent(item, forKey: "item")
        try values.encodeIfPresent(message, forKey: "message")
        try values.encodeIfPresent(modifiedAt, forKey: "modified_at")
    }
}

/// Comment (Base)
///
/// Base representation of a comment.
public struct CommentBase: Codable {
    /// The unique identifier for this comment.
    ///
    /// Example: "11446498"
    public var id: String?
    /// `comment`
    ///
    /// Example: "comment"
    public var type: `Type`?

    /// `comment`
    ///
    /// Example: "comment"
    public enum `Type`: String, Codable, CaseIterable {
        case comment
    }

    public init(id: String? = nil, type: `Type`? = nil) {
        self.id = id
        self.type = type
    }
}

/// Comment (Full)
///
/// Comments are messages created on files. Comments
/// can be made independently or created as responses to other
/// comments
public struct CommentFull: Codable {
    /// Standard representation of a comment.
    public var comment: Comment
    /// The string representing the comment text with
    /// @mentions included. @mention format is @[id:username]
    /// where `id` is user's Box ID and `username` is
    /// their display name.
    ///
    /// Example: "@[1234567:Aaron Levie] these tigers are cool!"
    public var taggedMessage: String?

    public init(comment: Comment, taggedMessage: String? = nil) {
        self.comment = comment
        self.taggedMessage = taggedMessage
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.comment = try Comment(from: decoder)
        self.taggedMessage = try values.decodeIfPresent(String.self, forKey: "tagged_message")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(comment, forKey: "comment")
        try values.encodeIfPresent(taggedMessage, forKey: "tagged_message")
    }
}

/// A list of comments
public struct Comments: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The 0-based offset of the first entry in this set. This will be the same
    /// as the `offset` query parameter.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    ///
    /// Example: 2000
    public var offset: Int?
    /// The order by which items are returned.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    public var order: [OrderItem]?
    /// One greater than the offset of the last entry in the entire collection.
    /// The total number of entries in the collection may be less than
    /// `total_count`.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    ///
    /// Example: 5000
    public var totalCount: Int?
    public var entries: [Comment]?

    /// The order in which a pagination is ordered
    public struct OrderItem: Codable {
        /// The field to order by
        ///
        /// Example: "type"
        public var by: String?
        /// The direction to order by, either ascending or descending
        ///
        /// Example: "ASC"
        public var direction: Direction?

        /// The direction to order by, either ascending or descending
        ///
        /// Example: "ASC"
        public enum Direction: String, Codable, CaseIterable {
            case asc = "ASC"
            case desc = "DESC"
        }

        public init(by: String? = nil, direction: Direction? = nil) {
            self.by = by
            self.direction = direction
        }
    }

    public init(limit: Int? = nil, offset: Int? = nil, order: [OrderItem]? = nil, totalCount: Int? = nil, entries: [Comment]? = nil) {
        self.limit = limit
        self.offset = offset
        self.order = order
        self.totalCount = totalCount
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.offset = try values.decodeIfPresent(Int.self, forKey: "offset")
        self.order = try values.decodeIfPresent([OrderItem].self, forKey: "order")
        self.totalCount = try values.decodeIfPresent(Int.self, forKey: "total_count")
        self.entries = try values.decodeIfPresent([Comment].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(offset, forKey: "offset")
        try values.encodeIfPresent(order, forKey: "order")
        try values.encodeIfPresent(totalCount, forKey: "total_count")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// The error that occurs when a file can not be created due
/// to a conflict.
public struct ConflictError: Codable {
    /// A generic error
    public var clientError: ClientError
    public var contextInfo: ContextInfo?

    public struct ContextInfo: Codable {
        /// A list of the file conflicts that caused this error.
        public var conflicts: [FileConflict]?

        public init(conflicts: [FileConflict]? = nil) {
            self.conflicts = conflicts
        }
    }

    public init(clientError: ClientError, contextInfo: ContextInfo? = nil) {
        self.clientError = clientError
        self.contextInfo = contextInfo
    }

    public init(from decoder: Decoder) throws {
        self.clientError = try ClientError(from: decoder)
        self.contextInfo = try ContextInfo(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(clientError, forKey: "clientError")
        try values.encodeIfPresent(contextInfo, forKey: "context_info")
    }
}

/// Device pins allow enterprises to control what devices can
/// use native Box applications.
public struct DevicePinner: Codable {
    /// The time the device pin was created
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var createdAt: Date?
    /// The unique identifier for this device pin.
    ///
    /// Example: "11446498"
    public var id: String?
    /// The time the device pin was modified
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var modifiedAt: Date?
    public var ownedBy: OwnedBy?
    /// The type of device being pinned
    ///
    /// Example: "iPad"
    public var productName: String?
    /// `device_pinner`
    ///
    /// Example: "device_pinner"
    public var type: `Type`?

    public struct OwnedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user that the device pin belongs to
        public var anyJSON: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// `device_pinner`
    ///
    /// Example: "device_pinner"
    public enum `Type`: String, Codable, CaseIterable {
        case devicePinner = "device_pinner"
    }

    public init(createdAt: Date? = nil, id: String? = nil, modifiedAt: Date? = nil, ownedBy: OwnedBy? = nil, productName: String? = nil, type: `Type`? = nil) {
        self.createdAt = createdAt
        self.id = id
        self.modifiedAt = modifiedAt
        self.ownedBy = ownedBy
        self.productName = productName
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case id
        case modifiedAt = "modified_at"
        case ownedBy = "owned_by"
        case productName = "product_name"
        case type
    }
}

/// A list of device pins
public struct DevicePinners: Codable {
    public var entries: [DevicePinner]?
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed.
    ///
    /// Example: 200
    public var limit: Int?
    /// The marker for the start of the next page of results.
    ///
    /// Example: 3000
    public var nextMarker: Int?
    /// The order by which items are returned.
    public var order: [OrderItem]?

    /// The order in which a pagination is ordered
    public struct OrderItem: Codable {
        /// The field that is ordered by
        ///
        /// Example: "id"
        public var by: By?
        /// The direction to order by, either ascending or descending
        ///
        /// Example: "asc"
        public var direction: Direction?

        /// The field that is ordered by
        ///
        /// Example: "id"
        public enum By: String, Codable, CaseIterable {
            case id
        }

        /// The direction to order by, either ascending or descending
        ///
        /// Example: "asc"
        public enum Direction: String, Codable, CaseIterable {
            case asc
            case desc
        }

        public init(by: By? = nil, direction: Direction? = nil) {
            self.by = by
            self.direction = direction
        }
    }

    public init(entries: [DevicePinner]? = nil, limit: Int? = nil, nextMarker: Int? = nil, order: [OrderItem]? = nil) {
        self.entries = entries
        self.limit = limit
        self.nextMarker = nextMarker
        self.order = order
    }

    private enum CodingKeys: String, CodingKey {
        case entries
        case limit
        case nextMarker = "next_marker"
        case order
    }
}

/// An email alias for a user.
public struct EmailAlias: Codable {
    /// The email address
    ///
    /// Example: "alias@example.com"
    public var email: String?
    /// The unique identifier for this object
    ///
    /// Example: "11446498"
    public var id: String?
    /// Whether the email address has been confirmed
    ///
    /// Example: true
    public var isConfirmed: Bool?
    /// `email_alias`
    ///
    /// Example: "email_alias"
    public var type: `Type`?

    /// `email_alias`
    ///
    /// Example: "email_alias"
    public enum `Type`: String, Codable, CaseIterable {
        case emailAlias = "email_alias"
    }

    public init(email: String? = nil, id: String? = nil, isConfirmed: Bool? = nil, type: `Type`? = nil) {
        self.email = email
        self.id = id
        self.isConfirmed = isConfirmed
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case email
        case id
        case isConfirmed = "is_confirmed"
        case type
    }
}

/// A list of email aliases
public struct EmailAliases: Codable {
    public var entries: [EmailAlias]?
    /// The number of email aliases.
    ///
    /// Example: 5000
    public var totalCount: Int?

    public init(entries: [EmailAlias]? = nil, totalCount: Int? = nil) {
        self.entries = entries
        self.totalCount = totalCount
    }

    private enum CodingKeys: String, CodingKey {
        case entries
        case totalCount = "total_count"
    }
}

/// The description of an event that happened within Box
public struct Event: Codable {
    /// This object provides additional information about the event if available.
    /// 
    /// This can include how a user performed an event as well as additional
    /// information to correlate an event to external KeySafe logs. Not all events
    /// have an `additional_details` object.  This object is only available in the
    /// Enterprise Events.
    ///
    /// Example:
    ///
    /// {
    ///   "key" : "value"
    /// }
    public var additionalDetails: [String: AnyJSON]?
    public var createdBy: CreatedBy?
    /// The ID of the event object. You can use this to detect duplicate events
    ///
    /// Example: "f82c3ba03e41f7e8a7608363cc6c0390183c3f83"
    public var eventID: String?
    public var eventType: EventType?
    /// The session of the user that performed the action. Not all events will
    /// populate this attribute.
    ///
    /// Example: "70090280850c8d2a1933c1"
    public var sessionID: String?
    public var source: Source?
    /// `event`
    ///
    /// Example: "event"
    public var type: String?

    public struct CreatedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user that performed the action represented by the event.
        /// Some events may be performed by users not logged into Box.
        /// In that case, not all attributes of the object are populated and the
        /// event is attributed to a unknown user (`user_id = 2`)
        public var anyJSON: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct EventType: Codable {
        /// Event Type
        ///
        /// An event type that can trigger an event
        ///
        /// Example: "FILE_MARKED_MALICIOUS"
        public var object: Object
        /// The event type that triggered this event
        public var anyJSON: AnyJSON

        /// Event Type
        ///
        /// An event type that can trigger an event
        ///
        /// Example: "FILE_MARKED_MALICIOUS"
        public enum Object: String, Codable, CaseIterable {
            case accessGranted = "ACCESS_GRANTED"
            case accessRevoked = "ACCESS_REVOKED"
            case addDeviceAssociation = "ADD_DEVICE_ASSOCIATION"
            case addLoginActivityDevice = "ADD_LOGIN_ACTIVITY_DEVICE"
            case adminLogin = "ADMIN_LOGIN"
            case applicationCreated = "APPLICATION_CREATED"
            case applicationPublicKeyAdded = "APPLICATION_PUBLIC_KEY_ADDED"
            case applicationPublicKeyDeleted = "APPLICATION_PUBLIC_KEY_DELETED"
            case changeAdminRole = "CHANGE_ADMIN_ROLE"
            case changeFolderPermission = "CHANGE_FOLDER_PERMISSION"
            case collaborationAccept = "COLLABORATION_ACCEPT"
            case collaborationExpiration = "COLLABORATION_EXPIRATION"
            case collaborationInvite = "COLLABORATION_INVITE"
            case collaborationRemove = "COLLABORATION_REMOVE"
            case collaborationRoleChange = "COLLABORATION_ROLE_CHANGE"
            case collabAddCollaborator = "COLLAB_ADD_COLLABORATOR"
            case collabInviteCollaborator = "COLLAB_INVITE_COLLABORATOR"
            case collabRemoveCollaborator = "COLLAB_REMOVE_COLLABORATOR"
            case collabRoleChange = "COLLAB_ROLE_CHANGE"
            case commentCreate = "COMMENT_CREATE"
            case commentDelete = "COMMENT_DELETE"
            case contentAccess = "CONTENT_ACCESS"
            case contentWorkflowAbnormalDownloadActivity = "CONTENT_WORKFLOW_ABNORMAL_DOWNLOAD_ACTIVITY"
            case contentWorkflowAutomationAdd = "CONTENT_WORKFLOW_AUTOMATION_ADD"
            case contentWorkflowAutomationDelete = "CONTENT_WORKFLOW_AUTOMATION_DELETE"
            case contentWorkflowPolicyAdd = "CONTENT_WORKFLOW_POLICY_ADD"
            case contentWorkflowSharingPolicyViolation = "CONTENT_WORKFLOW_SHARING_POLICY_VIOLATION"
            case contentWorkflowUploadPolicyViolation = "CONTENT_WORKFLOW_UPLOAD_POLICY_VIOLATION"
            case copy = "COPY"
            case dataRetentionCreateRetention = "DATA_RETENTION_CREATE_RETENTION"
            case dataRetentionRemoveRetention = "DATA_RETENTION_REMOVE_RETENTION"
            case delete = "DELETE"
            case deleteUser = "DELETE_USER"
            case deviceTrustCheckFailed = "DEVICE_TRUST_CHECK_FAILED"
            case download = "DOWNLOAD"
            case edit = "EDIT"
            case editUser = "EDIT_USER"
            case emailAliasConfirm = "EMAIL_ALIAS_CONFIRM"
            case emailAliasRemove = "EMAIL_ALIAS_REMOVE"
            case enableTwoFactorAuth = "ENABLE_TWO_FACTOR_AUTH"
            case enterpriseAppAuthorizationUpdate = "ENTERPRISE_APP_AUTHORIZATION_UPDATE"
            case failedLogin = "FAILED_LOGIN"
            case fileMarkedMalicious = "FILE_MARKED_MALICIOUS"
            case fileWatermarkedDownload = "FILE_WATERMARKED_DOWNLOAD"
            case groupAddItem = "GROUP_ADD_ITEM"
            case groupAddUser = "GROUP_ADD_USER"
            case groupCreation = "GROUP_CREATION"
            case groupDeletion = "GROUP_DELETION"
            case groupEdited = "GROUP_EDITED"
            case groupRemoveItem = "GROUP_REMOVE_ITEM"
            case groupRemoveUser = "GROUP_REMOVE_USER"
            case itemCopy = "ITEM_COPY"
            case itemCreate = "ITEM_CREATE"
            case itemDownload = "ITEM_DOWNLOAD"
            case itemMakeCurrentVersion = "ITEM_MAKE_CURRENT_VERSION"
            case itemModify = "ITEM_MODIFY"
            case itemMove = "ITEM_MOVE"
            case itemOpen = "ITEM_OPEN"
            case itemPreview = "ITEM_PREVIEW"
            case itemRename = "ITEM_RENAME"
            case itemShared = "ITEM_SHARED"
            case itemSharedCreate = "ITEM_SHARED_CREATE"
            case itemSharedUnshare = "ITEM_SHARED_UNSHARE"
            case itemSharedUpdate = "ITEM_SHARED_UPDATE"
            case itemSync = "ITEM_SYNC"
            case itemTrash = "ITEM_TRASH"
            case itemUndeleteViaTrash = "ITEM_UNDELETE_VIA_TRASH"
            case itemUnsync = "ITEM_UNSYNC"
            case itemUpload = "ITEM_UPLOAD"
            case legalHoldAssignmentCreate = "LEGAL_HOLD_ASSIGNMENT_CREATE"
            case legalHoldAssignmentDelete = "LEGAL_HOLD_ASSIGNMENT_DELETE"
            case legalHoldPolicyCreate = "LEGAL_HOLD_POLICY_CREATE"
            case legalHoldPolicyDelete = "LEGAL_HOLD_POLICY_DELETE"
            case legalHoldPolicyUpdate = "LEGAL_HOLD_POLICY_UPDATE"
            case lock = "LOCK"
            case lockCreate = "LOCK_CREATE"
            case lockDestroy = "LOCK_DESTROY"
            case login = "LOGIN"
            case masterInviteAccept = "MASTER_INVITE_ACCEPT"
            case masterInviteReject = "MASTER_INVITE_REJECT"
            case metadataInstanceCreate = "METADATA_INSTANCE_CREATE"
            case metadataInstanceDelete = "METADATA_INSTANCE_DELETE"
            case metadataInstanceUpdate = "METADATA_INSTANCE_UPDATE"
            case metadataTemplateCreate = "METADATA_TEMPLATE_CREATE"
            case metadataTemplateDelete = "METADATA_TEMPLATE_DELETE"
            case metadataTemplateUpdate = "METADATA_TEMPLATE_UPDATE"
            case move = "MOVE"
            case newUser = "NEW_USER"
            case preview = "PREVIEW"
            case removeDeviceAssociation = "REMOVE_DEVICE_ASSOCIATION"
            case removeLoginActivityDevice = "REMOVE_LOGIN_ACTIVITY_DEVICE"
            case rename = "RENAME"
            case retentionPolicyAssignmentAdd = "RETENTION_POLICY_ASSIGNMENT_ADD"
            case share = "SHARE"
            case shareExpiration = "SHARE_EXPIRATION"
            case shieldAlert = "SHIELD_ALERT"
            case shieldExternalCollabAccessBlocked = "SHIELD_EXTERNAL_COLLAB_ACCESS_BLOCKED"
            case shieldExternalCollabAccessBlockedMissingJustification = "SHIELD_EXTERNAL_COLLAB_ACCESS_BLOCKED_MISSING_JUSTIFICATION"
            case shieldExternalCollabInviteBlocked = "SHIELD_EXTERNAL_COLLAB_INVITE_BLOCKED"
            case shieldExternalCollabInviteBlockedMissingJustification = "SHIELD_EXTERNAL_COLLAB_INVITE_BLOCKED_MISSING_JUSTIFICATION"
            case shieldJustificationApproval = "SHIELD_JUSTIFICATION_APPROVAL"
            case storageExpiration = "STORAGE_EXPIRATION"
            case tagItemCreate = "TAG_ITEM_CREATE"
            case taskAssignmentCreate = "TASK_ASSIGNMENT_CREATE"
            case taskAssignmentDelete = "TASK_ASSIGNMENT_DELETE"
            case taskAssignmentUpdate = "TASK_ASSIGNMENT_UPDATE"
            case taskCreate = "TASK_CREATE"
            case taskUpdate = "TASK_UPDATE"
            case termsOfServiceAccept = "TERMS_OF_SERVICE_ACCEPT"
            case termsOfServiceReject = "TERMS_OF_SERVICE_REJECT"
            case undelete = "UNDELETE"
            case unlock = "UNLOCK"
            case unshare = "UNSHARE"
            case updateCollaborationExpiration = "UPDATE_COLLABORATION_EXPIRATION"
            case updateShareExpiration = "UPDATE_SHARE_EXPIRATION"
            case upload = "UPLOAD"
            case userAuthenticateOauth2AccessTokenCreate = "USER_AUTHENTICATE_OAUTH2_ACCESS_TOKEN_CREATE"
            case watermarkLabelCreate = "WATERMARK_LABEL_CREATE"
            case watermarkLabelDelete = "WATERMARK_LABEL_DELETE"
        }

        public init(object: Object, anyJSON: AnyJSON) {
            self.object = object
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.object = try Object(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(object, forKey: "object")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Source: Codable {
        public var object: Object
        /// The item that triggered this event
        public var anyJSON: AnyJSON

        public enum Object: Codable {
            case user(User)
            case eventSource(EventSource)

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(User.self) {
                    self = .user(value)
                } else if let value = try? container.decode(EventSource.self) {
                    self = .eventSource(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .user(let value): try container.encode(value)
                case .eventSource(let value): try container.encode(value)
                }
            }
        }

        public init(object: Object, anyJSON: AnyJSON) {
            self.object = object
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.object = try Object(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(object, forKey: "object")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(additionalDetails: [String: AnyJSON]? = nil, createdBy: CreatedBy? = nil, eventID: String? = nil, eventType: EventType? = nil, sessionID: String? = nil, source: Source? = nil, type: String? = nil) {
        self.additionalDetails = additionalDetails
        self.createdBy = createdBy
        self.eventID = eventID
        self.eventType = eventType
        self.sessionID = sessionID
        self.source = source
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case additionalDetails = "additional_details"
        case createdBy = "created_by"
        case eventID = "event_id"
        case eventType = "event_type"
        case sessionID = "session_id"
        case source
        case type
    }
}

/// The source file or folder that triggered an event in
/// the event stream.
public struct EventSource: Codable {
    /// The unique identifier that represents the
    /// item.
    ///
    /// Example: "560284318361"
    public var itemID: String?
    /// The name of the item.
    ///
    /// Example: "report.pdf"
    public var itemName: String?
    /// The type of the item that the event
    /// represents. Can be `file` or `folder`.
    ///
    /// Example: "file"
    public var itemType: ItemType?
    public var ownedBy: OwnedBy?
    public var parent: Parent?

    /// The type of the item that the event
    /// represents. Can be `file` or `folder`.
    ///
    /// Example: "file"
    public enum ItemType: String, Codable, CaseIterable {
        case file
        case folder
    }

    public struct OwnedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user who owns this item.
        public var anyJSON: AnyJSON
        public var anyJSON2: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON, anyJSON2: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
            self.anyJSON2 = anyJSON2
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
            self.anyJSON2 = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
            try values.encode(anyJSON2, forKey: "anyJSON2")
        }
    }

    public struct Parent: Codable {
        /// Folder (Mini)
        ///
        /// A mini representation of a file version, used when
        /// nested under another resource.
        public var folderMini: FolderMini
        /// The optional folder that this folder is located within.
        /// 
        /// This value may be `null` for some folders such as the
        /// root folder or the trash folder.
        public var anyJSON: AnyJSON

        public init(folderMini: FolderMini, anyJSON: AnyJSON) {
            self.folderMini = folderMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.folderMini = try FolderMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(folderMini, forKey: "folderMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(itemID: String? = nil, itemName: String? = nil, itemType: ItemType? = nil, ownedBy: OwnedBy? = nil, parent: Parent? = nil) {
        self.itemID = itemID
        self.itemName = itemName
        self.itemType = itemType
        self.ownedBy = ownedBy
        self.parent = parent
    }

    private enum CodingKeys: String, CodingKey {
        case itemID = "item_id"
        case itemName = "item_name"
        case itemType = "item_type"
        case ownedBy = "owned_by"
        case parent
    }
}

/// A list of event objects
public struct Events: Codable {
    /// The number of events returned in this response.
    public var chunkSize: Int?
    public var entries: [Event]?
    /// The stream position of the start of the next page (chunk)
    /// of events.
    ///
    /// Example: "1152922976252290886"
    public var nextStreamPosition: String?

    public init(chunkSize: Int? = nil, entries: [Event]? = nil, nextStreamPosition: String? = nil) {
        self.chunkSize = chunkSize
        self.entries = entries
        self.nextStreamPosition = nextStreamPosition
    }

    private enum CodingKeys: String, CodingKey {
        case chunkSize = "chunk_size"
        case entries
        case nextStreamPosition = "next_stream_position"
    }
}

/// A standard representation of a file, as returned from any
/// file API endpoints by default
public struct File: Codable {
    /// File (Mini)
    ///
    /// A mini representation of a file, used when
    /// nested under another resource.
    public var fileMini: FileMini
    /// The date and time at which this file was originally
    /// created, which might be before it was uploaded to Box.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var contentCreatedAt: Date?
    /// The date and time at which this file was last updated,
    /// which might be before it was uploaded to Box.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var contentModifiedAt: Date?
    /// The date and time when the file was created on Box.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var createdAt: Date?
    public var createdBy: CreatedBy?
    /// The optional description of this file
    ///
    /// Example: "Contract for Q1 renewal"
    public var description: String?
    /// Defines if this item has been deleted or not.
    /// 
    /// * `active` when the item has is not in the trash
    /// * `trashed` when the item has been moved to the trash but not deleted
    /// * `deleted` when the item has been permanently deleted.
    ///
    /// Example: "active"
    public var itemStatus: ItemStatus?
    /// The date and time when the file was last updated on Box.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var modifiedAt: Date?
    public var modifiedBy: ModifiedBy?
    public var ownedBy: OwnedBy?
    public var parent: Parent?
    public var pathCollection: PathCollection?
    /// The time at which this file is expected to be purged
    /// from the trash.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var purgedAt: Date?
    public var sharedLink: SharedLink?
    /// The file size in bytes. Be careful parsing this integer as it can
    /// get very large and cause an integer overflow.
    ///
    /// Example: 629644
    public var size: Int?
    /// The time at which this file was put in the trash.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var trashedAt: Date?

    public struct CreatedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user who created this file
        public var anyJSON: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// Defines if this item has been deleted or not.
    /// 
    /// * `active` when the item has is not in the trash
    /// * `trashed` when the item has been moved to the trash but not deleted
    /// * `deleted` when the item has been permanently deleted.
    ///
    /// Example: "active"
    public enum ItemStatus: String, Codable, CaseIterable {
        case active
        case trashed
        case deleted
    }

    public struct ModifiedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user who last modified this file
        public var anyJSON: AnyJSON
        public var anyJSON2: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON, anyJSON2: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
            self.anyJSON2 = anyJSON2
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
            self.anyJSON2 = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
            try values.encode(anyJSON2, forKey: "anyJSON2")
        }
    }

    public struct OwnedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user who owns this file
        public var anyJSON: AnyJSON
        public var anyJSON2: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON, anyJSON2: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
            self.anyJSON2 = anyJSON2
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
            self.anyJSON2 = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
            try values.encode(anyJSON2, forKey: "anyJSON2")
        }
    }

    public struct Parent: Codable {
        /// Folder (Mini)
        ///
        /// A mini representation of a file version, used when
        /// nested under another resource.
        public var folderMini: FolderMini
        /// The folder that this file is located within.
        public var anyJSON: AnyJSON

        public init(folderMini: FolderMini, anyJSON: AnyJSON) {
            self.folderMini = folderMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.folderMini = try FolderMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(folderMini, forKey: "folderMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct PathCollection: Codable {
        /// The parent folders for this item
        public var entries: [FolderMini]?
        /// The number of folders in this list.
        public var totalCount: Int?
        /// The tree of folders that this file is contained in,
        /// starting at the root.
        public var anyJSON: AnyJSON
        public var anyJSON2: AnyJSON

        public init(entries: [FolderMini]? = nil, totalCount: Int? = nil, anyJSON: AnyJSON, anyJSON2: AnyJSON) {
            self.entries = entries
            self.totalCount = totalCount
            self.anyJSON = anyJSON
            self.anyJSON2 = anyJSON2
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.entries = try values.decodeIfPresent([FolderMini].self, forKey: "entries")
            self.totalCount = try values.decodeIfPresent(Int.self, forKey: "total_count")
            self.anyJSON = try AnyJSON(from: decoder)
            self.anyJSON2 = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(entries, forKey: "entries")
            try values.encodeIfPresent(totalCount, forKey: "total_count")
            try values.encode(anyJSON, forKey: "anyJSON")
            try values.encode(anyJSON2, forKey: "anyJSON2")
        }
    }

    public struct SharedLink: Codable {
        /// The access level for this shared link.
        /// 
        /// * `open` - provides access to this item to anyone with this link
        /// * `company` - only provides access to this item to people the same company
        /// * `collaborators` - only provides access to this item to people who are
        ///    collaborators on this item
        /// 
        /// If this field is omitted when creating the shared link, the access level
        /// will be set to the default access level specified by the enterprise admin.
        ///
        /// Example: "open"
        public var access: Access?
        /// The number of times this item has been downloaded.
        public var downloadCount: Int?
        /// A URL that can be used to download the file. This URL can be used in
        /// a browser to download the file. This URL includes the file
        /// extension so that the file will be saved with the right file type.
        /// 
        /// This property will be `null` for folders.
        ///
        /// Example: "https://www.box.com/shared/static/rh935iit6ewrmw0unyul.jpeg"
        public var downloadURL: String?
        /// The effective access level for the shared link. This can be a more
        /// restrictive access level than the value in the `access` field when the
        /// enterprise settings restrict the allowed access levels.
        ///
        /// Example: "company"
        public var effectiveAccess: EffectiveAccess?
        /// The effective permissions for this shared link.
        ///
        /// Example: "can_download"
        public var effectivePermission: EffectivePermission?
        /// Defines if the shared link requires a password to access the item.
        ///
        /// Example: true
        public var isPasswordEnabled: Bool?
        /// Defines if this link allows a user to preview and download an item.
        public var permissions: Permissions?
        /// The number of times this item has been previewed.
        public var previewCount: Int?
        /// The date and time when this link will be unshared. This field can only be
        /// set by users with paid accounts.
        ///
        /// Example: "2018-04-13T13:53:23-07:00"
        public var unsharedAt: Date?
        /// The URL that can be used to access the item on Box.
        /// 
        /// This URL will display the item in Box's preview UI where the file
        /// can be downloaded if allowed.
        /// 
        /// This URL will continue to work even when a custom `vanity_url`
        /// has been set for this shared link.
        ///
        /// Example: "https://www.box.com/s/vspke7y05sb214wjokpk"
        public var url: String?
        /// The custom name of a shared link, as used in the `vanity_url` field.
        ///
        /// Example: "my_url"
        public var vanityName: String?
        /// The "Custom URL" that can also be used to preview the item on Box.  Custom
        /// URLs can only be created or modified in the Box Web application.
        ///
        /// Example: "https://acme.app.box.com/v/my_url/"
        public var vanityURL: String?
        /// The shared link for this file. This will be
        /// `null` if no shared link has been created for this
        /// file.
        public var anyJSON: AnyJSON
        public var anyJSON2: AnyJSON?

        /// The access level for this shared link.
        /// 
        /// * `open` - provides access to this item to anyone with this link
        /// * `company` - only provides access to this item to people the same company
        /// * `collaborators` - only provides access to this item to people who are
        ///    collaborators on this item
        /// 
        /// If this field is omitted when creating the shared link, the access level
        /// will be set to the default access level specified by the enterprise admin.
        ///
        /// Example: "open"
        public enum Access: String, Codable, CaseIterable {
            case `open`
            case company
            case collaborators
        }

        /// The effective access level for the shared link. This can be a more
        /// restrictive access level than the value in the `access` field when the
        /// enterprise settings restrict the allowed access levels.
        ///
        /// Example: "company"
        public enum EffectiveAccess: String, Codable, CaseIterable {
            case `open`
            case company
            case collaborators
        }

        /// The effective permissions for this shared link.
        ///
        /// Example: "can_download"
        public enum EffectivePermission: String, Codable, CaseIterable {
            case canDownload = "can_download"
            case canPreview = "can_preview"
        }

        /// Defines if this link allows a user to preview and download an item.
        public struct Permissions: Codable {
            /// Defines if the shared link allows for the item to be downloaded. For
            /// shared links on folders, this also applies to any items in the folder.
            /// 
            /// This value can be set to `true` when the effective access level is
            /// set to `open` or `company`, not `collaborators`.
            ///
            /// Example: true
            public var canDownload: Bool?
            /// Defines if the shared link allows for the item to be previewed.
            /// 
            /// This value is always `true`. For shared links on folders this also
            /// applies to any items in the folder.
            ///
            /// Example: true
            public var canPreview: Bool?

            public init(canDownload: Bool? = nil, canPreview: Bool? = nil) {
                self.canDownload = canDownload
                self.canPreview = canPreview
            }

            private enum CodingKeys: String, CodingKey {
                case canDownload = "can_download"
                case canPreview = "can_preview"
            }
        }

        public init(access: Access? = nil, downloadCount: Int? = nil, downloadURL: String? = nil, effectiveAccess: EffectiveAccess? = nil, effectivePermission: EffectivePermission? = nil, isPasswordEnabled: Bool? = nil, permissions: Permissions? = nil, previewCount: Int? = nil, unsharedAt: Date? = nil, url: String? = nil, vanityName: String? = nil, vanityURL: String? = nil, anyJSON: AnyJSON, anyJSON2: AnyJSON? = nil) {
            self.access = access
            self.downloadCount = downloadCount
            self.downloadURL = downloadURL
            self.effectiveAccess = effectiveAccess
            self.effectivePermission = effectivePermission
            self.isPasswordEnabled = isPasswordEnabled
            self.permissions = permissions
            self.previewCount = previewCount
            self.unsharedAt = unsharedAt
            self.url = url
            self.vanityName = vanityName
            self.vanityURL = vanityURL
            self.anyJSON = anyJSON
            self.anyJSON2 = anyJSON2
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.access = try Access(from: decoder)
            self.downloadCount = try values.decodeIfPresent(Int.self, forKey: "download_count")
            self.downloadURL = try values.decodeIfPresent(String.self, forKey: "download_url")
            self.effectiveAccess = try EffectiveAccess(from: decoder)
            self.effectivePermission = try EffectivePermission(from: decoder)
            self.isPasswordEnabled = try values.decodeIfPresent(Bool.self, forKey: "is_password_enabled")
            self.permissions = try Permissions(from: decoder)
            self.previewCount = try values.decodeIfPresent(Int.self, forKey: "preview_count")
            self.unsharedAt = try values.decodeIfPresent(Date.self, forKey: "unshared_at")
            self.url = try values.decodeIfPresent(String.self, forKey: "url")
            self.vanityName = try values.decodeIfPresent(String.self, forKey: "vanity_name")
            self.vanityURL = try values.decodeIfPresent(String.self, forKey: "vanity_url")
            self.anyJSON = try AnyJSON(from: decoder)
            self.anyJSON2 = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(access, forKey: "access")
            try values.encodeIfPresent(downloadCount, forKey: "download_count")
            try values.encodeIfPresent(downloadURL, forKey: "download_url")
            try values.encodeIfPresent(effectiveAccess, forKey: "effective_access")
            try values.encodeIfPresent(effectivePermission, forKey: "effective_permission")
            try values.encodeIfPresent(isPasswordEnabled, forKey: "is_password_enabled")
            try values.encodeIfPresent(permissions, forKey: "permissions")
            try values.encodeIfPresent(previewCount, forKey: "preview_count")
            try values.encodeIfPresent(unsharedAt, forKey: "unshared_at")
            try values.encodeIfPresent(url, forKey: "url")
            try values.encodeIfPresent(vanityName, forKey: "vanity_name")
            try values.encodeIfPresent(vanityURL, forKey: "vanity_url")
            try values.encode(anyJSON, forKey: "anyJSON")
            try values.encodeIfPresent(anyJSON2, forKey: "anyJSON2")
        }
    }

    public init(fileMini: FileMini, contentCreatedAt: Date? = nil, contentModifiedAt: Date? = nil, createdAt: Date? = nil, createdBy: CreatedBy? = nil, description: String? = nil, itemStatus: ItemStatus? = nil, modifiedAt: Date? = nil, modifiedBy: ModifiedBy? = nil, ownedBy: OwnedBy? = nil, parent: Parent? = nil, pathCollection: PathCollection? = nil, purgedAt: Date? = nil, sharedLink: SharedLink? = nil, size: Int? = nil, trashedAt: Date? = nil) {
        self.fileMini = fileMini
        self.contentCreatedAt = contentCreatedAt
        self.contentModifiedAt = contentModifiedAt
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.itemStatus = itemStatus
        self.modifiedAt = modifiedAt
        self.modifiedBy = modifiedBy
        self.ownedBy = ownedBy
        self.parent = parent
        self.pathCollection = pathCollection
        self.purgedAt = purgedAt
        self.sharedLink = sharedLink
        self.size = size
        self.trashedAt = trashedAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.fileMini = try FileMini(from: decoder)
        self.contentCreatedAt = try values.decodeIfPresent(Date.self, forKey: "content_created_at")
        self.contentModifiedAt = try values.decodeIfPresent(Date.self, forKey: "content_modified_at")
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
        self.createdBy = try CreatedBy(from: decoder)
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.itemStatus = try ItemStatus(from: decoder)
        self.modifiedAt = try values.decodeIfPresent(Date.self, forKey: "modified_at")
        self.modifiedBy = try ModifiedBy(from: decoder)
        self.ownedBy = try OwnedBy(from: decoder)
        self.parent = try Parent(from: decoder)
        self.pathCollection = try PathCollection(from: decoder)
        self.purgedAt = try values.decodeIfPresent(Date.self, forKey: "purged_at")
        self.sharedLink = try SharedLink(from: decoder)
        self.size = try values.decodeIfPresent(Int.self, forKey: "size")
        self.trashedAt = try values.decodeIfPresent(Date.self, forKey: "trashed_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(fileMini, forKey: "fileMini")
        try values.encodeIfPresent(contentCreatedAt, forKey: "content_created_at")
        try values.encodeIfPresent(contentModifiedAt, forKey: "content_modified_at")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(createdBy, forKey: "created_by")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(itemStatus, forKey: "item_status")
        try values.encodeIfPresent(modifiedAt, forKey: "modified_at")
        try values.encodeIfPresent(modifiedBy, forKey: "modified_by")
        try values.encodeIfPresent(ownedBy, forKey: "owned_by")
        try values.encodeIfPresent(parent, forKey: "parent")
        try values.encodeIfPresent(pathCollection, forKey: "path_collection")
        try values.encodeIfPresent(purgedAt, forKey: "purged_at")
        try values.encodeIfPresent(sharedLink, forKey: "shared_link")
        try values.encodeIfPresent(size, forKey: "size")
        try values.encodeIfPresent(trashedAt, forKey: "trashed_at")
    }
}

/// File (Base)
///
/// The bare basic representation of a file, the minimal
/// amount of fields returned when using the `fields` query
/// parameter.
public struct FileBase: Codable {
    /// The HTTP `etag` of this file. This can be used within some API
    /// endpoints in the `If-Match` and `If-None-Match` headers to only
    /// perform changes on the file if (no) changes have happened.
    ///
    /// Example: "1"
    public var etag: String?
    /// The unique identifier that represent a file.
    /// 
    /// The ID for any file can be determined
    /// by visiting a file in the web application
    /// and copying the ID from the URL. For example,
    /// for the URL `https://*.app.box.com/files/123`
    /// the `file_id` is `123`.
    ///
    /// Example: "12345"
    public var id: String?
    /// `file`
    ///
    /// Example: "file"
    public var type: `Type`?

    /// `file`
    ///
    /// Example: "file"
    public enum `Type`: String, Codable, CaseIterable {
        case file
    }

    public init(etag: String? = nil, id: String? = nil, type: `Type`? = nil) {
        self.etag = etag
        self.id = id
        self.type = type
    }
}

/// File (Full)
///
/// A full representation of a file, as can be returned from any
/// file API endpoints by default
public struct FileFull: Codable {
    /// A standard representation of a file, as returned from any
    /// file API endpoints by default
    public var file: File
    /// A list of the types of roles that user can be invited at
    /// when sharing this file.
    ///
    /// Example: ["editor"]
    public var allowedInviteeRoles: [AllowedInviteeRole]?
    public var classification: Classification?
    /// The number of comments on this file
    ///
    /// Example: 10
    public var commentCount: Int?
    /// When the file will automatically be deleted
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var expiresAt: Date?
    public var expiringEmbedLink: ExpiringEmbedLink?
    /// Indicates the (optional) file extension for this file. By default,
    /// this is set to an empty string.
    ///
    /// Example: "pdf"
    public var `extension`: String?
    /// Specifies if this file has any other collaborators.
    ///
    /// Example: true
    public var hasCollaborations: Bool?
    /// Specifies if this file is owned by a user outside of the
    /// authenticated enterprise.
    ///
    /// Example: true
    public var isExternallyOwned: Bool?
    /// Indicates if the file is a package. Packages are commonly used
    /// by Mac Applications and can include iWork files.
    ///
    /// Example: true
    public var isPackage: Bool?
    public var lock: Lock?
    public var metadata: AnyJSON?
    public var permissions: Permissions?
    public var representations: Representations?
    public var tags: Tags?
    public var uploaderDisplayName: String?
    /// The version number of this file
    ///
    /// Example: "1"
    public var versionNumber: String?
    public var watermarkInfo: WatermarkInfo?

    public enum AllowedInviteeRole: String, Codable, CaseIterable {
        case editor
        case viewer
        case previewer
        case uploader
        case previewerUploader = "previewer uploader"
        case viewerUploader = "viewer uploader"
        case coOwner = "co-owner"
    }

    public struct Classification: Codable {
        /// The color that is used to display the
        /// classification label in a user-interface. Colors are defined by the admin
        /// or co-admin who created the classification in the Box web app.
        ///
        /// Example: "#FF0000"
        public var color: String?
        /// An explanation of the meaning of this classification.
        ///
        /// Example: "Content that should not be shared outside the company."
        public var definition: String?
        /// The name of the classification
        ///
        /// Example: "Top Secret"
        public var name: String?
        /// Details about the classification applied to this file.
        public var anyJSON: AnyJSON
        public var anyJSON2: AnyJSON?

        public init(color: String? = nil, definition: String? = nil, name: String? = nil, anyJSON: AnyJSON, anyJSON2: AnyJSON? = nil) {
            self.color = color
            self.definition = definition
            self.name = name
            self.anyJSON = anyJSON
            self.anyJSON2 = anyJSON2
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.color = try values.decodeIfPresent(String.self, forKey: "color")
            self.definition = try values.decodeIfPresent(String.self, forKey: "definition")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.anyJSON = try AnyJSON(from: decoder)
            self.anyJSON2 = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(color, forKey: "color")
            try values.encodeIfPresent(definition, forKey: "definition")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encode(anyJSON, forKey: "anyJSON")
            try values.encodeIfPresent(anyJSON2, forKey: "anyJSON2")
        }
    }

    public struct ExpiringEmbedLink: Codable {
        /// Expiring embed link
        ///
        /// An expiring Box Embed Link.
        public var object: Object
        /// Requesting this field creates an expiring Box Embed URL for an
        /// embedded preview session in an `iframe`.
        /// 
        /// This URL will expire after 60 seconds and the session will
        /// expire after 60 minutes.
        /// 
        /// Not all file types are supported for these embed URLs. Box Embed
        /// is not optimized for mobile browsers and should not be used in web
        /// experiences designed for mobile devices. Many UI elements, like
        /// the **download** and **print** options might not show in mobile
        /// browsers.
        public var anyJSON: AnyJSON

        /// Expiring embed link
        ///
        /// An expiring Box Embed Link.
        public struct Object: Codable {
            /// The requested access token.
            ///
            /// Example: "c3FIOG9vSGV4VHo4QzAyg5T1JvNnJoZ3ExaVNyQWw6WjRsanRKZG5lQk9qUE1BVQ"
            public var accessToken: String?
            /// The time in seconds in seconds by which this token will expire.
            ///
            /// Example: 3600
            public var expiresIn: Int?
            /// The permissions that this access token permits,
            /// providing a list of resources (files, folders, etc)
            /// and the scopes permitted for each of those resources.
            public var restrictedTo: [FileScope]?
            /// The type of access token returned.
            ///
            /// Example: "bearer"
            public var tokenType: TokenType?
            /// The actual expiring embed URL for this file, constructed
            /// from the file ID and access tokens specified in this object.
            ///
            /// Example: "https://cloud.app.box.com/preview/expiring_embed/..."
            public var url: String?

            /// The type of access token returned.
            ///
            /// Example: "bearer"
            public enum TokenType: String, Codable, CaseIterable {
                case bearer
            }

            public init(accessToken: String? = nil, expiresIn: Int? = nil, restrictedTo: [FileScope]? = nil, tokenType: TokenType? = nil, url: String? = nil) {
                self.accessToken = accessToken
                self.expiresIn = expiresIn
                self.restrictedTo = restrictedTo
                self.tokenType = tokenType
                self.url = url
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.accessToken = try values.decodeIfPresent(String.self, forKey: "access_token")
                self.expiresIn = try values.decodeIfPresent(Int.self, forKey: "expires_in")
                self.restrictedTo = try values.decodeIfPresent([FileScope].self, forKey: "restricted_to")
                self.tokenType = try TokenType(from: decoder)
                self.url = try values.decodeIfPresent(String.self, forKey: "url")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(accessToken, forKey: "access_token")
                try values.encodeIfPresent(expiresIn, forKey: "expires_in")
                try values.encodeIfPresent(restrictedTo, forKey: "restricted_to")
                try values.encodeIfPresent(tokenType, forKey: "token_type")
                try values.encodeIfPresent(url, forKey: "url")
            }
        }

        public init(object: Object, anyJSON: AnyJSON) {
            self.object = object
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.object = try Object(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(object, forKey: "object")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Lock: Codable {
        /// The time this lock was created at.
        ///
        /// Example: "2012-12-12T10:53:43-08:00"
        public var createdAt: Date?
        public var createdBy: CreatedBy?
        /// The time this lock is to expire at, which might be in the past.
        ///
        /// Example: "2012-12-12T10:53:43-08:00"
        public var expiredAt: Date?
        /// The unique identifier for this lock
        ///
        /// Example: "11446498"
        public var id: String?
        /// Whether or not the file can be downloaded while locked.
        ///
        /// Example: true
        public var isDownloadPrevented: Bool?
        /// `lock`
        ///
        /// Example: "lock"
        public var type: `Type`?
        /// The lock held on this file. If there is no lock, this can either
        /// be `null` or have a timestamp in the past.
        public var anyJSON: AnyJSON

        public struct CreatedBy: Codable {
            /// User (Mini)
            ///
            /// A mini representation of a user, as can be returned when nested within other
            /// resources.
            public var userMini: UserMini
            /// The user who created the lock.
            public var anyJSON: AnyJSON

            public init(userMini: UserMini, anyJSON: AnyJSON) {
                self.userMini = userMini
                self.anyJSON = anyJSON
            }

            public init(from decoder: Decoder) throws {
                self.userMini = try UserMini(from: decoder)
                self.anyJSON = try AnyJSON(from: decoder)
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(userMini, forKey: "userMini")
                try values.encode(anyJSON, forKey: "anyJSON")
            }
        }

        /// `lock`
        ///
        /// Example: "lock"
        public enum `Type`: String, Codable, CaseIterable {
            case lock
        }

        public init(createdAt: Date? = nil, createdBy: CreatedBy? = nil, expiredAt: Date? = nil, id: String? = nil, isDownloadPrevented: Bool? = nil, type: `Type`? = nil, anyJSON: AnyJSON) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.expiredAt = expiredAt
            self.id = id
            self.isDownloadPrevented = isDownloadPrevented
            self.type = type
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
            self.createdBy = try CreatedBy(from: decoder)
            self.expiredAt = try values.decodeIfPresent(Date.self, forKey: "expired_at")
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.isDownloadPrevented = try values.decodeIfPresent(Bool.self, forKey: "is_download_prevented")
            self.type = try `Type`(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(createdAt, forKey: "created_at")
            try values.encodeIfPresent(createdBy, forKey: "created_by")
            try values.encodeIfPresent(expiredAt, forKey: "expired_at")
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(isDownloadPrevented, forKey: "is_download_prevented")
            try values.encodeIfPresent(type, forKey: "type")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Permissions: Codable {
        /// The permissions that the authenticated user has for a file.
        public var object: Object
        /// Describes the permissions that the current user has
        /// for this file.
        public var anyJSON: AnyJSON
        public var anyJSON2: AnyJSON

        /// The permissions that the authenticated user has for a file.
        public struct Object: Codable {
            /// Specifies if the current user can delete this item.
            ///
            /// Example: true
            public var canDelete: Bool?
            /// Specifies if the current user can download this item.
            ///
            /// Example: true
            public var canDownload: Bool?
            /// Specifies if the current user can invite new
            /// users to collaborate on this item, and if the user can
            /// update the role of a user already collaborated on this
            /// item.
            ///
            /// Example: true
            public var canInviteCollaborator: Bool?
            /// Specifies if the user can rename this item.
            ///
            /// Example: true
            public var canRename: Bool?
            /// Specifies if the user can change the access level of an
            /// existing shared link on this item.
            ///
            /// Example: true
            public var canSetShareAccess: Bool?
            /// Specifies if the user can create a shared link for this item.
            ///
            /// Example: true
            public var canShare: Bool?
            /// Specifies if the user can place annotations on this file.
            ///
            /// Example: true
            public var canAnnotate: Bool?
            /// Specifies if the user can place comments on this file.
            ///
            /// Example: true
            public var canComment: Bool?
            /// Specifies if the user can preview this file.
            ///
            /// Example: true
            public var canPreview: Bool?
            /// Specifies if the user can upload a new version of this file.
            ///
            /// Example: true
            public var canUpload: Bool?
            /// Specifies if the user view all annotations placed on this file
            ///
            /// Example: true
            public var canViewAnnotationsAll: Bool?
            /// Specifies if the user view annotations placed by themselves
            /// on this file
            ///
            /// Example: true
            public var canViewAnnotationsSelf: Bool?

            public init(canDelete: Bool? = nil, canDownload: Bool? = nil, canInviteCollaborator: Bool? = nil, canRename: Bool? = nil, canSetShareAccess: Bool? = nil, canShare: Bool? = nil, canAnnotate: Bool? = nil, canComment: Bool? = nil, canPreview: Bool? = nil, canUpload: Bool? = nil, canViewAnnotationsAll: Bool? = nil, canViewAnnotationsSelf: Bool? = nil) {
                self.canDelete = canDelete
                self.canDownload = canDownload
                self.canInviteCollaborator = canInviteCollaborator
                self.canRename = canRename
                self.canSetShareAccess = canSetShareAccess
                self.canShare = canShare
                self.canAnnotate = canAnnotate
                self.canComment = canComment
                self.canPreview = canPreview
                self.canUpload = canUpload
                self.canViewAnnotationsAll = canViewAnnotationsAll
                self.canViewAnnotationsSelf = canViewAnnotationsSelf
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.canDelete = try values.decodeIfPresent(Bool.self, forKey: "can_delete")
                self.canDownload = try values.decodeIfPresent(Bool.self, forKey: "can_download")
                self.canInviteCollaborator = try values.decodeIfPresent(Bool.self, forKey: "can_invite_collaborator")
                self.canRename = try values.decodeIfPresent(Bool.self, forKey: "can_rename")
                self.canSetShareAccess = try values.decodeIfPresent(Bool.self, forKey: "can_set_share_access")
                self.canShare = try values.decodeIfPresent(Bool.self, forKey: "can_share")
                self.canAnnotate = try values.decodeIfPresent(Bool.self, forKey: "can_annotate")
                self.canComment = try values.decodeIfPresent(Bool.self, forKey: "can_comment")
                self.canPreview = try values.decodeIfPresent(Bool.self, forKey: "can_preview")
                self.canUpload = try values.decodeIfPresent(Bool.self, forKey: "can_upload")
                self.canViewAnnotationsAll = try values.decodeIfPresent(Bool.self, forKey: "can_view_annotations_all")
                self.canViewAnnotationsSelf = try values.decodeIfPresent(Bool.self, forKey: "can_view_annotations_self")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(canDelete, forKey: "can_delete")
                try values.encodeIfPresent(canDownload, forKey: "can_download")
                try values.encodeIfPresent(canInviteCollaborator, forKey: "can_invite_collaborator")
                try values.encodeIfPresent(canRename, forKey: "can_rename")
                try values.encodeIfPresent(canSetShareAccess, forKey: "can_set_share_access")
                try values.encodeIfPresent(canShare, forKey: "can_share")
                try values.encodeIfPresent(canAnnotate, forKey: "can_annotate")
                try values.encodeIfPresent(canComment, forKey: "can_comment")
                try values.encodeIfPresent(canPreview, forKey: "can_preview")
                try values.encodeIfPresent(canUpload, forKey: "can_upload")
                try values.encodeIfPresent(canViewAnnotationsAll, forKey: "can_view_annotations_all")
                try values.encodeIfPresent(canViewAnnotationsSelf, forKey: "can_view_annotations_self")
            }
        }

        public init(object: Object, anyJSON: AnyJSON, anyJSON2: AnyJSON) {
            self.object = object
            self.anyJSON = anyJSON
            self.anyJSON2 = anyJSON2
        }

        public init(from decoder: Decoder) throws {
            self.object = try Object(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
            self.anyJSON2 = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(object, forKey: "object")
            try values.encode(anyJSON, forKey: "anyJSON")
            try values.encode(anyJSON2, forKey: "anyJSON2")
        }
    }

    public struct Representations: Codable {
        /// A list of files
        public var entries: [Entry]?
        /// A list of representations for a file that can be used to
        /// display a placeholder of the file in your application. By default
        /// this returns all representations and we recommend using the
        /// `X-Rep-Hints` header to further customize the desired
        /// representations.
        public var anyJSON: AnyJSON

        /// A file representation
        public struct Entry: Codable {
            /// An object containing the URL that can be used to actually fetch
            /// the representation.
            public var content: Content?
            /// An object containing the URL that can be used to fetch more info
            /// on this representation.
            public var info: Info?
            /// An object containing the size and type of this presentation.
            public var properties: Properties?
            /// Indicates the file type of the returned representation.
            ///
            /// Example: "png"
            public var representation: String?
            /// An object containing the status of this representation.
            public var status: Status?

            /// An object containing the URL that can be used to actually fetch
            /// the representation.
            public struct Content: Codable {
                /// The download URL that can be used to fetch the representation.
                /// Make sure to make an authenticated API call to this endpoint.
                /// 
                /// This URL is a template and will require the `{+asset_path}` to
                /// be replaced by a path. In general, for unpaged representations
                /// it can be replaced by an empty string.
                /// 
                /// For paged representations, replace the `{+asset_path}` with the
                /// page to request plus the extension for the file, for example
                /// `1.pdf`.
                /// 
                /// When requesting the download URL the following additional
                /// query params can be passed along.
                /// 
                /// * `set_content_disposition_type` - Sets the
                /// `Content-Disposition` header in the API response with the
                /// specified disposition type of either `inline` or `attachment`.
                /// If not supplied, the `Content-Disposition` header is not
                /// included in the response.
                /// 
                /// * `set_content_disposition_filename` - Allows the application to
                ///   define the representation's file name used in the
                ///   `Content-Disposition` header.  If not defined, the filename
                ///   is derived from the source file name in Box combined with the
                ///   extension of the representation.
                ///
                /// Example: "https://dl.boxcloud.com/api/2.0/internal_files/123/versions/345/representations/png_paged_2048x2048/content/{+asset_path}?watermark_content=4567"
                public var urlTemplate: String?

                public init(urlTemplate: String? = nil) {
                    self.urlTemplate = urlTemplate
                }

                private enum CodingKeys: String, CodingKey {
                    case urlTemplate = "url_template"
                }
            }

            /// An object containing the URL that can be used to fetch more info
            /// on this representation.
            public struct Info: Codable {
                /// The API URL that can be used to get more info on this file
                /// representation. Make sure to make an authenticated API call
                /// to this endpoint.
                ///
                /// Example: "https://api.box.com/2.0/internal_files/123/versions/345/representations/png_paged_2048x2048"
                public var url: String?

                public init(url: String? = nil) {
                    self.url = url
                }
            }

            /// An object containing the size and type of this presentation.
            public struct Properties: Codable {
                /// The width by height size of this representation in pixels.
                ///
                /// Example: "2048x2048"
                public var dimensions: String?
                /// Indicates if the representation is build up out of multiple
                /// pages.
                ///
                /// Example: true
                public var isPaged: Bool?
                /// Indicates if the representation can be used as a thumbnail of
                /// the file.
                ///
                /// Example: true
                public var isThumb: Bool?

                public init(dimensions: String? = nil, isPaged: Bool? = nil, isThumb: Bool? = nil) {
                    self.dimensions = dimensions
                    self.isPaged = isPaged
                    self.isThumb = isThumb
                }

                private enum CodingKeys: String, CodingKey {
                    case dimensions
                    case isPaged = "paged"
                    case isThumb = "thumb"
                }
            }

            /// An object containing the status of this representation.
            public struct Status: Codable {
                /// The status of the representation.
                /// 
                /// * `success` defines the representation as ready to be viewed.
                /// * `viewable` defines a video to be ready for viewing.
                /// * `pending` defines the representation as to be generated. Retry
                ///   this endpoint to re-check the status.
                /// * `none` defines that the representation will be created when
                ///   requested. Request the URL defined in the `info` object to
                ///   trigger this generation.
                ///
                /// Example: "success"
                public var state: State?

                /// The status of the representation.
                /// 
                /// * `success` defines the representation as ready to be viewed.
                /// * `viewable` defines a video to be ready for viewing.
                /// * `pending` defines the representation as to be generated. Retry
                ///   this endpoint to re-check the status.
                /// * `none` defines that the representation will be created when
                ///   requested. Request the URL defined in the `info` object to
                ///   trigger this generation.
                ///
                /// Example: "success"
                public enum State: String, Codable, CaseIterable {
                    case success
                    case viewable
                    case pending
                    case `none`
                }

                public init(state: State? = nil) {
                    self.state = state
                }
            }

            public init(content: Content? = nil, info: Info? = nil, properties: Properties? = nil, representation: String? = nil, status: Status? = nil) {
                self.content = content
                self.info = info
                self.properties = properties
                self.representation = representation
                self.status = status
            }
        }

        public init(entries: [Entry]? = nil, anyJSON: AnyJSON) {
            self.entries = entries
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.entries = try values.decodeIfPresent([Entry].self, forKey: "entries")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(entries, forKey: "entries")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Tags: Codable {
        /// The tags for this item. These tags are shown in
        /// the Box web app and mobile apps next to an item.
        /// 
        /// To add or remove a tag, retrieve the item's current tags,
        /// modify them, and then update this field.
        /// 
        /// There is a limit of 100 tags per item, and 10,000
        /// unique tags per enterprise.
        ///
        /// Example: ["approved"]
        public var strings: [String]
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct WatermarkInfo: Codable {
        /// Specifies if this item has a watermark applied.
        ///
        /// Example: true
        public var isWatermarked: Bool?
        /// Details about the watermark applied to this file
        public var anyJSON: AnyJSON

        public init(isWatermarked: Bool? = nil, anyJSON: AnyJSON) {
            self.isWatermarked = isWatermarked
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isWatermarked = try values.decodeIfPresent(Bool.self, forKey: "is_watermarked")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(isWatermarked, forKey: "is_watermarked")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(file: File, allowedInviteeRoles: [AllowedInviteeRole]? = nil, classification: Classification? = nil, commentCount: Int? = nil, expiresAt: Date? = nil, expiringEmbedLink: ExpiringEmbedLink? = nil, `extension`: String? = nil, hasCollaborations: Bool? = nil, isExternallyOwned: Bool? = nil, isPackage: Bool? = nil, lock: Lock? = nil, metadata: AnyJSON? = nil, permissions: Permissions? = nil, representations: Representations? = nil, tags: Tags? = nil, uploaderDisplayName: String? = nil, versionNumber: String? = nil, watermarkInfo: WatermarkInfo? = nil) {
        self.file = file
        self.allowedInviteeRoles = allowedInviteeRoles
        self.classification = classification
        self.commentCount = commentCount
        self.expiresAt = expiresAt
        self.expiringEmbedLink = expiringEmbedLink
        self.extension = `extension`
        self.hasCollaborations = hasCollaborations
        self.isExternallyOwned = isExternallyOwned
        self.isPackage = isPackage
        self.lock = lock
        self.metadata = metadata
        self.permissions = permissions
        self.representations = representations
        self.tags = tags
        self.uploaderDisplayName = uploaderDisplayName
        self.versionNumber = versionNumber
        self.watermarkInfo = watermarkInfo
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.file = try File(from: decoder)
        self.allowedInviteeRoles = try values.decodeIfPresent([AllowedInviteeRole].self, forKey: "allowed_invitee_roles")
        self.classification = try Classification(from: decoder)
        self.commentCount = try values.decodeIfPresent(Int.self, forKey: "comment_count")
        self.expiresAt = try values.decodeIfPresent(Date.self, forKey: "expires_at")
        self.expiringEmbedLink = try ExpiringEmbedLink(from: decoder)
        self.extension = try values.decodeIfPresent(String.self, forKey: "extension")
        self.hasCollaborations = try values.decodeIfPresent(Bool.self, forKey: "has_collaborations")
        self.isExternallyOwned = try values.decodeIfPresent(Bool.self, forKey: "is_externally_owned")
        self.isPackage = try values.decodeIfPresent(Bool.self, forKey: "is_package")
        self.lock = try Lock(from: decoder)
        self.metadata = try AnyJSON(from: decoder)
        self.permissions = try Permissions(from: decoder)
        self.representations = try Representations(from: decoder)
        self.tags = try Tags(from: decoder)
        self.uploaderDisplayName = try values.decodeIfPresent(String.self, forKey: "uploader_display_name")
        self.versionNumber = try values.decodeIfPresent(String.self, forKey: "version_number")
        self.watermarkInfo = try WatermarkInfo(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(file, forKey: "file")
        try values.encodeIfPresent(allowedInviteeRoles, forKey: "allowed_invitee_roles")
        try values.encodeIfPresent(classification, forKey: "classification")
        try values.encodeIfPresent(commentCount, forKey: "comment_count")
        try values.encodeIfPresent(expiresAt, forKey: "expires_at")
        try values.encodeIfPresent(expiringEmbedLink, forKey: "expiring_embed_link")
        try values.encodeIfPresent(`extension`, forKey: "extension")
        try values.encodeIfPresent(hasCollaborations, forKey: "has_collaborations")
        try values.encodeIfPresent(isExternallyOwned, forKey: "is_externally_owned")
        try values.encodeIfPresent(isPackage, forKey: "is_package")
        try values.encodeIfPresent(lock, forKey: "lock")
        try values.encodeIfPresent(metadata, forKey: "metadata")
        try values.encodeIfPresent(permissions, forKey: "permissions")
        try values.encodeIfPresent(representations, forKey: "representations")
        try values.encodeIfPresent(tags, forKey: "tags")
        try values.encodeIfPresent(uploaderDisplayName, forKey: "uploader_display_name")
        try values.encodeIfPresent(versionNumber, forKey: "version_number")
        try values.encodeIfPresent(watermarkInfo, forKey: "watermark_info")
    }
}

/// File (Mini)
///
/// A mini representation of a file, used when
/// nested under another resource.
public struct FileMini: Codable {
    /// File (Base)
    ///
    /// The bare basic representation of a file, the minimal
    /// amount of fields returned when using the `fields` query
    /// parameter.
    public var fileBase: FileBase
    public var fileVersion: FileVersion?
    /// The name of the file
    ///
    /// Example: "Contract.pdf"
    public var name: String?
    public var sequenceID: SequenceID?
    /// The SHA1 hash of the file. This can be used to compare the contents
    /// of a file on Box with a local file.
    ///
    /// Example: "85136C79CBF9FE36BB9D05D0639C70C265C18D37"
    public var sha1: String?

    public struct FileVersion: Codable {
        /// File version (Mini)
        ///
        /// A mini representation of a file version, used when
        /// nested within another resource.
        public var fileVersionMini: FileVersionMini
        /// The information about the current version of the file.
        public var anyJSON: AnyJSON

        public init(fileVersionMini: FileVersionMini, anyJSON: AnyJSON) {
            self.fileVersionMini = fileVersionMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.fileVersionMini = try FileVersionMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(fileVersionMini, forKey: "fileVersionMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SequenceID: Codable {
        /// A numeric identifier that represents the most recent user event
        /// that has been applied to this item.
        /// 
        /// This can be used in combination with the `GET /events`-endpoint
        /// to filter out user events that would have occurred before this
        /// identifier was read.
        /// 
        /// An example would be where a Box Drive-like application
        /// would fetch an item via the API, and then listen to incoming
        /// user events for changes to the item. The application would
        /// ignore any user events where the `sequence_id` in the event
        /// is smaller than or equal to the `sequence_id` in the originally
        /// fetched resource.
        ///
        /// Example: "3"
        public var string: String
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(fileBase: FileBase, fileVersion: FileVersion? = nil, name: String? = nil, sequenceID: SequenceID? = nil, sha1: String? = nil) {
        self.fileBase = fileBase
        self.fileVersion = fileVersion
        self.name = name
        self.sequenceID = sequenceID
        self.sha1 = sha1
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.fileBase = try FileBase(from: decoder)
        self.fileVersion = try FileVersion(from: decoder)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.sequenceID = try SequenceID(from: decoder)
        self.sha1 = try values.decodeIfPresent(String.self, forKey: "sha1")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(fileBase, forKey: "fileBase")
        try values.encodeIfPresent(fileVersion, forKey: "file_version")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(sequenceID, forKey: "sequence_id")
        try values.encodeIfPresent(sha1, forKey: "sha1")
    }
}

/// File (Conflict)
///
/// A representation of a file that is used to show
public struct FileConflict: Codable {
    /// File (Mini)
    ///
    /// A mini representation of a file, used when
    /// nested under another resource.
    public var fileMini: FileMini
    /// File version (Mini)
    ///
    /// A mini representation of a file version, used when
    /// nested within another resource.
    public var fileVersion: FileVersionMini?
    /// The SHA1 hash of the file.
    ///
    /// Example: "85136C79CBF9FE36BB9D05D0639C70C265C18D37"
    public var sha1: String?

    public init(fileMini: FileMini, fileVersion: FileVersionMini? = nil, sha1: String? = nil) {
        self.fileMini = fileMini
        self.fileVersion = fileVersion
        self.sha1 = sha1
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.fileMini = try FileMini(from: decoder)
        self.fileVersion = try FileVersionMini(from: decoder)
        self.sha1 = try values.decodeIfPresent(String.self, forKey: "sha1")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(fileMini, forKey: "fileMini")
        try values.encodeIfPresent(fileVersion, forKey: "file_version")
        try values.encodeIfPresent(sha1, forKey: "sha1")
    }
}

/// A standard representation of a file request, as returned
/// from any file request API endpoints by default.
public struct FileRequest: Codable {
    /// The date and time when the file request was created.
    ///
    /// Example: "2020-09-28T10:53:43-08:00"
    public var createdAt: Date?
    public var createdBy: CreatedBy?
    /// The optional description of this file request. This is
    /// shown in the Box UI to users uploading files.
    /// 
    /// This defaults to description of the file request that was
    /// copied to create this file request.
    ///
    /// Example: "Following documents are requested for your process"
    public var description: String?
    /// The HTTP `etag` of this file. This can be used in combination with
    /// the `If-Match` header when updating a file request. By providing that
    /// header, a change will only be performed on the  file request if the `etag`
    /// on the file request still matches the `etag` provided in the `If-Match`
    /// header.
    ///
    /// Example: "1"
    public var etag: String?
    /// The date after which a file request will no longer accept new
    /// submissions.
    /// 
    /// After this date, the `status` will automatically be set to
    /// `inactive`.
    ///
    /// Example: "2020-09-28T10:53:43-08:00"
    public var expiresAt: Date?
    public var folder: Folder?
    /// The unique identifier for this file request.
    ///
    /// Example: "42037322"
    public var id: String?
    /// Whether a file request submitter is required to provide
    /// a description of the files they are submitting.
    /// 
    /// When this setting is set to true, the Box UI will show
    /// a description field on the file request form.
    /// 
    /// This defaults to setting of file request that was
    /// copied to create this file request.
    ///
    /// Example: true
    public var isDescriptionRequired: Bool?
    /// Whether a file request submitter is required to provide
    /// their email address.
    /// 
    /// When this setting is set to true, the Box UI will show
    /// an email field on the file request form.
    /// 
    /// This defaults to setting of file request that was
    /// copied to create this file request.
    ///
    /// Example: true
    public var isEmailRequired: Bool?
    /// The status of the file request. This defaults
    /// to `active`.
    /// 
    /// When the status is set to `inactive`, the file request
    /// will no longer accept new submissions, and any visitor
    /// to the file request URL will receive a `HTTP 404` status
    /// code.
    /// 
    /// This defaults to status of file request that was
    /// copied to create this file request.
    ///
    /// Example: "active"
    public var status: Status?
    /// The title of file request. This is shown
    /// in the Box UI to users uploading files.
    /// 
    /// This defaults to title of the file request that was
    /// copied to create this file request.
    ///
    /// Example: "Please upload documents"
    public var title: String?
    /// `file-request`
    ///
    /// Example: "file-request"
    public var type: `Type`?
    /// The date and time when the file request was last updated.
    ///
    /// Example: "2020-09-28T10:53:43-08:00"
    public var updatedAt: Date?
    public var updatedBy: UpdatedBy?
    /// The generated URL for this file request. This URL can be shared
    /// with users to let them upload files to the associated folder.
    ///
    /// Example: "/f/19e57f40ace247278a8e3d336678c64a"
    public var url: String?

    public struct CreatedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user who created this file request.
        public var anyJSON: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Folder: Codable {
        /// Folder (Mini)
        ///
        /// A mini representation of a file version, used when
        /// nested under another resource.
        public var folderMini: FolderMini
        /// The folder that this file request is associated with.
        /// 
        /// Files submitted through the file request form will be
        /// uploaded to this folder.
        public var anyJSON: AnyJSON

        public init(folderMini: FolderMini, anyJSON: AnyJSON) {
            self.folderMini = folderMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.folderMini = try FolderMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(folderMini, forKey: "folderMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// The status of the file request. This defaults
    /// to `active`.
    /// 
    /// When the status is set to `inactive`, the file request
    /// will no longer accept new submissions, and any visitor
    /// to the file request URL will receive a `HTTP 404` status
    /// code.
    /// 
    /// This defaults to status of file request that was
    /// copied to create this file request.
    ///
    /// Example: "active"
    public enum Status: String, Codable, CaseIterable {
        case active
        case inactive
    }

    /// `file-request`
    ///
    /// Example: "file-request"
    public enum `Type`: String, Codable, CaseIterable {
        case fileRequest = "file-request"
    }

    public struct UpdatedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user who last modified this file request.
        public var anyJSON: AnyJSON
        public var anyJSON2: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON, anyJSON2: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
            self.anyJSON2 = anyJSON2
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
            self.anyJSON2 = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
            try values.encode(anyJSON2, forKey: "anyJSON2")
        }
    }

    public init(createdAt: Date? = nil, createdBy: CreatedBy? = nil, description: String? = nil, etag: String? = nil, expiresAt: Date? = nil, folder: Folder? = nil, id: String? = nil, isDescriptionRequired: Bool? = nil, isEmailRequired: Bool? = nil, status: Status? = nil, title: String? = nil, type: `Type`? = nil, updatedAt: Date? = nil, updatedBy: UpdatedBy? = nil, url: String? = nil) {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.etag = etag
        self.expiresAt = expiresAt
        self.folder = folder
        self.id = id
        self.isDescriptionRequired = isDescriptionRequired
        self.isEmailRequired = isEmailRequired
        self.status = status
        self.title = title
        self.type = type
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
        self.url = url
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case createdBy = "created_by"
        case description
        case etag
        case expiresAt = "expires_at"
        case folder
        case id
        case isDescriptionRequired = "is_description_required"
        case isEmailRequired = "is_email_required"
        case status
        case title
        case type
        case updatedAt = "updated_at"
        case updatedBy = "updated_by"
        case url
    }
}

/// File Request (Copy)
///
/// The request body to copy a file request.
public struct FileRequestCopyRequest: Codable {
    /// File Request (Update)
    ///
    /// The request body to update a file request.
    public var fileRequestUpdateRequest: FileRequestUpdateRequest
    /// The folder to associate the new file request to.
    public var folder: Folder?

    /// The folder to associate the new file request to.
    public struct Folder: Codable {
        /// The ID of the folder to associate the new
        /// file request to.
        ///
        /// Example: "42037322"
        public var id: String
        /// `folder`
        ///
        /// Example: "folder"
        public var type: `Type`?

        /// `folder`
        ///
        /// Example: "folder"
        public enum `Type`: String, Codable, CaseIterable {
            case folder
        }

        public init(id: String, type: `Type`? = nil) {
            self.id = id
            self.type = type
        }
    }

    public init(fileRequestUpdateRequest: FileRequestUpdateRequest, folder: Folder? = nil) {
        self.fileRequestUpdateRequest = fileRequestUpdateRequest
        self.folder = folder
    }

    public init(from decoder: Decoder) throws {
        self.fileRequestUpdateRequest = try FileRequestUpdateRequest(from: decoder)
        self.folder = try Folder(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(fileRequestUpdateRequest, forKey: "fileRequestUpdateRequest")
        try values.encodeIfPresent(folder, forKey: "folder")
    }
}

/// File Request (Update)
///
/// The request body to update a file request.
public struct FileRequestUpdateRequest: Codable {
    /// An optional new description for the file request. This can be
    /// used to change the description of the file request.
    /// 
    /// This will default to the value on the existing file request.
    ///
    /// Example: "Please upload required documents"
    public var description: String?
    /// The date after which a file request will no longer accept new
    /// submissions.
    /// 
    /// After this date, the `status` will automatically be set to
    /// `inactive`.
    /// 
    /// This will default to the value on the existing file request.
    ///
    /// Example: "2020-09-28T10:53:43-08:00"
    public var expiresAt: Date?
    /// Whether a file request submitter is required to provide
    /// a description of the files they are submitting.
    /// 
    /// When this setting is set to true, the Box UI will show
    /// a description field on the file request form.
    /// 
    /// This will default to the value on the existing file request.
    ///
    /// Example: true
    public var isDescriptionRequired: Bool?
    /// Whether a file request submitter is required to provide
    /// their email address.
    /// 
    /// When this setting is set to true, the Box UI will show
    /// an email field on the file request form.
    /// 
    /// This will default to the value on the existing file request.
    ///
    /// Example: true
    public var isEmailRequired: Bool?
    /// An optional new status of the file request.
    /// 
    /// When the status is set to `inactive`, the file request
    /// will no longer accept new submissions, and any visitor
    /// to the file request URL will receive a `HTTP 404` status
    /// code.
    /// 
    /// This will default to the value on the existing file request.
    ///
    /// Example: "active"
    public var status: Status?
    /// An optional new title for the file request. This can be
    /// used to change the title of the file request.
    /// 
    /// This will default to the value on the existing file request.
    ///
    /// Example: "Please upload required documents"
    public var title: String?

    /// An optional new status of the file request.
    /// 
    /// When the status is set to `inactive`, the file request
    /// will no longer accept new submissions, and any visitor
    /// to the file request URL will receive a `HTTP 404` status
    /// code.
    /// 
    /// This will default to the value on the existing file request.
    ///
    /// Example: "active"
    public enum Status: String, Codable, CaseIterable {
        case active
        case inactive
    }

    public init(description: String? = nil, expiresAt: Date? = nil, isDescriptionRequired: Bool? = nil, isEmailRequired: Bool? = nil, status: Status? = nil, title: String? = nil) {
        self.description = description
        self.expiresAt = expiresAt
        self.isDescriptionRequired = isDescriptionRequired
        self.isEmailRequired = isEmailRequired
        self.status = status
        self.title = title
    }

    private enum CodingKeys: String, CodingKey {
        case description
        case expiresAt = "expires_at"
        case isDescriptionRequired = "is_description_required"
        case isEmailRequired = "is_email_required"
        case status
        case title
    }
}

/// A relation between a file and the scopes for which the file can be accessed
public struct FileScope: Codable {
    public var object: Object?
    /// The file scopes for the file access
    ///
    /// Example: "item_download"
    public var scope: Scope?

    public struct Object: Codable {
        /// File (Mini)
        ///
        /// A mini representation of a file, used when
        /// nested under another resource.
        public var fileMini: FileMini
        /// The file for which the file can be accessed
        public var anyJSON: AnyJSON

        public init(fileMini: FileMini, anyJSON: AnyJSON) {
            self.fileMini = fileMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.fileMini = try FileMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(fileMini, forKey: "fileMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// The file scopes for the file access
    ///
    /// Example: "item_download"
    public enum Scope: String, Codable, CaseIterable {
        case annotationEdit = "annotation_edit"
        case annotationViewAll = "annotation_view_all"
        case annotationViewSelf = "annotation_view_self"
        case baseExplorer = "base_explorer"
        case basePicker = "base_picker"
        case basePreview = "base_preview"
        case baseUpload = "base_upload"
        case itemDelete = "item_delete"
        case itemDownload = "item_download"
        case itemPreview = "item_preview"
        case itemRename = "item_rename"
        case itemShare = "item_share"
    }

    public init(object: Object? = nil, scope: Scope? = nil) {
        self.object = object
        self.scope = scope
    }
}

/// A standard representation of a file version
public struct FileVersion: Codable {
    /// File version (Mini)
    ///
    /// A mini representation of a file version, used when
    /// nested within another resource.
    public var fileVersionMini: FileVersionMini
    /// When the file version object was created
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var createdAt: Date?
    /// When the file version object was last updated
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var modifiedAt: Date?
    public var modifiedBy: ModifiedBy?
    /// The name of the file version
    ///
    /// Example: "tigers.jpeg"
    public var name: String?
    /// When the file version object will be permanently deleted.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var purgedAt: Date?
    /// When the file version was restored from the trash.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var restoredAt: Date?
    public var restoredBy: RestoredBy?
    /// Size of the file version in bytes
    ///
    /// Example: 629644
    public var size: Int?
    /// When the file version object was trashed.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var trashedAt: Date?
    public var trashedBy: TrashedBy?
    public var uploaderDisplayName: String?

    public struct ModifiedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user who last updated the file version
        public var anyJSON: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct RestoredBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user who restored the file version from the trash.
        public var anyJSON: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct TrashedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user who trashed the file version
        public var anyJSON: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(fileVersionMini: FileVersionMini, createdAt: Date? = nil, modifiedAt: Date? = nil, modifiedBy: ModifiedBy? = nil, name: String? = nil, purgedAt: Date? = nil, restoredAt: Date? = nil, restoredBy: RestoredBy? = nil, size: Int? = nil, trashedAt: Date? = nil, trashedBy: TrashedBy? = nil, uploaderDisplayName: String? = nil) {
        self.fileVersionMini = fileVersionMini
        self.createdAt = createdAt
        self.modifiedAt = modifiedAt
        self.modifiedBy = modifiedBy
        self.name = name
        self.purgedAt = purgedAt
        self.restoredAt = restoredAt
        self.restoredBy = restoredBy
        self.size = size
        self.trashedAt = trashedAt
        self.trashedBy = trashedBy
        self.uploaderDisplayName = uploaderDisplayName
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.fileVersionMini = try FileVersionMini(from: decoder)
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
        self.modifiedAt = try values.decodeIfPresent(Date.self, forKey: "modified_at")
        self.modifiedBy = try ModifiedBy(from: decoder)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.purgedAt = try values.decodeIfPresent(Date.self, forKey: "purged_at")
        self.restoredAt = try values.decodeIfPresent(Date.self, forKey: "restored_at")
        self.restoredBy = try RestoredBy(from: decoder)
        self.size = try values.decodeIfPresent(Int.self, forKey: "size")
        self.trashedAt = try values.decodeIfPresent(Date.self, forKey: "trashed_at")
        self.trashedBy = try TrashedBy(from: decoder)
        self.uploaderDisplayName = try values.decodeIfPresent(String.self, forKey: "uploader_display_name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(fileVersionMini, forKey: "fileVersionMini")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(modifiedAt, forKey: "modified_at")
        try values.encodeIfPresent(modifiedBy, forKey: "modified_by")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(purgedAt, forKey: "purged_at")
        try values.encodeIfPresent(restoredAt, forKey: "restored_at")
        try values.encodeIfPresent(restoredBy, forKey: "restored_by")
        try values.encodeIfPresent(size, forKey: "size")
        try values.encodeIfPresent(trashedAt, forKey: "trashed_at")
        try values.encodeIfPresent(trashedBy, forKey: "trashed_by")
        try values.encodeIfPresent(uploaderDisplayName, forKey: "uploader_display_name")
    }
}

/// File version (Base)
///
/// The bare basic representation of a file version, the minimal
/// amount of fields returned when using the `fields` query
/// parameter.
public struct FileVersionBase: Codable {
    /// The unique identifier that represent a file version.
    ///
    /// Example: "12345"
    public var id: String?
    /// `file_version`
    ///
    /// Example: "file_version"
    public var type: `Type`?

    /// `file_version`
    ///
    /// Example: "file_version"
    public enum `Type`: String, Codable, CaseIterable {
        case fileVersion = "file_version"
    }

    public init(id: String? = nil, type: `Type`? = nil) {
        self.id = id
        self.type = type
    }
}

/// File version (Mini)
///
/// A mini representation of a file version, used when
/// nested within another resource.
public struct FileVersionMini: Codable {
    /// File version (Base)
    ///
    /// The bare basic representation of a file version, the minimal
    /// amount of fields returned when using the `fields` query
    /// parameter.
    public var fileVersionBase: FileVersionBase
    /// The SHA1 hash of this version of the file.
    ///
    /// Example: "134b65991ed521fcfe4724b7d814ab8ded5185dc"
    public var sha1: String?

    public init(fileVersionBase: FileVersionBase, sha1: String? = nil) {
        self.fileVersionBase = fileVersionBase
        self.sha1 = sha1
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.fileVersionBase = try FileVersionBase(from: decoder)
        self.sha1 = try values.decodeIfPresent(String.self, forKey: "sha1")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(fileVersionBase, forKey: "fileVersionBase")
        try values.encodeIfPresent(sha1, forKey: "sha1")
    }
}

/// File-Version-Legal-Hold is an entity representing all
/// holds on a File Version.
public struct FileVersionLegalHold: Codable {
    /// Time that this File-Version-Legal-Hold was
    /// deleted.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var deletedAt: Date?
    public var file: File?
    public var fileVersion: FileVersion?
    /// The unique identifier for this file version legal hold
    ///
    /// Example: "11446498"
    public var id: String?
    /// List of assignments contributing to this Hold.
    public var legalHoldPolicyAssignments: [LegalHoldPolicyAssignment]?
    /// `file_version_legal_hold`
    ///
    /// Example: "file_version_legal_hold"
    public var type: `Type`?

    public struct File: Codable {
        /// File (Mini)
        ///
        /// A mini representation of a file, used when
        /// nested under another resource.
        public var fileMini: FileMini
        /// The file for the file version held.
        /// Note that there is no guarantee that the current
        /// version of this file is held.
        public var anyJSON: AnyJSON

        public init(fileMini: FileMini, anyJSON: AnyJSON) {
            self.fileMini = fileMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.fileMini = try FileMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(fileMini, forKey: "fileMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct FileVersion: Codable {
        /// File version (Mini)
        ///
        /// A mini representation of a file version, used when
        /// nested within another resource.
        public var fileVersionMini: FileVersionMini
        /// The file version that is held
        public var anyJSON: AnyJSON

        public init(fileVersionMini: FileVersionMini, anyJSON: AnyJSON) {
            self.fileVersionMini = fileVersionMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.fileVersionMini = try FileVersionMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(fileVersionMini, forKey: "fileVersionMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// `file_version_legal_hold`
    ///
    /// Example: "file_version_legal_hold"
    public enum `Type`: String, Codable, CaseIterable {
        case fileVersionLegalHold = "file_version_legal_hold"
    }

    public init(deletedAt: Date? = nil, file: File? = nil, fileVersion: FileVersion? = nil, id: String? = nil, legalHoldPolicyAssignments: [LegalHoldPolicyAssignment]? = nil, type: `Type`? = nil) {
        self.deletedAt = deletedAt
        self.file = file
        self.fileVersion = fileVersion
        self.id = id
        self.legalHoldPolicyAssignments = legalHoldPolicyAssignments
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case deletedAt = "deleted_at"
        case file
        case fileVersion = "file_version"
        case id
        case legalHoldPolicyAssignments = "legal_hold_policy_assignments"
        case type
    }
}

/// A list of file version legal holds.
public struct FileVersionLegalHolds: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The marker for the start of the next page of results.
    ///
    /// Example: 3000
    public var nextMarker: Int?
    /// The marker for the start of the previous page of results.
    ///
    /// Example: 1000
    public var prevMarker: Int?
    public var entries: [FileVersionLegalHold]?

    public init(limit: Int? = nil, nextMarker: Int? = nil, prevMarker: Int? = nil, entries: [FileVersionLegalHold]? = nil) {
        self.limit = limit
        self.nextMarker = nextMarker
        self.prevMarker = prevMarker
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.nextMarker = try values.decodeIfPresent(Int.self, forKey: "next_marker")
        self.prevMarker = try values.decodeIfPresent(Int.self, forKey: "prev_marker")
        self.entries = try values.decodeIfPresent([FileVersionLegalHold].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(nextMarker, forKey: "next_marker")
        try values.encodeIfPresent(prevMarker, forKey: "prev_marker")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// A retention policy blocks permanent deletion of content
/// for a specified amount of time. Admins can apply policies to
/// specified folders, or an entire enterprise. A file version retention
/// is a  record for a retained file version. To use this feature,
/// you must  have the manage retention policies scope enabled for your
/// API key via  your application management console. For more information
/// about retention policies, please visit our help documentation
public struct FileVersionRetention: Codable {
    /// When this file version retention object was
    /// created
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var appliedAt: Date?
    /// When the retention expires on this file
    /// version retention
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var dispositionAt: Date?
    public var file: File?
    public var fileVersion: FileVersion?
    /// The unique identifier for this file version retention.
    ///
    /// Example: "11446498"
    public var id: String?
    /// `file_version_retention`
    ///
    /// Example: "file_version_retention"
    public var type: `Type`?
    public var winningRetentionPolicy: WinningRetentionPolicy?

    public struct File: Codable {
        /// File (Mini)
        ///
        /// A mini representation of a file, used when
        /// nested under another resource.
        public var fileMini: FileMini
        /// The file this file version retention was applied to
        public var anyJSON: AnyJSON

        public init(fileMini: FileMini, anyJSON: AnyJSON) {
            self.fileMini = fileMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.fileMini = try FileMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(fileMini, forKey: "fileMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct FileVersion: Codable {
        /// File version (Mini)
        ///
        /// A mini representation of a file version, used when
        /// nested within another resource.
        public var fileVersionMini: FileVersionMini
        /// The file version this file version retention was
        /// applied to
        public var anyJSON: AnyJSON

        public init(fileVersionMini: FileVersionMini, anyJSON: AnyJSON) {
            self.fileVersionMini = fileVersionMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.fileVersionMini = try FileVersionMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(fileVersionMini, forKey: "fileVersionMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// `file_version_retention`
    ///
    /// Example: "file_version_retention"
    public enum `Type`: String, Codable, CaseIterable {
        case fileVersionRetention = "file_version_retention"
    }

    public struct WinningRetentionPolicy: Codable {
        /// Retention policy (Mini)
        ///
        /// A mini representation of a retention policy, used when
        /// nested within another resource.
        public var retentionPolicyMini: RetentionPolicyMini
        /// The winning retention policy applied to this file
        /// version retention. A file version can have multiple
        /// retention policies applied.
        public var anyJSON: AnyJSON

        public init(retentionPolicyMini: RetentionPolicyMini, anyJSON: AnyJSON) {
            self.retentionPolicyMini = retentionPolicyMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.retentionPolicyMini = try RetentionPolicyMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(retentionPolicyMini, forKey: "retentionPolicyMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(appliedAt: Date? = nil, dispositionAt: Date? = nil, file: File? = nil, fileVersion: FileVersion? = nil, id: String? = nil, type: `Type`? = nil, winningRetentionPolicy: WinningRetentionPolicy? = nil) {
        self.appliedAt = appliedAt
        self.dispositionAt = dispositionAt
        self.file = file
        self.fileVersion = fileVersion
        self.id = id
        self.type = type
        self.winningRetentionPolicy = winningRetentionPolicy
    }

    private enum CodingKeys: String, CodingKey {
        case appliedAt = "applied_at"
        case dispositionAt = "disposition_at"
        case file
        case fileVersion = "file_version"
        case id
        case type
        case winningRetentionPolicy = "winning_retention_policy"
    }
}

/// A list of file version retentions.
public struct FileVersionRetentions: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The marker for the start of the next page of results.
    ///
    /// Example: 3000
    public var nextMarker: Int?
    /// The marker for the start of the previous page of results.
    ///
    /// Example: 1000
    public var prevMarker: Int?
    public var entries: [FileVersionRetention]?

    public init(limit: Int? = nil, nextMarker: Int? = nil, prevMarker: Int? = nil, entries: [FileVersionRetention]? = nil) {
        self.limit = limit
        self.nextMarker = nextMarker
        self.prevMarker = prevMarker
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.nextMarker = try values.decodeIfPresent(Int.self, forKey: "next_marker")
        self.prevMarker = try values.decodeIfPresent(Int.self, forKey: "prev_marker")
        self.entries = try values.decodeIfPresent([FileVersionRetention].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(nextMarker, forKey: "next_marker")
        try values.encodeIfPresent(prevMarker, forKey: "prev_marker")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// A list of file versions
public struct FileVersions: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The 0-based offset of the first entry in this set. This will be the same
    /// as the `offset` query parameter.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    ///
    /// Example: 2000
    public var offset: Int?
    /// The order by which items are returned.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    public var order: [OrderItem]?
    /// One greater than the offset of the last entry in the entire collection.
    /// The total number of entries in the collection may be less than
    /// `total_count`.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    ///
    /// Example: 5000
    public var totalCount: Int?
    public var entries: [FileVersion]?

    /// The order in which a pagination is ordered
    public struct OrderItem: Codable {
        /// The field to order by
        ///
        /// Example: "type"
        public var by: String?
        /// The direction to order by, either ascending or descending
        ///
        /// Example: "ASC"
        public var direction: Direction?

        /// The direction to order by, either ascending or descending
        ///
        /// Example: "ASC"
        public enum Direction: String, Codable, CaseIterable {
            case asc = "ASC"
            case desc = "DESC"
        }

        public init(by: String? = nil, direction: Direction? = nil) {
            self.by = by
            self.direction = direction
        }
    }

    public init(limit: Int? = nil, offset: Int? = nil, order: [OrderItem]? = nil, totalCount: Int? = nil, entries: [FileVersion]? = nil) {
        self.limit = limit
        self.offset = offset
        self.order = order
        self.totalCount = totalCount
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.offset = try values.decodeIfPresent(Int.self, forKey: "offset")
        self.order = try values.decodeIfPresent([OrderItem].self, forKey: "order")
        self.totalCount = try values.decodeIfPresent(Int.self, forKey: "total_count")
        self.entries = try values.decodeIfPresent([FileVersion].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(offset, forKey: "offset")
        try values.encodeIfPresent(order, forKey: "order")
        try values.encodeIfPresent(totalCount, forKey: "total_count")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// A list of files
public struct Files: Codable {
    /// A list of files
    public var entries: [File]?
    /// The number of files.
    public var totalCount: Int?

    public init(entries: [File]? = nil, totalCount: Int? = nil) {
        self.entries = entries
        self.totalCount = totalCount
    }

    private enum CodingKeys: String, CodingKey {
        case entries
        case totalCount = "total_count"
    }
}

/// A standard representation of a folder, as returned from any
/// folder API endpoints by default
public struct Folder: Codable {
    /// Folder (Mini)
    ///
    /// A mini representation of a file version, used when
    /// nested under another resource.
    public var folderMini: FolderMini
    /// The date and time at which this folder was originally
    /// created.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var contentCreatedAt: Date?
    /// The date and time at which this folder was last updated.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var contentModifiedAt: Date?
    /// The date and time when the folder was created. This value may
    /// be `null` for some folders such as the root folder or the trash
    /// folder.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var createdAt: Date?
    public var createdBy: CreatedBy?
    public var description: Description?
    /// The time and which the folder will be automatically be deleted.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var expiresAt: Date?
    public var folderUploadEmail: FolderUploadEmail?
    public var itemCollection: ItemCollection?
    /// Defines if this item has been deleted or not.
    /// 
    /// * `active` when the item has is not in the trash
    /// * `trashed` when the item has been moved to the trash but not deleted
    /// * `deleted` when the item has been permanently deleted.
    ///
    /// Example: "active"
    public var itemStatus: ItemStatus?
    /// The date and time when the folder was last updated. This value may
    /// be `null` for some folders such as the root folder or the trash
    /// folder.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var modifiedAt: Date?
    public var modifiedBy: ModifiedBy?
    public var ownedBy: OwnedBy?
    public var parent: Parent?
    public var pathCollection: PathCollection?
    /// The time at which this folder is expected to be purged
    /// from the trash.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var purgedAt: Date?
    public var sharedLink: SharedLink?
    /// The folder size in bytes.
    /// 
    /// Be careful parsing this integer as its
    /// value can get very large.
    ///
    /// Example: 629644
    public var size: Int?
    /// The time at which this folder was put in the trash.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var trashedAt: Date?

    public struct CreatedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user who created this folder
        public var anyJSON: AnyJSON
        public var anyJSON2: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON, anyJSON2: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
            self.anyJSON2 = anyJSON2
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
            self.anyJSON2 = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
            try values.encode(anyJSON2, forKey: "anyJSON2")
        }
    }

    public struct Description: Codable {
        /// The optional description of this folder
        ///
        /// Example: "Legal contracts for the new ACME deal"
        public var string: String
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct FolderUploadEmail: Codable {
        /// When this parameter has been set, users can email files
        /// to the email address that has been automatically
        /// created for this folder.
        /// 
        /// To create an email address, set this property either when
        /// creating or updating the folder.
        /// 
        /// When set to `collaborators`, only emails from registered email
        /// addresses for collaborators will be accepted. This includes
        /// any email aliases a user might have registered.
        /// 
        /// When set to `open` it will accept emails from any email
        /// address.
        ///
        /// Example: "open"
        public var access: Access?
        /// The optional upload email address for this folder.
        ///
        /// Example: "upload.Contracts.asd7asd@u.box.com"
        public var email: String?

        /// When this parameter has been set, users can email files
        /// to the email address that has been automatically
        /// created for this folder.
        /// 
        /// To create an email address, set this property either when
        /// creating or updating the folder.
        /// 
        /// When set to `collaborators`, only emails from registered email
        /// addresses for collaborators will be accepted. This includes
        /// any email aliases a user might have registered.
        /// 
        /// When set to `open` it will accept emails from any email
        /// address.
        ///
        /// Example: "open"
        public enum Access: String, Codable, CaseIterable {
            case `open`
            case collaborators
        }

        public init(access: Access? = nil, email: String? = nil) {
            self.access = access
            self.email = email
        }
    }

    public struct ItemCollection: Codable {
        /// A list of files, folders, and web links in
        /// their mini representation.
        public var items: Items
        /// A page of the items that are in the folder.
        /// 
        /// This field can only be requested when querying a folder's
        /// information, not when querying a folder's items.
        public var anyJSON: AnyJSON
        public var anyJSON2: AnyJSON

        public init(items: Items, anyJSON: AnyJSON, anyJSON2: AnyJSON) {
            self.items = items
            self.anyJSON = anyJSON
            self.anyJSON2 = anyJSON2
        }

        public init(from decoder: Decoder) throws {
            self.items = try Items(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
            self.anyJSON2 = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(items, forKey: "items")
            try values.encode(anyJSON, forKey: "anyJSON")
            try values.encode(anyJSON2, forKey: "anyJSON2")
        }
    }

    /// Defines if this item has been deleted or not.
    /// 
    /// * `active` when the item has is not in the trash
    /// * `trashed` when the item has been moved to the trash but not deleted
    /// * `deleted` when the item has been permanently deleted.
    ///
    /// Example: "active"
    public enum ItemStatus: String, Codable, CaseIterable {
        case active
        case trashed
        case deleted
    }

    public struct ModifiedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user who last modified this folder.
        public var anyJSON: AnyJSON
        public var anyJSON2: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON, anyJSON2: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
            self.anyJSON2 = anyJSON2
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
            self.anyJSON2 = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
            try values.encode(anyJSON2, forKey: "anyJSON2")
        }
    }

    public struct OwnedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user who owns this folder.
        public var anyJSON: AnyJSON
        public var anyJSON2: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON, anyJSON2: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
            self.anyJSON2 = anyJSON2
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
            self.anyJSON2 = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
            try values.encode(anyJSON2, forKey: "anyJSON2")
        }
    }

    public struct Parent: Codable {
        /// Folder (Mini)
        ///
        /// A mini representation of a file version, used when
        /// nested under another resource.
        public var folderMini: FolderMini
        /// The optional folder that this folder is located within.
        /// 
        /// This value may be `null` for some folders such as the
        /// root folder or the trash folder.
        public var anyJSON: AnyJSON

        public init(folderMini: FolderMini, anyJSON: AnyJSON) {
            self.folderMini = folderMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.folderMini = try FolderMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(folderMini, forKey: "folderMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct PathCollection: Codable {
        /// The parent folders for this item
        public var entries: [FolderMini]?
        /// The number of folders in this list.
        public var totalCount: Int?
        /// The tree of folders that this folder is contained in,
        /// starting at the root.
        public var anyJSON: AnyJSON
        public var anyJSON2: AnyJSON

        public init(entries: [FolderMini]? = nil, totalCount: Int? = nil, anyJSON: AnyJSON, anyJSON2: AnyJSON) {
            self.entries = entries
            self.totalCount = totalCount
            self.anyJSON = anyJSON
            self.anyJSON2 = anyJSON2
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.entries = try values.decodeIfPresent([FolderMini].self, forKey: "entries")
            self.totalCount = try values.decodeIfPresent(Int.self, forKey: "total_count")
            self.anyJSON = try AnyJSON(from: decoder)
            self.anyJSON2 = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(entries, forKey: "entries")
            try values.encodeIfPresent(totalCount, forKey: "total_count")
            try values.encode(anyJSON, forKey: "anyJSON")
            try values.encode(anyJSON2, forKey: "anyJSON2")
        }
    }

    public struct SharedLink: Codable {
        /// The access level for this shared link.
        /// 
        /// * `open` - provides access to this item to anyone with this link
        /// * `company` - only provides access to this item to people the same company
        /// * `collaborators` - only provides access to this item to people who are
        ///    collaborators on this item
        /// 
        /// If this field is omitted when creating the shared link, the access level
        /// will be set to the default access level specified by the enterprise admin.
        ///
        /// Example: "open"
        public var access: Access?
        /// The number of times this item has been downloaded.
        public var downloadCount: Int?
        /// A URL that can be used to download the file. This URL can be used in
        /// a browser to download the file. This URL includes the file
        /// extension so that the file will be saved with the right file type.
        /// 
        /// This property will be `null` for folders.
        ///
        /// Example: "https://www.box.com/shared/static/rh935iit6ewrmw0unyul.jpeg"
        public var downloadURL: String?
        /// The effective access level for the shared link. This can be a more
        /// restrictive access level than the value in the `access` field when the
        /// enterprise settings restrict the allowed access levels.
        ///
        /// Example: "company"
        public var effectiveAccess: EffectiveAccess?
        /// The effective permissions for this shared link.
        ///
        /// Example: "can_download"
        public var effectivePermission: EffectivePermission?
        /// Defines if the shared link requires a password to access the item.
        ///
        /// Example: true
        public var isPasswordEnabled: Bool?
        /// Defines if this link allows a user to preview and download an item.
        public var permissions: Permissions?
        /// The number of times this item has been previewed.
        public var previewCount: Int?
        /// The date and time when this link will be unshared. This field can only be
        /// set by users with paid accounts.
        ///
        /// Example: "2018-04-13T13:53:23-07:00"
        public var unsharedAt: Date?
        /// The URL that can be used to access the item on Box.
        /// 
        /// This URL will display the item in Box's preview UI where the file
        /// can be downloaded if allowed.
        /// 
        /// This URL will continue to work even when a custom `vanity_url`
        /// has been set for this shared link.
        ///
        /// Example: "https://www.box.com/s/vspke7y05sb214wjokpk"
        public var url: String?
        /// The custom name of a shared link, as used in the `vanity_url` field.
        ///
        /// Example: "my_url"
        public var vanityName: String?
        /// The "Custom URL" that can also be used to preview the item on Box.  Custom
        /// URLs can only be created or modified in the Box Web application.
        ///
        /// Example: "https://acme.app.box.com/v/my_url/"
        public var vanityURL: String?
        /// The shared link for this folder. This will be
        /// `null` if no shared link has been created for this
        /// folder.
        public var anyJSON: AnyJSON

        /// The access level for this shared link.
        /// 
        /// * `open` - provides access to this item to anyone with this link
        /// * `company` - only provides access to this item to people the same company
        /// * `collaborators` - only provides access to this item to people who are
        ///    collaborators on this item
        /// 
        /// If this field is omitted when creating the shared link, the access level
        /// will be set to the default access level specified by the enterprise admin.
        ///
        /// Example: "open"
        public enum Access: String, Codable, CaseIterable {
            case `open`
            case company
            case collaborators
        }

        /// The effective access level for the shared link. This can be a more
        /// restrictive access level than the value in the `access` field when the
        /// enterprise settings restrict the allowed access levels.
        ///
        /// Example: "company"
        public enum EffectiveAccess: String, Codable, CaseIterable {
            case `open`
            case company
            case collaborators
        }

        /// The effective permissions for this shared link.
        ///
        /// Example: "can_download"
        public enum EffectivePermission: String, Codable, CaseIterable {
            case canDownload = "can_download"
            case canPreview = "can_preview"
        }

        /// Defines if this link allows a user to preview and download an item.
        public struct Permissions: Codable {
            /// Defines if the shared link allows for the item to be downloaded. For
            /// shared links on folders, this also applies to any items in the folder.
            /// 
            /// This value can be set to `true` when the effective access level is
            /// set to `open` or `company`, not `collaborators`.
            ///
            /// Example: true
            public var canDownload: Bool?
            /// Defines if the shared link allows for the item to be previewed.
            /// 
            /// This value is always `true`. For shared links on folders this also
            /// applies to any items in the folder.
            ///
            /// Example: true
            public var canPreview: Bool?

            public init(canDownload: Bool? = nil, canPreview: Bool? = nil) {
                self.canDownload = canDownload
                self.canPreview = canPreview
            }

            private enum CodingKeys: String, CodingKey {
                case canDownload = "can_download"
                case canPreview = "can_preview"
            }
        }

        public init(access: Access? = nil, downloadCount: Int? = nil, downloadURL: String? = nil, effectiveAccess: EffectiveAccess? = nil, effectivePermission: EffectivePermission? = nil, isPasswordEnabled: Bool? = nil, permissions: Permissions? = nil, previewCount: Int? = nil, unsharedAt: Date? = nil, url: String? = nil, vanityName: String? = nil, vanityURL: String? = nil, anyJSON: AnyJSON) {
            self.access = access
            self.downloadCount = downloadCount
            self.downloadURL = downloadURL
            self.effectiveAccess = effectiveAccess
            self.effectivePermission = effectivePermission
            self.isPasswordEnabled = isPasswordEnabled
            self.permissions = permissions
            self.previewCount = previewCount
            self.unsharedAt = unsharedAt
            self.url = url
            self.vanityName = vanityName
            self.vanityURL = vanityURL
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.access = try Access(from: decoder)
            self.downloadCount = try values.decodeIfPresent(Int.self, forKey: "download_count")
            self.downloadURL = try values.decodeIfPresent(String.self, forKey: "download_url")
            self.effectiveAccess = try EffectiveAccess(from: decoder)
            self.effectivePermission = try EffectivePermission(from: decoder)
            self.isPasswordEnabled = try values.decodeIfPresent(Bool.self, forKey: "is_password_enabled")
            self.permissions = try Permissions(from: decoder)
            self.previewCount = try values.decodeIfPresent(Int.self, forKey: "preview_count")
            self.unsharedAt = try values.decodeIfPresent(Date.self, forKey: "unshared_at")
            self.url = try values.decodeIfPresent(String.self, forKey: "url")
            self.vanityName = try values.decodeIfPresent(String.self, forKey: "vanity_name")
            self.vanityURL = try values.decodeIfPresent(String.self, forKey: "vanity_url")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(access, forKey: "access")
            try values.encodeIfPresent(downloadCount, forKey: "download_count")
            try values.encodeIfPresent(downloadURL, forKey: "download_url")
            try values.encodeIfPresent(effectiveAccess, forKey: "effective_access")
            try values.encodeIfPresent(effectivePermission, forKey: "effective_permission")
            try values.encodeIfPresent(isPasswordEnabled, forKey: "is_password_enabled")
            try values.encodeIfPresent(permissions, forKey: "permissions")
            try values.encodeIfPresent(previewCount, forKey: "preview_count")
            try values.encodeIfPresent(unsharedAt, forKey: "unshared_at")
            try values.encodeIfPresent(url, forKey: "url")
            try values.encodeIfPresent(vanityName, forKey: "vanity_name")
            try values.encodeIfPresent(vanityURL, forKey: "vanity_url")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(folderMini: FolderMini, contentCreatedAt: Date? = nil, contentModifiedAt: Date? = nil, createdAt: Date? = nil, createdBy: CreatedBy? = nil, description: Description? = nil, expiresAt: Date? = nil, folderUploadEmail: FolderUploadEmail? = nil, itemCollection: ItemCollection? = nil, itemStatus: ItemStatus? = nil, modifiedAt: Date? = nil, modifiedBy: ModifiedBy? = nil, ownedBy: OwnedBy? = nil, parent: Parent? = nil, pathCollection: PathCollection? = nil, purgedAt: Date? = nil, sharedLink: SharedLink? = nil, size: Int? = nil, trashedAt: Date? = nil) {
        self.folderMini = folderMini
        self.contentCreatedAt = contentCreatedAt
        self.contentModifiedAt = contentModifiedAt
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.expiresAt = expiresAt
        self.folderUploadEmail = folderUploadEmail
        self.itemCollection = itemCollection
        self.itemStatus = itemStatus
        self.modifiedAt = modifiedAt
        self.modifiedBy = modifiedBy
        self.ownedBy = ownedBy
        self.parent = parent
        self.pathCollection = pathCollection
        self.purgedAt = purgedAt
        self.sharedLink = sharedLink
        self.size = size
        self.trashedAt = trashedAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.folderMini = try FolderMini(from: decoder)
        self.contentCreatedAt = try values.decodeIfPresent(Date.self, forKey: "content_created_at")
        self.contentModifiedAt = try values.decodeIfPresent(Date.self, forKey: "content_modified_at")
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
        self.createdBy = try CreatedBy(from: decoder)
        self.description = try Description(from: decoder)
        self.expiresAt = try values.decodeIfPresent(Date.self, forKey: "expires_at")
        self.folderUploadEmail = try FolderUploadEmail(from: decoder)
        self.itemCollection = try ItemCollection(from: decoder)
        self.itemStatus = try ItemStatus(from: decoder)
        self.modifiedAt = try values.decodeIfPresent(Date.self, forKey: "modified_at")
        self.modifiedBy = try ModifiedBy(from: decoder)
        self.ownedBy = try OwnedBy(from: decoder)
        self.parent = try Parent(from: decoder)
        self.pathCollection = try PathCollection(from: decoder)
        self.purgedAt = try values.decodeIfPresent(Date.self, forKey: "purged_at")
        self.sharedLink = try SharedLink(from: decoder)
        self.size = try values.decodeIfPresent(Int.self, forKey: "size")
        self.trashedAt = try values.decodeIfPresent(Date.self, forKey: "trashed_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(folderMini, forKey: "folderMini")
        try values.encodeIfPresent(contentCreatedAt, forKey: "content_created_at")
        try values.encodeIfPresent(contentModifiedAt, forKey: "content_modified_at")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(createdBy, forKey: "created_by")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(expiresAt, forKey: "expires_at")
        try values.encodeIfPresent(folderUploadEmail, forKey: "folder_upload_email")
        try values.encodeIfPresent(itemCollection, forKey: "item_collection")
        try values.encodeIfPresent(itemStatus, forKey: "item_status")
        try values.encodeIfPresent(modifiedAt, forKey: "modified_at")
        try values.encodeIfPresent(modifiedBy, forKey: "modified_by")
        try values.encodeIfPresent(ownedBy, forKey: "owned_by")
        try values.encodeIfPresent(parent, forKey: "parent")
        try values.encodeIfPresent(pathCollection, forKey: "path_collection")
        try values.encodeIfPresent(purgedAt, forKey: "purged_at")
        try values.encodeIfPresent(sharedLink, forKey: "shared_link")
        try values.encodeIfPresent(size, forKey: "size")
        try values.encodeIfPresent(trashedAt, forKey: "trashed_at")
    }
}

/// Folder (Base)
///
/// The bare basic representation of a folder, the minimal
/// amount of fields returned when using the `fields` query
/// parameter.
public struct FolderBase: Codable {
    /// The HTTP `etag` of this folder. This can be used within some API
    /// endpoints in the `If-Match` and `If-None-Match` headers to only
    /// perform changes on the folder if (no) changes have happened.
    ///
    /// Example: "1"
    public var etag: String?
    /// The unique identifier that represent a folder.
    /// 
    /// The ID for any folder can be determined
    /// by visiting a folder in the web application
    /// and copying the ID from the URL. For example,
    /// for the URL `https://*.app.box.com/folders/123`
    /// the `folder_id` is `123`.
    ///
    /// Example: "12345"
    public var id: String?
    /// `folder`
    ///
    /// Example: "folder"
    public var type: `Type`?

    /// `folder`
    ///
    /// Example: "folder"
    public enum `Type`: String, Codable, CaseIterable {
        case folder
    }

    public init(etag: String? = nil, id: String? = nil, type: `Type`? = nil) {
        self.etag = etag
        self.id = id
        self.type = type
    }
}

/// Folder (Full)
///
/// A full representation of a folder, as can be returned from any
/// folder API endpoints by default
public struct FolderFull: Codable {
    /// A standard representation of a folder, as returned from any
    /// folder API endpoints by default
    public var folder: Folder
    /// A list of the types of roles that user can be invited at
    /// when sharing this folder.
    ///
    /// Example: ["editor"]
    public var allowedInviteeRoles: [AllowedInviteeRole]?
    /// A list of access levels that are available
    /// for this folder.
    /// 
    /// For some folders, like the root folder, this will always
    /// be an empty list as sharing is not allowed at that level.
    ///
    /// Example: ["open"]
    public var allowedSharedLinkAccessLevels: [AllowedSharedLinkAccessLevel]?
    public var canNonOwnersInvite: CanNonOwnersInvite?
    /// Specifies if collaborators who are not owners
    /// of this folder are restricted from viewing other
    /// collaborations on this folder.
    /// 
    /// It also restricts non-owners from inviting new
    /// collaborators.
    ///
    /// Example: true
    public var canNonOwnersViewCollaborators: Bool?
    public var classification: Classification?
    /// Specifies if this folder has any other collaborators.
    ///
    /// Example: true
    public var hasCollaborations: Bool?
    public var isCollaborationRestrictedToEnterprise: IsCollaborationRestrictedToEnterprise?
    /// Specifies if this folder is owned by a user outside of the
    /// authenticated enterprise.
    ///
    /// Example: true
    public var isExternallyOwned: Bool?
    public var metadata: AnyJSON?
    public var permissions: Permissions?
    public var syncState: Object?
    public var tags: Tags?
    public var watermarkInfo: WatermarkInfo?

    public enum AllowedInviteeRole: String, Codable, CaseIterable {
        case editor
        case viewer
        case previewer
        case uploader
        case previewerUploader = "previewer uploader"
        case viewerUploader = "viewer uploader"
        case coOwner = "co-owner"
    }

    public enum AllowedSharedLinkAccessLevel: String, Codable, CaseIterable {
        case `open`
        case company
        case collaborators
    }

    public struct CanNonOwnersInvite: Codable {
        /// Specifies if users who are not the owner
        /// of the folder can invite new collaborators to the folder.
        ///
        /// Example: true
        public var isBool: Bool
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Classification: Codable {
        /// The color that is used to display the
        /// classification label in a user-interface. Colors are defined by the admin
        /// or co-admin who created the classification in the Box web app.
        ///
        /// Example: "#FF0000"
        public var color: String?
        /// An explanation of the meaning of this classification.
        ///
        /// Example: "Content that should not be shared outside the company."
        public var definition: String?
        /// The name of the classification
        ///
        /// Example: "Top Secret"
        public var name: String?
        /// Details about the classification applied to this folder.
        public var anyJSON: AnyJSON
        public var anyJSON2: AnyJSON?

        public init(color: String? = nil, definition: String? = nil, name: String? = nil, anyJSON: AnyJSON, anyJSON2: AnyJSON? = nil) {
            self.color = color
            self.definition = definition
            self.name = name
            self.anyJSON = anyJSON
            self.anyJSON2 = anyJSON2
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.color = try values.decodeIfPresent(String.self, forKey: "color")
            self.definition = try values.decodeIfPresent(String.self, forKey: "definition")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.anyJSON = try AnyJSON(from: decoder)
            self.anyJSON2 = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(color, forKey: "color")
            try values.encodeIfPresent(definition, forKey: "definition")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encode(anyJSON, forKey: "anyJSON")
            try values.encodeIfPresent(anyJSON2, forKey: "anyJSON2")
        }
    }

    public struct IsCollaborationRestrictedToEnterprise: Codable {
        /// Specifies if new invites to this folder are restricted to users
        /// within the enterprise. This does not affect existing
        /// collaborations.
        ///
        /// Example: true
        public var isBool: Bool
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Permissions: Codable {
        /// The permissions that the authenticated user has for a folder.
        public var object: Object
        /// Describes the permissions that the current user has
        /// for this folder
        public var anyJSON: AnyJSON
        public var anyJSON2: AnyJSON

        /// The permissions that the authenticated user has for a folder.
        public struct Object: Codable {
            /// Specifies if the current user can delete this item.
            ///
            /// Example: true
            public var canDelete: Bool?
            /// Specifies if the current user can download this item.
            ///
            /// Example: true
            public var canDownload: Bool?
            /// Specifies if the current user can invite new
            /// users to collaborate on this item, and if the user can
            /// update the role of a user already collaborated on this
            /// item.
            ///
            /// Example: true
            public var canInviteCollaborator: Bool?
            /// Specifies if the user can rename this item.
            ///
            /// Example: true
            public var canRename: Bool?
            /// Specifies if the user can change the access level of an
            /// existing shared link on this item.
            ///
            /// Example: true
            public var canSetShareAccess: Bool?
            /// Specifies if the user can create a shared link for this item.
            ///
            /// Example: true
            public var canShare: Bool?
            /// Specifies if the user can upload into this folder.
            ///
            /// Example: true
            public var canUpload: Bool?

            public init(canDelete: Bool? = nil, canDownload: Bool? = nil, canInviteCollaborator: Bool? = nil, canRename: Bool? = nil, canSetShareAccess: Bool? = nil, canShare: Bool? = nil, canUpload: Bool? = nil) {
                self.canDelete = canDelete
                self.canDownload = canDownload
                self.canInviteCollaborator = canInviteCollaborator
                self.canRename = canRename
                self.canSetShareAccess = canSetShareAccess
                self.canShare = canShare
                self.canUpload = canUpload
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.canDelete = try values.decodeIfPresent(Bool.self, forKey: "can_delete")
                self.canDownload = try values.decodeIfPresent(Bool.self, forKey: "can_download")
                self.canInviteCollaborator = try values.decodeIfPresent(Bool.self, forKey: "can_invite_collaborator")
                self.canRename = try values.decodeIfPresent(Bool.self, forKey: "can_rename")
                self.canSetShareAccess = try values.decodeIfPresent(Bool.self, forKey: "can_set_share_access")
                self.canShare = try values.decodeIfPresent(Bool.self, forKey: "can_share")
                self.canUpload = try values.decodeIfPresent(Bool.self, forKey: "can_upload")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(canDelete, forKey: "can_delete")
                try values.encodeIfPresent(canDownload, forKey: "can_download")
                try values.encodeIfPresent(canInviteCollaborator, forKey: "can_invite_collaborator")
                try values.encodeIfPresent(canRename, forKey: "can_rename")
                try values.encodeIfPresent(canSetShareAccess, forKey: "can_set_share_access")
                try values.encodeIfPresent(canShare, forKey: "can_share")
                try values.encodeIfPresent(canUpload, forKey: "can_upload")
            }
        }

        public init(object: Object, anyJSON: AnyJSON, anyJSON2: AnyJSON) {
            self.object = object
            self.anyJSON = anyJSON
            self.anyJSON2 = anyJSON2
        }

        public init(from decoder: Decoder) throws {
            self.object = try Object(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
            self.anyJSON2 = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(object, forKey: "object")
            try values.encode(anyJSON, forKey: "anyJSON")
            try values.encode(anyJSON2, forKey: "anyJSON2")
        }
    }

    /// Specifies whether a folder should be synced to a
    /// user's device or not. This is used by Box Sync
    /// (discontinued) and is not used by Box Drive.
    ///
    /// Example: "synced"
    public enum Object: String, Codable, CaseIterable {
        case synced
        case notSynced = "not_synced"
        case partiallySynced = "partially_synced"
    }

    public struct Tags: Codable {
        /// The tags for this item. These tags are shown in
        /// the Box web app and mobile apps next to an item.
        /// 
        /// To add or remove a tag, retrieve the item's current tags,
        /// modify them, and then update this field.
        /// 
        /// There is a limit of 100 tags per item, and 10,000
        /// unique tags per enterprise.
        ///
        /// Example: ["approved"]
        public var strings: [String]
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct WatermarkInfo: Codable {
        /// Specifies if this item has a watermark applied.
        ///
        /// Example: true
        public var isWatermarked: Bool?
        /// Details about the watermark applied to this folder
        public var anyJSON: AnyJSON
        public var anyJSON2: AnyJSON

        public init(isWatermarked: Bool? = nil, anyJSON: AnyJSON, anyJSON2: AnyJSON) {
            self.isWatermarked = isWatermarked
            self.anyJSON = anyJSON
            self.anyJSON2 = anyJSON2
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isWatermarked = try values.decodeIfPresent(Bool.self, forKey: "is_watermarked")
            self.anyJSON = try AnyJSON(from: decoder)
            self.anyJSON2 = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(isWatermarked, forKey: "is_watermarked")
            try values.encode(anyJSON, forKey: "anyJSON")
            try values.encode(anyJSON2, forKey: "anyJSON2")
        }
    }

    public init(folder: Folder, allowedInviteeRoles: [AllowedInviteeRole]? = nil, allowedSharedLinkAccessLevels: [AllowedSharedLinkAccessLevel]? = nil, canNonOwnersInvite: CanNonOwnersInvite? = nil, canNonOwnersViewCollaborators: Bool? = nil, classification: Classification? = nil, hasCollaborations: Bool? = nil, isCollaborationRestrictedToEnterprise: IsCollaborationRestrictedToEnterprise? = nil, isExternallyOwned: Bool? = nil, metadata: AnyJSON? = nil, permissions: Permissions? = nil, syncState: Object? = nil, tags: Tags? = nil, watermarkInfo: WatermarkInfo? = nil) {
        self.folder = folder
        self.allowedInviteeRoles = allowedInviteeRoles
        self.allowedSharedLinkAccessLevels = allowedSharedLinkAccessLevels
        self.canNonOwnersInvite = canNonOwnersInvite
        self.canNonOwnersViewCollaborators = canNonOwnersViewCollaborators
        self.classification = classification
        self.hasCollaborations = hasCollaborations
        self.isCollaborationRestrictedToEnterprise = isCollaborationRestrictedToEnterprise
        self.isExternallyOwned = isExternallyOwned
        self.metadata = metadata
        self.permissions = permissions
        self.syncState = syncState
        self.tags = tags
        self.watermarkInfo = watermarkInfo
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.folder = try Folder(from: decoder)
        self.allowedInviteeRoles = try values.decodeIfPresent([AllowedInviteeRole].self, forKey: "allowed_invitee_roles")
        self.allowedSharedLinkAccessLevels = try values.decodeIfPresent([AllowedSharedLinkAccessLevel].self, forKey: "allowed_shared_link_access_levels")
        self.canNonOwnersInvite = try CanNonOwnersInvite(from: decoder)
        self.canNonOwnersViewCollaborators = try values.decodeIfPresent(Bool.self, forKey: "can_non_owners_view_collaborators")
        self.classification = try Classification(from: decoder)
        self.hasCollaborations = try values.decodeIfPresent(Bool.self, forKey: "has_collaborations")
        self.isCollaborationRestrictedToEnterprise = try IsCollaborationRestrictedToEnterprise(from: decoder)
        self.isExternallyOwned = try values.decodeIfPresent(Bool.self, forKey: "is_externally_owned")
        self.metadata = try AnyJSON(from: decoder)
        self.permissions = try Permissions(from: decoder)
        self.syncState = try Object(from: decoder)
        self.tags = try Tags(from: decoder)
        self.watermarkInfo = try WatermarkInfo(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(folder, forKey: "folder")
        try values.encodeIfPresent(allowedInviteeRoles, forKey: "allowed_invitee_roles")
        try values.encodeIfPresent(allowedSharedLinkAccessLevels, forKey: "allowed_shared_link_access_levels")
        try values.encodeIfPresent(canNonOwnersInvite, forKey: "can_non_owners_invite")
        try values.encodeIfPresent(canNonOwnersViewCollaborators, forKey: "can_non_owners_view_collaborators")
        try values.encodeIfPresent(classification, forKey: "classification")
        try values.encodeIfPresent(hasCollaborations, forKey: "has_collaborations")
        try values.encodeIfPresent(isCollaborationRestrictedToEnterprise, forKey: "is_collaboration_restricted_to_enterprise")
        try values.encodeIfPresent(isExternallyOwned, forKey: "is_externally_owned")
        try values.encodeIfPresent(metadata, forKey: "metadata")
        try values.encodeIfPresent(permissions, forKey: "permissions")
        try values.encodeIfPresent(syncState, forKey: "sync_state")
        try values.encodeIfPresent(tags, forKey: "tags")
        try values.encodeIfPresent(watermarkInfo, forKey: "watermark_info")
    }
}

/// Folder (Mini)
///
/// A mini representation of a file version, used when
/// nested under another resource.
public struct FolderMini: Codable {
    /// Folder (Base)
    ///
    /// The bare basic representation of a folder, the minimal
    /// amount of fields returned when using the `fields` query
    /// parameter.
    public var folderBase: FolderBase
    /// The name of the folder.
    ///
    /// Example: "Contracts"
    public var name: String?
    public var sequenceID: SequenceID?

    public struct SequenceID: Codable {
        /// A numeric identifier that represents the most recent user event
        /// that has been applied to this item.
        /// 
        /// This can be used in combination with the `GET /events`-endpoint
        /// to filter out user events that would have occurred before this
        /// identifier was read.
        /// 
        /// An example would be where a Box Drive-like application
        /// would fetch an item via the API, and then listen to incoming
        /// user events for changes to the item. The application would
        /// ignore any user events where the `sequence_id` in the event
        /// is smaller than or equal to the `sequence_id` in the originally
        /// fetched resource.
        ///
        /// Example: "3"
        public var string: String
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(folderBase: FolderBase, name: String? = nil, sequenceID: SequenceID? = nil) {
        self.folderBase = folderBase
        self.name = name
        self.sequenceID = sequenceID
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.folderBase = try FolderBase(from: decoder)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.sequenceID = try SequenceID(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(folderBase, forKey: "folderBase")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(sequenceID, forKey: "sequence_id")
    }
}

/// Folder locks define access restrictions placed by folder owners
/// to prevent specific folders from being moved or deleted.
public struct FolderLock: Codable {
    /// When the folder lock object was created.
    ///
    /// Example: "2020-09-14T23:12:53Z"
    public var createdAt: Date?
    public var createdBy: CreatedBy?
    public var folder: Folder?
    /// The unique identifier for this folder lock.
    ///
    /// Example: "12345678"
    public var id: String?
    /// The lock type, always `freeze`.
    ///
    /// Example: "freeze"
    public var lockType: String?
    /// The operations that have been locked. Currently the `move`
    /// and `delete` operations cannot be locked separately, and both need to be
    /// set to `true`.
    public var lockedOperations: LockedOperations?
    /// The object type, always `folder_lock`.
    ///
    /// Example: "folder_lock"
    public var type: String?

    public struct CreatedBy: Codable {
        /// User (Base)
        ///
        /// A mini representation of a user, used when
        /// nested within another resource.
        public var userBase: UserBase
        /// The user or group that created the lock.
        public var anyJSON: AnyJSON

        public init(userBase: UserBase, anyJSON: AnyJSON) {
            self.userBase = userBase
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userBase = try UserBase(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userBase, forKey: "userBase")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Folder: Codable {
        /// Folder (Mini)
        ///
        /// A mini representation of a file version, used when
        /// nested under another resource.
        public var folderMini: FolderMini
        /// The folder that the lock applies to.
        public var anyJSON: AnyJSON

        public init(folderMini: FolderMini, anyJSON: AnyJSON) {
            self.folderMini = folderMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.folderMini = try FolderMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(folderMini, forKey: "folderMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// The operations that have been locked. Currently the `move`
    /// and `delete` operations cannot be locked separately, and both need to be
    /// set to `true`.
    public struct LockedOperations: Codable {
        /// Whether deleting the folder is restricted.
        ///
        /// Example: true
        public var delete: Bool?
        /// Whether moving the folder is restricted.
        ///
        /// Example: true
        public var isMove: Bool?

        public init(delete: Bool? = nil, isMove: Bool? = nil) {
            self.delete = delete
            self.isMove = isMove
        }

        private enum CodingKeys: String, CodingKey {
            case delete
            case isMove = "move"
        }
    }

    public init(createdAt: Date? = nil, createdBy: CreatedBy? = nil, folder: Folder? = nil, id: String? = nil, lockType: String? = nil, lockedOperations: LockedOperations? = nil, type: String? = nil) {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.folder = folder
        self.id = id
        self.lockType = lockType
        self.lockedOperations = lockedOperations
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case createdBy = "created_by"
        case folder
        case id
        case lockType = "lock_type"
        case lockedOperations = "locked_operations"
        case type
    }
}

/// A list of folder locks
public struct FolderLocks: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The marker for the start of the next page of results.
    ///
    /// Example: 3000
    public var nextMarker: Int?
    /// The marker for the start of the previous page of results.
    ///
    /// Example: 1000
    public var prevMarker: Int?
    public var entries: [FolderLock]?

    public init(limit: Int? = nil, nextMarker: Int? = nil, prevMarker: Int? = nil, entries: [FolderLock]? = nil) {
        self.limit = limit
        self.nextMarker = nextMarker
        self.prevMarker = prevMarker
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.nextMarker = try values.decodeIfPresent(Int.self, forKey: "next_marker")
        self.prevMarker = try values.decodeIfPresent(Int.self, forKey: "prev_marker")
        self.entries = try values.decodeIfPresent([FolderLock].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(nextMarker, forKey: "next_marker")
        try values.encodeIfPresent(prevMarker, forKey: "prev_marker")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// A standard representation of a group, as returned from any
/// group API endpoints by default
public struct Group: Codable {
    /// Group (Mini)
    ///
    /// Mini representation of a group, including id and name of
    /// group.
    public var groupMini: GroupMini
    /// When the group object was created
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var createdAt: Date?
    /// When the group object was last modified
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var modifiedAt: Date?

    public init(groupMini: GroupMini, createdAt: Date? = nil, modifiedAt: Date? = nil) {
        self.groupMini = groupMini
        self.createdAt = createdAt
        self.modifiedAt = modifiedAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.groupMini = try GroupMini(from: decoder)
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
        self.modifiedAt = try values.decodeIfPresent(Date.self, forKey: "modified_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(groupMini, forKey: "groupMini")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(modifiedAt, forKey: "modified_at")
    }
}

/// Group (Base)
///
/// A base representation of a group.
public struct GroupBase: Codable {
    /// The unique identifier for this object
    ///
    /// Example: "11446498"
    public var id: String?
    /// `group`
    ///
    /// Example: "group"
    public var type: `Type`?

    /// `group`
    ///
    /// Example: "group"
    public enum `Type`: String, Codable, CaseIterable {
        case group
    }

    public init(id: String? = nil, type: `Type`? = nil) {
        self.id = id
        self.type = type
    }
}

/// Group (Full)
///
/// Groups contain a set of users, and can be used in place of
/// users in some operations, such as collaborations.
public struct GroupFull: Codable {
    /// A standard representation of a group, as returned from any
    /// group API endpoints by default
    public var group: Group
    /// Human readable description of the group.
    ///
    /// Example: "Support Group - as imported from Active Directory"
    public var description: String?
    /// An arbitrary identifier that can be used by
    /// external group sync tools to link this Box Group to
    /// an external group. Example values of this field
    /// could be an Active Directory Object ID or a Google
    /// Group ID.  We recommend you use of this field in
    /// order to avoid issues when group names are updated in
    /// either Box or external systems.
    ///
    /// Example: "AD:123456"
    public var externalSyncIdentifier: String?
    /// Specifies who can invite the group to collaborate
    /// on items.
    /// 
    /// When set to `admins_only` the enterprise admin, co-admins,
    /// and the group's admin can invite the group.
    /// 
    /// When set to `admins_and_members` all the admins listed
    /// above and group members can invite the group.
    /// 
    /// When set to `all_managed_users` all managed users in the
    /// enterprise can invite the group.
    ///
    /// Example: "admins_only"
    public var invitabilityLevel: InvitabilityLevel?
    /// Specifies who can view the members of the group
    /// (Get Memberships for Group).
    /// 
    /// * `admins_only` - the enterprise admin, co-admins, group's
    ///   group admin
    /// * `admins_and_members` - all admins and group members
    /// * `all_managed_users` - all managed users in the
    ///   enterprise
    ///
    /// Example: "admins_only"
    public var memberViewabilityLevel: MemberViewabilityLevel?
    public var permissions: Permissions?
    /// Keeps track of which external source this group is
    /// coming from (e.g. "Active Directory", "Google Groups",
    /// "Facebook Groups").  Setting this will
    /// also prevent Box users from editing the group name
    /// and its members directly via the Box web application.
    /// This is desirable for one-way syncing of groups.
    ///
    /// Example: "Active Directory"
    public var provenance: String?

    /// Specifies who can invite the group to collaborate
    /// on items.
    /// 
    /// When set to `admins_only` the enterprise admin, co-admins,
    /// and the group's admin can invite the group.
    /// 
    /// When set to `admins_and_members` all the admins listed
    /// above and group members can invite the group.
    /// 
    /// When set to `all_managed_users` all managed users in the
    /// enterprise can invite the group.
    ///
    /// Example: "admins_only"
    public enum InvitabilityLevel: String, Codable, CaseIterable {
        case adminsOnly = "admins_only"
        case adminsAndMembers = "admins_and_members"
        case allManagedUsers = "all_managed_users"
    }

    /// Specifies who can view the members of the group
    /// (Get Memberships for Group).
    /// 
    /// * `admins_only` - the enterprise admin, co-admins, group's
    ///   group admin
    /// * `admins_and_members` - all admins and group members
    /// * `all_managed_users` - all managed users in the
    ///   enterprise
    ///
    /// Example: "admins_only"
    public enum MemberViewabilityLevel: String, Codable, CaseIterable {
        case adminsOnly = "admins_only"
        case adminsAndMembers = "admins_and_members"
        case allManagedUsers = "all_managed_users"
    }

    public struct Permissions: Codable {
        /// Specifies if the user can invite the group to collaborate on any items.
        ///
        /// Example: true
        public var canInviteAsCollaborator: Bool?
        /// Describes the permissions that the current user has
        /// for this group.
        public var anyJSON: AnyJSON

        public init(canInviteAsCollaborator: Bool? = nil, anyJSON: AnyJSON) {
            self.canInviteAsCollaborator = canInviteAsCollaborator
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.canInviteAsCollaborator = try values.decodeIfPresent(Bool.self, forKey: "can_invite_as_collaborator")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(canInviteAsCollaborator, forKey: "can_invite_as_collaborator")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(group: Group, description: String? = nil, externalSyncIdentifier: String? = nil, invitabilityLevel: InvitabilityLevel? = nil, memberViewabilityLevel: MemberViewabilityLevel? = nil, permissions: Permissions? = nil, provenance: String? = nil) {
        self.group = group
        self.description = description
        self.externalSyncIdentifier = externalSyncIdentifier
        self.invitabilityLevel = invitabilityLevel
        self.memberViewabilityLevel = memberViewabilityLevel
        self.permissions = permissions
        self.provenance = provenance
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.group = try Group(from: decoder)
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.externalSyncIdentifier = try values.decodeIfPresent(String.self, forKey: "external_sync_identifier")
        self.invitabilityLevel = try InvitabilityLevel(from: decoder)
        self.memberViewabilityLevel = try MemberViewabilityLevel(from: decoder)
        self.permissions = try Permissions(from: decoder)
        self.provenance = try values.decodeIfPresent(String.self, forKey: "provenance")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(group, forKey: "group")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(externalSyncIdentifier, forKey: "external_sync_identifier")
        try values.encodeIfPresent(invitabilityLevel, forKey: "invitability_level")
        try values.encodeIfPresent(memberViewabilityLevel, forKey: "member_viewability_level")
        try values.encodeIfPresent(permissions, forKey: "permissions")
        try values.encodeIfPresent(provenance, forKey: "provenance")
    }
}

/// Group (Mini)
///
/// Mini representation of a group, including id and name of
/// group.
public struct GroupMini: Codable {
    /// Group (Base)
    ///
    /// A base representation of a group.
    public var groupBase: GroupBase
    /// The type of the group.
    ///
    /// Example: "managed_group"
    public var groupType: GroupType?
    /// The name of the group
    ///
    /// Example: "Support"
    public var name: String?

    /// The type of the group.
    ///
    /// Example: "managed_group"
    public enum GroupType: String, Codable, CaseIterable {
        case managedGroup = "managed_group"
        case allUsersGroup = "all_users_group"
    }

    public init(groupBase: GroupBase, groupType: GroupType? = nil, name: String? = nil) {
        self.groupBase = groupBase
        self.groupType = groupType
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.groupBase = try GroupBase(from: decoder)
        self.groupType = try GroupType(from: decoder)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(groupBase, forKey: "groupBase")
        try values.encodeIfPresent(groupType, forKey: "group_type")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

/// Membership is used to signify that a user is part of a
/// group.
public struct GroupMembership: Codable {
    /// The time this membership was created.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var createdAt: Date?
    public var group: Group?
    /// The unique identifier for this group membership
    ///
    /// Example: "11446498"
    public var id: String?
    /// The time this membership was last modified.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var modifiedAt: Date?
    /// The role of the user in the group.
    ///
    /// Example: "member"
    public var role: Role?
    /// `group_membership`
    ///
    /// Example: "group_membership"
    public var type: `Type`?
    public var user: User?

    public struct Group: Codable {
        /// Group (Mini)
        ///
        /// Mini representation of a group, including id and name of
        /// group.
        public var groupMini: GroupMini
        /// The group that the membership applies to
        public var anyJSON: AnyJSON

        public init(groupMini: GroupMini, anyJSON: AnyJSON) {
            self.groupMini = groupMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.groupMini = try GroupMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(groupMini, forKey: "groupMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// The role of the user in the group.
    ///
    /// Example: "member"
    public enum Role: String, Codable, CaseIterable {
        case member
        case admin
    }

    /// `group_membership`
    ///
    /// Example: "group_membership"
    public enum `Type`: String, Codable, CaseIterable {
        case groupMembership = "group_membership"
    }

    public struct User: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user that the membership applies to
        public var anyJSON: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(createdAt: Date? = nil, group: Group? = nil, id: String? = nil, modifiedAt: Date? = nil, role: Role? = nil, type: `Type`? = nil, user: User? = nil) {
        self.createdAt = createdAt
        self.group = group
        self.id = id
        self.modifiedAt = modifiedAt
        self.role = role
        self.type = type
        self.user = user
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case group
        case id
        case modifiedAt = "modified_at"
        case role
        case type
        case user
    }
}

/// A list of group memberships.
public struct GroupMemberships: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The 0-based offset of the first entry in this set. This will be the same
    /// as the `offset` query parameter.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    ///
    /// Example: 2000
    public var offset: Int?
    /// The order by which items are returned.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    public var order: [OrderItem]?
    /// One greater than the offset of the last entry in the entire collection.
    /// The total number of entries in the collection may be less than
    /// `total_count`.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    ///
    /// Example: 5000
    public var totalCount: Int?
    public var entries: [GroupMembership]?

    /// The order in which a pagination is ordered
    public struct OrderItem: Codable {
        /// The field to order by
        ///
        /// Example: "type"
        public var by: String?
        /// The direction to order by, either ascending or descending
        ///
        /// Example: "ASC"
        public var direction: Direction?

        /// The direction to order by, either ascending or descending
        ///
        /// Example: "ASC"
        public enum Direction: String, Codable, CaseIterable {
            case asc = "ASC"
            case desc = "DESC"
        }

        public init(by: String? = nil, direction: Direction? = nil) {
            self.by = by
            self.direction = direction
        }
    }

    public init(limit: Int? = nil, offset: Int? = nil, order: [OrderItem]? = nil, totalCount: Int? = nil, entries: [GroupMembership]? = nil) {
        self.limit = limit
        self.offset = offset
        self.order = order
        self.totalCount = totalCount
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.offset = try values.decodeIfPresent(Int.self, forKey: "offset")
        self.order = try values.decodeIfPresent([OrderItem].self, forKey: "order")
        self.totalCount = try values.decodeIfPresent(Int.self, forKey: "total_count")
        self.entries = try values.decodeIfPresent([GroupMembership].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(offset, forKey: "offset")
        try values.encodeIfPresent(order, forKey: "order")
        try values.encodeIfPresent(totalCount, forKey: "total_count")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// A list of groups.
public struct Groups: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The 0-based offset of the first entry in this set. This will be the same
    /// as the `offset` query parameter.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    ///
    /// Example: 2000
    public var offset: Int?
    /// The order by which items are returned.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    public var order: [OrderItem]?
    /// One greater than the offset of the last entry in the entire collection.
    /// The total number of entries in the collection may be less than
    /// `total_count`.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    ///
    /// Example: 5000
    public var totalCount: Int?
    public var entries: [GroupMini]?

    /// The order in which a pagination is ordered
    public struct OrderItem: Codable {
        /// The field to order by
        ///
        /// Example: "type"
        public var by: String?
        /// The direction to order by, either ascending or descending
        ///
        /// Example: "ASC"
        public var direction: Direction?

        /// The direction to order by, either ascending or descending
        ///
        /// Example: "ASC"
        public enum Direction: String, Codable, CaseIterable {
            case asc = "ASC"
            case desc = "DESC"
        }

        public init(by: String? = nil, direction: Direction? = nil) {
            self.by = by
            self.direction = direction
        }
    }

    public init(limit: Int? = nil, offset: Int? = nil, order: [OrderItem]? = nil, totalCount: Int? = nil, entries: [GroupMini]? = nil) {
        self.limit = limit
        self.offset = offset
        self.order = order
        self.totalCount = totalCount
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.offset = try values.decodeIfPresent(Int.self, forKey: "offset")
        self.order = try values.decodeIfPresent([OrderItem].self, forKey: "order")
        self.totalCount = try values.decodeIfPresent(Int.self, forKey: "total_count")
        self.entries = try values.decodeIfPresent([GroupMini].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(offset, forKey: "offset")
        try values.encodeIfPresent(order, forKey: "order")
        try values.encodeIfPresent(totalCount, forKey: "total_count")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// An invite for a user to an enterprise.
public struct Invite: Codable {
    /// User (Mini)
    ///
    /// A mini representation of a user, as can be returned when nested within other
    /// resources.
    public var actionableBy: UserMini?
    /// When the invite was created
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var createdAt: Date?
    /// The unique identifier for this invite
    ///
    /// Example: "11446498"
    public var id: String?
    /// User (Mini)
    ///
    /// A mini representation of a user, as can be returned when nested within other
    /// resources.
    public var invitedBy: UserMini?
    /// Enterprise
    ///
    /// A representation of a Box enterprise
    public var invitedTo: InvitedTo?
    /// When the invite was modified.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var modifiedAt: Date?
    /// The status of the invite
    ///
    /// Example: "pending"
    public var status: String?
    /// `invite`
    ///
    /// Example: "invite"
    public var type: `Type`?

    /// Enterprise
    ///
    /// A representation of a Box enterprise
    public struct InvitedTo: Codable {
        /// The unique identifier for this enterprise.
        ///
        /// Example: "11446498"
        public var id: String?
        /// The name of the enterprise
        ///
        /// Example: "Acme Inc."
        public var name: String?
        /// `enterprise`
        ///
        /// Example: "enterprise"
        public var type: `Type`?

        /// `enterprise`
        ///
        /// Example: "enterprise"
        public enum `Type`: String, Codable, CaseIterable {
            case enterprise
        }

        public init(id: String? = nil, name: String? = nil, type: `Type`? = nil) {
            self.id = id
            self.name = name
            self.type = type
        }
    }

    /// `invite`
    ///
    /// Example: "invite"
    public enum `Type`: String, Codable, CaseIterable {
        case invite
    }

    public init(actionableBy: UserMini? = nil, createdAt: Date? = nil, id: String? = nil, invitedBy: UserMini? = nil, invitedTo: InvitedTo? = nil, modifiedAt: Date? = nil, status: String? = nil, type: `Type`? = nil) {
        self.actionableBy = actionableBy
        self.createdAt = createdAt
        self.id = id
        self.invitedBy = invitedBy
        self.invitedTo = invitedTo
        self.modifiedAt = modifiedAt
        self.status = status
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case actionableBy = "actionable_by"
        case createdAt = "created_at"
        case id
        case invitedBy = "invited_by"
        case invitedTo = "invited_to"
        case modifiedAt = "modified_at"
        case status
        case type
    }
}

/// A list of files, folders, and web links in
/// their mini representation.
public struct Items: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The 0-based offset of the first entry in this set. This will be the same
    /// as the `offset` query parameter.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    ///
    /// Example: 2000
    public var offset: Int?
    /// The order by which items are returned.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    public var order: [OrderItem]?
    /// One greater than the offset of the last entry in the entire collection.
    /// The total number of entries in the collection may be less than
    /// `total_count`.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    ///
    /// Example: 5000
    public var totalCount: Int?
    /// The items in this collection.
    public var entries: [Entry]?

    /// The order in which a pagination is ordered
    public struct OrderItem: Codable {
        /// The field to order by
        ///
        /// Example: "type"
        public var by: String?
        /// The direction to order by, either ascending or descending
        ///
        /// Example: "ASC"
        public var direction: Direction?

        /// The direction to order by, either ascending or descending
        ///
        /// Example: "ASC"
        public enum Direction: String, Codable, CaseIterable {
            case asc = "ASC"
            case desc = "DESC"
        }

        public init(by: String? = nil, direction: Direction? = nil) {
            self.by = by
            self.direction = direction
        }
    }

    public enum Entry: Codable {
        case fileMini(FileMini)
        case folderMini(FolderMini)
        case webLinkMini(WebLinkMini)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(FileMini.self) {
                self = .fileMini(value)
            } else if let value = try? container.decode(FolderMini.self) {
                self = .folderMini(value)
            } else if let value = try? container.decode(WebLinkMini.self) {
                self = .webLinkMini(value)
            } else {
                throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
            case .fileMini(let value): try container.encode(value)
            case .folderMini(let value): try container.encode(value)
            case .webLinkMini(let value): try container.encode(value)
            }
        }
    }

    public init(limit: Int? = nil, offset: Int? = nil, order: [OrderItem]? = nil, totalCount: Int? = nil, entries: [Entry]? = nil) {
        self.limit = limit
        self.offset = offset
        self.order = order
        self.totalCount = totalCount
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.offset = try values.decodeIfPresent(Int.self, forKey: "offset")
        self.order = try values.decodeIfPresent([OrderItem].self, forKey: "order")
        self.totalCount = try values.decodeIfPresent(Int.self, forKey: "total_count")
        self.entries = try values.decodeIfPresent([Entry].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(offset, forKey: "offset")
        try values.encodeIfPresent(order, forKey: "order")
        try values.encodeIfPresent(totalCount, forKey: "total_count")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// A skill card that contains a set of keywords
public struct KeywordSkillCard: Codable {
    /// The optional date and time this card was created at.
    ///
    /// Example: "2018-04-13T13:53:23-07:00"
    public var createdAt: Date?
    /// An list of entries in the metadata card.
    public var entries: [Entry]
    /// The invocation of this service, used to track
    /// which instance of a service applied the metadata.
    public var invocation: Invocation
    /// The service that applied this metadata.
    public var skill: Skill
    /// The title of the card.
    public var skillCardTitle: SkillCardTitle?
    /// `keyword`
    ///
    /// Example: "keyword"
    public var skillCardType: SkillCardType
    /// `skill_card`
    ///
    /// Example: "skill_card"
    public var type: `Type`

    /// An entry in the `entries` attribute of a metadata card
    public struct Entry: Codable {
        /// The text of the keyword.
        ///
        /// Example: "keyword1"
        public var text: String?

        public init(text: String? = nil) {
            self.text = text
        }
    }

    /// The invocation of this service, used to track
    /// which instance of a service applied the metadata.
    public struct Invocation: Codable {
        /// A custom identifier that represent the instance of
        /// the service that applied this metadata. For example,
        /// if your `image-recognition-service` runs on multiple
        /// nodes, this field can be used to identify the ID of
        /// the node that was used to apply the metadata.
        ///
        /// Example: "image-recognition-service-123"
        public var id: String
        /// `skill_invocation`
        ///
        /// Example: "skill_invocation"
        public var type: `Type`

        /// `skill_invocation`
        ///
        /// Example: "skill_invocation"
        public enum `Type`: String, Codable, CaseIterable {
            case skillInvocation = "skill_invocation"
        }

        public init(id: String, type: `Type`) {
            self.id = id
            self.type = type
        }
    }

    /// The service that applied this metadata.
    public struct Skill: Codable {
        /// A custom identifier that represent the service that
        /// applied this metadata.
        ///
        /// Example: "image-recognition-service"
        public var id: String
        /// `service`
        ///
        /// Example: "service"
        public var type: `Type`

        /// `service`
        ///
        /// Example: "service"
        public enum `Type`: String, Codable, CaseIterable {
            case service
        }

        public init(id: String, type: `Type`) {
            self.id = id
            self.type = type
        }
    }

    /// The title of the card.
    public struct SkillCardTitle: Codable {
        /// An optional identifier for the title.
        ///
        /// Example: "labels"
        public var code: String?
        /// The actual title to show in the UI.
        ///
        /// Example: "Labels"
        public var message: String

        public init(code: String? = nil, message: String) {
            self.code = code
            self.message = message
        }
    }

    /// `keyword`
    ///
    /// Example: "keyword"
    public enum SkillCardType: String, Codable, CaseIterable {
        case keyword
    }

    /// `skill_card`
    ///
    /// Example: "skill_card"
    public enum `Type`: String, Codable, CaseIterable {
        case skillCard = "skill_card"
    }

    public init(createdAt: Date? = nil, entries: [Entry], invocation: Invocation, skill: Skill, skillCardTitle: SkillCardTitle? = nil, skillCardType: SkillCardType, type: `Type`) {
        self.createdAt = createdAt
        self.entries = entries
        self.invocation = invocation
        self.skill = skill
        self.skillCardTitle = skillCardTitle
        self.skillCardType = skillCardType
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case entries
        case invocation
        case skill
        case skillCardTitle = "skill_card_title"
        case skillCardType = "skill_card_type"
        case type
    }
}

/// A list of legal hold policies.
public struct LegalHoldPolicies: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The marker for the start of the next page of results.
    ///
    /// Example: 3000
    public var nextMarker: Int?
    /// The marker for the start of the previous page of results.
    ///
    /// Example: 1000
    public var prevMarker: Int?
    public var entries: [LegalHoldPolicy]?

    public init(limit: Int? = nil, nextMarker: Int? = nil, prevMarker: Int? = nil, entries: [LegalHoldPolicy]? = nil) {
        self.limit = limit
        self.nextMarker = nextMarker
        self.prevMarker = prevMarker
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.nextMarker = try values.decodeIfPresent(Int.self, forKey: "next_marker")
        self.prevMarker = try values.decodeIfPresent(Int.self, forKey: "prev_marker")
        self.entries = try values.decodeIfPresent([LegalHoldPolicy].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(nextMarker, forKey: "next_marker")
        try values.encodeIfPresent(prevMarker, forKey: "prev_marker")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// Legal Hold Policy information describes the basic
/// characteristics of the Policy, such as name, description,
/// and filter dates.
public struct LegalHoldPolicy: Codable {
    /// Legal hold policy (Mini)
    ///
    /// A mini legal hold policy
    public var legalHoldPolicyMini: LegalHoldPolicyMini
    /// Counts of assignments within this a legal hold policy by item type
    public var assignmentCounts: AssignmentCounts?
    /// When the legal hold policy object was created
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var createdAt: Date?
    public var createdBy: CreatedBy?
    /// When the policy release request was sent. (Because
    /// it can take time for a policy to fully delete, this
    /// isn't quite the same time that the policy is fully deleted).
    /// 
    /// If `null`, the policy was not deleted.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var deletedAt: Date?
    /// Description of the legal hold policy. Optional
    /// property with a 500 character limit.
    ///
    /// Example: "Postman created policy"
    public var description: String?
    /// User-specified, optional date filter applies to
    /// Custodian assignments only
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var filterEndedAt: Date?
    /// User-specified, optional date filter applies to
    /// Custodian assignments only
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var filterStartedAt: Date?
    /// When the legal hold policy object was modified.
    /// Does not update when assignments are added or removed.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var modifiedAt: Date?
    /// Name of the legal hold policy.
    ///
    /// Example: "Policy 4"
    public var policyName: String?
    /// Optional notes about why the policy was created.
    ///
    /// Example: "Example"
    public var releaseNotes: String?
    /// * 'active' - the policy is not in a transition state
    /// * 'applying' - that the policy is in the process of
    ///   being applied
    /// * 'releasing' - that the process is in the process
    ///   of being released
    /// * 'released' - the policy is no longer active
    ///
    /// Example: "active"
    public var status: Status?

    /// Counts of assignments within this a legal hold policy by item type
    public struct AssignmentCounts: Codable {
        /// The number of files this policy is applied to
        public var file: Int?
        /// The number of file versions this policy is applied to
        public var fileVersion: Int?
        /// The number of folders this policy is applied to
        public var folder: Int?
        /// The number of users this policy is applied to
        public var user: Int?

        public init(file: Int? = nil, fileVersion: Int? = nil, folder: Int? = nil, user: Int? = nil) {
            self.file = file
            self.fileVersion = fileVersion
            self.folder = folder
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case file
            case fileVersion = "file_version"
            case folder
            case user
        }
    }

    public struct CreatedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user who created the legal hold policy object
        public var anyJSON: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// * 'active' - the policy is not in a transition state
    /// * 'applying' - that the policy is in the process of
    ///   being applied
    /// * 'releasing' - that the process is in the process
    ///   of being released
    /// * 'released' - the policy is no longer active
    ///
    /// Example: "active"
    public enum Status: String, Codable, CaseIterable {
        case active
        case applying
        case releasing
        case released
    }

    public init(legalHoldPolicyMini: LegalHoldPolicyMini, assignmentCounts: AssignmentCounts? = nil, createdAt: Date? = nil, createdBy: CreatedBy? = nil, deletedAt: Date? = nil, description: String? = nil, filterEndedAt: Date? = nil, filterStartedAt: Date? = nil, modifiedAt: Date? = nil, policyName: String? = nil, releaseNotes: String? = nil, status: Status? = nil) {
        self.legalHoldPolicyMini = legalHoldPolicyMini
        self.assignmentCounts = assignmentCounts
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.deletedAt = deletedAt
        self.description = description
        self.filterEndedAt = filterEndedAt
        self.filterStartedAt = filterStartedAt
        self.modifiedAt = modifiedAt
        self.policyName = policyName
        self.releaseNotes = releaseNotes
        self.status = status
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.legalHoldPolicyMini = try LegalHoldPolicyMini(from: decoder)
        self.assignmentCounts = try AssignmentCounts(from: decoder)
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
        self.createdBy = try CreatedBy(from: decoder)
        self.deletedAt = try values.decodeIfPresent(Date.self, forKey: "deleted_at")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.filterEndedAt = try values.decodeIfPresent(Date.self, forKey: "filter_ended_at")
        self.filterStartedAt = try values.decodeIfPresent(Date.self, forKey: "filter_started_at")
        self.modifiedAt = try values.decodeIfPresent(Date.self, forKey: "modified_at")
        self.policyName = try values.decodeIfPresent(String.self, forKey: "policy_name")
        self.releaseNotes = try values.decodeIfPresent(String.self, forKey: "release_notes")
        self.status = try Status(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(legalHoldPolicyMini, forKey: "legalHoldPolicyMini")
        try values.encodeIfPresent(assignmentCounts, forKey: "assignment_counts")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(createdBy, forKey: "created_by")
        try values.encodeIfPresent(deletedAt, forKey: "deleted_at")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(filterEndedAt, forKey: "filter_ended_at")
        try values.encodeIfPresent(filterStartedAt, forKey: "filter_started_at")
        try values.encodeIfPresent(modifiedAt, forKey: "modified_at")
        try values.encodeIfPresent(policyName, forKey: "policy_name")
        try values.encodeIfPresent(releaseNotes, forKey: "release_notes")
        try values.encodeIfPresent(status, forKey: "status")
    }
}

/// Legal hold policy (Mini)
///
/// A mini legal hold policy
public struct LegalHoldPolicyMini: Codable {
    /// The unique identifier for this legal hold policy
    ///
    /// Example: "11446498"
    public var id: String?
    /// `legal_hold_policy`
    ///
    /// Example: "legal_hold_policy"
    public var type: `Type`?

    /// `legal_hold_policy`
    ///
    /// Example: "legal_hold_policy"
    public enum `Type`: String, Codable, CaseIterable {
        case legalHoldPolicy = "legal_hold_policy"
    }

    public init(id: String? = nil, type: `Type`? = nil) {
        self.id = id
        self.type = type
    }
}

/// Legal Hold Assignments are used to assign Legal Hold
/// Policies to Users, Folders, Files, or File Versions.
/// 
/// Creating a Legal Hold Assignment puts a hold
/// on the File-Versions that belong to the Assignment's
/// 'apply-to' entity.
public struct LegalHoldPolicyAssignment: Codable {
    /// Legal hold policy assignment (Base)
    ///
    /// Legal Hold Assignments are used to assign Legal Hold
    /// Policies to Users, Folders, Files, or File Versions.
    /// 
    /// Creating a Legal Hold Assignment puts a hold
    /// on the File-Versions that belong to the Assignment's
    /// 'apply-to' entity.
    public var legalHoldPolicyAssignmentBase: LegalHoldPolicyAssignmentBase
    /// When the legal hold policy assignment object was
    /// created
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var assignedAt: Date?
    public var assignedBy: AssignedBy?
    public var assignedTo: AssignedTo?
    /// When the assignment release request was sent.
    /// (Because it can take time for an assignment to fully
    /// delete, this isn't quite the same time that the
    /// assignment is fully deleted). If null, Assignment
    /// was not deleted.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var deletedAt: Date?
    public var legalHoldPolicy: LegalHoldPolicy?

    public struct AssignedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user who created the legal hold policy
        /// assignment
        public var anyJSON: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AssignedTo: Codable {
        public var object: Object
        /// The item that the the legal hold policy
        /// is assigned to. Includes type and ID.
        public var anyJSON: AnyJSON

        public enum Object: Codable {
            case file(File)
            case folder(Folder)
            case webLink(WebLink)

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(File.self) {
                    self = .file(value)
                } else if let value = try? container.decode(Folder.self) {
                    self = .folder(value)
                } else if let value = try? container.decode(WebLink.self) {
                    self = .webLink(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .file(let value): try container.encode(value)
                case .folder(let value): try container.encode(value)
                case .webLink(let value): try container.encode(value)
                }
            }
        }

        public init(object: Object, anyJSON: AnyJSON) {
            self.object = object
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.object = try Object(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(object, forKey: "object")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct LegalHoldPolicy: Codable {
        /// Legal hold policy (Mini)
        ///
        /// A mini legal hold policy
        public var legalHoldPolicyMini: LegalHoldPolicyMini
        /// The policy that the legal hold policy assignment
        /// is part of
        public var anyJSON: AnyJSON

        public init(legalHoldPolicyMini: LegalHoldPolicyMini, anyJSON: AnyJSON) {
            self.legalHoldPolicyMini = legalHoldPolicyMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.legalHoldPolicyMini = try LegalHoldPolicyMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(legalHoldPolicyMini, forKey: "legalHoldPolicyMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(legalHoldPolicyAssignmentBase: LegalHoldPolicyAssignmentBase, assignedAt: Date? = nil, assignedBy: AssignedBy? = nil, assignedTo: AssignedTo? = nil, deletedAt: Date? = nil, legalHoldPolicy: LegalHoldPolicy? = nil) {
        self.legalHoldPolicyAssignmentBase = legalHoldPolicyAssignmentBase
        self.assignedAt = assignedAt
        self.assignedBy = assignedBy
        self.assignedTo = assignedTo
        self.deletedAt = deletedAt
        self.legalHoldPolicy = legalHoldPolicy
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.legalHoldPolicyAssignmentBase = try LegalHoldPolicyAssignmentBase(from: decoder)
        self.assignedAt = try values.decodeIfPresent(Date.self, forKey: "assigned_at")
        self.assignedBy = try AssignedBy(from: decoder)
        self.assignedTo = try AssignedTo(from: decoder)
        self.deletedAt = try values.decodeIfPresent(Date.self, forKey: "deleted_at")
        self.legalHoldPolicy = try LegalHoldPolicy(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(legalHoldPolicyAssignmentBase, forKey: "legalHoldPolicyAssignmentBase")
        try values.encodeIfPresent(assignedAt, forKey: "assigned_at")
        try values.encodeIfPresent(assignedBy, forKey: "assigned_by")
        try values.encodeIfPresent(assignedTo, forKey: "assigned_to")
        try values.encodeIfPresent(deletedAt, forKey: "deleted_at")
        try values.encodeIfPresent(legalHoldPolicy, forKey: "legal_hold_policy")
    }
}

/// Legal hold policy assignment (Base)
///
/// Legal Hold Assignments are used to assign Legal Hold
/// Policies to Users, Folders, Files, or File Versions.
/// 
/// Creating a Legal Hold Assignment puts a hold
/// on the File-Versions that belong to the Assignment's
/// 'apply-to' entity.
public struct LegalHoldPolicyAssignmentBase: Codable {
    /// The unique identifier for this legal hold assignment
    ///
    /// Example: "11446498"
    public var id: String?
    /// `legal_hold_policy_assignment`
    ///
    /// Example: "legal_hold_policy_assignment"
    public var type: `Type`?

    /// `legal_hold_policy_assignment`
    ///
    /// Example: "legal_hold_policy_assignment"
    public enum `Type`: String, Codable, CaseIterable {
        case legalHoldPolicyAssignment = "legal_hold_policy_assignment"
    }

    public init(id: String? = nil, type: `Type`? = nil) {
        self.id = id
        self.type = type
    }
}

/// A list of legal hold policies assignments.
public struct LegalHoldPolicyAssignments: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The marker for the start of the next page of results.
    ///
    /// Example: 3000
    public var nextMarker: Int?
    /// The marker for the start of the previous page of results.
    ///
    /// Example: 1000
    public var prevMarker: Int?
    public var entries: [LegalHoldPolicyAssignmentBase]?

    public init(limit: Int? = nil, nextMarker: Int? = nil, prevMarker: Int? = nil, entries: [LegalHoldPolicyAssignmentBase]? = nil) {
        self.limit = limit
        self.nextMarker = nextMarker
        self.prevMarker = prevMarker
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.nextMarker = try values.decodeIfPresent(Int.self, forKey: "next_marker")
        self.prevMarker = try values.decodeIfPresent(Int.self, forKey: "prev_marker")
        self.entries = try values.decodeIfPresent([LegalHoldPolicyAssignmentBase].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(nextMarker, forKey: "next_marker")
        try values.encodeIfPresent(prevMarker, forKey: "prev_marker")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// Metadata instance (Base)
///
/// The base representation of a metadata instance.
public struct MetadataBase: Codable {
    /// The identifier of the item that this metadata instance
    /// has been attached to. This combines the `type` and the `id`
    /// of the parent in the form `{type}_{id}`.
    ///
    /// Example: "folder_59449484661,"
    public var parent: String?
    /// An ID for the scope in which this template
    /// has been applied. This will be `enterprise_{enterprise_id}` for templates
    /// defined for use in this enterprise, and `global` for general templates
    /// that are available to all enterprises using Box.
    ///
    /// Example: "enterprise_27335"
    public var scope: String?
    /// The name of the template
    ///
    /// Example: "marketingCollateral"
    public var template: String?
    /// The version of the metadata instance. This version starts at 0 and
    /// increases every time a user-defined property is modified.
    public var version: Int?

    public init(parent: String? = nil, scope: String? = nil, template: String? = nil, version: Int? = nil) {
        self.parent = parent
        self.scope = scope
        self.template = template
        self.version = version
    }

    private enum CodingKeys: String, CodingKey {
        case parent = "$parent"
        case scope = "$scope"
        case template = "$template"
        case version = "$version"
    }
}

/// Metadata instance (Full)
///
/// An instance of a metadata template, which has been applied to a file or
/// folder.
public struct MetadataFull: Codable {
    /// Metadata instance
    ///
    /// An instance of a metadata template, which has been applied to a file or
    /// folder.
    public var metadataBase: MetadataBase
    /// Whether the user can edit this metadata instance.
    ///
    /// Example: true
    public var canEdit: Bool?
    /// A UUID to identify the metadata instance.
    ///
    /// Example: "01234500-12f1-1234-aa12-b1d234cb567e"
    public var id: String?
    /// A unique identifier for the "type" of this instance. This is an
    /// internal system property and should not be used by a client
    /// application.
    ///
    /// Example: "properties-6bcba49f-ca6d-4d2a-a758-57fe6edf44d0"
    public var type: String?
    /// The last-known version of the template of the object. This is an
    /// internal system property and should not be used by a client
    /// application.
    public var typeVersion: Int?

    public init(metadataBase: MetadataBase, canEdit: Bool? = nil, id: String? = nil, type: String? = nil, typeVersion: Int? = nil) {
        self.metadataBase = metadataBase
        self.canEdit = canEdit
        self.id = id
        self.type = type
        self.typeVersion = typeVersion
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.metadataBase = try MetadataBase(from: decoder)
        self.canEdit = try values.decodeIfPresent(Bool.self, forKey: "$canEdit")
        self.id = try values.decodeIfPresent(String.self, forKey: "$id")
        self.type = try values.decodeIfPresent(String.self, forKey: "$type")
        self.typeVersion = try values.decodeIfPresent(Int.self, forKey: "$typeVersion")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(metadataBase, forKey: "metadataBase")
        try values.encodeIfPresent(canEdit, forKey: "$canEdit")
        try values.encodeIfPresent(id, forKey: "$id")
        try values.encodeIfPresent(type, forKey: "$type")
        try values.encodeIfPresent(typeVersion, forKey: "$typeVersion")
    }
}

/// A list of metadata cascade policies.
public struct MetadataCascadePolicies: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The marker for the start of the next page of results.
    ///
    /// Example: 3000
    public var nextMarker: Int?
    /// The marker for the start of the previous page of results.
    ///
    /// Example: 1000
    public var prevMarker: Int?
    public var entries: [MetadataCascadePolicy]?

    public init(limit: Int? = nil, nextMarker: Int? = nil, prevMarker: Int? = nil, entries: [MetadataCascadePolicy]? = nil) {
        self.limit = limit
        self.nextMarker = nextMarker
        self.prevMarker = prevMarker
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.nextMarker = try values.decodeIfPresent(Int.self, forKey: "next_marker")
        self.prevMarker = try values.decodeIfPresent(Int.self, forKey: "prev_marker")
        self.entries = try values.decodeIfPresent([MetadataCascadePolicy].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(nextMarker, forKey: "next_marker")
        try values.encodeIfPresent(prevMarker, forKey: "prev_marker")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// A metadata cascade policy automatically applies a metadata template instance
/// to all the files and folders within the targeted folder.
public struct MetadataCascadePolicy: Codable {
    /// The ID of the metadata cascade policy object
    ///
    /// Example: "6fd4ff89-8fc1-42cf-8b29-1890dedd26d7"
    public var id: String?
    /// The enterprise that owns this policy.
    public var ownerEnterprise: OwnerEnterprise?
    /// Represent the folder the policy is applied to.
    public var parent: Parent?
    /// The scope of the of the template that is cascaded down to the folder's
    /// children.
    ///
    /// Example: "global"
    public var scope: Scope?
    /// The key of the template that is cascaded down to the folder's
    /// children.
    /// 
    /// In many cases the template key is automatically derived
    /// of its display name, for example `Contract Template` would
    /// become `contractTemplate`. In some cases the creator of the
    /// template will have provided its own template key.
    /// 
    /// Please [list the templates for an enterprise][list], or
    /// get all instances on a [file][file] or [folder][folder]
    /// to inspect a template's key.
    /// 
    /// [list]: e://get-metadata-templates-enterprise
    /// [file]: e://get-files-id-metadata
    /// [folder]: e://get-folders-id-metadata
    ///
    /// Example: "productInfo"
    public var templateKey: String?
    /// `metadata_cascade_policy`
    ///
    /// Example: "metadata_cascade_policy"
    public var type: `Type`?

    /// The enterprise that owns this policy.
    public struct OwnerEnterprise: Codable {
        /// The ID of the enterprise that owns the policy.
        ///
        /// Example: "690678"
        public var id: String?
        /// `enterprise`
        ///
        /// Example: "enterprise"
        public var type: `Type`?

        /// `enterprise`
        ///
        /// Example: "enterprise"
        public enum `Type`: String, Codable, CaseIterable {
            case enterprise
        }

        public init(id: String? = nil, type: `Type`? = nil) {
            self.id = id
            self.type = type
        }
    }

    /// Represent the folder the policy is applied to.
    public struct Parent: Codable {
        /// The ID of the folder the policy is applied to.
        ///
        /// Example: "1234567"
        public var id: String?
        /// `folder`
        ///
        /// Example: "folder"
        public var type: `Type`?

        /// `folder`
        ///
        /// Example: "folder"
        public enum `Type`: String, Codable, CaseIterable {
            case folder
        }

        public init(id: String? = nil, type: `Type`? = nil) {
            self.id = id
            self.type = type
        }
    }

    /// The scope of the of the template that is cascaded down to the folder's
    /// children.
    ///
    /// Example: "global"
    public enum Scope: String, Codable, CaseIterable {
        case global
        case enterprise = "enterprise_*"
    }

    /// `metadata_cascade_policy`
    ///
    /// Example: "metadata_cascade_policy"
    public enum `Type`: String, Codable, CaseIterable {
        case metadataCascadePolicy = "metadata_cascade_policy"
    }

    public init(id: String? = nil, ownerEnterprise: OwnerEnterprise? = nil, parent: Parent? = nil, scope: Scope? = nil, templateKey: String? = nil, type: `Type`? = nil) {
        self.id = id
        self.ownerEnterprise = ownerEnterprise
        self.parent = parent
        self.scope = scope
        self.templateKey = templateKey
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case ownerEnterprise = "owner_enterprise"
        case parent
        case scope
        case templateKey
        case type
    }
}

/// Match a `date` metadata field to a range of values.
///
/// Example:
///
/// {
///   "gt" : "2016-08-01T00:00:00Z",
///   "lt" : "2017-08-01T00:00:00Z"
/// }
public struct MetadataFieldFilterDateRangeItem: Codable {
    /// Specifies the (inclusive) lower bound for the metadata field
    /// value. The value of a field must be greater than (`gt`) or
    /// equal to this value for the search query to match this
    /// template.
    ///
    /// Example: "2016-08-01T00:00:00Z"
    public var gt: Date?
    /// Specifies the (inclusive) upper bound for the metadata field
    /// value. The value of a field must be lower than (`lt`) or
    /// equal to this value for the search query to match this
    /// template.
    ///
    /// Example: "2017-08-01T00:00:00Z"
    public var lt: Date?

    public init(gt: Date? = nil, lt: Date? = nil) {
        self.gt = gt
        self.lt = lt
    }
}

/// Specifies which `float` field on the template to filter the search
/// results by, specifying a range of values that can match.
///
/// Example:
///
/// {
///   "gt" : 100000,
///   "lt" : 200000
/// }
public struct MetadataFieldFilterFloatRangeItem: Codable {
    /// Specifies the (inclusive) lower bound for the metadata field
    /// value. The value of a field must be greater than (`gt`) or
    /// equal to this value for the search query to match this
    /// template.
    ///
    /// Example: 100000
    public var gt: Double?
    /// Specifies the (inclusive) upper bound for the metadata field
    /// value. The value of a field must be lower than (`lt`) or
    /// equal to this value for the search query to match this
    /// template.
    ///
    /// Example: 200000
    public var lt: Double?

    public init(gt: Double? = nil, lt: Double? = nil) {
        self.gt = gt
        self.lt = lt
    }
}

/// A metadata template to filter the search results by.
public struct MetadataFilter: Codable {
    public var filters: Filters?
    /// Specifies the scope of the template to filter search results by.
    /// 
    /// This will be `enterprise_{enterprise_id}` for templates defined
    /// for use in this enterprise, and `global` for general templates
    /// that are available to all enterprises using Box.
    ///
    /// Example: "enterprise"
    public var scope: Scope?
    /// The key of the template to filter search results by.
    /// 
    /// In many cases the template key is automatically derived
    /// of its display name, for example `Contract Template` would
    /// become `contractTemplate`. In some cases the creator of the
    /// template will have provided its own template key.
    /// 
    /// Please [list the templates for an enterprise][list], or
    /// get all instances on a [file][file] or [folder][folder]
    /// to inspect a template's key.
    /// 
    /// [list]: e://get-metadata-templates-enterprise
    /// [file]: e://get-files-id-metadata
    /// [folder]: e://get-folders-id-metadata
    ///
    /// Example: "contract"
    public var templateKey: String?

    public struct Filters: Codable {
        public var object: Object
        /// Specifies which fields on the template to filter the search
        /// results by. When more than one field is specified, the query
        /// performs a logical `AND` to ensure that the instance of the
        /// template matches each of the fields specified.
        public var anyJSON: AnyJSON
        /// Example:
        ///
        /// {
        ///   "category" : "online",
        ///   "contractValue" : 1000000
        /// }
        public var anyJSON2: AnyJSON

        public struct Object: Codable {
            /// Metadata field filter (string)
            ///
            /// Specifies which text field on the template to filter the search
            /// results by.
            ///
            /// Example:
            ///
            /// {
            ///   "category" : "online"
            /// }
            public var stringString: [String: String]?
            /// Metadata field filter (float)
            ///
            /// Specifies which `float` field on the template to filter the search
            /// results by.
            ///
            /// Example:
            ///
            /// {
            ///   "contractValue" : 10000
            /// }
            public var stringDouble: [String: Double]?
            /// Metadata field filter (multi-select)
            ///
            /// Specifies the values to match for a `multiSelect` metadata
            /// field. When performing a search, the query will essentially
            /// perform an `OR` operation to match any template where any of
            /// the provided values match this field.
            ///
            /// Example:
            ///
            /// {
            ///   "category" : [
            ///     "online",
            ///     "enterprise"
            ///   ]
            /// }
            public var stringString2: [String: [String]]?
            /// Metadata field filter (float range)
            ///
            /// Specifies which `float` field on the template to filter the search
            /// results by, specifying a range of values that can match.
            ///
            /// Example:
            ///
            /// {
            ///   "contractValue" : {
            ///     "gt" : 100000,
            ///     "lt" : 200000
            ///   }
            /// }
            public var stringMetadataFieldFilterFloatRangeItem: [String: MetadataFieldFilterFloatRangeItem]?
            /// Metadata field filter (date range)
            ///
            /// Specifies which `date` field on the template to filter the search
            /// results by, specifying a range of dates that can match.
            ///
            /// Example:
            ///
            /// {
            ///   "expirationDate" : {
            ///     "gt" : "2016-08-01T00:00:00Z",
            ///     "lt" : "2017-08-01T00:00:00Z"
            ///   }
            /// }
            public var stringMetadataFieldFilterDateRangeItem: [String: MetadataFieldFilterDateRangeItem]?

            public init(stringString: [String: String]? = nil, stringDouble: [String: Double]? = nil, stringString2: [String: [String]]? = nil, stringMetadataFieldFilterFloatRangeItem: [String: MetadataFieldFilterFloatRangeItem]? = nil, stringMetadataFieldFilterDateRangeItem: [String: MetadataFieldFilterDateRangeItem]? = nil) {
                self.stringString = stringString
                self.stringDouble = stringDouble
                self.stringString2 = stringString2
                self.stringMetadataFieldFilterFloatRangeItem = stringMetadataFieldFilterFloatRangeItem
                self.stringMetadataFieldFilterDateRangeItem = stringMetadataFieldFilterDateRangeItem
            }

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                self.stringString = try? container.decode([String: String].self)
                self.stringDouble = try? container.decode([String: Double].self)
                self.stringString2 = try? container.decode([String: [String]].self)
                self.stringMetadataFieldFilterFloatRangeItem = try? container.decode([String: MetadataFieldFilterFloatRangeItem].self)
                self.stringMetadataFieldFilterDateRangeItem = try? container.decode([String: MetadataFieldFilterDateRangeItem].self)
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                if let value = stringString { try container.encode(value) }
                if let value = stringDouble { try container.encode(value) }
                if let value = stringString2 { try container.encode(value) }
                if let value = stringMetadataFieldFilterFloatRangeItem { try container.encode(value) }
                if let value = stringMetadataFieldFilterDateRangeItem { try container.encode(value) }
            }
        }

        public init(object: Object, anyJSON: AnyJSON, anyJSON2: AnyJSON) {
            self.object = object
            self.anyJSON = anyJSON
            self.anyJSON2 = anyJSON2
        }

        public init(from decoder: Decoder) throws {
            self.object = try Object(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
            self.anyJSON2 = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(object, forKey: "object")
            try values.encode(anyJSON, forKey: "anyJSON")
            try values.encode(anyJSON2, forKey: "anyJSON2")
        }
    }

    /// Specifies the scope of the template to filter search results by.
    /// 
    /// This will be `enterprise_{enterprise_id}` for templates defined
    /// for use in this enterprise, and `global` for general templates
    /// that are available to all enterprises using Box.
    ///
    /// Example: "enterprise"
    public enum Scope: String, Codable, CaseIterable {
        case global
        case enterprise
        case enterpriseEnterpriseID = "enterprise_{enterprise_id}"
    }

    public init(filters: Filters? = nil, scope: Scope? = nil, templateKey: String? = nil) {
        self.filters = filters
        self.scope = scope
        self.templateKey = templateKey
    }
}

/// Metadata query search request
///
/// Create a search using SQL-like syntax to return items that match specific
/// metadata.
public struct MetadataQuery: Codable {
    /// The ID of the folder that you are restricting the query to. A
    /// value of zero will return results from all folders you have access
    /// to. A non-zero value will only return results found in the folder
    /// corresponding to the ID or in any of its subfolders.
    ///
    /// Example: "0"
    public var ancestorFolderID: String
    /// By default, this endpoint returns only the most basic info about the items for
    /// which the query matches. This attribute can be used to specify a list of
    /// additional attributes to return for any item, including its metadata.
    /// 
    /// This attribute takes a list of item fields, metadata template identifiers,
    /// or metadata template field identifiers.
    /// 
    /// For example:
    /// 
    /// * `created_by` will add the details of the user who created the item to
    /// the response.
    /// * `metadata.<scope>.<templateKey>` will return the mini-representation
    /// of the metadata instance identified by the `scope` and `templateKey`.
    /// * `metadata.<scope>.<templateKey>.<field>` will return all the mini-representation
    /// of the metadata instance identified by the `scope` and `templateKey` plus
    /// the field specified by the `field` name. Multiple fields for the same
    /// `scope` and `templateKey` can be defined.
    ///
    /// Example: ["extension", "created_at", "item_status", "metadata.enterprise_1234.contracts", "metadata.enterprise_1234.regions.location"]
    public var fields: [String]?
    /// Specifies the template used in the query. Must be in the form
    /// `scope.templateKey`. Not all templates can be used in this field,
    /// most notably the built-in, Box-provided classification templates
    /// can not be used in a query.
    ///
    /// Example: "enterprise_123456.someTemplate"
    public var from: String
    /// A value between 0 and 100 that indicates the maximum number of results
    /// to return for a single request. This only specifies a maximum
    /// boundary and will not guarantee the minimum number of results
    /// returned.
    ///
    /// Example: 50
    public var limit: Int?
    /// Marker to use for requesting the next page.
    ///
    /// Example: "AAAAAmVYB1FWec8GH6yWu2nwmanfMh07IyYInaa7DZDYjgO1H4KoLW29vPlLY173OKsci6h6xGh61gG73gnaxoS+o0BbI1/h6le6cikjlupVhASwJ2Cj0tOD9wlnrUMHHw3/ISf+uuACzrOMhN6d5fYrbidPzS6MdhJOejuYlvsg4tcBYzjauP3+VU51p77HFAIuObnJT0ff"
    public var marker: String?
    /// A list of template fields and directions to sort the metadata query
    /// results by.
    /// 
    /// The ordering `direction` must be the same for each item in the array.
    public var orderBy: [OrderByItem]?
    /// The query to perform. A query is a logical expression that is very similar
    /// to a SQL `SELECT` statement. Values in the search query can be turned into
    /// parameters specified in the `query_param` arguments list to prevent having
    /// to manually insert search values into the query string.
    /// 
    /// For example, a value of `:amount` would represent the `amount` value in
    /// `query_params` object.
    ///
    /// Example: "value >= :amount"
    public var query: String?
    /// Set of arguments corresponding to the parameters specified in the
    /// `query`. The type of each parameter used in the `query_params` must match
    /// the type of the corresponding metadata template field.
    ///
    /// Example:
    ///
    /// {
    ///   "amount" : "100"
    /// }
    public var queryParams: [String: String]?

    /// An object representing one of the metadata template fields to sort the
    /// metadata query results by.
    public struct OrderByItem: Codable {
        /// The direction to order by, either ascending or descending.
        /// 
        /// The `ordering` direction must be the same for each item in the
        /// array.
        ///
        /// Example: "asc"
        public var direction: Direction?
        /// The metadata template field to order by.
        /// 
        /// The `field_key` represents the `key` value of a field from the
        /// metadata template being searched for.
        ///
        /// Example: "amount"
        public var fieldKey: String?

        /// The direction to order by, either ascending or descending.
        /// 
        /// The `ordering` direction must be the same for each item in the
        /// array.
        ///
        /// Example: "asc"
        public enum Direction: String, Codable, CaseIterable {
            case asc = "ASC"
            case desc = "DESC"
            case asc2 = "asc"
            case desc2 = "desc"
        }

        public init(direction: Direction? = nil, fieldKey: String? = nil) {
            self.direction = direction
            self.fieldKey = fieldKey
        }

        private enum CodingKeys: String, CodingKey {
            case direction
            case fieldKey = "field_key"
        }
    }

    public init(ancestorFolderID: String, fields: [String]? = nil, from: String, limit: Int? = nil, marker: String? = nil, orderBy: [OrderByItem]? = nil, query: String? = nil, queryParams: [String: String]? = nil) {
        self.ancestorFolderID = ancestorFolderID
        self.fields = fields
        self.from = from
        self.limit = limit
        self.marker = marker
        self.orderBy = orderBy
        self.query = query
        self.queryParams = queryParams
    }

    private enum CodingKeys: String, CodingKey {
        case ancestorFolderID = "ancestor_folder_id"
        case fields
        case from
        case limit
        case marker
        case orderBy = "order_by"
        case query
        case queryParams = "query_params"
    }
}

/// A metadata query index
public struct MetadataQueryIndex: Codable {
    /// A list of template fields which make up the index.
    public var fields: [Field]?
    /// The ID of the metadata query index.
    ///
    /// Example: "-9876"
    public var id: String?
    /// The status of the metadata query index
    ///
    /// Example: "active"
    public var status: Status?
    /// Value is always `metadata_query_index`
    ///
    /// Example: "metadata_query_index"
    public var type: String?

    /// The field which makes up the index.
    public struct Field: Codable {
        /// The metadata template field key.
        ///
        /// Example: "vendor name"
        public var key: String?
        /// The sort direction of the field.
        ///
        /// Example: "asc"
        public var sortDirection: SortDirection?

        /// The sort direction of the field.
        ///
        /// Example: "asc"
        public enum SortDirection: String, Codable, CaseIterable {
            case asc
            case desc
        }

        public init(key: String? = nil, sortDirection: SortDirection? = nil) {
            self.key = key
            self.sortDirection = sortDirection
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.key = try values.decodeIfPresent(String.self, forKey: "key")
            self.sortDirection = try SortDirection(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(key, forKey: "key")
            try values.encodeIfPresent(sortDirection, forKey: "sort_direction")
        }
    }

    /// The status of the metadata query index
    ///
    /// Example: "active"
    public enum Status: String, Codable, CaseIterable {
        case building
        case active
        case disabled
    }

    public init(fields: [Field]? = nil, id: String? = nil, status: Status? = nil, type: String? = nil) {
        self.fields = fields
        self.id = id
        self.status = status
        self.type = type
    }
}

/// A collection of metadata query indices.
public struct MetadataQueryIndices: Codable {
    /// A collection of metadata query indices.
    public var entries: [MetadataQueryIndex]?
    /// The limit that was used for this request.
    ///
    /// Example: 100
    public var limit: Int?
    /// The marker for the start of the next page of results.
    ///
    /// Example: "0!-M7487OpVfBTNBV-XsQjU50gQFlbFFu5nArMWD7Ck61GH_Qo40M1S2xN5zWZPBzEjaQS1SOjJiQoo5BsXEl1bCVLRZ2pTqo4SKp9tyqzWQK2L51KR_nC1EgF5I_TJSFw7uO2Bx4HweGETOjh5_2oPSWw5iMkM-OvGApeR0lGFO48FDKoyzJyLgz5aogxoKd8VE09CesOOnTnmZvrW0puylDc-hFjY5YLmWFBKox3SOWiSDwKFkmZGNHyjEzza1nSwbZg6CYsAdGsDwGJhuCeTNsFzP5Mo5qx9wMloS0lSPuf2CcBInbIJzl2CKlXF3FvqhANttpm2nzdBTQRSoJyJnjVBpf4Q_HjV2eb4KIZBBlLy067UCVdv2AAWQFd5E2i6s1YiGRTtgMEZntOSUYD4IYLMWWm5Ra7ke_SP32SL3GSjbBQYIyCVQ.."
    public var nextMarker: String?

    public init(entries: [MetadataQueryIndex]? = nil, limit: Int? = nil, nextMarker: String? = nil) {
        self.entries = entries
        self.limit = limit
        self.nextMarker = nextMarker
    }

    private enum CodingKeys: String, CodingKey {
        case entries
        case limit
        case nextMarker = "next_marker"
    }
}

/// Metadata query search results
///
/// A page of files and folders that matched the metadata query.
public struct MetadataQueryResults: Codable {
    /// The mini representation of the files and folders that match the search
    /// terms.
    /// 
    /// By default, this endpoint returns only the most basic info about the
    /// items. To get additional fields for each item, including any of the
    /// metadata, use the `fields` attribute in the query.
    public var entries: [Entry]?
    /// The limit that was used for this search. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed.
    ///
    /// Example: 100
    public var limit: Int?
    /// The marker for the start of the next page of results.
    ///
    /// Example: "0!-M7487OpVfBTNBV-XsQjU50gQFlbFFu5nArMWD7Ck61GH_Qo40M1S2xN5zWZPBzEjaQS1SOjJiQoo5BsXEl1bCVLRZ2pTqo4SKp9tyqzWQK2L51KR_nC1EgF5I_TJSFw7uO2Bx4HweGETOjh5_2oPSWw5iMkM-OvGApeR0lGFO48FDKoyzJyLgz5aogxoKd8VE09CesOOnTnmZvrW0puylDc-hFjY5YLmWFBKox3SOWiSDwKFkmZGNHyjEzza1nSwbZg6CYsAdGsDwGJhuCeTNsFzP5Mo5qx9wMloS0lSPuf2CcBInbIJzl2CKlXF3FvqhANttpm2nzdBTQRSoJyJnjVBpf4Q_HjV2eb4KIZBBlLy067UCVdv2AAWQFd5E2i6s1YiGRTtgMEZntOSUYD4IYLMWWm5Ra7ke_SP32SL3GSjbBQYIyCVQ.."
    public var nextMarker: String?

    public enum Entry: Codable {
        case file(File)
        case folder(Folder)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(File.self) {
                self = .file(value)
            } else if let value = try? container.decode(Folder.self) {
                self = .folder(value)
            } else {
                throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
            case .file(let value): try container.encode(value)
            case .folder(let value): try container.encode(value)
            }
        }
    }

    public init(entries: [Entry]? = nil, limit: Int? = nil, nextMarker: String? = nil) {
        self.entries = entries
        self.limit = limit
        self.nextMarker = nextMarker
    }

    private enum CodingKeys: String, CodingKey {
        case entries
        case limit
        case nextMarker = "next_marker"
    }
}

/// A template for metadata that can be applied to files and folders
public struct MetadataTemplate: Codable {
    /// Whether or not to include the metadata when a file or folder is copied.
    ///
    /// Example: true
    public var isCopyInstanceOnItemCopy: Bool?
    /// The display name of the template. This can be seen in the Box web app
    /// and mobile apps.
    ///
    /// Example: "Product Info"
    public var displayName: String?
    /// An ordered list of template fields which are part of the template. Each
    /// field can be a regular text field, date field, number field, as well as a
    /// single or multi-select list.
    public var fields: [Field]?
    /// Defines if this template is visible in the Box web app UI, or if
    /// it is purely intended for usage through the API.
    ///
    /// Example: true
    public var isHidden: Bool?
    /// The ID of the metadata template.
    ///
    /// Example: "58063d82-4128-7b43-bba9-92f706befcdf"
    public var id: String?
    /// The scope of the metadata template can either be `global` or
    /// `enterprise_*`. The `global` scope is used for templates that are
    /// available to any Box enterprise. The `enterprise_*` scope represents
    /// templates that have been created within a specific enterprise, where `*`
    /// will be the ID of that enterprise.
    ///
    /// Example: "enterprise_123456"
    public var scope: String?
    /// A unique identifier for the template. This identifier is unique across
    /// the `scope` of the enterprise to which the metadata template is being
    /// applied, yet is not necessarily unique across different enterprises.
    ///
    /// Example: "productInfo"
    public var templateKey: String?
    /// `metadata_template`
    ///
    /// Example: "metadata_template"
    public var type: `Type`?

    /// A field within a metadata template. Fields can be a basic text, date, or
    /// number field, or a list of options.
    public struct Field: Codable {
        /// A description of the field. This is not shown to the user.
        ///
        /// Example: "The category"
        public var description: String?
        /// The display name of the field as it is shown to the user in the web and
        /// mobile apps.
        ///
        /// Example: "Category"
        public var displayName: String
        /// Whether this field is hidden in the UI for the user and can only be set
        /// through the API instead.
        ///
        /// Example: true
        public var isHidden: Bool?
        /// A unique identifier for the field. The identifier must
        /// be unique within the template to which it belongs.
        ///
        /// Example: "category"
        public var key: String
        /// A list of options for this field. This is used in combination with the
        /// `enum` and `multiSelect` field types.
        public var options: [Option]?
        /// The type of field. The basic fields are a `string` field for text, a
        /// `float` field for numbers, and a `date` fields to present the user with a
        /// date-time picker.
        /// 
        /// Additionally, metadata templates support an `enum` field for a basic list
        /// of items, and ` multiSelect` field for a similar list of items where the
        /// user can select more than one value.
        ///
        /// Example: "string"
        public var type: `Type`
        /// The unique ID of the metadata template field.
        ///
        /// Example: "822227e0-47a5-921b-88a8-494760b2e6d2"
        public var id: String?

        /// Metadata Option (Write)
        ///
        /// An option for a Metadata Template Field.
        /// 
        /// Options only need to be provided for fields of type `enum` and `multiSelect`.
        /// Options represent the value(s) a user can select for the field either through
        /// the UI or through the API.
        public struct Option: Codable {
            /// The text value of the option. This represents both the display name of the
            /// option and the internal key used when updating templates.
            ///
            /// Example: "Category 1"
            public var key: String

            public init(key: String) {
                self.key = key
            }
        }

        /// The type of field. The basic fields are a `string` field for text, a
        /// `float` field for numbers, and a `date` fields to present the user with a
        /// date-time picker.
        /// 
        /// Additionally, metadata templates support an `enum` field for a basic list
        /// of items, and ` multiSelect` field for a similar list of items where the
        /// user can select more than one value.
        ///
        /// Example: "string"
        public enum `Type`: String, Codable, CaseIterable {
            case string
            case float
            case date
            case `enum`
            case multiSelect
        }

        public init(description: String? = nil, displayName: String, isHidden: Bool? = nil, key: String, options: [Option]? = nil, type: `Type`, id: String? = nil) {
            self.description = description
            self.displayName = displayName
            self.isHidden = isHidden
            self.key = key
            self.options = options
            self.type = type
            self.id = id
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.description = try values.decodeIfPresent(String.self, forKey: "description")
            self.displayName = try values.decode(String.self, forKey: "displayName")
            self.isHidden = try values.decodeIfPresent(Bool.self, forKey: "hidden")
            self.key = try values.decode(String.self, forKey: "key")
            self.options = try values.decodeIfPresent([Option].self, forKey: "options")
            self.type = try `Type`(from: decoder)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(description, forKey: "description")
            try values.encode(displayName, forKey: "displayName")
            try values.encodeIfPresent(isHidden, forKey: "hidden")
            try values.encode(key, forKey: "key")
            try values.encodeIfPresent(options, forKey: "options")
            try values.encode(type, forKey: "type")
            try values.encodeIfPresent(id, forKey: "id")
        }
    }

    /// `metadata_template`
    ///
    /// Example: "metadata_template"
    public enum `Type`: String, Codable, CaseIterable {
        case metadataTemplate = "metadata_template"
    }

    public init(isCopyInstanceOnItemCopy: Bool? = nil, displayName: String? = nil, fields: [Field]? = nil, isHidden: Bool? = nil, id: String? = nil, scope: String? = nil, templateKey: String? = nil, type: `Type`? = nil) {
        self.isCopyInstanceOnItemCopy = isCopyInstanceOnItemCopy
        self.displayName = displayName
        self.fields = fields
        self.isHidden = isHidden
        self.id = id
        self.scope = scope
        self.templateKey = templateKey
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case isCopyInstanceOnItemCopy = "copyInstanceOnItemCopy"
        case displayName
        case fields
        case isHidden = "hidden"
        case id
        case scope
        case templateKey
        case type
    }
}

/// A list of metadata templates
public struct MetadataTemplates: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The marker for the start of the next page of results.
    ///
    /// Example: 3000
    public var nextMarker: Int?
    /// The marker for the start of the previous page of results.
    ///
    /// Example: 1000
    public var prevMarker: Int?
    public var entries: [MetadataTemplate]?

    public init(limit: Int? = nil, nextMarker: Int? = nil, prevMarker: Int? = nil, entries: [MetadataTemplate]? = nil) {
        self.limit = limit
        self.nextMarker = nextMarker
        self.prevMarker = prevMarker
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.nextMarker = try values.decodeIfPresent(Int.self, forKey: "next_marker")
        self.prevMarker = try values.decodeIfPresent(Int.self, forKey: "prev_marker")
        self.entries = try values.decodeIfPresent([MetadataTemplate].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(nextMarker, forKey: "next_marker")
        try values.encodeIfPresent(prevMarker, forKey: "prev_marker")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// Metadata instances
///
/// A list of metadata instances that have been applied to a file or folder.
public struct Metadatas: Codable {
    /// A list of metadata instances, as applied to this file or folder.
    public var entries: [MetadataBase]?
    /// The limit that was used for this page of results.
    ///
    /// Example: 100
    public var limit: Int?

    public init(entries: [MetadataBase]? = nil, limit: Int? = nil) {
        self.entries = entries
        self.limit = limit
    }
}

/// OAuth 2.0 error
///
/// An OAuth 2.0 error
public struct OAuth2Error: Codable {
    /// The type of the error returned.
    ///
    /// Example: "invalid_client"
    public var error: String?
    /// The type of the error returned.
    ///
    /// Example: "The client credentials are not valid"
    public var errorDescription: String?

    public init(error: String? = nil, errorDescription: String? = nil) {
        self.error = error
        self.errorDescription = errorDescription
    }

    private enum CodingKeys: String, CodingKey {
        case error
        case errorDescription = "error_description"
    }
}

/// Token revocation request
///
/// A request to revoke an OAuth 2.0 token
public struct PostOAuth2Revoke: Codable {
    /// The Client ID of the application requesting to revoke the
    /// access token.
    ///
    /// Example: "ly1nj6n11vionaie65emwzk575hnnmrk"
    public var clientID: String?
    /// The client secret of the application requesting to revoke
    /// an access token.
    ///
    /// Example: "hOzsTeFlT6ko0dme22uGbQal04SBPYc1"
    public var clientSecret: String?
    /// The access token to revoke.
    ///
    /// Example: "n22JPxrh18m4Y0wIZPIqYZK7VRrsMTWW"
    public var token: String?
    public var grantType: AnyJSON

    public init(clientID: String? = nil, clientSecret: String? = nil, token: String? = nil, grantType: AnyJSON) {
        self.clientID = clientID
        self.clientSecret = clientSecret
        self.token = token
        self.grantType = grantType
    }

    private enum CodingKeys: String, CodingKey {
        case clientID = "client_id"
        case clientSecret = "client_secret"
        case token
        case grantType = "grant_type"
    }
}

/// Token request
///
/// A request for a new OAuth 2.0 token
public struct PostOAuth2Token: Codable {
    /// The token used to create an annotator token.
    /// This is a JWT assertion.
    /// 
    /// Used in combination with `urn:ietf:params:oauth:grant-type:token-exchange`
    /// as the `grant_type`.
    ///
    /// Example: "c3FIOG9vSGV4VHo4QzAyg5T1JvNnJoZ3ExaVNyQWw6WjRsanRKZG5lQk9qUE1BVQ"
    public var actorToken: String?
    /// The type of `actor_token` passed in.
    /// 
    /// Used in combination with `urn:ietf:params:oauth:grant-type:token-exchange`
    /// as the `grant_type`.
    ///
    /// Example: "urn:ietf:params:oauth:token-type:id_token"
    public var actorTokenType: ActorTokenType?
    /// A JWT assertion for which to request a new access token.
    /// 
    /// Used in combination with `urn:ietf:params:oauth:grant-type:jwt-bearer`
    /// as the `grant_type`.
    ///
    /// Example: "xxxxx.yyyyy.zzzzz"
    public var assertion: String?
    /// Full URL of the shared link on the file or folder
    /// that the token should be generated for.
    ///
    /// Example: "https://cloud.box.com/s/123456"
    public var boxSharedLink: String?
    /// Used in combination with `client_credentials` as the `grant_type`.
    /// Value is determined by `box_subject_type`. If `user` use user ID and if
    /// `enterprise` use enterprise ID.
    ///
    /// Example: "123456789"
    public var boxSubjectID: String?
    /// Used in combination with `client_credentials` as the `grant_type`.
    ///
    /// Example: "enterprise"
    public var boxSubjectType: BoxSubjectType?
    /// The Client ID of the application requesting an access token.
    /// 
    /// Used in combination with `authorization_code`, `client_credentials`, or
    /// `urn:ietf:params:oauth:grant-type:jwt-bearer` as the `grant_type`.
    ///
    /// Example: "ly1nj6n11vionaie65emwzk575hnnmrk"
    public var clientID: String?
    /// The client secret of the application requesting an access token.
    /// 
    /// Used in combination with `authorization_code`, `client_credentials`, or
    /// `urn:ietf:params:oauth:grant-type:jwt-bearer` as the `grant_type`.
    ///
    /// Example: "hOzsTeFlT6ko0dme22uGbQal04SBPYc1"
    public var clientSecret: String?
    /// The client-side authorization code passed to your application by
    /// Box in the browser redirect after the user has successfully
    /// granted your application permission to make API calls on their
    /// behalf.
    /// 
    /// Used in combination with `authorization_code` as the `grant_type`.
    ///
    /// Example: "n22JPxrh18m4Y0wIZPIqYZK7VRrsMTWW"
    public var code: String?
    /// The type of request being made, either using a client-side obtained
    /// authorization code, a refresh token, a JWT assertion, client credentials
    /// grant or another access token for the purpose of downscoping a token.
    ///
    /// Example: "authorization_code"
    public var grantType: GrantType
    /// A refresh token used to get a new access token with.
    /// 
    /// Used in combination with `refresh_token` as the `grant_type`.
    ///
    /// Example: "c3FIOG9vSGV4VHo4QzAyg5T1JvNnJoZ3ExaVNyQWw6WjRsanRKZG5lQk9qUE1BVQ"
    public var refreshToken: String?
    /// Full URL for the file that the token should be generated for.
    ///
    /// Example: "https://api.box.com/2.0/files/123456"
    public var resource: String?
    /// The space-delimited list of scopes that you want apply to the
    /// new access token.
    /// 
    /// The `subject_token` will need to have all of these scopes or
    /// the call will error with **401 Unauthorized**.
    ///
    /// Example: "item_upload item_preview base_explorer"
    public var scope: String?
    /// The token to exchange for a downscoped token. This can be a regular
    /// access token, a JWT assertion, or an app token.
    /// 
    /// Used in combination with `urn:ietf:params:oauth:grant-type:token-exchange`
    /// as the `grant_type`.
    ///
    /// Example: "c3FIOG9vSGV4VHo4QzAyg5T1JvNnJoZ3ExaVNyQWw6WjRsanRKZG5lQk9qUE1BVQ"
    public var subjectToken: String?
    /// The type of `subject_token` passed in.
    /// 
    /// Used in combination with `urn:ietf:params:oauth:grant-type:token-exchange`
    /// as the `grant_type`.
    ///
    /// Example: "urn:ietf:params:oauth:token-type:access_token"
    public var subjectTokenType: SubjectTokenType?

    /// The type of `actor_token` passed in.
    /// 
    /// Used in combination with `urn:ietf:params:oauth:grant-type:token-exchange`
    /// as the `grant_type`.
    ///
    /// Example: "urn:ietf:params:oauth:token-type:id_token"
    public enum ActorTokenType: String, Codable, CaseIterable {
        case urnIetfParamsOauthTokenTypeIDToken = "urn:ietf:params:oauth:token-type:id_token"
    }

    /// Used in combination with `client_credentials` as the `grant_type`.
    ///
    /// Example: "enterprise"
    public enum BoxSubjectType: String, Codable, CaseIterable {
        case enterprise
        case user
    }

    /// The type of request being made, either using a client-side obtained
    /// authorization code, a refresh token, a JWT assertion, client credentials
    /// grant or another access token for the purpose of downscoping a token.
    ///
    /// Example: "authorization_code"
    public enum GrantType: String, Codable, CaseIterable {
        case authorizationCode = "authorization_code"
        case refreshToken = "refresh_token"
        case clientCredentials = "client_credentials"
        case urnIetfParamsOauthGrantTypeJwtBearer = "urn:ietf:params:oauth:grant-type:jwt-bearer"
        case urnIetfParamsOauthGrantTypeTokenExchange = "urn:ietf:params:oauth:grant-type:token-exchange"
    }

    /// The type of `subject_token` passed in.
    /// 
    /// Used in combination with `urn:ietf:params:oauth:grant-type:token-exchange`
    /// as the `grant_type`.
    ///
    /// Example: "urn:ietf:params:oauth:token-type:access_token"
    public enum SubjectTokenType: String, Codable, CaseIterable {
        case urnIetfParamsOauthTokenTypeAccessToken = "urn:ietf:params:oauth:token-type:access_token"
    }

    public init(actorToken: String? = nil, actorTokenType: ActorTokenType? = nil, assertion: String? = nil, boxSharedLink: String? = nil, boxSubjectID: String? = nil, boxSubjectType: BoxSubjectType? = nil, clientID: String? = nil, clientSecret: String? = nil, code: String? = nil, grantType: GrantType, refreshToken: String? = nil, resource: String? = nil, scope: String? = nil, subjectToken: String? = nil, subjectTokenType: SubjectTokenType? = nil) {
        self.actorToken = actorToken
        self.actorTokenType = actorTokenType
        self.assertion = assertion
        self.boxSharedLink = boxSharedLink
        self.boxSubjectID = boxSubjectID
        self.boxSubjectType = boxSubjectType
        self.clientID = clientID
        self.clientSecret = clientSecret
        self.code = code
        self.grantType = grantType
        self.refreshToken = refreshToken
        self.resource = resource
        self.scope = scope
        self.subjectToken = subjectToken
        self.subjectTokenType = subjectTokenType
    }

    private enum CodingKeys: String, CodingKey {
        case actorToken = "actor_token"
        case actorTokenType = "actor_token_type"
        case assertion
        case boxSharedLink = "box_shared_link"
        case boxSubjectID = "box_subject_id"
        case boxSubjectType = "box_subject_type"
        case clientID = "client_id"
        case clientSecret = "client_secret"
        case code
        case grantType = "grant_type"
        case refreshToken = "refresh_token"
        case resource
        case scope
        case subjectToken = "subject_token"
        case subjectTokenType = "subject_token_type"
    }
}

/// Refresh access token
///
/// A request to refresh an Access Token. Use this API to refresh an expired
/// Access Token using a valid Refresh Token.
public struct PostOAuth2TokenRefreshAccessToken: Codable {
    /// The client ID of the application requesting to refresh the token.
    ///
    /// Example: "ly1nj6n11vionaie65emwzk575hnnmrk"
    public var clientID: String
    /// The client secret of the application requesting to refresh the token.
    ///
    /// Example: "hOzsTeFlT6ko0dme22uGbQal04SBPYc1"
    public var clientSecret: String
    /// The type of request being made, in this case a refresh request.
    ///
    /// Example: "refresh_token"
    public var grantType: GrantType
    /// The refresh token to refresh.
    ///
    /// Example: "c3FIOG9vSGV4VHo4QzAyg5T1JvNnJoZ3ExaVNyQWw6WjRsanRKZG5lQk9qUE1BVQ"
    public var refreshToken: String

    /// The type of request being made, in this case a refresh request.
    ///
    /// Example: "refresh_token"
    public enum GrantType: String, Codable, CaseIterable {
        case refreshToken = "refresh_token"
    }

    public init(clientID: String, clientSecret: String, grantType: GrantType, refreshToken: String) {
        self.clientID = clientID
        self.clientSecret = clientSecret
        self.grantType = grantType
        self.refreshToken = refreshToken
    }

    private enum CodingKeys: String, CodingKey {
        case clientID = "client_id"
        case clientSecret = "client_secret"
        case grantType = "grant_type"
        case refreshToken = "refresh_token"
    }
}

/// Real-time server
///
/// A real-time server that can be used for
/// long polling user events
public struct RealtimeServer: Codable {
    /// The maximum number of retries this server will
    /// allow before a new long poll should be started by
    /// getting a [new list of server](#options-events).
    ///
    /// Example: 10
    public var maxRetries: Int?
    /// The maximum number of seconds without a response
    /// after which you should retry the long poll connection.
    /// 
    /// This helps to overcome network issues where the long
    /// poll looks to be working but no packages are coming
    /// through.
    ///
    /// Example: 610
    public var retryTimeout: Int?
    /// The time in minutes for which this server is available
    ///
    /// Example: 10
    public var ttl: Int?
    /// `realtime_server`
    ///
    /// Example: "realtime_server"
    public var type: String?
    /// The URL for the server.
    ///
    /// Example: "http://2.realtime.services.box.net/subscribe?channel=cc807c9c4869ffb1c81a&stream_type=all"
    public var url: String?

    public init(maxRetries: Int? = nil, retryTimeout: Int? = nil, ttl: Int? = nil, type: String? = nil, url: String? = nil) {
        self.maxRetries = maxRetries
        self.retryTimeout = retryTimeout
        self.ttl = ttl
        self.type = type
        self.url = url
    }

    private enum CodingKeys: String, CodingKey {
        case maxRetries = "max_retries"
        case retryTimeout = "retry_timeout"
        case ttl
        case type
        case url
    }
}

/// Real-time servers
///
/// A list of real-time servers that can
/// be used for long-polling.
public struct RealtimeServers: Codable {
    /// The number of items in this response.
    public var chunkSize: Int?
    public var entries: [RealtimeServer]?

    public init(chunkSize: Int? = nil, entries: [RealtimeServer]? = nil) {
        self.chunkSize = chunkSize
        self.entries = entries
    }

    private enum CodingKeys: String, CodingKey {
        case chunkSize = "chunk_size"
        case entries
    }
}

/// A recent item accessed by a user.
public struct RecentItem: Codable {
    /// The time of the most recent interaction.
    ///
    /// Example: "2018-04-13T13:53:23-07:00"
    public var interactedAt: Date?
    /// If the item was accessed through a shared link it will appear here,
    /// otherwise this will be null.
    ///
    /// Example: "https://www.box.com/shared/static/rh935iit6ewrmw0unyul.jpeg"
    public var interactionSharedLink: String?
    /// The most recent type of access the user performed on
    /// the item.
    ///
    /// Example: "item_preview"
    public var interactionType: InteractionType?
    public var item: Item?
    /// `recent_item`
    ///
    /// Example: "recent_item"
    public var type: String?

    /// The most recent type of access the user performed on
    /// the item.
    ///
    /// Example: "item_preview"
    public enum InteractionType: String, Codable, CaseIterable {
        case itemPreview = "item_preview"
        case itemUpload = "item_upload"
        case itemComment = "item_comment"
        case itemOpen = "item_open"
        case itemModify = "item_modify"
    }

    public struct Item: Codable {
        public var object: Object
        /// The item that was recently accessed.
        public var anyJSON: AnyJSON

        public enum Object: Codable {
            case file(File)
            case folder(Folder)
            case webLink(WebLink)

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(File.self) {
                    self = .file(value)
                } else if let value = try? container.decode(Folder.self) {
                    self = .folder(value)
                } else if let value = try? container.decode(WebLink.self) {
                    self = .webLink(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .file(let value): try container.encode(value)
                case .folder(let value): try container.encode(value)
                case .webLink(let value): try container.encode(value)
                }
            }
        }

        public init(object: Object, anyJSON: AnyJSON) {
            self.object = object
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.object = try Object(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(object, forKey: "object")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(interactedAt: Date? = nil, interactionSharedLink: String? = nil, interactionType: InteractionType? = nil, item: Item? = nil, type: String? = nil) {
        self.interactedAt = interactedAt
        self.interactionSharedLink = interactionSharedLink
        self.interactionType = interactionType
        self.item = item
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case interactedAt = "interacted_at"
        case interactionSharedLink = "interaction_shared_link"
        case interactionType = "interaction_type"
        case item
        case type
    }
}

/// A list of recent items.
public struct RecentItems: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The marker for the start of the next page of results.
    ///
    /// Example: 3000
    public var nextMarker: Int?
    /// The marker for the start of the previous page of results.
    ///
    /// Example: 1000
    public var prevMarker: Int?
    public var entries: [RecentItem]?

    public init(limit: Int? = nil, nextMarker: Int? = nil, prevMarker: Int? = nil, entries: [RecentItem]? = nil) {
        self.limit = limit
        self.nextMarker = nextMarker
        self.prevMarker = prevMarker
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.nextMarker = try values.decodeIfPresent(Int.self, forKey: "next_marker")
        self.prevMarker = try values.decodeIfPresent(Int.self, forKey: "prev_marker")
        self.entries = try values.decodeIfPresent([RecentItem].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(nextMarker, forKey: "next_marker")
        try values.encodeIfPresent(prevMarker, forKey: "prev_marker")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// A list of retention policies
public struct RetentionPolicies: Codable {
    public var entries: [RetentionPolicy]?
    /// The number of retention policies.
    ///
    /// Example: 156
    public var totalCount: Int?

    public init(entries: [RetentionPolicy]? = nil, totalCount: Int? = nil) {
        self.entries = entries
        self.totalCount = totalCount
    }

    private enum CodingKeys: String, CodingKey {
        case entries
        case totalCount = "total_count"
    }
}

/// A retention policy blocks permanent deletion of content
/// for a specified amount of time. Admins can create retention
/// policies and then later assign them to specific folders
/// or their entire enterprise.  To use this feature, you must
/// have the manage retention policies scope enabled
/// for your API key via your application management console.
public struct RetentionPolicy: Codable {
    /// Retention policy (Mini)
    ///
    /// A mini representation of a retention policy, used when
    /// nested within another resource.
    public var retentionPolicyMini: RetentionPolicyMini
    /// When the retention policy object was created
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var createdAt: Date?
    public var createdBy: CreatedBy?
    /// When the retention policy object was last modified
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var modifiedAt: Date?
    /// The type of the retention policy. A retention
    /// policy type can either be `finite`, where a
    /// specific amount of time to retain the content is known
    /// upfront, or `indefinite`, where the amount of time
    /// to retain the content is still unknown.
    ///
    /// Example: "finite"
    public var policyType: PolicyType?
    /// The status of the retention policy. The status of
    /// a policy will be `active`, unless explicitly retired by an
    /// administrator, in which case the status will be `retired`.
    /// Once a policy has been retired, it cannot become
    /// active again.
    ///
    /// Example: "active"
    public var status: Status?

    public struct CreatedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// A mini user object representing the user that
        /// created the retention policy
        public var anyJSON: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// The type of the retention policy. A retention
    /// policy type can either be `finite`, where a
    /// specific amount of time to retain the content is known
    /// upfront, or `indefinite`, where the amount of time
    /// to retain the content is still unknown.
    ///
    /// Example: "finite"
    public enum PolicyType: String, Codable, CaseIterable {
        case finite
        case indefinite
    }

    /// The status of the retention policy. The status of
    /// a policy will be `active`, unless explicitly retired by an
    /// administrator, in which case the status will be `retired`.
    /// Once a policy has been retired, it cannot become
    /// active again.
    ///
    /// Example: "active"
    public enum Status: String, Codable, CaseIterable {
        case active
        case retired
    }

    public init(retentionPolicyMini: RetentionPolicyMini, createdAt: Date? = nil, createdBy: CreatedBy? = nil, modifiedAt: Date? = nil, policyType: PolicyType? = nil, status: Status? = nil) {
        self.retentionPolicyMini = retentionPolicyMini
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.modifiedAt = modifiedAt
        self.policyType = policyType
        self.status = status
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.retentionPolicyMini = try RetentionPolicyMini(from: decoder)
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
        self.createdBy = try CreatedBy(from: decoder)
        self.modifiedAt = try values.decodeIfPresent(Date.self, forKey: "modified_at")
        self.policyType = try PolicyType(from: decoder)
        self.status = try Status(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(retentionPolicyMini, forKey: "retentionPolicyMini")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(createdBy, forKey: "created_by")
        try values.encodeIfPresent(modifiedAt, forKey: "modified_at")
        try values.encodeIfPresent(policyType, forKey: "policy_type")
        try values.encodeIfPresent(status, forKey: "status")
    }
}

/// Retention policy (Base)
///
/// The bare basic representation of a file version, the minimal
/// amount of fields returned when using the `fields` query
/// parameter.
public struct RetentionPolicyBase: Codable {
    /// The unique identifier that represent a file version.
    ///
    /// Example: "12345"
    public var id: String?
    /// `retention_policy`
    ///
    /// Example: "retention_policy"
    public var type: `Type`?

    /// `retention_policy`
    ///
    /// Example: "retention_policy"
    public enum `Type`: String, Codable, CaseIterable {
        case retentionPolicy = "retention_policy"
    }

    public init(id: String? = nil, type: `Type`? = nil) {
        self.id = id
        self.type = type
    }
}

/// Retention policy (Mini)
///
/// A mini representation of a retention policy, used when
/// nested within another resource.
public struct RetentionPolicyMini: Codable {
    /// Retention policy (Base)
    ///
    /// The bare basic representation of a file version, the minimal
    /// amount of fields returned when using the `fields` query
    /// parameter.
    public var retentionPolicyBase: RetentionPolicyBase
    /// The disposition action of the retention policy.
    /// This action can be `permanently_delete`, which
    /// will cause the content retained by the policy
    /// to be permanently deleted, or `remove_retention`,
    /// which will lift the retention policy from the content,
    /// allowing it to be deleted by users,
    /// once the retention policy has expired.
    ///
    /// Example: "permanently_delete"
    public var dispositionAction: DispositionAction?
    /// The name given to the retention policy
    ///
    /// Example: "Some Policy Name"
    public var policyName: String?
    /// The length of the retention policy. This length
    /// specifies the duration in days that the retention
    /// policy will be active for after being assigned to
    /// content.  If the policy has A `policy_type` of
    /// `indefinite`, the `retention_length` will also be
    /// `indefinite`.
    ///
    /// Example: "365"
    public var retentionLength: String?

    /// The disposition action of the retention policy.
    /// This action can be `permanently_delete`, which
    /// will cause the content retained by the policy
    /// to be permanently deleted, or `remove_retention`,
    /// which will lift the retention policy from the content,
    /// allowing it to be deleted by users,
    /// once the retention policy has expired.
    ///
    /// Example: "permanently_delete"
    public enum DispositionAction: String, Codable, CaseIterable {
        case permanentlyDelete = "permanently_delete"
        case removeRetention = "remove_retention"
    }

    public init(retentionPolicyBase: RetentionPolicyBase, dispositionAction: DispositionAction? = nil, policyName: String? = nil, retentionLength: String? = nil) {
        self.retentionPolicyBase = retentionPolicyBase
        self.dispositionAction = dispositionAction
        self.policyName = policyName
        self.retentionLength = retentionLength
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.retentionPolicyBase = try RetentionPolicyBase(from: decoder)
        self.dispositionAction = try DispositionAction(from: decoder)
        self.policyName = try values.decodeIfPresent(String.self, forKey: "policy_name")
        self.retentionLength = try values.decodeIfPresent(String.self, forKey: "retention_length")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(retentionPolicyBase, forKey: "retentionPolicyBase")
        try values.encodeIfPresent(dispositionAction, forKey: "disposition_action")
        try values.encodeIfPresent(policyName, forKey: "policy_name")
        try values.encodeIfPresent(retentionLength, forKey: "retention_length")
    }
}

/// The retention policy assignment endpoint provides a way
/// for admins to apply a retention policy on a per-folder
/// basis, or place a blanket policy over the entire
/// enterprise.
public struct RetentionPolicyAssignment: Codable {
    /// When the retention policy assignment object was
    /// created
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var assignedAt: Date?
    public var assignedBy: AssignedBy?
    public var assignedTo: AssignedTo?
    /// The unique identifier for this retention policy assignment
    ///
    /// Example: "11446498"
    public var id: String?
    public var retentionPolicy: RetentionPolicy?
    /// `retention_policy_assignment`
    ///
    /// Example: "retention_policy_assignment"
    public var type: `Type`?

    public struct AssignedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// A mini user object representing the user that
        /// created the retention policy assignment object
        public var anyJSON: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AssignedTo: Codable {
        /// The unique identifier for this object
        ///
        /// Example: "11446498"
        public var id: String?
        /// The type for this object
        ///
        /// Example: "file"
        public var type: String?
        /// The `type` and `id` of the content that is under
        /// retention. The `type` can either be `folder` or `
        /// enterprise`.
        public var anyJSON: AnyJSON

        public init(id: String? = nil, type: String? = nil, anyJSON: AnyJSON) {
            self.id = id
            self.type = type
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.type = try values.decodeIfPresent(String.self, forKey: "type")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(type, forKey: "type")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct RetentionPolicy: Codable {
        /// Retention policy (Mini)
        ///
        /// A mini representation of a retention policy, used when
        /// nested within another resource.
        public var retentionPolicyMini: RetentionPolicyMini
        /// A mini retention policy object representing the
        /// retention policy that has been assigned to this content
        public var anyJSON: AnyJSON

        public init(retentionPolicyMini: RetentionPolicyMini, anyJSON: AnyJSON) {
            self.retentionPolicyMini = retentionPolicyMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.retentionPolicyMini = try RetentionPolicyMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(retentionPolicyMini, forKey: "retentionPolicyMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// `retention_policy_assignment`
    ///
    /// Example: "retention_policy_assignment"
    public enum `Type`: String, Codable, CaseIterable {
        case retentionPolicyAssignment = "retention_policy_assignment"
    }

    public init(assignedAt: Date? = nil, assignedBy: AssignedBy? = nil, assignedTo: AssignedTo? = nil, id: String? = nil, retentionPolicy: RetentionPolicy? = nil, type: `Type`? = nil) {
        self.assignedAt = assignedAt
        self.assignedBy = assignedBy
        self.assignedTo = assignedTo
        self.id = id
        self.retentionPolicy = retentionPolicy
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case assignedAt = "assigned_at"
        case assignedBy = "assigned_by"
        case assignedTo = "assigned_to"
        case id
        case retentionPolicy = "retention_policy"
        case type
    }
}

/// A list of retention policy assignments
public struct RetentionPolicyAssignments: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The marker for the start of the next page of results.
    ///
    /// Example: 3000
    public var nextMarker: Int?
    /// The marker for the start of the previous page of results.
    ///
    /// Example: 1000
    public var prevMarker: Int?
    public var entries: [RetentionPolicyAssignment]?

    public init(limit: Int? = nil, nextMarker: Int? = nil, prevMarker: Int? = nil, entries: [RetentionPolicyAssignment]? = nil) {
        self.limit = limit
        self.nextMarker = nextMarker
        self.prevMarker = prevMarker
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.nextMarker = try values.decodeIfPresent(Int.self, forKey: "next_marker")
        self.prevMarker = try values.decodeIfPresent(Int.self, forKey: "prev_marker")
        self.entries = try values.decodeIfPresent([RetentionPolicyAssignment].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(nextMarker, forKey: "next_marker")
        try values.encodeIfPresent(prevMarker, forKey: "prev_marker")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// Search Result (including Shared Link)
///
/// A single of files, folder or web link that matched the search query,
/// including the additional information about the shared link through
/// which the item has been shared with the user.
/// 
/// This response format is only returned when the
/// `include_recent_shared_links` query parameter has been set to `true`.
public struct SearchResultWithSharedLink: Codable {
    /// The optional shared link through which the user has access to this
    /// item. This value is only returned for items for which the user has
    /// recently accessed the file through a shared link. For all other
    /// items this value will return `null`.
    ///
    /// Example: "https://www.box.com/s/vspke7y05sb214wjokpk"
    public var accessibleViaSharedLink: AnyJSON?
    public var item: Item?
    /// The result type. The value is always `search_result`.
    ///
    /// Example: "search_result"
    public var type: AnyJSON?

    public struct Item: Codable {
        public var object: Object
        /// The file, folder or web link that matched the
        /// search query.
        public var anyJSON: AnyJSON

        public enum Object: Codable {
            case file(File)
            case folder(Folder)
            case webLink(WebLink)

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(File.self) {
                    self = .file(value)
                } else if let value = try? container.decode(Folder.self) {
                    self = .folder(value)
                } else if let value = try? container.decode(WebLink.self) {
                    self = .webLink(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .file(let value): try container.encode(value)
                case .folder(let value): try container.encode(value)
                case .webLink(let value): try container.encode(value)
                }
            }
        }

        public init(object: Object, anyJSON: AnyJSON) {
            self.object = object
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.object = try Object(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(object, forKey: "object")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(accessibleViaSharedLink: AnyJSON? = nil, item: Item? = nil, type: AnyJSON? = nil) {
        self.accessibleViaSharedLink = accessibleViaSharedLink
        self.item = item
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case accessibleViaSharedLink = "accessible_via_shared_link"
        case item
        case type
    }
}

/// A list of files, folders and web links that matched the search query.
public struct SearchResults: Codable {
    /// The limit that was used for this search. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The 0-based offset of the first entry in this set. This will be the same
    /// as the `offset` query parameter used.
    ///
    /// Example: 2000
    public var offset: Int?
    /// One greater than the offset of the last entry in the search results.
    /// The total number of entries in the collection may be less than
    /// `total_count`.
    ///
    /// Example: 5000
    public var totalCount: Int?
    /// The search results for the query provided.
    public var entries: [Entry]?

    public enum Entry: Codable {
        case file(File)
        case folder(Folder)
        case webLink(WebLink)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(File.self) {
                self = .file(value)
            } else if let value = try? container.decode(Folder.self) {
                self = .folder(value)
            } else if let value = try? container.decode(WebLink.self) {
                self = .webLink(value)
            } else {
                throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
            case .file(let value): try container.encode(value)
            case .folder(let value): try container.encode(value)
            case .webLink(let value): try container.encode(value)
            }
        }
    }

    public init(limit: Int? = nil, offset: Int? = nil, totalCount: Int? = nil, entries: [Entry]? = nil) {
        self.limit = limit
        self.offset = offset
        self.totalCount = totalCount
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.offset = try values.decodeIfPresent(Int.self, forKey: "offset")
        self.totalCount = try values.decodeIfPresent(Int.self, forKey: "total_count")
        self.entries = try values.decodeIfPresent([Entry].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(offset, forKey: "offset")
        try values.encodeIfPresent(totalCount, forKey: "total_count")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// Search Results (including Shared Links)
///
/// A list of files, folders and web links that matched the search query,
/// including the additional information about any shared links through
/// which the item has been shared with the user.
/// 
/// This response format is only returned when the `include_recent_shared_links`
/// query parameter has been set to `true`.
public struct SearchResultsWithSharedLinks: Codable {
    /// The limit that was used for this search. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The 0-based offset of the first entry in this set. This will be the same
    /// as the `offset` query parameter used.
    ///
    /// Example: 2000
    public var offset: Int?
    /// One greater than the offset of the last entry in the search results.
    /// The total number of entries in the collection may be less than
    /// `total_count`.
    ///
    /// Example: 5000
    public var totalCount: Int?
    /// The search results for the query provided, including the
    /// additional information about any shared links through
    /// which the item has been shared with the user.
    public var entries: [SearchResultWithSharedLink]?

    public init(limit: Int? = nil, offset: Int? = nil, totalCount: Int? = nil, entries: [SearchResultWithSharedLink]? = nil) {
        self.limit = limit
        self.offset = offset
        self.totalCount = totalCount
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.offset = try values.decodeIfPresent(Int.self, forKey: "offset")
        self.totalCount = try values.decodeIfPresent(Int.self, forKey: "total_count")
        self.entries = try values.decodeIfPresent([SearchResultWithSharedLink].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(offset, forKey: "offset")
        try values.encodeIfPresent(totalCount, forKey: "total_count")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// A Sign Request Object
public struct SignRequest: Codable {
    /// Create a sign request
    ///
    /// A request to create a sign request object
    public var signRequestCreateRequest: SignRequestCreateRequest
    /// Uses `days_valid` to calculate the date and time, in GMT, the sign request will expire if unsigned.
    ///
    /// Example: "2021-04-26T08:12:13.982Z"
    public var autoExpireAt: Date?
    /// Sign request ID
    ///
    /// Example: "12345"
    public var id: String?
    /// This URL is returned if `is_document_preparation_needed` is
    /// set to `true` in the request. It is used to prepare the sign request
    /// via UI. The sign request is not sent until preparation is complete.
    ///
    /// Example: "https://prepareurl.com"
    public var prepareURL: String?
    /// List of files that will be signed, which are copies of the original
    /// source files. A new version of these files are created as signers sign
    /// and can be downloaded at any point in the signing process.
    public var signFiles: SignFiles?
    /// Array of signers for the sign request
    public var signers: [SignRequestSigner]?
    public var signingLog: SigningLog?
    /// Describes the status of the sign request
    ///
    /// Example: "converting"
    public var status: Status?
    /// Object type
    ///
    /// Example: "sign-request"
    public var type: `Type`?

    /// List of files that will be signed, which are copies of the original
    /// source files. A new version of these files are created as signers sign
    /// and can be downloaded at any point in the signing process.
    public struct SignFiles: Codable {
        public var files: [FileMini]?
        /// Indicates whether the `sign_files` documents are processing
        /// and the PDFs may be out of date. A change to any document
        /// requires processing on all `sign_files`. We
        /// recommended waiting until processing is finished
        /// (and this value is true) before downloading the PDFs.
        ///
        /// Example: true
        public var isReadyForDownload: Bool?

        public init(files: [FileMini]? = nil, isReadyForDownload: Bool? = nil) {
            self.files = files
            self.isReadyForDownload = isReadyForDownload
        }

        private enum CodingKeys: String, CodingKey {
            case files
            case isReadyForDownload = "is_ready_for_download"
        }
    }

    public struct SigningLog: Codable {
        /// File (Mini)
        ///
        /// A mini representation of a file, used when
        /// nested under another resource.
        public var fileMini: FileMini
        /// Reference to a file that holds a log of all signer activity for
        /// the request
        public var anyJSON: AnyJSON

        public init(fileMini: FileMini, anyJSON: AnyJSON) {
            self.fileMini = fileMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.fileMini = try FileMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(fileMini, forKey: "fileMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// Describes the status of the sign request
    ///
    /// Example: "converting"
    public enum Status: String, Codable, CaseIterable {
        case converting
        case created
        case sent
        case viewed
        case signed
        case cancelled
        case declined
        case errorConverting = "error_converting"
        case errorSending = "error_sending"
        case expired
    }

    /// Object type
    ///
    /// Example: "sign-request"
    public enum `Type`: String, Codable, CaseIterable {
        case signRequest = "sign-request"
    }

    public init(signRequestCreateRequest: SignRequestCreateRequest, autoExpireAt: Date? = nil, id: String? = nil, prepareURL: String? = nil, signFiles: SignFiles? = nil, signers: [SignRequestSigner]? = nil, signingLog: SigningLog? = nil, status: Status? = nil, type: `Type`? = nil) {
        self.signRequestCreateRequest = signRequestCreateRequest
        self.autoExpireAt = autoExpireAt
        self.id = id
        self.prepareURL = prepareURL
        self.signFiles = signFiles
        self.signers = signers
        self.signingLog = signingLog
        self.status = status
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.signRequestCreateRequest = try SignRequestCreateRequest(from: decoder)
        self.autoExpireAt = try values.decodeIfPresent(Date.self, forKey: "auto_expire_at")
        self.id = try values.decodeIfPresent(String.self, forKey: "id")
        self.prepareURL = try values.decodeIfPresent(String.self, forKey: "prepare_url")
        self.signFiles = try SignFiles(from: decoder)
        self.signers = try values.decodeIfPresent([SignRequestSigner].self, forKey: "signers")
        self.signingLog = try SigningLog(from: decoder)
        self.status = try Status(from: decoder)
        self.type = try `Type`(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(signRequestCreateRequest, forKey: "signRequestCreateRequest")
        try values.encodeIfPresent(autoExpireAt, forKey: "auto_expire_at")
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(prepareURL, forKey: "prepare_url")
        try values.encodeIfPresent(signFiles, forKey: "sign_files")
        try values.encodeIfPresent(signers, forKey: "signers")
        try values.encodeIfPresent(signingLog, forKey: "signing_log")
        try values.encodeIfPresent(status, forKey: "status")
        try values.encodeIfPresent(type, forKey: "type")
    }
}

/// Create a sign request
///
/// A request to create a sign request object
public struct SignRequestCreateRequest: Codable {
    /// Reminds signers to sign a document on day 3, 8, 13 and 18. Reminders are only sent to outstanding signers.
    ///
    /// Example: true
    public var isAreRemindersEnabled: Bool?
    /// Disables the usage of signatures generated by typing (text)
    ///
    /// Example: true
    public var isAreTextSignaturesEnabled: Bool
    /// Number of days after which this request will automatically expire if not completed
    public var daysValid: Int?
    /// Message to include in sign request email. The field is cleaned through sanitization of specific characters. However, some html tags are allowed. Links included in the message are also converted to hyperlinks in the email. The message may contain the following html tags including `a`, `abbr`, `acronym`, `b`, `blockquote`, `code`, `em`, `i`, `ul`, `li`, `ol`, and `strong`. Be aware that when the text to html ratio is too high, the email may end up in spam filters. Custom styles on these tags are not allowed. If this field is not passed, a default message will be used.
    ///
    /// Example: "Hello! Please sign the document below"
    public var emailMessage: String?
    /// Subject of sign request email. This is cleaned by sign request. If this field is not passed, a default subject will be used.
    ///
    /// Example: "Sign Request from Acme"
    public var emailSubject: String?
    /// This can be used to reference an ID in an external system that the sign request is related to.
    ///
    /// Example: "123"
    public var externalID: String?
    /// Indicates if the sender should receive a `prepare_url` in the response to complete document preparation via UI.
    ///
    /// Example: true
    public var isDocumentPreparationNeeded: Bool?
    public var parentFolder: ParentFolder
    /// When a document contains sign related tags in the content, you can prefill them using this `prefill_tags` by referencing the 'id' of the tag as the `external_id` field of the prefill tag.
    public var prefillTags: [SignRequestPrefillTag]?
    /// Array of signers for the sign request. 35 is the max number of signers permitted.
    public var signers: [SignRequestCreateSigner]
    /// List of files to create a signing document from. This is currently limited to one file. Only the ID and type fields are required for each file.
    public var sourceFiles: [FileMini]

    public struct ParentFolder: Codable {
        /// Folder (Mini)
        ///
        /// A mini representation of a file version, used when
        /// nested under another resource.
        public var folderMini: FolderMini
        /// The destination folder to place final, signed document and signing
        /// log. Only `ID` and `type` fields are required. The root folder,
        /// folder ID `0`, cannot be used.
        public var anyJSON: AnyJSON

        public init(folderMini: FolderMini, anyJSON: AnyJSON) {
            self.folderMini = folderMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.folderMini = try FolderMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(folderMini, forKey: "folderMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(isAreRemindersEnabled: Bool? = nil, isAreTextSignaturesEnabled: Bool? = nil, daysValid: Int? = nil, emailMessage: String? = nil, emailSubject: String? = nil, externalID: String? = nil, isDocumentPreparationNeeded: Bool? = nil, parentFolder: ParentFolder, prefillTags: [SignRequestPrefillTag]? = nil, signers: [SignRequestCreateSigner], sourceFiles: [FileMini]) {
        self.isAreRemindersEnabled = isAreRemindersEnabled
        self.isAreTextSignaturesEnabled = isAreTextSignaturesEnabled ?? true
        self.daysValid = daysValid
        self.emailMessage = emailMessage
        self.emailSubject = emailSubject
        self.externalID = externalID
        self.isDocumentPreparationNeeded = isDocumentPreparationNeeded
        self.parentFolder = parentFolder
        self.prefillTags = prefillTags
        self.signers = signers
        self.sourceFiles = sourceFiles
    }

    private enum CodingKeys: String, CodingKey {
        case isAreRemindersEnabled = "are_reminders_enabled"
        case isAreTextSignaturesEnabled = "are_text_signatures_enabled"
        case daysValid = "days_valid"
        case emailMessage = "email_message"
        case emailSubject = "email_subject"
        case externalID = "external_id"
        case isDocumentPreparationNeeded = "is_document_preparation_needed"
        case parentFolder = "parent_folder"
        case prefillTags = "prefill_tags"
        case signers
        case sourceFiles = "source_files"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isAreRemindersEnabled = try values.decodeIfPresent(Bool.self, forKey: .isAreRemindersEnabled)
        self.isAreTextSignaturesEnabled = try values.decodeIfPresent(Bool.self, forKey: .isAreTextSignaturesEnabled) ?? true
        self.daysValid = try values.decodeIfPresent(Int.self, forKey: .daysValid)
        self.emailMessage = try values.decodeIfPresent(String.self, forKey: .emailMessage)
        self.emailSubject = try values.decodeIfPresent(String.self, forKey: .emailSubject)
        self.externalID = try values.decodeIfPresent(String.self, forKey: .externalID)
        self.isDocumentPreparationNeeded = try values.decodeIfPresent(Bool.self, forKey: .isDocumentPreparationNeeded)
        self.parentFolder = try values.decode(ParentFolder.self, forKey: .parentFolder)
        self.prefillTags = try values.decodeIfPresent([SignRequestPrefillTag].self, forKey: .prefillTags)
        self.signers = try values.decode([SignRequestCreateSigner].self, forKey: .signers)
        self.sourceFiles = try values.decode([FileMini].self, forKey: .sourceFiles)
    }
}

/// Signer fields for Create Sign Request
///
/// The schema for a Signer in a POST Sign Request request body
public struct SignRequestCreateSigner: Codable {
    /// Email address of the signer
    ///
    /// Example: "example@gmail.com"
    public var email: String
    /// User ID for the signer in an external application responsible
    /// for authentication when accessing the embed URL.
    ///
    /// Example: "1234"
    public var embedURLExternalUserID: String?
    /// Used in combination with an embed URL for a sender. After the
    /// sender signs, they will be redirected to the next `in_person` signer.
    ///
    /// Example: true
    public var isInPerson: Bool?
    /// Order of the signer
    public var order: Int?
    /// Defines the role of the signer in the sign request. A `signer`
    /// must sign the document and an `approver` must approve the document. A
    /// `final_copy_reader` only receives the final signed document and signing
    /// log.
    ///
    /// Example: "signer"
    public var role: Role?

    /// Defines the role of the signer in the sign request. A `signer`
    /// must sign the document and an `approver` must approve the document. A
    /// `final_copy_reader` only receives the final signed document and signing
    /// log.
    ///
    /// Example: "signer"
    public enum Role: String, Codable, CaseIterable {
        case signer
        case approver
        case finalCopyReader = "final_copy_reader"
    }

    public init(email: String, embedURLExternalUserID: String? = nil, isInPerson: Bool? = nil, order: Int? = nil, role: Role? = nil) {
        self.email = email
        self.embedURLExternalUserID = embedURLExternalUserID
        self.isInPerson = isInPerson
        self.order = order
        self.role = role
    }

    private enum CodingKeys: String, CodingKey {
        case email
        case embedURLExternalUserID = "embed_url_external_user_id"
        case isInPerson = "is_in_person"
        case order
        case role
    }
}

/// Prefill tags are used to prefill placeholders with signer input data. Only
/// one value field can be included.
public struct SignRequestPrefillTag: Codable {
    /// Checkbox prefill value
    ///
    /// Example: true
    public var isCheckboxValue: Bool?
    /// Date prefill value
    ///
    /// Example: "2021-04-26T08:12:13.982Z"
    public var dateValue: Date?
    /// This references the ID of a specific tag contained in a file of the sign request.
    ///
    /// Example: "1234"
    public var documentTagID: String?
    /// Text prefill value
    ///
    /// Example: "text"
    public var textValue: String?

    public init(isCheckboxValue: Bool? = nil, dateValue: Date? = nil, documentTagID: String? = nil, textValue: String? = nil) {
        self.isCheckboxValue = isCheckboxValue
        self.dateValue = dateValue
        self.documentTagID = documentTagID
        self.textValue = textValue
    }

    private enum CodingKeys: String, CodingKey {
        case isCheckboxValue = "checkbox_value"
        case dateValue = "date_value"
        case documentTagID = "document_tag_id"
        case textValue = "text_value"
    }
}

/// Signer fields for GET Sign Request response
///
/// The schema for a Signer in a GET Sign Request request body
public struct SignRequestSigner: Codable {
    /// Signer fields for Create Sign Request
    ///
    /// The schema for a Signer in a POST Sign Request request body
    public var signRequestCreateSigner: SignRequestCreateSigner
    /// URL to direct a signer to for signing
    ///
    /// Example: "https://example.com"
    public var embedURL: String?
    /// Set to `true` if the signer views the document
    ///
    /// Example: true
    public var hasViewedDocument: Bool?
    public var inputs: [SignRequestSignerInput]?
    /// Final decision made by the signer
    public var signerDecision: SignerDecision?

    /// Final decision made by the signer
    public struct SignerDecision: Codable {
        /// Date and Time that the decision was made
        ///
        /// Example: "2021-04-26T08:12:13.982Z"
        public var finalizedAt: Date?
        /// Type of decision made by the signer
        ///
        /// Example: "signed"
        public var type: `Type`?

        /// Type of decision made by the signer
        ///
        /// Example: "signed"
        public enum `Type`: String, Codable, CaseIterable {
            case signed
            case declined
        }

        public init(finalizedAt: Date? = nil, type: `Type`? = nil) {
            self.finalizedAt = finalizedAt
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case finalizedAt = "finalized_at"
            case type
        }
    }

    public init(signRequestCreateSigner: SignRequestCreateSigner, embedURL: String? = nil, hasViewedDocument: Bool? = nil, inputs: [SignRequestSignerInput]? = nil, signerDecision: SignerDecision? = nil) {
        self.signRequestCreateSigner = signRequestCreateSigner
        self.embedURL = embedURL
        self.hasViewedDocument = hasViewedDocument
        self.inputs = inputs
        self.signerDecision = signerDecision
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.signRequestCreateSigner = try SignRequestCreateSigner(from: decoder)
        self.embedURL = try values.decodeIfPresent(String.self, forKey: "embed_url")
        self.hasViewedDocument = try values.decodeIfPresent(Bool.self, forKey: "has_viewed_document")
        self.inputs = try values.decodeIfPresent([SignRequestSignerInput].self, forKey: "inputs")
        self.signerDecision = try SignerDecision(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(signRequestCreateSigner, forKey: "signRequestCreateSigner")
        try values.encodeIfPresent(embedURL, forKey: "embed_url")
        try values.encodeIfPresent(hasViewedDocument, forKey: "has_viewed_document")
        try values.encodeIfPresent(inputs, forKey: "inputs")
        try values.encodeIfPresent(signerDecision, forKey: "signer_decision")
    }
}

/// Input created by a Signer on a Sign Request
public struct SignRequestSignerInput: Codable {
    /// Prefill tags are used to prefill placeholders with signer input data. Only
    /// one value field can be included.
    public var signRequestPrefillTag: SignRequestPrefillTag
    /// Index of page that the input is on
    public var pageIndex: Int?
    /// Type of input
    ///
    /// Example: "text"
    public var type: `Type`?

    /// Type of input
    ///
    /// Example: "text"
    public enum `Type`: String, Codable, CaseIterable {
        case signature
        case date
        case text
        case checkbox
    }

    public init(signRequestPrefillTag: SignRequestPrefillTag, pageIndex: Int? = nil, type: `Type`? = nil) {
        self.signRequestPrefillTag = signRequestPrefillTag
        self.pageIndex = pageIndex
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.signRequestPrefillTag = try SignRequestPrefillTag(from: decoder)
        self.pageIndex = try values.decodeIfPresent(Int.self, forKey: "page_index")
        self.type = try `Type`(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(signRequestPrefillTag, forKey: "signRequestPrefillTag")
        try values.encodeIfPresent(pageIndex, forKey: "page_index")
        try values.encodeIfPresent(type, forKey: "type")
    }
}

/// Box Sign
///
/// A standard representation of a sign request, as returned from any Box Sign
/// API endpoints by default.
public struct SignRequests: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The marker for the start of the next page of results.
    ///
    /// Example: 3000
    public var nextMarker: Int?
    /// The marker for the start of the previous page of results.
    ///
    /// Example: 1000
    public var prevMarker: Int?
    public var entries: [SignRequest]?

    public init(limit: Int? = nil, nextMarker: Int? = nil, prevMarker: Int? = nil, entries: [SignRequest]? = nil) {
        self.limit = limit
        self.nextMarker = nextMarker
        self.prevMarker = prevMarker
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.nextMarker = try values.decodeIfPresent(Int.self, forKey: "next_marker")
        self.prevMarker = try values.decodeIfPresent(Int.self, forKey: "prev_marker")
        self.entries = try values.decodeIfPresent([SignRequest].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(nextMarker, forKey: "next_marker")
        try values.encodeIfPresent(prevMarker, forKey: "prev_marker")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// A generic Box Skill metadata card.
public struct SkillCard: Codable {
    /// The optional date and time this card was created at.
    ///
    /// Example: "2018-04-13T13:53:23-07:00"
    public var createdAt: Date?
    /// An optional total duration in seconds.
    /// 
    /// Used with a `skill_card_type` of `transcript` or
    /// `timeline`.
    ///
    /// Example: 1000
    public var duration: Int?
    /// An optional list of entries in the metadata card.
    /// 
    /// This field is used with a `skill_card_type` of
    /// `transcript`, `keyword` or `timeline`.
    public var entries: [Entry]?
    /// The invocation of this service, used to track
    /// which instance of a service applied the metadata.
    public var invocation: Invocation
    /// The service that applied this metadata.
    public var skill: Skill
    /// The title of the card.
    public var skillCardTitle: SkillCardTitle?
    /// The type of card to add to the file.
    ///
    /// Example: "status"
    public var skillCardType: SkillCardType
    /// Used with a card of type `status` to set the status of the skill. This can be used to show a message to the user while the Skill is processing the data.
    public var status: Status?
    /// `skill_card`
    ///
    /// Example: "skill_card"
    public var type: `Type`

    /// An entry in the `entries` attribute of a metadata card
    public struct Entry: Codable {
        /// Defines a list of timestamps for an entry. This is
        /// used with a `skill_card_type` of `transcript` as
        /// well as `timeline` to place items on a timeline.
        /// 
        /// For a `skill_card_type` of `transcript` there can
        /// only be one entry in this list for each item, and
        /// only the `start` time is used to place the
        /// transcript on the timeline.
        public var appears: [Appear]?
        /// The image to show on a for an entry that appears
        /// on a timeline. This image URL is required for any
        /// `timeline` cards. The image will be shown in a
        /// list of items (for example faces), and clicking
        /// the image will show the user where that entry
        /// appears during the duration of this entry.
        ///
        /// Example: "https://example.com/image1.jpg"
        public var imageURL: String?
        /// The text of the entry. This would be the actual
        /// keyword in a `keyword` card, the line of a
        /// transcript in a `transcript` card, or the display
        /// name for an item when using the `timeline` entry.
        ///
        /// Example: "keyword1"
        public var text: String?

        /// The timestamp for an entry.
        public struct Appear: Codable {
            /// The time in seconds when an
            /// entry should stop appearing on a timeline. For
            /// a `skill_card_type` of `transcript` this value
            /// is ignored.
            ///
            /// Example: 20
            public var end: Int?
            /// The time in seconds when an
            /// entry should start appearing on a timeline.
            public var start: Int?

            public init(end: Int? = nil, start: Int? = nil) {
                self.end = end
                self.start = start
            }
        }

        public init(appears: [Appear]? = nil, imageURL: String? = nil, text: String? = nil) {
            self.appears = appears
            self.imageURL = imageURL
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case appears
            case imageURL = "image_url"
            case text
        }
    }

    /// The invocation of this service, used to track
    /// which instance of a service applied the metadata.
    public struct Invocation: Codable {
        /// A custom identifier that represent the instance of
        /// the service that applied this metadata. For example,
        /// if your `image-recognition-service` runs on multiple
        /// nodes, this field can be used to identify the ID of
        /// the node that was used to apply the metadata.
        ///
        /// Example: "image-recognition-service-123"
        public var id: String
        /// `skill_invocation`
        ///
        /// Example: "skill_invocation"
        public var type: `Type`

        /// `skill_invocation`
        ///
        /// Example: "skill_invocation"
        public enum `Type`: String, Codable, CaseIterable {
            case skillInvocation = "skill_invocation"
        }

        public init(id: String, type: `Type`) {
            self.id = id
            self.type = type
        }
    }

    /// The service that applied this metadata.
    public struct Skill: Codable {
        /// A custom identifier that represent the service that
        /// applied this metadata.
        ///
        /// Example: "image-recognition-service"
        public var id: String
        /// `service`
        ///
        /// Example: "service"
        public var type: `Type`

        /// `service`
        ///
        /// Example: "service"
        public enum `Type`: String, Codable, CaseIterable {
            case service
        }

        public init(id: String, type: `Type`) {
            self.id = id
            self.type = type
        }
    }

    /// The title of the card.
    public struct SkillCardTitle: Codable {
        /// An optional identifier for the title.
        ///
        /// Example: "my_transcripts"
        public var code: String?
        /// The actual title to show in the UI.
        ///
        /// Example: "My Transcripts"
        public var message: String

        public init(code: String? = nil, message: String) {
            self.code = code
            self.message = message
        }
    }

    /// The type of card to add to the file.
    ///
    /// Example: "status"
    public enum SkillCardType: String, Codable, CaseIterable {
        case transcript
        case keyword
        case timeline
        case status
    }

    /// Used with a card of type `status` to set the status of the skill. This can be used to show a message to the user while the Skill is processing the data.
    public struct Status: Codable {
        /// A code for the status of this Skill invocation. By
        /// default each of these will have their own accompanied
        /// messages. These can be adjusted by setting the `message`
        /// value on this object.
        ///
        /// Example: "success"
        public var code: Code
        /// A custom message that can be provided with this status.
        /// This will be shown in the web app to the end user.
        ///
        /// Example: "We're preparing to process your file. Please hold on!"
        public var message: String?

        /// A code for the status of this Skill invocation. By
        /// default each of these will have their own accompanied
        /// messages. These can be adjusted by setting the `message`
        /// value on this object.
        ///
        /// Example: "success"
        public enum Code: String, Codable, CaseIterable {
            case invoked
            case processing
            case success
            case transientFailure = "transient_failure"
            case permanentFailure = "permanent_failure"
        }

        public init(code: Code, message: String? = nil) {
            self.code = code
            self.message = message
        }
    }

    /// `skill_card`
    ///
    /// Example: "skill_card"
    public enum `Type`: String, Codable, CaseIterable {
        case skillCard = "skill_card"
    }

    public init(createdAt: Date? = nil, duration: Int? = nil, entries: [Entry]? = nil, invocation: Invocation, skill: Skill, skillCardTitle: SkillCardTitle? = nil, skillCardType: SkillCardType, status: Status? = nil, type: `Type`) {
        self.createdAt = createdAt
        self.duration = duration
        self.entries = entries
        self.invocation = invocation
        self.skill = skill
        self.skillCardTitle = skillCardTitle
        self.skillCardType = skillCardType
        self.status = status
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case duration
        case entries
        case invocation
        case skill
        case skillCardTitle = "skill_card_title"
        case skillCardType = "skill_card_type"
        case status
        case type
    }
}

/// Skills metadata instance
///
/// The metadata assigned to a using for Box skills.
public struct SkillCardsMetadata: Codable {
    /// Whether the user can edit this metadata
    ///
    /// Example: true
    public var canEdit: Bool?
    /// A UUID to identify the metadata object
    ///
    /// Example: "01234500-12f1-1234-aa12-b1d234cb567e"
    public var id: String?
    /// An ID for the parent folder
    ///
    /// Example: "folder_59449484661,"
    public var parent: String?
    /// An ID for the scope in which this template
    /// has been applied
    ///
    /// Example: "enterprise_27335"
    public var scope: String?
    /// The name of the template
    ///
    /// Example: "properties"
    public var template: String?
    /// A unique identifier for the "type" of this instance. This is an internal
    /// system property and should not be used by a client application.
    ///
    /// Example: "properties-6bcba49f-ca6d-4d2a-a758-57fe6edf44d0"
    public var type: String?
    /// The last-known version of the template of the object. This is an internal
    /// system property and should not be used by a client application.
    public var typeVersion: Int?
    /// The version of the metadata object. Starts at 0 and increases every time
    /// a user-defined property is modified.
    public var version: Int?
    /// A list of Box Skill cards that have been applied to this file.
    public var cards: [Card]?

    public enum Card: Codable {
        case skillCard(SkillCard)
        case keywordSkillCard(KeywordSkillCard)
        case timelineSkillCard(TimelineSkillCard)
        case transcriptSkillCard(TranscriptSkillCard)
        case statusSkillCard(StatusSkillCard)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(SkillCard.self) {
                self = .skillCard(value)
            } else if let value = try? container.decode(KeywordSkillCard.self) {
                self = .keywordSkillCard(value)
            } else if let value = try? container.decode(TimelineSkillCard.self) {
                self = .timelineSkillCard(value)
            } else if let value = try? container.decode(TranscriptSkillCard.self) {
                self = .transcriptSkillCard(value)
            } else if let value = try? container.decode(StatusSkillCard.self) {
                self = .statusSkillCard(value)
            } else {
                throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
            case .skillCard(let value): try container.encode(value)
            case .keywordSkillCard(let value): try container.encode(value)
            case .timelineSkillCard(let value): try container.encode(value)
            case .transcriptSkillCard(let value): try container.encode(value)
            case .statusSkillCard(let value): try container.encode(value)
            }
        }
    }

    public init(canEdit: Bool? = nil, id: String? = nil, parent: String? = nil, scope: String? = nil, template: String? = nil, type: String? = nil, typeVersion: Int? = nil, version: Int? = nil, cards: [Card]? = nil) {
        self.canEdit = canEdit
        self.id = id
        self.parent = parent
        self.scope = scope
        self.template = template
        self.type = type
        self.typeVersion = typeVersion
        self.version = version
        self.cards = cards
    }

    private enum CodingKeys: String, CodingKey {
        case canEdit = "$canEdit"
        case id = "$id"
        case parent = "$parent"
        case scope = "$scope"
        case template = "$template"
        case type = "$type"
        case typeVersion = "$typeVersion"
        case version = "$version"
        case cards
    }
}

/// Skill webhook payload
///
/// The payload of a Box skill as sent to a skill's
/// `invocation_url`.
public struct SkillInvocation: Codable {
    /// The time this invocation was created.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var createdAt: Date?
    public var enterprise: Enterprise?
    public var event: Event?
    /// Unique identifier for the invocation request.
    ///
    /// Example: "fd1d2e53-35f5-41fb-9c25-4ba326daf2f9_341016304"
    public var id: String?
    public var skill: Skill?
    public var source: Source?
    /// The details status of this event.
    public var status: Status?
    /// The read-only and read-write access tokens for this item
    public var token: Token?
    /// Action that triggered the invocation
    ///
    /// Example: "FILE_CONTENT"
    public var trigger: String?
    /// `skill_invocation`
    ///
    /// Example: "skill_invocation"
    public var type: `Type`?

    public struct Enterprise: Codable {
        /// The unique identifier for this enterprise.
        ///
        /// Example: "11446498"
        public var id: String?
        /// The name of the enterprise
        ///
        /// Example: "Acme Inc."
        public var name: String?
        /// `enterprise`
        ///
        /// Example: "enterprise"
        public var type: `Type`?
        /// The enterprise that this invocation was triggered for
        public var anyJSON: AnyJSON

        /// `enterprise`
        ///
        /// Example: "enterprise"
        public enum `Type`: String, Codable, CaseIterable {
            case enterprise
        }

        public init(id: String? = nil, name: String? = nil, type: `Type`? = nil, anyJSON: AnyJSON) {
            self.id = id
            self.name = name
            self.type = type
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.type = try `Type`(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(type, forKey: "type")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class Event: Codable {
        /// The description of an event that happened within Box
        public var event: BoxAPI.Event
        /// The event that triggered this invocation
        public var anyJSON: AnyJSON

        public init(event: BoxAPI.Event, anyJSON: AnyJSON) {
            self.event = event
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.event = try values.decode(BoxAPI.Event.self, forKey: "event")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(event, forKey: "event")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Skill: Codable {
        /// The client ID of the application
        ///
        /// Example: "hxel2s12wd2h9r8ne103c4gjbqefofih"
        public var apiKey: String?
        /// The unique identifier for this skill
        ///
        /// Example: "11446498"
        public var id: String?
        /// The name of the skill
        ///
        /// Example: "Hello World Skill"
        public var name: String?
        /// `skill`
        ///
        /// Example: "skill"
        public var type: `Type`?
        /// The skill that triggered this invocation
        public var anyJSON: AnyJSON

        /// `skill`
        ///
        /// Example: "skill"
        public enum `Type`: String, Codable, CaseIterable {
            case skill
        }

        public init(apiKey: String? = nil, id: String? = nil, name: String? = nil, type: `Type`? = nil, anyJSON: AnyJSON) {
            self.apiKey = apiKey
            self.id = id
            self.name = name
            self.type = type
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.apiKey = try values.decodeIfPresent(String.self, forKey: "api_key")
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.type = try `Type`(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(apiKey, forKey: "api_key")
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(type, forKey: "type")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Source: Codable {
        public var object: Object
        /// The item that caused the invocation to trigger
        public var anyJSON: AnyJSON

        public enum Object: Codable {
            case file(File)
            case folder(Folder)

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(File.self) {
                    self = .file(value)
                } else if let value = try? container.decode(Folder.self) {
                    self = .folder(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .file(let value): try container.encode(value)
                case .folder(let value): try container.encode(value)
                }
            }
        }

        public init(object: Object, anyJSON: AnyJSON) {
            self.object = object
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.object = try Object(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(object, forKey: "object")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// The details status of this event.
    public struct Status: Codable {
        /// Additional status information.
        ///
        /// Example: "Example"
        public var additionalInfo: String?
        /// Error code information, if error occurred.
        ///
        /// Example: "400"
        public var errorCode: String?
        /// Status information
        ///
        /// Example: "Example"
        public var message: String?
        /// The state of this event.
        /// 
        /// * `invoked` - Triggered the skill with event details to start
        ///   applying skill on the file.
        /// * `processing` - Currently processing.
        /// * `success` - Completed processing with a success.
        /// * `transient_failure` - Encountered an issue which can be
        ///   retried.
        /// * `permanent_failure` -  Encountered a permanent issue and
        ///   retry would not help.
        ///
        /// Example: "invoked"
        public var state: State?

        /// The state of this event.
        /// 
        /// * `invoked` - Triggered the skill with event details to start
        ///   applying skill on the file.
        /// * `processing` - Currently processing.
        /// * `success` - Completed processing with a success.
        /// * `transient_failure` - Encountered an issue which can be
        ///   retried.
        /// * `permanent_failure` -  Encountered a permanent issue and
        ///   retry would not help.
        ///
        /// Example: "invoked"
        public enum State: String, Codable, CaseIterable {
            case invoked
            case processing
            case success
            case transientFailure = "transient_failure"
            case permanentFailure = "permanent_failure"
        }

        public init(additionalInfo: String? = nil, errorCode: String? = nil, message: String? = nil, state: State? = nil) {
            self.additionalInfo = additionalInfo
            self.errorCode = errorCode
            self.message = message
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case additionalInfo = "additional_info"
            case errorCode = "error_code"
            case message
            case state
        }
    }

    /// The read-only and read-write access tokens for this item
    public struct Token: Codable {
        /// The basics of an access token
        public var read: Read?
        /// The basics of an access token
        public var write: Write?

        /// The basics of an access token
        public struct Read: Codable {
            /// The requested access token.
            ///
            /// Example: "c3FIOG9vSGV4VHo4QzAyg5T1JvNnJoZ3ExaVNyQWw6WjRsanRKZG5lQk9qUE1BVQ"
            public var accessToken: String?
            /// The time in seconds in seconds by which this token will expire.
            ///
            /// Example: 3600
            public var expiresIn: Int?
            /// The permissions that this access token permits,
            /// providing a list of resources (files, folders, etc)
            /// and the scopes permitted for each of those resources.
            public var restrictedTo: [FileScope]?
            /// The type of access token returned.
            ///
            /// Example: "bearer"
            public var tokenType: TokenType?

            /// The type of access token returned.
            ///
            /// Example: "bearer"
            public enum TokenType: String, Codable, CaseIterable {
                case bearer
            }

            public init(accessToken: String? = nil, expiresIn: Int? = nil, restrictedTo: [FileScope]? = nil, tokenType: TokenType? = nil) {
                self.accessToken = accessToken
                self.expiresIn = expiresIn
                self.restrictedTo = restrictedTo
                self.tokenType = tokenType
            }

            private enum CodingKeys: String, CodingKey {
                case accessToken = "access_token"
                case expiresIn = "expires_in"
                case restrictedTo = "restricted_to"
                case tokenType = "token_type"
            }
        }

        /// The basics of an access token
        public struct Write: Codable {
            /// The requested access token.
            ///
            /// Example: "c3FIOG9vSGV4VHo4QzAyg5T1JvNnJoZ3ExaVNyQWw6WjRsanRKZG5lQk9qUE1BVQ"
            public var accessToken: String?
            /// The time in seconds in seconds by which this token will expire.
            ///
            /// Example: 3600
            public var expiresIn: Int?
            /// The permissions that this access token permits,
            /// providing a list of resources (files, folders, etc)
            /// and the scopes permitted for each of those resources.
            public var restrictedTo: [FileScope]?
            /// The type of access token returned.
            ///
            /// Example: "bearer"
            public var tokenType: TokenType?

            /// The type of access token returned.
            ///
            /// Example: "bearer"
            public enum TokenType: String, Codable, CaseIterable {
                case bearer
            }

            public init(accessToken: String? = nil, expiresIn: Int? = nil, restrictedTo: [FileScope]? = nil, tokenType: TokenType? = nil) {
                self.accessToken = accessToken
                self.expiresIn = expiresIn
                self.restrictedTo = restrictedTo
                self.tokenType = tokenType
            }

            private enum CodingKeys: String, CodingKey {
                case accessToken = "access_token"
                case expiresIn = "expires_in"
                case restrictedTo = "restricted_to"
                case tokenType = "token_type"
            }
        }

        public init(read: Read? = nil, write: Write? = nil) {
            self.read = read
            self.write = write
        }
    }

    /// `skill_invocation`
    ///
    /// Example: "skill_invocation"
    public enum `Type`: String, Codable, CaseIterable {
        case skillInvocation = "skill_invocation"
    }

    public init(createdAt: Date? = nil, enterprise: Enterprise? = nil, event: Event? = nil, id: String? = nil, skill: Skill? = nil, source: Source? = nil, status: Status? = nil, token: Token? = nil, trigger: String? = nil, type: `Type`? = nil) {
        self.createdAt = createdAt
        self.enterprise = enterprise
        self.event = event
        self.id = id
        self.skill = skill
        self.source = source
        self.status = status
        self.token = token
        self.trigger = trigger
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case enterprise
        case event
        case id
        case skill
        case source
        case status
        case token
        case trigger
        case type
    }
}

/// A Box Skill metadata card that puts a status message in the metadata sidebar.
public struct StatusSkillCard: Codable {
    /// The optional date and time this card was created at.
    ///
    /// Example: "2018-04-13T13:53:23-07:00"
    public var createdAt: Date?
    /// The invocation of this service, used to track
    /// which instance of a service applied the metadata.
    public var invocation: Invocation
    /// The service that applied this metadata.
    public var skill: Skill
    /// The title of the card.
    public var skillCardTitle: SkillCardTitle?
    /// `status`
    ///
    /// Example: "status"
    public var skillCardType: SkillCardType
    /// Sets the status of the skill. This can be used to show a message to the user while the Skill is processing the data, or if it was not able to process the file.
    public var status: Status
    /// `skill_card`
    ///
    /// Example: "skill_card"
    public var type: `Type`

    /// The invocation of this service, used to track
    /// which instance of a service applied the metadata.
    public struct Invocation: Codable {
        /// A custom identifier that represent the instance of
        /// the service that applied this metadata. For example,
        /// if your `image-recognition-service` runs on multiple
        /// nodes, this field can be used to identify the ID of
        /// the node that was used to apply the metadata.
        ///
        /// Example: "image-recognition-service-123"
        public var id: String
        /// `skill_invocation`
        ///
        /// Example: "skill_invocation"
        public var type: `Type`

        /// `skill_invocation`
        ///
        /// Example: "skill_invocation"
        public enum `Type`: String, Codable, CaseIterable {
            case skillInvocation = "skill_invocation"
        }

        public init(id: String, type: `Type`) {
            self.id = id
            self.type = type
        }
    }

    /// The service that applied this metadata.
    public struct Skill: Codable {
        /// A custom identifier that represent the service that
        /// applied this metadata.
        ///
        /// Example: "image-recognition-service"
        public var id: String
        /// `service`
        ///
        /// Example: "service"
        public var type: `Type`

        /// `service`
        ///
        /// Example: "service"
        public enum `Type`: String, Codable, CaseIterable {
            case service
        }

        public init(id: String, type: `Type`) {
            self.id = id
            self.type = type
        }
    }

    /// The title of the card.
    public struct SkillCardTitle: Codable {
        /// An optional identifier for the title.
        ///
        /// Example: "status"
        public var code: String?
        /// The actual title to show in the UI.
        ///
        /// Example: "Status"
        public var message: String

        public init(code: String? = nil, message: String) {
            self.code = code
            self.message = message
        }
    }

    /// `status`
    ///
    /// Example: "status"
    public enum SkillCardType: String, Codable, CaseIterable {
        case status
    }

    /// Sets the status of the skill. This can be used to show a message to the user while the Skill is processing the data, or if it was not able to process the file.
    public struct Status: Codable {
        /// A code for the status of this Skill invocation. By
        /// default each of these will have their own accompanied
        /// messages. These can be adjusted by setting the `message`
        /// value on this object.
        ///
        /// Example: "success"
        public var code: Code
        /// A custom message that can be provided with this status.
        /// This will be shown in the web app to the end user.
        ///
        /// Example: "We're preparing to process your file. Please hold on!"
        public var message: String?

        /// A code for the status of this Skill invocation. By
        /// default each of these will have their own accompanied
        /// messages. These can be adjusted by setting the `message`
        /// value on this object.
        ///
        /// Example: "success"
        public enum Code: String, Codable, CaseIterable {
            case invoked
            case processing
            case success
            case transientFailure = "transient_failure"
            case permanentFailure = "permanent_failure"
        }

        public init(code: Code, message: String? = nil) {
            self.code = code
            self.message = message
        }
    }

    /// `skill_card`
    ///
    /// Example: "skill_card"
    public enum `Type`: String, Codable, CaseIterable {
        case skillCard = "skill_card"
    }

    public init(createdAt: Date? = nil, invocation: Invocation, skill: Skill, skillCardTitle: SkillCardTitle? = nil, skillCardType: SkillCardType, status: Status, type: `Type`) {
        self.createdAt = createdAt
        self.invocation = invocation
        self.skill = skill
        self.skillCardTitle = skillCardTitle
        self.skillCardType = skillCardType
        self.status = status
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case invocation
        case skill
        case skillCardTitle = "skill_card_title"
        case skillCardType = "skill_card_type"
        case status
        case type
    }
}

/// A list of storage policies.
public struct StoragePolicies: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The marker for the start of the next page of results.
    ///
    /// Example: 3000
    public var nextMarker: Int?
    /// The marker for the start of the previous page of results.
    ///
    /// Example: 1000
    public var prevMarker: Int?
    public var entries: [StoragePolicy]?

    public init(limit: Int? = nil, nextMarker: Int? = nil, prevMarker: Int? = nil, entries: [StoragePolicy]? = nil) {
        self.limit = limit
        self.nextMarker = nextMarker
        self.prevMarker = prevMarker
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.nextMarker = try values.decodeIfPresent(Int.self, forKey: "next_marker")
        self.prevMarker = try values.decodeIfPresent(Int.self, forKey: "prev_marker")
        self.entries = try values.decodeIfPresent([StoragePolicy].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(nextMarker, forKey: "next_marker")
        try values.encodeIfPresent(prevMarker, forKey: "prev_marker")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// The Storage Policy object describes the storage zone.
public struct StoragePolicy: Codable {
    /// Storage policy (Mini)
    ///
    /// A mini description of a Storage Policy object
    public var storagePolicyMini: StoragePolicyMini
    /// A descriptive name of the region
    ///
    /// Example: "Montreal / Dublin"
    public var name: String?

    public init(storagePolicyMini: StoragePolicyMini, name: String? = nil) {
        self.storagePolicyMini = storagePolicyMini
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.storagePolicyMini = try StoragePolicyMini(from: decoder)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(storagePolicyMini, forKey: "storagePolicyMini")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

/// Storage policy (Mini)
///
/// A mini description of a Storage Policy object
public struct StoragePolicyMini: Codable {
    /// The unique identifier for this storage policy
    ///
    /// Example: "11446498"
    public var id: String?
    /// `storage_policy`
    ///
    /// Example: "storage_policy"
    public var type: `Type`?

    /// `storage_policy`
    ///
    /// Example: "storage_policy"
    public enum `Type`: String, Codable, CaseIterable {
        case storagePolicy = "storage_policy"
    }

    public init(id: String? = nil, type: `Type`? = nil) {
        self.id = id
        self.type = type
    }
}

/// The assignment of a storage policy to a user or enterprise
public struct StoragePolicyAssignment: Codable {
    public var assignedTo: AssignedTo?
    public var storagePolicy: StoragePolicy?

    public struct AssignedTo: Codable {
        /// The unique identifier for this object
        ///
        /// Example: "11446498"
        public var id: String?
        /// The type for this object
        ///
        /// Example: "file"
        public var type: String?
        /// The enterprise or use the policy is assigned to
        public var anyJSON: AnyJSON

        public init(id: String? = nil, type: String? = nil, anyJSON: AnyJSON) {
            self.id = id
            self.type = type
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.type = try values.decodeIfPresent(String.self, forKey: "type")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(type, forKey: "type")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct StoragePolicy: Codable {
        /// Storage policy (Mini)
        ///
        /// A mini description of a Storage Policy object
        public var storagePolicyMini: StoragePolicyMini
        /// The assigned storage policy
        public var anyJSON: AnyJSON

        public init(storagePolicyMini: StoragePolicyMini, anyJSON: AnyJSON) {
            self.storagePolicyMini = storagePolicyMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.storagePolicyMini = try StoragePolicyMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(storagePolicyMini, forKey: "storagePolicyMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(assignedTo: AssignedTo? = nil, storagePolicy: StoragePolicy? = nil) {
        self.assignedTo = assignedTo
        self.storagePolicy = storagePolicy
    }

    private enum CodingKeys: String, CodingKey {
        case assignedTo = "assigned_to"
        case storagePolicy = "storage_policy"
    }
}

/// A list of storage policy assignments.
public struct StoragePolicyAssignments: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The marker for the start of the next page of results.
    ///
    /// Example: 3000
    public var nextMarker: Int?
    /// The marker for the start of the previous page of results.
    ///
    /// Example: 1000
    public var prevMarker: Int?
    public var entries: [StoragePolicyAssignment]?

    public init(limit: Int? = nil, nextMarker: Int? = nil, prevMarker: Int? = nil, entries: [StoragePolicyAssignment]? = nil) {
        self.limit = limit
        self.nextMarker = nextMarker
        self.prevMarker = prevMarker
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.nextMarker = try values.decodeIfPresent(Int.self, forKey: "next_marker")
        self.prevMarker = try values.decodeIfPresent(Int.self, forKey: "prev_marker")
        self.entries = try values.decodeIfPresent([StoragePolicyAssignment].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(nextMarker, forKey: "next_marker")
        try values.encodeIfPresent(prevMarker, forKey: "prev_marker")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// A task allows for file-centric workflows within Box. Users can
/// create tasks on files and assign them to other users for them to complete the
/// tasks.
public struct Task: Codable {
    /// The type of task the task assignee will be prompted to
    /// perform.
    ///
    /// Example: "review"
    public var action: Action?
    /// Defines which assignees need to complete this task before the task
    /// is considered completed.
    /// 
    /// * `all_assignees` requires all assignees to review or
    /// approve the the task in order for it to be considered completed.
    /// * `any_assignee` accepts any one assignee to review or
    /// approve the the task in order for it to be considered completed.
    ///
    /// Example: "all_assignees"
    public var completionRule: CompletionRule?
    /// When the task object was created
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var createdAt: Date?
    public var createdBy: CreatedBy?
    /// When the task is due
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var dueAt: Date?
    /// The unique identifier for this task
    ///
    /// Example: "11446498"
    public var id: String?
    /// Whether the task has been completed
    ///
    /// Example: true
    public var isCompleted: Bool?
    public var item: Item?
    /// A message that will be included with the task
    ///
    /// Example: "Legal review"
    public var message: String?
    public var taskAssignmentCollection: TaskAssignmentCollection?
    /// `task`
    ///
    /// Example: "task"
    public var type: `Type`?

    /// The type of task the task assignee will be prompted to
    /// perform.
    ///
    /// Example: "review"
    public enum Action: String, Codable, CaseIterable {
        case review
        case complete
    }

    /// Defines which assignees need to complete this task before the task
    /// is considered completed.
    /// 
    /// * `all_assignees` requires all assignees to review or
    /// approve the the task in order for it to be considered completed.
    /// * `any_assignee` accepts any one assignee to review or
    /// approve the the task in order for it to be considered completed.
    ///
    /// Example: "all_assignees"
    public enum CompletionRule: String, Codable, CaseIterable {
        case allAssignees = "all_assignees"
        case anyAssignee = "any_assignee"
    }

    public struct CreatedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user who created the task
        public var anyJSON: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Item: Codable {
        /// File (Mini)
        ///
        /// A mini representation of a file, used when
        /// nested under another resource.
        public var fileMini: FileMini
        /// The file associated with the task
        public var anyJSON: AnyJSON

        public init(fileMini: FileMini, anyJSON: AnyJSON) {
            self.fileMini = fileMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.fileMini = try FileMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(fileMini, forKey: "fileMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct TaskAssignmentCollection: Codable {
        /// A list of task assignments
        public var taskAssignments: TaskAssignments
        /// A collection of task assignment objects
        /// associated with the task
        public var anyJSON: AnyJSON

        public init(taskAssignments: TaskAssignments, anyJSON: AnyJSON) {
            self.taskAssignments = taskAssignments
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.taskAssignments = try TaskAssignments(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(taskAssignments, forKey: "taskAssignments")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// `task`
    ///
    /// Example: "task"
    public enum `Type`: String, Codable, CaseIterable {
        case task
    }

    public init(action: Action? = nil, completionRule: CompletionRule? = nil, createdAt: Date? = nil, createdBy: CreatedBy? = nil, dueAt: Date? = nil, id: String? = nil, isCompleted: Bool? = nil, item: Item? = nil, message: String? = nil, taskAssignmentCollection: TaskAssignmentCollection? = nil, type: `Type`? = nil) {
        self.action = action
        self.completionRule = completionRule
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.dueAt = dueAt
        self.id = id
        self.isCompleted = isCompleted
        self.item = item
        self.message = message
        self.taskAssignmentCollection = taskAssignmentCollection
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case action
        case completionRule = "completion_rule"
        case createdAt = "created_at"
        case createdBy = "created_by"
        case dueAt = "due_at"
        case id
        case isCompleted = "is_completed"
        case item
        case message
        case taskAssignmentCollection = "task_assignment_collection"
        case type
    }
}

/// A task assignment defines which task is assigned to which user to complete.
public struct TaskAssignment: Codable {
    /// The date at which this task was assigned to the user.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var assignedAt: Date?
    public var assignedBy: AssignedBy?
    public var assignedTo: AssignedTo?
    /// The date at which this task assignment was
    /// completed. This will be `null` if the task is not completed yet.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var completedAt: Date?
    /// The unique identifier for this task assignment
    ///
    /// Example: "11446498"
    public var id: String?
    public var item: Item?
    /// A message that will is included with the task
    /// assignment. This is visible to the assigned user in the web and mobile
    /// UI.
    ///
    /// Example: "Please review"
    public var message: String?
    /// The date at which the assigned user was reminded of this task
    /// assignment.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var remindedAt: Date?
    /// The current state of the assignment. The available states depend on
    /// the `action` value of the task object.
    ///
    /// Example: "incomplete"
    public var resolutionState: ResolutionState?
    /// `task_assignment`
    ///
    /// Example: "task_assignment"
    public var type: `Type`?

    public struct AssignedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user who assigned this task.
        public var anyJSON: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AssignedTo: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user that the task has been assigned to.
        public var anyJSON: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Item: Codable {
        /// File (Mini)
        ///
        /// A mini representation of a file, used when
        /// nested under another resource.
        public var fileMini: FileMini
        /// The file that the task has been assigned to.
        public var anyJSON: AnyJSON

        public init(fileMini: FileMini, anyJSON: AnyJSON) {
            self.fileMini = fileMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.fileMini = try FileMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(fileMini, forKey: "fileMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// The current state of the assignment. The available states depend on
    /// the `action` value of the task object.
    ///
    /// Example: "incomplete"
    public enum ResolutionState: String, Codable, CaseIterable {
        case completed
        case incomplete
        case approved
        case rejected
    }

    /// `task_assignment`
    ///
    /// Example: "task_assignment"
    public enum `Type`: String, Codable, CaseIterable {
        case taskAssignment = "task_assignment"
    }

    public init(assignedAt: Date? = nil, assignedBy: AssignedBy? = nil, assignedTo: AssignedTo? = nil, completedAt: Date? = nil, id: String? = nil, item: Item? = nil, message: String? = nil, remindedAt: Date? = nil, resolutionState: ResolutionState? = nil, type: `Type`? = nil) {
        self.assignedAt = assignedAt
        self.assignedBy = assignedBy
        self.assignedTo = assignedTo
        self.completedAt = completedAt
        self.id = id
        self.item = item
        self.message = message
        self.remindedAt = remindedAt
        self.resolutionState = resolutionState
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case assignedAt = "assigned_at"
        case assignedBy = "assigned_by"
        case assignedTo = "assigned_to"
        case completedAt = "completed_at"
        case id
        case item
        case message
        case remindedAt = "reminded_at"
        case resolutionState = "resolution_state"
        case type
    }
}

/// A list of task assignments
public struct TaskAssignments: Codable {
    public var entries: [TaskAssignment]?
    /// The total number of items in this collection.
    ///
    /// Example: 100
    public var totalCount: Int?

    public init(entries: [TaskAssignment]? = nil, totalCount: Int? = nil) {
        self.entries = entries
        self.totalCount = totalCount
    }

    private enum CodingKeys: String, CodingKey {
        case entries
        case totalCount = "total_count"
    }
}

/// A list of tasks
public struct Tasks: Codable {
    public var entries: [Task]?
    /// One greater than the offset of the last entry in the entire collection.
    /// The total number of entries in the collection may be less than
    /// `total_count`.
    ///
    /// Example: 5000
    public var totalCount: Int?

    public init(entries: [Task]? = nil, totalCount: Int? = nil) {
        self.entries = entries
        self.totalCount = totalCount
    }

    private enum CodingKeys: String, CodingKey {
        case entries
        case totalCount = "total_count"
    }
}

/// The root-level record that is supposed to represent a
/// single Terms of Service.
public struct TermsOfService: Codable {
    /// Terms of service (Mini)
    ///
    /// The root-level record that is supposed to represent a
    /// single Terms of Service.
    public var termsOfServiceMini: TermsOfServiceMini
    /// When the legal item was created
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var createdAt: Date?
    public var enterprise: Enterprise?
    /// When the legal item was modified.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var modifiedAt: Date?
    /// Whether these terms are enabled or not
    ///
    /// Example: "enabled"
    public var status: Status?
    /// The text for your terms and conditions. This text could be
    /// empty if the `status` is set to `disabled`.
    ///
    /// Example: "By using this service, you agree to ..."
    public var text: String?
    /// Whether to apply these terms to managed users or external users
    ///
    /// Example: "managed"
    public var tosType: TosType?

    public struct Enterprise: Codable {
        /// The unique identifier for this enterprise.
        ///
        /// Example: "11446498"
        public var id: String?
        /// The name of the enterprise
        ///
        /// Example: "Acme Inc."
        public var name: String?
        /// `enterprise`
        ///
        /// Example: "enterprise"
        public var type: `Type`?
        /// The enterprise these terms apply to
        public var anyJSON: AnyJSON

        /// `enterprise`
        ///
        /// Example: "enterprise"
        public enum `Type`: String, Codable, CaseIterable {
            case enterprise
        }

        public init(id: String? = nil, name: String? = nil, type: `Type`? = nil, anyJSON: AnyJSON) {
            self.id = id
            self.name = name
            self.type = type
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.type = try `Type`(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(type, forKey: "type")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// Whether these terms are enabled or not
    ///
    /// Example: "enabled"
    public enum Status: String, Codable, CaseIterable {
        case enabled
        case disabled
    }

    /// Whether to apply these terms to managed users or external users
    ///
    /// Example: "managed"
    public enum TosType: String, Codable, CaseIterable {
        case managed
        case external
    }

    public init(termsOfServiceMini: TermsOfServiceMini, createdAt: Date? = nil, enterprise: Enterprise? = nil, modifiedAt: Date? = nil, status: Status? = nil, text: String? = nil, tosType: TosType? = nil) {
        self.termsOfServiceMini = termsOfServiceMini
        self.createdAt = createdAt
        self.enterprise = enterprise
        self.modifiedAt = modifiedAt
        self.status = status
        self.text = text
        self.tosType = tosType
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.termsOfServiceMini = try TermsOfServiceMini(from: decoder)
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
        self.enterprise = try Enterprise(from: decoder)
        self.modifiedAt = try values.decodeIfPresent(Date.self, forKey: "modified_at")
        self.status = try Status(from: decoder)
        self.text = try values.decodeIfPresent(String.self, forKey: "text")
        self.tosType = try TosType(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(termsOfServiceMini, forKey: "termsOfServiceMini")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(enterprise, forKey: "enterprise")
        try values.encodeIfPresent(modifiedAt, forKey: "modified_at")
        try values.encodeIfPresent(status, forKey: "status")
        try values.encodeIfPresent(text, forKey: "text")
        try values.encodeIfPresent(tosType, forKey: "tos_type")
    }
}

/// Terms of service (Mini)
///
/// The root-level record that is supposed to represent a
/// single Terms of Service.
public struct TermsOfServiceMini: Codable {
    /// The unique identifier for this terms of service.
    ///
    /// Example: "11446498"
    public var id: String?
    /// `terms_of_service`
    ///
    /// Example: "terms_of_service"
    public var type: `Type`?

    /// `terms_of_service`
    ///
    /// Example: "terms_of_service"
    public enum `Type`: String, Codable, CaseIterable {
        case termsOfService = "terms_of_service"
    }

    public init(id: String? = nil, type: `Type`? = nil) {
        self.id = id
        self.type = type
    }
}

/// The association between a Terms of Service and a user
public struct TermsOfServiceUserStatus: Codable {
    /// When the legal item was created
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var createdAt: Date?
    /// The unique identifier for this terms of service user status
    ///
    /// Example: "11446498"
    public var id: String?
    /// If the user has accepted the terms of services
    ///
    /// Example: true
    public var isAccepted: Bool?
    /// When the legal item was modified.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var modifiedAt: Date?
    public var tos: Tos?
    /// `terms_of_service_user_status`
    ///
    /// Example: "terms_of_service_user_status"
    public var type: `Type`?
    public var user: User?

    public struct Tos: Codable {
        /// Terms of service (Mini)
        ///
        /// The root-level record that is supposed to represent a
        /// single Terms of Service.
        public var termsOfServiceMini: TermsOfServiceMini
        /// The terms of service
        public var anyJSON: AnyJSON

        public init(termsOfServiceMini: TermsOfServiceMini, anyJSON: AnyJSON) {
            self.termsOfServiceMini = termsOfServiceMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.termsOfServiceMini = try TermsOfServiceMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(termsOfServiceMini, forKey: "termsOfServiceMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// `terms_of_service_user_status`
    ///
    /// Example: "terms_of_service_user_status"
    public enum `Type`: String, Codable, CaseIterable {
        case termsOfServiceUserStatus = "terms_of_service_user_status"
    }

    public struct User: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user
        public var anyJSON: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(createdAt: Date? = nil, id: String? = nil, isAccepted: Bool? = nil, modifiedAt: Date? = nil, tos: Tos? = nil, type: `Type`? = nil, user: User? = nil) {
        self.createdAt = createdAt
        self.id = id
        self.isAccepted = isAccepted
        self.modifiedAt = modifiedAt
        self.tos = tos
        self.type = type
        self.user = user
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case id
        case isAccepted = "is_accepted"
        case modifiedAt = "modified_at"
        case tos
        case type
        case user
    }
}

/// A list of terms of service user statuses
public struct TermsOfServiceUserStatuses: Codable {
    public var entries: [TermsOfServiceUserStatus]?
    /// The total number of objects.
    public var totalCount: Int?

    public init(entries: [TermsOfServiceUserStatus]? = nil, totalCount: Int? = nil) {
        self.entries = entries
        self.totalCount = totalCount
    }

    private enum CodingKeys: String, CodingKey {
        case entries
        case totalCount = "total_count"
    }
}

/// A list of terms of services
public struct TermsOfServices: Codable {
    public var entries: [TermsOfService]?
    /// The total number of objects.
    public var totalCount: Int?

    public init(entries: [TermsOfService]? = nil, totalCount: Int? = nil) {
        self.entries = entries
        self.totalCount = totalCount
    }

    private enum CodingKeys: String, CodingKey {
        case entries
        case totalCount = "total_count"
    }
}

/// A Box Skill metadata card that places a list of images on a
/// timeline.
public struct TimelineSkillCard: Codable {
    /// The optional date and time this card was created at.
    ///
    /// Example: "2018-04-13T13:53:23-07:00"
    public var createdAt: Date?
    /// An total duration in seconds of the timeline.
    ///
    /// Example: 1000
    public var duration: Int?
    /// A list of entries on the timeline.
    public var entries: [Entry]
    /// The invocation of this service, used to track
    /// which instance of a service applied the metadata.
    public var invocation: Invocation
    /// The service that applied this metadata.
    public var skill: Skill
    /// The title of the card.
    public var skillCardTitle: SkillCardTitle?
    /// `timeline`
    ///
    /// Example: "timeline"
    public var skillCardType: SkillCardType
    /// `skill_card`
    ///
    /// Example: "skill_card"
    public var type: `Type`

    /// An single item that's placed on multiple items on the timeline.
    public struct Entry: Codable {
        /// Defines a list of timestamps for when this item should appear on the
        /// timeline.
        public var appears: [Appear]?
        /// The image to show on a for an entry that appears
        /// on a timeline. This image URL is required for every entry.
        /// 
        /// The image will be shown in a
        /// list of items (for example faces), and clicking
        /// the image will show the user where that entry
        /// appears during the duration of this entry.
        ///
        /// Example: "https://example.com/image1.jpg"
        public var imageURL: String?
        /// The text of the entry. This would be the display
        /// name for an item being placed on the timeline, for example the name
        /// of the person who was detected in a video.
        ///
        /// Example: "John"
        public var text: String?

        /// The timestamp for an entry.
        public struct Appear: Codable {
            /// The time in seconds when an
            /// entry should stop appearing on a timeline.
            ///
            /// Example: 20
            public var end: Int?
            /// The time in seconds when an
            /// entry should start appearing on a timeline.
            public var start: Int?

            public init(end: Int? = nil, start: Int? = nil) {
                self.end = end
                self.start = start
            }
        }

        public init(appears: [Appear]? = nil, imageURL: String? = nil, text: String? = nil) {
            self.appears = appears
            self.imageURL = imageURL
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case appears
            case imageURL = "image_url"
            case text
        }
    }

    /// The invocation of this service, used to track
    /// which instance of a service applied the metadata.
    public struct Invocation: Codable {
        /// A custom identifier that represent the instance of
        /// the service that applied this metadata. For example,
        /// if your `image-recognition-service` runs on multiple
        /// nodes, this field can be used to identify the ID of
        /// the node that was used to apply the metadata.
        ///
        /// Example: "image-recognition-service-123"
        public var id: String
        /// `skill_invocation`
        ///
        /// Example: "skill_invocation"
        public var type: `Type`

        /// `skill_invocation`
        ///
        /// Example: "skill_invocation"
        public enum `Type`: String, Codable, CaseIterable {
            case skillInvocation = "skill_invocation"
        }

        public init(id: String, type: `Type`) {
            self.id = id
            self.type = type
        }
    }

    /// The service that applied this metadata.
    public struct Skill: Codable {
        /// A custom identifier that represent the service that
        /// applied this metadata.
        ///
        /// Example: "image-recognition-service"
        public var id: String
        /// `service`
        ///
        /// Example: "service"
        public var type: `Type`

        /// `service`
        ///
        /// Example: "service"
        public enum `Type`: String, Codable, CaseIterable {
            case service
        }

        public init(id: String, type: `Type`) {
            self.id = id
            self.type = type
        }
    }

    /// The title of the card.
    public struct SkillCardTitle: Codable {
        /// An optional identifier for the title.
        ///
        /// Example: "Faces"
        public var code: String?
        /// The actual title to show in the UI.
        ///
        /// Example: "Faces"
        public var message: String

        public init(code: String? = nil, message: String) {
            self.code = code
            self.message = message
        }
    }

    /// `timeline`
    ///
    /// Example: "timeline"
    public enum SkillCardType: String, Codable, CaseIterable {
        case timeline
    }

    /// `skill_card`
    ///
    /// Example: "skill_card"
    public enum `Type`: String, Codable, CaseIterable {
        case skillCard = "skill_card"
    }

    public init(createdAt: Date? = nil, duration: Int? = nil, entries: [Entry], invocation: Invocation, skill: Skill, skillCardTitle: SkillCardTitle? = nil, skillCardType: SkillCardType, type: `Type`) {
        self.createdAt = createdAt
        self.duration = duration
        self.entries = entries
        self.invocation = invocation
        self.skill = skill
        self.skillCardTitle = skillCardTitle
        self.skillCardType = skillCardType
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case duration
        case entries
        case invocation
        case skill
        case skillCardTitle = "skill_card_title"
        case skillCardType = "skill_card_type"
        case type
    }
}

/// A Box Skill metadata card that adds a transcript to a file.
public struct TranscriptSkillCard: Codable {
    /// The optional date and time this card was created at.
    ///
    /// Example: "2018-04-13T13:53:23-07:00"
    public var createdAt: Date?
    /// An optional total duration in seconds.
    /// 
    /// Used with a `skill_card_type` of `transcript` or
    /// `timeline`.
    ///
    /// Example: 1000
    public var duration: Int?
    /// An list of entries for the card. This represents the individual entries of
    /// the transcription.
    public var entries: [Entry]
    /// The invocation of this service, used to track
    /// which instance of a service applied the metadata.
    public var invocation: Invocation
    /// The service that applied this metadata.
    public var skill: Skill
    /// The title of the card.
    public var skillCardTitle: SkillCardTitle?
    /// `transcript`
    ///
    /// Example: "transcript"
    public var skillCardType: SkillCardType
    /// `skill_card`
    ///
    /// Example: "skill_card"
    public var type: `Type`

    /// An entry in the `entries` attribute of a metadata card
    public struct Entry: Codable {
        /// Defines when a transcribed bit of text appears. This only includes a
        /// start time and no end time.
        public var appears: [Appear]?
        /// The text of the entry. This would be the transcribed text assigned
        /// to the entry on the timeline.
        ///
        /// Example: "Hi, and welcome to this video..."
        public var text: String?

        /// The timestamp for an entry.
        public struct Appear: Codable {
            /// The time in seconds when an
            /// entry should start appearing on a timeline.
            public var start: Int?

            public init(start: Int? = nil) {
                self.start = start
            }
        }

        public init(appears: [Appear]? = nil, text: String? = nil) {
            self.appears = appears
            self.text = text
        }
    }

    /// The invocation of this service, used to track
    /// which instance of a service applied the metadata.
    public struct Invocation: Codable {
        /// A custom identifier that represent the instance of
        /// the service that applied this metadata. For example,
        /// if your `image-recognition-service` runs on multiple
        /// nodes, this field can be used to identify the ID of
        /// the node that was used to apply the metadata.
        ///
        /// Example: "transciption-service-123"
        public var id: String
        /// `skill_invocation`
        ///
        /// Example: "skill_invocation"
        public var type: `Type`

        /// `skill_invocation`
        ///
        /// Example: "skill_invocation"
        public enum `Type`: String, Codable, CaseIterable {
            case skillInvocation = "skill_invocation"
        }

        public init(id: String, type: `Type`) {
            self.id = id
            self.type = type
        }
    }

    /// The service that applied this metadata.
    public struct Skill: Codable {
        /// A custom identifier that represent the service that
        /// applied this metadata.
        ///
        /// Example: "transciption-service"
        public var id: String
        /// `service`
        ///
        /// Example: "service"
        public var type: `Type`

        /// `service`
        ///
        /// Example: "service"
        public enum `Type`: String, Codable, CaseIterable {
            case service
        }

        public init(id: String, type: `Type`) {
            self.id = id
            self.type = type
        }
    }

    /// The title of the card.
    public struct SkillCardTitle: Codable {
        /// An optional identifier for the title.
        ///
        /// Example: "my_transcripts"
        public var code: String?
        /// The actual title to show in the UI.
        ///
        /// Example: "My Transcripts"
        public var message: String

        public init(code: String? = nil, message: String) {
            self.code = code
            self.message = message
        }
    }

    /// `transcript`
    ///
    /// Example: "transcript"
    public enum SkillCardType: String, Codable, CaseIterable {
        case transcript
    }

    /// `skill_card`
    ///
    /// Example: "skill_card"
    public enum `Type`: String, Codable, CaseIterable {
        case skillCard = "skill_card"
    }

    public init(createdAt: Date? = nil, duration: Int? = nil, entries: [Entry], invocation: Invocation, skill: Skill, skillCardTitle: SkillCardTitle? = nil, skillCardType: SkillCardType, type: `Type`) {
        self.createdAt = createdAt
        self.duration = duration
        self.entries = entries
        self.invocation = invocation
        self.skill = skill
        self.skillCardTitle = skillCardTitle
        self.skillCardType = skillCardType
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case duration
        case entries
        case invocation
        case skill
        case skillCardTitle = "skill_card_title"
        case skillCardType = "skill_card_type"
        case type
    }
}

/// The representation of an upload
/// session chunk.
public struct UploadPart: Codable {
    /// Upload part (Mini)
    ///
    /// The basic representation of an upload
    /// session chunk.
    public var uploadPartMini: UploadPartMini
    /// The SHA1 hash of the chunk.
    ///
    /// Example: "134b65991ed521fcfe4724b7d814ab8ded5185dc"
    public var sha1: String?

    public init(uploadPartMini: UploadPartMini, sha1: String? = nil) {
        self.uploadPartMini = uploadPartMini
        self.sha1 = sha1
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.uploadPartMini = try UploadPartMini(from: decoder)
        self.sha1 = try values.decodeIfPresent(String.self, forKey: "sha1")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(uploadPartMini, forKey: "uploadPartMini")
        try values.encodeIfPresent(sha1, forKey: "sha1")
    }
}

/// Upload part (Mini)
///
/// The basic representation of an upload
/// session chunk.
public struct UploadPartMini: Codable {
    /// The offset of the chunk within the file
    /// in bytes. The lower bound of the position
    /// of the chunk within the file.
    ///
    /// Example: 16777216
    public var offset: Int?
    /// The unique ID of the chunk.
    ///
    /// Example: "6F2D3486"
    public var partID: String?
    /// The size of the chunk in bytes.
    ///
    /// Example: 3222784
    public var size: Int?

    public init(offset: Int? = nil, partID: String? = nil, size: Int? = nil) {
        self.offset = offset
        self.partID = partID
        self.size = size
    }

    private enum CodingKeys: String, CodingKey {
        case offset
        case partID = "part_id"
        case size
    }
}

/// A list of uploaded chunks for an upload
/// session.
public struct UploadParts: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The 0-based offset of the first entry in this set. This will be the same
    /// as the `offset` query parameter.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    ///
    /// Example: 2000
    public var offset: Int?
    /// The order by which items are returned.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    public var order: [OrderItem]?
    /// One greater than the offset of the last entry in the entire collection.
    /// The total number of entries in the collection may be less than
    /// `total_count`.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    ///
    /// Example: 5000
    public var totalCount: Int?
    public var entries: [UploadPart]?

    /// The order in which a pagination is ordered
    public struct OrderItem: Codable {
        /// The field to order by
        ///
        /// Example: "type"
        public var by: String?
        /// The direction to order by, either ascending or descending
        ///
        /// Example: "ASC"
        public var direction: Direction?

        /// The direction to order by, either ascending or descending
        ///
        /// Example: "ASC"
        public enum Direction: String, Codable, CaseIterable {
            case asc = "ASC"
            case desc = "DESC"
        }

        public init(by: String? = nil, direction: Direction? = nil) {
            self.by = by
            self.direction = direction
        }
    }

    public init(limit: Int? = nil, offset: Int? = nil, order: [OrderItem]? = nil, totalCount: Int? = nil, entries: [UploadPart]? = nil) {
        self.limit = limit
        self.offset = offset
        self.order = order
        self.totalCount = totalCount
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.offset = try values.decodeIfPresent(Int.self, forKey: "offset")
        self.order = try values.decodeIfPresent([OrderItem].self, forKey: "order")
        self.totalCount = try values.decodeIfPresent(Int.self, forKey: "total_count")
        self.entries = try values.decodeIfPresent([UploadPart].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(offset, forKey: "offset")
        try values.encodeIfPresent(order, forKey: "order")
        try values.encodeIfPresent(totalCount, forKey: "total_count")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// An upload session for chunk uploading a file.
public struct UploadSession: Codable {
    /// The unique identifier for this session
    ///
    /// Example: "F971964745A5CD0C001BBE4E58196BFD"
    public var id: String?
    /// The number of parts that have been uploaded and processed
    /// by the server. This starts at `0`.
    /// 
    /// When committing a file files, inspecting this property can
    /// provide insight if all parts have been uploaded correctly.
    ///
    /// Example: 455
    public var numPartsProcessed: Int?
    /// The  size in bytes that must be used for all parts of of the
    /// upload.
    /// 
    /// Only the last part is allowed to be of a smaller size.
    ///
    /// Example: 1024
    public var partSize: Int?
    public var sessionEndpoints: SessionEndpoints?
    /// The date and time when this session expires.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var sessionExpiresAt: Date?
    /// The total number of parts expected in this upload session,
    /// as determined by the file size and part size.
    ///
    /// Example: 1000
    public var totalParts: Int?
    /// `upload_session`
    ///
    /// Example: "upload_session"
    public var type: `Type`?

    public struct SessionEndpoints: Codable {
        /// The URL for used to abort the session.
        ///
        /// Example: "https://upload.box.com/api/2.0/files/upload_sessions/F971964745A5CD0C001BBE4E58196BFD"
        public var abort: String?
        /// The URL used to commit the file
        ///
        /// Example: "https://upload.box.com/api/2.0/files/upload_sessions/F971964745A5CD0C001BBE4E58196BFD/commit"
        public var commit: String?
        /// The URL users to list all parts.
        ///
        /// Example: "https://upload.box.com/api/2.0/files/upload_sessions/F971964745A5CD0C001BBE4E58196BFD/parts"
        public var listParts: String?
        /// The URL used to get the upload log from.
        ///
        /// Example: "https://upload.box.com/api/2.0/files/upload_sessions/F971964745A5CD0C001BBE4E58196BFD/log"
        public var logEvent: String?
        /// The URL used to get the status of the upload.
        ///
        /// Example: "https://upload.box.com/api/2.0/files/upload_sessions/F971964745A5CD0C001BBE4E58196BFD"
        public var status: String?
        /// The URL to upload parts to
        ///
        /// Example: "https://upload.box.com/api/2.0/files/upload_sessions/F971964745A5CD0C001BBE4E58196BFD"
        public var uploadPart: String?
        /// A list of endpoints for this session.
        public var anyJSON: AnyJSON

        public init(abort: String? = nil, commit: String? = nil, listParts: String? = nil, logEvent: String? = nil, status: String? = nil, uploadPart: String? = nil, anyJSON: AnyJSON) {
            self.abort = abort
            self.commit = commit
            self.listParts = listParts
            self.logEvent = logEvent
            self.status = status
            self.uploadPart = uploadPart
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.abort = try values.decodeIfPresent(String.self, forKey: "abort")
            self.commit = try values.decodeIfPresent(String.self, forKey: "commit")
            self.listParts = try values.decodeIfPresent(String.self, forKey: "list_parts")
            self.logEvent = try values.decodeIfPresent(String.self, forKey: "log_event")
            self.status = try values.decodeIfPresent(String.self, forKey: "status")
            self.uploadPart = try values.decodeIfPresent(String.self, forKey: "upload_part")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(abort, forKey: "abort")
            try values.encodeIfPresent(commit, forKey: "commit")
            try values.encodeIfPresent(listParts, forKey: "list_parts")
            try values.encodeIfPresent(logEvent, forKey: "log_event")
            try values.encodeIfPresent(status, forKey: "status")
            try values.encodeIfPresent(uploadPart, forKey: "upload_part")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// `upload_session`
    ///
    /// Example: "upload_session"
    public enum `Type`: String, Codable, CaseIterable {
        case uploadSession = "upload_session"
    }

    public init(id: String? = nil, numPartsProcessed: Int? = nil, partSize: Int? = nil, sessionEndpoints: SessionEndpoints? = nil, sessionExpiresAt: Date? = nil, totalParts: Int? = nil, type: `Type`? = nil) {
        self.id = id
        self.numPartsProcessed = numPartsProcessed
        self.partSize = partSize
        self.sessionEndpoints = sessionEndpoints
        self.sessionExpiresAt = sessionExpiresAt
        self.totalParts = totalParts
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case numPartsProcessed = "num_parts_processed"
        case partSize = "part_size"
        case sessionEndpoints = "session_endpoints"
        case sessionExpiresAt = "session_expires_at"
        case totalParts = "total_parts"
        case type
    }
}

/// The details for the upload session for the file.
public struct UploadURL: Codable {
    /// An optional access token to use to upload the file
    ///
    /// Example: "Pc3FIOG9vSGV4VHo4QzAyg5T1JvNnJoZ3ExaVNyQWw6WjRsanRKZG5lQk9qUE1BVQP"
    public var uploadToken: String?
    /// A URL for an upload session that can be used to upload
    /// the file.
    ///
    /// Example: "https://upload-las.app.box.com/api/2.0/files/content?upload_session_id=1234"
    public var uploadURL: String?

    public init(uploadToken: String? = nil, uploadURL: String? = nil) {
        self.uploadToken = uploadToken
        self.uploadURL = uploadURL
    }

    private enum CodingKeys: String, CodingKey {
        case uploadToken = "upload_token"
        case uploadURL = "upload_url"
    }
}

/// A chunk of a file uploaded as part of
/// an upload session, as returned by some endpoints.
public struct UploadedPart: Codable {
    /// Upload part
    ///
    /// The representation of an upload
    /// session chunk.
    public var part: UploadPart?

    public init(part: UploadPart? = nil) {
        self.part = part
    }
}

/// A standard representation of a user, as returned from any
/// user API endpoints by default
public struct User: Codable {
    /// User (Mini)
    ///
    /// A mini representation of a user, as can be returned when nested within other
    /// resources.
    public var userMini: UserMini
    /// The userâ€™s address
    ///
    /// Example: "900 Jefferson Ave, Redwood City, CA 94063"
    public var address: String?
    /// URL of the userâ€™s avatar image
    ///
    /// Example: "https://www.box.com/api/avatar/large/181216415"
    public var avatarURL: String?
    /// When the user object was created
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var createdAt: Date?
    /// The userâ€™s job title
    ///
    /// Example: "CEO"
    public var jobTitle: String?
    /// The language of the user, formatted in modified version of the
    /// [ISO 639-1](/guides/api-calls/language-codes) format.
    ///
    /// Example: "en"
    public var language: String?
    /// The maximum individual file size in bytes the user can have
    ///
    /// Example: 2147483648
    public var maxUploadSize: Int?
    /// When the user object was last modified
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var modifiedAt: Date?
    /// An alternate notification email address to which email
    /// notifications are sent. When it's confirmed, this will be
    /// the email address to which notifications are sent instead of
    /// to the primary email address.
    public var notificationEmail: NotificationEmail?
    /// The userâ€™s phone number
    ///
    /// Example: "6509241374"
    public var phone: String?
    /// The userâ€™s total available space amount in bytes
    ///
    /// Example: 11345156112
    public var spaceAmount: Int?
    /// The amount of space in use by the user
    ///
    /// Example: 1237009912
    public var spaceUsed: Int?
    /// The user's account status
    ///
    /// Example: "active"
    public var status: Status?
    /// The user's timezone
    ///
    /// Example: "Africa/Bujumbura"
    public var timezone: String?

    /// An alternate notification email address to which email
    /// notifications are sent. When it's confirmed, this will be
    /// the email address to which notifications are sent instead of
    /// to the primary email address.
    public struct NotificationEmail: Codable {
        /// The email address to send the notifications to.
        ///
        /// Example: "notifications@example.com"
        public var email: String?
        /// Specifies if this email address has been confirmed.
        ///
        /// Example: true
        public var isConfirmed: Bool?

        public init(email: String? = nil, isConfirmed: Bool? = nil) {
            self.email = email
            self.isConfirmed = isConfirmed
        }

        private enum CodingKeys: String, CodingKey {
            case email
            case isConfirmed = "is_confirmed"
        }
    }

    /// The user's account status
    ///
    /// Example: "active"
    public enum Status: String, Codable, CaseIterable {
        case active
        case inactive
        case cannotDeleteEdit = "cannot_delete_edit"
        case cannotDeleteEditUpload = "cannot_delete_edit_upload"
    }

    public init(userMini: UserMini, address: String? = nil, avatarURL: String? = nil, createdAt: Date? = nil, jobTitle: String? = nil, language: String? = nil, maxUploadSize: Int? = nil, modifiedAt: Date? = nil, notificationEmail: NotificationEmail? = nil, phone: String? = nil, spaceAmount: Int? = nil, spaceUsed: Int? = nil, status: Status? = nil, timezone: String? = nil) {
        self.userMini = userMini
        self.address = address
        self.avatarURL = avatarURL
        self.createdAt = createdAt
        self.jobTitle = jobTitle
        self.language = language
        self.maxUploadSize = maxUploadSize
        self.modifiedAt = modifiedAt
        self.notificationEmail = notificationEmail
        self.phone = phone
        self.spaceAmount = spaceAmount
        self.spaceUsed = spaceUsed
        self.status = status
        self.timezone = timezone
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.userMini = try UserMini(from: decoder)
        self.address = try values.decodeIfPresent(String.self, forKey: "address")
        self.avatarURL = try values.decodeIfPresent(String.self, forKey: "avatar_url")
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
        self.jobTitle = try values.decodeIfPresent(String.self, forKey: "job_title")
        self.language = try values.decodeIfPresent(String.self, forKey: "language")
        self.maxUploadSize = try values.decodeIfPresent(Int.self, forKey: "max_upload_size")
        self.modifiedAt = try values.decodeIfPresent(Date.self, forKey: "modified_at")
        self.notificationEmail = try NotificationEmail(from: decoder)
        self.phone = try values.decodeIfPresent(String.self, forKey: "phone")
        self.spaceAmount = try values.decodeIfPresent(Int.self, forKey: "space_amount")
        self.spaceUsed = try values.decodeIfPresent(Int.self, forKey: "space_used")
        self.status = try Status(from: decoder)
        self.timezone = try values.decodeIfPresent(String.self, forKey: "timezone")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(userMini, forKey: "userMini")
        try values.encodeIfPresent(address, forKey: "address")
        try values.encodeIfPresent(avatarURL, forKey: "avatar_url")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(jobTitle, forKey: "job_title")
        try values.encodeIfPresent(language, forKey: "language")
        try values.encodeIfPresent(maxUploadSize, forKey: "max_upload_size")
        try values.encodeIfPresent(modifiedAt, forKey: "modified_at")
        try values.encodeIfPresent(notificationEmail, forKey: "notification_email")
        try values.encodeIfPresent(phone, forKey: "phone")
        try values.encodeIfPresent(spaceAmount, forKey: "space_amount")
        try values.encodeIfPresent(spaceUsed, forKey: "space_used")
        try values.encodeIfPresent(status, forKey: "status")
        try values.encodeIfPresent(timezone, forKey: "timezone")
    }
}

/// User (Base)
///
/// A mini representation of a user, used when
/// nested within another resource.
public struct UserBase: Codable {
    /// The unique identifier for this user
    ///
    /// Example: "11446498"
    public var id: String?
    /// `user`
    ///
    /// Example: "user"
    public var type: `Type`?

    /// `user`
    ///
    /// Example: "user"
    public enum `Type`: String, Codable, CaseIterable {
        case user
    }

    public init(id: String? = nil, type: `Type`? = nil) {
        self.id = id
        self.type = type
    }
}

/// User (Full)
///
/// A full representation of a user, as can be returned from any
/// user API endpoint.
public struct UserFull: Codable {
    /// A standard representation of a user, as returned from any
    /// user API endpoints by default
    public var user: User
    /// Whether the user can see other enterprise users in their contact list
    ///
    /// Example: true
    public var canSeeManagedUsers: Bool?
    public var enterprise: Enterprise?
    /// An external identifier for an app user, which can be used to look up
    /// the user. This can be used to tie user IDs from external identity
    /// providers to Box users.
    ///
    /// Example: "my-user-1234"
    public var externalAppUserID: String?
    /// The root (protocol, subdomain, domain) of any links that need to be
    /// generated for the user
    ///
    /// Example: "https://example.app.box.com/"
    public var hostname: String?
    /// Whether to exempt the user from Enterprise device limits
    ///
    /// Example: true
    public var isExemptFromDeviceLimits: Bool?
    /// Whether the user must use two-factor authentication
    ///
    /// Example: true
    public var isExemptFromLoginVerification: Bool?
    /// Whether the user is allowed to collaborate with users outside their
    /// enterprise
    ///
    /// Example: true
    public var isExternalCollabRestricted: Bool?
    /// Whether the user is an App User
    ///
    /// Example: true
    public var isPlatformAccessOnly: Bool?
    /// Whether the user can use Box Sync
    ///
    /// Example: true
    public var isSyncEnabled: Bool?
    /// Tags for all files and folders owned by the user. Values returned
    /// will only contain tags that were set by the requester.
    ///
    /// Example: ["important"]
    public var myTags: [String]?
    /// The userâ€™s enterprise role
    ///
    /// Example: "admin"
    public var role: Role?
    /// Tracking codes allow an admin to generate reports from the
    /// admin console and assign an attribute to a specific group
    /// of users. This setting must be enabled for an enterprise
    /// before it can be used.
    public var trackingCodes: [TrackingCode]?

    public struct Enterprise: Codable {
        /// The unique identifier for this enterprise.
        ///
        /// Example: "11446498"
        public var id: String?
        /// The name of the enterprise
        ///
        /// Example: "Acme Inc."
        public var name: String?
        /// `enterprise`
        ///
        /// Example: "enterprise"
        public var type: `Type`?
        /// Representation of the userâ€™s enterprise
        public var anyJSON: AnyJSON

        /// `enterprise`
        ///
        /// Example: "enterprise"
        public enum `Type`: String, Codable, CaseIterable {
            case enterprise
        }

        public init(id: String? = nil, name: String? = nil, type: `Type`? = nil, anyJSON: AnyJSON) {
            self.id = id
            self.name = name
            self.type = type
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.type = try `Type`(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(type, forKey: "type")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// The userâ€™s enterprise role
    ///
    /// Example: "admin"
    public enum Role: String, Codable, CaseIterable {
        case admin
        case coadmin
        case user
    }

    /// Custom tracking code for a user.
    public struct TrackingCode: Codable {
        /// The name of the tracking code, which must be preconfigured in
        /// the Admin Console
        ///
        /// Example: "department"
        public var name: String?
        /// `tracking_code`
        ///
        /// Example: "tracking_code"
        public var type: `Type`?
        /// The value of the tracking code
        ///
        /// Example: "Sales"
        public var value: String?

        /// `tracking_code`
        ///
        /// Example: "tracking_code"
        public enum `Type`: String, Codable, CaseIterable {
            case trackingCode = "tracking_code"
        }

        public init(name: String? = nil, type: `Type`? = nil, value: String? = nil) {
            self.name = name
            self.type = type
            self.value = value
        }
    }

    public init(user: User, canSeeManagedUsers: Bool? = nil, enterprise: Enterprise? = nil, externalAppUserID: String? = nil, hostname: String? = nil, isExemptFromDeviceLimits: Bool? = nil, isExemptFromLoginVerification: Bool? = nil, isExternalCollabRestricted: Bool? = nil, isPlatformAccessOnly: Bool? = nil, isSyncEnabled: Bool? = nil, myTags: [String]? = nil, role: Role? = nil, trackingCodes: [TrackingCode]? = nil) {
        self.user = user
        self.canSeeManagedUsers = canSeeManagedUsers
        self.enterprise = enterprise
        self.externalAppUserID = externalAppUserID
        self.hostname = hostname
        self.isExemptFromDeviceLimits = isExemptFromDeviceLimits
        self.isExemptFromLoginVerification = isExemptFromLoginVerification
        self.isExternalCollabRestricted = isExternalCollabRestricted
        self.isPlatformAccessOnly = isPlatformAccessOnly
        self.isSyncEnabled = isSyncEnabled
        self.myTags = myTags
        self.role = role
        self.trackingCodes = trackingCodes
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.user = try User(from: decoder)
        self.canSeeManagedUsers = try values.decodeIfPresent(Bool.self, forKey: "can_see_managed_users")
        self.enterprise = try Enterprise(from: decoder)
        self.externalAppUserID = try values.decodeIfPresent(String.self, forKey: "external_app_user_id")
        self.hostname = try values.decodeIfPresent(String.self, forKey: "hostname")
        self.isExemptFromDeviceLimits = try values.decodeIfPresent(Bool.self, forKey: "is_exempt_from_device_limits")
        self.isExemptFromLoginVerification = try values.decodeIfPresent(Bool.self, forKey: "is_exempt_from_login_verification")
        self.isExternalCollabRestricted = try values.decodeIfPresent(Bool.self, forKey: "is_external_collab_restricted")
        self.isPlatformAccessOnly = try values.decodeIfPresent(Bool.self, forKey: "is_platform_access_only")
        self.isSyncEnabled = try values.decodeIfPresent(Bool.self, forKey: "is_sync_enabled")
        self.myTags = try values.decodeIfPresent([String].self, forKey: "my_tags")
        self.role = try Role(from: decoder)
        self.trackingCodes = try values.decodeIfPresent([TrackingCode].self, forKey: "tracking_codes")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(user, forKey: "user")
        try values.encodeIfPresent(canSeeManagedUsers, forKey: "can_see_managed_users")
        try values.encodeIfPresent(enterprise, forKey: "enterprise")
        try values.encodeIfPresent(externalAppUserID, forKey: "external_app_user_id")
        try values.encodeIfPresent(hostname, forKey: "hostname")
        try values.encodeIfPresent(isExemptFromDeviceLimits, forKey: "is_exempt_from_device_limits")
        try values.encodeIfPresent(isExemptFromLoginVerification, forKey: "is_exempt_from_login_verification")
        try values.encodeIfPresent(isExternalCollabRestricted, forKey: "is_external_collab_restricted")
        try values.encodeIfPresent(isPlatformAccessOnly, forKey: "is_platform_access_only")
        try values.encodeIfPresent(isSyncEnabled, forKey: "is_sync_enabled")
        try values.encodeIfPresent(myTags, forKey: "my_tags")
        try values.encodeIfPresent(role, forKey: "role")
        try values.encodeIfPresent(trackingCodes, forKey: "tracking_codes")
    }
}

/// User (Mini)
///
/// A mini representation of a user, as can be returned when nested within other
/// resources.
public struct UserMini: Codable {
    /// User (Base)
    ///
    /// A mini representation of a user, used when
    /// nested within another resource.
    public var userBase: UserBase
    /// The primary email address of this user
    ///
    /// Example: "ceo@example.com"
    public var login: String?
    /// The display name of this user
    ///
    /// Example: "Aaron Levie"
    public var name: String?

    public init(userBase: UserBase, login: String? = nil, name: String? = nil) {
        self.userBase = userBase
        self.login = login
        self.name = name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.userBase = try UserBase(from: decoder)
        self.login = try values.decodeIfPresent(String.self, forKey: "login")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(userBase, forKey: "userBase")
        try values.encodeIfPresent(login, forKey: "login")
        try values.encodeIfPresent(name, forKey: "name")
    }
}

/// A list of users.
public struct Users: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The 0-based offset of the first entry in this set. This will be the same
    /// as the `offset` query parameter.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    ///
    /// Example: 2000
    public var offset: Int?
    /// The order by which items are returned.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    public var order: [OrderItem]?
    /// One greater than the offset of the last entry in the entire collection.
    /// The total number of entries in the collection may be less than
    /// `total_count`.
    /// 
    /// This field is only returned for calls that use offset-based pagination.
    /// For marker-based paginated APIs, this field will be omitted.
    ///
    /// Example: 5000
    public var totalCount: Int?
    public var entries: [User]?

    /// The order in which a pagination is ordered
    public struct OrderItem: Codable {
        /// The field to order by
        ///
        /// Example: "type"
        public var by: String?
        /// The direction to order by, either ascending or descending
        ///
        /// Example: "ASC"
        public var direction: Direction?

        /// The direction to order by, either ascending or descending
        ///
        /// Example: "ASC"
        public enum Direction: String, Codable, CaseIterable {
            case asc = "ASC"
            case desc = "DESC"
        }

        public init(by: String? = nil, direction: Direction? = nil) {
            self.by = by
            self.direction = direction
        }
    }

    public init(limit: Int? = nil, offset: Int? = nil, order: [OrderItem]? = nil, totalCount: Int? = nil, entries: [User]? = nil) {
        self.limit = limit
        self.offset = offset
        self.order = order
        self.totalCount = totalCount
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.offset = try values.decodeIfPresent(Int.self, forKey: "offset")
        self.order = try values.decodeIfPresent([OrderItem].self, forKey: "order")
        self.totalCount = try values.decodeIfPresent(Int.self, forKey: "total_count")
        self.entries = try values.decodeIfPresent([User].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(offset, forKey: "offset")
        try values.encodeIfPresent(order, forKey: "order")
        try values.encodeIfPresent(totalCount, forKey: "total_count")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// A watermark is a semi-transparent overlay on an embedded file
/// preview that displays a viewer's email address or user ID
/// and the time of access over a file's content
public struct Watermark: Codable {
    public var watermark: Watermark?

    public struct Watermark: Codable {
        /// When this watermark was created
        ///
        /// Example: "2012-12-12T10:53:43-08:00"
        public var createdAt: Date?
        /// When this task was modified
        ///
        /// Example: "2012-12-12T10:53:43-08:00"
        public var modifiedAt: Date?

        public init(createdAt: Date? = nil, modifiedAt: Date? = nil) {
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "created_at"
            case modifiedAt = "modified_at"
        }
    }

    public init(watermark: Watermark? = nil) {
        self.watermark = watermark
    }
}

/// Web links are objects that point to URLs. These objects
/// are also known as bookmarks within the Box web application.
/// 
/// Web link objects are treated similarly to file objects,
/// they will also support most actions that apply to regular files.
public struct WebLink: Codable {
    /// Web link (Mini)
    ///
    /// Web links are objects that point to URLs. These objects
    /// are also known as bookmarks within the Box web application.
    /// 
    /// Web link objects are treated similarly to file objects,
    /// they will also support most actions that apply to regular files.
    public var webLinkMini: WebLinkMini
    /// When this file was created on Boxâ€™s servers.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var createdAt: Date?
    public var createdBy: CreatedBy?
    /// The description accompanying the web link. This is
    /// visible within the Box web application.
    ///
    /// Example: "Example page"
    public var description: String?
    /// Whether this item is deleted or not. Values include `active`,
    /// `trashed` if the file has been moved to the trash, and `deleted` if
    /// the file has been permanently deleted
    ///
    /// Example: "active"
    public var itemStatus: ItemStatus?
    /// When this file was last updated on the Box
    /// servers.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var modifiedAt: Date?
    public var modifiedBy: ModifiedBy?
    public var ownedBy: OwnedBy?
    public var parent: Parent?
    public var pathCollection: PathCollection?
    /// When this file will be permanently deleted.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var purgedAt: Date?
    public var sharedLink: SharedLink?
    /// When this file was last moved to the trash.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var trashedAt: Date?

    public struct CreatedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user who created this web link
        public var anyJSON: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// Whether this item is deleted or not. Values include `active`,
    /// `trashed` if the file has been moved to the trash, and `deleted` if
    /// the file has been permanently deleted
    ///
    /// Example: "active"
    public enum ItemStatus: String, Codable, CaseIterable {
        case active
        case trashed
        case deleted
    }

    public struct ModifiedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user who last modified this web link
        public var anyJSON: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct OwnedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user who owns this web link
        public var anyJSON: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Parent: Codable {
        /// Folder (Mini)
        ///
        /// A mini representation of a file version, used when
        /// nested under another resource.
        public var folderMini: FolderMini
        /// The parent object the web link belongs to
        public var anyJSON: AnyJSON

        public init(folderMini: FolderMini, anyJSON: AnyJSON) {
            self.folderMini = folderMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.folderMini = try FolderMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(folderMini, forKey: "folderMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct PathCollection: Codable {
        /// The parent folders for this item
        public var entries: [FolderMini]?
        /// The number of folders in this list.
        public var totalCount: Int?
        /// The tree of folders that this web link is contained in,
        /// starting at the root.
        public var anyJSON: AnyJSON
        public var anyJSON2: AnyJSON

        public init(entries: [FolderMini]? = nil, totalCount: Int? = nil, anyJSON: AnyJSON, anyJSON2: AnyJSON) {
            self.entries = entries
            self.totalCount = totalCount
            self.anyJSON = anyJSON
            self.anyJSON2 = anyJSON2
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.entries = try values.decodeIfPresent([FolderMini].self, forKey: "entries")
            self.totalCount = try values.decodeIfPresent(Int.self, forKey: "total_count")
            self.anyJSON = try AnyJSON(from: decoder)
            self.anyJSON2 = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(entries, forKey: "entries")
            try values.encodeIfPresent(totalCount, forKey: "total_count")
            try values.encode(anyJSON, forKey: "anyJSON")
            try values.encode(anyJSON2, forKey: "anyJSON2")
        }
    }

    public struct SharedLink: Codable {
        /// The access level for this shared link.
        /// 
        /// * `open` - provides access to this item to anyone with this link
        /// * `company` - only provides access to this item to people the same company
        /// * `collaborators` - only provides access to this item to people who are
        ///    collaborators on this item
        /// 
        /// If this field is omitted when creating the shared link, the access level
        /// will be set to the default access level specified by the enterprise admin.
        ///
        /// Example: "open"
        public var access: Access?
        /// The number of times this item has been downloaded.
        public var downloadCount: Int?
        /// A URL that can be used to download the file. This URL can be used in
        /// a browser to download the file. This URL includes the file
        /// extension so that the file will be saved with the right file type.
        /// 
        /// This property will be `null` for folders.
        ///
        /// Example: "https://www.box.com/shared/static/rh935iit6ewrmw0unyul.jpeg"
        public var downloadURL: String?
        /// The effective access level for the shared link. This can be a more
        /// restrictive access level than the value in the `access` field when the
        /// enterprise settings restrict the allowed access levels.
        ///
        /// Example: "company"
        public var effectiveAccess: EffectiveAccess?
        /// The effective permissions for this shared link.
        ///
        /// Example: "can_download"
        public var effectivePermission: EffectivePermission?
        /// Defines if the shared link requires a password to access the item.
        ///
        /// Example: true
        public var isPasswordEnabled: Bool?
        /// Defines if this link allows a user to preview and download an item.
        public var permissions: Permissions?
        /// The number of times this item has been previewed.
        public var previewCount: Int?
        /// The date and time when this link will be unshared. This field can only be
        /// set by users with paid accounts.
        ///
        /// Example: "2018-04-13T13:53:23-07:00"
        public var unsharedAt: Date?
        /// The URL that can be used to access the item on Box.
        /// 
        /// This URL will display the item in Box's preview UI where the file
        /// can be downloaded if allowed.
        /// 
        /// This URL will continue to work even when a custom `vanity_url`
        /// has been set for this shared link.
        ///
        /// Example: "https://www.box.com/s/vspke7y05sb214wjokpk"
        public var url: String?
        /// The custom name of a shared link, as used in the `vanity_url` field.
        ///
        /// Example: "my_url"
        public var vanityName: String?
        /// The "Custom URL" that can also be used to preview the item on Box.  Custom
        /// URLs can only be created or modified in the Box Web application.
        ///
        /// Example: "https://acme.app.box.com/v/my_url/"
        public var vanityURL: String?
        /// The shared link object for this item. Will be
        /// `null` if no shared link has been created.
        public var anyJSON: AnyJSON
        public var anyJSON2: AnyJSON?

        /// The access level for this shared link.
        /// 
        /// * `open` - provides access to this item to anyone with this link
        /// * `company` - only provides access to this item to people the same company
        /// * `collaborators` - only provides access to this item to people who are
        ///    collaborators on this item
        /// 
        /// If this field is omitted when creating the shared link, the access level
        /// will be set to the default access level specified by the enterprise admin.
        ///
        /// Example: "open"
        public enum Access: String, Codable, CaseIterable {
            case `open`
            case company
            case collaborators
        }

        /// The effective access level for the shared link. This can be a more
        /// restrictive access level than the value in the `access` field when the
        /// enterprise settings restrict the allowed access levels.
        ///
        /// Example: "company"
        public enum EffectiveAccess: String, Codable, CaseIterable {
            case `open`
            case company
            case collaborators
        }

        /// The effective permissions for this shared link.
        ///
        /// Example: "can_download"
        public enum EffectivePermission: String, Codable, CaseIterable {
            case canDownload = "can_download"
            case canPreview = "can_preview"
        }

        /// Defines if this link allows a user to preview and download an item.
        public struct Permissions: Codable {
            /// Defines if the shared link allows for the item to be downloaded. For
            /// shared links on folders, this also applies to any items in the folder.
            /// 
            /// This value can be set to `true` when the effective access level is
            /// set to `open` or `company`, not `collaborators`.
            ///
            /// Example: true
            public var canDownload: Bool?
            /// Defines if the shared link allows for the item to be previewed.
            /// 
            /// This value is always `true`. For shared links on folders this also
            /// applies to any items in the folder.
            ///
            /// Example: true
            public var canPreview: Bool?

            public init(canDownload: Bool? = nil, canPreview: Bool? = nil) {
                self.canDownload = canDownload
                self.canPreview = canPreview
            }

            private enum CodingKeys: String, CodingKey {
                case canDownload = "can_download"
                case canPreview = "can_preview"
            }
        }

        public init(access: Access? = nil, downloadCount: Int? = nil, downloadURL: String? = nil, effectiveAccess: EffectiveAccess? = nil, effectivePermission: EffectivePermission? = nil, isPasswordEnabled: Bool? = nil, permissions: Permissions? = nil, previewCount: Int? = nil, unsharedAt: Date? = nil, url: String? = nil, vanityName: String? = nil, vanityURL: String? = nil, anyJSON: AnyJSON, anyJSON2: AnyJSON? = nil) {
            self.access = access
            self.downloadCount = downloadCount
            self.downloadURL = downloadURL
            self.effectiveAccess = effectiveAccess
            self.effectivePermission = effectivePermission
            self.isPasswordEnabled = isPasswordEnabled
            self.permissions = permissions
            self.previewCount = previewCount
            self.unsharedAt = unsharedAt
            self.url = url
            self.vanityName = vanityName
            self.vanityURL = vanityURL
            self.anyJSON = anyJSON
            self.anyJSON2 = anyJSON2
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.access = try Access(from: decoder)
            self.downloadCount = try values.decodeIfPresent(Int.self, forKey: "download_count")
            self.downloadURL = try values.decodeIfPresent(String.self, forKey: "download_url")
            self.effectiveAccess = try EffectiveAccess(from: decoder)
            self.effectivePermission = try EffectivePermission(from: decoder)
            self.isPasswordEnabled = try values.decodeIfPresent(Bool.self, forKey: "is_password_enabled")
            self.permissions = try Permissions(from: decoder)
            self.previewCount = try values.decodeIfPresent(Int.self, forKey: "preview_count")
            self.unsharedAt = try values.decodeIfPresent(Date.self, forKey: "unshared_at")
            self.url = try values.decodeIfPresent(String.self, forKey: "url")
            self.vanityName = try values.decodeIfPresent(String.self, forKey: "vanity_name")
            self.vanityURL = try values.decodeIfPresent(String.self, forKey: "vanity_url")
            self.anyJSON = try AnyJSON(from: decoder)
            self.anyJSON2 = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(access, forKey: "access")
            try values.encodeIfPresent(downloadCount, forKey: "download_count")
            try values.encodeIfPresent(downloadURL, forKey: "download_url")
            try values.encodeIfPresent(effectiveAccess, forKey: "effective_access")
            try values.encodeIfPresent(effectivePermission, forKey: "effective_permission")
            try values.encodeIfPresent(isPasswordEnabled, forKey: "is_password_enabled")
            try values.encodeIfPresent(permissions, forKey: "permissions")
            try values.encodeIfPresent(previewCount, forKey: "preview_count")
            try values.encodeIfPresent(unsharedAt, forKey: "unshared_at")
            try values.encodeIfPresent(url, forKey: "url")
            try values.encodeIfPresent(vanityName, forKey: "vanity_name")
            try values.encodeIfPresent(vanityURL, forKey: "vanity_url")
            try values.encode(anyJSON, forKey: "anyJSON")
            try values.encodeIfPresent(anyJSON2, forKey: "anyJSON2")
        }
    }

    public init(webLinkMini: WebLinkMini, createdAt: Date? = nil, createdBy: CreatedBy? = nil, description: String? = nil, itemStatus: ItemStatus? = nil, modifiedAt: Date? = nil, modifiedBy: ModifiedBy? = nil, ownedBy: OwnedBy? = nil, parent: Parent? = nil, pathCollection: PathCollection? = nil, purgedAt: Date? = nil, sharedLink: SharedLink? = nil, trashedAt: Date? = nil) {
        self.webLinkMini = webLinkMini
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.itemStatus = itemStatus
        self.modifiedAt = modifiedAt
        self.modifiedBy = modifiedBy
        self.ownedBy = ownedBy
        self.parent = parent
        self.pathCollection = pathCollection
        self.purgedAt = purgedAt
        self.sharedLink = sharedLink
        self.trashedAt = trashedAt
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.webLinkMini = try WebLinkMini(from: decoder)
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
        self.createdBy = try CreatedBy(from: decoder)
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.itemStatus = try ItemStatus(from: decoder)
        self.modifiedAt = try values.decodeIfPresent(Date.self, forKey: "modified_at")
        self.modifiedBy = try ModifiedBy(from: decoder)
        self.ownedBy = try OwnedBy(from: decoder)
        self.parent = try Parent(from: decoder)
        self.pathCollection = try PathCollection(from: decoder)
        self.purgedAt = try values.decodeIfPresent(Date.self, forKey: "purged_at")
        self.sharedLink = try SharedLink(from: decoder)
        self.trashedAt = try values.decodeIfPresent(Date.self, forKey: "trashed_at")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(webLinkMini, forKey: "webLinkMini")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(createdBy, forKey: "created_by")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(itemStatus, forKey: "item_status")
        try values.encodeIfPresent(modifiedAt, forKey: "modified_at")
        try values.encodeIfPresent(modifiedBy, forKey: "modified_by")
        try values.encodeIfPresent(ownedBy, forKey: "owned_by")
        try values.encodeIfPresent(parent, forKey: "parent")
        try values.encodeIfPresent(pathCollection, forKey: "path_collection")
        try values.encodeIfPresent(purgedAt, forKey: "purged_at")
        try values.encodeIfPresent(sharedLink, forKey: "shared_link")
        try values.encodeIfPresent(trashedAt, forKey: "trashed_at")
    }
}

/// Web link (Base)
///
/// Web links are objects that point to URLs. These objects
/// are also known as bookmarks within the Box web application.
/// 
/// Web link objects are treated similarly to file objects,
/// they will also support most actions that apply to regular files.
public struct WebLinkBase: Codable {
    /// The entity tag of this web link. Used with `If-Match`
    /// headers.
    ///
    /// Example: "1"
    public var etag: String?
    /// The unique identifier for this web link
    ///
    /// Example: "11446498"
    public var id: String?
    /// `web_link`
    ///
    /// Example: "web_link"
    public var type: `Type`?

    /// `web_link`
    ///
    /// Example: "web_link"
    public enum `Type`: String, Codable, CaseIterable {
        case webLink = "web_link"
    }

    public init(etag: String? = nil, id: String? = nil, type: `Type`? = nil) {
        self.etag = etag
        self.id = id
        self.type = type
    }
}

/// Web link (Mini)
///
/// Web links are objects that point to URLs. These objects
/// are also known as bookmarks within the Box web application.
/// 
/// Web link objects are treated similarly to file objects,
/// they will also support most actions that apply to regular files.
public struct WebLinkMini: Codable {
    /// Web link (Base)
    ///
    /// Web links are objects that point to URLs. These objects
    /// are also known as bookmarks within the Box web application.
    /// 
    /// Web link objects are treated similarly to file objects,
    /// they will also support most actions that apply to regular files.
    public var webLinkBase: WebLinkBase
    /// The name of the web link
    ///
    /// Example: "My Bookmark"
    public var name: String?
    public var sequenceID: SequenceID?
    /// The URL this web link points to
    ///
    /// Example: "https://www.example.com/example/1234"
    public var url: String?

    public struct SequenceID: Codable {
        /// A numeric identifier that represents the most recent user event
        /// that has been applied to this item.
        /// 
        /// This can be used in combination with the `GET /events`-endpoint
        /// to filter out user events that would have occurred before this
        /// identifier was read.
        /// 
        /// An example would be where a Box Drive-like application
        /// would fetch an item via the API, and then listen to incoming
        /// user events for changes to the item. The application would
        /// ignore any user events where the `sequence_id` in the event
        /// is smaller than or equal to the `sequence_id` in the originally
        /// fetched resource.
        ///
        /// Example: "3"
        public var string: String
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(webLinkBase: WebLinkBase, name: String? = nil, sequenceID: SequenceID? = nil, url: String? = nil) {
        self.webLinkBase = webLinkBase
        self.name = name
        self.sequenceID = sequenceID
        self.url = url
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.webLinkBase = try WebLinkBase(from: decoder)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.sequenceID = try SequenceID(from: decoder)
        self.url = try values.decodeIfPresent(String.self, forKey: "url")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(webLinkBase, forKey: "webLinkBase")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(sequenceID, forKey: "sequence_id")
        try values.encodeIfPresent(url, forKey: "url")
    }
}

/// Represents a configured webhook.
public struct Webhook: Codable {
    /// The URL that is notified by this webhook
    ///
    /// Example: "https://example.com/webhooks"
    public var address: String?
    /// A timestamp identifying the time that
    /// the webhook was created.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var createdAt: Date?
    public var createdBy: CreatedBy?
    /// The unique identifier for this webhook.
    ///
    /// Example: "11446498"
    public var id: String?
    /// The item that will trigger the webhook
    public var target: Target?
    /// An array of event names that this webhook is
    /// to be triggered for
    ///
    /// Example: ["FILE.UPLOADED"]
    public var triggers: [Trigger]?
    /// `webhook`
    ///
    /// Example: "webhook"
    public var type: `Type`?

    public struct CreatedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user who created the webhook
        public var anyJSON: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// The item that will trigger the webhook
    public struct Target: Codable {
        /// The ID of the item to trigger a webhook
        ///
        /// Example: "1231232"
        public var id: String?
        /// The type of item to trigger a webhook
        ///
        /// Example: "file"
        public var type: `Type`?

        /// The type of item to trigger a webhook
        ///
        /// Example: "file"
        public enum `Type`: String, Codable, CaseIterable {
            case file
            case folder
        }

        public init(id: String? = nil, type: `Type`? = nil) {
            self.id = id
            self.type = type
        }
    }

    /// Webhook Trigger
    ///
    /// The event name that triggered this webhook
    ///
    /// Example: "FILE.UPLOADED"
    public enum Trigger: String, Codable, CaseIterable {
        case fileUploaded = "FILE.UPLOADED"
        case filePreviewed = "FILE.PREVIEWED"
        case fileDownloaded = "FILE.DOWNLOADED"
        case fileTrashed = "FILE.TRASHED"
        case fileDeleted = "FILE.DELETED"
        case fileRestored = "FILE.RESTORED"
        case fileCopied = "FILE.COPIED"
        case fileMoved = "FILE.MOVED"
        case fileLocked = "FILE.LOCKED"
        case fileUnlocked = "FILE.UNLOCKED"
        case fileRenamed = "FILE.RENAMED"
        case commentCreated = "COMMENT.CREATED"
        case commentUpdated = "COMMENT.UPDATED"
        case commentDeleted = "COMMENT.DELETED"
        case taskAssignmentCreated = "TASK_ASSIGNMENT.CREATED"
        case taskAssignmentUpdated = "TASK_ASSIGNMENT.UPDATED"
        case metadataInstanceCreated = "METADATA_INSTANCE.CREATED"
        case metadataInstanceUpdated = "METADATA_INSTANCE.UPDATED"
        case metadataInstanceDeleted = "METADATA_INSTANCE.DELETED"
        case folderCreated = "FOLDER.CREATED"
        case folderRenamed = "FOLDER.RENAMED"
        case folderDownloaded = "FOLDER.DOWNLOADED"
        case folderRestored = "FOLDER.RESTORED"
        case folderDeleted = "FOLDER.DELETED"
        case folderCopied = "FOLDER.COPIED"
        case folderMoved = "FOLDER.MOVED"
        case folderTrashed = "FOLDER.TRASHED"
        case webhookDeleted = "WEBHOOK.DELETED"
        case collaborationCreated = "COLLABORATION.CREATED"
        case collaborationAccepted = "COLLABORATION.ACCEPTED"
        case collaborationRejected = "COLLABORATION.REJECTED"
        case collaborationRemoved = "COLLABORATION.REMOVED"
        case collaborationUpdated = "COLLABORATION.UPDATED"
        case sharedLinkDeleted = "SHARED_LINK.DELETED"
        case sharedLinkCreated = "SHARED_LINK.CREATED"
        case sharedLinkUpdated = "SHARED_LINK.UPDATED"
    }

    /// `webhook`
    ///
    /// Example: "webhook"
    public enum `Type`: String, Codable, CaseIterable {
        case webhook
    }

    public init(address: String? = nil, createdAt: Date? = nil, createdBy: CreatedBy? = nil, id: String? = nil, target: Target? = nil, triggers: [Trigger]? = nil, type: `Type`? = nil) {
        self.address = address
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.id = id
        self.target = target
        self.triggers = triggers
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case address
        case createdAt = "created_at"
        case createdBy = "created_by"
        case id
        case target
        case triggers
        case type
    }
}

/// Webhook (V2) payload
///
/// The event that is sent to a webhook address when an event happens.
public struct WebhookInvocation: Codable {
    /// A timestamp identifying the time that
    /// the webhook event was triggered.
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var createdAt: Date?
    public var createdBy: CreatedBy?
    /// The unique identifier for this webhook invocation
    ///
    /// Example: "11446498"
    public var id: String?
    public var source: Source?
    public var trigger: Trigger?
    /// `webhook_event`
    ///
    /// Example: "webhook_event"
    public var type: `Type`?
    public var webhook: Webhook?

    public struct CreatedBy: Codable {
        /// User (Mini)
        ///
        /// A mini representation of a user, as can be returned when nested within other
        /// resources.
        public var userMini: UserMini
        /// The user that triggered this event
        public var anyJSON: AnyJSON

        public init(userMini: UserMini, anyJSON: AnyJSON) {
            self.userMini = userMini
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userMini = try UserMini(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userMini, forKey: "userMini")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Source: Codable {
        public var object: Object
        /// The item that caused the event to trigger
        public var anyJSON: AnyJSON

        public enum Object: Codable {
            case file(File)
            case folder(Folder)

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(File.self) {
                    self = .file(value)
                } else if let value = try? container.decode(Folder.self) {
                    self = .folder(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .file(let value): try container.encode(value)
                case .folder(let value): try container.encode(value)
                }
            }
        }

        public init(object: Object, anyJSON: AnyJSON) {
            self.object = object
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.object = try Object(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(object, forKey: "object")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Trigger: Codable {
        /// Webhook Trigger
        ///
        /// The event name that triggered this webhook
        ///
        /// Example: "FILE.UPLOADED"
        public var object: Object
        /// The event name that triggered this webhook
        public var anyJSON: AnyJSON

        /// Webhook Trigger
        ///
        /// The event name that triggered this webhook
        ///
        /// Example: "FILE.UPLOADED"
        public enum Object: String, Codable, CaseIterable {
            case fileUploaded = "FILE.UPLOADED"
            case filePreviewed = "FILE.PREVIEWED"
            case fileDownloaded = "FILE.DOWNLOADED"
            case fileTrashed = "FILE.TRASHED"
            case fileDeleted = "FILE.DELETED"
            case fileRestored = "FILE.RESTORED"
            case fileCopied = "FILE.COPIED"
            case fileMoved = "FILE.MOVED"
            case fileLocked = "FILE.LOCKED"
            case fileUnlocked = "FILE.UNLOCKED"
            case fileRenamed = "FILE.RENAMED"
            case commentCreated = "COMMENT.CREATED"
            case commentUpdated = "COMMENT.UPDATED"
            case commentDeleted = "COMMENT.DELETED"
            case taskAssignmentCreated = "TASK_ASSIGNMENT.CREATED"
            case taskAssignmentUpdated = "TASK_ASSIGNMENT.UPDATED"
            case metadataInstanceCreated = "METADATA_INSTANCE.CREATED"
            case metadataInstanceUpdated = "METADATA_INSTANCE.UPDATED"
            case metadataInstanceDeleted = "METADATA_INSTANCE.DELETED"
            case folderCreated = "FOLDER.CREATED"
            case folderRenamed = "FOLDER.RENAMED"
            case folderDownloaded = "FOLDER.DOWNLOADED"
            case folderRestored = "FOLDER.RESTORED"
            case folderDeleted = "FOLDER.DELETED"
            case folderCopied = "FOLDER.COPIED"
            case folderMoved = "FOLDER.MOVED"
            case folderTrashed = "FOLDER.TRASHED"
            case webhookDeleted = "WEBHOOK.DELETED"
            case collaborationCreated = "COLLABORATION.CREATED"
            case collaborationAccepted = "COLLABORATION.ACCEPTED"
            case collaborationRejected = "COLLABORATION.REJECTED"
            case collaborationRemoved = "COLLABORATION.REMOVED"
            case collaborationUpdated = "COLLABORATION.UPDATED"
            case sharedLinkDeleted = "SHARED_LINK.DELETED"
            case sharedLinkCreated = "SHARED_LINK.CREATED"
            case sharedLinkUpdated = "SHARED_LINK.UPDATED"
        }

        public init(object: Object, anyJSON: AnyJSON) {
            self.object = object
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.object = try Object(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(object, forKey: "object")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    /// `webhook_event`
    ///
    /// Example: "webhook_event"
    public enum `Type`: String, Codable, CaseIterable {
        case webhookEvent = "webhook_event"
    }

    public final class Webhook: Codable {
        /// Represents a configured webhook.
        public var webhook: BoxAPI.Webhook
        /// The webhook object that triggered this event
        public var anyJSON: AnyJSON

        public init(webhook: BoxAPI.Webhook, anyJSON: AnyJSON) {
            self.webhook = webhook
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.webhook = try values.decode(BoxAPI.Webhook.self, forKey: "webhook")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(webhook, forKey: "webhook")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(createdAt: Date? = nil, createdBy: CreatedBy? = nil, id: String? = nil, source: Source? = nil, trigger: Trigger? = nil, type: `Type`? = nil, webhook: Webhook? = nil) {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.id = id
        self.source = source
        self.trigger = trigger
        self.type = type
        self.webhook = webhook
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case createdBy = "created_by"
        case id
        case source
        case trigger
        case type
        case webhook
    }
}

/// A list of webhooks.
public struct Webhooks: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The marker for the start of the next page of results.
    ///
    /// Example: 3000
    public var nextMarker: Int?
    /// The marker for the start of the previous page of results.
    ///
    /// Example: 1000
    public var prevMarker: Int?
    public var entries: [Webhook]?

    public init(limit: Int? = nil, nextMarker: Int? = nil, prevMarker: Int? = nil, entries: [Webhook]? = nil) {
        self.limit = limit
        self.nextMarker = nextMarker
        self.prevMarker = prevMarker
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.nextMarker = try values.decodeIfPresent(Int.self, forKey: "next_marker")
        self.prevMarker = try values.decodeIfPresent(Int.self, forKey: "prev_marker")
        self.entries = try values.decodeIfPresent([Webhook].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(nextMarker, forKey: "next_marker")
        try values.encodeIfPresent(prevMarker, forKey: "prev_marker")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// Box Relay Workflows are objects that represent a named collection of flows.
/// 
/// You application must be authorized to use the `Manage Box Relay` application
/// scope within the developer console in order to use this resource.
public struct Workflow: Codable {
    /// Workflow (Mini)
    ///
    /// Box Relay Workflows are objects that represent a named collection of flows.
    /// 
    /// You application must be authorized to use the `Manage Box Relay` application
    /// scope within the developer console in order to use this resource.
    public var workflowMini: WorkflowMini
    /// A list of flows assigned to a workflow.
    public var flows: [Flow]?

    /// A step in a Box Relay Workflow. Each flow contains a `Trigger` and
    /// a collection of Outcomes to perform once the conditions of a
    /// `Trigger` are met
    public struct Flow: Codable {
        /// When this flow was created
        ///
        /// Example: "2012-12-12T10:53:43-08:00"
        public var createdAt: Date?
        public var createdBy: CreatedBy?
        /// The identifier of the flow
        ///
        /// Example: "12345"
        public var id: String?
        public var outcomes: Outcomes?
        public var trigger: Trigger?
        /// The flow's resource type
        ///
        /// Example: "flow"
        public var type: `Type`?

        public struct CreatedBy: Codable {
            /// User (Base)
            ///
            /// A mini representation of a user, used when
            /// nested within another resource.
            public var userBase: UserBase
            /// The user who created this flow
            public var anyJSON: AnyJSON

            public init(userBase: UserBase, anyJSON: AnyJSON) {
                self.userBase = userBase
                self.anyJSON = anyJSON
            }

            public init(from decoder: Decoder) throws {
                self.userBase = try UserBase(from: decoder)
                self.anyJSON = try AnyJSON(from: decoder)
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(userBase, forKey: "userBase")
                try values.encode(anyJSON, forKey: "anyJSON")
            }
        }

        public struct Outcomes: Codable {
            public var placeholderItems: [PlaceholderItem]
            /// Actions that are completed once the flow is triggered
            public var anyJSON: AnyJSON

            /// List of outcomes to perform once the conditions of trigger are met.
            public struct PlaceholderItem: Codable {
                public var actionType: ActionType?
                /// The identifier of the outcome
                ///
                /// Example: "12345"
                public var id: String?
                /// If `action_type` is `assign_task` and the task is rejected, returns a
                /// list of outcomes to complete
                public var ifRejected: [IfRejectedItem]?
                /// The name of the outcome
                ///
                /// Example: "Task Approval Outcome"
                public var name: String?
                /// Information about how to complete the outcome which varies based on
                /// `action_type` selected
                public var outcomeParameters: [String: AnyJSON]?
                /// The outcomes resource type
                ///
                /// Example: "outcome"
                public var type: `Type`?

                public struct ActionType: Codable {
                    /// Action Type
                    ///
                    /// The type of outcome
                    ///
                    /// Example: "assign_task"
                    public var object: Object
                    /// The type of outcome
                    public var anyJSON: AnyJSON

                    /// Action Type
                    ///
                    /// The type of outcome
                    ///
                    /// Example: "assign_task"
                    public enum Object: String, Codable, CaseIterable {
                        case addMetadata = "add_metadata"
                        case assignTask = "assign_task"
                        case copyFile = "copy_file"
                        case copyFolder = "copy_folder"
                        case createFolder = "create_folder"
                        case deleteFile = "delete_file"
                        case deleteFolder = "delete_folder"
                        case lockFile = "lock_file"
                        case moveFile = "move_file"
                        case moveFolder = "move_folder"
                        case removeWatermarkFile = "remove_watermark_file"
                        case renameFolder = "rename_folder"
                        case restoreFolder = "restore_folder"
                        case shareFile = "share_file"
                        case shareFolder = "share_folder"
                        case unlockFile = "unlock_file"
                        case uploadFile = "upload_file"
                        case waitForTask = "wait_for_task"
                        case watermarkFile = "watermark_file"
                        case goBackToStep = "go_back_to_step"
                        case applyFileClassification = "apply_file_classification"
                        case applyFolderClassification = "apply_folder_classification"
                        case sendNotification = "send_notification"
                    }

                    public init(object: Object, anyJSON: AnyJSON) {
                        self.object = object
                        self.anyJSON = anyJSON
                    }

                    public init(from decoder: Decoder) throws {
                        self.object = try Object(from: decoder)
                        self.anyJSON = try AnyJSON(from: decoder)
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encode(object, forKey: "object")
                        try values.encode(anyJSON, forKey: "anyJSON")
                    }
                }

                public struct IfRejectedItem: Codable {
                    public var actionType: ActionType?
                    /// The identifier of the outcome
                    ///
                    /// Example: "12345"
                    public var id: String?
                    /// The name of the outcome
                    ///
                    /// Example: "Approval Rejection Outcome"
                    public var name: String?
                    /// Information about how to complete the outcome which varies based on
                    /// `action_type` selected
                    public var outcomeParameters: [String: AnyJSON]?
                    /// The outcomes resource type
                    ///
                    /// Example: "outcome"
                    public var type: `Type`?

                    public struct ActionType: Codable {
                        /// Action Type
                        ///
                        /// The type of outcome
                        ///
                        /// Example: "assign_task"
                        public var object: Object
                        /// The type of outcome
                        public var anyJSON: AnyJSON

                        /// Action Type
                        ///
                        /// The type of outcome
                        ///
                        /// Example: "assign_task"
                        public enum Object: String, Codable, CaseIterable {
                            case addMetadata = "add_metadata"
                            case assignTask = "assign_task"
                            case copyFile = "copy_file"
                            case copyFolder = "copy_folder"
                            case createFolder = "create_folder"
                            case deleteFile = "delete_file"
                            case deleteFolder = "delete_folder"
                            case lockFile = "lock_file"
                            case moveFile = "move_file"
                            case moveFolder = "move_folder"
                            case removeWatermarkFile = "remove_watermark_file"
                            case renameFolder = "rename_folder"
                            case restoreFolder = "restore_folder"
                            case shareFile = "share_file"
                            case shareFolder = "share_folder"
                            case unlockFile = "unlock_file"
                            case uploadFile = "upload_file"
                            case waitForTask = "wait_for_task"
                            case watermarkFile = "watermark_file"
                            case goBackToStep = "go_back_to_step"
                            case applyFileClassification = "apply_file_classification"
                            case applyFolderClassification = "apply_folder_classification"
                            case sendNotification = "send_notification"
                        }

                        public init(object: Object, anyJSON: AnyJSON) {
                            self.object = object
                            self.anyJSON = anyJSON
                        }

                        public init(from decoder: Decoder) throws {
                            self.object = try Object(from: decoder)
                            self.anyJSON = try AnyJSON(from: decoder)
                        }

                        public func encode(to encoder: Encoder) throws {
                            var values = encoder.container(keyedBy: StringCodingKey.self)
                            try values.encode(object, forKey: "object")
                            try values.encode(anyJSON, forKey: "anyJSON")
                        }
                    }

                    /// The outcomes resource type
                    ///
                    /// Example: "outcome"
                    public enum `Type`: String, Codable, CaseIterable {
                        case outcome
                    }

                    public init(actionType: ActionType? = nil, id: String? = nil, name: String? = nil, outcomeParameters: [String: AnyJSON]? = nil, type: `Type`? = nil) {
                        self.actionType = actionType
                        self.id = id
                        self.name = name
                        self.outcomeParameters = outcomeParameters
                        self.type = type
                    }

                    private enum CodingKeys: String, CodingKey {
                        case actionType = "action_type"
                        case id
                        case name
                        case outcomeParameters = "outcome_parameters"
                        case type
                    }
                }

                /// The outcomes resource type
                ///
                /// Example: "outcome"
                public enum `Type`: String, Codable, CaseIterable {
                    case outcome
                }

                public init(actionType: ActionType? = nil, id: String? = nil, ifRejected: [IfRejectedItem]? = nil, name: String? = nil, outcomeParameters: [String: AnyJSON]? = nil, type: `Type`? = nil) {
                    self.actionType = actionType
                    self.id = id
                    self.ifRejected = ifRejected
                    self.name = name
                    self.outcomeParameters = outcomeParameters
                    self.type = type
                }

                private enum CodingKeys: String, CodingKey {
                    case actionType = "action_type"
                    case id
                    case ifRejected = "if_rejected"
                    case name
                    case outcomeParameters = "outcome_parameters"
                    case type
                }
            }

            public init(placeholderItems: [PlaceholderItem], anyJSON: AnyJSON) {
                self.placeholderItems = placeholderItems
                self.anyJSON = anyJSON
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.placeholderItems = try values.decode([PlaceholderItem].self, forKey: "placeholderItems")
                self.anyJSON = try AnyJSON(from: decoder)
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(placeholderItems, forKey: "placeholderItems")
                try values.encode(anyJSON, forKey: "anyJSON")
            }
        }

        public struct Trigger: Codable {
            /// List of trigger scopes
            public var scope: [ScopeItem]?
            /// The type of trigger selected for this flow
            ///
            /// Example: "WORKFLOW_MANUAL_START"
            public var triggerType: TriggerType?
            /// The trigger's resource type
            ///
            /// Example: "trigger"
            public var type: `Type`?
            /// Trigger that initiates flow
            public var anyJSON: AnyJSON

            /// Object that describes where and how a Trigger condition is met
            public struct ScopeItem: Codable {
                /// The object the `ref` points to
                public var object: Object?
                /// Indicates the path of the condition value to check
                ///
                /// Example: "/event/source/parameters/folder"
                public var ref: String?
                /// The trigger scope's resource type
                ///
                /// Example: "trigger_scope"
                public var type: `Type`?

                /// The object the `ref` points to
                public struct Object: Codable {
                    /// The id of the object
                    ///
                    /// Example: "12345"
                    public var id: String?
                    /// The type of the object
                    ///
                    /// Example: "folder"
                    public var type: `Type`?

                    /// The type of the object
                    ///
                    /// Example: "folder"
                    public enum `Type`: String, Codable, CaseIterable {
                        case folder
                    }

                    public init(id: String? = nil, type: `Type`? = nil) {
                        self.id = id
                        self.type = type
                    }
                }

                /// The trigger scope's resource type
                ///
                /// Example: "trigger_scope"
                public enum `Type`: String, Codable, CaseIterable {
                    case triggerScope = "trigger_scope"
                }

                public init(object: Object? = nil, ref: String? = nil, type: `Type`? = nil) {
                    self.object = object
                    self.ref = ref
                    self.type = type
                }
            }

            /// The type of trigger selected for this flow
            ///
            /// Example: "WORKFLOW_MANUAL_START"
            public enum TriggerType: String, Codable, CaseIterable {
                case workflowManualStart = "WORKFLOW_MANUAL_START"
            }

            /// The trigger's resource type
            ///
            /// Example: "trigger"
            public enum `Type`: String, Codable, CaseIterable {
                case trigger
            }

            public init(scope: [ScopeItem]? = nil, triggerType: TriggerType? = nil, type: `Type`? = nil, anyJSON: AnyJSON) {
                self.scope = scope
                self.triggerType = triggerType
                self.type = type
                self.anyJSON = anyJSON
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.scope = try values.decodeIfPresent([ScopeItem].self, forKey: "scope")
                self.triggerType = try TriggerType(from: decoder)
                self.type = try `Type`(from: decoder)
                self.anyJSON = try AnyJSON(from: decoder)
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(scope, forKey: "scope")
                try values.encodeIfPresent(triggerType, forKey: "trigger_type")
                try values.encodeIfPresent(type, forKey: "type")
                try values.encode(anyJSON, forKey: "anyJSON")
            }
        }

        /// The flow's resource type
        ///
        /// Example: "flow"
        public enum `Type`: String, Codable, CaseIterable {
            case flow
        }

        public init(createdAt: Date? = nil, createdBy: CreatedBy? = nil, id: String? = nil, outcomes: Outcomes? = nil, trigger: Trigger? = nil, type: `Type`? = nil) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.id = id
            self.outcomes = outcomes
            self.trigger = trigger
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "created_at"
            case createdBy = "created_by"
            case id
            case outcomes
            case trigger
            case type
        }
    }

    public init(workflowMini: WorkflowMini, flows: [Flow]? = nil) {
        self.workflowMini = workflowMini
        self.flows = flows
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.workflowMini = try WorkflowMini(from: decoder)
        self.flows = try values.decodeIfPresent([Flow].self, forKey: "flows")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(workflowMini, forKey: "workflowMini")
        try values.encodeIfPresent(flows, forKey: "flows")
    }
}

/// Workflow (Full)
///
/// Box Relay Workflows are objects that represent a named collection of flows.
/// 
/// You application must be authorized to use the `Manage Box Relay` application
/// scope within the developer console in order to use this resource.
public struct WorkflowFull: Codable {
    /// Box Relay Workflows are objects that represent a named collection of flows.
    /// 
    /// You application must be authorized to use the `Manage Box Relay` application
    /// scope within the developer console in order to use this resource.
    public var workflow: Workflow
    /// The date and time when the workflow was created on Box
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var createdAt: Date?
    public var createdBy: CreatedBy?
    /// The date and time when the workflow was last updated on Box
    ///
    /// Example: "2012-12-12T10:53:43-08:00"
    public var modifiedAt: Date?
    public var modifiedBy: ModifiedBy?

    public struct CreatedBy: Codable {
        /// User (Base)
        ///
        /// A mini representation of a user, used when
        /// nested within another resource.
        public var userBase: UserBase
        /// The user who created this workflow
        public var anyJSON: AnyJSON

        public init(userBase: UserBase, anyJSON: AnyJSON) {
            self.userBase = userBase
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userBase = try UserBase(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userBase, forKey: "userBase")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ModifiedBy: Codable {
        /// User (Base)
        ///
        /// A mini representation of a user, used when
        /// nested within another resource.
        public var userBase: UserBase
        /// The user who last modified this workflow
        public var anyJSON: AnyJSON

        public init(userBase: UserBase, anyJSON: AnyJSON) {
            self.userBase = userBase
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.userBase = try UserBase(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(userBase, forKey: "userBase")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(workflow: Workflow, createdAt: Date? = nil, createdBy: CreatedBy? = nil, modifiedAt: Date? = nil, modifiedBy: ModifiedBy? = nil) {
        self.workflow = workflow
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.modifiedAt = modifiedAt
        self.modifiedBy = modifiedBy
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.workflow = try Workflow(from: decoder)
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: "created_at")
        self.createdBy = try CreatedBy(from: decoder)
        self.modifiedAt = try values.decodeIfPresent(Date.self, forKey: "modified_at")
        self.modifiedBy = try ModifiedBy(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(workflow, forKey: "workflow")
        try values.encodeIfPresent(createdAt, forKey: "created_at")
        try values.encodeIfPresent(createdBy, forKey: "created_by")
        try values.encodeIfPresent(modifiedAt, forKey: "modified_at")
        try values.encodeIfPresent(modifiedBy, forKey: "modified_by")
    }
}

/// Workflow (Mini)
///
/// Box Relay Workflows are objects that represent a named collection of flows.
/// 
/// You application must be authorized to use the `Manage Box Relay` application
/// scope within the developer console in order to use this resource.
public struct WorkflowMini: Codable {
    /// The description for a workflow.
    ///
    /// Example: "This workflow sets off a new hire approval flow"
    public var description: String?
    /// The unique identifier for the workflow
    ///
    /// Example: "11446498"
    public var id: String?
    /// Specifies if this workflow is enabled
    ///
    /// Example: true
    public var isEnabled: Bool?
    /// The name of the workflow
    ///
    /// Example: "New Hire Workflow"
    public var name: String?
    /// `workflow`
    ///
    /// Example: "workflow"
    public var type: `Type`?

    /// `workflow`
    ///
    /// Example: "workflow"
    public enum `Type`: String, Codable, CaseIterable {
        case workflow
    }

    public init(description: String? = nil, id: String? = nil, isEnabled: Bool? = nil, name: String? = nil, type: `Type`? = nil) {
        self.description = description
        self.id = id
        self.isEnabled = isEnabled
        self.name = name
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case description
        case id
        case isEnabled = "is_enabled"
        case name
        case type
    }
}

/// A list of workflows.
/// 
/// You application must be authorized to use the `Manage Box Relay` application
/// scope within the developer console in order to use this resource.
public struct Workflows: Codable {
    /// The limit that was used for these entries. This will be the same as the
    /// `limit` query parameter unless that value exceeded the maximum value
    /// allowed. The maximum value varies by API.
    ///
    /// Example: 1000
    public var limit: Int?
    /// The marker for the start of the next page of results.
    ///
    /// Example: 3000
    public var nextMarker: Int?
    /// The marker for the start of the previous page of results.
    ///
    /// Example: 1000
    public var prevMarker: Int?
    public var entries: [Workflow]?

    public init(limit: Int? = nil, nextMarker: Int? = nil, prevMarker: Int? = nil, entries: [Workflow]? = nil) {
        self.limit = limit
        self.nextMarker = nextMarker
        self.prevMarker = prevMarker
        self.entries = entries
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.limit = try values.decodeIfPresent(Int.self, forKey: "limit")
        self.nextMarker = try values.decodeIfPresent(Int.self, forKey: "next_marker")
        self.prevMarker = try values.decodeIfPresent(Int.self, forKey: "prev_marker")
        self.entries = try values.decodeIfPresent([Workflow].self, forKey: "entries")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(limit, forKey: "limit")
        try values.encodeIfPresent(nextMarker, forKey: "next_marker")
        try values.encodeIfPresent(prevMarker, forKey: "prev_marker")
        try values.encodeIfPresent(entries, forKey: "entries")
    }
}

/// Represents a successful request to create a `zip` archive of a list of files
/// and folders.
///
/// Example:
///
/// {
///   "download_url" : "https:\/\/dl.boxcloud.com\/2.0\/zip_downloads\/29l00nfxDyHOt7RphI9zT_w==nDnZEDjY2S8iEWWCHEEiptFxwoWojjlibZjJ6geuE5xnXENDTPxzgbks_yY=\/content",
///   "expires_at" : "2020-07-22T11:26:08Z",
///   "name_conflicts" : [
///     [
///       {
///         "download_name" : "3aa6a7.pdf",
///         "id" : "12345",
///         "original_name" : "Report.pdf",
///         "type" : "file"
///       },
///       {
///         "download_name" : "5d53f2.pdf",
///         "id" : "34325",
///         "original_name" : "Report.pdf",
///         "type" : "file"
///       }
///     ]
///   ],
///   "status_url" : "https:\/\/api.box.com\/2.0\/zip_downloads\/29l00nfxDyHOt7RphI9zT_w==nDnZEDjY2S8iEWWCHEEiptFxwoWojjlibZjJ6geuE5xnXENDTPxzgbks_yY=\/status"
/// }
public struct ZipDownload: Codable {
    /// The URL that can be used to download the `zip` archive. A `Get` request to
    /// this URL will start streaming the items requested. By default, this URL
    /// is only valid for a few seconds, until the `exires_at` time, unless a
    /// download is started after which it is valid for the duration of the
    /// download.
    /// 
    /// It is important to note that the domain and path of this URL might change
    /// between API calls, and therefore it's important to use this URL as-is.
    ///
    /// Example: "https://dl.boxcloud.com/2.0/zip_downloads/Lu6fA9Ob-jyysp3AAvMF4AkLEwZwAYbL=tgj2zIC=eK9RvJnJbjJl9rNh2qBgHDpyOCAOhpM=vajg2mKq8Mdd/content"
    public var downloadURL: String?
    /// The time and date when this archive will expire. After this time the
    /// `status_url` and `download_url` will return an error.
    /// 
    /// By default, these URLs are only valid for a few seconds, unless a download
    /// is started after which the `download_url` is valid for the duration of the
    /// download, and the `status_url` is valid for 12 hours from the start of the
    /// download.
    ///
    /// Example: "2019-08-29T23:59:00-07:00"
    public var expiresAt: Date?
    /// A list of conflicts that occurred when trying to create the archive. This
    /// would occur when multiple items have been requested with the
    /// same name.
    /// 
    /// To solve these conflicts, the API will automatically rename an item
    /// and return a mapping between the original item's name and its new
    /// name.
    /// 
    /// For every conflict, both files will be renamed and therefore this list
    /// will always be a multiple of 2.
    public var nameConflicts: [[NameConflictItem]]?
    /// The URL that can be used to get the status of the `zip` archive being
    /// downloaded. A `Get` request to this URL will return the number of files
    /// in the archive as well as the number of items already downloaded or
    /// skipped. By default, this URL is only valid for a few seconds, until the
    /// `exires_at` time, unless a download is started after which the URL is
    /// valid for 12 hours from the start of the download.
    /// 
    /// It is important to note that the domain and path of this URL might change
    /// between API calls, and therefore it's important to use this URL as-is.
    ///
    /// Example: "https://api.box.com/2.0/zip_downloads/Lu6fA9Ob-jyysp3AAvMF4AkLEwZwAYbL=tgj2zIC=eK9RvJnJbjJl9rNh2qBgHDpyOCAOhpM=vajg2mKq8Mdd/status"
    public var statusURL: String?

    /// A file or folder for which a conflict was encountered, This object provides the type and identifier of the original item, as well as a mapping between its original name and it's new name as it will appear in the archive.
    public struct NameConflictItem: Codable {
        /// The new name of this item as it will appear in the
        /// downloaded `zip` archive.
        ///
        /// Example: "3aa6a7.pdf"
        public var downloadName: String?
        /// The identifier of the item
        ///
        /// Example: "12345"
        public var id: String?
        /// The original name of this item
        ///
        /// Example: "Report.pdf"
        public var originalName: String?
        /// The type of this item
        ///
        /// Example: "file"
        public var type: `Type`?

        /// The type of this item
        ///
        /// Example: "file"
        public enum `Type`: String, Codable, CaseIterable {
            case file
            case folder
        }

        public init(downloadName: String? = nil, id: String? = nil, originalName: String? = nil, type: `Type`? = nil) {
            self.downloadName = downloadName
            self.id = id
            self.originalName = originalName
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case downloadName = "download_name"
            case id
            case originalName = "original_name"
            case type
        }
    }

    public init(downloadURL: String? = nil, expiresAt: Date? = nil, nameConflicts: [[NameConflictItem]]? = nil, statusURL: String? = nil) {
        self.downloadURL = downloadURL
        self.expiresAt = expiresAt
        self.nameConflicts = nameConflicts
        self.statusURL = statusURL
    }

    private enum CodingKeys: String, CodingKey {
        case downloadURL = "download_url"
        case expiresAt = "expires_at"
        case nameConflicts = "name_conflicts"
        case statusURL = "status_url"
    }
}

/// Create a `zip` archive
///
/// A request to create a `zip` archive to download
public struct ZipDownloadRequest: Codable {
    /// The optional name of the `zip` archive. This name will be appended by the
    /// `.zip` file extension, for example `January Financials.zip`.
    ///
    /// Example: "January Financials"
    public var downloadFileName: String?
    /// A list of items to add to the `zip` archive. These can
    /// be folders or files.
    public var items: [Item]

    /// An item to add to the `zip` archive. This can be a file or a folder.
    public struct Item: Codable {
        /// The identifier of the item to add to the archive. When this item is
        /// a folder then this can not be the root folder with ID `0`.
        ///
        /// Example: "12345"
        public var id: String
        /// The type of the item to add to the archive.
        ///
        /// Example: "file"
        public var type: `Type`

        /// The type of the item to add to the archive.
        ///
        /// Example: "file"
        public enum `Type`: String, Codable, CaseIterable {
            case file
            case folder = "folder."
        }

        public init(id: String, type: `Type`) {
            self.id = id
            self.type = type
        }
    }

    public init(downloadFileName: String? = nil, items: [Item]) {
        self.downloadFileName = downloadFileName
        self.items = items
    }

    private enum CodingKeys: String, CodingKey {
        case downloadFileName = "download_file_name"
        case items
    }
}

/// The status of a `zip` archive being downloaded.
public struct ZipDownloadStatus: Codable {
    /// The number of files that have already been downloaded.
    ///
    /// Example: 10
    public var downloadedFileCount: Int?
    /// The number of files that have been skipped as they could not be
    /// downloaded. In many cases this is due to permission issues that have
    /// surfaced between the creation of the request for the archive and the
    /// archive being downloaded.
    public var skippedFileCount: Int?
    /// The number of folders that have been skipped as they could not be
    /// downloaded. In many cases this is due to permission issues that have
    /// surfaced between the creation of the request for the archive and the
    /// archive being downloaded.
    public var skippedFolderCount: Int?
    /// The state of the archive being downloaded.
    ///
    /// Example: "success"
    public var state: State?
    /// The total number of files in the archive.
    ///
    /// Example: 20
    public var totalFileCount: Int?

    /// The state of the archive being downloaded.
    ///
    /// Example: "success"
    public enum State: String, Codable, CaseIterable {
        case inProgress = "in_progress"
        case failed
        case success
    }

    public init(downloadedFileCount: Int? = nil, skippedFileCount: Int? = nil, skippedFolderCount: Int? = nil, state: State? = nil, totalFileCount: Int? = nil) {
        self.downloadedFileCount = downloadedFileCount
        self.skippedFileCount = skippedFileCount
        self.skippedFolderCount = skippedFolderCount
        self.state = state
        self.totalFileCount = totalFileCount
    }

    private enum CodingKeys: String, CodingKey {
        case downloadedFileCount = "downloaded_file_count"
        case skippedFileCount = "skipped_file_count"
        case skippedFolderCount = "skipped_folder_count"
        case state
        case totalFileCount = "total_file_count"
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
