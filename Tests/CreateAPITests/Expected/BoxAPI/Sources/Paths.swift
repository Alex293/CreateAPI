// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension Paths {
    public static var authorize: Authorize {
        Authorize(path: "/authorize")
    }

    public struct Authorize {
        /// Path: `/authorize`
        public let path: String

        /// Authorize user
        ///
        /// Authorize a user by sending them through the [Box](https://box.com)
        /// website and request their permission to act on their behalf.
        /// 
        /// This is the first step when authenticating a user using
        /// OAuth 2.0. To request a user's authorization to use the Box APIs
        /// on their behalf you will need to send a user to the URL with this
        /// format.
        public func get(parameters: GetParameters) -> Request<String> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var responseType: ResponseType
            public var clientID: String
            public var redirectUri: String?
            public var state: String?
            public var scope: String?

            public enum ResponseType: String, Codable, CaseIterable {
                case code
            }

            public init(responseType: ResponseType, clientID: String, redirectUri: String? = nil, state: String? = nil, scope: String? = nil) {
                self.responseType = responseType
                self.clientID = clientID
                self.redirectUri = redirectUri
                self.state = state
                self.scope = scope
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(responseType, forKey: "response_type")
                encoder.encode(clientID, forKey: "client_id")
                encoder.encode(redirectUri, forKey: "redirect_uri")
                encoder.encode(state, forKey: "state")
                encoder.encode(scope, forKey: "scope")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var collaborationWhitelistEntries: CollaborationWhitelistEntries {
        CollaborationWhitelistEntries(path: "/collaboration_whitelist_entries")
    }

    public struct CollaborationWhitelistEntries {
        /// Path: `/collaboration_whitelist_entries`
        public let path: String

        /// List allowed collaboration domains
        ///
        /// Returns the list domains that have been deemed safe to create collaborations
        /// for within the current enterprise.
        public func get(marker: String? = nil, limit: Int? = nil) -> Request<BoxAPI.CollaborationAllowlistEntries> {
            .get(path, query: makeGetQuery(marker, limit))
        }

        private func makeGetQuery(_ marker: String?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(marker, forKey: "marker")
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }

        /// Add domain to list of allowed collaboration domains
        ///
        /// Creates a new entry in the list of allowed domains to allow
        /// collaboration for.
        public func post(_ body: PostRequest? = nil) -> Request<BoxAPI.CollaborationAllowlistEntry> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The direction in which to allow collaborations.
            ///
            /// Example: "inbound"
            public var direction: Direction
            /// The domain to add to the list of allowed domains.
            ///
            /// Example: "example.com"
            public var domain: String

            /// The direction in which to allow collaborations.
            ///
            /// Example: "inbound"
            public enum Direction: String, Codable, CaseIterable {
                case inbound
                case outbound
                case both
            }

            public init(direction: Direction, domain: String) {
                self.direction = direction
                self.domain = domain
            }
        }
    }
}

extension Paths.CollaborationWhitelistEntries {
    public func collaborationWhitelistEntryID(_ collaborationWhitelistEntryID: String) -> WithCollaborationWhitelistEntryID {
        WithCollaborationWhitelistEntryID(path: "\(path)/\(collaborationWhitelistEntryID)")
    }

    public struct WithCollaborationWhitelistEntryID {
        /// Path: `/collaboration_whitelist_entries/{collaboration_whitelist_entry_id}`
        public let path: String

        /// Get allowed collaboration domain
        ///
        /// Returns a domain that has been deemed safe to create collaborations
        /// for within the current enterprise.
        public var get: Request<BoxAPI.CollaborationAllowlistEntry> {
            .get(path)
        }

        /// Remove domain from list of allowed collaboration domains
        ///
        /// Removes a domain from the list of domains that have been deemed safe to create
        /// collaborations for within the current enterprise.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var collaborationWhitelistExemptTargets: CollaborationWhitelistExemptTargets {
        CollaborationWhitelistExemptTargets(path: "/collaboration_whitelist_exempt_targets")
    }

    public struct CollaborationWhitelistExemptTargets {
        /// Path: `/collaboration_whitelist_exempt_targets`
        public let path: String

        /// List users exempt from collaboration domain restrictions
        ///
        /// Returns a list of users who have been exempt from the collaboration
        /// domain restrictions.
        public func get(marker: String? = nil, limit: Int? = nil) -> Request<BoxAPI.CollaborationAllowlistExemptTargets> {
            .get(path, query: makeGetQuery(marker, limit))
        }

        private func makeGetQuery(_ marker: String?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(marker, forKey: "marker")
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }

        /// Create user exemption from collaboration domain restrictions
        ///
        /// Exempts a user from the restrictions set out by the allowed list of domains
        /// for collaborations.
        public func post(user: PostRequest.User) -> Request<BoxAPI.CollaborationAllowlistExemptTarget> {
            .post(path, body: PostRequest(user: user))
        }

        public struct PostRequest: Encodable {
            /// The user to exempt.
            public var user: User

            /// The user to exempt.
            public struct User: Encodable {
                /// The ID of the user to exempt.
                ///
                /// Example: "23522323"
                public var id: String

                public init(id: String) {
                    self.id = id
                }
            }

            public init(user: User) {
                self.user = user
            }
        }
    }
}

extension Paths.CollaborationWhitelistExemptTargets {
    public func collaborationWhitelistExemptTargetID(_ collaborationWhitelistExemptTargetID: String) -> WithCollaborationWhitelistExemptTargetID {
        WithCollaborationWhitelistExemptTargetID(path: "\(path)/\(collaborationWhitelistExemptTargetID)")
    }

    public struct WithCollaborationWhitelistExemptTargetID {
        /// Path: `/collaboration_whitelist_exempt_targets/{collaboration_whitelist_exempt_target_id}`
        public let path: String

        /// Get user exempt from collaboration domain restrictions
        ///
        /// Returns a users who has been exempt from the collaboration
        /// domain restrictions.
        public var get: Request<BoxAPI.CollaborationAllowlistExemptTarget> {
            .get(path)
        }

        /// Remove user from list of users exempt from domain restrictions
        ///
        /// Removes a user's exemption from the restrictions set out by the allowed list
        /// of domains for collaborations.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var collaborations: Collaborations {
        Collaborations(path: "/collaborations")
    }

    public struct Collaborations {
        /// Path: `/collaborations`
        public let path: String

        /// List pending collaborations
        ///
        /// Retrieves all pending collaboration invites for this user.
        public func get(parameters: GetParameters) -> Request<BoxAPI.Collaborations> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var status: Status
            public var fields: [String]?
            public var offset: Int?
            public var limit: Int?

            public enum Status: String, Codable, CaseIterable {
                case pending
            }

            public init(status: Status, fields: [String]? = nil, offset: Int? = nil, limit: Int? = nil) {
                self.status = status
                self.fields = fields
                self.offset = offset
                self.limit = limit
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(status, forKey: "status")
                encoder.encode(fields, forKey: "fields", explode: false)
                encoder.encode(offset, forKey: "offset")
                encoder.encode(limit, forKey: "limit")
                return encoder.items
            }
        }

        /// Create collaboration
        ///
        /// Adds a collaboration for a single user or a single group to a file
        /// or folder.
        /// 
        /// Collaborations can be created using email address, user IDs, or a
        /// group IDs.
        /// 
        /// If a collaboration is being created with a group, access to
        /// this endpoint is dependent on the group's ability to be invited.
        public func post(fields: [String]? = nil, isNotify: Bool? = nil, _ body: PostRequest? = nil) -> Request<BoxAPI.Collaboration> {
            .post(path, query: makePostQuery(fields, isNotify), body: body)
        }

        private func makePostQuery(_ fields: [String]?, _ isNotify: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            encoder.encode(isNotify, forKey: "notify")
            return encoder.items
        }

        public struct PostRequest: Encodable {
            /// The user or group to give access to the item.
            public var accessibleBy: AccessibleBy
            /// Determines if the invited users can see the entire parent path to
            /// the associated folder. The user will not gain privileges in any
            /// parent folder and therefore can not see content the user is not
            /// collaborated on.
            /// 
            /// Be aware that this meaningfully increases the time required to load the
            /// invitee's **All Files** page. We recommend you limit the number of
            /// collaborations with `can_view_path` enabled to 1,000 per user.
            ///
            /// Example: true
            public var canViewPath: Bool?
            /// Set the expiration date for the collaboration. At this date, the
            /// collaboration will be automatically removed from the item.
            /// 
            /// This feature will only work if the **Automatically remove invited
            /// collaborators: Allow folder owners to extend the expiry date**
            /// setting has been enabled in the **Enterprise Settings**
            /// of the **Admin Console**. When the setting is not enabled,
            /// collaborations can not have an expiry date and a value for this
            /// field will be result in an error.
            ///
            /// Example: "2019-08-29T23:59:00-07:00"
            public var expiresAt: Date?
            /// The item to attach the comment to.
            public var item: Item
            /// The level of access granted.
            ///
            /// Example: "editor"
            public var role: Role

            /// The user or group to give access to the item.
            public struct AccessibleBy: Encodable {
                /// The ID of the user or group.
                /// 
                /// Alternatively, use `login` to specify a user by email
                /// address.
                ///
                /// Example: "23522323"
                public var id: String?
                /// The email address of the user to grant access to the item.
                /// 
                /// Alternatively, use `id` to specify a user by user ID.
                ///
                /// Example: "john@example.com"
                public var login: String?
                /// The type of collaborator to invite.
                ///
                /// Example: "user"
                public var type: `Type`

                /// The type of collaborator to invite.
                ///
                /// Example: "user"
                public enum `Type`: String, Codable, CaseIterable {
                    case user
                    case group
                }

                public init(id: String? = nil, login: String? = nil, type: `Type`) {
                    self.id = id
                    self.login = login
                    self.type = type
                }
            }

            /// The item to attach the comment to.
            public struct Item: Encodable {
                /// The ID of the item that will be granted access to
                ///
                /// Example: "11446498"
                public var id: String
                /// The type of the item that this collaboration will be
                /// granted access to
                ///
                /// Example: "file"
                public var type: `Type`

                /// The type of the item that this collaboration will be
                /// granted access to
                ///
                /// Example: "file"
                public enum `Type`: String, Codable, CaseIterable {
                    case file
                    case folder
                }

                public init(id: String, type: `Type`) {
                    self.id = id
                    self.type = type
                }
            }

            /// The level of access granted.
            ///
            /// Example: "editor"
            public enum Role: String, Codable, CaseIterable {
                case editor
                case viewer
                case previewer
                case uploader
                case previewerUploader = "previewer uploader"
                case viewerUploader = "viewer uploader"
                case coOwner = "co-owner"
            }

            public init(accessibleBy: AccessibleBy, canViewPath: Bool? = nil, expiresAt: Date? = nil, item: Item, role: Role) {
                self.accessibleBy = accessibleBy
                self.canViewPath = canViewPath
                self.expiresAt = expiresAt
                self.item = item
                self.role = role
            }

            private enum CodingKeys: String, CodingKey {
                case accessibleBy = "accessible_by"
                case canViewPath = "can_view_path"
                case expiresAt = "expires_at"
                case item
                case role
            }
        }
    }
}

extension Paths.Collaborations {
    public func collaborationID(_ collaborationID: String) -> WithCollaborationID {
        WithCollaborationID(path: "\(path)/\(collaborationID)")
    }

    public struct WithCollaborationID {
        /// Path: `/collaborations/{collaboration_id}`
        public let path: String

        /// Get collaboration
        ///
        /// Retrieves a single collaboration.
        public func get(fields: [String]? = nil) -> Request<BoxAPI.Collaboration> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        /// Update collaboration
        ///
        /// Updates a collaboration.
        /// 
        /// Can be used to change the owner of an item, or to
        /// accept collaboration invites.
        public func put(_ body: PutRequest? = nil) -> Request<BoxAPI.Collaboration> {
            .put(path, body: body)
        }

        public struct PutRequest: Encodable {
            /// Determines if the invited users can see the entire parent path to
            /// the associated folder. The user will not gain privileges in any
            /// parent folder and therefore can not see content the user is not
            /// collaborated on.
            /// 
            /// Be aware that this meaningfully increases the time required to load the
            /// invitee's **All Files** page. We recommend you limit the number of
            /// collaborations with `can_view_path` enabled to 1,000 per user.
            ///
            /// Example: true
            public var canViewPath: Bool?
            /// Update the expiration date for the collaboration. At this date,
            /// the collaboration will be automatically removed from the item.
            /// 
            /// This feature will only work if the **Automatically remove invited
            /// collaborators: Allow folder owners to extend the expiry date**
            /// setting has been enabled in the **Enterprise Settings**
            /// of the **Admin Console**. When the setting is not enabled,
            /// collaborations can not have an expiry date and a value for this
            /// field will be result in an error.
            /// 
            /// Additionally, a collaboration can only be given an
            /// expiration if it was created after the **Automatically remove
            /// invited collaborator** setting was enabled.
            ///
            /// Example: "2019-08-29T23:59:00-07:00"
            public var expiresAt: Date?
            /// The level of access granted.
            ///
            /// Example: "editor"
            public var role: Role
            /// <!--alex ignore reject-->
            /// Set the status of a `pending` collaboration invitation,
            /// effectively accepting, or rejecting the invite.
            ///
            /// Example: "accepted"
            public var status: Status?

            /// The level of access granted.
            ///
            /// Example: "editor"
            public enum Role: String, Codable, CaseIterable {
                case editor
                case viewer
                case previewer
                case uploader
                case previewerUploader = "previewer uploader"
                case viewerUploader = "viewer uploader"
                case coOwner = "co-owner"
                case owner
            }

            /// <!--alex ignore reject-->
            /// Set the status of a `pending` collaboration invitation,
            /// effectively accepting, or rejecting the invite.
            ///
            /// Example: "accepted"
            public enum Status: String, Codable, CaseIterable {
                case pending
                case accepted
                case rejected
            }

            public init(canViewPath: Bool? = nil, expiresAt: Date? = nil, role: Role, status: Status? = nil) {
                self.canViewPath = canViewPath
                self.expiresAt = expiresAt
                self.role = role
                self.status = status
            }

            private enum CodingKeys: String, CodingKey {
                case canViewPath = "can_view_path"
                case expiresAt = "expires_at"
                case role
                case status
            }
        }

        /// Remove collaboration
        ///
        /// Deletes a single collaboration.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var collections: Collections {
        Collections(path: "/collections")
    }

    public struct Collections {
        /// Path: `/collections`
        public let path: String

        /// List all collections
        ///
        /// Retrieves all collections for a given user.
        /// 
        /// Currently, only the `favorites` collection
        /// is supported.
        public func get(parameters: GetParameters? = nil) -> Request<BoxAPI.Collections> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var fields: [String]?
            public var offset: Int?
            public var limit: Int?

            public init(fields: [String]? = nil, offset: Int? = nil, limit: Int? = nil) {
                self.fields = fields
                self.offset = offset
                self.limit = limit
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields", explode: false)
                encoder.encode(offset, forKey: "offset")
                encoder.encode(limit, forKey: "limit")
                return encoder.items
            }
        }
    }
}

extension Paths.Collections {
    public func collectionID(_ collectionID: String) -> WithCollectionID {
        WithCollectionID(path: "\(path)/\(collectionID)")
    }

    public struct WithCollectionID {
        /// Path: `/collections/{collection_id}`
        public let path: String
    }
}

extension Paths.Collections.WithCollectionID {
    public var items: Items {
        Items(path: path + "/items")
    }

    public struct Items {
        /// Path: `/collections/{collection_id}/items`
        public let path: String

        /// List collection items
        ///
        /// Retrieves the files and/or folders contained within
        /// this collection.
        public func get(parameters: GetParameters? = nil) -> Request<BoxAPI.Items> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var fields: [String]?
            public var offset: Int?
            public var limit: Int?

            public init(fields: [String]? = nil, offset: Int? = nil, limit: Int? = nil) {
                self.fields = fields
                self.offset = offset
                self.limit = limit
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields", explode: false)
                encoder.encode(offset, forKey: "offset")
                encoder.encode(limit, forKey: "limit")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var comments: Comments {
        Comments(path: "/comments")
    }

    public struct Comments {
        /// Path: `/comments`
        public let path: String

        /// Create comment
        ///
        /// Adds a comment by the user to a specific file, or
        /// as a reply to an other comment.
        public func post(fields: [String]? = nil, _ body: PostRequest? = nil) -> Request<BoxAPI.Comment> {
            .post(path, query: makePostQuery(fields), body: body)
        }

        private func makePostQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        public struct PostRequest: Encodable {
            /// The item to attach the comment to.
            public var item: Item?
            /// The text of the comment.
            /// 
            /// To mention a user, use the `tagged_message`
            /// parameter instead.
            ///
            /// Example: "Review completed!"
            public var message: String
            /// The text of the comment, including `@[user_id:name]`
            /// somewhere in the message to mention another user, which
            /// will send them an email notification, letting them know
            /// they have been mentioned.
            /// 
            /// The `user_id` is the target user's ID, where the `name`
            /// can be any custom phrase. In the Box UI this name will
            /// link to the user's profile.
            /// 
            /// If you are not mentioning another user, use `message`
            /// instead.
            ///
            /// Example: "@[1234:John] Review completed!"
            public var taggedMessage: String?

            /// The item to attach the comment to.
            public struct Item: Encodable {
                /// The ID of the item
                ///
                /// Example: "11446498"
                public var id: String
                /// The type of the item that this comment will be placed on.
                ///
                /// Example: "file"
                public var type: `Type`

                /// The type of the item that this comment will be placed on.
                ///
                /// Example: "file"
                public enum `Type`: String, Codable, CaseIterable {
                    case file
                    case comment
                }

                public init(id: String, type: `Type`) {
                    self.id = id
                    self.type = type
                }
            }

            public init(item: Item? = nil, message: String, taggedMessage: String? = nil) {
                self.item = item
                self.message = message
                self.taggedMessage = taggedMessage
            }

            private enum CodingKeys: String, CodingKey {
                case item
                case message
                case taggedMessage = "tagged_message"
            }
        }
    }
}

extension Paths.Comments {
    public func commentID(_ commentID: String) -> WithCommentID {
        WithCommentID(path: "\(path)/\(commentID)")
    }

    public struct WithCommentID {
        /// Path: `/comments/{comment_id}`
        public let path: String

        /// Get comment
        ///
        /// Retrieves the message and metadata for a specific comment, as well
        /// as information on the user who created the comment.
        public func get(fields: [String]? = nil) -> Request<BoxAPI.Comment> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        /// Update comment
        ///
        /// Update the message of a comment.
        public func put(fields: [String]? = nil, message: String? = nil) -> Request<BoxAPI.Comment> {
            .put(path, query: makePutQuery(fields), body: ["message": message])
        }

        private func makePutQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        /// Remove comment
        ///
        /// Permanently deletes a comment.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var devicePinners: DevicePinners {
        DevicePinners(path: "/device_pinners")
    }

    public struct DevicePinners {
        /// Path: `/device_pinners`
        public let path: String
    }
}

extension Paths.DevicePinners {
    public func devicePinnerID(_ devicePinnerID: String) -> WithDevicePinnerID {
        WithDevicePinnerID(path: "\(path)/\(devicePinnerID)")
    }

    public struct WithDevicePinnerID {
        /// Path: `/device_pinners/{device_pinner_id}`
        public let path: String

        /// Get device pin
        ///
        /// Retrieves information about an individual device pin.
        public var get: Request<BoxAPI.DevicePinner> {
            .get(path)
        }

        /// Remove device pin
        ///
        /// Deletes an individual device pin.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var enterprises: Enterprises {
        Enterprises(path: "/enterprises")
    }

    public struct Enterprises {
        /// Path: `/enterprises`
        public let path: String
    }
}

extension Paths.Enterprises {
    public func enterpriseID(_ enterpriseID: String) -> WithEnterpriseID {
        WithEnterpriseID(path: "\(path)/\(enterpriseID)")
    }

    public struct WithEnterpriseID {
        /// Path: `/enterprises/{enterprise_id}`
        public let path: String
    }
}

extension Paths.Enterprises.WithEnterpriseID {
    public var devicePinners: DevicePinners {
        DevicePinners(path: path + "/device_pinners")
    }

    public struct DevicePinners {
        /// Path: `/enterprises/{enterprise_id}/device_pinners`
        public let path: String

        /// List enterprise device pins
        ///
        /// Retrieves all the device pins within an enterprise.
        /// 
        /// The user must have admin privileges, and the application
        /// needs the "manage enterprise" scope to make this call.
        public func get(parameters: GetParameters? = nil) -> Request<BoxAPI.DevicePinners> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var marker: String?
            public var limit: Int?
            public var direction: Direction?

            public enum Direction: String, Codable, CaseIterable {
                case asc = "ASC"
                case desc = "DESC"
            }

            public init(marker: String? = nil, limit: Int? = nil, direction: Direction? = nil) {
                self.marker = marker
                self.limit = limit
                self.direction = direction
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(marker, forKey: "marker")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(direction, forKey: "direction")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var events: Events {
        Events(path: "/events")
    }

    public struct Events {
        /// Path: `/events`
        public let path: String

        /// List user and enterprise events
        ///
        /// Returns up to a year of past events for a given user
        /// or for the entire enterprise.
        /// 
        /// By default this returns events for the authenticated user. To retrieve
        /// events for the entire enterprise, set the `stream_type` to `admin_logs`.
        /// The user making the API call will need to have admin privileges, and
        /// the application will need to have the permission to access the event feed
        /// to get the enterprise event feed.
        public func get(parameters: GetParameters? = nil) -> Request<BoxAPI.Events> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var streamType: StreamType?
            public var streamPosition: String?
            public var limit: Int?
            public var eventType: [EventType]?
            public var createdAfter: Date?
            public var createdBefore: Date?

            public enum StreamType: String, Codable, CaseIterable {
                case all
                case changes
                case sync
                case adminLogs = "admin_logs"
            }

            /// An event type that can be filtered by
            public enum EventType: String, Codable, CaseIterable {
                case accessGranted = "ACCESS_GRANTED"
                case accessRevoked = "ACCESS_REVOKED"
                case addDeviceAssociation = "ADD_DEVICE_ASSOCIATION"
                case addLoginActivityDevice = "ADD_LOGIN_ACTIVITY_DEVICE"
                case adminLogin = "ADMIN_LOGIN"
                case applicationCreated = "APPLICATION_CREATED"
                case applicationPublicKeyAdded = "APPLICATION_PUBLIC_KEY_ADDED"
                case applicationPublicKeyDeleted = "APPLICATION_PUBLIC_KEY_DELETED"
                case changeAdminRole = "CHANGE_ADMIN_ROLE"
                case changeFolderPermission = "CHANGE_FOLDER_PERMISSION"
                case collaborationAccept = "COLLABORATION_ACCEPT"
                case collaborationExpiration = "COLLABORATION_EXPIRATION"
                case collaborationInvite = "COLLABORATION_INVITE"
                case collaborationRemove = "COLLABORATION_REMOVE"
                case collaborationRoleChange = "COLLABORATION_ROLE_CHANGE"
                case commentCreate = "COMMENT_CREATE"
                case commentDelete = "COMMENT_DELETE"
                case contentWorkflowAbnormalDownloadActivity = "CONTENT_WORKFLOW_ABNORMAL_DOWNLOAD_ACTIVITY"
                case contentWorkflowAutomationAdd = "CONTENT_WORKFLOW_AUTOMATION_ADD"
                case contentWorkflowAutomationDelete = "CONTENT_WORKFLOW_AUTOMATION_DELETE"
                case contentWorkflowPolicyAdd = "CONTENT_WORKFLOW_POLICY_ADD"
                case contentWorkflowSharingPolicyViolation = "CONTENT_WORKFLOW_SHARING_POLICY_VIOLATION"
                case contentWorkflowUploadPolicyViolation = "CONTENT_WORKFLOW_UPLOAD_POLICY_VIOLATION"
                case copy = "COPY"
                case dataRetentionCreateRetention = "DATA_RETENTION_CREATE_RETENTION"
                case dataRetentionRemoveRetention = "DATA_RETENTION_REMOVE_RETENTION"
                case delete = "DELETE"
                case deleteUser = "DELETE_USER"
                case deviceTrustCheckFailed = "DEVICE_TRUST_CHECK_FAILED"
                case download = "DOWNLOAD"
                case edit = "EDIT"
                case editUser = "EDIT_USER"
                case emailAliasConfirm = "EMAIL_ALIAS_CONFIRM"
                case emailAliasRemove = "EMAIL_ALIAS_REMOVE"
                case enterpriseAppAuthorizationUpdate = "ENTERPRISE_APP_AUTHORIZATION_UPDATE"
                case externalCollabSecuritySettings = "EXTERNAL_COLLAB_SECURITY_SETTINGS"
                case failedLogin = "FAILED_LOGIN"
                case fileMarkedMalicious = "FILE_MARKED_MALICIOUS"
                case fileWatermarkedDownload = "FILE_WATERMARKED_DOWNLOAD"
                case groupAddItem = "GROUP_ADD_ITEM"
                case groupAddUser = "GROUP_ADD_USER"
                case groupCreation = "GROUP_CREATION"
                case groupDeletion = "GROUP_DELETION"
                case groupEdited = "GROUP_EDITED"
                case groupRemoveItem = "GROUP_REMOVE_ITEM"
                case groupRemoveUser = "GROUP_REMOVE_USER"
                case itemModify = "ITEM_MODIFY"
                case itemOpen = "ITEM_OPEN"
                case itemSharedUpdate = "ITEM_SHARED_UPDATE"
                case itemSync = "ITEM_SYNC"
                case itemUnsync = "ITEM_UNSYNC"
                case legalHoldAssignmentCreate = "LEGAL_HOLD_ASSIGNMENT_CREATE"
                case legalHoldAssignmentDelete = "LEGAL_HOLD_ASSIGNMENT_DELETE"
                case legalHoldPolicyCreate = "LEGAL_HOLD_POLICY_CREATE"
                case legalHoldPolicyDelete = "LEGAL_HOLD_POLICY_DELETE"
                case legalHoldPolicyUpdate = "LEGAL_HOLD_POLICY_UPDATE"
                case lock = "LOCK"
                case login = "LOGIN"
                case metadataInstanceCreate = "METADATA_INSTANCE_CREATE"
                case metadataInstanceDelete = "METADATA_INSTANCE_DELETE"
                case metadataInstanceUpdate = "METADATA_INSTANCE_UPDATE"
                case metadataTemplateCreate = "METADATA_TEMPLATE_CREATE"
                case metadataTemplateDelete = "METADATA_TEMPLATE_DELETE"
                case metadataTemplateUpdate = "METADATA_TEMPLATE_UPDATE"
                case move = "MOVE"
                case newUser = "NEW_USER"
                case oauth2AccessTokenRevoke = "OAUTH2_ACCESS_TOKEN_REVOKE"
                case preview = "PREVIEW"
                case removeDeviceAssociation = "REMOVE_DEVICE_ASSOCIATION"
                case removeLoginActivityDevice = "REMOVE_LOGIN_ACTIVITY_DEVICE"
                case rename = "RENAME"
                case retentionPolicyAssignmentAdd = "RETENTION_POLICY_ASSIGNMENT_ADD"
                case share = "SHARE"
                case shareExpiration = "SHARE_EXPIRATION"
                case shieldAlert = "SHIELD_ALERT"
                case storageExpiration = "STORAGE_EXPIRATION"
                case taskAssignmentCreate = "TASK_ASSIGNMENT_CREATE"
                case taskAssignmentDelete = "TASK_ASSIGNMENT_DELETE"
                case taskAssignmentUpdate = "TASK_ASSIGNMENT_UPDATE"
                case taskCreate = "TASK_CREATE"
                case taskUpdate = "TASK_UPDATE"
                case termsOfServiceAccept = "TERMS_OF_SERVICE_ACCEPT"
                case termsOfServiceReject = "TERMS_OF_SERVICE_REJECT"
                case undelete = "UNDELETE"
                case unlock = "UNLOCK"
                case unshare = "UNSHARE"
                case updateCollaborationExpiration = "UPDATE_COLLABORATION_EXPIRATION"
                case updateShareExpiration = "UPDATE_SHARE_EXPIRATION"
                case upload = "UPLOAD"
                case userAuthenticateOauth2AccessTokenCreate = "USER_AUTHENTICATE_OAUTH2_ACCESS_TOKEN_CREATE"
                case watermarkLabelCreate = "WATERMARK_LABEL_CREATE"
                case watermarkLabelDelete = "WATERMARK_LABEL_DELETE"
            }

            public init(streamType: StreamType? = nil, streamPosition: String? = nil, limit: Int? = nil, eventType: [EventType]? = nil, createdAfter: Date? = nil, createdBefore: Date? = nil) {
                self.streamType = streamType
                self.streamPosition = streamPosition
                self.limit = limit
                self.eventType = eventType
                self.createdAfter = createdAfter
                self.createdBefore = createdBefore
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(streamType, forKey: "stream_type")
                encoder.encode(streamPosition, forKey: "stream_position")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(eventType, forKey: "event_type", explode: false)
                encoder.encode(createdAfter, forKey: "created_after")
                encoder.encode(createdBefore, forKey: "created_before")
                return encoder.items
            }
        }

        /// Get events long poll endpoint
        ///
        /// Returns a list of real-time servers that can be used for long-polling updates
        /// to the [event stream](#get-events).
        /// 
        /// Long polling is the concept where a HTTP request is kept open until the
        /// server sends a response, then repeating the process over and over to receive
        /// updated responses.
        /// 
        /// Long polling the event stream can only be used for user events, not for
        /// enterprise events.
        /// 
        /// To use long polling, first use this endpoint to retrieve a list of long poll
        /// URLs. Next, make a long poll request to any of the provided URLs.
        /// 
        /// When an event occurs in monitored account a response with the value
        /// `new_change` will be sent. The response contains no other details as
        /// it only serves as a prompt to take further action such as sending a
        /// request to the [events endpoint](#get-events) with the last known
        /// `stream_position`.
        /// 
        /// After the server sends this response it closes the connection. You must now
        /// repeat the long poll process to begin listening for events again.
        /// 
        /// If no events occur for a while and the connection times out you will
        /// receive a response with the value `reconnect`. When you receive this response
        /// youâ€™ll make another call to this endpoint to restart the process.
        /// 
        /// If you receive no events in `retry_timeout` seconds then you will need to
        /// make another request to the real-time server (one of the URLs in the response
        /// for this endpoint). This might be necessary due to network errors.
        /// 
        /// Finally, if you receive a `max_retries` error when making a request to the
        /// real-time server, you should start over by making a call to this endpoint
        /// first.
        public var options: Request<BoxAPI.RealtimeServers> {
            .options(path)
        }
    }
}

extension Paths {
    public static var fileRequests: FileRequests {
        FileRequests(path: "/file_requests")
    }

    public struct FileRequests {
        /// Path: `/file_requests`
        public let path: String
    }
}

extension Paths.FileRequests {
    public func fileRequestID(_ fileRequestID: String) -> WithFileRequestID {
        WithFileRequestID(path: "\(path)/\(fileRequestID)")
    }

    public struct WithFileRequestID {
        /// Path: `/file_requests/{file_request_id}`
        public let path: String

        /// Get file request
        ///
        /// Retrieves the information about a file request.
        public var get: Request<BoxAPI.FileRequest> {
            .get(path)
        }

        /// Update file request
        ///
        /// Updates a file request. This can be used to activate or
        /// deactivate a file request.
        public func put(_ body: BoxAPI.FileRequestUpdateRequest? = nil) -> Request<BoxAPI.FileRequest> {
            .put(path, body: body)
        }

        /// Delete file request
        ///
        /// Deletes a file request permanently.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.FileRequests.WithFileRequestID {
    public var copy: Copy {
        Copy(path: path + "/copy")
    }

    public struct Copy {
        /// Path: `/file_requests/{file_request_id}/copy`
        public let path: String

        /// Copy file request
        ///
        /// Copies an existing file request that is already present on one folder,
        /// and applies it to another folder.
        public func post(_ body: BoxAPI.FileRequestCopyRequest? = nil) -> Request<BoxAPI.FileRequest> {
            .post(path, body: body)
        }
    }
}

extension Paths {
    public static var fileVersionLegalHolds: FileVersionLegalHolds {
        FileVersionLegalHolds(path: "/file_version_legal_holds")
    }

    public struct FileVersionLegalHolds {
        /// Path: `/file_version_legal_holds`
        public let path: String

        /// List file version legal holds
        ///
        /// Get a list of file versions on legal hold for a legal hold
        /// assignment.
        /// 
        /// Due to ongoing re-architecture efforts this API might not return all file
        /// versions for this policy ID.
        /// 
        /// Instead, this API will only return file versions held in the legacy
        /// architecture. Two new endpoints will available to request any file versions
        /// held in the new architecture.
        /// 
        /// For file versions held in the new architecture, the `GET
        /// /legal_hold_policy_assignments/:id/file_versions_on_hold` API can be used to
        /// return all past file versions available for this policy assignment, and the
        /// `GET /legal_hold_policy_assignments/:id/files_on_hold` API can be used to
        /// return any current (latest) versions of a file under legal hold.
        /// 
        /// The `GET /legal_hold_policy_assignments?policy_id={id}` API can be used to
        /// find a list of policy assignments for a given policy ID.
        /// 
        /// Once the re-architecture is completed this API will be deprecated.
        public func get(parameters: GetParameters) -> Request<BoxAPI.FileVersionLegalHolds> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var policyID: String
            public var marker: String?
            public var limit: Int?

            public init(policyID: String, marker: String? = nil, limit: Int? = nil) {
                self.policyID = policyID
                self.marker = marker
                self.limit = limit
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(policyID, forKey: "policy_id")
                encoder.encode(marker, forKey: "marker")
                encoder.encode(limit, forKey: "limit")
                return encoder.items
            }
        }
    }
}

extension Paths.FileVersionLegalHolds {
    public func fileVersionLegalHoldID(_ fileVersionLegalHoldID: String) -> WithFileVersionLegalHoldID {
        WithFileVersionLegalHoldID(path: "\(path)/\(fileVersionLegalHoldID)")
    }

    public struct WithFileVersionLegalHoldID {
        /// Path: `/file_version_legal_holds/{file_version_legal_hold_id}`
        public let path: String

        /// Get file version legal hold
        ///
        /// Retrieves information about the legal hold policies
        /// assigned to a file version.
        public var get: Request<BoxAPI.FileVersionLegalHold> {
            .get(path)
        }
    }
}

extension Paths {
    public static var fileVersionRetentions: FileVersionRetentions {
        FileVersionRetentions(path: "/file_version_retentions")
    }

    public struct FileVersionRetentions {
        /// Path: `/file_version_retentions`
        public let path: String
    }
}

extension Paths.FileVersionRetentions {
    public func fileVersionRetentionID(_ fileVersionRetentionID: String) -> WithFileVersionRetentionID {
        WithFileVersionRetentionID(path: "\(path)/\(fileVersionRetentionID)")
    }

    public struct WithFileVersionRetentionID {
        /// Path: `/file_version_retentions/{file_version_retention_id}`
        public let path: String

        /// Get retention on file
        ///
        /// Returns information about a file version retention.
        public var get: Request<BoxAPI.FileVersionRetention> {
            .get(path)
        }
    }
}

extension Paths {
    public static var files: Files {
        Files(path: "/files")
    }

    public struct Files {
        /// Path: `/files`
        public let path: String
    }
}

extension Paths.Files {
    public var content: Content {
        Content(path: path + "/content")
    }

    public struct Content {
        /// Path: `/files/content`
        public let path: String

        /// Upload file
        ///
        /// Uploads a small file to Box. For file sizes over 50MB we recommend
        /// using the Chunk Upload APIs.
        /// 
        /// # Request body order
        /// 
        /// The `attributes` part of the body must come **before** the
        /// `file` part. Requests that do not follow this format when
        /// uploading the file will receive a HTTP `400` error with a
        /// `metadata_after_file_contents` error code.
        public func post(fields: [String]? = nil, _ body: Data? = nil) -> Request<BoxAPI.Files> {
            .post(path, query: makePostQuery(fields), body: body)
        }

        private func makePostQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }
    }
}

extension Paths.Files {
    public var uploadSessions: UploadSessions {
        UploadSessions(path: path + "/upload_sessions")
    }

    public struct UploadSessions {
        /// Path: `/files/upload_sessions`
        public let path: String

        /// Create upload session
        ///
        /// Creates an upload session for a new file.
        public func post(_ body: PostRequest? = nil) -> Request<BoxAPI.UploadSession> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The name of new file
            ///
            /// Example: "Project.mov"
            public var fileName: String
            /// The total number of bytes of the file to be uploaded
            ///
            /// Example: 104857600
            public var fileSize: Int
            /// The ID of the folder to upload the new file to.
            ///
            /// Example: "0"
            public var folderID: String

            public init(fileName: String, fileSize: Int, folderID: String) {
                self.fileName = fileName
                self.fileSize = fileSize
                self.folderID = folderID
            }

            private enum CodingKeys: String, CodingKey {
                case fileName = "file_name"
                case fileSize = "file_size"
                case folderID = "folder_id"
            }
        }
    }
}

extension Paths.Files.UploadSessions {
    public func uploadSessionID(_ uploadSessionID: String) -> WithUploadSessionID {
        WithUploadSessionID(path: "\(path)/\(uploadSessionID)")
    }

    public struct WithUploadSessionID {
        /// Path: `/files/upload_sessions/{upload_session_id}`
        public let path: String

        /// Get upload session
        ///
        /// Return information about an upload session.
        public var get: Request<BoxAPI.UploadSession> {
            .get(path)
        }

        /// Upload part of file
        ///
        /// Updates a chunk of an upload session for a file.
        public func put(_ body: Data? = nil) -> Request<BoxAPI.UploadedPart> {
            .put(path, body: body)
        }

        /// Remove upload session
        ///
        /// Abort an upload session and discard all data uploaded.
        /// 
        /// This cannot be reversed.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Files.UploadSessions.WithUploadSessionID {
    public var commit: Commit {
        Commit(path: path + "/commit")
    }

    public struct Commit {
        /// Path: `/files/upload_sessions/{upload_session_id}/commit`
        public let path: String

        /// Commit upload session
        ///
        /// Close an upload session and create a file from the
        /// uploaded chunks.
        public func post(parts: [BoxAPI.UploadPart]) -> Request<BoxAPI.Files> {
            .post(path, body: ["parts": parts])
        }
    }
}

extension Paths.Files.UploadSessions.WithUploadSessionID {
    public var parts: Parts {
        Parts(path: path + "/parts")
    }

    public struct Parts {
        /// Path: `/files/upload_sessions/{upload_session_id}/parts`
        public let path: String

        /// List parts
        ///
        /// Return a list of the chunks uploaded to the upload
        /// session so far.
        public func get(offset: Int? = nil, limit: Int? = nil) -> Request<BoxAPI.UploadParts> {
            .get(path, query: makeGetQuery(offset, limit))
        }

        private func makeGetQuery(_ offset: Int?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(offset, forKey: "offset")
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths.Files {
    public func fileID(_ fileID: String) -> WithFileID {
        WithFileID(path: "\(path)/\(fileID)")
    }

    public struct WithFileID {
        /// Path: `/files/{file_id}`
        public let path: String

        /// Get file information
        ///
        /// Retrieves the details about a file.
        public func get(fields: [String]? = nil) -> Request<BoxAPI.File> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        /// Restore file
        ///
        /// Restores a file that has been moved to the trash.
        /// 
        /// An optional new parent ID can be provided to restore the file to in case the
        /// original folder has been deleted.
        public func post(fields: [String]? = nil, _ body: PostRequest? = nil) -> Request<BoxAPI.File> {
            .post(path, query: makePostQuery(fields), body: body)
        }

        private func makePostQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        public struct PostRequest: Encodable {
            /// An optional new name for the file.
            ///
            /// Example: "Restored.docx"
            public var name: String?
            public var parent: Parent?

            public struct Parent: Encodable {
                /// The ID of parent item
                ///
                /// Example: "123"
                public var id: String?
                /// Specifies an optional ID of a folder to restore the file to
                /// when the original folder no longer exists.
                /// 
                /// Please be aware that this ID will only be used if the original
                /// folder no longer exists. Use this ID to provide a fallback
                /// location to restore the file to if the original location
                /// has been deleted.
                public var anyJSON: AnyJSON

                public init(id: String? = nil, anyJSON: AnyJSON) {
                    self.id = id
                    self.anyJSON = anyJSON
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(id, forKey: "id")
                    try values.encode(anyJSON, forKey: "anyJSON")
                }
            }

            public init(name: String? = nil, parent: Parent? = nil) {
                self.name = name
                self.parent = parent
            }
        }

        /// Update file
        ///
        /// Updates a file. This can be used to rename or move a file,
        /// create a shared link, or lock a file.
        public func put(fields: [String]? = nil, _ body: PutRequest? = nil) -> Request<BoxAPI.File> {
            .put(path, query: makePutQuery(fields), body: body)
        }

        private func makePutQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        public struct PutRequest: Encodable {
            /// The description for a file. This can be seen in the right-hand sidebar panel
            /// when viewing a file in the Box web app. Additionally, this index is used in
            /// the search index of the file, allowing users to find the file by the content
            /// in the description.
            ///
            /// Example: "The latest reports. Automatically updated"
            public var description: String?
            /// Defines a lock on an item. This prevents the item from being
            /// moved, renamed, or otherwise changed by anyone other than the user
            /// who created the lock.
            /// 
            /// Set this to `null` to remove the lock.
            public var lock: Lock?
            /// An optional different name for the file. This can be used to
            /// rename the file.
            ///
            /// Example: "NewFile.txt"
            public var name: String?
            public var parent: Parent?
            /// Defines who can download a file.
            public var permissions: Permissions?
            public var sharedLink: SharedLink?
            /// The tags for this item. These tags are shown in
            /// the Box web app and mobile apps next to an item.
            /// 
            /// To add or remove a tag, retrieve the item's current tags,
            /// modify them, and then update this field.
            /// 
            /// There is a limit of 100 tags per item, and 10,000
            /// unique tags per enterprise.
            ///
            /// Example: ["approved"]
            public var tags: [String]?

            /// Defines a lock on an item. This prevents the item from being
            /// moved, renamed, or otherwise changed by anyone other than the user
            /// who created the lock.
            /// 
            /// Set this to `null` to remove the lock.
            public struct Lock: Encodable {
                /// The type of this object.
                ///
                /// Example: "lock"
                public var access: Access?
                /// Defines the time at which the lock expires.
                ///
                /// Example: "2012-12-12T10:53:43-08:00"
                public var expiresAt: Date?
                /// Defines if the file can be downloaded while it is locked.
                ///
                /// Example: true
                public var isDownloadPrevented: Bool?
                public var type: AnyJSON

                /// The type of this object.
                ///
                /// Example: "lock"
                public enum Access: String, Codable, CaseIterable {
                    case lock
                }

                public init(access: Access? = nil, expiresAt: Date? = nil, isDownloadPrevented: Bool? = nil, type: AnyJSON) {
                    self.access = access
                    self.expiresAt = expiresAt
                    self.isDownloadPrevented = isDownloadPrevented
                    self.type = type
                }

                private enum CodingKeys: String, CodingKey {
                    case access
                    case expiresAt = "expires_at"
                    case isDownloadPrevented = "is_download_prevented"
                    case type
                }
            }

            public struct Parent: Encodable {
                /// The ID of parent item
                ///
                /// Example: "123"
                public var id: String?
                /// An optional new parent folder for the file. This can be used
                /// to move the file to a new folder.
                public var anyJSON: AnyJSON

                public init(id: String? = nil, anyJSON: AnyJSON) {
                    self.id = id
                    self.anyJSON = anyJSON
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(id, forKey: "id")
                    try values.encode(anyJSON, forKey: "anyJSON")
                }
            }

            /// Defines who can download a file.
            public struct Permissions: Encodable {
                /// Defines who is allowed to download this file. The possible
                /// values are either `open` for everyone or `company` for
                /// the other members of the user's enterprise.
                /// 
                /// This setting overrides the download permissions that are
                /// normally part of the `role` of a collaboration. When set to
                /// `company`, this essentially removes the download option for
                /// external users with `viewer` or `editor` a roles.
                ///
                /// Example: "open"
                public var canDownload: CanDownload?

                /// Defines who is allowed to download this file. The possible
                /// values are either `open` for everyone or `company` for
                /// the other members of the user's enterprise.
                /// 
                /// This setting overrides the download permissions that are
                /// normally part of the `role` of a collaboration. When set to
                /// `company`, this essentially removes the download option for
                /// external users with `viewer` or `editor` a roles.
                ///
                /// Example: "open"
                public enum CanDownload: String, Codable, CaseIterable {
                    case `open`
                    case company
                }

                public init(canDownload: CanDownload? = nil) {
                    self.canDownload = canDownload
                }

                private enum CodingKeys: String, CodingKey {
                    case canDownload = "can_download"
                }
            }

            public struct SharedLink: Encodable {
                /// The level of access for the shared link. This can be
                /// restricted to anyone with the link (`open`), only people
                /// within the company (`company`) and only those who
                /// have been invited to the folder (`collaborators`).
                /// 
                /// If not set, this field defaults to the access level specified
                /// by the enterprise admin. To create a shared link with this
                /// default setting pass the `shared_link` object with
                /// no `access` field, for example `{ "shared_link": {} }`.
                /// 
                /// The `company` access level is only available to paid
                /// accounts.
                ///
                /// Example: "open"
                public var access: Access?
                /// The password required to access the shared link. Set the
                /// password to `null` to remove it.
                /// 
                /// A password can only be set when `access` is set to `open`.
                ///
                /// Example: "do-not-use-this-password"
                public var password: String?
                public var permissions: Permissions?
                /// The timestamp at which this shared link will
                /// expire. This field can only be set by
                /// users with paid accounts.
                ///
                /// Example: "2012-12-12T10:53:43-08:00"
                public var unsharedAt: Date?
                /// Defines a custom vanity name to use in the shared link URL,
                /// for example `https://app.box.com/v/my-shared-link`.
                /// 
                /// Custom URLs should not be used when sharing sensitive content
                /// as vanity URLs are a lot easier to guess than regular shared links.
                ///
                /// Example: "my-shared-link"
                public var vanityName: String?
                /// Defines a shared link for a file. Set this to `null` to remove
                /// the shared link.
                public var anyJSON: AnyJSON

                /// The level of access for the shared link. This can be
                /// restricted to anyone with the link (`open`), only people
                /// within the company (`company`) and only those who
                /// have been invited to the folder (`collaborators`).
                /// 
                /// If not set, this field defaults to the access level specified
                /// by the enterprise admin. To create a shared link with this
                /// default setting pass the `shared_link` object with
                /// no `access` field, for example `{ "shared_link": {} }`.
                /// 
                /// The `company` access level is only available to paid
                /// accounts.
                ///
                /// Example: "open"
                public enum Access: String, Codable, CaseIterable {
                    case `open`
                    case company
                    case collaborators
                }

                public struct Permissions: Encodable {
                    /// If the shared link allows for downloading of files.
                    /// This can only be set when `access` is set to
                    /// `open` or `company`.
                    ///
                    /// Example: true
                    public var canDownload: Bool?

                    public init(canDownload: Bool? = nil) {
                        self.canDownload = canDownload
                    }

                    private enum CodingKeys: String, CodingKey {
                        case canDownload = "can_download"
                    }
                }

                public init(access: Access? = nil, password: String? = nil, permissions: Permissions? = nil, unsharedAt: Date? = nil, vanityName: String? = nil, anyJSON: AnyJSON) {
                    self.access = access
                    self.password = password
                    self.permissions = permissions
                    self.unsharedAt = unsharedAt
                    self.vanityName = vanityName
                    self.anyJSON = anyJSON
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(access, forKey: "access")
                    try values.encodeIfPresent(password, forKey: "password")
                    try values.encodeIfPresent(permissions, forKey: "permissions")
                    try values.encodeIfPresent(unsharedAt, forKey: "unshared_at")
                    try values.encodeIfPresent(vanityName, forKey: "vanity_name")
                    try values.encode(anyJSON, forKey: "anyJSON")
                }
            }

            public init(description: String? = nil, lock: Lock? = nil, name: String? = nil, parent: Parent? = nil, permissions: Permissions? = nil, sharedLink: SharedLink? = nil, tags: [String]? = nil) {
                self.description = description
                self.lock = lock
                self.name = name
                self.parent = parent
                self.permissions = permissions
                self.sharedLink = sharedLink
                self.tags = tags
            }

            private enum CodingKeys: String, CodingKey {
                case description
                case lock
                case name
                case parent
                case permissions
                case sharedLink = "shared_link"
                case tags
            }
        }

        /// Delete file
        ///
        /// Deletes a file, either permanently or by moving it to
        /// the trash.
        /// 
        /// The the enterprise settings determine whether the item will
        /// be permanently deleted from Box or moved to the trash.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Files {
    public func fileID(_ fileID: String) -> WithAddSharedLink {
        WithAddSharedLink(path: "\(path)/\(fileID)#add_shared_link")
    }

    public struct WithAddSharedLink {
        /// Path: `/files/{file_id}#add_shared_link`
        public let path: String

        /// Add shared link to file
        ///
        /// Adds a shared link to a file.
        public func put(fields: String, sharedLink: PutRequest.SharedLink? = nil) -> Request<BoxAPI.File> {
            .put(path, query: [("fields", fields)], body: PutRequest(sharedLink: sharedLink))
        }

        public struct PutRequest: Encodable {
            /// The settings for the shared link to create on the file.
            /// 
            /// Use an empty object (`{}`) to use the default settings for shared
            /// links.
            public var sharedLink: SharedLink?

            /// The settings for the shared link to create on the file.
            /// 
            /// Use an empty object (`{}`) to use the default settings for shared
            /// links.
            public struct SharedLink: Encodable {
                /// The level of access for the shared link. This can be
                /// restricted to anyone with the link (`open`), only people
                /// within the company (`company`) and only those who
                /// have been invited to the file (`collaborators`).
                /// 
                /// If not set, this field defaults to the access level specified
                /// by the enterprise admin. To create a shared link with this
                /// default setting pass the `shared_link` object with
                /// no `access` field, for example `{ "shared_link": {} }`.
                /// 
                /// The `company` access level is only available to paid
                /// accounts.
                ///
                /// Example: "open"
                public var access: Access?
                /// The password required to access the shared link. Set the
                /// password to `null` to remove it.
                /// 
                /// A password can only be set when `access` is set to `open`.
                ///
                /// Example: "do-not-use-this-password"
                public var password: String?
                public var permissions: Permissions?
                /// The timestamp at which this shared link will
                /// expire. This field can only be set by
                /// users with paid accounts. The value must be greater than the
                /// current date and time.
                ///
                /// Example: "2012-12-12T10:53:43-08:00"
                public var unsharedAt: Date?
                /// Defines a custom vanity name to use in the shared link URL,
                /// for example `https://app.box.com/v/my-shared-link`.
                /// 
                /// Custom URLs should not be used when sharing sensitive content
                /// as vanity URLs are a lot easier to guess than regular shared
                /// links.
                ///
                /// Example: "my-shared-link"
                public var vanityName: String?

                /// The level of access for the shared link. This can be
                /// restricted to anyone with the link (`open`), only people
                /// within the company (`company`) and only those who
                /// have been invited to the file (`collaborators`).
                /// 
                /// If not set, this field defaults to the access level specified
                /// by the enterprise admin. To create a shared link with this
                /// default setting pass the `shared_link` object with
                /// no `access` field, for example `{ "shared_link": {} }`.
                /// 
                /// The `company` access level is only available to paid
                /// accounts.
                ///
                /// Example: "open"
                public enum Access: String, Codable, CaseIterable {
                    case `open`
                    case company
                    case collaborators
                }

                public struct Permissions: Encodable {
                    /// If the shared link allows for downloading of files.
                    /// This can only be set when `access` is set to
                    /// `open` or `company`.
                    ///
                    /// Example: true
                    public var canDownload: Bool?

                    public init(canDownload: Bool? = nil) {
                        self.canDownload = canDownload
                    }

                    private enum CodingKeys: String, CodingKey {
                        case canDownload = "can_download"
                    }
                }

                public init(access: Access? = nil, password: String? = nil, permissions: Permissions? = nil, unsharedAt: Date? = nil, vanityName: String? = nil) {
                    self.access = access
                    self.password = password
                    self.permissions = permissions
                    self.unsharedAt = unsharedAt
                    self.vanityName = vanityName
                }

                private enum CodingKeys: String, CodingKey {
                    case access
                    case password
                    case permissions
                    case unsharedAt = "unshared_at"
                    case vanityName = "vanity_name"
                }
            }

            public init(sharedLink: SharedLink? = nil) {
                self.sharedLink = sharedLink
            }

            private enum CodingKeys: String, CodingKey {
                case sharedLink = "shared_link"
            }
        }
    }
}

extension Paths.Files {
    public func fileID(_ fileID: String) -> WithGetSharedLink {
        WithGetSharedLink(path: "\(path)/\(fileID)#get_shared_link")
    }

    public struct WithGetSharedLink {
        /// Path: `/files/{file_id}#get_shared_link`
        public let path: String

        /// Get shared link for file
        ///
        /// Gets the information for a shared link on a file.
        public func get(fields: String) -> Request<BoxAPI.File> {
            .get(path, query: [("fields", fields)])
        }
    }
}

extension Paths.Files {
    public func fileID(_ fileID: String) -> WithRemoveSharedLink {
        WithRemoveSharedLink(path: "\(path)/\(fileID)#remove_shared_link")
    }

    public struct WithRemoveSharedLink {
        /// Path: `/files/{file_id}#remove_shared_link`
        public let path: String

        /// Remove shared link from file
        ///
        /// Removes a shared link from a file.
        public func put(fields: String, sharedLink: [String: AnyJSON]? = nil) -> Request<BoxAPI.File> {
            .put(path, query: [("fields", fields)], body: ["shared_link": sharedLink])
        }
    }
}

extension Paths.Files {
    public func fileID(_ fileID: String) -> WithUpdateSharedLink {
        WithUpdateSharedLink(path: "\(path)/\(fileID)#update_shared_link")
    }

    public struct WithUpdateSharedLink {
        /// Path: `/files/{file_id}#update_shared_link`
        public let path: String

        /// Update shared link on file
        ///
        /// Updates a shared link on a file.
        public func put(fields: String, sharedLink: PutRequest.SharedLink? = nil) -> Request<BoxAPI.File> {
            .put(path, query: [("fields", fields)], body: PutRequest(sharedLink: sharedLink))
        }

        public struct PutRequest: Encodable {
            /// The settings for the shared link to update.
            public var sharedLink: SharedLink?

            /// The settings for the shared link to update.
            public struct SharedLink: Encodable {
                /// The level of access for the shared link. This can be
                /// restricted to anyone with the link (`open`), only people
                /// within the company (`company`) and only those who
                /// have been invited to the folder (`collaborators`).
                /// 
                /// If not set, this field defaults to the access level specified
                /// by the enterprise admin. To create a shared link with this
                /// default setting pass the `shared_link` object with
                /// no `access` field, for example `{ "shared_link": {} }`.
                /// 
                /// The `company` access level is only available to paid
                /// accounts.
                ///
                /// Example: "open"
                public var access: Access?
                /// The password required to access the shared link. Set the
                /// password to `null` to remove it.
                /// 
                /// A password can only be set when `access` is set to `open`.
                ///
                /// Example: "do-not-use-this-password"
                public var password: String?
                public var permissions: Permissions?
                /// The timestamp at which this shared link will
                /// expire. This field can only be set by
                /// users with paid accounts. The value must be greater than the
                /// current date and time.
                ///
                /// Example: "2012-12-12T10:53:43-08:00"
                public var unsharedAt: Date?
                /// Defines a custom vanity name to use in the shared link URL,
                /// for example `https://app.box.com/v/my-shared-link`.
                /// 
                /// Custom URLs should not be used when sharing sensitive content
                /// as vanity URLs are a lot easier to guess than regular shared
                /// links.
                ///
                /// Example: "my-shared-link"
                public var vanityName: String?

                /// The level of access for the shared link. This can be
                /// restricted to anyone with the link (`open`), only people
                /// within the company (`company`) and only those who
                /// have been invited to the folder (`collaborators`).
                /// 
                /// If not set, this field defaults to the access level specified
                /// by the enterprise admin. To create a shared link with this
                /// default setting pass the `shared_link` object with
                /// no `access` field, for example `{ "shared_link": {} }`.
                /// 
                /// The `company` access level is only available to paid
                /// accounts.
                ///
                /// Example: "open"
                public enum Access: String, Codable, CaseIterable {
                    case `open`
                    case company
                    case collaborators
                }

                public struct Permissions: Encodable {
                    /// If the shared link allows for downloading of files.
                    /// This can only be set when `access` is set to
                    /// `open` or `company`.
                    ///
                    /// Example: true
                    public var canDownload: Bool?

                    public init(canDownload: Bool? = nil) {
                        self.canDownload = canDownload
                    }

                    private enum CodingKeys: String, CodingKey {
                        case canDownload = "can_download"
                    }
                }

                public init(access: Access? = nil, password: String? = nil, permissions: Permissions? = nil, unsharedAt: Date? = nil, vanityName: String? = nil) {
                    self.access = access
                    self.password = password
                    self.permissions = permissions
                    self.unsharedAt = unsharedAt
                    self.vanityName = vanityName
                }

                private enum CodingKeys: String, CodingKey {
                    case access
                    case password
                    case permissions
                    case unsharedAt = "unshared_at"
                    case vanityName = "vanity_name"
                }
            }

            public init(sharedLink: SharedLink? = nil) {
                self.sharedLink = sharedLink
            }

            private enum CodingKeys: String, CodingKey {
                case sharedLink = "shared_link"
            }
        }
    }
}

extension Paths.Files.WithFileID {
    public var collaborations: Collaborations {
        Collaborations(path: path + "/collaborations")
    }

    public struct Collaborations {
        /// Path: `/files/{file_id}/collaborations`
        public let path: String

        /// List file collaborations
        ///
        /// Retrieves a list of pending and active collaborations for a
        /// file. This returns all the users that have access to the file
        /// or have been invited to the file.
        public func get(parameters: GetParameters? = nil) -> Request<BoxAPI.Collaborations> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var fields: [String]?
            public var limit: Int?
            public var marker: String?

            public init(fields: [String]? = nil, limit: Int? = nil, marker: String? = nil) {
                self.fields = fields
                self.limit = limit
                self.marker = marker
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields", explode: false)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(marker, forKey: "marker")
                return encoder.items
            }
        }
    }
}

extension Paths.Files.WithFileID {
    public var comments: Comments {
        Comments(path: path + "/comments")
    }

    public struct Comments {
        /// Path: `/files/{file_id}/comments`
        public let path: String

        /// List file comments
        ///
        /// Retrieves a list of comments for a file.
        public func get(parameters: GetParameters? = nil) -> Request<BoxAPI.Comments> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var fields: [String]?
            public var limit: Int?
            public var offset: Int?

            public init(fields: [String]? = nil, limit: Int? = nil, offset: Int? = nil) {
                self.fields = fields
                self.limit = limit
                self.offset = offset
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields", explode: false)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                return encoder.items
            }
        }
    }
}

extension Paths.Files.WithFileID {
    public var content: Content {
        Content(path: path + "/content")
    }

    public struct Content {
        /// Path: `/files/{file_id}/content`
        public let path: String

        /// Download file
        ///
        /// Returns the contents of a file in binary format.
        public func get(version: String? = nil, accessToken: String? = nil) -> Request<Void> {
            .get(path, query: makeGetQuery(version, accessToken))
        }

        public enum GetResponseHeaders {
            /// The time in seconds after which to retry the download
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }

        private func makeGetQuery(_ version: String?, _ accessToken: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(version, forKey: "version")
            encoder.encode(accessToken, forKey: "access_token")
            return encoder.items
        }

        /// Upload file version
        ///
        /// Update a file's content. For file sizes over 50MB we recommend
        /// using the Chunk Upload APIs.
        /// 
        /// # Request body order
        /// 
        /// The `attributes` part of the body must come **before** the
        /// `file` part. Requests that do not follow this format when
        /// uploading the file will receive a HTTP `400` error with a
        /// `metadata_after_file_contents` error code.
        public func post(fields: [String]? = nil, _ body: Data? = nil) -> Request<BoxAPI.Files> {
            .post(path, query: makePostQuery(fields), body: body)
        }

        private func makePostQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }
    }
}

extension Paths.Files.WithFileID {
    public var copy: Copy {
        Copy(path: path + "/copy")
    }

    public struct Copy {
        /// Path: `/files/{file_id}/copy`
        public let path: String

        /// Copy file
        ///
        /// Creates a copy of a file.
        public func post(fields: [String]? = nil, _ body: PostRequest? = nil) -> Request<BoxAPI.File> {
            .post(path, query: makePostQuery(fields), body: body)
        }

        private func makePostQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        public struct PostRequest: Encodable {
            /// An optional new name for the copied file.
            /// 
            /// There are some restrictions to the file name. Names containing
            /// non-printable ASCII characters, forward and backward slashes
            /// (`/`, `\`), and protected names like `.` and `..` are
            /// automatically sanitized by removing the non-allowed
            /// characters.
            ///
            /// Example: "FileCopy.txt"
            public var name: String?
            /// The destination folder to copy the file to.
            public var parent: Parent
            /// An optional ID of the specific file version to copy.
            ///
            /// Example: "0"
            public var version: String?

            /// The destination folder to copy the file to.
            public struct Parent: Encodable {
                /// The ID of folder to copy the file to.
                ///
                /// Example: "0"
                public var id: String

                public init(id: String) {
                    self.id = id
                }
            }

            public init(name: String? = nil, parent: Parent, version: String? = nil) {
                self.name = name
                self.parent = parent
                self.version = version
            }
        }
    }
}

extension Paths.Files.WithFileID {
    public var metadata: Metadata {
        Metadata(path: path + "/metadata")
    }

    public struct Metadata {
        /// Path: `/files/{file_id}/metadata`
        public let path: String

        /// List metadata instances on file
        ///
        /// Retrieves all metadata for a given file.
        public var get: Request<BoxAPI.Metadatas> {
            .get(path)
        }
    }
}

extension Paths.Files.WithFileID.Metadata {
    public var enterprise: Enterprise {
        Enterprise(path: path + "/enterprise")
    }

    public struct Enterprise {
        /// Path: `/files/{file_id}/metadata/enterprise`
        public let path: String
    }
}

extension Paths.Files.WithFileID.Metadata.Enterprise {
    public var securityClassification6VMVochwUWo: SecurityClassification6VMVochwUWo {
        SecurityClassification6VMVochwUWo(path: path + "/securityClassification-6VMVochwUWo")
    }

    public struct SecurityClassification6VMVochwUWo {
        /// Path: `/files/{file_id}/metadata/enterprise/securityClassification-6VMVochwUWo`
        public let path: String

        /// Get classification on file
        ///
        /// Retrieves the classification metadata instance that
        /// has been applied to a file.
        /// 
        /// This API can also be called by including the enterprise ID in the
        /// URL explicitly, for example
        /// `/files/:id//enterprise_12345/securityClassification-6VMVochwUWo`.
        public var get: Request<BoxAPI.Classification> {
            .get(path)
        }

        /// Add classification to file
        ///
        /// Adds a classification to a file by specifying the label of the
        /// classification to add.
        /// 
        /// This API can also be called by including the enterprise ID in the
        /// URL explicitly, for example
        /// `/files/:id//enterprise_12345/securityClassification-6VMVochwUWo`.
        public func post(boxSecurityClassificationKey: String? = nil) -> Request<BoxAPI.Classification> {
            .post(path, body: ["Box__Security__Classification__Key": boxSecurityClassificationKey])
        }

        /// Update classification on file
        ///
        /// Updates a classification on a file.
        /// 
        /// The classification can only be updated if a classification has already been
        /// applied to the file before. When editing classifications, only values are
        /// defined for the enterprise will be accepted.
        public func put(_ body: Data) -> Request<BoxAPI.Classification> {
            .put(path, body: body)
        }

        /// Remove classification from file
        ///
        /// Removes any classifications from a file.
        /// 
        /// This API can also be called by including the enterprise ID in the
        /// URL explicitly, for example
        /// `/files/:id//enterprise_12345/securityClassification-6VMVochwUWo`.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Files.WithFileID.Metadata {
    public var global: Global {
        Global(path: path + "/global")
    }

    public struct Global {
        /// Path: `/files/{file_id}/metadata/global`
        public let path: String
    }
}

extension Paths.Files.WithFileID.Metadata.Global {
    public var boxSkillsCards: BoxSkillsCards {
        BoxSkillsCards(path: path + "/boxSkillsCards")
    }

    public struct BoxSkillsCards {
        /// Path: `/files/{file_id}/metadata/global/boxSkillsCards`
        public let path: String

        /// List Box Skill cards on file
        ///
        /// List the Box Skills metadata cards that are attached to a file.
        public var get: Request<BoxAPI.SkillCardsMetadata> {
            .get(path)
        }

        /// Create Box Skill cards on file
        ///
        /// Applies one or more Box Skills metadata cards to a file.
        public func post(cards: [PostRequest.Card]) -> Request<BoxAPI.SkillCardsMetadata> {
            .post(path, body: PostRequest(cards: cards))
        }

        public struct PostRequest: Encodable {
            /// A list of Box Skill cards to apply to this file.
            public var cards: [Card]

            public enum Card: Encodable {
                case skillCard(BoxAPI.SkillCard)
                case keywordSkillCard(BoxAPI.KeywordSkillCard)
                case timelineSkillCard(BoxAPI.TimelineSkillCard)
                case transcriptSkillCard(BoxAPI.TranscriptSkillCard)
                case statusSkillCard(BoxAPI.StatusSkillCard)

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.singleValueContainer()
                    switch self {
                    case .skillCard(let value): try container.encode(value)
                    case .keywordSkillCard(let value): try container.encode(value)
                    case .timelineSkillCard(let value): try container.encode(value)
                    case .transcriptSkillCard(let value): try container.encode(value)
                    case .statusSkillCard(let value): try container.encode(value)
                    }
                }
            }

            public init(cards: [Card]) {
                self.cards = cards
            }
        }

        /// Update Box Skill cards on file
        ///
        /// Updates one or more Box Skills metadata cards to a file.
        public func put(_ body: Data) -> Request<BoxAPI.SkillCardsMetadata> {
            .put(path, body: body)
        }

        /// Remove Box Skill cards from file
        ///
        /// Removes any Box Skills cards metadata from a file.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Files.WithFileID.Metadata {
    public func scope(_ scope: String) -> WithScope {
        WithScope(path: "\(path)/\(scope)")
    }

    public struct WithScope {
        /// Path: `/files/{file_id}/metadata/{scope}`
        public let path: String
    }
}

extension Paths.Files.WithFileID.Metadata.WithScope {
    public func templateKey(_ templateKey: String) -> WithTemplateKey {
        WithTemplateKey(path: "\(path)/\(templateKey)")
    }

    public struct WithTemplateKey {
        /// Path: `/files/{file_id}/metadata/{scope}/{template_key}`
        public let path: String

        /// Get metadata instance on file
        ///
        /// Retrieves the instance of a metadata template that has been applied to a
        /// file.
        public var get: Request<BoxAPI.MetadataBase> {
            .get(path)
        }

        /// Create metadata instance on file
        ///
        /// Applies an instance of a metadata template to a file.
        /// 
        /// In most cases only values that are present in the metadata template
        /// will be accepted, except for the `global.properties` template which accepts
        /// any key-value pair.
        public func post(_ body: [String: String]? = nil) -> Request<BoxAPI.MetadataBase> {
            .post(path, body: body)
        }

        /// Update metadata instance on file
        ///
        /// Updates a piece of metadata on a file.
        /// 
        /// The metadata instance can only be updated if the template has already been
        /// applied to the file before. When editing metadata, only values that match
        /// the metadata template schema will be accepted.
        /// 
        /// The update is applied atomically. If any errors occur during the
        /// application of the operations, the metadata instance will not be changed.
        public func put(_ body: Data) -> Request<BoxAPI.MetadataBase> {
            .put(path, body: body)
        }

        /// Remove metadata instance from file
        ///
        /// Deletes a piece of file metadata.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Files.WithFileID {
    public var tasks: Tasks {
        Tasks(path: path + "/tasks")
    }

    public struct Tasks {
        /// Path: `/files/{file_id}/tasks`
        public let path: String

        /// List tasks on file
        ///
        /// Retrieves a list of all the tasks for a file. This
        /// endpoint does not support pagination.
        public var get: Request<BoxAPI.Tasks> {
            .get(path)
        }
    }
}

extension Paths.Files.WithFileID {
    public func `extension`(_ `extension`: String) -> WithThumbnail {
        WithThumbnail(path: "\(path)/thumbnail.\(`extension`)")
    }

    public struct WithThumbnail {
        /// Path: `/files/{file_id}/thumbnail.{extension}`
        public let path: String

        /// Get file thumbnail
        ///
        /// Retrieves a thumbnail, or smaller image representation, of a file.
        /// 
        /// Sizes of `32x32`,`64x64`, `128x128`, and `256x256` can be returned in
        /// the `.png` format and sizes of `32x32`, `94x94`, `160x160`, and `320x320`
        /// can be returned in the `.jpg` format.
        /// 
        /// Thumbnails can be generated for the image and video file formats listed
        /// [found on our community site][1].
        /// 
        /// [1]: https://community.box.com/t5/Migrating-and-Previewing-Content/File-Types-and-Fonts-Supported-in-Box-Content-Preview/ta-p/327
        public func get(parameters: GetParameters? = nil) -> Request<Data> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var minHeight: Int?
            public var minWidth: Int?
            public var maxHeight: Int?
            public var maxWidth: Int?

            public init(minHeight: Int? = nil, minWidth: Int? = nil, maxHeight: Int? = nil, maxWidth: Int? = nil) {
                self.minHeight = minHeight
                self.minWidth = minWidth
                self.maxHeight = maxHeight
                self.maxWidth = maxWidth
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(minHeight, forKey: "min_height")
                encoder.encode(minWidth, forKey: "min_width")
                encoder.encode(maxHeight, forKey: "max_height")
                encoder.encode(maxWidth, forKey: "max_width")
                return encoder.items
            }
        }
    }
}

extension Paths.Files.WithFileID {
    public var trash: Trash {
        Trash(path: path + "/trash")
    }

    public struct Trash {
        /// Path: `/files/{file_id}/trash`
        public let path: String

        /// Get trashed file
        ///
        /// Retrieves a file that has been moved to the trash.
        /// 
        /// Please note that only if the file itself has been moved to the
        /// trash can it be retrieved with this API call. If instead one of
        /// its parent folders was moved to the trash, only that folder
        /// can be inspected using the
        /// [`GET /folders/:id/trash`](e://get_folders_id_trash) API.
        /// 
        /// To list all items that have been moved to the trash, please
        /// use the [`GET /folders/trash/items`](e://get-folders-trash-items/)
        /// API.
        public func get(fields: [String]? = nil) -> Request<BoxAPI.File> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        /// Permanently remove file
        ///
        /// Permanently deletes a file that is in the trash.
        /// This action cannot be undone.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Files.WithFileID {
    public var uploadSessions: UploadSessions {
        UploadSessions(path: path + "/upload_sessions")
    }

    public struct UploadSessions {
        /// Path: `/files/{file_id}/upload_sessions`
        public let path: String

        /// Create upload session for existing file
        ///
        /// Creates an upload session for an existing file.
        public func post(_ body: PostRequest? = nil) -> Request<BoxAPI.UploadSession> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The optional new name of new file
            ///
            /// Example: "Project.mov"
            public var fileName: String?
            /// The total number of bytes of the file to be uploaded
            ///
            /// Example: 104857600
            public var fileSize: Int

            public init(fileName: String? = nil, fileSize: Int) {
                self.fileName = fileName
                self.fileSize = fileSize
            }

            private enum CodingKeys: String, CodingKey {
                case fileName = "file_name"
                case fileSize = "file_size"
            }
        }
    }
}

extension Paths.Files.WithFileID {
    public var versions: Versions {
        Versions(path: path + "/versions")
    }

    public struct Versions {
        /// Path: `/files/{file_id}/versions`
        public let path: String

        /// List all file versions
        ///
        /// Retrieve a list of the past versions for a file.
        /// 
        /// Versions are only tracked by Box users with premium accounts. To fetch the ID
        /// of the current version of a file, use the `GET /file/:id` API.
        public func get(parameters: GetParameters? = nil) -> Request<BoxAPI.FileVersions> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var fields: [String]?
            public var limit: Int?
            public var offset: Int?

            public init(fields: [String]? = nil, limit: Int? = nil, offset: Int? = nil) {
                self.fields = fields
                self.limit = limit
                self.offset = offset
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields", explode: false)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                return encoder.items
            }
        }
    }
}

extension Paths.Files.WithFileID.Versions {
    public var current: Current {
        Current(path: path + "/current")
    }

    public struct Current {
        /// Path: `/files/{file_id}/versions/current`
        public let path: String

        /// Revert file version
        ///
        /// Revert to a previous version of a file.
        /// 
        /// If previous versions exist, this method can be used to
        /// promote one of the older versions to the top of the version history.
        /// 
        /// This actually creates a new copy of the old version and puts it at the
        /// top of the versions history. The file will have the exact same contents
        /// as the older version, with the the same hash digest, `etag`, and
        /// name as the original.
        /// 
        /// Other properties such as comments do not get updated to their
        /// former values.
        public func post(fields: [String]? = nil, _ body: PostRequest? = nil) -> Request<BoxAPI.FileVersion> {
            .post(path, query: makePostQuery(fields), body: body)
        }

        private func makePostQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        /// The file version to revert to
        public struct PostRequest: Encodable {
            /// The file version ID
            ///
            /// Example: "11446498"
            public var id: String?
            /// The type to revert to
            ///
            /// Example: "file_version"
            public var type: `Type`?

            /// The type to revert to
            ///
            /// Example: "file_version"
            public enum `Type`: String, Codable, CaseIterable {
                case fileVersion = "file_version"
            }

            public init(id: String? = nil, type: `Type`? = nil) {
                self.id = id
                self.type = type
            }
        }
    }
}

extension Paths.Files.WithFileID.Versions {
    public func fileVersionID(_ fileVersionID: String) -> WithFileVersionID {
        WithFileVersionID(path: "\(path)/\(fileVersionID)")
    }

    public struct WithFileVersionID {
        /// Path: `/files/{file_id}/versions/{file_version_id}`
        public let path: String

        /// Get file version
        ///
        /// Retrieve a specific version of a file.
        /// 
        /// Versions are only tracked for Box users with premium accounts.
        public func get(fields: [String]? = nil) -> Request<BoxAPI.FileVersion> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        /// Remove file version
        ///
        /// Move a file version to the trash.
        /// 
        /// Versions are only tracked for Box users with premium accounts.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Files.WithFileID {
    public var watermark: Watermark {
        Watermark(path: path + "/watermark")
    }

    public struct Watermark {
        /// Path: `/files/{file_id}/watermark`
        public let path: String

        /// Get watermark on file
        ///
        /// Retrieve the watermark for a file.
        public var get: Request<BoxAPI.Watermark> {
            .get(path)
        }

        /// Apply watermark to file
        ///
        /// Applies or update a watermark on a file.
        public func put(watermark: PutRequest.Watermark) -> Request<BoxAPI.Watermark> {
            .put(path, body: PutRequest(watermark: watermark))
        }

        public struct PutRequest: Encodable {
            /// The watermark to imprint on the file
            public var watermark: Watermark

            /// The watermark to imprint on the file
            public struct Watermark: Encodable {
                /// The type of watermark to apply.
                /// 
                /// Currently only supports one option.
                ///
                /// Example: "default"
                public var imprint: Imprint

                /// The type of watermark to apply.
                /// 
                /// Currently only supports one option.
                ///
                /// Example: "default"
                public enum Imprint: String, Codable, CaseIterable {
                    case `default`
                }

                public init(imprint: Imprint) {
                    self.imprint = imprint
                }
            }

            public init(watermark: Watermark) {
                self.watermark = watermark
            }
        }

        /// Remove watermark from file
        ///
        /// Removes the watermark from a file.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var folderLocks: FolderLocks {
        FolderLocks(path: "/folder_locks")
    }

    public struct FolderLocks {
        /// Path: `/folder_locks`
        public let path: String

        /// List folder locks
        ///
        /// Retrieves folder lock details for a given folder.
        public func get(folderID: String) -> Request<BoxAPI.FolderLocks> {
            .get(path, query: [("folder_id", folderID)])
        }

        /// Create folder lock
        ///
        /// Creates a folder lock on a folder, preventing it from being moved and/or
        /// deleted.
        public func post(_ body: PostRequest? = nil) -> Request<BoxAPI.FolderLock> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The folder to apply the lock to.
            public var folder: Folder
            /// The operations to lock for the folder. If `locked_operations` is
            /// included in the request, both `move` and `delete` must also be
            /// included and both set to `true`.
            public var lockedOperations: LockedOperations?

            /// The folder to apply the lock to.
            public struct Folder: Encodable {
                /// The ID of the folder.
                ///
                /// Example: "1234567890"
                public var id: String
                /// The content type the lock is being applied to. Only `folder`
                /// is supported.
                ///
                /// Example: "folder"
                public var type: String

                public init(id: String, type: String) {
                    self.id = id
                    self.type = type
                }
            }

            /// The operations to lock for the folder. If `locked_operations` is
            /// included in the request, both `move` and `delete` must also be
            /// included and both set to `true`.
            public struct LockedOperations: Encodable {
                /// Whether deleting the folder should be locked.
                ///
                /// Example: true
                public var delete: Bool
                /// Whether moving the folder should be locked.
                ///
                /// Example: true
                public var isMove: Bool

                public init(delete: Bool, isMove: Bool) {
                    self.delete = delete
                    self.isMove = isMove
                }

                private enum CodingKeys: String, CodingKey {
                    case delete
                    case isMove = "move"
                }
            }

            public init(folder: Folder, lockedOperations: LockedOperations? = nil) {
                self.folder = folder
                self.lockedOperations = lockedOperations
            }

            private enum CodingKeys: String, CodingKey {
                case folder
                case lockedOperations = "locked_operations"
            }
        }
    }
}

extension Paths.FolderLocks {
    public func folderLockID(_ folderLockID: String) -> WithFolderLockID {
        WithFolderLockID(path: "\(path)/\(folderLockID)")
    }

    public struct WithFolderLockID {
        /// Path: `/folder_locks/{folder_lock_id}`
        public let path: String

        /// Delete folder lock
        ///
        /// Deletes a folder lock on a given folder.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var folders: Folders {
        Folders(path: "/folders")
    }

    public struct Folders {
        /// Path: `/folders`
        public let path: String

        /// Create folder
        ///
        /// Creates a new empty folder within the specified parent folder.
        public func post(fields: [String]? = nil, _ body: PostRequest? = nil) -> Request<BoxAPI.Folder> {
            .post(path, query: makePostQuery(fields), body: body)
        }

        private func makePostQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        public struct PostRequest: Encodable {
            public var folderUploadEmail: FolderUploadEmail?
            /// The name for the new folder.
            /// 
            /// There are some restrictions to the file name. Names containing
            /// non-printable ASCII characters, forward and backward slashes
            /// (`/`, `\`), as well as names with trailing spaces are
            /// prohibited.
            /// 
            /// Additionally, the names `.` and `..` are
            /// not allowed either.
            ///
            /// Example: "New Folder"
            public var name: String
            /// The parent folder to create the new folder within.
            public var parent: Parent
            /// Specifies whether a folder should be synced to a
            /// user's device or not. This is used by Box Sync
            /// (discontinued) and is not used by Box Drive.
            ///
            /// Example: "synced"
            public var syncState: SyncState?

            public struct FolderUploadEmail: Encodable {
                /// When this parameter has been set, users can email files
                /// to the email address that has been automatically
                /// created for this folder.
                /// 
                /// To create an email address, set this property either when
                /// creating or updating the folder.
                /// 
                /// When set to `collaborators`, only emails from registered email
                /// addresses for collaborators will be accepted. This includes
                /// any email aliases a user might have registered.
                /// 
                /// When set to `open` it will accept emails from any email
                /// address.
                ///
                /// Example: "open"
                public var access: Access?
                /// Setting this object enables the upload email address.
                /// 
                /// This email address can be used by users to directly
                /// upload files directly to the folder via email.
                public var anyJSON: AnyJSON

                /// When this parameter has been set, users can email files
                /// to the email address that has been automatically
                /// created for this folder.
                /// 
                /// To create an email address, set this property either when
                /// creating or updating the folder.
                /// 
                /// When set to `collaborators`, only emails from registered email
                /// addresses for collaborators will be accepted. This includes
                /// any email aliases a user might have registered.
                /// 
                /// When set to `open` it will accept emails from any email
                /// address.
                ///
                /// Example: "open"
                public enum Access: String, Codable, CaseIterable {
                    case `open`
                    case collaborators
                }

                public init(access: Access? = nil, anyJSON: AnyJSON) {
                    self.access = access
                    self.anyJSON = anyJSON
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(access, forKey: "access")
                    try values.encode(anyJSON, forKey: "anyJSON")
                }
            }

            /// The parent folder to create the new folder within.
            public struct Parent: Encodable {
                /// The ID of parent folder
                ///
                /// Example: "0"
                public var id: String

                public init(id: String) {
                    self.id = id
                }
            }

            /// Specifies whether a folder should be synced to a
            /// user's device or not. This is used by Box Sync
            /// (discontinued) and is not used by Box Drive.
            ///
            /// Example: "synced"
            public enum SyncState: String, Codable, CaseIterable {
                case synced
                case notSynced = "not_synced"
                case partiallySynced = "partially_synced"
            }

            public init(folderUploadEmail: FolderUploadEmail? = nil, name: String, parent: Parent, syncState: SyncState? = nil) {
                self.folderUploadEmail = folderUploadEmail
                self.name = name
                self.parent = parent
                self.syncState = syncState
            }

            private enum CodingKeys: String, CodingKey {
                case folderUploadEmail = "folder_upload_email"
                case name
                case parent
                case syncState = "sync_state"
            }
        }
    }
}

extension Paths.Folders {
    public var trash: Trash {
        Trash(path: path + "/trash")
    }

    public struct Trash {
        /// Path: `/folders/trash`
        public let path: String
    }
}

extension Paths.Folders.Trash {
    public var items: Items {
        Items(path: path + "/items")
    }

    public struct Items {
        /// Path: `/folders/trash/items`
        public let path: String

        /// List trashed items
        ///
        /// Retrieves the files and folders that have been moved
        /// to the trash.
        /// 
        /// Any attribute in the full files or folders objects can be passed
        /// in with the `fields` parameter to retrieve those specific
        /// attributes that are not returned by default.
        /// 
        /// This endpoint defaults to use offset-based pagination, yet also supports
        /// marker-based pagination using the `marker` parameter.
        public func get(parameters: GetParameters? = nil) -> Request<BoxAPI.Items> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var fields: [String]?
            public var limit: Int?
            public var offset: Int?
            public var isUsemarker: Bool?
            public var marker: String?
            public var direction: Direction?
            public var sort: Sort?

            public enum Direction: String, Codable, CaseIterable {
                case asc = "ASC"
                case desc = "DESC"
            }

            public enum Sort: String, Codable, CaseIterable {
                case id
                case name
                case date
                case size
            }

            public init(fields: [String]? = nil, limit: Int? = nil, offset: Int? = nil, isUsemarker: Bool? = nil, marker: String? = nil, direction: Direction? = nil, sort: Sort? = nil) {
                self.fields = fields
                self.limit = limit
                self.offset = offset
                self.isUsemarker = isUsemarker
                self.marker = marker
                self.direction = direction
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields", explode: false)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(isUsemarker, forKey: "usemarker")
                encoder.encode(marker, forKey: "marker")
                encoder.encode(direction, forKey: "direction")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }
    }
}

extension Paths.Folders {
    public func folderID(_ folderID: String) -> WithFolderID {
        WithFolderID(path: "\(path)/\(folderID)")
    }

    public struct WithFolderID {
        /// Path: `/folders/{folder_id}`
        public let path: String

        /// Get folder information
        ///
        /// Retrieves details for a folder, including the first 100 entries
        /// in the folder.
        /// 
        /// To fetch more items within the folder, please use the
        /// [Get items in a folder](#get-folders-id-items) endpoint.
        public func get(fields: [String]? = nil) -> Request<BoxAPI.Folder> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        /// Restore folder
        ///
        /// Restores a folder that has been moved to the trash.
        /// 
        /// An optional new parent ID can be provided to restore the folder to in case the
        /// original folder has been deleted.
        /// 
        /// # Folder locking
        /// 
        /// During this operation, part of the file tree will be locked, mainly
        /// the source folder and all of its descendants, as well as the destination
        /// folder.
        /// 
        /// For the duration of the operation, no other move, copy, delete, or restore
        /// operation can performed on any of the locked folders.
        public func post(fields: [String]? = nil, _ body: PostRequest? = nil) -> Request<BoxAPI.Folder> {
            .post(path, query: makePostQuery(fields), body: body)
        }

        private func makePostQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        public struct PostRequest: Encodable {
            /// An optional new name for the folder.
            ///
            /// Example: "Restored Photos"
            public var name: String?
            public var parent: Parent?

            public struct Parent: Encodable {
                /// The ID of parent item
                ///
                /// Example: "123"
                public var id: String?
                /// Specifies an optional ID of a folder to restore the folder
                /// to when the original folder no longer exists.
                /// 
                /// Please be aware that this ID will only be used if the original
                /// folder no longer exists. Use this ID to provide a fallback
                /// location to restore the folder to if the original location
                /// has been deleted.
                public var anyJSON: AnyJSON

                public init(id: String? = nil, anyJSON: AnyJSON) {
                    self.id = id
                    self.anyJSON = anyJSON
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(id, forKey: "id")
                    try values.encode(anyJSON, forKey: "anyJSON")
                }
            }

            public init(name: String? = nil, parent: Parent? = nil) {
                self.name = name
                self.parent = parent
            }
        }

        /// Update folder
        ///
        /// Updates a folder. This can be also be used to move the folder,
        /// create shared links, update collaborations, and more.
        public func put(fields: [String]? = nil, _ body: PutRequest? = nil) -> Request<BoxAPI.Folder> {
            .put(path, query: makePutQuery(fields), body: body)
        }

        private func makePutQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        public struct PutRequest: Encodable {
            /// Specifies if users who are not the owner
            /// of the folder can invite new collaborators to the folder.
            ///
            /// Example: true
            public var canNonOwnersInvite: Bool?
            /// Restricts collaborators who are not the owner of
            /// this folder from viewing other collaborations on
            /// this folder.
            /// 
            /// It also restricts non-owners from inviting new
            /// collaborators.
            /// 
            /// When setting this field to `false`, it is required
            /// to also set `can_non_owners_invite_collaborators` to
            /// `false` if it has not already been set.
            ///
            /// Example: true
            public var canNonOwnersViewCollaborators: Bool?
            /// An array of collections to make this folder
            /// a member of. Currently
            /// we only support the `favorites` collection.
            /// 
            /// To get the ID for a collection, use the
            /// [List all collections][1] endpoint.
            /// 
            /// Passing an empty array `[]` or `null` will remove
            /// the folder from all collections.
            /// 
            /// [1]: ../advanced-files-and-folders/#get-collections
            public var collections: [Collection]?
            /// The optional description of this folder
            ///
            /// Example: "Legal contracts for the new ACME deal"
            public var description: String?
            public var folderUploadEmail: FolderUploadEmail?
            /// Specifies if new invites to this folder are restricted to users
            /// within the enterprise. This does not affect existing
            /// collaborations.
            ///
            /// Example: true
            public var isCollaborationRestrictedToEnterprise: Bool?
            /// The optional new name for this folder.
            ///
            /// Example: "New Folder"
            public var name: String?
            /// The parent folder for this folder. Use this to move
            /// the folder or to restore it out of the trash.
            public var parent: Parent?
            public var sharedLink: SharedLink?
            /// Specifies whether a folder should be synced to a
            /// user's device or not. This is used by Box Sync
            /// (discontinued) and is not used by Box Drive.
            ///
            /// Example: "synced"
            public var syncState: SyncState?
            /// The tags for this item. These tags are shown in
            /// the Box web app and mobile apps next to an item.
            /// 
            /// To add or remove a tag, retrieve the item's current tags,
            /// modify them, and then update this field.
            /// 
            /// There is a limit of 100 tags per item, and 10,000
            /// unique tags per enterprise.
            ///
            /// Example: ["approved"]
            public var tags: [String]?

            /// Reference
            ///
            /// The bare basic reference for an object
            public struct Collection: Encodable {
                /// The unique identifier for this object
                ///
                /// Example: "11446498"
                public var id: String?
                /// The type for this object
                ///
                /// Example: "file"
                public var type: String?

                public init(id: String? = nil, type: String? = nil) {
                    self.id = id
                    self.type = type
                }
            }

            public struct FolderUploadEmail: Encodable {
                /// When this parameter has been set, users can email files
                /// to the email address that has been automatically
                /// created for this folder.
                /// 
                /// To create an email address, set this property either when
                /// creating or updating the folder.
                /// 
                /// When set to `collaborators`, only emails from registered email
                /// addresses for collaborators will be accepted. This includes
                /// any email aliases a user might have registered.
                /// 
                /// When set to `open` it will accept emails from any email
                /// address.
                ///
                /// Example: "open"
                public var access: Access?
                /// Setting this object enables the upload email address.
                /// 
                /// This email address can be used by users to directly
                /// upload files directly to the folder via email.
                /// 
                /// Setting the value to `null` will disable the email address.
                public var anyJSON: AnyJSON

                /// When this parameter has been set, users can email files
                /// to the email address that has been automatically
                /// created for this folder.
                /// 
                /// To create an email address, set this property either when
                /// creating or updating the folder.
                /// 
                /// When set to `collaborators`, only emails from registered email
                /// addresses for collaborators will be accepted. This includes
                /// any email aliases a user might have registered.
                /// 
                /// When set to `open` it will accept emails from any email
                /// address.
                ///
                /// Example: "open"
                public enum Access: String, Codable, CaseIterable {
                    case `open`
                    case collaborators
                }

                public init(access: Access? = nil, anyJSON: AnyJSON) {
                    self.access = access
                    self.anyJSON = anyJSON
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(access, forKey: "access")
                    try values.encode(anyJSON, forKey: "anyJSON")
                }
            }

            /// The parent folder for this folder. Use this to move
            /// the folder or to restore it out of the trash.
            public struct Parent: Encodable {
                /// The ID of the new parent folder
                ///
                /// Example: "0"
                public var id: String?

                public init(id: String? = nil) {
                    self.id = id
                }
            }

            public struct SharedLink: Encodable {
                /// The level of access for the shared link. This can be
                /// restricted to anyone with the link (`open`), only people
                /// within the company (`company`) and only those who
                /// have been invited to the folder (`collaborators`).
                /// 
                /// If not set, this field defaults to the access level specified
                /// by the enterprise admin. To create a shared link with this
                /// default setting pass the `shared_link` object with
                /// no `access` field, for example `{ "shared_link": {} }`.
                /// 
                /// The `company` access level is only available to paid
                /// accounts.
                ///
                /// Example: "open"
                public var access: Access?
                /// The password required to access the shared link. Set the
                /// password to `null` to remove it.
                /// 
                /// A password can only be set when `access` is set to `open`.
                ///
                /// Example: "do-not-use-this-password"
                public var password: String?
                public var permissions: Permissions?
                /// The timestamp at which this shared link will
                /// expire. This field can only be set by
                /// users with paid accounts.
                ///
                /// Example: "2012-12-12T10:53:43-08:00"
                public var unsharedAt: Date?
                /// Defines a custom vanity name to use in the shared link URL,
                /// for example `https://app.box.com/v/my-shared-link`.
                /// 
                /// Custom URLs should not be used when sharing sensitive content
                /// as vanity URLs are a lot easier to guess than regular shared links.
                ///
                /// Example: "my-shared-link"
                public var vanityName: String?
                /// Enables the creation of a shared link for a folder.
                public var anyJSON: AnyJSON

                /// The level of access for the shared link. This can be
                /// restricted to anyone with the link (`open`), only people
                /// within the company (`company`) and only those who
                /// have been invited to the folder (`collaborators`).
                /// 
                /// If not set, this field defaults to the access level specified
                /// by the enterprise admin. To create a shared link with this
                /// default setting pass the `shared_link` object with
                /// no `access` field, for example `{ "shared_link": {} }`.
                /// 
                /// The `company` access level is only available to paid
                /// accounts.
                ///
                /// Example: "open"
                public enum Access: String, Codable, CaseIterable {
                    case `open`
                    case company
                    case collaborators
                }

                public struct Permissions: Encodable {
                    /// If the shared link allows for downloading of files.
                    /// This can only be set when `access` is set to
                    /// `open` or `company`.
                    ///
                    /// Example: true
                    public var canDownload: Bool?

                    public init(canDownload: Bool? = nil) {
                        self.canDownload = canDownload
                    }

                    private enum CodingKeys: String, CodingKey {
                        case canDownload = "can_download"
                    }
                }

                public init(access: Access? = nil, password: String? = nil, permissions: Permissions? = nil, unsharedAt: Date? = nil, vanityName: String? = nil, anyJSON: AnyJSON) {
                    self.access = access
                    self.password = password
                    self.permissions = permissions
                    self.unsharedAt = unsharedAt
                    self.vanityName = vanityName
                    self.anyJSON = anyJSON
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(access, forKey: "access")
                    try values.encodeIfPresent(password, forKey: "password")
                    try values.encodeIfPresent(permissions, forKey: "permissions")
                    try values.encodeIfPresent(unsharedAt, forKey: "unshared_at")
                    try values.encodeIfPresent(vanityName, forKey: "vanity_name")
                    try values.encode(anyJSON, forKey: "anyJSON")
                }
            }

            /// Specifies whether a folder should be synced to a
            /// user's device or not. This is used by Box Sync
            /// (discontinued) and is not used by Box Drive.
            ///
            /// Example: "synced"
            public enum SyncState: String, Codable, CaseIterable {
                case synced
                case notSynced = "not_synced"
                case partiallySynced = "partially_synced"
            }

            public init(canNonOwnersInvite: Bool? = nil, canNonOwnersViewCollaborators: Bool? = nil, collections: [Collection]? = nil, description: String? = nil, folderUploadEmail: FolderUploadEmail? = nil, isCollaborationRestrictedToEnterprise: Bool? = nil, name: String? = nil, parent: Parent? = nil, sharedLink: SharedLink? = nil, syncState: SyncState? = nil, tags: [String]? = nil) {
                self.canNonOwnersInvite = canNonOwnersInvite
                self.canNonOwnersViewCollaborators = canNonOwnersViewCollaborators
                self.collections = collections
                self.description = description
                self.folderUploadEmail = folderUploadEmail
                self.isCollaborationRestrictedToEnterprise = isCollaborationRestrictedToEnterprise
                self.name = name
                self.parent = parent
                self.sharedLink = sharedLink
                self.syncState = syncState
                self.tags = tags
            }

            private enum CodingKeys: String, CodingKey {
                case canNonOwnersInvite = "can_non_owners_invite"
                case canNonOwnersViewCollaborators = "can_non_owners_view_collaborators"
                case collections
                case description
                case folderUploadEmail = "folder_upload_email"
                case isCollaborationRestrictedToEnterprise = "is_collaboration_restricted_to_enterprise"
                case name
                case parent
                case sharedLink = "shared_link"
                case syncState = "sync_state"
                case tags
            }
        }

        /// Delete folder
        ///
        /// Deletes a folder, either permanently or by moving it to
        /// the trash.
        public func delete(isRecursive: Bool? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(isRecursive))
        }

        private func makeDeleteQuery(_ isRecursive: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRecursive, forKey: "recursive")
            return encoder.items
        }
    }
}

extension Paths.Folders {
    public func folderID(_ folderID: String) -> WithAddSharedLink {
        WithAddSharedLink(path: "\(path)/\(folderID)#add_shared_link")
    }

    public struct WithAddSharedLink {
        /// Path: `/folders/{folder_id}#add_shared_link`
        public let path: String

        /// Add shared link to folder
        ///
        /// Adds a shared link to a folder.
        public func put(fields: String, sharedLink: PutRequest.SharedLink? = nil) -> Request<BoxAPI.Folder> {
            .put(path, query: [("fields", fields)], body: PutRequest(sharedLink: sharedLink))
        }

        public struct PutRequest: Encodable {
            /// The settings for the shared link to create on the folder.
            /// 
            /// Use an empty object (`{}`) to use the default settings for shared
            /// links.
            public var sharedLink: SharedLink?

            /// The settings for the shared link to create on the folder.
            /// 
            /// Use an empty object (`{}`) to use the default settings for shared
            /// links.
            public struct SharedLink: Encodable {
                /// The level of access for the shared link. This can be
                /// restricted to anyone with the link (`open`), only people
                /// within the company (`company`) and only those who
                /// have been invited to the folder (`collaborators`).
                /// 
                /// If not set, this field defaults to the access level specified
                /// by the enterprise admin. To create a shared link with this
                /// default setting pass the `shared_link` object with
                /// no `access` field, for example `{ "shared_link": {} }`.
                /// 
                /// The `company` access level is only available to paid
                /// accounts.
                ///
                /// Example: "open"
                public var access: Access?
                /// The password required to access the shared link. Set the
                /// password to `null` to remove it.
                /// 
                /// A password can only be set when `access` is set to `open`.
                ///
                /// Example: "do-not-use-this-password"
                public var password: String?
                public var permissions: Permissions?
                /// The timestamp at which this shared link will
                /// expire. This field can only be set by
                /// users with paid accounts. The value must be greater than the
                /// current date and time.
                ///
                /// Example: "2012-12-12T10:53:43-08:00"
                public var unsharedAt: Date?

                /// The level of access for the shared link. This can be
                /// restricted to anyone with the link (`open`), only people
                /// within the company (`company`) and only those who
                /// have been invited to the folder (`collaborators`).
                /// 
                /// If not set, this field defaults to the access level specified
                /// by the enterprise admin. To create a shared link with this
                /// default setting pass the `shared_link` object with
                /// no `access` field, for example `{ "shared_link": {} }`.
                /// 
                /// The `company` access level is only available to paid
                /// accounts.
                ///
                /// Example: "open"
                public enum Access: String, Codable, CaseIterable {
                    case `open`
                    case company
                    case collaborators
                }

                public struct Permissions: Encodable {
                    /// If the shared link allows for downloading of folders.
                    /// This can only be set when `access` is set to
                    /// `open` or `company`.
                    ///
                    /// Example: true
                    public var canDownload: Bool?

                    public init(canDownload: Bool? = nil) {
                        self.canDownload = canDownload
                    }

                    private enum CodingKeys: String, CodingKey {
                        case canDownload = "can_download"
                    }
                }

                public init(access: Access? = nil, password: String? = nil, permissions: Permissions? = nil, unsharedAt: Date? = nil) {
                    self.access = access
                    self.password = password
                    self.permissions = permissions
                    self.unsharedAt = unsharedAt
                }

                private enum CodingKeys: String, CodingKey {
                    case access
                    case password
                    case permissions
                    case unsharedAt = "unshared_at"
                }
            }

            public init(sharedLink: SharedLink? = nil) {
                self.sharedLink = sharedLink
            }

            private enum CodingKeys: String, CodingKey {
                case sharedLink = "shared_link"
            }
        }
    }
}

extension Paths.Folders {
    public func folderID(_ folderID: String) -> WithGetSharedLink {
        WithGetSharedLink(path: "\(path)/\(folderID)#get_shared_link")
    }

    public struct WithGetSharedLink {
        /// Path: `/folders/{folder_id}#get_shared_link`
        public let path: String

        /// Get shared link for folder
        ///
        /// Gets the information for a shared link on a folder.
        public func get(fields: String) -> Request<BoxAPI.Folder> {
            .get(path, query: [("fields", fields)])
        }
    }
}

extension Paths.Folders {
    public func folderID(_ folderID: String) -> WithRemoveSharedLink {
        WithRemoveSharedLink(path: "\(path)/\(folderID)#remove_shared_link")
    }

    public struct WithRemoveSharedLink {
        /// Path: `/folders/{folder_id}#remove_shared_link`
        public let path: String

        /// Remove shared link from folder
        ///
        /// Removes a shared link from a folder.
        public func put(fields: String, sharedLink: [String: AnyJSON]? = nil) -> Request<BoxAPI.Folder> {
            .put(path, query: [("fields", fields)], body: ["shared_link": sharedLink])
        }
    }
}

extension Paths.Folders {
    public func folderID(_ folderID: String) -> WithUpdateSharedLink {
        WithUpdateSharedLink(path: "\(path)/\(folderID)#update_shared_link")
    }

    public struct WithUpdateSharedLink {
        /// Path: `/folders/{folder_id}#update_shared_link`
        public let path: String

        /// Update shared link on folder
        ///
        /// Updates a shared link on a folder.
        public func put(fields: String, sharedLink: PutRequest.SharedLink? = nil) -> Request<BoxAPI.Folder> {
            .put(path, query: [("fields", fields)], body: PutRequest(sharedLink: sharedLink))
        }

        public struct PutRequest: Encodable {
            /// The settings for the shared link to update.
            public var sharedLink: SharedLink?

            /// The settings for the shared link to update.
            public struct SharedLink: Encodable {
                /// The level of access for the shared link. This can be
                /// restricted to anyone with the link (`open`), only people
                /// within the company (`company`) and only those who
                /// have been invited to the folder (`collaborators`).
                /// 
                /// If not set, this field defaults to the access level specified
                /// by the enterprise admin. To create a shared link with this
                /// default setting pass the `shared_link` object with
                /// no `access` field, for example `{ "shared_link": {} }`.
                /// 
                /// The `company` access level is only available to paid
                /// accounts.
                ///
                /// Example: "open"
                public var access: Access?
                /// The password required to access the shared link. Set the
                /// password to `null` to remove it.
                /// 
                /// A password can only be set when `access` is set to `open`.
                ///
                /// Example: "do-not-use-this-password"
                public var password: String?
                public var permissions: Permissions?
                /// The timestamp at which this shared link will
                /// expire. This field can only be set by
                /// users with paid accounts. The value must be greater than the
                /// current date and time.
                ///
                /// Example: "2012-12-12T10:53:43-08:00"
                public var unsharedAt: Date?

                /// The level of access for the shared link. This can be
                /// restricted to anyone with the link (`open`), only people
                /// within the company (`company`) and only those who
                /// have been invited to the folder (`collaborators`).
                /// 
                /// If not set, this field defaults to the access level specified
                /// by the enterprise admin. To create a shared link with this
                /// default setting pass the `shared_link` object with
                /// no `access` field, for example `{ "shared_link": {} }`.
                /// 
                /// The `company` access level is only available to paid
                /// accounts.
                ///
                /// Example: "open"
                public enum Access: String, Codable, CaseIterable {
                    case `open`
                    case company
                    case collaborators
                }

                public struct Permissions: Encodable {
                    /// If the shared link allows for downloading of folders.
                    /// This can only be set when `access` is set to
                    /// `open` or `company`.
                    ///
                    /// Example: true
                    public var canDownload: Bool?

                    public init(canDownload: Bool? = nil) {
                        self.canDownload = canDownload
                    }

                    private enum CodingKeys: String, CodingKey {
                        case canDownload = "can_download"
                    }
                }

                public init(access: Access? = nil, password: String? = nil, permissions: Permissions? = nil, unsharedAt: Date? = nil) {
                    self.access = access
                    self.password = password
                    self.permissions = permissions
                    self.unsharedAt = unsharedAt
                }

                private enum CodingKeys: String, CodingKey {
                    case access
                    case password
                    case permissions
                    case unsharedAt = "unshared_at"
                }
            }

            public init(sharedLink: SharedLink? = nil) {
                self.sharedLink = sharedLink
            }

            private enum CodingKeys: String, CodingKey {
                case sharedLink = "shared_link"
            }
        }
    }
}

extension Paths.Folders.WithFolderID {
    public var collaborations: Collaborations {
        Collaborations(path: path + "/collaborations")
    }

    public struct Collaborations {
        /// Path: `/folders/{folder_id}/collaborations`
        public let path: String

        /// List folder collaborations
        ///
        /// Retrieves a list of pending and active collaborations for a
        /// folder. This returns all the users that have access to the folder
        /// or have been invited to the folder.
        public func get(fields: [String]? = nil) -> Request<BoxAPI.Collaborations> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }
    }
}

extension Paths.Folders.WithFolderID {
    public var copy: Copy {
        Copy(path: path + "/copy")
    }

    public struct Copy {
        /// Path: `/folders/{folder_id}/copy`
        public let path: String

        /// Copy folder
        ///
        /// Creates a copy of a folder within a destination folder.
        /// 
        /// The original folder will not be changed.
        public func post(fields: [String]? = nil, _ body: PostRequest? = nil) -> Request<BoxAPI.Folder> {
            .post(path, query: makePostQuery(fields), body: body)
        }

        private func makePostQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        public struct PostRequest: Encodable {
            /// An optional new name for the copied folder.
            /// 
            /// There are some restrictions to the file name. Names containing
            /// non-printable ASCII characters, forward and backward slashes
            /// (`/`, `\`), as well as names with trailing spaces are
            /// prohibited.
            /// 
            /// Additionally, the names `.` and `..` are
            /// not allowed either.
            ///
            /// Example: "New Folder"
            public var name: String?
            /// The destination folder to copy the folder to.
            public var parent: Parent

            /// The destination folder to copy the folder to.
            public struct Parent: Encodable {
                /// The ID of parent folder
                ///
                /// Example: "0"
                public var id: String

                public init(id: String) {
                    self.id = id
                }
            }

            public init(name: String? = nil, parent: Parent) {
                self.name = name
                self.parent = parent
            }
        }
    }
}

extension Paths.Folders.WithFolderID {
    public var items: Items {
        Items(path: path + "/items")
    }

    public struct Items {
        /// Path: `/folders/{folder_id}/items`
        public let path: String

        /// List items in folder
        ///
        /// Retrieves a page of items in a folder. These items can be files,
        /// folders, and web links.
        /// 
        /// To request more information about the folder itself, like its size,
        /// please use the [Get a folder](#get-folders-id) endpoint instead.
        public func get(parameters: GetParameters? = nil) -> Request<BoxAPI.Items> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var fields: [String]?
            public var isUsemarker: Bool?
            public var marker: String?
            public var offset: Int?
            public var limit: Int?
            public var sort: Sort?
            public var direction: Direction?

            public enum Sort: String, Codable, CaseIterable {
                case id
                case name
                case date
                case size
            }

            public enum Direction: String, Codable, CaseIterable {
                case asc = "ASC"
                case desc = "DESC"
            }

            public init(fields: [String]? = nil, isUsemarker: Bool? = nil, marker: String? = nil, offset: Int? = nil, limit: Int? = nil, sort: Sort? = nil, direction: Direction? = nil) {
                self.fields = fields
                self.isUsemarker = isUsemarker
                self.marker = marker
                self.offset = offset
                self.limit = limit
                self.sort = sort
                self.direction = direction
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields", explode: false)
                encoder.encode(isUsemarker, forKey: "usemarker")
                encoder.encode(marker, forKey: "marker")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(sort, forKey: "sort")
                encoder.encode(direction, forKey: "direction")
                return encoder.items
            }
        }
    }
}

extension Paths.Folders.WithFolderID {
    public var metadata: Metadata {
        Metadata(path: path + "/metadata")
    }

    public struct Metadata {
        /// Path: `/folders/{folder_id}/metadata`
        public let path: String

        /// List metadata instances on folder
        ///
        /// Retrieves all metadata for a given folder. This can not be used on the root
        /// folder with ID `0`.
        public var get: Request<BoxAPI.Metadatas> {
            .get(path)
        }
    }
}

extension Paths.Folders.WithFolderID.Metadata {
    public var enterprise: Enterprise {
        Enterprise(path: path + "/enterprise")
    }

    public struct Enterprise {
        /// Path: `/folders/{folder_id}/metadata/enterprise`
        public let path: String
    }
}

extension Paths.Folders.WithFolderID.Metadata.Enterprise {
    public var securityClassification6VMVochwUWo: SecurityClassification6VMVochwUWo {
        SecurityClassification6VMVochwUWo(path: path + "/securityClassification-6VMVochwUWo")
    }

    public struct SecurityClassification6VMVochwUWo {
        /// Path: `/folders/{folder_id}/metadata/enterprise/securityClassification-6VMVochwUWo`
        public let path: String

        /// Get classification on folder
        ///
        /// Retrieves the classification metadata instance that
        /// has been applied to a folder.
        /// 
        /// This API can also be called by including the enterprise ID in the
        /// URL explicitly, for example
        /// `/folders/:id//enterprise_12345/securityClassification-6VMVochwUWo`.
        public var get: Request<BoxAPI.Classification> {
            .get(path)
        }

        /// Add classification to folder
        ///
        /// Adds a classification to a folder by specifying the label of the
        /// classification to add.
        /// 
        /// This API can also be called by including the enterprise ID in the
        /// URL explicitly, for example
        /// `/folders/:id//enterprise_12345/securityClassification-6VMVochwUWo`.
        public func post(boxSecurityClassificationKey: String? = nil) -> Request<BoxAPI.Classification> {
            .post(path, body: ["Box__Security__Classification__Key": boxSecurityClassificationKey])
        }

        /// Update classification on folder
        ///
        /// Updates a classification on a folder.
        /// 
        /// The classification can only be updated if a classification has already been
        /// applied to the folder before. When editing classifications, only values are
        /// defined for the enterprise will be accepted.
        public func put(_ body: Data) -> Request<BoxAPI.Classification> {
            .put(path, body: body)
        }

        /// Remove classification from folder
        ///
        /// Removes any classifications from a folder.
        /// 
        /// This API can also be called by including the enterprise ID in the
        /// URL explicitly, for example
        /// `/folders/:id//enterprise_12345/securityClassification-6VMVochwUWo`.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Folders.WithFolderID.Metadata {
    public func scope(_ scope: String) -> WithScope {
        WithScope(path: "\(path)/\(scope)")
    }

    public struct WithScope {
        /// Path: `/folders/{folder_id}/metadata/{scope}`
        public let path: String
    }
}

extension Paths.Folders.WithFolderID.Metadata.WithScope {
    public func templateKey(_ templateKey: String) -> WithTemplateKey {
        WithTemplateKey(path: "\(path)/\(templateKey)")
    }

    public struct WithTemplateKey {
        /// Path: `/folders/{folder_id}/metadata/{scope}/{template_key}`
        public let path: String

        /// Get metadata instance on folder
        ///
        /// Retrieves the instance of a metadata template that has been applied to a
        /// folder. This can not be used on the root folder with ID `0`.
        public var get: Request<BoxAPI.MetadataBase> {
            .get(path)
        }

        /// Create metadata instance on folder
        ///
        /// Applies an instance of a metadata template to a folder.
        /// 
        /// In most cases only values that are present in the metadata template
        /// will be accepted, except for the `global.properties` template which accepts
        /// any key-value pair.
        /// 
        /// To display the metadata template in the Box web app the enterprise needs to be
        /// configured to enable **Cascading Folder Level Metadata** for the user in the
        /// admin console.
        public func post(_ body: [String: String]? = nil) -> Request<BoxAPI.MetadataBase> {
            .post(path, body: body)
        }

        /// Update metadata instance on folder
        ///
        /// Updates a piece of metadata on a folder.
        /// 
        /// The metadata instance can only be updated if the template has already been
        /// applied to the folder before. When editing metadata, only values that match
        /// the metadata template schema will be accepted.
        /// 
        /// The update is applied atomically. If any errors occur during the
        /// application of the operations, the metadata instance will not be changed.
        public func put(_ body: Data) -> Request<BoxAPI.MetadataBase> {
            .put(path, body: body)
        }

        /// Remove metadata instance from folder
        ///
        /// Deletes a piece of folder metadata.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Folders.WithFolderID {
    public var trash: Trash {
        Trash(path: path + "/trash")
    }

    public struct Trash {
        /// Path: `/folders/{folder_id}/trash`
        public let path: String

        /// Get trashed folder
        ///
        /// Retrieves a folder that has been moved to the trash.
        /// 
        /// Please note that only if the folder itself has been moved to the
        /// trash can it be retrieved with this API call. If instead one of
        /// its parent folders was moved to the trash, only that folder
        /// can be inspected using the
        /// [`GET /folders/:id/trash`](e://get_folders_id_trash) API.
        /// 
        /// To list all items that have been moved to the trash, please
        /// use the [`GET /folders/trash/items`](e://get-folders-trash-items/)
        /// API.
        public func get(fields: [String]? = nil) -> Request<BoxAPI.Folder> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        /// Permanently remove folder
        ///
        /// Permanently deletes a folder that is in the trash.
        /// This action cannot be undone.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Folders.WithFolderID {
    public var watermark: Watermark {
        Watermark(path: path + "/watermark")
    }

    public struct Watermark {
        /// Path: `/folders/{folder_id}/watermark`
        public let path: String

        /// Get watermark for folder
        ///
        /// Retrieve the watermark for a folder.
        public var get: Request<BoxAPI.Watermark> {
            .get(path)
        }

        /// Apply watermark to folder
        ///
        /// Applies or update a watermark on a folder.
        public func put(watermark: PutRequest.Watermark) -> Request<BoxAPI.Watermark> {
            .put(path, body: PutRequest(watermark: watermark))
        }

        public struct PutRequest: Encodable {
            /// The watermark to imprint on the folder
            public var watermark: Watermark

            /// The watermark to imprint on the folder
            public struct Watermark: Encodable {
                /// The type of watermark to apply.
                /// 
                /// Currently only supports one option.
                ///
                /// Example: "default"
                public var imprint: Imprint

                /// The type of watermark to apply.
                /// 
                /// Currently only supports one option.
                ///
                /// Example: "default"
                public enum Imprint: String, Codable, CaseIterable {
                    case `default`
                }

                public init(imprint: Imprint) {
                    self.imprint = imprint
                }
            }

            public init(watermark: Watermark) {
                self.watermark = watermark
            }
        }

        /// Remove watermark from folder
        ///
        /// Removes the watermark from a folder.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var groupMemberships: GroupMemberships {
        GroupMemberships(path: "/group_memberships")
    }

    public struct GroupMemberships {
        /// Path: `/group_memberships`
        public let path: String

        /// Add user to group
        ///
        /// Creates a group membership. Only users with
        /// admin-level permissions will be able to use this API.
        public func post(fields: [String]? = nil, _ body: PostRequest? = nil) -> Request<BoxAPI.GroupMembership> {
            .post(path, query: makePostQuery(fields), body: body)
        }

        private func makePostQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        public struct PostRequest: Encodable {
            /// Custom configuration for the permissions an admin
            /// if a group will receive. This option has no effect
            /// on members with a role of `member`.
            /// 
            /// Setting these permissions overwrites the default
            /// access levels of an admin.
            /// 
            /// Specifying a value of "null" for this object will disable
            /// all configurable permissions. Specifying permissions will set
            /// them accordingly, omitted permissions will be enabled by default.
            ///
            /// Example:
            ///
            /// {
            ///   "can_run_reports" : true
            /// }
            public var configurablePermissions: [String: Bool]?
            /// The group to add the user to.
            public var group: Group
            /// The role of the user in the group.
            ///
            /// Example: "member"
            public var role: Role?
            /// The user to add to the group.
            public var user: User

            /// The group to add the user to.
            public struct Group: Encodable {
                /// The ID of the group to add the user to
                ///
                /// Example: "4545523"
                public var id: String

                public init(id: String) {
                    self.id = id
                }
            }

            /// The role of the user in the group.
            ///
            /// Example: "member"
            public enum Role: String, Codable, CaseIterable {
                case member
                case admin
            }

            /// The user to add to the group.
            public struct User: Encodable {
                /// The ID of the user to add to the group
                ///
                /// Example: "1434325"
                public var id: String

                public init(id: String) {
                    self.id = id
                }
            }

            public init(configurablePermissions: [String: Bool]? = nil, group: Group, role: Role? = nil, user: User) {
                self.configurablePermissions = configurablePermissions
                self.group = group
                self.role = role
                self.user = user
            }

            private enum CodingKeys: String, CodingKey {
                case configurablePermissions = "configurable_permissions"
                case group
                case role
                case user
            }
        }
    }
}

extension Paths.GroupMemberships {
    public func groupMembershipID(_ groupMembershipID: String) -> WithGroupMembershipID {
        WithGroupMembershipID(path: "\(path)/\(groupMembershipID)")
    }

    public struct WithGroupMembershipID {
        /// Path: `/group_memberships/{group_membership_id}`
        public let path: String

        /// Get group membership
        ///
        /// Retrieves a specific group membership. Only admins of this
        /// group or users with admin-level permissions will be able to
        /// use this API.
        public func get(fields: [String]? = nil) -> Request<BoxAPI.GroupMembership> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        /// Update group membership
        ///
        /// Updates a user's group membership. Only admins of this
        /// group or users with admin-level permissions will be able to
        /// use this API.
        public func put(fields: [String]? = nil, _ body: PutRequest? = nil) -> Request<BoxAPI.GroupMembership> {
            .put(path, query: makePutQuery(fields), body: body)
        }

        private func makePutQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        public struct PutRequest: Encodable {
            /// Custom configuration for the permissions an admin
            /// if a group will receive. This option has no effect
            /// on members with a role of `member`.
            /// 
            /// Setting these permissions overwrites the default
            /// access levels of an admin.
            /// 
            /// Specifying a value of "null" for this object will disable
            /// all configurable permissions. Specifying permissions will set
            /// them accordingly, omitted permissions will be enabled by default.
            ///
            /// Example:
            ///
            /// {
            ///   "can_run_reports" : true
            /// }
            public var configurablePermissions: [String: Bool]?
            /// The role of the user in the group.
            ///
            /// Example: "member"
            public var role: Role?

            /// The role of the user in the group.
            ///
            /// Example: "member"
            public enum Role: String, Codable, CaseIterable {
                case member
                case admin
            }

            public init(configurablePermissions: [String: Bool]? = nil, role: Role? = nil) {
                self.configurablePermissions = configurablePermissions
                self.role = role
            }

            private enum CodingKeys: String, CodingKey {
                case configurablePermissions = "configurable_permissions"
                case role
            }
        }

        /// Remove user from group
        ///
        /// Deletes a specific group membership. Only admins of this
        /// group or users with admin-level permissions will be able to
        /// use this API.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var groups: Groups {
        Groups(path: "/groups")
    }

    public struct Groups {
        /// Path: `/groups`
        public let path: String

        /// List groups for enterprise
        ///
        /// Retrieves all of the groups for a given enterprise. The user
        /// must have admin permissions to inspect enterprise's groups.
        public func get(parameters: GetParameters? = nil) -> Request<BoxAPI.Groups> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var filterTerm: String?
            public var fields: [String]?
            public var limit: Int?
            public var offset: Int?

            public init(filterTerm: String? = nil, fields: [String]? = nil, limit: Int? = nil, offset: Int? = nil) {
                self.filterTerm = filterTerm
                self.fields = fields
                self.limit = limit
                self.offset = offset
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(filterTerm, forKey: "filter_term")
                encoder.encode(fields, forKey: "fields", explode: false)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                return encoder.items
            }
        }

        /// Create group
        ///
        /// Creates a new group of users in an enterprise. Only users with admin
        /// permissions can create new groups.
        public func post(fields: [String]? = nil, _ body: PostRequest? = nil) -> Request<BoxAPI.Group> {
            .post(path, query: makePostQuery(fields), body: body)
        }

        private func makePostQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        public struct PostRequest: Encodable {
            /// A human readable description of the group.
            ///
            /// Example: "Customer Support Group - as imported from Active Directory"
            public var description: String?
            /// An arbitrary identifier that can be used by
            /// external group sync tools to link this Box Group to
            /// an external group.
            /// 
            /// Example values of this field
            /// could be an **Active Directory Object ID** or a **Google
            /// Group ID**.
            /// 
            /// We recommend you use of this field in
            /// order to avoid issues when group names are updated in
            /// either Box or external systems.
            ///
            /// Example: "AD:123456"
            public var externalSyncIdentifier: String?
            /// Specifies who can invite the group to collaborate
            /// on folders.
            /// 
            /// When set to `admins_only` the enterprise admin, co-admins,
            /// and the group's admin can invite the group.
            /// 
            /// When set to `admins_and_members` all the admins listed
            /// above and group members can invite the group.
            /// 
            /// When set to `all_managed_users` all managed users in the
            /// enterprise can invite the group.
            ///
            /// Example: "admins_only"
            public var invitabilityLevel: InvitabilityLevel?
            /// Specifies who can see the members of the group.
            /// 
            /// * `admins_only` - the enterprise admin, co-admins, group's
            ///   group admin
            /// * `admins_and_members` - all admins and group members
            /// * `all_managed_users` - all managed users in the
            ///   enterprise
            ///
            /// Example: "admins_only"
            public var memberViewabilityLevel: MemberViewabilityLevel?
            /// The name of the new group to be created. This name must be unique
            /// within the enterprise.
            ///
            /// Example: "Customer Support"
            public var name: String
            /// Keeps track of which external source this group is
            /// coming, for example `Active Directory`, or `Okta`.
            /// 
            /// Setting this will also prevent Box admins from editing
            /// the group name and its members directly via the Box
            /// web application.
            /// 
            /// This is desirable for one-way syncing of groups.
            ///
            /// Example: "Active Directory"
            public var provenance: String?

            /// Specifies who can invite the group to collaborate
            /// on folders.
            /// 
            /// When set to `admins_only` the enterprise admin, co-admins,
            /// and the group's admin can invite the group.
            /// 
            /// When set to `admins_and_members` all the admins listed
            /// above and group members can invite the group.
            /// 
            /// When set to `all_managed_users` all managed users in the
            /// enterprise can invite the group.
            ///
            /// Example: "admins_only"
            public enum InvitabilityLevel: String, Codable, CaseIterable {
                case adminsOnly = "admins_only"
                case adminsAndMembers = "admins_and_members"
                case allManagedUsers = "all_managed_users"
            }

            /// Specifies who can see the members of the group.
            /// 
            /// * `admins_only` - the enterprise admin, co-admins, group's
            ///   group admin
            /// * `admins_and_members` - all admins and group members
            /// * `all_managed_users` - all managed users in the
            ///   enterprise
            ///
            /// Example: "admins_only"
            public enum MemberViewabilityLevel: String, Codable, CaseIterable {
                case adminsOnly = "admins_only"
                case adminsAndMembers = "admins_and_members"
                case allManagedUsers = "all_managed_users"
            }

            public init(description: String? = nil, externalSyncIdentifier: String? = nil, invitabilityLevel: InvitabilityLevel? = nil, memberViewabilityLevel: MemberViewabilityLevel? = nil, name: String, provenance: String? = nil) {
                self.description = description
                self.externalSyncIdentifier = externalSyncIdentifier
                self.invitabilityLevel = invitabilityLevel
                self.memberViewabilityLevel = memberViewabilityLevel
                self.name = name
                self.provenance = provenance
            }

            private enum CodingKeys: String, CodingKey {
                case description
                case externalSyncIdentifier = "external_sync_identifier"
                case invitabilityLevel = "invitability_level"
                case memberViewabilityLevel = "member_viewability_level"
                case name
                case provenance
            }
        }
    }
}

extension Paths.Groups {
    public func groupID(_ groupID: String) -> WithGroupID {
        WithGroupID(path: "\(path)/\(groupID)")
    }

    public struct WithGroupID {
        /// Path: `/groups/{group_id}`
        public let path: String

        /// Get group
        ///
        /// Retrieves information about a group. Only members of this
        /// group or users with admin-level permissions will be able to
        /// use this API.
        public func get(fields: [String]? = nil) -> Request<BoxAPI.Group> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        /// Update group
        ///
        /// Updates a specific group. Only admins of this
        /// group or users with admin-level permissions will be able to
        /// use this API.
        public func put(fields: [String]? = nil, _ body: PutRequest? = nil) -> Request<BoxAPI.Group> {
            .put(path, query: makePutQuery(fields), body: body)
        }

        private func makePutQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        public struct PutRequest: Encodable {
            /// A human readable description of the group.
            ///
            /// Example: "Customer Support Group - as imported from Active Directory"
            public var description: String?
            /// An arbitrary identifier that can be used by
            /// external group sync tools to link this Box Group to
            /// an external group.
            /// 
            /// Example values of this field
            /// could be an **Active Directory Object ID** or a **Google
            /// Group ID**.
            /// 
            /// We recommend you use of this field in
            /// order to avoid issues when group names are updated in
            /// either Box or external systems.
            ///
            /// Example: "AD:123456"
            public var externalSyncIdentifier: String?
            /// Specifies who can invite the group to collaborate
            /// on folders.
            /// 
            /// When set to `admins_only` the enterprise admin, co-admins,
            /// and the group's admin can invite the group.
            /// 
            /// When set to `admins_and_members` all the admins listed
            /// above and group members can invite the group.
            /// 
            /// When set to `all_managed_users` all managed users in the
            /// enterprise can invite the group.
            ///
            /// Example: "admins_only"
            public var invitabilityLevel: InvitabilityLevel?
            /// Specifies who can see the members of the group.
            /// 
            /// * `admins_only` - the enterprise admin, co-admins, group's
            ///   group admin
            /// * `admins_and_members` - all admins and group members
            /// * `all_managed_users` - all managed users in the
            ///   enterprise
            ///
            /// Example: "admins_only"
            public var memberViewabilityLevel: MemberViewabilityLevel?
            /// The name of the new group to be created. Must be unique within the
            /// enterprise.
            ///
            /// Example: "Customer Support"
            public var name: String?
            /// Keeps track of which external source this group is
            /// coming, for example `Active Directory`, or `Okta`.
            /// 
            /// Setting this will also prevent Box admins from editing
            /// the group name and its members directly via the Box
            /// web application.
            /// 
            /// This is desirable for one-way syncing of groups.
            ///
            /// Example: "Active Directory"
            public var provenance: String?

            /// Specifies who can invite the group to collaborate
            /// on folders.
            /// 
            /// When set to `admins_only` the enterprise admin, co-admins,
            /// and the group's admin can invite the group.
            /// 
            /// When set to `admins_and_members` all the admins listed
            /// above and group members can invite the group.
            /// 
            /// When set to `all_managed_users` all managed users in the
            /// enterprise can invite the group.
            ///
            /// Example: "admins_only"
            public enum InvitabilityLevel: String, Codable, CaseIterable {
                case adminsOnly = "admins_only"
                case adminsAndMembers = "admins_and_members"
                case allManagedUsers = "all_managed_users"
            }

            /// Specifies who can see the members of the group.
            /// 
            /// * `admins_only` - the enterprise admin, co-admins, group's
            ///   group admin
            /// * `admins_and_members` - all admins and group members
            /// * `all_managed_users` - all managed users in the
            ///   enterprise
            ///
            /// Example: "admins_only"
            public enum MemberViewabilityLevel: String, Codable, CaseIterable {
                case adminsOnly = "admins_only"
                case adminsAndMembers = "admins_and_members"
                case allManagedUsers = "all_managed_users"
            }

            public init(description: String? = nil, externalSyncIdentifier: String? = nil, invitabilityLevel: InvitabilityLevel? = nil, memberViewabilityLevel: MemberViewabilityLevel? = nil, name: String? = nil, provenance: String? = nil) {
                self.description = description
                self.externalSyncIdentifier = externalSyncIdentifier
                self.invitabilityLevel = invitabilityLevel
                self.memberViewabilityLevel = memberViewabilityLevel
                self.name = name
                self.provenance = provenance
            }

            private enum CodingKeys: String, CodingKey {
                case description
                case externalSyncIdentifier = "external_sync_identifier"
                case invitabilityLevel = "invitability_level"
                case memberViewabilityLevel = "member_viewability_level"
                case name
                case provenance
            }
        }

        /// Remove group
        ///
        /// Permanently deletes a group. Only users with
        /// admin-level permissions will be able to use this API.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Groups.WithGroupID {
    public var collaborations: Collaborations {
        Collaborations(path: path + "/collaborations")
    }

    public struct Collaborations {
        /// Path: `/groups/{group_id}/collaborations`
        public let path: String

        /// List group collaborations
        ///
        /// Retrieves all the collaborations for a group. The user
        /// must have admin permissions to inspect enterprise's groups.
        /// 
        /// Each collaboration object has details on which files or
        /// folders the group has access to and with what role.
        public func get(limit: Int? = nil, offset: Int? = nil) -> Request<BoxAPI.Collaborations> {
            .get(path, query: makeGetQuery(limit, offset))
        }

        private func makeGetQuery(_ limit: Int?, _ offset: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(limit, forKey: "limit")
            encoder.encode(offset, forKey: "offset")
            return encoder.items
        }
    }
}

extension Paths.Groups.WithGroupID {
    public var memberships: Memberships {
        Memberships(path: path + "/memberships")
    }

    public struct Memberships {
        /// Path: `/groups/{group_id}/memberships`
        public let path: String

        /// List members of group
        ///
        /// Retrieves all the members for a group. Only members of this
        /// group or users with admin-level permissions will be able to
        /// use this API.
        public func get(limit: Int? = nil, offset: Int? = nil) -> Request<BoxAPI.GroupMemberships> {
            .get(path, query: makeGetQuery(limit, offset))
        }

        private func makeGetQuery(_ limit: Int?, _ offset: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(limit, forKey: "limit")
            encoder.encode(offset, forKey: "offset")
            return encoder.items
        }
    }
}

extension Paths {
    public static var invites: Invites {
        Invites(path: "/invites")
    }

    public struct Invites {
        /// Path: `/invites`
        public let path: String

        /// Create user invite
        ///
        /// Invites an existing external user to join an enterprise.
        /// 
        /// The existing user can not be part of another enterprise and
        /// must already have a Box account. Once invited, the user will receive an
        /// email and are prompted to accept the invitation within the
        /// Box web application.
        /// 
        /// This method requires the "Manage An Enterprise" scope enabled for
        /// the application, which can be enabled within the developer console.
        public func post(fields: [String]? = nil, _ body: PostRequest? = nil) -> Request<BoxAPI.Invite> {
            .post(path, query: makePostQuery(fields), body: body)
        }

        private func makePostQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        public struct PostRequest: Encodable {
            /// The user to invite
            public var actionableBy: ActionableBy
            /// The enterprise to invite the user to
            public var enterprise: Enterprise

            /// The user to invite
            public struct ActionableBy: Encodable {
                /// The login of the invited user
                ///
                /// Example: "john@example.com"
                public var login: String?
                public var id: AnyJSON

                public init(login: String? = nil, id: AnyJSON) {
                    self.login = login
                    self.id = id
                }
            }

            /// The enterprise to invite the user to
            public struct Enterprise: Encodable {
                /// The ID of the enterprise
                ///
                /// Example: "1232234"
                public var id: String

                public init(id: String) {
                    self.id = id
                }
            }

            public init(actionableBy: ActionableBy, enterprise: Enterprise) {
                self.actionableBy = actionableBy
                self.enterprise = enterprise
            }

            private enum CodingKeys: String, CodingKey {
                case actionableBy = "actionable_by"
                case enterprise
            }
        }
    }
}

extension Paths.Invites {
    public func inviteID(_ inviteID: String) -> WithInviteID {
        WithInviteID(path: "\(path)/\(inviteID)")
    }

    public struct WithInviteID {
        /// Path: `/invites/{invite_id}`
        public let path: String

        /// Get user invite status
        ///
        /// Returns the status of a user invite.
        public func get(fields: [String]? = nil) -> Request<BoxAPI.Invite> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }
    }
}

extension Paths {
    public static var legalHoldPolicies: LegalHoldPolicies {
        LegalHoldPolicies(path: "/legal_hold_policies")
    }

    public struct LegalHoldPolicies {
        /// Path: `/legal_hold_policies`
        public let path: String

        /// List all legal hold policies
        ///
        /// Retrieves a list of legal hold policies that belong to
        /// an enterprise.
        public func get(parameters: GetParameters? = nil) -> Request<BoxAPI.LegalHoldPolicies> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var policyName: String?
            public var fields: [String]?
            public var marker: String?
            public var limit: Int?

            public init(policyName: String? = nil, fields: [String]? = nil, marker: String? = nil, limit: Int? = nil) {
                self.policyName = policyName
                self.fields = fields
                self.marker = marker
                self.limit = limit
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(policyName, forKey: "policy_name")
                encoder.encode(fields, forKey: "fields", explode: false)
                encoder.encode(marker, forKey: "marker")
                encoder.encode(limit, forKey: "limit")
                return encoder.items
            }
        }

        /// Create legal hold policy
        ///
        /// Create a new legal hold policy.
        public func post(_ body: PostRequest? = nil) -> Request<BoxAPI.LegalHoldPolicy> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// A description for the policy.
            ///
            /// Example: "A custom policy for the sales team"
            public var description: String?
            /// The filter end date.
            /// 
            /// When this policy is applied using a `custodian` legal
            /// hold assignments, it will only apply to file versions
            /// created or uploaded inside of the
            /// date range. Other assignment types, such as folders and
            /// files, will ignore the date filter.
            /// 
            /// Required if `is_ongoing` is set to `false`.
            ///
            /// Example: "2012-12-18T10:53:43-08:00"
            public var filterEndedAt: Date?
            /// The filter start date.
            /// 
            /// When this policy is applied using a `custodian` legal
            /// hold assignments, it will only apply to file versions
            /// created or uploaded inside of the
            /// date range. Other assignment types, such as folders and
            /// files, will ignore the date filter.
            /// 
            /// Required if `is_ongoing` is set to `false`.
            ///
            /// Example: "2012-12-12T10:53:43-08:00"
            public var filterStartedAt: Date?
            /// Whether new assignments under this policy should
            /// continue applying to files even after initialization.
            /// 
            /// When this policy is applied using a legal hold assignment,
            /// it will continue applying the policy to any new file versions
            /// even after it has been applied.
            /// 
            /// For example, if a legal hold assignment is placed on a user
            /// today, and that user uploads a file tomorrow, that file will
            /// get held. This will continue until the policy is retired.
            /// 
            /// Required if no filter dates are set.
            ///
            /// Example: true
            public var isOngoing: Bool?
            /// The name of the policy.
            ///
            /// Example: "Sales Policy"
            public var policyName: String

            public init(description: String? = nil, filterEndedAt: Date? = nil, filterStartedAt: Date? = nil, isOngoing: Bool? = nil, policyName: String) {
                self.description = description
                self.filterEndedAt = filterEndedAt
                self.filterStartedAt = filterStartedAt
                self.isOngoing = isOngoing
                self.policyName = policyName
            }

            private enum CodingKeys: String, CodingKey {
                case description
                case filterEndedAt = "filter_ended_at"
                case filterStartedAt = "filter_started_at"
                case isOngoing = "is_ongoing"
                case policyName = "policy_name"
            }
        }
    }
}

extension Paths.LegalHoldPolicies {
    public func legalHoldPolicyID(_ legalHoldPolicyID: String) -> WithLegalHoldPolicyID {
        WithLegalHoldPolicyID(path: "\(path)/\(legalHoldPolicyID)")
    }

    public struct WithLegalHoldPolicyID {
        /// Path: `/legal_hold_policies/{legal_hold_policy_id}`
        public let path: String

        /// Get legal hold policy
        ///
        /// Retrieve a legal hold policy.
        public var get: Request<BoxAPI.LegalHoldPolicy> {
            .get(path)
        }

        /// Update legal hold policy
        ///
        /// Update legal hold policy.
        public func put(_ body: PutRequest? = nil) -> Request<BoxAPI.LegalHoldPolicy> {
            .put(path, body: body)
        }

        public struct PutRequest: Encodable {
            /// A description for the policy.
            ///
            /// Example: "A custom policy for the sales team"
            public var description: String?
            /// The name of the policy.
            ///
            /// Example: "Sales Policy"
            public var policyName: String?
            /// Notes around why the policy was released.
            ///
            /// Example: "Required for GDPR"
            public var releaseNotes: String?

            public init(description: String? = nil, policyName: String? = nil, releaseNotes: String? = nil) {
                self.description = description
                self.policyName = policyName
                self.releaseNotes = releaseNotes
            }

            private enum CodingKeys: String, CodingKey {
                case description
                case policyName = "policy_name"
                case releaseNotes = "release_notes"
            }
        }

        /// Remove legal hold policy
        ///
        /// Delete an existing legal hold policy.
        /// 
        /// This is an asynchronous process. The policy will not be
        /// fully deleted yet when the response returns.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var legalHoldPolicyAssignments: LegalHoldPolicyAssignments {
        LegalHoldPolicyAssignments(path: "/legal_hold_policy_assignments")
    }

    public struct LegalHoldPolicyAssignments {
        /// Path: `/legal_hold_policy_assignments`
        public let path: String

        /// List legal hold policy assignments
        ///
        /// Retrieves a list of items a legal hold policy has been assigned to.
        public func get(parameters: GetParameters) -> Request<BoxAPI.LegalHoldPolicyAssignments> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var policyID: String
            public var assignToType: AssignToType?
            public var assignToID: String?
            public var marker: String?
            public var limit: Int?
            public var fields: [String]?

            public enum AssignToType: String, Codable, CaseIterable {
                case file
                case fileVersion = "file_version"
                case folder
                case user
            }

            public init(policyID: String, assignToType: AssignToType? = nil, assignToID: String? = nil, marker: String? = nil, limit: Int? = nil, fields: [String]? = nil) {
                self.policyID = policyID
                self.assignToType = assignToType
                self.assignToID = assignToID
                self.marker = marker
                self.limit = limit
                self.fields = fields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(policyID, forKey: "policy_id")
                encoder.encode(assignToType, forKey: "assign_to_type")
                encoder.encode(assignToID, forKey: "assign_to_id")
                encoder.encode(marker, forKey: "marker")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(fields, forKey: "fields", explode: false)
                return encoder.items
            }
        }

        /// Assign legal hold policy
        ///
        /// Assign a legal hold to a file, file version, folder, or user.
        public func post(_ body: PostRequest? = nil) -> Request<BoxAPI.LegalHoldPolicyAssignment> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The item to assign the policy to
            public var assignTo: AssignTo
            /// The ID of the policy to assign.
            ///
            /// Example: "123244"
            public var policyID: String

            /// The item to assign the policy to
            public struct AssignTo: Encodable {
                /// The ID of item to assign the policy to
                ///
                /// Example: "6564564"
                public var id: String
                /// The type of item to assign the policy to
                ///
                /// Example: "folder"
                public var type: `Type`

                /// The type of item to assign the policy to
                ///
                /// Example: "folder"
                public enum `Type`: String, Codable, CaseIterable {
                    case file
                    case fileVersion = "file_version"
                    case folder
                    case user
                }

                public init(id: String, type: `Type`) {
                    self.id = id
                    self.type = type
                }
            }

            public init(assignTo: AssignTo, policyID: String) {
                self.assignTo = assignTo
                self.policyID = policyID
            }

            private enum CodingKeys: String, CodingKey {
                case assignTo = "assign_to"
                case policyID = "policy_id"
            }
        }
    }
}

extension Paths.LegalHoldPolicyAssignments {
    public func legalHoldPolicyAssignmentID(_ legalHoldPolicyAssignmentID: String) -> WithLegalHoldPolicyAssignmentID {
        WithLegalHoldPolicyAssignmentID(path: "\(path)/\(legalHoldPolicyAssignmentID)")
    }

    public struct WithLegalHoldPolicyAssignmentID {
        /// Path: `/legal_hold_policy_assignments/{legal_hold_policy_assignment_id}`
        public let path: String

        /// Get legal hold policy assignment
        ///
        /// Retrieve a legal hold policy assignment.
        public var get: Request<BoxAPI.LegalHoldPolicyAssignment> {
            .get(path)
        }

        /// Unassign legal hold policy
        ///
        /// Remove a legal hold from an item.
        /// 
        /// This is an asynchronous process. The policy will not be
        /// fully removed yet when the response returns.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.LegalHoldPolicyAssignments.WithLegalHoldPolicyAssignmentID {
    public var fileVersionsOnHold: FileVersionsOnHold {
        FileVersionsOnHold(path: path + "/file_versions_on_hold")
    }

    public struct FileVersionsOnHold {
        /// Path: `/legal_hold_policy_assignments/{legal_hold_policy_assignment_id}/file_versions_on_hold`
        public let path: String

        /// List previous file versions for legal hold policy assignment
        ///
        /// Get a list of previous file versions for a legal hold
        /// assignment.
        /// 
        /// In some cases you may only need the latest file versions instead. In these
        /// cases, use the `GET  /legal_hold_policy_assignments/:id/files_on_hold` API
        /// instead to return any current (latest) versions of a file for this legal hold
        /// policy assignment.
        /// 
        /// Due to ongoing re-architecture efforts this API might not return all files
        /// held for this policy ID. Instead, this API will only return past file versions
        /// held in the newly developed architecture. The `GET /file_version_legal_holds`
        /// API can be used to fetch current and past versions of files held within the
        /// legacy architecture.
        /// 
        /// The `GET /legal_hold_policy_assignments?policy_id={id}` API can be used to
        /// find a list of policy assignments for a given policy ID.
        public func get(parameters: GetParameters? = nil) -> Request<BoxAPI.FileVersionLegalHolds> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var marker: String?
            public var limit: Int?
            public var fields: [String]?

            public init(marker: String? = nil, limit: Int? = nil, fields: [String]? = nil) {
                self.marker = marker
                self.limit = limit
                self.fields = fields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(marker, forKey: "marker")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(fields, forKey: "fields", explode: false)
                return encoder.items
            }
        }
    }
}

extension Paths.LegalHoldPolicyAssignments.WithLegalHoldPolicyAssignmentID {
    public var filesOnHold: FilesOnHold {
        FilesOnHold(path: path + "/files_on_hold")
    }

    public struct FilesOnHold {
        /// Path: `/legal_hold_policy_assignments/{legal_hold_policy_assignment_id}/files_on_hold`
        public let path: String

        /// List current file versions for legal hold policy assignment
        ///
        /// Get a list of current file versions for a legal hold
        /// assignment.
        /// 
        /// In some cases you may want to get previous file versions instead. In these
        /// cases, use the `GET  /legal_hold_policy_assignments/:id/file_versions_on_hold`
        /// API instead to return any previous versions of a file for this legal hold
        /// policy assignment.
        /// 
        /// Due to ongoing re-architecture efforts this API might not return all file
        /// versions held for this policy ID. Instead, this API will only return the
        /// latest file version held in the newly developed architecture. The `GET
        /// /file_version_legal_holds` API can be used to fetch current and past versions
        /// of files held within the legacy architecture.
        /// 
        /// The `GET /legal_hold_policy_assignments?policy_id={id}` API can be used to
        /// find a list of policy assignments for a given policy ID.
        public func get(parameters: GetParameters? = nil) -> Request<BoxAPI.FileVersionLegalHolds> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var marker: String?
            public var limit: Int?
            public var fields: [String]?

            public init(marker: String? = nil, limit: Int? = nil, fields: [String]? = nil) {
                self.marker = marker
                self.limit = limit
                self.fields = fields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(marker, forKey: "marker")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(fields, forKey: "fields", explode: false)
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var metadataCascadePolicies: MetadataCascadePolicies {
        MetadataCascadePolicies(path: "/metadata_cascade_policies")
    }

    public struct MetadataCascadePolicies {
        /// Path: `/metadata_cascade_policies`
        public let path: String

        /// List metadata cascade policies
        ///
        /// Retrieves a list of all the metadata cascade policies
        /// that are applied to a given folder. This can not be used on the root
        /// folder with ID `0`.
        public func get(parameters: GetParameters) -> Request<BoxAPI.MetadataCascadePolicies> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var folderID: String
            public var ownerEnterpriseID: String?
            public var marker: String?
            public var offset: Int?

            public init(folderID: String, ownerEnterpriseID: String? = nil, marker: String? = nil, offset: Int? = nil) {
                self.folderID = folderID
                self.ownerEnterpriseID = ownerEnterpriseID
                self.marker = marker
                self.offset = offset
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(folderID, forKey: "folder_id")
                encoder.encode(ownerEnterpriseID, forKey: "owner_enterprise_id")
                encoder.encode(marker, forKey: "marker")
                encoder.encode(offset, forKey: "offset")
                return encoder.items
            }
        }

        /// Create metadata cascade policy
        ///
        /// Creates a new metadata cascade policy that applies a given
        /// metadata template to a given folder and automatically
        /// cascades it down to any files within that folder.
        /// 
        /// In order for the policy to be applied a metadata instance must first
        /// be applied to the folder the policy is to be applied to.
        public func post(_ body: PostRequest? = nil) -> Request<BoxAPI.MetadataCascadePolicy> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The ID of the folder to apply the policy to. This folder will
            /// need to already have an instance of the targeted metadata
            /// template applied to it.
            ///
            /// Example: "1234567"
            public var folderID: String
            /// The scope of the targeted metadata template. This template will
            /// need to already have an instance applied to the targeted folder.
            ///
            /// Example: "enterprise"
            public var scope: Scope
            /// The key of the targeted metadata template. This template will
            /// need to already have an instance applied to the targeted folder.
            /// 
            /// In many cases the template key is automatically derived
            /// of its display name, for example `Contract Template` would
            /// become `contractTemplate`. In some cases the creator of the
            /// template will have provided its own template key.
            /// 
            /// Please [list the templates for an enterprise][list], or
            /// get all instances on a [file][file] or [folder][folder]
            /// to inspect a template's key.
            /// 
            /// [list]: e://get-metadata-templates-enterprise
            /// [file]: e://get-files-id-metadata
            /// [folder]: e://get-folders-id-metadata
            ///
            /// Example: "productInfo"
            public var templateKey: String

            /// The scope of the targeted metadata template. This template will
            /// need to already have an instance applied to the targeted folder.
            ///
            /// Example: "enterprise"
            public enum Scope: String, Codable, CaseIterable {
                case global
                case enterprise
            }

            public init(folderID: String, scope: Scope, templateKey: String) {
                self.folderID = folderID
                self.scope = scope
                self.templateKey = templateKey
            }

            private enum CodingKeys: String, CodingKey {
                case folderID = "folder_id"
                case scope
                case templateKey
            }
        }
    }
}

extension Paths.MetadataCascadePolicies {
    public func metadataCascadePolicyID(_ metadataCascadePolicyID: String) -> WithMetadataCascadePolicyID {
        WithMetadataCascadePolicyID(path: "\(path)/\(metadataCascadePolicyID)")
    }

    public struct WithMetadataCascadePolicyID {
        /// Path: `/metadata_cascade_policies/{metadata_cascade_policy_id}`
        public let path: String

        /// Get metadata cascade policy
        ///
        /// Retrieve a specific metadata cascade policy assigned to a folder.
        public var get: Request<BoxAPI.MetadataCascadePolicy> {
            .get(path)
        }

        /// Remove metadata cascade policy
        ///
        /// Deletes a metadata cascade policy.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.MetadataCascadePolicies.WithMetadataCascadePolicyID {
    public var apply: Apply {
        Apply(path: path + "/apply")
    }

    public struct Apply {
        /// Path: `/metadata_cascade_policies/{metadata_cascade_policy_id}/apply`
        public let path: String

        /// Force-apply metadata cascade policy to folder
        ///
        /// Force the metadata on a folder with a metadata cascade policy to be applied to
        /// all of its children. This can be used after creating a new cascade policy to
        /// enforce the metadata to be cascaded down to all existing files within that
        /// folder.
        public func post(conflictResolution: PostRequest.ConflictResolution) -> Request<Void> {
            .post(path, body: PostRequest(conflictResolution: conflictResolution))
        }

        public struct PostRequest: Encodable {
            /// Describes the desired behavior when dealing with the conflict
            /// where a metadata template already has an instance applied
            /// to a child.
            /// 
            /// * `none` will preserve the existing value on the file
            /// * `overwrite` will force-apply the templates values over
            ///   any existing values.
            ///
            /// Example: "none"
            public var conflictResolution: ConflictResolution

            /// Describes the desired behavior when dealing with the conflict
            /// where a metadata template already has an instance applied
            /// to a child.
            /// 
            /// * `none` will preserve the existing value on the file
            /// * `overwrite` will force-apply the templates values over
            ///   any existing values.
            ///
            /// Example: "none"
            public enum ConflictResolution: String, Codable, CaseIterable {
                case `none`
                case overwrite
            }

            public init(conflictResolution: ConflictResolution) {
                self.conflictResolution = conflictResolution
            }

            private enum CodingKeys: String, CodingKey {
                case conflictResolution = "conflict_resolution"
            }
        }
    }
}

extension Paths {
    public static var metadataQueries: MetadataQueries {
        MetadataQueries(path: "/metadata_queries")
    }

    public struct MetadataQueries {
        /// Path: `/metadata_queries`
        public let path: String
    }
}

extension Paths.MetadataQueries {
    public var executeRead: ExecuteRead {
        ExecuteRead(path: path + "/execute_read")
    }

    public struct ExecuteRead {
        /// Path: `/metadata_queries/execute_read`
        public let path: String

        /// Query files/folders by metadata
        ///
        /// Create a search using SQL-like syntax to return items that match specific
        /// metadata.
        /// 
        /// By default, this endpoint returns only the most basic info about the items for
        /// which the query matches. To get additional fields for each item, including any
        /// of the metadata, use the `fields` attribute in the query.
        public func post(_ body: BoxAPI.MetadataQuery? = nil) -> Request<BoxAPI.MetadataQueryResults> {
            .post(path, body: body)
        }
    }
}

extension Paths {
    public static var metadataQueryIndices: MetadataQueryIndices {
        MetadataQueryIndices(path: "/metadata_query_indices")
    }

    public struct MetadataQueryIndices {
        /// Path: `/metadata_query_indices`
        public let path: String

        /// List metadata query indices
        ///
        /// Retrieves the metadata query indices for a given scope and template key.
        public func get(scope: Scope, templateKey: String) -> Request<BoxAPI.MetadataQueryIndices> {
            .get(path, query: makeGetQuery(scope, templateKey))
        }

        private func makeGetQuery(_ scope: Scope, _ templateKey: String) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(scope, forKey: "scope")
            encoder.encode(templateKey, forKey: "template_key")
            return encoder.items
        }

        public enum Scope: String, Codable, CaseIterable {
            case global
            case enterprise
        }
    }
}

extension Paths {
    public static var metadataTemplates: MetadataTemplates {
        MetadataTemplates(path: "/metadata_templates")
    }

    public struct MetadataTemplates {
        /// Path: `/metadata_templates`
        public let path: String

        /// Find metadata template by instance ID
        ///
        /// Finds a metadata template by searching for the ID of an instance of the
        /// template.
        public func get(metadataInstanceID: String) -> Request<BoxAPI.MetadataTemplates> {
            .get(path, query: [("metadata_instance_id", metadataInstanceID)])
        }
    }
}

extension Paths.MetadataTemplates {
    public var enterprise: Enterprise {
        Enterprise(path: path + "/enterprise")
    }

    public struct Enterprise {
        /// Path: `/metadata_templates/enterprise`
        public let path: String

        /// List all metadata templates for enterprise
        ///
        /// Used to retrieve all metadata templates created to be used specifically within
        /// the user's enterprise
        public func get(marker: String? = nil, limit: Int? = nil) -> Request<BoxAPI.MetadataTemplates> {
            .get(path, query: makeGetQuery(marker, limit))
        }

        private func makeGetQuery(_ marker: String?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(marker, forKey: "marker")
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths.MetadataTemplates.Enterprise {
    public var securityClassification6VMVochwUWo: SecurityClassification6VMVochwUWo {
        SecurityClassification6VMVochwUWo(path: path + "/securityClassification-6VMVochwUWo")
    }

    public struct SecurityClassification6VMVochwUWo {
        /// Path: `/metadata_templates/enterprise/securityClassification-6VMVochwUWo`
        public let path: String
    }
}

extension Paths.MetadataTemplates.Enterprise.SecurityClassification6VMVochwUWo {
    public var schema: Schema {
        Schema(path: path + "/schema")
    }

    public struct Schema {
        /// Path: `/metadata_templates/enterprise/securityClassification-6VMVochwUWo/schema`
        public let path: String

        /// List all classifications
        ///
        /// Retrieves the classification metadata template and lists all the
        /// classifications available to this enterprise.
        /// 
        /// This API can also be called by including the enterprise ID in the
        /// URL explicitly, for example
        /// `/metadata_templates/enterprise_12345/securityClassification-6VMVochwUWo/schema`.
        public var get: Request<BoxAPI.ClassificationTemplate> {
            .get(path)
        }

        /// Delete all classifications
        ///
        /// Delete all classifications by deleting the classification
        /// metadata template.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.MetadataTemplates.Enterprise.SecurityClassification6VMVochwUWo {
    public var schemaAdd: SchemaAdd {
        SchemaAdd(path: path + "/schema#add")
    }

    public struct SchemaAdd {
        /// Path: `/metadata_templates/enterprise/securityClassification-6VMVochwUWo/schema#add`
        public let path: String

        /// Add classification
        ///
        /// Adds one or more new classifications to the list of classifications
        /// available to the enterprise.
        /// 
        /// This API can also be called by including the enterprise ID in the
        /// URL explicitly, for example
        /// `/metadata_templates/enterprise_12345/securityClassification-6VMVochwUWo/schema`.
        public func put(_ body: Data) -> Request<BoxAPI.ClassificationTemplate> {
            .put(path, body: body)
        }
    }
}

extension Paths.MetadataTemplates.Enterprise.SecurityClassification6VMVochwUWo {
    public var schemaDelete: SchemaDelete {
        SchemaDelete(path: path + "/schema#delete")
    }

    public struct SchemaDelete {
        /// Path: `/metadata_templates/enterprise/securityClassification-6VMVochwUWo/schema#delete`
        public let path: String

        /// Delete classification
        ///
        /// Removes a classification from the list of classifications
        /// available to the enterprise.
        /// 
        /// This API can also be called by including the enterprise ID in the
        /// URL explicitly, for example
        /// `/metadata_templates/enterprise_12345/securityClassification-6VMVochwUWo/schema`.
        public func put(_ body: Data) -> Request<BoxAPI.ClassificationTemplate> {
            .put(path, body: body)
        }
    }
}

extension Paths.MetadataTemplates.Enterprise.SecurityClassification6VMVochwUWo {
    public var schemaUpdate: SchemaUpdate {
        SchemaUpdate(path: path + "/schema#update")
    }

    public struct SchemaUpdate {
        /// Path: `/metadata_templates/enterprise/securityClassification-6VMVochwUWo/schema#update`
        public let path: String

        /// Update classification
        ///
        /// Updates the labels and descriptions of one or more classifications
        /// available to the enterprise.
        /// 
        /// This API can also be called by including the enterprise ID in the
        /// URL explicitly, for example
        /// `/metadata_templates/enterprise_12345/securityClassification-6VMVochwUWo/schema`.
        public func put(_ body: Data) -> Request<BoxAPI.ClassificationTemplate> {
            .put(path, body: body)
        }
    }
}

extension Paths.MetadataTemplates {
    public var global: Global {
        Global(path: path + "/global")
    }

    public struct Global {
        /// Path: `/metadata_templates/global`
        public let path: String

        /// List all global metadata templates
        ///
        /// Used to retrieve all generic, global metadata templates available to all
        /// enterprises using Box.
        public func get(marker: String? = nil, limit: Int? = nil) -> Request<BoxAPI.MetadataTemplates> {
            .get(path, query: makeGetQuery(marker, limit))
        }

        private func makeGetQuery(_ marker: String?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(marker, forKey: "marker")
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths.MetadataTemplates {
    public var schema: Schema {
        Schema(path: path + "/schema")
    }

    public struct Schema {
        /// Path: `/metadata_templates/schema`
        public let path: String

        /// Create metadata template
        ///
        /// Creates a new metadata template that can be applied to
        /// files and folders.
        public func post(_ body: PostRequest? = nil) -> Request<BoxAPI.MetadataTemplate> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Whether or not to copy any metadata attached to a file or folder
            /// when it is copied. By default, metadata is not copied along with a
            /// file or folder when it is copied.
            ///
            /// Example: true
            public var isCopyInstanceOnItemCopy: Bool
            /// The display name of the template.
            ///
            /// Example: "Product Info"
            public var displayName: String
            /// An ordered list of template fields which are part of the template.
            /// Each field can be a regular text field, date field, number field,
            /// as well as a single or multi-select list.
            public var fields: [Field]?
            /// Defines if this template is visible in the Box web app UI, or if
            /// it is purely intended for usage through the API.
            ///
            /// Example: true
            public var isHidden: Bool
            /// The scope of the metadata template to create. Applications can
            /// only create templates for use within the authenticated user's
            /// enterprise.
            /// 
            /// This value needs to be set to `enterprise`, as `global` scopes can
            /// not be created by applications.
            ///
            /// Example: "enterprise"
            public var scope: String
            /// A unique identifier for the template. This identifier needs to be
            /// unique across the enterprise for which the metadata template is
            /// being created.
            /// 
            /// When not provided, the API will create a unique `templateKey`
            /// based on the value of the `displayName`.
            ///
            /// Example: "productInfo"
            public var templateKey: String?

            /// Metadata Field (Write)
            ///
            /// A field within a metadata template. Fields can be a basic text, date, or
            /// number field, or a list of options.
            public struct Field: Encodable {
                /// A description of the field. This is not shown to the user.
                ///
                /// Example: "The category"
                public var description: String?
                /// The display name of the field as it is shown to the user in the web and
                /// mobile apps.
                ///
                /// Example: "Category"
                public var displayName: String
                /// Whether this field is hidden in the UI for the user and can only be set
                /// through the API instead.
                ///
                /// Example: true
                public var isHidden: Bool?
                /// A unique identifier for the field. The identifier must
                /// be unique within the template to which it belongs.
                ///
                /// Example: "category"
                public var key: String
                /// A list of options for this field. This is used in combination with the
                /// `enum` and `multiSelect` field types.
                public var options: [Option]?
                /// The type of field. The basic fields are a `string` field for text, a
                /// `float` field for numbers, and a `date` fields to present the user with a
                /// date-time picker.
                /// 
                /// Additionally, metadata templates support an `enum` field for a basic list
                /// of items, and ` multiSelect` field for a similar list of items where the
                /// user can select more than one value.
                ///
                /// Example: "string"
                public var type: `Type`

                /// Metadata Option (Write)
                ///
                /// An option for a Metadata Template Field.
                /// 
                /// Options only need to be provided for fields of type `enum` and `multiSelect`.
                /// Options represent the value(s) a user can select for the field either through
                /// the UI or through the API.
                public struct Option: Encodable {
                    /// The text value of the option. This represents both the display name of the
                    /// option and the internal key used when updating templates.
                    ///
                    /// Example: "Category 1"
                    public var key: String

                    public init(key: String) {
                        self.key = key
                    }
                }

                /// The type of field. The basic fields are a `string` field for text, a
                /// `float` field for numbers, and a `date` fields to present the user with a
                /// date-time picker.
                /// 
                /// Additionally, metadata templates support an `enum` field for a basic list
                /// of items, and ` multiSelect` field for a similar list of items where the
                /// user can select more than one value.
                ///
                /// Example: "string"
                public enum `Type`: String, Codable, CaseIterable {
                    case string
                    case float
                    case date
                    case `enum`
                    case multiSelect
                }

                public init(description: String? = nil, displayName: String, isHidden: Bool? = nil, key: String, options: [Option]? = nil, type: `Type`) {
                    self.description = description
                    self.displayName = displayName
                    self.isHidden = isHidden
                    self.key = key
                    self.options = options
                    self.type = type
                }

                private enum CodingKeys: String, CodingKey {
                    case description
                    case displayName
                    case isHidden = "hidden"
                    case key
                    case options
                    case type
                }
            }

            public init(isCopyInstanceOnItemCopy: Bool? = nil, displayName: String, fields: [Field]? = nil, isHidden: Bool? = nil, scope: String, templateKey: String? = nil) {
                self.isCopyInstanceOnItemCopy = isCopyInstanceOnItemCopy ?? false
                self.displayName = displayName
                self.fields = fields
                self.isHidden = isHidden ?? false
                self.scope = scope
                self.templateKey = templateKey
            }

            private enum CodingKeys: String, CodingKey {
                case isCopyInstanceOnItemCopy = "copyInstanceOnItemCopy"
                case displayName
                case fields
                case isHidden = "hidden"
                case scope
                case templateKey
            }
        }
    }
}

extension Paths.MetadataTemplates {
    public var schemaClassifications: SchemaClassifications {
        SchemaClassifications(path: path + "/schema#classifications")
    }

    public struct SchemaClassifications {
        /// Path: `/metadata_templates/schema#classifications`
        public let path: String

        /// Add initial classifications
        ///
        /// When an enterprise does not yet have any classifications, this API call
        /// initializes the classification template with an initial set of
        /// classifications.
        /// 
        /// If an enterprise already has a classification, the template will already
        /// exist and instead an API call should be made to add additional
        /// classifications.
        public func post(_ body: PostRequest? = nil) -> Request<BoxAPI.ClassificationTemplate> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// `false`
            ///
            /// Example: false
            public var isCopyInstanceOnItemCopy: Bool?
            /// `Classification`
            ///
            /// Example: "Classification"
            public var displayName: DisplayName
            /// The classification template holds one field, which holds
            /// all the valid classification values.
            public var fields: [Field]?
            /// `false`
            ///
            /// Example: false
            public var isHidden: Bool?
            /// The scope in which to create the classifications. This should
            /// be `enterprise` or `enterprise_{id}` where `id` is the unique
            /// ID of the enterprise.
            ///
            /// Example: "enterprise"
            public var scope: Scope
            /// `securityClassification-6VMVochwUWo`
            ///
            /// Example: "securityClassification-6VMVochwUWo"
            public var templateKey: TemplateKey?

            /// `Classification`
            ///
            /// Example: "Classification"
            public enum DisplayName: String, Codable, CaseIterable {
                case classification = "Classification"
            }

            /// The `enum` field which holds all the valid classification
            /// values.
            public struct Field: Encodable {
                /// `Classification`
                ///
                /// Example: "Classification"
                public var displayName: DisplayName?
                /// `false`
                ///
                /// Example: false
                public var isHidden: Bool?
                /// `Box__Security__Classification__Key`
                ///
                /// Example: "Box__Security__Classification__Key"
                public var key: Key?
                /// The actual list of classifications that are present on
                /// this template.
                public var options: [Option]?
                /// `enum`
                ///
                /// Example: "enum"
                public var type: `Type`?

                /// `Classification`
                ///
                /// Example: "Classification"
                public enum DisplayName: String, Codable, CaseIterable {
                    case classification = "Classification"
                }

                /// `Box__Security__Classification__Key`
                ///
                /// Example: "Box__Security__Classification__Key"
                public enum Key: String, Codable, CaseIterable {
                    case boxSecurityClassificationKey = "Box__Security__Classification__Key"
                }

                /// An individual classification.
                public struct Option: Encodable {
                    /// The display name and key this classification. This
                    /// will be show in the Box UI.
                    ///
                    /// Example: "Sensitive"
                    public var key: String?
                    /// Additional information about the classification.
                    public var staticConfig: StaticConfig?

                    /// Additional information about the classification.
                    public struct StaticConfig: Encodable {
                        /// Additional information about the classification.
                        public var classification: Classification?

                        /// Additional information about the classification.
                        public struct Classification: Encodable {
                            /// A longer description of the classification.
                            ///
                            /// Example: "Sensitive information"
                            public var classificationDefinition: String?
                            /// An identifier used to assign a color to
                            /// a classification label.
                            /// 
                            /// Mapping between a `colorID` and a color may
                            /// change without notice. Currently, the color
                            /// mappings are as follows.
                            /// 
                            /// * `0`: Yellow
                            /// * `1`: Orange
                            /// * `2`: Watermelon red
                            /// * `3`: Purple rain
                            /// * `4`: Light blue
                            /// * `5`: Dark blue
                            /// * `6`: Light green
                            /// * `7`: Gray
                            public var colorID: Double?

                            public init(classificationDefinition: String? = nil, colorID: Double? = nil) {
                                self.classificationDefinition = classificationDefinition
                                self.colorID = colorID
                            }
                        }

                        public init(classification: Classification? = nil) {
                            self.classification = classification
                        }
                    }

                    public init(key: String? = nil, staticConfig: StaticConfig? = nil) {
                        self.key = key
                        self.staticConfig = staticConfig
                    }
                }

                /// `enum`
                ///
                /// Example: "enum"
                public enum `Type`: String, Codable, CaseIterable {
                    case `enum`
                }

                public init(displayName: DisplayName? = nil, isHidden: Bool? = nil, key: Key? = nil, options: [Option]? = nil, type: `Type`? = nil) {
                    self.displayName = displayName
                    self.isHidden = isHidden
                    self.key = key
                    self.options = options
                    self.type = type
                }

                private enum CodingKeys: String, CodingKey {
                    case displayName
                    case isHidden = "hidden"
                    case key
                    case options
                    case type
                }
            }

            /// The scope in which to create the classifications. This should
            /// be `enterprise` or `enterprise_{id}` where `id` is the unique
            /// ID of the enterprise.
            ///
            /// Example: "enterprise"
            public enum Scope: String, Codable, CaseIterable {
                case enterprise
            }

            /// `securityClassification-6VMVochwUWo`
            ///
            /// Example: "securityClassification-6VMVochwUWo"
            public enum TemplateKey: String, Codable, CaseIterable {
                case securityClassification6VMVochwUWo = "securityClassification-6VMVochwUWo"
            }

            public init(isCopyInstanceOnItemCopy: Bool? = nil, displayName: DisplayName, fields: [Field]? = nil, isHidden: Bool? = nil, scope: Scope, templateKey: TemplateKey? = nil) {
                self.isCopyInstanceOnItemCopy = isCopyInstanceOnItemCopy
                self.displayName = displayName
                self.fields = fields
                self.isHidden = isHidden
                self.scope = scope
                self.templateKey = templateKey
            }

            private enum CodingKeys: String, CodingKey {
                case isCopyInstanceOnItemCopy = "copyInstanceOnItemCopy"
                case displayName
                case fields
                case isHidden = "hidden"
                case scope
                case templateKey
            }
        }
    }
}

extension Paths.MetadataTemplates {
    public func scope(_ scope: String) -> WithScope {
        WithScope(path: "\(path)/\(scope)")
    }

    public struct WithScope {
        /// Path: `/metadata_templates/{scope}`
        public let path: String
    }
}

extension Paths.MetadataTemplates.WithScope {
    public func templateKey(_ templateKey: String) -> WithTemplateKey {
        WithTemplateKey(path: "\(path)/\(templateKey)")
    }

    public struct WithTemplateKey {
        /// Path: `/metadata_templates/{scope}/{template_key}`
        public let path: String
    }
}

extension Paths.MetadataTemplates.WithScope.WithTemplateKey {
    public var schema: Schema {
        Schema(path: path + "/schema")
    }

    public struct Schema {
        /// Path: `/metadata_templates/{scope}/{template_key}/schema`
        public let path: String

        /// Get metadata template by name
        ///
        /// Retrieves a metadata template by its `scope` and `templateKey` values.
        /// 
        /// To find the `scope` and `templateKey` for a template, list all templates for
        /// an enterprise or globally, or list all templates applied to a file or folder.
        public var get: Request<BoxAPI.MetadataTemplate> {
            .get(path)
        }

        /// Update metadata template
        ///
        /// Updates a metadata template.
        /// 
        /// The metadata template can only be updated if the template
        /// already exists.
        /// 
        /// The update is applied atomically. If any errors occur during the
        /// application of the operations, the metadata template will not be changed.
        public func put(_ body: Data) -> Request<BoxAPI.MetadataTemplate> {
            .put(path, body: body)
        }

        /// Remove metadata template
        ///
        /// Delete a metadata template and its instances.
        /// This deletion is permanent and can not be reversed.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.MetadataTemplates {
    public func templateID(_ templateID: String) -> WithTemplateID {
        WithTemplateID(path: "\(path)/\(templateID)")
    }

    public struct WithTemplateID {
        /// Path: `/metadata_templates/{template_id}`
        public let path: String

        /// Get metadata template by ID
        ///
        /// Retrieves a metadata template by its ID.
        public var get: Request<BoxAPI.MetadataTemplate> {
            .get(path)
        }
    }
}

extension Paths {
    public static var oauth2: Oauth2 {
        Oauth2(path: "/oauth2")
    }

    public struct Oauth2 {
        /// Path: `/oauth2`
        public let path: String
    }
}

extension Paths.Oauth2 {
    public var revoke: Revoke {
        Revoke(path: path + "/revoke")
    }

    public struct Revoke {
        /// Path: `/oauth2/revoke`
        public let path: String

        /// Revoke access token
        ///
        /// Revoke an active Access Token, effectively logging a user out
        /// that has been previously authenticated.
        public func post(_ body: BoxAPI.PostOAuth2Revoke? = nil) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.Oauth2 {
    public var token: Token {
        Token(path: path + "/token")
    }

    public struct Token {
        /// Path: `/oauth2/token`
        public let path: String

        /// Request access token
        ///
        /// Request an Access Token using either a client-side obtained OAuth 2.0
        /// authorization code or a server-side JWT assertion.
        /// 
        /// An Access Token is a string that enables Box to verify that a
        /// request belongs to an authorized session. In the normal order of
        /// operations you will begin by requesting authentication from the
        /// [authorize](#get-authorize) endpoint and Box will send you an
        /// authorization code.
        /// 
        /// You will then send this code to this endpoint to exchange it for
        /// an Access Token. The returned Access Token can then be used to to make
        /// Box API calls.
        public func post(_ body: BoxAPI.PostOAuth2Token? = nil) -> Request<BoxAPI.AccessToken> {
            .post(path, body: body)
        }
    }
}

extension Paths.Oauth2 {
    public var tokenRefresh: TokenRefresh {
        TokenRefresh(path: path + "/token#refresh")
    }

    public struct TokenRefresh {
        /// Path: `/oauth2/token#refresh`
        public let path: String

        /// Refresh access token
        ///
        /// Refresh an Access Token using its client ID, secret, and refresh token.
        public func post(_ body: BoxAPI.PostOAuth2TokenRefreshAccessToken? = nil) -> Request<BoxAPI.AccessToken> {
            .post(path, body: body)
        }
    }
}

extension Paths {
    public static var recentItems: RecentItems {
        RecentItems(path: "/recent_items")
    }

    public struct RecentItems {
        /// Path: `/recent_items`
        public let path: String

        /// List recently accessed items
        ///
        /// Returns information about the recent items accessed
        /// by a user, either in the last 90 days or up to the last
        /// 1000 items accessed.
        public func get(parameters: GetParameters? = nil) -> Request<BoxAPI.RecentItems> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var fields: [String]?
            public var limit: Int?
            public var marker: String?

            public init(fields: [String]? = nil, limit: Int? = nil, marker: String? = nil) {
                self.fields = fields
                self.limit = limit
                self.marker = marker
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields", explode: false)
                encoder.encode(limit, forKey: "limit")
                encoder.encode(marker, forKey: "marker")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var retentionPolicies: RetentionPolicies {
        RetentionPolicies(path: "/retention_policies")
    }

    public struct RetentionPolicies {
        /// Path: `/retention_policies`
        public let path: String

        /// List retention policies
        ///
        /// Retrieves all of the retention policies for an enterprise.
        public func get(parameters: GetParameters? = nil) -> Request<BoxAPI.RetentionPolicies> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var policyName: String?
            public var policyType: PolicyType?
            public var createdByUserID: String?

            public enum PolicyType: String, Codable, CaseIterable {
                case finite
                case indefinite
            }

            public init(policyName: String? = nil, policyType: PolicyType? = nil, createdByUserID: String? = nil) {
                self.policyName = policyName
                self.policyType = policyType
                self.createdByUserID = createdByUserID
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(policyName, forKey: "policy_name")
                encoder.encode(policyType, forKey: "policy_type")
                encoder.encode(createdByUserID, forKey: "created_by_user_id")
                return encoder.items
            }
        }

        /// Create retention policy
        ///
        /// Creates a retention policy.
        public func post(_ body: PostRequest? = nil) -> Request<BoxAPI.RetentionPolicy> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Whether owner and co-owners of a file are notified
            /// when the policy nears expiration.
            ///
            /// Example: true
            public var isAreOwnersNotified: Bool?
            /// Whether the owner of a file will be allowed to
            /// extend the retention.
            ///
            /// Example: true
            public var canOwnerExtendRetention: Bool?
            public var customNotificationRecipients: [CustomNotificationRecipient]?
            /// The disposition action of the retention policy.
            /// This action can be `permanently_delete`, which
            /// will cause the content retained by the policy
            /// to be permanently deleted, or `remove_retention`,
            /// which will lift the retention policy from the content,
            /// allowing it to be deleted by users,
            /// once the retention policy has expired.
            ///
            /// Example: "permanently_delete"
            public var dispositionAction: DispositionAction
            /// The name for the retention policy
            ///
            /// Example: "Some Policy Name"
            public var policyName: String
            /// The type of the retention policy. A retention
            /// policy type can either be `finite`, where a
            /// specific amount of time to retain the content is known
            /// upfront, or `indefinite`, where the amount of time
            /// to retain the content is still unknown.
            ///
            /// Example: "finite"
            public var policyType: PolicyType
            /// The length of the retention policy. This length
            /// specifies the duration in days that the retention
            /// policy will be active for after being assigned to
            /// content.  If the policy has A `policy_type` of
            /// `indefinite`, the `retention_length` will also be
            /// `indefinite`.
            ///
            /// Example: "365"
            public var retentionLength: String?

            /// A user that is notified of an event.
            public struct CustomNotificationRecipient: Encodable {
                /// The id of the user to notify
                ///
                /// Example: "12312312"
                public var id: String?
                /// The email address the user uses to notify
                ///
                /// Example: "apple@example.com"
                public var login: String?
                /// The name of the user to notify
                ///
                /// Example: "Tim Apple"
                public var name: String?
                /// The type of item to notify
                ///
                /// Example: "user"
                public var type: `Type`?

                /// The type of item to notify
                ///
                /// Example: "user"
                public enum `Type`: String, Codable, CaseIterable {
                    case user
                }

                public init(id: String? = nil, login: String? = nil, name: String? = nil, type: `Type`? = nil) {
                    self.id = id
                    self.login = login
                    self.name = name
                    self.type = type
                }
            }

            /// The disposition action of the retention policy.
            /// This action can be `permanently_delete`, which
            /// will cause the content retained by the policy
            /// to be permanently deleted, or `remove_retention`,
            /// which will lift the retention policy from the content,
            /// allowing it to be deleted by users,
            /// once the retention policy has expired.
            ///
            /// Example: "permanently_delete"
            public enum DispositionAction: String, Codable, CaseIterable {
                case permanentlyDelete = "permanently_delete"
                case removeRetention = "remove_retention"
            }

            /// The type of the retention policy. A retention
            /// policy type can either be `finite`, where a
            /// specific amount of time to retain the content is known
            /// upfront, or `indefinite`, where the amount of time
            /// to retain the content is still unknown.
            ///
            /// Example: "finite"
            public enum PolicyType: String, Codable, CaseIterable {
                case finite
                case indefinite
            }

            public init(isAreOwnersNotified: Bool? = nil, canOwnerExtendRetention: Bool? = nil, customNotificationRecipients: [CustomNotificationRecipient]? = nil, dispositionAction: DispositionAction, policyName: String, policyType: PolicyType, retentionLength: String? = nil) {
                self.isAreOwnersNotified = isAreOwnersNotified
                self.canOwnerExtendRetention = canOwnerExtendRetention
                self.customNotificationRecipients = customNotificationRecipients
                self.dispositionAction = dispositionAction
                self.policyName = policyName
                self.policyType = policyType
                self.retentionLength = retentionLength
            }

            private enum CodingKeys: String, CodingKey {
                case isAreOwnersNotified = "are_owners_notified"
                case canOwnerExtendRetention = "can_owner_extend_retention"
                case customNotificationRecipients = "custom_notification_recipients"
                case dispositionAction = "disposition_action"
                case policyName = "policy_name"
                case policyType = "policy_type"
                case retentionLength = "retention_length"
            }
        }
    }
}

extension Paths.RetentionPolicies {
    public func retentionPolicyID(_ retentionPolicyID: String) -> WithRetentionPolicyID {
        WithRetentionPolicyID(path: "\(path)/\(retentionPolicyID)")
    }

    public struct WithRetentionPolicyID {
        /// Path: `/retention_policies/{retention_policy_id}`
        public let path: String

        /// Get retention policy
        ///
        /// Retrieves a retention policy.
        public var get: Request<BoxAPI.RetentionPolicy> {
            .get(path)
        }

        /// Update retention policy
        ///
        /// Updates a retention policy.
        public func put(_ body: PutRequest? = nil) -> Request<BoxAPI.RetentionPolicy> {
            .put(path, body: body)
        }

        public struct PutRequest: Encodable {
            /// The disposition action of the retention policy.
            /// This action can be `permanently_delete`, which
            /// will cause the content retained by the policy
            /// to be permanently deleted, or `remove_retention`,
            /// which will lift the retention policy from the content,
            /// allowing it to be deleted by users,
            /// once the retention policy has expired.
            ///
            /// Example: "permanently_delete"
            public var dispositionAction: DispositionAction?
            /// The name for the retention policy
            ///
            /// Example: "Some Policy Name"
            public var policyName: String?
            /// Used to retire a retention policy.
            /// 
            /// If not retiring a policy, do not include this parameter
            /// or set it to `null`.
            ///
            /// Example: "retired"
            public var status: Status?

            /// The disposition action of the retention policy.
            /// This action can be `permanently_delete`, which
            /// will cause the content retained by the policy
            /// to be permanently deleted, or `remove_retention`,
            /// which will lift the retention policy from the content,
            /// allowing it to be deleted by users,
            /// once the retention policy has expired.
            ///
            /// Example: "permanently_delete"
            public enum DispositionAction: String, Codable, CaseIterable {
                case permanentlyDelete = "permanently_delete"
                case removeRetention = "remove_retention"
            }

            /// Used to retire a retention policy.
            /// 
            /// If not retiring a policy, do not include this parameter
            /// or set it to `null`.
            ///
            /// Example: "retired"
            public enum Status: String, Codable, CaseIterable {
                case retired
            }

            public init(dispositionAction: DispositionAction? = nil, policyName: String? = nil, status: Status? = nil) {
                self.dispositionAction = dispositionAction
                self.policyName = policyName
                self.status = status
            }

            private enum CodingKeys: String, CodingKey {
                case dispositionAction = "disposition_action"
                case policyName = "policy_name"
                case status
            }
        }
    }
}

extension Paths.RetentionPolicies.WithRetentionPolicyID {
    public var assignments: Assignments {
        Assignments(path: path + "/assignments")
    }

    public struct Assignments {
        /// Path: `/retention_policies/{retention_policy_id}/assignments`
        public let path: String

        /// List retention policy assignments
        ///
        /// Returns a list of all retention policy assignments associated with a specified
        /// retention policy.
        public func get(parameters: GetParameters? = nil) -> Request<BoxAPI.RetentionPolicyAssignments> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var type: `Type`?
            public var marker: String?
            public var limit: Int?

            public enum `Type`: String, Codable, CaseIterable {
                case folder
                case enterprise
            }

            public init(type: `Type`? = nil, marker: String? = nil, limit: Int? = nil) {
                self.type = type
                self.marker = marker
                self.limit = limit
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(type, forKey: "type")
                encoder.encode(marker, forKey: "marker")
                encoder.encode(limit, forKey: "limit")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var retentionPolicyAssignments: RetentionPolicyAssignments {
        RetentionPolicyAssignments(path: "/retention_policy_assignments")
    }

    public struct RetentionPolicyAssignments {
        /// Path: `/retention_policy_assignments`
        public let path: String

        /// Assign retention policy
        ///
        /// Assigns a retention policy to an item.
        public func post(_ body: PostRequest? = nil) -> Request<BoxAPI.RetentionPolicyAssignment> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The item to assign the policy to
            public var assignTo: AssignTo
            /// The ID of the retention policy to assign
            ///
            /// Example: "173463"
            public var policyID: String

            /// The item to assign the policy to
            public struct AssignTo: Encodable {
                /// The ID of item to assign the policy to.
                /// 
                /// Set to `null` or omit when `type` is set to
                /// `enterprise`.
                ///
                /// Example: "6564564"
                public var id: String
                /// The type of item to assign the policy to.
                ///
                /// Example: "folder"
                public var type: `Type`

                /// The type of item to assign the policy to.
                ///
                /// Example: "folder"
                public enum `Type`: String, Codable, CaseIterable {
                    case enterprise
                    case folder
                    case metadataTemplate = "metadata_template"
                }

                public init(id: String, type: `Type`) {
                    self.id = id
                    self.type = type
                }
            }

            public init(assignTo: AssignTo, policyID: String) {
                self.assignTo = assignTo
                self.policyID = policyID
            }

            private enum CodingKeys: String, CodingKey {
                case assignTo = "assign_to"
                case policyID = "policy_id"
            }
        }
    }
}

extension Paths.RetentionPolicyAssignments {
    public func retentionPolicyAssignmentID(_ retentionPolicyAssignmentID: String) -> WithRetentionPolicyAssignmentID {
        WithRetentionPolicyAssignmentID(path: "\(path)/\(retentionPolicyAssignmentID)")
    }

    public struct WithRetentionPolicyAssignmentID {
        /// Path: `/retention_policy_assignments/{retention_policy_assignment_id}`
        public let path: String

        /// Get retention policy assignment
        ///
        /// Retrieves a retention policy assignment
        public var get: Request<BoxAPI.RetentionPolicyAssignment> {
            .get(path)
        }
    }
}

extension Paths.RetentionPolicyAssignments.WithRetentionPolicyAssignmentID {
    public var fileVersionsUnderRetention: FileVersionsUnderRetention {
        FileVersionsUnderRetention(path: path + "/file_versions_under_retention")
    }

    public struct FileVersionsUnderRetention {
        /// Path: `/retention_policy_assignments/{retention_policy_assignment_id}/file_versions_under_retention`
        public let path: String

        /// Get file versions under retention
        ///
        /// Returns a list of file versions under retention for a retention policy
        /// assignment.
        public func get(marker: String? = nil, limit: Int? = nil) -> Request<BoxAPI.FileVersionRetentions> {
            .get(path, query: makeGetQuery(marker, limit))
        }

        private func makeGetQuery(_ marker: String?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(marker, forKey: "marker")
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths.RetentionPolicyAssignments.WithRetentionPolicyAssignmentID {
    public var filesUnderRetention: FilesUnderRetention {
        FilesUnderRetention(path: path + "/files_under_retention")
    }

    public struct FilesUnderRetention {
        /// Path: `/retention_policy_assignments/{retention_policy_assignment_id}/files_under_retention`
        public let path: String

        /// Get files under retention
        ///
        /// Returns a list of files under retention for a retention policy assignment.
        public func get(marker: String? = nil, limit: Int? = nil) -> Request<BoxAPI.FileVersionRetentions> {
            .get(path, query: makeGetQuery(marker, limit))
        }

        private func makeGetQuery(_ marker: String?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(marker, forKey: "marker")
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }
    }
}

extension Paths {
    public static var search: Search {
        Search(path: "/search")
    }

    public struct Search {
        /// Path: `/search`
        public let path: String

        /// Search for content
        ///
        /// Searches for files, folders, web links, and shared files across the
        /// users content or across the entire enterprise.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public enum GetResponse: Decodable {
            case searchResults(BoxAPI.SearchResults)
            case searchResultsWithSharedLinks(BoxAPI.SearchResultsWithSharedLinks)

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(BoxAPI.SearchResults.self) {
                    self = .searchResults(value)
                } else if let value = try? container.decode(BoxAPI.SearchResultsWithSharedLinks.self) {
                    self = .searchResultsWithSharedLinks(value)
                } else {
                    throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
                }
            }
        }

        public struct GetParameters {
            public var query: String?
            public var scope: Scope?
            public var fileExtensions: [String]?
            public var createdAtRange: [String]?
            public var updatedAtRange: [String]?
            public var sizeRange: [Int]?
            public var ownerUserIDs: [String]?
            public var ancestorFolderIDs: [String]?
            public var contentTypes: [ContentTypes]?
            public var type: `Type`?
            public var trashContent: TrashContent?
            /// A list of metadata templates to filter the search results by.
            /// 
            /// Required unless `query` parameter is defined.
            public var mdfilters: [BoxAPI.MetadataFilter]?
            public var sort: Sort?
            public var direction: Direction?
            public var limit: Int?
            public var isIncludeRecentSharedLinks: Bool?
            public var fields: [String]?
            public var offset: Int?

            public enum Scope: String, Codable, CaseIterable {
                case userContent = "user_content"
                case enterpriseContent = "enterprise_content"
            }

            public enum ContentTypes: String, Codable, CaseIterable {
                case name
                case description
                case fileContent = "file_content"
                case comments
                case tag
            }

            public enum `Type`: String, Codable, CaseIterable {
                case file
                case folder
                case webLink = "web_link"
            }

            public enum TrashContent: String, Codable, CaseIterable {
                case nonTrashedOnly = "non_trashed_only"
                case trashedOnly = "trashed_only"
            }

            public enum Sort: String, Codable, CaseIterable {
                case modifiedAt = "modified_at"
                case relevance
            }

            public enum Direction: String, Codable, CaseIterable {
                case desc = "DESC"
                case asc = "ASC"
            }

            public init(query: String? = nil, scope: Scope? = nil, fileExtensions: [String]? = nil, createdAtRange: [String]? = nil, updatedAtRange: [String]? = nil, sizeRange: [Int]? = nil, ownerUserIDs: [String]? = nil, ancestorFolderIDs: [String]? = nil, contentTypes: [ContentTypes]? = nil, type: `Type`? = nil, trashContent: TrashContent? = nil, mdfilters: [BoxAPI.MetadataFilter]? = nil, sort: Sort? = nil, direction: Direction? = nil, limit: Int? = nil, isIncludeRecentSharedLinks: Bool? = nil, fields: [String]? = nil, offset: Int? = nil) {
                self.query = query
                self.scope = scope
                self.fileExtensions = fileExtensions
                self.createdAtRange = createdAtRange
                self.updatedAtRange = updatedAtRange
                self.sizeRange = sizeRange
                self.ownerUserIDs = ownerUserIDs
                self.ancestorFolderIDs = ancestorFolderIDs
                self.contentTypes = contentTypes
                self.type = type
                self.trashContent = trashContent
                self.mdfilters = mdfilters
                self.sort = sort
                self.direction = direction
                self.limit = limit
                self.isIncludeRecentSharedLinks = isIncludeRecentSharedLinks
                self.fields = fields
                self.offset = offset
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(query, forKey: "query")
                encoder.encode(scope, forKey: "scope")
                encoder.encode(fileExtensions, forKey: "file_extensions", explode: false)
                encoder.encode(createdAtRange, forKey: "created_at_range", explode: false)
                encoder.encode(updatedAtRange, forKey: "updated_at_range", explode: false)
                encoder.encode(sizeRange, forKey: "size_range", explode: false)
                encoder.encode(ownerUserIDs, forKey: "owner_user_ids", explode: false)
                encoder.encode(ancestorFolderIDs, forKey: "ancestor_folder_ids", explode: false)
                encoder.encode(contentTypes, forKey: "content_types", explode: false)
                encoder.encode(type, forKey: "type")
                encoder.encode(trashContent, forKey: "trash_content")
                encoder.encode(mdfilters, forKey: "mdfilters")
                encoder.encode(sort, forKey: "sort")
                encoder.encode(direction, forKey: "direction")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(isIncludeRecentSharedLinks, forKey: "include_recent_shared_links")
                encoder.encode(fields, forKey: "fields", explode: false)
                encoder.encode(offset, forKey: "offset")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var sharedItems: SharedItems {
        SharedItems(path: "/shared_items")
    }

    public struct SharedItems {
        /// Path: `/shared_items`
        public let path: String

        /// Find file for shared link
        ///
        /// Return the file represented by a shared link.
        /// 
        /// A shared file can be represented by a shared link,
        /// which can originate within the current enterprise or within another.
        /// 
        /// This endpoint allows an application to retrieve information about a
        /// shared file when only given a shared link.
        public func get(fields: [String]? = nil) -> Request<BoxAPI.File> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }
    }
}

extension Paths {
    public static var sharedItemsFolders: SharedItemsFolders {
        SharedItemsFolders(path: "/shared_items#folders")
    }

    public struct SharedItemsFolders {
        /// Path: `/shared_items#folders`
        public let path: String

        /// Find folder for shared link
        ///
        /// Return the folder represented by a shared link.
        /// 
        /// A shared folder can be represented by a shared link,
        /// which can originate within the current enterprise or within another.
        /// 
        /// This endpoint allows an application to retrieve information about a
        /// shared folder when only given a shared link.
        public func get(fields: [String]? = nil) -> Request<BoxAPI.Folder> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }
    }
}

extension Paths {
    public static var signRequests: SignRequests {
        SignRequests(path: "/sign_requests")
    }

    public struct SignRequests {
        /// Path: `/sign_requests`
        public let path: String

        /// List sign requests
        ///
        /// Gets sign requests created by a user.
        public func get(marker: String? = nil, limit: Int? = nil) -> Request<BoxAPI.SignRequests> {
            .get(path, query: makeGetQuery(marker, limit))
        }

        private func makeGetQuery(_ marker: String?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(marker, forKey: "marker")
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }

        /// Create sign request
        ///
        /// Creates a sign request. This involves preparing a document for signing and
        /// sending the sign request to signers.
        public func post(_ body: BoxAPI.SignRequestCreateRequest? = nil) -> Request<BoxAPI.SignRequest> {
            .post(path, body: body)
        }
    }
}

extension Paths.SignRequests {
    public func signRequestID(_ signRequestID: String) -> WithSignRequestID {
        WithSignRequestID(path: "\(path)/\(signRequestID)")
    }

    public struct WithSignRequestID {
        /// Path: `/sign_requests/{sign_request_id}`
        public let path: String

        /// Get sign request by ID
        ///
        /// Gets a sign request by ID.
        public var get: Request<BoxAPI.SignRequest> {
            .get(path)
        }
    }
}

extension Paths.SignRequests.WithSignRequestID {
    public var cancel: Cancel {
        Cancel(path: path + "/cancel")
    }

    public struct Cancel {
        /// Path: `/sign_requests/{sign_request_id}/cancel`
        public let path: String

        /// Cancel sign request
        ///
        /// Cancels a sign request.
        public var post: Request<BoxAPI.SignRequest> {
            .post(path)
        }
    }
}

extension Paths.SignRequests.WithSignRequestID {
    public var resend: Resend {
        Resend(path: path + "/resend")
    }

    public struct Resend {
        /// Path: `/sign_requests/{sign_request_id}/resend`
        public let path: String

        /// Resend sign request
        ///
        /// Resends a sign request email to all outstanding signers.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths {
    public static var skillInvocations: SkillInvocations {
        SkillInvocations(path: "/skill_invocations")
    }

    public struct SkillInvocations {
        /// Path: `/skill_invocations`
        public let path: String
    }
}

extension Paths.SkillInvocations {
    public func skillID(_ skillID: String) -> WithSkillID {
        WithSkillID(path: "\(path)/\(skillID)")
    }

    public struct WithSkillID {
        /// Path: `/skill_invocations/{skill_id}`
        public let path: String

        /// Update all Box Skill cards on file
        ///
        /// An alternative method that can be used to overwrite and update all Box Skill
        /// metadata cards on a file.
        public func put(_ body: PutRequest? = nil) -> Request<Void> {
            .put(path, body: body)
        }

        public struct PutRequest: Encodable {
            /// The file to assign the cards to.
            public var file: File
            /// The optional file version to assign the cards to.
            public var fileVersion: FileVersion?
            /// The metadata to set for this skill. This is a list of
            /// Box Skills cards. These cards will overwrite any existing Box
            /// skill cards on the file.
            public var metadata: Metadata
            /// Defines the status of this invocation. Set this to `success` when setting Skill cards.
            ///
            /// Example: "success"
            public var status: Status
            /// A descriptor that defines what items are affected by this call.
            /// 
            /// Set this to the default values when setting a card to a `success`
            /// state, and leave it out in most other situations.
            public var usage: Usage?

            /// The file to assign the cards to.
            public struct File: Encodable {
                /// The ID of the file
                ///
                /// Example: "3243244"
                public var id: String?
                /// `file`
                ///
                /// Example: "file"
                public var type: `Type`?

                /// `file`
                ///
                /// Example: "file"
                public enum `Type`: String, Codable, CaseIterable {
                    case file
                }

                public init(id: String? = nil, type: `Type`? = nil) {
                    self.id = id
                    self.type = type
                }
            }

            /// The optional file version to assign the cards to.
            public struct FileVersion: Encodable {
                /// The ID of the file version
                ///
                /// Example: "731381601045"
                public var id: String?
                /// `file_version`
                ///
                /// Example: "file_version"
                public var type: `Type`?

                /// `file_version`
                ///
                /// Example: "file_version"
                public enum `Type`: String, Codable, CaseIterable {
                    case fileVersion = "file_version"
                }

                public init(id: String? = nil, type: `Type`? = nil) {
                    self.id = id
                    self.type = type
                }
            }

            /// The metadata to set for this skill. This is a list of
            /// Box Skills cards. These cards will overwrite any existing Box
            /// skill cards on the file.
            public struct Metadata: Encodable {
                /// A list of Box Skill cards to apply to this file.
                public var cards: [Card]?

                public enum Card: Encodable {
                    case skillCard(BoxAPI.SkillCard)
                    case keywordSkillCard(BoxAPI.KeywordSkillCard)
                    case timelineSkillCard(BoxAPI.TimelineSkillCard)
                    case transcriptSkillCard(BoxAPI.TranscriptSkillCard)
                    case statusSkillCard(BoxAPI.StatusSkillCard)

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.singleValueContainer()
                        switch self {
                        case .skillCard(let value): try container.encode(value)
                        case .keywordSkillCard(let value): try container.encode(value)
                        case .timelineSkillCard(let value): try container.encode(value)
                        case .transcriptSkillCard(let value): try container.encode(value)
                        case .statusSkillCard(let value): try container.encode(value)
                        }
                    }
                }

                public init(cards: [Card]? = nil) {
                    self.cards = cards
                }
            }

            /// Defines the status of this invocation. Set this to `success` when setting Skill cards.
            ///
            /// Example: "success"
            public enum Status: String, Codable, CaseIterable {
                case invoked
                case processing
                case success
                case transientFailure = "transient_failure"
                case permanentFailure = "permanent_failure"
            }

            /// A descriptor that defines what items are affected by this call.
            /// 
            /// Set this to the default values when setting a card to a `success`
            /// state, and leave it out in most other situations.
            public struct Usage: Encodable {
                /// `file`
                ///
                /// Example: "file"
                public var unit: String?
                /// `1`
                public var value: Double?

                public init(unit: String? = nil, value: Double? = nil) {
                    self.unit = unit
                    self.value = value
                }
            }

            public init(file: File, fileVersion: FileVersion? = nil, metadata: Metadata, status: Status, usage: Usage? = nil) {
                self.file = file
                self.fileVersion = fileVersion
                self.metadata = metadata
                self.status = status
                self.usage = usage
            }

            private enum CodingKeys: String, CodingKey {
                case file
                case fileVersion = "file_version"
                case metadata
                case status
                case usage
            }
        }
    }
}

extension Paths {
    public static var storagePolicies: StoragePolicies {
        StoragePolicies(path: "/storage_policies")
    }

    public struct StoragePolicies {
        /// Path: `/storage_policies`
        public let path: String

        /// List storage policies
        ///
        /// Fetches all the storage policies in the enterprise.
        public func get(parameters: GetParameters? = nil) -> Request<BoxAPI.StoragePolicies> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var fields: [String]?
            public var marker: String?
            public var limit: Int?

            public init(fields: [String]? = nil, marker: String? = nil, limit: Int? = nil) {
                self.fields = fields
                self.marker = marker
                self.limit = limit
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(fields, forKey: "fields", explode: false)
                encoder.encode(marker, forKey: "marker")
                encoder.encode(limit, forKey: "limit")
                return encoder.items
            }
        }
    }
}

extension Paths.StoragePolicies {
    public func storagePolicyID(_ storagePolicyID: String) -> WithStoragePolicyID {
        WithStoragePolicyID(path: "\(path)/\(storagePolicyID)")
    }

    public struct WithStoragePolicyID {
        /// Path: `/storage_policies/{storage_policy_id}`
        public let path: String

        /// Get storage policy
        ///
        /// Fetches a specific storage policy.
        public var get: Request<BoxAPI.StoragePolicy> {
            .get(path)
        }
    }
}

extension Paths {
    public static var storagePolicyAssignments: StoragePolicyAssignments {
        StoragePolicyAssignments(path: "/storage_policy_assignments")
    }

    public struct StoragePolicyAssignments {
        /// Path: `/storage_policy_assignments`
        public let path: String

        /// List storage policy assignments
        ///
        /// Fetches all the storage policy assignment for an enterprise or user.
        public func get(parameters: GetParameters) -> Request<BoxAPI.StoragePolicyAssignments> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var marker: String?
            public var resolvedForType: ResolvedForType
            public var resolvedForID: String

            public enum ResolvedForType: String, Codable, CaseIterable {
                case user
                case enterprise
            }

            public init(marker: String? = nil, resolvedForType: ResolvedForType, resolvedForID: String) {
                self.marker = marker
                self.resolvedForType = resolvedForType
                self.resolvedForID = resolvedForID
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(marker, forKey: "marker")
                encoder.encode(resolvedForType, forKey: "resolved_for_type")
                encoder.encode(resolvedForID, forKey: "resolved_for_id")
                return encoder.items
            }
        }

        /// Assign storage policy
        ///
        /// Creates a storage policy assignment for an enterprise or user.
        public func post(_ body: PostRequest? = nil) -> Request<BoxAPI.StoragePolicyAssignment> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The user or enterprise to assign the storage
            /// policy to.
            public var assignedTo: AssignedTo
            /// The storage policy to assign to the user or
            /// enterprise
            public var storagePolicy: StoragePolicy

            /// The user or enterprise to assign the storage
            /// policy to.
            public struct AssignedTo: Encodable {
                /// The ID of the user or enterprise
                ///
                /// Example: "9987987"
                public var id: String
                /// The type to assign the policy to.
                ///
                /// Example: "user"
                public var type: `Type`

                /// The type to assign the policy to.
                ///
                /// Example: "user"
                public enum `Type`: String, Codable, CaseIterable {
                    case user
                    case enterprise
                }

                public init(id: String, type: `Type`) {
                    self.id = id
                    self.type = type
                }
            }

            /// The storage policy to assign to the user or
            /// enterprise
            public struct StoragePolicy: Encodable {
                /// The ID of the storage policy to assign.
                ///
                /// Example: "1434325"
                public var id: String
                /// The type to assign.
                ///
                /// Example: "storage_policy"
                public var type: `Type`

                /// The type to assign.
                ///
                /// Example: "storage_policy"
                public enum `Type`: String, Codable, CaseIterable {
                    case storagePolicy = "storage_policy"
                }

                public init(id: String, type: `Type`) {
                    self.id = id
                    self.type = type
                }
            }

            public init(assignedTo: AssignedTo, storagePolicy: StoragePolicy) {
                self.assignedTo = assignedTo
                self.storagePolicy = storagePolicy
            }

            private enum CodingKeys: String, CodingKey {
                case assignedTo = "assigned_to"
                case storagePolicy = "storage_policy"
            }
        }
    }
}

extension Paths.StoragePolicyAssignments {
    public func storagePolicyAssignmentID(_ storagePolicyAssignmentID: String) -> WithStoragePolicyAssignmentID {
        WithStoragePolicyAssignmentID(path: "\(path)/\(storagePolicyAssignmentID)")
    }

    public struct WithStoragePolicyAssignmentID {
        /// Path: `/storage_policy_assignments/{storage_policy_assignment_id}`
        public let path: String

        /// Get storage policy assignment
        ///
        /// Fetches a specific storage policy assignment.
        public var get: Request<BoxAPI.StoragePolicyAssignment> {
            .get(path)
        }

        /// Update storage policy assignment
        ///
        /// Updates a specific storage policy assignment.
        public func put(storagePolicy: PutRequest.StoragePolicy) -> Request<BoxAPI.StoragePolicyAssignment> {
            .put(path, body: PutRequest(storagePolicy: storagePolicy))
        }

        public struct PutRequest: Encodable {
            /// The storage policy to assign to the user or
            /// enterprise
            public var storagePolicy: StoragePolicy

            /// The storage policy to assign to the user or
            /// enterprise
            public struct StoragePolicy: Encodable {
                /// The ID of the storage policy to assign.
                ///
                /// Example: "1434325"
                public var id: String
                /// The type to assign.
                ///
                /// Example: "storage_policy"
                public var type: `Type`

                /// The type to assign.
                ///
                /// Example: "storage_policy"
                public enum `Type`: String, Codable, CaseIterable {
                    case storagePolicy = "storage_policy"
                }

                public init(id: String, type: `Type`) {
                    self.id = id
                    self.type = type
                }
            }

            public init(storagePolicy: StoragePolicy) {
                self.storagePolicy = storagePolicy
            }

            private enum CodingKeys: String, CodingKey {
                case storagePolicy = "storage_policy"
            }
        }

        /// Unassign storage policy
        ///
        /// Delete a storage policy assignment.
        /// 
        /// Deleting a storage policy assignment on a user
        /// will have the user inherit the enterprise's default
        /// storage policy.
        /// 
        /// There is a rate limit for calling this endpoint of only
        /// twice per user in a 24 hour time frame.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var taskAssignments: TaskAssignments {
        TaskAssignments(path: "/task_assignments")
    }

    public struct TaskAssignments {
        /// Path: `/task_assignments`
        public let path: String

        /// Assign task
        ///
        /// Assigns a task to a user.
        /// 
        /// A task can be assigned to more than one user by creating multiple
        /// assignments.
        public func post(_ body: PostRequest? = nil) -> Request<BoxAPI.TaskAssignment> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The user to assign the task to.
            public var assignTo: AssignTo
            /// The task to assign to a user.
            public var task: Task

            /// The user to assign the task to.
            public struct AssignTo: Encodable {
                /// The ID of the user to assign to the
                /// task.
                /// 
                /// To specify a user by their email
                /// address use the `login` parameter.
                ///
                /// Example: "3242343"
                public var id: String?
                /// The email address of the user to assign to the task.
                /// To specify a user by their user ID please use the `id` parameter.
                ///
                /// Example: "john@example.com"
                public var login: String?

                public init(id: String? = nil, login: String? = nil) {
                    self.id = id
                    self.login = login
                }
            }

            /// The task to assign to a user.
            public struct Task: Encodable {
                /// The ID of the task
                ///
                /// Example: "11446498"
                public var id: String
                /// The type of the item to assign.
                ///
                /// Example: "task"
                public var type: `Type`

                /// The type of the item to assign.
                ///
                /// Example: "task"
                public enum `Type`: String, Codable, CaseIterable {
                    case task
                }

                public init(id: String, type: `Type`) {
                    self.id = id
                    self.type = type
                }
            }

            public init(assignTo: AssignTo, task: Task) {
                self.assignTo = assignTo
                self.task = task
            }

            private enum CodingKeys: String, CodingKey {
                case assignTo = "assign_to"
                case task
            }
        }
    }
}

extension Paths.TaskAssignments {
    public func taskAssignmentID(_ taskAssignmentID: String) -> WithTaskAssignmentID {
        WithTaskAssignmentID(path: "\(path)/\(taskAssignmentID)")
    }

    public struct WithTaskAssignmentID {
        /// Path: `/task_assignments/{task_assignment_id}`
        public let path: String

        /// Get task assignment
        ///
        /// Retrieves information about a task assignment.
        public var get: Request<BoxAPI.TaskAssignment> {
            .get(path)
        }

        /// Update task assignment
        ///
        /// Updates a task assignment. This endpoint can be
        /// used to update the state of a task assigned to a user.
        public func put(_ body: PutRequest? = nil) -> Request<BoxAPI.TaskAssignment> {
            .put(path, body: body)
        }

        public struct PutRequest: Encodable {
            /// An optional message by the assignee that can be added to the task.
            ///
            /// Example: "Looks good to me"
            public var message: String?
            /// The state of the task assigned to the user.
            /// 
            /// * For a task with an `action` value of `complete` this can be
            /// `incomplete` or `completed`.
            /// * For a task with an `action` of `review` this can be
            /// `incomplete`, `approved`, or `rejected`.
            ///
            /// Example: "completed"
            public var resolutionState: ResolutionState?

            /// The state of the task assigned to the user.
            /// 
            /// * For a task with an `action` value of `complete` this can be
            /// `incomplete` or `completed`.
            /// * For a task with an `action` of `review` this can be
            /// `incomplete`, `approved`, or `rejected`.
            ///
            /// Example: "completed"
            public enum ResolutionState: String, Codable, CaseIterable {
                case completed
                case incomplete
                case approved
                case rejected
            }

            public init(message: String? = nil, resolutionState: ResolutionState? = nil) {
                self.message = message
                self.resolutionState = resolutionState
            }

            private enum CodingKeys: String, CodingKey {
                case message
                case resolutionState = "resolution_state"
            }
        }

        /// Unassign task
        ///
        /// Deletes a specific task assignment.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var tasks: Tasks {
        Tasks(path: "/tasks")
    }

    public struct Tasks {
        /// Path: `/tasks`
        public let path: String

        /// Create task
        ///
        /// Creates a single task on a file. This task is not assigned to any user and
        /// will need to be assigned separately.
        public func post(_ body: PostRequest? = nil) -> Request<BoxAPI.Task> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The action the task assignee will be prompted to do. Must be
            /// 
            /// * `review` defines an approval task that can be approved or
            /// rejected
            /// * `complete` defines a general task which can be completed
            ///
            /// Example: "review"
            public var action: Action?
            /// Defines which assignees need to complete this task before the task
            /// is considered completed.
            /// 
            /// * `all_assignees` (default) requires all assignees to review or
            /// approve the the task in order for it to be considered completed.
            /// * `any_assignee` accepts any one assignee to review or
            /// approve the the task in order for it to be considered completed.
            ///
            /// Example: "all_assignees"
            public var completionRule: CompletionRule?
            /// Defines when the task is due. Defaults to `null` if not
            /// provided.
            ///
            /// Example: "2012-12-12T10:53:43-08:00"
            public var dueAt: Date?
            /// The file to attach the task to.
            public var item: Item
            /// An optional message to include with the task.
            ///
            /// Example: "Please review"
            public var message: String?

            /// The action the task assignee will be prompted to do. Must be
            /// 
            /// * `review` defines an approval task that can be approved or
            /// rejected
            /// * `complete` defines a general task which can be completed
            ///
            /// Example: "review"
            public enum Action: String, Codable, CaseIterable {
                case review
                case complete
            }

            /// Defines which assignees need to complete this task before the task
            /// is considered completed.
            /// 
            /// * `all_assignees` (default) requires all assignees to review or
            /// approve the the task in order for it to be considered completed.
            /// * `any_assignee` accepts any one assignee to review or
            /// approve the the task in order for it to be considered completed.
            ///
            /// Example: "all_assignees"
            public enum CompletionRule: String, Codable, CaseIterable {
                case allAssignees = "all_assignees"
                case anyAssignee = "any_assignee"
            }

            /// The file to attach the task to.
            public struct Item: Encodable {
                /// The ID of the file
                ///
                /// Example: "11446498"
                public var id: String
                /// `file`
                ///
                /// Example: "file"
                public var type: `Type`

                /// `file`
                ///
                /// Example: "file"
                public enum `Type`: String, Codable, CaseIterable {
                    case file
                }

                public init(id: String, type: `Type`) {
                    self.id = id
                    self.type = type
                }
            }

            public init(action: Action? = nil, completionRule: CompletionRule? = nil, dueAt: Date? = nil, item: Item, message: String? = nil) {
                self.action = action
                self.completionRule = completionRule
                self.dueAt = dueAt
                self.item = item
                self.message = message
            }

            private enum CodingKeys: String, CodingKey {
                case action
                case completionRule = "completion_rule"
                case dueAt = "due_at"
                case item
                case message
            }
        }
    }
}

extension Paths.Tasks {
    public func taskID(_ taskID: String) -> WithTaskID {
        WithTaskID(path: "\(path)/\(taskID)")
    }

    public struct WithTaskID {
        /// Path: `/tasks/{task_id}`
        public let path: String

        /// Get task
        ///
        /// Retrieves information about a specific task.
        public var get: Request<BoxAPI.Task> {
            .get(path)
        }

        /// Update task
        ///
        /// Updates a task. This can be used to update a task's configuration, or to
        /// update its completion state.
        public func put(_ body: PutRequest? = nil) -> Request<BoxAPI.Task> {
            .put(path, body: body)
        }

        public struct PutRequest: Encodable {
            /// The action the task assignee will be prompted to do. Must be
            /// 
            /// * `review` defines an approval task that can be approved or
            /// rejected
            /// * `complete` defines a general task which can be completed
            ///
            /// Example: "review"
            public var action: Action?
            /// Defines which assignees need to complete this task before the task
            /// is considered completed.
            /// 
            /// * `all_assignees` (default) requires all assignees to review or
            /// approve the the task in order for it to be considered completed.
            /// * `any_assignee` accepts any one assignee to review or
            /// approve the the task in order for it to be considered completed.
            ///
            /// Example: "all_assignees"
            public var completionRule: CompletionRule?
            /// When the task is due at.
            ///
            /// Example: "2012-12-12T10:53:43-08:00"
            public var dueAt: Date?
            /// The message included with the task.
            ///
            /// Example: "Please review"
            public var message: String?

            /// The action the task assignee will be prompted to do. Must be
            /// 
            /// * `review` defines an approval task that can be approved or
            /// rejected
            /// * `complete` defines a general task which can be completed
            ///
            /// Example: "review"
            public enum Action: String, Codable, CaseIterable {
                case review
                case complete
            }

            /// Defines which assignees need to complete this task before the task
            /// is considered completed.
            /// 
            /// * `all_assignees` (default) requires all assignees to review or
            /// approve the the task in order for it to be considered completed.
            /// * `any_assignee` accepts any one assignee to review or
            /// approve the the task in order for it to be considered completed.
            ///
            /// Example: "all_assignees"
            public enum CompletionRule: String, Codable, CaseIterable {
                case allAssignees = "all_assignees"
                case anyAssignee = "any_assignee"
            }

            public init(action: Action? = nil, completionRule: CompletionRule? = nil, dueAt: Date? = nil, message: String? = nil) {
                self.action = action
                self.completionRule = completionRule
                self.dueAt = dueAt
                self.message = message
            }

            private enum CodingKeys: String, CodingKey {
                case action
                case completionRule = "completion_rule"
                case dueAt = "due_at"
                case message
            }
        }

        /// Remove task
        ///
        /// Removes a task from a file.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Tasks.WithTaskID {
    public var assignments: Assignments {
        Assignments(path: path + "/assignments")
    }

    public struct Assignments {
        /// Path: `/tasks/{task_id}/assignments`
        public let path: String

        /// List task assignments
        ///
        /// Lists all of the assignments for a given task.
        public var get: Request<BoxAPI.TaskAssignments> {
            .get(path)
        }
    }
}

extension Paths {
    public static var termsOfServiceUserStatuses: TermsOfServiceUserStatuses {
        TermsOfServiceUserStatuses(path: "/terms_of_service_user_statuses")
    }

    public struct TermsOfServiceUserStatuses {
        /// Path: `/terms_of_service_user_statuses`
        public let path: String

        /// List terms of service user statuses
        ///
        /// Retrieves an overview of users and their status for a
        /// terms of service, including Whether they have accepted
        /// the terms and when.
        public func get(tosID: String, userID: String? = nil) -> Request<BoxAPI.TermsOfServiceUserStatuses> {
            .get(path, query: makeGetQuery(tosID, userID))
        }

        private func makeGetQuery(_ tosID: String, _ userID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tosID, forKey: "tos_id")
            encoder.encode(userID, forKey: "user_id")
            return encoder.items
        }

        /// Create terms of service status for new user
        ///
        /// Sets the status for a terms of service for a user.
        public func post(_ body: PostRequest? = nil) -> Request<BoxAPI.TermsOfServiceUserStatus> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Whether the user has accepted the terms.
            ///
            /// Example: true
            public var isAccepted: Bool
            /// The terms of service to set the status for.
            public var tos: Tos
            /// The user to set the status for.
            public var user: User

            /// The terms of service to set the status for.
            public struct Tos: Encodable {
                /// The ID of terms of service
                ///
                /// Example: "1232132"
                public var id: String
                /// The type of object.
                ///
                /// Example: "terms_of_service"
                public var type: `Type`

                /// The type of object.
                ///
                /// Example: "terms_of_service"
                public enum `Type`: String, Codable, CaseIterable {
                    case termsOfService = "terms_of_service"
                }

                public init(id: String, type: `Type`) {
                    self.id = id
                    self.type = type
                }
            }

            /// The user to set the status for.
            public struct User: Encodable {
                /// The ID of user
                ///
                /// Example: "3423423"
                public var id: String
                /// The type of object.
                ///
                /// Example: "user"
                public var type: `Type`

                /// The type of object.
                ///
                /// Example: "user"
                public enum `Type`: String, Codable, CaseIterable {
                    case user
                }

                public init(id: String, type: `Type`) {
                    self.id = id
                    self.type = type
                }
            }

            public init(isAccepted: Bool, tos: Tos, user: User) {
                self.isAccepted = isAccepted
                self.tos = tos
                self.user = user
            }

            private enum CodingKeys: String, CodingKey {
                case isAccepted = "is_accepted"
                case tos
                case user
            }
        }
    }
}

extension Paths.TermsOfServiceUserStatuses {
    public func termsOfServiceUserStatusID(_ termsOfServiceUserStatusID: String) -> WithTermsOfServiceUserStatusID {
        WithTermsOfServiceUserStatusID(path: "\(path)/\(termsOfServiceUserStatusID)")
    }

    public struct WithTermsOfServiceUserStatusID {
        /// Path: `/terms_of_service_user_statuses/{terms_of_service_user_status_id}`
        public let path: String

        /// Update terms of service status for existing user
        ///
        /// Updates the status for a terms of service for a user.
        public func put(isAccepted: Bool) -> Request<BoxAPI.TermsOfServiceUserStatus> {
            .put(path, body: ["is_accepted": isAccepted])
        }
    }
}

extension Paths {
    public static var termsOfServices: TermsOfServices {
        TermsOfServices(path: "/terms_of_services")
    }

    public struct TermsOfServices {
        /// Path: `/terms_of_services`
        public let path: String

        /// List terms of services
        ///
        /// Returns the current terms of service text and settings
        /// for the enterprise.
        public func get(tosType: TosType? = nil) -> Request<BoxAPI.TermsOfServices> {
            .get(path, query: makeGetQuery(tosType))
        }

        private func makeGetQuery(_ tosType: TosType?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(tosType, forKey: "tos_type")
            return encoder.items
        }

        public enum TosType: String, Codable, CaseIterable {
            case external
            case managed
        }

        /// Create terms of service
        ///
        /// Creates a terms of service for a given enterprise
        /// and type of user.
        public func post(_ body: PostRequest? = nil) -> Request<BoxAPI.Task> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Whether this terms of service is active.
            ///
            /// Example: "enabled"
            public var status: Status
            /// The terms of service text to display to users.
            /// 
            /// The text can be set to empty if the `status` is set to `disabled`.
            ///
            /// Example: "By collaborating on this file you are accepting..."
            public var text: String
            /// The type of user to set the terms of
            /// service for.
            ///
            /// Example: "managed"
            public var tosType: TosType?

            /// Whether this terms of service is active.
            ///
            /// Example: "enabled"
            public enum Status: String, Codable, CaseIterable {
                case enabled
                case disabled
            }

            /// The type of user to set the terms of
            /// service for.
            ///
            /// Example: "managed"
            public enum TosType: String, Codable, CaseIterable {
                case external
                case managed
            }

            public init(status: Status, text: String, tosType: TosType? = nil) {
                self.status = status
                self.text = text
                self.tosType = tosType
            }

            private enum CodingKeys: String, CodingKey {
                case status
                case text
                case tosType = "tos_type"
            }
        }
    }
}

extension Paths.TermsOfServices {
    public func termsOfServiceID(_ termsOfServiceID: String) -> WithTermsOfServiceID {
        WithTermsOfServiceID(path: "\(path)/\(termsOfServiceID)")
    }

    public struct WithTermsOfServiceID {
        /// Path: `/terms_of_services/{terms_of_service_id}`
        public let path: String

        /// Get terms of service
        ///
        /// Fetches a specific terms of service.
        public var get: Request<BoxAPI.TermsOfService> {
            .get(path)
        }

        /// Update terms of service
        ///
        /// Updates a specific terms of service.
        public func put(_ body: PutRequest? = nil) -> Request<BoxAPI.TermsOfService> {
            .put(path, body: body)
        }

        public struct PutRequest: Encodable {
            /// Whether this terms of service is active.
            ///
            /// Example: "enabled"
            public var status: Status
            /// The terms of service text to display to users.
            /// 
            /// The text can be set to empty if the `status` is set to `disabled`.
            ///
            /// Example: "By collaborating on this file you are accepting..."
            public var text: String

            /// Whether this terms of service is active.
            ///
            /// Example: "enabled"
            public enum Status: String, Codable, CaseIterable {
                case enabled
                case disabled
            }

            public init(status: Status, text: String) {
                self.status = status
                self.text = text
            }
        }
    }
}

extension Paths {
    public static var users: Users {
        Users(path: "/users")
    }

    public struct Users {
        /// Path: `/users`
        public let path: String

        /// List enterprise users
        ///
        /// Returns a list of all users for the Enterprise along with their `user_id`,
        /// `public_name`, and `login`.
        /// 
        /// The application and the authenticated user need to
        /// have the permission to look up users in the entire
        /// enterprise.
        public func get(parameters: GetParameters? = nil) -> Request<BoxAPI.Users> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var filterTerm: String?
            public var userType: UserType?
            public var externalAppUserID: String?
            public var fields: [String]?
            public var offset: Int?
            public var limit: Int?
            public var isUsemarker: Bool?
            public var marker: String?

            public enum UserType: String, Codable, CaseIterable {
                case all
                case managed
                case external
            }

            public init(filterTerm: String? = nil, userType: UserType? = nil, externalAppUserID: String? = nil, fields: [String]? = nil, offset: Int? = nil, limit: Int? = nil, isUsemarker: Bool? = nil, marker: String? = nil) {
                self.filterTerm = filterTerm
                self.userType = userType
                self.externalAppUserID = externalAppUserID
                self.fields = fields
                self.offset = offset
                self.limit = limit
                self.isUsemarker = isUsemarker
                self.marker = marker
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(filterTerm, forKey: "filter_term")
                encoder.encode(userType, forKey: "user_type")
                encoder.encode(externalAppUserID, forKey: "external_app_user_id")
                encoder.encode(fields, forKey: "fields", explode: false)
                encoder.encode(offset, forKey: "offset")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(isUsemarker, forKey: "usemarker")
                encoder.encode(marker, forKey: "marker")
                return encoder.items
            }
        }

        /// Create user
        ///
        /// Creates a new managed user in an enterprise. This endpoint
        /// is only available to users and applications with the right
        /// admin permissions.
        public func post(fields: [String]? = nil, _ body: PostRequest? = nil) -> Request<BoxAPI.User> {
            .post(path, query: makePostQuery(fields), body: body)
        }

        private func makePostQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        public struct PostRequest: Encodable {
            /// The userâ€™s address
            ///
            /// Example: "900 Jefferson Ave, Redwood City, CA 94063"
            public var address: String?
            /// Whether the user can see other enterprise users in their
            /// contact list
            ///
            /// Example: true
            public var canSeeManagedUsers: Bool?
            /// An external identifier for an app user, which can be used to look
            /// up the user. This can be used to tie user IDs from external
            /// identity providers to Box users.
            ///
            /// Example: "my-user-1234"
            public var externalAppUserID: String?
            /// Whether to exempt the user from enterprise device limits
            ///
            /// Example: true
            public var isExemptFromDeviceLimits: Bool?
            /// Whether the user must use two-factor authentication
            ///
            /// Example: true
            public var isExemptFromLoginVerification: Bool?
            /// Whether the user is allowed to collaborate with users outside
            /// their enterprise
            ///
            /// Example: true
            public var isExternalCollabRestricted: Bool?
            /// Specifies that the user is an app user.
            ///
            /// Example: true
            public var isPlatformAccessOnly: Bool?
            /// Whether the user can use Box Sync
            ///
            /// Example: true
            public var isSyncEnabled: Bool?
            /// The userâ€™s job title
            ///
            /// Example: "CEO"
            public var jobTitle: String?
            /// The language of the user, formatted in modified version of the
            /// [ISO 639-1](/guides/api-calls/language-codes) format.
            ///
            /// Example: "en"
            public var language: String?
            /// The email address the user uses to log in
            /// 
            /// Required, unless `is_platform_access_only`
            /// is set to `true`.
            ///
            /// Example: "boss@box.com"
            public var login: String?
            /// The name of the user
            ///
            /// Example: "Aaron Levie"
            public var name: String
            /// The userâ€™s phone number
            ///
            /// Example: "6509241374"
            public var phone: String?
            /// The userâ€™s enterprise role
            ///
            /// Example: "user"
            public var role: Role?
            /// The userâ€™s total available space in bytes. Set this to `-1` to
            /// indicate unlimited storage.
            ///
            /// Example: 11345156112
            public var spaceAmount: Int?
            /// The user's account status
            ///
            /// Example: "active"
            public var status: Status?
            /// The user's timezone
            ///
            /// Example: "Africa/Bujumbura"
            public var timezone: String?
            /// Tracking codes allow an admin to generate reports from the
            /// admin console and assign an attribute to a specific group
            /// of users. This setting must be enabled for an enterprise before it
            /// can be used.
            ///
            /// Example: ["code1: 12345"]
            public var trackingCodes: [String]?

            /// The userâ€™s enterprise role
            ///
            /// Example: "user"
            public enum Role: String, Codable, CaseIterable {
                case coadmin
                case user
            }

            /// The user's account status
            ///
            /// Example: "active"
            public enum Status: String, Codable, CaseIterable {
                case active
                case inactive
                case cannotDeleteEdit = "cannot_delete_edit"
                case cannotDeleteEditUpload = "cannot_delete_edit_upload"
            }

            public init(address: String? = nil, canSeeManagedUsers: Bool? = nil, externalAppUserID: String? = nil, isExemptFromDeviceLimits: Bool? = nil, isExemptFromLoginVerification: Bool? = nil, isExternalCollabRestricted: Bool? = nil, isPlatformAccessOnly: Bool? = nil, isSyncEnabled: Bool? = nil, jobTitle: String? = nil, language: String? = nil, login: String? = nil, name: String, phone: String? = nil, role: Role? = nil, spaceAmount: Int? = nil, status: Status? = nil, timezone: String? = nil, trackingCodes: [String]? = nil) {
                self.address = address
                self.canSeeManagedUsers = canSeeManagedUsers
                self.externalAppUserID = externalAppUserID
                self.isExemptFromDeviceLimits = isExemptFromDeviceLimits
                self.isExemptFromLoginVerification = isExemptFromLoginVerification
                self.isExternalCollabRestricted = isExternalCollabRestricted
                self.isPlatformAccessOnly = isPlatformAccessOnly
                self.isSyncEnabled = isSyncEnabled
                self.jobTitle = jobTitle
                self.language = language
                self.login = login
                self.name = name
                self.phone = phone
                self.role = role
                self.spaceAmount = spaceAmount
                self.status = status
                self.timezone = timezone
                self.trackingCodes = trackingCodes
            }

            private enum CodingKeys: String, CodingKey {
                case address
                case canSeeManagedUsers = "can_see_managed_users"
                case externalAppUserID = "external_app_user_id"
                case isExemptFromDeviceLimits = "is_exempt_from_device_limits"
                case isExemptFromLoginVerification = "is_exempt_from_login_verification"
                case isExternalCollabRestricted = "is_external_collab_restricted"
                case isPlatformAccessOnly = "is_platform_access_only"
                case isSyncEnabled = "is_sync_enabled"
                case jobTitle = "job_title"
                case language
                case login
                case name
                case phone
                case role
                case spaceAmount = "space_amount"
                case status
                case timezone
                case trackingCodes = "tracking_codes"
            }
        }
    }
}

extension Paths.Users {
    public var me: Me {
        Me(path: path + "/me")
    }

    public struct Me {
        /// Path: `/users/me`
        public let path: String

        /// Get current user
        ///
        /// Retrieves information about the user who is currently authenticated.
        /// 
        /// In the case of a client-side authenticated OAuth 2.0 application
        /// this will be the user who authorized the app.
        /// 
        /// In the case of a JWT, server-side authenticated application
        /// this will be the service account that belongs to the application
        /// by default.
        /// 
        /// Use the `As-User` header to change who this API call is made on behalf of.
        public func get(fields: [String]? = nil) -> Request<BoxAPI.User> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }
    }
}

extension Paths.Users {
    public func userID(_ userID: String) -> WithUserID {
        WithUserID(path: "\(path)/\(userID)")
    }

    public struct WithUserID {
        /// Path: `/users/{user_id}`
        public let path: String

        /// Get user
        ///
        /// Retrieves information about a user in the enterprise.
        /// 
        /// The application and the authenticated user need to
        /// have the permission to look up users in the entire
        /// enterprise.
        /// 
        /// This endpoint also returns a limited set of information
        /// for external users who are collaborated on content
        /// owned by the enterprise for authenticated users with the
        /// right scopes. In this case, disallowed fields will return
        /// null instead.
        public func get(fields: [String]? = nil) -> Request<BoxAPI.User> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        /// Update user
        ///
        /// Updates a managed user in an enterprise. This endpoint
        /// is only available to users and applications with the right
        /// admin permissions.
        public func put(fields: [String]? = nil, _ body: PutRequest? = nil) -> Request<BoxAPI.User> {
            .put(path, query: makePutQuery(fields), body: body)
        }

        private func makePutQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        public struct PutRequest: Encodable {
            /// The userâ€™s address
            ///
            /// Example: "900 Jefferson Ave, Redwood City, CA 94063"
            public var address: String?
            /// Whether the user can see other enterprise users in their
            /// contact list
            ///
            /// Example: true
            public var canSeeManagedUsers: Bool?
            /// Set this to `null` to roll the user out of the enterprise
            /// and make them a free user
            public var enterprise: String?
            /// Whether to exempt the user from enterprise device limits
            ///
            /// Example: true
            public var isExemptFromDeviceLimits: Bool?
            /// Whether the user must use two-factor authentication
            ///
            /// Example: true
            public var isExemptFromLoginVerification: Bool?
            /// Whether the user is allowed to collaborate with users outside
            /// their enterprise
            ///
            /// Example: true
            public var isExternalCollabRestricted: Bool?
            /// Whether the user is required to reset their password
            ///
            /// Example: true
            public var isPasswordResetRequired: Bool?
            /// Whether the user can use Box Sync
            ///
            /// Example: true
            public var isSyncEnabled: Bool?
            /// The userâ€™s job title
            ///
            /// Example: "CEO"
            public var jobTitle: String?
            /// The language of the user, formatted in modified version of the
            /// [ISO 639-1](/guides/api-calls/language-codes) format.
            ///
            /// Example: "en"
            public var language: String?
            /// The email address the user uses to log in
            ///
            /// Example: "boss@box.com"
            public var login: String?
            /// The name of the user
            ///
            /// Example: "Aaron Levie"
            public var name: String?
            /// An alternate notification email address to which email
            /// notifications are sent. When it's confirmed, this will be
            /// the email address to which notifications are sent instead of
            /// to the primary email address.
            /// 
            /// Set this value to `null` to remove the notification email.
            public var notificationEmail: NotificationEmail?
            /// Whether the user should receive an email when they
            /// are rolled out of an enterprise
            ///
            /// Example: true
            public var isNotify: Bool?
            /// The userâ€™s phone number
            ///
            /// Example: "6509241374"
            public var phone: String?
            /// The userâ€™s enterprise role
            ///
            /// Example: "user"
            public var role: Role?
            /// The userâ€™s total available space in bytes. Set this to `-1` to
            /// indicate unlimited storage.
            ///
            /// Example: 11345156112
            public var spaceAmount: Int?
            /// The user's account status
            ///
            /// Example: "active"
            public var status: Status?
            /// The user's timezone
            ///
            /// Example: "Africa/Bujumbura"
            public var timezone: String?
            /// Tracking codes allow an admin to generate reports from the
            /// admin console and assign an attribute to a specific group
            /// of users. This setting must be enabled for an enterprise before it
            /// can be used.
            ///
            /// Example: ["code1: 12345"]
            public var trackingCodes: [String]?

            /// An alternate notification email address to which email
            /// notifications are sent. When it's confirmed, this will be
            /// the email address to which notifications are sent instead of
            /// to the primary email address.
            /// 
            /// Set this value to `null` to remove the notification email.
            public struct NotificationEmail: Encodable {
                /// The email address to send the notifications to.
                ///
                /// Example: "notifications@example.com"
                public var email: String?

                public init(email: String? = nil) {
                    self.email = email
                }
            }

            /// The userâ€™s enterprise role
            ///
            /// Example: "user"
            public enum Role: String, Codable, CaseIterable {
                case coadmin
                case user
            }

            /// The user's account status
            ///
            /// Example: "active"
            public enum Status: String, Codable, CaseIterable {
                case active
                case inactive
                case cannotDeleteEdit = "cannot_delete_edit"
                case cannotDeleteEditUpload = "cannot_delete_edit_upload"
            }

            public init(address: String? = nil, canSeeManagedUsers: Bool? = nil, enterprise: String? = nil, isExemptFromDeviceLimits: Bool? = nil, isExemptFromLoginVerification: Bool? = nil, isExternalCollabRestricted: Bool? = nil, isPasswordResetRequired: Bool? = nil, isSyncEnabled: Bool? = nil, jobTitle: String? = nil, language: String? = nil, login: String? = nil, name: String? = nil, notificationEmail: NotificationEmail? = nil, isNotify: Bool? = nil, phone: String? = nil, role: Role? = nil, spaceAmount: Int? = nil, status: Status? = nil, timezone: String? = nil, trackingCodes: [String]? = nil) {
                self.address = address
                self.canSeeManagedUsers = canSeeManagedUsers
                self.enterprise = enterprise
                self.isExemptFromDeviceLimits = isExemptFromDeviceLimits
                self.isExemptFromLoginVerification = isExemptFromLoginVerification
                self.isExternalCollabRestricted = isExternalCollabRestricted
                self.isPasswordResetRequired = isPasswordResetRequired
                self.isSyncEnabled = isSyncEnabled
                self.jobTitle = jobTitle
                self.language = language
                self.login = login
                self.name = name
                self.notificationEmail = notificationEmail
                self.isNotify = isNotify
                self.phone = phone
                self.role = role
                self.spaceAmount = spaceAmount
                self.status = status
                self.timezone = timezone
                self.trackingCodes = trackingCodes
            }

            private enum CodingKeys: String, CodingKey {
                case address
                case canSeeManagedUsers = "can_see_managed_users"
                case enterprise
                case isExemptFromDeviceLimits = "is_exempt_from_device_limits"
                case isExemptFromLoginVerification = "is_exempt_from_login_verification"
                case isExternalCollabRestricted = "is_external_collab_restricted"
                case isPasswordResetRequired = "is_password_reset_required"
                case isSyncEnabled = "is_sync_enabled"
                case jobTitle = "job_title"
                case language
                case login
                case name
                case notificationEmail = "notification_email"
                case isNotify = "notify"
                case phone
                case role
                case spaceAmount = "space_amount"
                case status
                case timezone
                case trackingCodes = "tracking_codes"
            }
        }

        /// Delete user
        ///
        /// Deletes a user. By default this will fail if the user
        /// still owns any content. Move their owned content first
        /// before proceeding, or use the `force` field to delete
        /// the user and their files.
        public func delete(isNotify: Bool? = nil, isForce: Bool? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(isNotify, isForce))
        }

        private func makeDeleteQuery(_ isNotify: Bool?, _ isForce: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isNotify, forKey: "notify")
            encoder.encode(isForce, forKey: "force")
            return encoder.items
        }
    }
}

extension Paths.Users.WithUserID {
    public var avatar: Avatar {
        Avatar(path: path + "/avatar")
    }

    public struct Avatar {
        /// Path: `/users/{user_id}/avatar`
        public let path: String

        /// Get user avatar
        ///
        /// Retrieves an image of a the user's avatar.
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths.Users.WithUserID {
    public var emailAliases: EmailAliases {
        EmailAliases(path: path + "/email_aliases")
    }

    public struct EmailAliases {
        /// Path: `/users/{user_id}/email_aliases`
        public let path: String

        /// List user's email aliases
        ///
        /// Retrieves all email aliases for a user. The collection
        /// does not include the primary login for the user.
        public var get: Request<BoxAPI.EmailAliases> {
            .get(path)
        }

        /// Create email alias
        ///
        /// Adds a new email alias to a user account..
        public func post(email: String) -> Request<BoxAPI.EmailAlias> {
            .post(path, body: ["email": email])
        }
    }
}

extension Paths.Users.WithUserID.EmailAliases {
    public func emailAliasID(_ emailAliasID: String) -> WithEmailAliasID {
        WithEmailAliasID(path: "\(path)/\(emailAliasID)")
    }

    public struct WithEmailAliasID {
        /// Path: `/users/{user_id}/email_aliases/{email_alias_id}`
        public let path: String

        /// Remove email alias
        ///
        /// Removes an email alias from a user.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithUserID {
    public var folders: Folders {
        Folders(path: path + "/folders")
    }

    public struct Folders {
        /// Path: `/users/{user_id}/folders`
        public let path: String
    }
}

extension Paths.Users.WithUserID.Folders {
    public var _0: __0 {
        __0(path: path + "/0")
    }

    public struct __0 {
        /// Path: `/users/{user_id}/folders/0`
        public let path: String

        /// Transfer owned folders
        ///
        /// Move all of the items (files, folders and workflows) owned by a user into
        /// another user's account
        /// 
        /// Only the root folder (`0`) can be transferred.
        /// 
        /// Folders can only be moved across users by users with administrative
        /// permissions.
        /// 
        /// All existing shared links and folder-level collaborations are transferred
        /// during the operation. Please note that while collaborations at the individual
        /// file-level are transferred during the operation, the collaborations are
        /// deleted when the original user is deleted.
        /// 
        /// This call will be performed synchronously which might lead to a slow response
        /// when the source user has a large number of items in all of its folders.
        /// 
        /// If the destination path has a metadata cascade policy attached to any of
        /// the parent folders, a metadata cascade operation will be kicked off
        /// asynchronously.
        /// 
        /// There is currently no way to check for when this operation is finished.
        /// 
        /// The destination folder's name will be in the format `{User}'s Files and
        /// Folders`, where `{User}` is the display name of the user.
        /// 
        /// To make this API call your application will need to have the "Read and write
        /// all files and folders stored in Box" scope enabled.
        /// 
        /// Please make sure the destination user has access to `Relay` or `Relay Lite`,
        /// and has access to the files and folders involved in the workflows being
        /// transferred.
        /// 
        /// Admins will receive an email when the operation is completed.
        public func put(fields: [String]? = nil, isNotify: Bool? = nil, ownedBy: PutRequest.OwnedBy) -> Request<BoxAPI.Folder> {
            .put(path, query: makePutQuery(fields, isNotify), body: PutRequest(ownedBy: ownedBy))
        }

        private func makePutQuery(_ fields: [String]?, _ isNotify: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            encoder.encode(isNotify, forKey: "notify")
            return encoder.items
        }

        public struct PutRequest: Encodable {
            /// The user who the folder will be transferred to
            public var ownedBy: OwnedBy

            /// The user who the folder will be transferred to
            public struct OwnedBy: Encodable {
                /// The ID of the user who the folder will be
                /// transferred to
                ///
                /// Example: "1232234"
                public var id: String

                public init(id: String) {
                    self.id = id
                }
            }

            public init(ownedBy: OwnedBy) {
                self.ownedBy = ownedBy
            }

            private enum CodingKeys: String, CodingKey {
                case ownedBy = "owned_by"
            }
        }
    }
}

extension Paths.Users.WithUserID {
    public var memberships: Memberships {
        Memberships(path: path + "/memberships")
    }

    public struct Memberships {
        /// Path: `/users/{user_id}/memberships`
        public let path: String

        /// List user's groups
        ///
        /// Retrieves all the groups for a user. Only members of this
        /// group or users with admin-level permissions will be able to
        /// use this API.
        public func get(limit: Int? = nil, offset: Int? = nil) -> Request<BoxAPI.GroupMemberships> {
            .get(path, query: makeGetQuery(limit, offset))
        }

        private func makeGetQuery(_ limit: Int?, _ offset: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(limit, forKey: "limit")
            encoder.encode(offset, forKey: "offset")
            return encoder.items
        }
    }
}

extension Paths {
    public static var webLinks: WebLinks {
        WebLinks(path: "/web_links")
    }

    public struct WebLinks {
        /// Path: `/web_links`
        public let path: String

        /// Create web link
        ///
        /// Creates a web link object within a folder.
        public func post(_ body: PostRequest? = nil) -> Request<BoxAPI.WebLink> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Description of the web link.
            ///
            /// Example: "Cloud Content Management"
            public var description: String?
            /// Name of the web link. Defaults to the URL if not set.
            ///
            /// Example: "Box Website"
            public var name: String?
            /// The parent folder to create the web link within.
            public var parent: Parent
            /// The URL that this web link links to. Must start with
            /// `"http://"` or `"https://"`.
            ///
            /// Example: "https://box.com"
            public var url: String

            /// The parent folder to create the web link within.
            public struct Parent: Encodable {
                /// The ID of parent folder
                ///
                /// Example: "0"
                public var id: String

                public init(id: String) {
                    self.id = id
                }
            }

            public init(description: String? = nil, name: String? = nil, parent: Parent, url: String) {
                self.description = description
                self.name = name
                self.parent = parent
                self.url = url
            }
        }
    }
}

extension Paths.WebLinks {
    public func webLinkID(_ webLinkID: String) -> WithWebLinkID {
        WithWebLinkID(path: "\(path)/\(webLinkID)")
    }

    public struct WithWebLinkID {
        /// Path: `/web_links/{web_link_id}`
        public let path: String

        /// Get web link
        ///
        /// Retrieve information about a web link.
        public var get: Request<BoxAPI.WebLink> {
            .get(path)
        }

        /// Restore web link
        ///
        /// Restores a web link that has been moved to the trash.
        /// 
        /// An optional new parent ID can be provided to restore the  web link to in case
        /// the original folder has been deleted.
        public func post(fields: [String]? = nil, _ body: PostRequest? = nil) -> Request<BoxAPI.WebLink> {
            .post(path, query: makePostQuery(fields), body: body)
        }

        private func makePostQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        public struct PostRequest: Encodable {
            /// An optional new name for the web link.
            ///
            /// Example: "Restored.docx"
            public var name: String?
            public var parent: Parent?

            public struct Parent: Encodable {
                /// The ID of parent item
                ///
                /// Example: "123"
                public var id: String?
                /// Specifies an optional ID of a folder to restore the web link
                /// to when the original folder no longer exists.
                /// 
                /// Please be aware that this ID will only be used if the original
                /// folder no longer exists. Use this ID to provide a fallback
                /// location to restore the web link to if the original location
                /// has been deleted.
                public var anyJSON: AnyJSON

                public init(id: String? = nil, anyJSON: AnyJSON) {
                    self.id = id
                    self.anyJSON = anyJSON
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(id, forKey: "id")
                    try values.encode(anyJSON, forKey: "anyJSON")
                }
            }

            public init(name: String? = nil, parent: Parent? = nil) {
                self.name = name
                self.parent = parent
            }
        }

        /// Update web link
        ///
        /// Updates a web link object.
        public func put(_ body: PutRequest? = nil) -> Request<BoxAPI.WebLink> {
            .put(path, body: body)
        }

        public struct PutRequest: Encodable {
            /// A new description of the web link.
            ///
            /// Example: "Cloud Content Management"
            public var description: String?
            /// A new name for the web link. Defaults to the URL if not set.
            ///
            /// Example: "Box Website"
            public var name: String?
            public var parent: Parent?
            /// The new URL that the web link links to. Must start with
            /// `"http://"` or `"https://"`.
            ///
            /// Example: "https://box.com"
            public var url: String?

            public struct Parent: Encodable {
                /// The ID of parent item
                ///
                /// Example: "123"
                public var id: String?
                /// The new parent folder to put the web link in.
                /// Use this to move the web link to a different folder.
                public var anyJSON: AnyJSON

                public init(id: String? = nil, anyJSON: AnyJSON) {
                    self.id = id
                    self.anyJSON = anyJSON
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(id, forKey: "id")
                    try values.encode(anyJSON, forKey: "anyJSON")
                }
            }

            public init(description: String? = nil, name: String? = nil, parent: Parent? = nil, url: String? = nil) {
                self.description = description
                self.name = name
                self.parent = parent
                self.url = url
            }
        }

        /// Remove web link
        ///
        /// Deletes a web link.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.WebLinks.WithWebLinkID {
    public var trash: Trash {
        Trash(path: path + "/trash")
    }

    public struct Trash {
        /// Path: `/web_links/{web_link_id}/trash`
        public let path: String

        /// Get trashed web link
        ///
        /// Retrieves a web link that has been moved to the trash.
        public func get(fields: [String]? = nil) -> Request<BoxAPI.Folder> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }

        /// Permanently remove web link
        ///
        /// Permanently deletes a web link that is in the trash.
        /// This action cannot be undone.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var webhooks: Webhooks {
        Webhooks(path: "/webhooks")
    }

    public struct Webhooks {
        /// Path: `/webhooks`
        public let path: String

        /// List all webhooks
        ///
        /// Returns all defined webhooks for the requesting application.
        /// 
        /// This API only returns webhooks that are applied to files or folders that are
        /// owned by the authenticated user. This means that an admin can not see webhooks
        /// created by a service account unless the admin has access to those folders, and
        /// vice versa.
        public func get(marker: String? = nil, limit: Int? = nil) -> Request<BoxAPI.Webhooks> {
            .get(path, query: makeGetQuery(marker, limit))
        }

        private func makeGetQuery(_ marker: String?, _ limit: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(marker, forKey: "marker")
            encoder.encode(limit, forKey: "limit")
            return encoder.items
        }

        /// Create webhook
        ///
        /// Creates a webhook.
        public func post(_ body: PostRequest? = nil) -> Request<BoxAPI.Webhook> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The URL that is notified by this webhook
            ///
            /// Example: "https://example.com/webhooks"
            public var address: String
            /// The item that will trigger the webhook
            public var target: Target
            /// An array of event names that this webhook is
            /// to be triggered for
            ///
            /// Example: ["FILE.UPLOADED"]
            public var triggers: [Trigger]

            /// The item that will trigger the webhook
            public struct Target: Encodable {
                /// The ID of the item to trigger a webhook
                ///
                /// Example: "1231232"
                public var id: String?
                /// The type of item to trigger a webhook
                ///
                /// Example: "file"
                public var type: `Type`?

                /// The type of item to trigger a webhook
                ///
                /// Example: "file"
                public enum `Type`: String, Codable, CaseIterable {
                    case file
                    case folder
                }

                public init(id: String? = nil, type: `Type`? = nil) {
                    self.id = id
                    self.type = type
                }
            }

            /// Webhook Trigger
            ///
            /// The event name that triggered this webhook
            ///
            /// Example: "FILE.UPLOADED"
            public enum Trigger: String, Codable, CaseIterable {
                case fileUploaded = "FILE.UPLOADED"
                case filePreviewed = "FILE.PREVIEWED"
                case fileDownloaded = "FILE.DOWNLOADED"
                case fileTrashed = "FILE.TRASHED"
                case fileDeleted = "FILE.DELETED"
                case fileRestored = "FILE.RESTORED"
                case fileCopied = "FILE.COPIED"
                case fileMoved = "FILE.MOVED"
                case fileLocked = "FILE.LOCKED"
                case fileUnlocked = "FILE.UNLOCKED"
                case fileRenamed = "FILE.RENAMED"
                case commentCreated = "COMMENT.CREATED"
                case commentUpdated = "COMMENT.UPDATED"
                case commentDeleted = "COMMENT.DELETED"
                case taskAssignmentCreated = "TASK_ASSIGNMENT.CREATED"
                case taskAssignmentUpdated = "TASK_ASSIGNMENT.UPDATED"
                case metadataInstanceCreated = "METADATA_INSTANCE.CREATED"
                case metadataInstanceUpdated = "METADATA_INSTANCE.UPDATED"
                case metadataInstanceDeleted = "METADATA_INSTANCE.DELETED"
                case folderCreated = "FOLDER.CREATED"
                case folderRenamed = "FOLDER.RENAMED"
                case folderDownloaded = "FOLDER.DOWNLOADED"
                case folderRestored = "FOLDER.RESTORED"
                case folderDeleted = "FOLDER.DELETED"
                case folderCopied = "FOLDER.COPIED"
                case folderMoved = "FOLDER.MOVED"
                case folderTrashed = "FOLDER.TRASHED"
                case webhookDeleted = "WEBHOOK.DELETED"
                case collaborationCreated = "COLLABORATION.CREATED"
                case collaborationAccepted = "COLLABORATION.ACCEPTED"
                case collaborationRejected = "COLLABORATION.REJECTED"
                case collaborationRemoved = "COLLABORATION.REMOVED"
                case collaborationUpdated = "COLLABORATION.UPDATED"
                case sharedLinkDeleted = "SHARED_LINK.DELETED"
                case sharedLinkCreated = "SHARED_LINK.CREATED"
                case sharedLinkUpdated = "SHARED_LINK.UPDATED"
            }

            public init(address: String, target: Target, triggers: [Trigger]) {
                self.address = address
                self.target = target
                self.triggers = triggers
            }
        }
    }
}

extension Paths.Webhooks {
    public func webhookID(_ webhookID: String) -> WithWebhookID {
        WithWebhookID(path: "\(path)/\(webhookID)")
    }

    public struct WithWebhookID {
        /// Path: `/webhooks/{webhook_id}`
        public let path: String

        /// Get webhook
        ///
        /// Retrieves a specific webhook
        public var get: Request<BoxAPI.Webhook> {
            .get(path)
        }

        /// Update webhook
        ///
        /// Updates a webhook.
        public func put(_ body: PutRequest? = nil) -> Request<BoxAPI.Webhook> {
            .put(path, body: body)
        }

        public struct PutRequest: Encodable {
            /// The URL that is notified by this webhook
            ///
            /// Example: "https://example.com/webhooks"
            public var address: String?
            /// The item that will trigger the webhook
            public var target: Target?
            /// An array of event names that this webhook is
            /// to be triggered for
            ///
            /// Example: ["FILE.UPLOADED"]
            public var triggers: [Trigger]?

            /// The item that will trigger the webhook
            public struct Target: Encodable {
                /// The ID of the item to trigger a webhook
                ///
                /// Example: "1231232"
                public var id: String?
                /// The type of item to trigger a webhook
                ///
                /// Example: "file"
                public var type: `Type`?

                /// The type of item to trigger a webhook
                ///
                /// Example: "file"
                public enum `Type`: String, Codable, CaseIterable {
                    case file
                    case folder
                }

                public init(id: String? = nil, type: `Type`? = nil) {
                    self.id = id
                    self.type = type
                }
            }

            /// Webhook Trigger
            ///
            /// The event name that triggered this webhook
            ///
            /// Example: "FILE.UPLOADED"
            public enum Trigger: String, Codable, CaseIterable {
                case fileUploaded = "FILE.UPLOADED"
                case filePreviewed = "FILE.PREVIEWED"
                case fileDownloaded = "FILE.DOWNLOADED"
                case fileTrashed = "FILE.TRASHED"
                case fileDeleted = "FILE.DELETED"
                case fileRestored = "FILE.RESTORED"
                case fileCopied = "FILE.COPIED"
                case fileMoved = "FILE.MOVED"
                case fileLocked = "FILE.LOCKED"
                case fileUnlocked = "FILE.UNLOCKED"
                case fileRenamed = "FILE.RENAMED"
                case commentCreated = "COMMENT.CREATED"
                case commentUpdated = "COMMENT.UPDATED"
                case commentDeleted = "COMMENT.DELETED"
                case taskAssignmentCreated = "TASK_ASSIGNMENT.CREATED"
                case taskAssignmentUpdated = "TASK_ASSIGNMENT.UPDATED"
                case metadataInstanceCreated = "METADATA_INSTANCE.CREATED"
                case metadataInstanceUpdated = "METADATA_INSTANCE.UPDATED"
                case metadataInstanceDeleted = "METADATA_INSTANCE.DELETED"
                case folderCreated = "FOLDER.CREATED"
                case folderRenamed = "FOLDER.RENAMED"
                case folderDownloaded = "FOLDER.DOWNLOADED"
                case folderRestored = "FOLDER.RESTORED"
                case folderDeleted = "FOLDER.DELETED"
                case folderCopied = "FOLDER.COPIED"
                case folderMoved = "FOLDER.MOVED"
                case folderTrashed = "FOLDER.TRASHED"
                case webhookDeleted = "WEBHOOK.DELETED"
                case collaborationCreated = "COLLABORATION.CREATED"
                case collaborationAccepted = "COLLABORATION.ACCEPTED"
                case collaborationRejected = "COLLABORATION.REJECTED"
                case collaborationRemoved = "COLLABORATION.REMOVED"
                case collaborationUpdated = "COLLABORATION.UPDATED"
                case sharedLinkDeleted = "SHARED_LINK.DELETED"
                case sharedLinkCreated = "SHARED_LINK.CREATED"
                case sharedLinkUpdated = "SHARED_LINK.UPDATED"
            }

            public init(address: String? = nil, target: Target? = nil, triggers: [Trigger]? = nil) {
                self.address = address
                self.target = target
                self.triggers = triggers
            }
        }

        /// Remove webhook
        ///
        /// Deletes a webhook.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var workflows: Workflows {
        Workflows(path: "/workflows")
    }

    public struct Workflows {
        /// Path: `/workflows`
        public let path: String

        /// List workflows
        ///
        /// Returns list of workflows that act on a given `folder ID`, and
        /// have a flow with a trigger type of `WORKFLOW_MANUAL_START`.
        /// 
        /// You application must be authorized to use the `Manage Box Relay` application
        /// scope within the developer console in to use this endpoint.
        public func get(parameters: GetParameters) -> Request<BoxAPI.Workflows> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var folderID: String
            public var triggerType: String?
            public var limit: Int?
            public var marker: String?

            public init(folderID: String, triggerType: String? = nil, limit: Int? = nil, marker: String? = nil) {
                self.folderID = folderID
                self.triggerType = triggerType
                self.limit = limit
                self.marker = marker
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(folderID, forKey: "folder_id")
                encoder.encode(triggerType, forKey: "trigger_type")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(marker, forKey: "marker")
                return encoder.items
            }
        }
    }
}

extension Paths.Workflows {
    public func workflowID(_ workflowID: String) -> WithWorkflowID {
        WithWorkflowID(path: "\(path)/\(workflowID)")
    }

    public struct WithWorkflowID {
        /// Path: `/workflows/{workflow_id}`
        public let path: String
    }
}

extension Paths.Workflows.WithWorkflowID {
    public var start: Start {
        Start(path: path + "/start")
    }

    public struct Start {
        /// Path: `/workflows/{workflow_id}/start`
        public let path: String

        /// Starts workflow based on request body
        ///
        /// Initiates a flow with a trigger type of `WORKFLOW_MANUAL_START`.
        /// 
        /// You application must be authorized to use the `Manage Box Relay` application
        /// scope within the developer console.
        public func post(_ body: PostRequest? = nil) -> Request<Void> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The array of files for which the workflow should start. All files
            /// must be in the workflow's configured folder.
            public var files: [File]
            /// The flow that will be triggered
            public var flow: Flow
            /// The folder object for which the workflow is configured.
            public var folder: Folder
            /// A list of outcomes required to be configured at start time.
            public var outcomes: [[String: AnyJSON]]?
            /// The type of the parameters object
            ///
            /// Example: "workflow_parameters"
            public var type: `Type`?

            /// A file the workflow should start for
            public struct File: Encodable {
                /// The id of the file
                ///
                /// Example: "12345678"
                public var id: String?
                /// The type of the file object
                ///
                /// Example: "file"
                public var type: `Type`?

                /// The type of the file object
                ///
                /// Example: "file"
                public enum `Type`: String, Codable, CaseIterable {
                    case file
                }

                public init(id: String? = nil, type: `Type`? = nil) {
                    self.id = id
                    self.type = type
                }
            }

            /// The flow that will be triggered
            public struct Flow: Encodable {
                /// The id of the flow
                ///
                /// Example: "123456789"
                public var id: String?
                /// The type of the flow object
                ///
                /// Example: "flow"
                public var type: String?

                public init(id: String? = nil, type: String? = nil) {
                    self.id = id
                    self.type = type
                }
            }

            /// The folder object for which the workflow is configured.
            public struct Folder: Encodable {
                /// The id of the folder
                ///
                /// Example: "87654321"
                public var id: String?
                /// The type of the folder object
                ///
                /// Example: "folder"
                public var type: `Type`?

                /// The type of the folder object
                ///
                /// Example: "folder"
                public enum `Type`: String, Codable, CaseIterable {
                    case folder
                }

                public init(id: String? = nil, type: `Type`? = nil) {
                    self.id = id
                    self.type = type
                }
            }

            /// The type of the parameters object
            ///
            /// Example: "workflow_parameters"
            public enum `Type`: String, Codable, CaseIterable {
                case workflowParameters = "workflow_parameters"
            }

            public init(files: [File], flow: Flow, folder: Folder, outcomes: [[String: AnyJSON]]? = nil, type: `Type`? = nil) {
                self.files = files
                self.flow = flow
                self.folder = folder
                self.outcomes = outcomes
                self.type = type
            }
        }
    }
}

extension Paths {
    public static var zipDownloads: ZipDownloads {
        ZipDownloads(path: "/zip_downloads")
    }

    public struct ZipDownloads {
        /// Path: `/zip_downloads`
        public let path: String

        /// Create zip download
        ///
        /// Creates a request to download multiple files and folders as a single `zip`
        /// archive file. This API does not return the archive but instead performs all
        /// the checks to ensure that the user has access to all the items, and then
        /// returns a `download_url` and a `status_url` that can be used to download the
        /// archive.
        /// 
        /// The limit for an archive is either the Account's upload limit or
        /// 10,000 files, whichever is met first
        public func post(_ body: BoxAPI.ZipDownloadRequest? = nil) -> Request<BoxAPI.ZipDownload> {
            .post(path, body: body)
        }
    }
}

extension Paths.ZipDownloads {
    public func zipDownloadID(_ zipDownloadID: String) -> WithZipDownloadID {
        WithZipDownloadID(path: "\(path)/\(zipDownloadID)")
    }

    public struct WithZipDownloadID {
        /// Path: `/zip_downloads/{zip_download_id}`
        public let path: String
    }
}

extension Paths.ZipDownloads.WithZipDownloadID {
    public var content: Content {
        Content(path: path + "/content")
    }

    public struct Content {
        /// Path: `/zip_downloads/{zip_download_id}/content`
        public let path: String

        /// Download zip archive
        ///
        /// Returns the contents of a `zip` archive in binary format. This URL does not
        /// require any form of authentication and could be used in a user's browser to
        /// download the archive to a user's device.
        /// 
        /// By default, this URL is only valid for a few seconds from the creation of
        /// the request for this archive. Once a download has started it can not be
        /// stopped and resumed, instead a new request for a zip archive would need to
        /// be created.
        /// 
        /// The URL of this endpoint should not be considered as fixed. Instead, use
        /// the [Create zip download](e://post_zip_downloads) API to request to create a
        /// `zip` archive, and then follow the `download_url` field in the response to
        /// this endpoint.
        public var get: Request<Data> {
            .get(path)
        }

        public enum GetResponseHeaders {
            /// The name of the archive to be downloaded
            public static let contentDisposition = HTTPHeader<String>(field: "Content-Disposition")
        }
    }
}

extension Paths.ZipDownloads.WithZipDownloadID {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/zip_downloads/{zip_download_id}/status`
        public let path: String

        /// Get zip download status
        ///
        /// Returns the download status of a `zip` archive, allowing an application to
        /// inspect the progress of the download as well as the number of items that
        /// might have been skipped.
        /// 
        /// This endpoint can only be accessed once the download has started.
        /// Subsequently this endpoint is valid for 12 hours from the start of the
        /// download.
        /// 
        /// The URL of this endpoint should not be considered as fixed. Instead, use
        /// the [Create zip download](e://post_zip_downloads) API to request to create a
        /// `zip` archive, and then follow the `status_url` field in the response to
        /// this endpoint.
        public var get: Request<BoxAPI.ZipDownloadStatus> {
            .get(path)
        }
    }
}

public enum Paths {}
