// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import NaiveDate

/// Jira instance health check results. Deprecated and no longer returned.
public struct HealthCheckResult: Codable {
    /// The name of the Jira health check item.
    public var name: String?
    /// The description of the Jira health check item.
    public var description: String?
    /// Whether the Jira health check item passed or failed.
    public var isPassed: Bool?

    public init(name: String? = nil, description: String? = nil, isPassed: Bool? = nil) {
        self.name = name
        self.description = description
        self.isPassed = isPassed
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case description
        case isPassed = "passed"
    }
}

/// Details about the Jira instance.
public struct ServerInformation: Codable {
    /// The base URL of the Jira instance.
    public var baseURL: String?
    /// The version of Jira.
    public var version: String?
    /// The major, minor, and revision version numbers of the Jira version.
    public var versionNumbers: [Int]?
    /// The type of server deployment. This is always returned as *Cloud*.
    public var deploymentType: String?
    /// The build number of the Jira version.
    public var buildNumber: Int?
    /// The timestamp when the Jira version was built.
    public var buildDate: Date?
    /// The time in Jira when this request was responded to.
    public var serverTime: Date?
    /// The unique identifier of the Jira version.
    public var scmInfo: String?
    /// The name of the Jira instance.
    public var serverTitle: String?
    /// Jira instance health check results. Deprecated and no longer returned.
    public var healthChecks: [HealthCheckResult]?

    public init(baseURL: String? = nil, version: String? = nil, versionNumbers: [Int]? = nil, deploymentType: String? = nil, buildNumber: Int? = nil, buildDate: Date? = nil, serverTime: Date? = nil, scmInfo: String? = nil, serverTitle: String? = nil, healthChecks: [HealthCheckResult]? = nil) {
        self.baseURL = baseURL
        self.version = version
        self.versionNumbers = versionNumbers
        self.deploymentType = deploymentType
        self.buildNumber = buildNumber
        self.buildDate = buildDate
        self.serverTime = serverTime
        self.scmInfo = scmInfo
        self.serverTitle = serverTitle
        self.healthChecks = healthChecks
    }

    private enum CodingKeys: String, CodingKey {
        case baseURL = "baseUrl"
        case version
        case versionNumbers
        case deploymentType
        case buildNumber
        case buildDate
        case serverTime
        case scmInfo
        case serverTitle
        case healthChecks
    }
}

/// A list of JQL queries to parse.
public struct JqlQueriesToParse: Codable {
    /// A list of queries to parse.
    public var queries: String

    public init(queries: String) {
        self.queries = queries
    }
}

/// A JQL query clause that consists of nested clauses. For example, `(labels in (urgent, blocker) OR lastCommentedBy = currentUser()). Note that, where nesting is not defined, the parser nests JQL clauses based on the operator precedence. For example, "A OR B AND C" is parsed as "(A OR B) AND C". See Setting the precedence of operators for more information about precedence in JQL queries.`
public struct CompoundClause: Codable {
    /// The list of nested clauses.
    public var clauses: [JqlQueryClause]
    /// The operator between the clauses.
    public var `operator`: Operator

    /// The operator between the clauses.
    public enum Operator: String, Codable, CaseIterable {
        case and
        case or
        case not
    }

    public init(clauses: [JqlQueryClause], `operator`: Operator) {
        self.clauses = clauses
        self.operator = `operator`
    }

    private enum CodingKeys: String, CodingKey {
        case clauses
        case `operator` = "operator"
    }
}

/// A clause that asserts whether a field was changed. For example, `status CHANGED AFTER startOfMonth(-1M)`.See [CHANGED](https://confluence.atlassian.com/x/dgiiLQ#Advancedsearching-operatorsreference-CHANGEDCHANGED) for more information about the CHANGED operator.
public struct FieldChangedClause: Codable {
    /// A field used in a JQL query. See [Advanced searching - fields reference](https://confluence.atlassian.com/x/dAiiLQ) for more information about fields in JQL queries.
    public var field: JqlQueryField
    /// The operator applied to the field.
    public var `operator`: Operator
    /// The list of time predicates.
    public var predicates: [JqlQueryClauseTimePredicate]

    /// The operator applied to the field.
    public enum Operator: String, Codable, CaseIterable {
        case changed
    }

    public init(field: JqlQueryField, `operator`: Operator, predicates: [JqlQueryClauseTimePredicate]) {
        self.field = field
        self.operator = `operator`
        self.predicates = predicates
    }

    private enum CodingKeys: String, CodingKey {
        case field
        case `operator` = "operator"
        case predicates
    }
}

/// A clause that asserts the current value of a field. For example, `summary ~ test`.
public struct FieldValueClause: Codable {
    /// A field used in a JQL query. See [Advanced searching - fields reference](https://confluence.atlassian.com/x/dAiiLQ) for more information about fields in JQL queries.
    public var field: JqlQueryField
    /// The operator between the field and operand.
    public var `operator`: Operator
    /// Details of an operand in a JQL clause.
    public var operand: JqlQueryClauseOperand

    /// The operator between the field and operand.
    public enum Operator: String, Codable, CaseIterable {
        case equal = "="
        case notEqual = "!="
        case greaterThan = ">"
        case lessThan = "<"
        case greaterThanOrEqualTo = ">="
        case lessThanOrEqualTo = "<="
        case `in`
        case notIn = "not in"
        case tilda = "~"
        case tildaEqual = "~="
        case `is`
        case isNot = "is not"
    }

    public init(field: JqlQueryField, `operator`: Operator, operand: JqlQueryClauseOperand) {
        self.field = field
        self.operator = `operator`
        self.operand = operand
    }

    private enum CodingKeys: String, CodingKey {
        case field
        case `operator` = "operator"
        case operand
    }
}

/// A clause that asserts a previous value of a field. For example, `status WAS "Resolved" BY currentUser() BEFORE "2019/02/02"`. See [WAS](https://confluence.atlassian.com/x/dgiiLQ#Advancedsearching-operatorsreference-WASWAS) for more information about the WAS operator.
public struct FieldWasClause: Codable {
    /// A field used in a JQL query. See [Advanced searching - fields reference](https://confluence.atlassian.com/x/dAiiLQ) for more information about fields in JQL queries.
    public var field: JqlQueryField
    /// The operator between the field and operand.
    public var `operator`: Operator
    /// Details of an operand in a JQL clause.
    public var operand: JqlQueryClauseOperand
    /// The list of time predicates.
    public var predicates: [JqlQueryClauseTimePredicate]

    /// The operator between the field and operand.
    public enum Operator: String, Codable, CaseIterable {
        case was
        case wasIn = "was in"
        case wasNotIn = "was not in"
        case wasNot = "was not"
    }

    public init(field: JqlQueryField, `operator`: Operator, operand: JqlQueryClauseOperand, predicates: [JqlQueryClauseTimePredicate]) {
        self.field = field
        self.operator = `operator`
        self.operand = operand
        self.predicates = predicates
    }

    private enum CodingKeys: String, CodingKey {
        case field
        case `operator` = "operator"
        case operand
        case predicates
    }
}

/// An operand that is a function. See [Advanced searching - functions reference](https://confluence.atlassian.com/x/dwiiLQ) for more information about JQL functions.
public struct FunctionOperand: Codable {
    /// The name of the function.
    public var function: String
    /// The list of function arguments.
    public var arguments: [String]

    public init(function: String, arguments: [String]) {
        self.function = function
        self.arguments = arguments
    }
}

/// A parsed JQL query.
public struct JqlQuery: Codable {
    public var `where`: JqlQueryClause?
    /// Details of the order-by JQL clause.
    public var orderBy: JqlQueryOrderByClause?

    public init(`where`: JqlQueryClause? = nil, orderBy: JqlQueryOrderByClause? = nil) {
        self.where = `where`
        self.orderBy = orderBy
    }

    private enum CodingKeys: String, CodingKey {
        case `where` = "where"
        case orderBy
    }
}

/// A JQL query clause.
public struct JqlQueryClause: Codable {
    public var compoundClause: CompoundClause?
    /// A clause that asserts the current value of a field. For example, `summary ~ test`.
    public var fieldValueClause: FieldValueClause?
    /// A clause that asserts a previous value of a field. For example, `status WAS "Resolved" BY currentUser() BEFORE "2019/02/02"`. See [WAS](https://confluence.atlassian.com/x/dgiiLQ#Advancedsearching-operatorsreference-WASWAS) for more information about the WAS operator.
    public var fieldWasClause: FieldWasClause?
    /// A clause that asserts whether a field was changed. For example, `status CHANGED AFTER startOfMonth(-1M)`.See [CHANGED](https://confluence.atlassian.com/x/dgiiLQ#Advancedsearching-operatorsreference-CHANGEDCHANGED) for more information about the CHANGED operator.
    public var fieldChangedClause: FieldChangedClause?

    public init(compoundClause: CompoundClause? = nil, fieldValueClause: FieldValueClause? = nil, fieldWasClause: FieldWasClause? = nil, fieldChangedClause: FieldChangedClause? = nil) {
        self.compoundClause = compoundClause
        self.fieldValueClause = fieldValueClause
        self.fieldWasClause = fieldWasClause
        self.fieldChangedClause = fieldChangedClause
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        self.compoundClause = try? container.decode(CompoundClause.self)
        self.fieldValueClause = try? container.decode(FieldValueClause.self)
        self.fieldWasClause = try? container.decode(FieldWasClause.self)
        self.fieldChangedClause = try? container.decode(FieldChangedClause.self)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        if let value = compoundClause { try container.encode(value) }
        if let value = fieldValueClause { try container.encode(value) }
        if let value = fieldWasClause { try container.encode(value) }
        if let value = fieldChangedClause { try container.encode(value) }
    }
}

/// Details of an operand in a JQL clause.
public struct JqlQueryClauseOperand: Codable {
    /// An operand that is a list of values.
    public var listOperand: ListOperand?
    /// An operand that is a user-provided value.
    public var valueOperand: ValueOperand?
    /// An operand that is a function. See [Advanced searching - functions reference](https://confluence.atlassian.com/x/dwiiLQ) for more information about JQL functions.
    public var functionOperand: FunctionOperand?
    /// An operand that is a JQL keyword. See [Advanced searching - keywords reference](https://confluence.atlassian.com/jiracorecloud/advanced-searching-keywords-reference-765593717.html#Advancedsearching-keywordsreference-EMPTYEMPTY) for more information about operand keywords.
    public var keywordOperand: KeywordOperand?

    public init(listOperand: ListOperand? = nil, valueOperand: ValueOperand? = nil, functionOperand: FunctionOperand? = nil, keywordOperand: KeywordOperand? = nil) {
        self.listOperand = listOperand
        self.valueOperand = valueOperand
        self.functionOperand = functionOperand
        self.keywordOperand = keywordOperand
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        self.listOperand = try? container.decode(ListOperand.self)
        self.valueOperand = try? container.decode(ValueOperand.self)
        self.functionOperand = try? container.decode(FunctionOperand.self)
        self.keywordOperand = try? container.decode(KeywordOperand.self)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        if let value = listOperand { try container.encode(value) }
        if let value = valueOperand { try container.encode(value) }
        if let value = functionOperand { try container.encode(value) }
        if let value = keywordOperand { try container.encode(value) }
    }
}

/// A time predicate for a temporal JQL clause.
public struct JqlQueryClauseTimePredicate: Codable {
    /// The operator between the field and the operand.
    public var `operator`: Operator
    /// Details of an operand in a JQL clause.
    public var operand: JqlQueryClauseOperand

    /// The operator between the field and the operand.
    public enum Operator: String, Codable, CaseIterable {
        case before
        case after
        case from
        case to
        case on
        case during
        case by
    }

    public init(`operator`: Operator, operand: JqlQueryClauseOperand) {
        self.operator = `operator`
        self.operand = operand
    }

    private enum CodingKeys: String, CodingKey {
        case `operator` = "operator"
        case operand
    }
}

/// A field used in a JQL query. See [Advanced searching - fields reference](https://confluence.atlassian.com/x/dAiiLQ) for more information about fields in JQL queries.
public struct JqlQueryField: Codable {
    /// The name of the field.
    public var name: String
    /// When the field refers to a value in an entity property, details of the entity property value.
    public var property: [JqlQueryFieldEntityProperty]?

    public init(name: String, property: [JqlQueryFieldEntityProperty]? = nil) {
        self.name = name
        self.property = property
    }
}

/// Details of an entity property.
public struct JqlQueryFieldEntityProperty: Codable {
    /// The object on which the property is set.
    ///
    /// Example: "issue"
    public var entity: String
    /// The key of the property.
    ///
    /// Example: "stats"
    public var key: String
    /// The path in the property value to query.
    ///
    /// Example: "comments.count"
    public var path: String
    /// The type of the property value extraction. Not available if the extraction for the property is not registered on the instance with the [Entity property](https://developer.atlassian.com/cloud/jira/platform/modules/entity-property/) module.
    ///
    /// Example: "number"
    public var type: `Type`?

    /// The type of the property value extraction. Not available if the extraction for the property is not registered on the instance with the [Entity property](https://developer.atlassian.com/cloud/jira/platform/modules/entity-property/) module.
    ///
    /// Example: "number"
    public enum `Type`: String, Codable, CaseIterable {
        case number
        case string
        case text
        case date
        case user
    }

    public init(entity: String, key: String, path: String, type: `Type`? = nil) {
        self.entity = entity
        self.key = key
        self.path = path
        self.type = type
    }
}

/// Details of the order-by JQL clause.
public struct JqlQueryOrderByClause: Codable {
    /// The list of order-by clause fields and their ordering directives.
    public var fields: [JqlQueryOrderByClauseElement]

    public init(fields: [JqlQueryOrderByClauseElement]) {
        self.fields = fields
    }
}

/// An element of the order-by JQL clause.
public struct JqlQueryOrderByClauseElement: Codable {
    /// A field used in a JQL query. See [Advanced searching - fields reference](https://confluence.atlassian.com/x/dAiiLQ) for more information about fields in JQL queries.
    public var field: JqlQueryField
    /// The direction in which to order the results.
    public var direction: Direction?

    /// The direction in which to order the results.
    public enum Direction: String, Codable, CaseIterable {
        case asc
        case desc
    }

    public init(field: JqlQueryField, direction: Direction? = nil) {
        self.field = field
        self.direction = direction
    }
}

/// An operand that can be part of a list operand.
public struct JqlQueryUnitaryOperand: Codable {
    /// An operand that is a user-provided value.
    public var valueOperand: ValueOperand?
    /// An operand that is a function. See [Advanced searching - functions reference](https://confluence.atlassian.com/x/dwiiLQ) for more information about JQL functions.
    public var functionOperand: FunctionOperand?
    /// An operand that is a JQL keyword. See [Advanced searching - keywords reference](https://confluence.atlassian.com/jiracorecloud/advanced-searching-keywords-reference-765593717.html#Advancedsearching-keywordsreference-EMPTYEMPTY) for more information about operand keywords.
    public var keywordOperand: KeywordOperand?

    public init(valueOperand: ValueOperand? = nil, functionOperand: FunctionOperand? = nil, keywordOperand: KeywordOperand? = nil) {
        self.valueOperand = valueOperand
        self.functionOperand = functionOperand
        self.keywordOperand = keywordOperand
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        self.valueOperand = try? container.decode(ValueOperand.self)
        self.functionOperand = try? container.decode(FunctionOperand.self)
        self.keywordOperand = try? container.decode(KeywordOperand.self)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        if let value = valueOperand { try container.encode(value) }
        if let value = functionOperand { try container.encode(value) }
        if let value = keywordOperand { try container.encode(value) }
    }
}

/// An operand that is a JQL keyword. See [Advanced searching - keywords reference](https://confluence.atlassian.com/jiracorecloud/advanced-searching-keywords-reference-765593717.html#Advancedsearching-keywordsreference-EMPTYEMPTY) for more information about operand keywords.
public struct KeywordOperand: Codable {
    /// The keyword that is the operand value.
    public var keyword: Keyword

    /// The keyword that is the operand value.
    public enum Keyword: String, Codable, CaseIterable {
        case empty
    }

    public init(keyword: Keyword) {
        self.keyword = keyword
    }
}

/// An operand that is a list of values.
public struct ListOperand: Codable {
    /// The list of operand values.
    public var values: String

    public init(values: String) {
        self.values = values
    }
}

/// A list of parsed JQL queries.
public struct ParsedJqlQueries: Codable {
    /// A list of parsed JQL queries.
    public var queries: String

    public init(queries: String) {
        self.queries = queries
    }
}

/// An operand that is a user-provided value.
public struct ValueOperand: Codable {
    /// The operand value.
    public var value: String

    public init(value: String) {
        self.value = value
    }
}

/// Error messages from an operation.
public struct ErrorCollection: Codable {
    /// The list of error messages produced by this operation. For example, "input parameter 'key' must be provided"
    public var errorMessages: [String]?
    /// The list of errors by parameter returned by the operation. For example,"projectKey": "Project keys must start with an uppercase letter, followed by one or more uppercase alphanumeric characters."
    public var errors: [String: String]?
    public var status: Int?

    public init(errorMessages: [String]? = nil, errors: [String: String]? = nil, status: Int? = nil) {
        self.errorMessages = errorMessages
        self.errors = errors
        self.status = status
    }
}

/// Details of an issue navigator column item.
public struct ColumnItem: Codable {
    /// The issue navigator column label.
    public var label: String?
    /// The issue navigator column value.
    public var value: String?

    public init(label: String? = nil, value: String? = nil) {
        self.label = label
        self.value = value
    }
}

/// Details about a license for the Jira instance.
public struct License: Codable {
    /// The applications under this license.
    public var applications: [LicensedApplication]

    public init(applications: [LicensedApplication]) {
        self.applications = applications
    }
}

/// Details about a licensed Jira application.
public struct LicensedApplication: Codable {
    /// The ID of the application.
    public var id: String
    /// The licensing plan.
    public var plan: Plan

    /// The licensing plan.
    public enum Plan: String, Codable, CaseIterable {
        case unlicensed = "UNLICENSED"
        case free = "FREE"
        case paid = "PAID"
    }

    public init(id: String, plan: Plan) {
        self.id = id
        self.plan = plan
    }
}

/// Details about an issue event.
public struct IssueEvent: Codable {
    /// The ID of the event.
    public var id: Int?
    /// The name of the event.
    public var name: String?

    public init(id: Int? = nil, name: String? = nil) {
        self.id = id
        self.name = name
    }
}

/// Details about the configuration of Jira.
public struct Configuration: Codable {
    /// Whether the ability for users to vote on issues is enabled. See [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM) for details.
    public var isVotingEnabled: Bool?
    /// Whether the ability for users to watch issues is enabled. See [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM) for details.
    public var isWatchingEnabled: Bool?
    /// Whether the ability to create unassigned issues is enabled. See [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM) for details.
    public var isUnassignedIssuesAllowed: Bool?
    /// Whether the ability to create subtasks for issues is enabled.
    public var isSubTasksEnabled: Bool?
    /// Whether the ability to link issues is enabled.
    public var isIssueLinkingEnabled: Bool?
    /// Whether the ability to track time is enabled. This property is deprecated.
    public var isTimeTrackingEnabled: Bool?
    /// Whether the ability to add attachments to issues is enabled.
    public var isAttachmentsEnabled: Bool?
    /// The configuration of time tracking.
    public var timeTrackingConfiguration: TimeTrackingConfiguration?

    public init(isVotingEnabled: Bool? = nil, isWatchingEnabled: Bool? = nil, isUnassignedIssuesAllowed: Bool? = nil, isSubTasksEnabled: Bool? = nil, isIssueLinkingEnabled: Bool? = nil, isTimeTrackingEnabled: Bool? = nil, isAttachmentsEnabled: Bool? = nil, timeTrackingConfiguration: TimeTrackingConfiguration? = nil) {
        self.isVotingEnabled = isVotingEnabled
        self.isWatchingEnabled = isWatchingEnabled
        self.isUnassignedIssuesAllowed = isUnassignedIssuesAllowed
        self.isSubTasksEnabled = isSubTasksEnabled
        self.isIssueLinkingEnabled = isIssueLinkingEnabled
        self.isTimeTrackingEnabled = isTimeTrackingEnabled
        self.isAttachmentsEnabled = isAttachmentsEnabled
        self.timeTrackingConfiguration = timeTrackingConfiguration
    }

    private enum CodingKeys: String, CodingKey {
        case isVotingEnabled = "votingEnabled"
        case isWatchingEnabled = "watchingEnabled"
        case isUnassignedIssuesAllowed = "unassignedIssuesAllowed"
        case isSubTasksEnabled = "subTasksEnabled"
        case isIssueLinkingEnabled = "issueLinkingEnabled"
        case isTimeTrackingEnabled = "timeTrackingEnabled"
        case isAttachmentsEnabled = "attachmentsEnabled"
        case timeTrackingConfiguration
    }
}

/// Details of the time tracking configuration.
public struct TimeTrackingConfiguration: Codable {
    /// The number of hours in a working day.
    public var workingHoursPerDay: Double
    /// The number of days in a working week.
    public var workingDaysPerWeek: Double
    /// The format that will appear on an issue's *Time Spent* field.
    public var timeFormat: TimeFormat
    /// The default unit of time applied to logged time.
    public var defaultUnit: DefaultUnit

    /// The format that will appear on an issue's *Time Spent* field.
    public enum TimeFormat: String, Codable, CaseIterable {
        case pretty
        case days
        case hours
    }

    /// The default unit of time applied to logged time.
    public enum DefaultUnit: String, Codable, CaseIterable {
        case minute
        case hour
        case day
        case week
    }

    public init(workingHoursPerDay: Double, workingDaysPerWeek: Double, timeFormat: TimeFormat, defaultUnit: DefaultUnit) {
        self.workingHoursPerDay = workingHoursPerDay
        self.workingDaysPerWeek = workingDaysPerWeek
        self.timeFormat = timeFormat
        self.defaultUnit = defaultUnit
    }
}

/// Details of an application property.
public struct ApplicationProperty: Codable {
    /// The ID of the application property. The ID and key are the same.
    public var id: String?
    /// The key of the application property. The ID and key are the same.
    public var key: String?
    /// The new value.
    public var value: String?
    /// The name of the application property.
    public var name: String?
    /// The description of the application property.
    public var desc: String?
    /// The data type of the application property.
    public var type: String?
    /// The default value of the application property.
    public var defaultValue: String?
    public var example: String?
    /// The allowed values, if applicable.
    public var allowedValues: [String]?

    public init(id: String? = nil, key: String? = nil, value: String? = nil, name: String? = nil, desc: String? = nil, type: String? = nil, defaultValue: String? = nil, example: String? = nil, allowedValues: [String]? = nil) {
        self.id = id
        self.key = key
        self.value = value
        self.name = name
        self.desc = desc
        self.type = type
        self.defaultValue = defaultValue
        self.example = example
        self.allowedValues = allowedValues
    }
}

public struct SimpleApplicationPropertyBean: Codable {
    /// The ID of the application property.
    public var id: String?
    /// The new value.
    public var value: String?

    public init(id: String? = nil, value: String? = nil) {
        self.id = id
        self.value = value
    }
}

/// Details of an application role.
public struct ApplicationRole: Codable {
    /// The key of the application role.
    public var key: String?
    /// The groups associated with the application role.
    public var groups: [String]?
    /// The display name of the application role.
    public var name: String?
    /// The groups that are granted default access for this application role.
    public var defaultGroups: [String]?
    /// Determines whether this application role should be selected by default on user creation.
    public var isSelectedByDefault: Bool?
    /// Deprecated.
    public var isDefined: Bool?
    /// The maximum count of users on your license.
    public var numberOfSeats: Int?
    /// The count of users remaining on your license.
    public var remainingSeats: Int?
    /// The number of users counting against your license.
    public var userCount: Int?
    /// The [type of users](https://confluence.atlassian.com/x/lRW3Ng) being counted against your license.
    public var userCountDescription: String?
    public var hasUnlimitedSeats: Bool?
    /// Indicates if the application role belongs to Jira platform (`jira-core`).
    public var isPlatform: Bool?

    public init(key: String? = nil, groups: [String]? = nil, name: String? = nil, defaultGroups: [String]? = nil, isSelectedByDefault: Bool? = nil, isDefined: Bool? = nil, numberOfSeats: Int? = nil, remainingSeats: Int? = nil, userCount: Int? = nil, userCountDescription: String? = nil, hasUnlimitedSeats: Bool? = nil, isPlatform: Bool? = nil) {
        self.key = key
        self.groups = groups
        self.name = name
        self.defaultGroups = defaultGroups
        self.isSelectedByDefault = isSelectedByDefault
        self.isDefined = isDefined
        self.numberOfSeats = numberOfSeats
        self.remainingSeats = remainingSeats
        self.userCount = userCount
        self.userCountDescription = userCountDescription
        self.hasUnlimitedSeats = hasUnlimitedSeats
        self.isPlatform = isPlatform
    }

    private enum CodingKeys: String, CodingKey {
        case key
        case groups
        case name
        case defaultGroups
        case isSelectedByDefault = "selectedByDefault"
        case isDefined = "defined"
        case numberOfSeats
        case remainingSeats
        case userCount
        case userCountDescription
        case hasUnlimitedSeats
        case isPlatform = "platform"
    }
}

public struct AvatarURLsBean: Codable {
    /// The URL of the item's 16x16 pixel avatar.
    public var _16x16: URL?
    /// The URL of the item's 24x24 pixel avatar.
    public var _24x24: URL?
    /// The URL of the item's 32x32 pixel avatar.
    public var _32x32: URL?
    /// The URL of the item's 48x48 pixel avatar.
    public var _48x48: URL?

    public init(_16x16: URL? = nil, _24x24: URL? = nil, _32x32: URL? = nil, _48x48: URL? = nil) {
        self._16x16 = _16x16
        self._24x24 = _24x24
        self._32x32 = _32x32
        self._48x48 = _48x48
    }

    private enum CodingKeys: String, CodingKey {
        case _16x16 = "16x16"
        case _24x24 = "24x24"
        case _32x32 = "32x32"
        case _48x48 = "48x48"
    }
}

/// Details about a group name.
public struct GroupName: Codable {
    /// The name of group.
    public var name: String?
    /// The URL for these group details.
    public var this: URL?

    public init(name: String? = nil, this: URL? = nil) {
        self.name = name
        self.this = this
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case this = "self"
    }
}

/// Details about an issue type.
public struct IssueTypeDetails: Codable {
    /// The URL of these issue type details.
    public var this: String?
    /// The ID of the issue type.
    public var id: String?
    /// The description of the issue type.
    public var description: String?
    /// The URL of the issue type's avatar.
    public var iconURL: String?
    /// The name of the issue type.
    public var name: String?
    /// Whether this issue type is used to create subtasks.
    public var isSubtask: Bool?
    /// The ID of the issue type's avatar.
    public var avatarID: Int?
    /// Unique ID for next-gen projects.
    public var entityID: String?
    /// Hierarchy level of the issue type.
    public var hierarchyLevel: Int?
    /// Details of the next-gen projects the issue type is available in.
    public var scope: Scope?

    public init(this: String? = nil, id: String? = nil, description: String? = nil, iconURL: String? = nil, name: String? = nil, isSubtask: Bool? = nil, avatarID: Int? = nil, entityID: String? = nil, hierarchyLevel: Int? = nil, scope: Scope? = nil) {
        self.this = this
        self.id = id
        self.description = description
        self.iconURL = iconURL
        self.name = name
        self.isSubtask = isSubtask
        self.avatarID = avatarID
        self.entityID = entityID
        self.hierarchyLevel = hierarchyLevel
        self.scope = scope
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case id
        case description
        case iconURL = "iconUrl"
        case name
        case isSubtask = "subtask"
        case avatarID = "avatarId"
        case entityID = "entityId"
        case hierarchyLevel
        case scope
    }
}

public struct ListWrapperCallbackApplicationRole: Codable {
    public init() {}
}

public struct ListWrapperCallbackGroupName: Codable {
    public init() {}
}

/// A page of items.
public struct PageBeanWorkflowScheme: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [WorkflowScheme]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [WorkflowScheme]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// Details about a project.
public struct ProjectDetails: Codable {
    /// The URL of the project details.
    public var this: String?
    /// The ID of the project.
    public var id: String?
    /// The key of the project.
    public var key: String?
    /// The name of the project.
    public var name: String?
    /// The [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes) of the project.
    public var projectTypeKey: ProjectTypeKey?
    /// Whether or not the project is simplified.
    public var isSimplified: Bool?
    /// The URLs of the project's avatars.
    public var avatarURLs: AvatarURLsBean?
    /// The category the project belongs to.
    public var projectCategory: UpdatedProjectCategory?

    /// The [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes) of the project.
    public enum ProjectTypeKey: String, Codable, CaseIterable {
        case software
        case serviceDesk = "service_desk"
        case business
    }

    public init(this: String? = nil, id: String? = nil, key: String? = nil, name: String? = nil, projectTypeKey: ProjectTypeKey? = nil, isSimplified: Bool? = nil, avatarURLs: AvatarURLsBean? = nil, projectCategory: UpdatedProjectCategory? = nil) {
        self.this = this
        self.id = id
        self.key = key
        self.name = name
        self.projectTypeKey = projectTypeKey
        self.isSimplified = isSimplified
        self.avatarURLs = avatarURLs
        self.projectCategory = projectCategory
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case id
        case key
        case name
        case projectTypeKey
        case isSimplified = "simplified"
        case avatarURLs = "avatarUrls"
        case projectCategory
    }
}

/// The projects the item is associated with. Indicated for items associated with [next-gen projects](https://confluence.atlassian.com/x/loMyO).
public struct Scope: Codable {
    /// The type of scope.
    public var type: `Type`?
    /// The project the item has scope in.
    public var project: ProjectDetails?

    /// The type of scope.
    public enum `Type`: String, Codable, CaseIterable {
        case project = "PROJECT"
        case template = "TEMPLATE"
    }

    public init(type: `Type`? = nil, project: ProjectDetails? = nil) {
        self.type = type
        self.project = project
    }
}

public struct SimpleListWrapperApplicationRole: Codable {
    public var size: Int?
    public var items: [ApplicationRole]?
    public var maxResults: Int?

    public init(size: Int? = nil, items: [ApplicationRole]? = nil, maxResults: Int? = nil) {
        self.size = size
        self.items = items
        self.maxResults = maxResults
    }

    private enum CodingKeys: String, CodingKey {
        case size
        case items
        case maxResults = "max-results"
    }
}

public struct SimpleListWrapperGroupName: Codable {
    public var size: Int?
    public var items: [GroupName]?
    public var maxResults: Int?

    public init(size: Int? = nil, items: [GroupName]? = nil, maxResults: Int? = nil) {
        self.size = size
        self.items = items
        self.maxResults = maxResults
    }

    private enum CodingKeys: String, CodingKey {
        case size
        case items
        case maxResults = "max-results"
    }
}

/// A project category.
public struct UpdatedProjectCategory: Codable {
    /// The URL of the project category.
    public var this: String?
    /// The ID of the project category.
    public var id: String?
    /// The name of the project category.
    public var description: String?
    /// The description of the project category.
    public var name: String?

    public init(this: String? = nil, id: String? = nil, description: String? = nil, name: String? = nil) {
        self.this = this
        self.id = id
        self.description = description
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case id
        case description
        case name
    }
}

/// A user with details as permitted by the user's Atlassian Account privacy settings. However, be aware of these exceptions:
/// 
///  *  User record deleted from Atlassian: This occurs as the result of a right to be forgotten request. In this case, `displayName` provides an indication and other parameters have default values or are blank (for example, email is blank).
///  *  User record corrupted: This occurs as a results of events such as a server import and can only happen to deleted users. In this case, `accountId` returns *unknown* and all other parameters have fallback values.
///  *  User record unavailable: This usually occurs due to an internal service outage. In this case, all parameters have fallback values.
public struct User: Codable {
    /// The URL of the user.
    public var this: URL?
    /// This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
    public var key: String?
    /// The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. Required in requests.
    public var accountID: String?
    /// The user account type. Can take the following values:
    /// 
    ///  *  `atlassian` regular Atlassian user account
    ///  *  `app` system account used for Connect applications and OAuth to represent external systems
    ///  *  `customer` Jira Service Desk account representing an external service desk
    public var accountType: AccountType?
    /// This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
    public var name: String?
    /// The email address of the user. Depending on the user’s privacy setting, this may be returned as null.
    public var emailAddress: String?
    /// The avatars of the user.
    public var avatarURLs: AvatarURLsBean?
    /// The display name of the user. Depending on the user’s privacy setting, this may return an alternative value.
    public var displayName: String?
    /// Whether the user is active.
    public var isActive: Bool?
    /// The time zone specified in the user's profile. Depending on the user’s privacy setting, this may be returned as null.
    public var timeZone: String?
    /// The locale of the user. Depending on the user’s privacy setting, this may be returned as null.
    public var locale: String?
    /// The groups that the user belongs to.
    public var groups: SimpleListWrapperGroupName?
    /// The application roles the user is assigned to.
    public var applicationRoles: SimpleListWrapperApplicationRole?
    /// Expand options that include additional user details in the response.
    public var expand: String?

    /// The user account type. Can take the following values:
    /// 
    ///  *  `atlassian` regular Atlassian user account
    ///  *  `app` system account used for Connect applications and OAuth to represent external systems
    ///  *  `customer` Jira Service Desk account representing an external service desk
    public enum AccountType: String, Codable, CaseIterable {
        case atlassian
        case app
        case customer
        case unknown
    }

    public init(this: URL? = nil, key: String? = nil, accountID: String? = nil, accountType: AccountType? = nil, name: String? = nil, emailAddress: String? = nil, avatarURLs: AvatarURLsBean? = nil, displayName: String? = nil, isActive: Bool? = nil, timeZone: String? = nil, locale: String? = nil, groups: SimpleListWrapperGroupName? = nil, applicationRoles: SimpleListWrapperApplicationRole? = nil, expand: String? = nil) {
        self.this = this
        self.key = key
        self.accountID = accountID
        self.accountType = accountType
        self.name = name
        self.emailAddress = emailAddress
        self.avatarURLs = avatarURLs
        self.displayName = displayName
        self.isActive = isActive
        self.timeZone = timeZone
        self.locale = locale
        self.groups = groups
        self.applicationRoles = applicationRoles
        self.expand = expand
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case key
        case accountID = "accountId"
        case accountType
        case name
        case emailAddress
        case avatarURLs = "avatarUrls"
        case displayName
        case isActive = "active"
        case timeZone
        case locale
        case groups
        case applicationRoles
        case expand
    }
}

/// Details about a workflow scheme.
public struct WorkflowScheme: Codable {
    /// The ID of the workflow scheme.
    public var id: Int?
    /// The name of the workflow scheme. The name must be unique. The maximum length is 255 characters. Required when creating a workflow scheme.
    public var name: String?
    /// The description of the workflow scheme.
    public var description: String?
    /// The name of the default workflow for the workflow scheme. The default workflow has *All Unassigned Issue Types* assigned to it in Jira. If `defaultWorkflow` is not specified when creating a workflow scheme, it is set to *Jira Workflow (jira)*.
    public var defaultWorkflow: String?
    /// The issue type to workflow mappings, where each mapping is an issue type ID and workflow name pair. Note that an issue type can only be mapped to one workflow in a workflow scheme.
    public var issueTypeMappings: [String: String]?
    /// For draft workflow schemes, this property is the name of the default workflow for the original workflow scheme. The default workflow has *All Unassigned Issue Types* assigned to it in Jira.
    public var originalDefaultWorkflow: String?
    /// For draft workflow schemes, this property is the issue type to workflow mappings for the original workflow scheme, where each mapping is an issue type ID and workflow name pair. Note that an issue type can only be mapped to one workflow in a workflow scheme.
    public var originalIssueTypeMappings: [String: String]?
    /// Whether the workflow scheme is a draft or not.
    public var isDraft: Bool?
    /// The user that last modified the draft workflow scheme. A modification is a change to the issue type-project mappings only. This property does not apply to non-draft workflows.
    public var lastModifiedUser: User?
    /// The date-time that the draft workflow scheme was last modified. A modification is a change to the issue type-project mappings only. This property does not apply to non-draft workflows.
    public var lastModified: String?
    public var this: URL?
    /// Whether to create or update a draft workflow scheme when updating an active workflow scheme. An active workflow scheme is a workflow scheme that is used by at least one project. The following examples show how this property works:
    /// 
    ///  *  Update an active workflow scheme with `updateDraftIfNeeded` set to `true`: If a draft workflow scheme exists, it is updated. Otherwise, a draft workflow scheme is created.
    ///  *  Update an active workflow scheme with `updateDraftIfNeeded` set to `false`: An error is returned, as active workflow schemes cannot be updated.
    ///  *  Update an inactive workflow scheme with `updateDraftIfNeeded` set to `true`: The workflow scheme is updated, as inactive workflow schemes do not require drafts to update.
    /// 
    /// Defaults to `false`.
    public var isUpdateDraftIfNeeded: Bool?
    /// The issue types available in Jira.
    public var issueTypes: [String: IssueTypeDetails]?

    public init(id: Int? = nil, name: String? = nil, description: String? = nil, defaultWorkflow: String? = nil, issueTypeMappings: [String: String]? = nil, originalDefaultWorkflow: String? = nil, originalIssueTypeMappings: [String: String]? = nil, isDraft: Bool? = nil, lastModifiedUser: User? = nil, lastModified: String? = nil, this: URL? = nil, isUpdateDraftIfNeeded: Bool? = nil, issueTypes: [String: IssueTypeDetails]? = nil) {
        self.id = id
        self.name = name
        self.description = description
        self.defaultWorkflow = defaultWorkflow
        self.issueTypeMappings = issueTypeMappings
        self.originalDefaultWorkflow = originalDefaultWorkflow
        self.originalIssueTypeMappings = originalIssueTypeMappings
        self.isDraft = isDraft
        self.lastModifiedUser = lastModifiedUser
        self.lastModified = lastModified
        self.this = this
        self.isUpdateDraftIfNeeded = isUpdateDraftIfNeeded
        self.issueTypes = issueTypes
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case description
        case defaultWorkflow
        case issueTypeMappings
        case originalDefaultWorkflow
        case originalIssueTypeMappings
        case isDraft = "draft"
        case lastModifiedUser
        case lastModified
        case this = "self"
        case isUpdateDraftIfNeeded = "updateDraftIfNeeded"
        case issueTypes
    }
}

/// Details about the mapping between issue types and a workflow.
public struct IssueTypesWorkflowMapping: Codable {
    /// The name of the workflow. Optional if updating the workflow-issue types mapping.
    public var workflow: String?
    /// The list of issue type IDs.
    public var issueTypes: [String]?
    /// Whether the workflow is the default workflow for the workflow scheme.
    public var isDefaultMapping: Bool?
    /// Whether a draft workflow scheme is created or updated when updating an active workflow scheme. The draft is updated with the new workflow-issue types mapping. Defaults to `false`.
    public var isUpdateDraftIfNeeded: Bool?

    public init(workflow: String? = nil, issueTypes: [String]? = nil, isDefaultMapping: Bool? = nil, isUpdateDraftIfNeeded: Bool? = nil) {
        self.workflow = workflow
        self.issueTypes = issueTypes
        self.isDefaultMapping = isDefaultMapping
        self.isUpdateDraftIfNeeded = isUpdateDraftIfNeeded
    }

    private enum CodingKeys: String, CodingKey {
        case workflow
        case issueTypes
        case isDefaultMapping = "defaultMapping"
        case isUpdateDraftIfNeeded = "updateDraftIfNeeded"
    }
}

/// Details about the mapping between an issue type and a workflow.
public struct IssueTypeWorkflowMapping: Codable {
    /// The ID of the issue type. Not required if updating the issue type-workflow mapping.
    public var issueType: String?
    /// The name of the workflow.
    public var workflow: String?
    /// Set to true to create or update the draft of a workflow scheme and update the mapping in the draft, when the workflow scheme cannot be edited. Defaults to `false`. Only applicable when updating the workflow-issue types mapping.
    public var isUpdateDraftIfNeeded: Bool?

    public init(issueType: String? = nil, workflow: String? = nil, isUpdateDraftIfNeeded: Bool? = nil) {
        self.issueType = issueType
        self.workflow = workflow
        self.isUpdateDraftIfNeeded = isUpdateDraftIfNeeded
    }

    private enum CodingKeys: String, CodingKey {
        case issueType
        case workflow
        case isUpdateDraftIfNeeded = "updateDraftIfNeeded"
    }
}

/// Details about the default workflow.
public struct DefaultWorkflow: Codable {
    /// The name of the workflow to set as the default workflow.
    public var workflow: String
    /// Whether a draft workflow scheme is created or updated when updating an active workflow scheme. The draft is updated with the new default workflow. Defaults to `false`.
    public var isUpdateDraftIfNeeded: Bool?

    public init(workflow: String, isUpdateDraftIfNeeded: Bool? = nil) {
        self.workflow = workflow
        self.isUpdateDraftIfNeeded = isUpdateDraftIfNeeded
    }

    private enum CodingKeys: String, CodingKey {
        case workflow
        case isUpdateDraftIfNeeded = "updateDraftIfNeeded"
    }
}

/// Details about the status mappings for publishing a draft workflow scheme.
public struct PublishDraftWorkflowScheme: Codable {
    /// Mappings of statuses to new statuses for issue types.
    public var statusMappings: [StatusMapping]?

    public init(statusMappings: [StatusMapping]? = nil) {
        self.statusMappings = statusMappings
    }
}

/// Details about the mapping from a status to a new status for an issue type.
public struct StatusMapping: Codable {
    /// The ID of the issue type.
    public var issueTypeID: String
    /// The ID of the status.
    public var statusID: String
    /// The ID of the new status.
    public var newStatusID: String

    public init(issueTypeID: String, statusID: String, newStatusID: String) {
        self.issueTypeID = issueTypeID
        self.statusID = statusID
        self.newStatusID = newStatusID
    }

    private enum CodingKeys: String, CodingKey {
        case issueTypeID = "issueTypeId"
        case statusID = "statusId"
        case newStatusID = "newStatusId"
    }
}

/// Details about a task.
public struct TaskProgressBeanObject: Codable {
    /// The URL of the task.
    public var this: URL
    /// The ID of the task.
    public var id: String
    /// The description of the task.
    public var description: String?
    /// The status of the task.
    public var status: Status
    /// Information about the progress of the task.
    public var message: String?
    /// The result of the task execution.
    public var result: AnyJSON?
    /// The ID of the user who submitted the task.
    public var submittedBy: Int
    /// The progress of the task, as a percentage complete.
    public var progress: Int
    /// The execution time of the task, in milliseconds.
    public var elapsedRuntime: Int
    /// A timestamp recording when the task was submitted.
    public var submitted: Int
    /// A timestamp recording when the task was started.
    public var started: Int?
    /// A timestamp recording when the task was finished.
    public var finished: Int?
    /// A timestamp recording when the task progress was last updated.
    public var lastUpdate: Int

    /// The status of the task.
    public enum Status: String, Codable, CaseIterable {
        case enqueued = "ENQUEUED"
        case running = "RUNNING"
        case complete = "COMPLETE"
        case failed = "FAILED"
        case cancelRequested = "CANCEL_REQUESTED"
        case cancelled = "CANCELLED"
        case dead = "DEAD"
    }

    public init(this: URL, id: String, description: String? = nil, status: Status, message: String? = nil, result: AnyJSON? = nil, submittedBy: Int, progress: Int, elapsedRuntime: Int, submitted: Int, started: Int? = nil, finished: Int? = nil, lastUpdate: Int) {
        self.this = this
        self.id = id
        self.description = description
        self.status = status
        self.message = message
        self.result = result
        self.submittedBy = submittedBy
        self.progress = progress
        self.elapsedRuntime = elapsedRuntime
        self.submitted = submitted
        self.started = started
        self.finished = finished
        self.lastUpdate = lastUpdate
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case id
        case description
        case status
        case message
        case result
        case submittedBy
        case progress
        case elapsedRuntime
        case submitted
        case started
        case finished
        case lastUpdate
    }
}

/// A container for a list of workflow schemes together with the projects they are associated with.
public struct ContainerOfWorkflowSchemeAssociations: Codable {
    /// A list of workflow schemes together with projects they are associated with.
    public var values: [WorkflowSchemeAssociations]

    public init(values: [WorkflowSchemeAssociations]) {
        self.values = values
    }
}

/// A workflow scheme along with a list of projects that use it.
public struct WorkflowSchemeAssociations: Codable {
    /// The list of projects that use the workflow scheme.
    public var projectIDs: [String]
    /// The workflow scheme.
    public var workflowScheme: WorkflowScheme

    public init(projectIDs: [String], workflowScheme: WorkflowScheme) {
        self.projectIDs = projectIDs
        self.workflowScheme = workflowScheme
    }

    private enum CodingKeys: String, CodingKey {
        case projectIDs = "projectIds"
        case workflowScheme
    }
}

/// An associated workflow scheme and project.
public struct WorkflowSchemeProjectAssociation: Codable {
    /// The ID of the workflow scheme. If the workflow scheme ID is `null`, the operation assigns the default workflow scheme.
    public var workflowSchemeID: String?
    /// The ID of the project.
    public var projectID: String

    public init(workflowSchemeID: String? = nil, projectID: String) {
        self.workflowSchemeID = workflowSchemeID
        self.projectID = projectID
    }

    private enum CodingKeys: String, CodingKey {
        case workflowSchemeID = "workflowSchemeId"
        case projectID = "projectId"
    }
}

/// Details about a permission granted to a user or group.
public struct PermissionGrant: Codable {
    /// The ID of the permission granted details.
    public var id: Int?
    /// The URL of the permission granted details.
    public var this: URL?
    /// The user or group being granted the permission. It consists of a `type` and a type-dependent `parameter`. See [Holder object](../api-group-permission-schemes/#holder-object) in *Get all permission schemes* for more information.
    public var holder: PermissionHolder?
    /// The permission to grant. This permission can be one of the built-in permissions or a custom permission added by an app. See [Built-in permissions](../api-group-permission-schemes/#built-in-permissions) in *Get all permission schemes* for more information about the built-in permissions. See the [project permission](https://developer.atlassian.com/cloud/jira/platform/modules/project-permission/) and [global permission](https://developer.atlassian.com/cloud/jira/platform/modules/global-permission/) module documentation for more information about custom permissions.
    public var permission: String?

    public init(id: Int? = nil, this: URL? = nil, holder: PermissionHolder? = nil, permission: String? = nil) {
        self.id = id
        self.this = this
        self.holder = holder
        self.permission = permission
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case this = "self"
        case holder
        case permission
    }
}

/// Details of a user, group, field, or project role that holds a permission. See [Holder object](../api-group-permission-schemes/#holder-object) in *Get all permission schemes* for more information.
public struct PermissionHolder: Codable {
    /// The type of permission holder.
    public var type: String
    /// The identifier of permission holder.
    public var parameter: String?
    /// Expand options that include additional permission holder details in the response.
    public var expand: String?

    public init(type: String, parameter: String? = nil, expand: String? = nil) {
        self.type = type
        self.parameter = parameter
        self.expand = expand
    }
}

/// Details of a permission scheme.
public struct PermissionScheme: Codable {
    /// The expand options available for the permission scheme.
    public var expand: String?
    /// The ID of the permission scheme.
    public var id: Int?
    /// The URL of the permission scheme.
    public var this: URL?
    /// The name of the permission scheme. Must be unique.
    public var name: String
    /// A description for the permission scheme.
    public var description: String?
    /// The scope of the permission scheme.
    public var scope: Scope?
    /// The permission scheme to create or update. See [About permission schemes and grants](../api-group-permission-schemes/#about-permission-schemes-and-grants) for more information.
    public var permissions: [PermissionGrant]?

    public init(expand: String? = nil, id: Int? = nil, this: URL? = nil, name: String, description: String? = nil, scope: Scope? = nil, permissions: [PermissionGrant]? = nil) {
        self.expand = expand
        self.id = id
        self.this = this
        self.name = name
        self.description = description
        self.scope = scope
        self.permissions = permissions
    }

    private enum CodingKeys: String, CodingKey {
        case expand
        case id
        case this = "self"
        case name
        case description
        case scope
        case permissions
    }
}

/// List of all permission schemes.
public struct PermissionSchemes: Codable {
    /// Permission schemes list.
    public var permissionSchemes: [PermissionScheme]?

    public init(permissionSchemes: [PermissionScheme]? = nil) {
        self.permissionSchemes = permissionSchemes
    }
}

/// List of permission grants.
public struct PermissionGrants: Codable {
    /// Permission grants list.
    public var permissions: [PermissionGrant]?
    /// Expand options that include additional permission grant details in the response.
    public var expand: String?

    public init(permissions: [PermissionGrant]? = nil, expand: String? = nil) {
        self.permissions = permissions
        self.expand = expand
    }
}

/// Details about a workflow.
public struct DeprecatedWorkflow: Codable {
    /// The name of the workflow.
    public var name: String?
    /// The description of the workflow.
    public var description: String?
    /// The datetime the workflow was last modified.
    public var lastModifiedDate: String?
    /// This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
    public var lastModifiedUser: String?
    /// The account ID of the user that last modified the workflow.
    public var lastModifiedUserAccountID: String?
    /// The number of steps included in the workflow.
    public var steps: Int?
    /// The scope where this workflow applies
    public var scope: Scope?
    public var isDefault: Bool?

    public init(name: String? = nil, description: String? = nil, lastModifiedDate: String? = nil, lastModifiedUser: String? = nil, lastModifiedUserAccountID: String? = nil, steps: Int? = nil, scope: Scope? = nil, isDefault: Bool? = nil) {
        self.name = name
        self.description = description
        self.lastModifiedDate = lastModifiedDate
        self.lastModifiedUser = lastModifiedUser
        self.lastModifiedUserAccountID = lastModifiedUserAccountID
        self.steps = steps
        self.scope = scope
        self.isDefault = isDefault
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case description
        case lastModifiedDate
        case lastModifiedUser
        case lastModifiedUserAccountID = "lastModifiedUserAccountId"
        case steps
        case scope
        case isDefault = "default"
    }
}

/// A workflow transition condition.
public struct CreateWorkflowCondition: Codable {
    /// The compound condition operator.
    public var `operator`: Operator?
    /// The list of workflow conditions.
    public var conditions: [CreateWorkflowCondition]?
    /// The type of the transition rule.
    public var type: String?
    /// EXPERIMENTAL. The configuration of the transition rule.
    public var configuration: [String: AnyJSON]?

    /// The compound condition operator.
    public enum Operator: String, Codable, CaseIterable {
        case and = "AND"
        case or = "OR"
    }

    public init(`operator`: Operator? = nil, conditions: [CreateWorkflowCondition]? = nil, type: String? = nil, configuration: [String: AnyJSON]? = nil) {
        self.operator = `operator`
        self.conditions = conditions
        self.type = type
        self.configuration = configuration
    }

    private enum CodingKeys: String, CodingKey {
        case `operator` = "operator"
        case conditions
        case type
        case configuration
    }
}

/// The details of a workflow.
public struct CreateWorkflowDetails: Codable {
    /// The name of the workflow. The name must be unique. The maximum length is 255 characters. Characters can be separated by a whitespace but the name cannot start or end with a whitespace.
    public var name: String
    /// The description of the workflow. The maximum length is 1000 characters.
    public var description: String?
    /// The transitions of the workflow. For the request to be valid, these transitions must:
    /// 
    ///  *  include one *initial* transition.
    ///  *  not use the same name for a *global* and *directed* transition.
    ///  *  have a unique name for each *global* transition.
    ///  *  have a unique 'to' status for each *global* transition.
    ///  *  have unique names for each transition from a status.
    ///  *  not have a 'from' status on *initial* and *global* transitions.
    ///  *  have a 'from' status on *directed* transitions.
    /// 
    /// All the transition statuses must be included in `statuses`.
    public var transitions: [CreateWorkflowTransitionDetails]
    /// The statuses of the workflow. Any status that does not include a transition is added to the workflow without a transition.
    public var statuses: [CreateWorkflowStatusDetails]

    public init(name: String, description: String? = nil, transitions: [CreateWorkflowTransitionDetails], statuses: [CreateWorkflowStatusDetails]) {
        self.name = name
        self.description = description
        self.transitions = transitions
        self.statuses = statuses
    }
}

/// The details of a transition status.
public struct CreateWorkflowStatusDetails: Codable {
    /// The ID of the status.
    public var id: String
    /// The properties of the status.
    public var properties: [String: String]?

    public init(id: String, properties: [String: String]? = nil) {
        self.id = id
        self.properties = properties
    }
}

/// The details of a workflow transition.
public struct CreateWorkflowTransitionDetails: Codable {
    /// The name of the transition. The maximum length is 60 characters.
    public var name: String
    /// The description of the transition. The maximum length is 1000 characters.
    public var description: String?
    /// The statuses the transition can start from.
    public var from: [String]?
    /// The status the transition goes to.
    public var to: String
    /// The type of the transition.
    public var type: `Type`
    /// The rules of the transition.
    public var rules: CreateWorkflowTransitionRulesDetails?
    /// The screen of the transition.
    public var screen: CreateWorkflowTransitionScreenDetails?
    /// The properties of the transition.
    public var properties: [String: String]?

    /// The type of the transition.
    public enum `Type`: String, Codable, CaseIterable {
        case global
        case initial
        case directed
    }

    public init(name: String, description: String? = nil, from: [String]? = nil, to: String, type: `Type`, rules: CreateWorkflowTransitionRulesDetails? = nil, screen: CreateWorkflowTransitionScreenDetails? = nil, properties: [String: String]? = nil) {
        self.name = name
        self.description = description
        self.from = from
        self.to = to
        self.type = type
        self.rules = rules
        self.screen = screen
        self.properties = properties
    }
}

/// A workflow transition rule.
public struct CreateWorkflowTransitionRule: Codable {
    /// The type of the transition rule.
    public var type: String
    /// EXPERIMENTAL. The configuration of the transition rule.
    public var configuration: [String: AnyJSON]?

    public init(type: String, configuration: [String: AnyJSON]? = nil) {
        self.type = type
        self.configuration = configuration
    }
}

/// The details of a workflow transition rules.
public struct CreateWorkflowTransitionRulesDetails: Codable {
    /// The workflow conditions.
    public var conditions: CreateWorkflowCondition?
    /// The workflow validators.
    public var validators: [CreateWorkflowTransitionRule]?
    /// The workflow post functions.
    public var postFunctions: [CreateWorkflowTransitionRule]?

    public init(conditions: CreateWorkflowCondition? = nil, validators: [CreateWorkflowTransitionRule]? = nil, postFunctions: [CreateWorkflowTransitionRule]? = nil) {
        self.conditions = conditions
        self.validators = validators
        self.postFunctions = postFunctions
    }
}

/// The details of a transition screen.
public struct CreateWorkflowTransitionScreenDetails: Codable {
    /// The ID of the screen.
    public var id: String

    public init(id: String) {
        self.id = id
    }
}

/// The classic workflow identifiers.
public struct WorkflowIDs: Codable {
    /// The name of the workflow.
    public var name: String
    /// The entity ID of the workflow.
    public var entityID: String?

    public init(name: String, entityID: String? = nil) {
        self.name = name
        self.entityID = entityID
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case entityID = "entityId"
    }
}

/// Details about the server Jira is running on.
public struct WorkflowTransitionProperty: Codable {
    /// The key of the transition property. Also known as the name of the transition property.
    public var key: String?
    /// The value of the transition property.
    public var value: String
    /// The ID of the transition property.
    public var id: String?

    public init(key: String? = nil, value: String, id: String? = nil) {
        self.key = key
        self.value = value
        self.id = id
    }
}

/// A page of items.
public struct PageBeanWorkflow: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [Workflow]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [Workflow]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// Properties that identify a published workflow.
public struct PublishedWorkflowID: Codable {
    /// The name of the workflow.
    public var name: String
    /// The entity ID of the workflow.
    public var entityID: String?

    public init(name: String, entityID: String? = nil) {
        self.name = name
        self.entityID = entityID
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case entityID = "entityId"
    }
}

/// Details of a workflow transition.
public struct Transition: Codable {
    /// The ID of the transition.
    public var id: String
    /// The name of the transition.
    public var name: String
    /// The description of the transition.
    public var description: String
    /// The statuses the transition can start from.
    public var from: [String]
    /// The status the transition goes to.
    public var to: String
    /// The type of the transition.
    public var type: `Type`
    /// The details of a transition screen.
    public var screen: TransitionScreenDetails?
    public var rules: WorkflowRules?
    /// The properties of the transition.
    public var properties: [String: AnyJSON]?

    /// The type of the transition.
    public enum `Type`: String, Codable, CaseIterable {
        case global
        case initial
        case directed
    }

    public init(id: String, name: String, description: String, from: [String], to: String, type: `Type`, screen: TransitionScreenDetails? = nil, rules: WorkflowRules? = nil, properties: [String: AnyJSON]? = nil) {
        self.id = id
        self.name = name
        self.description = description
        self.from = from
        self.to = to
        self.type = type
        self.screen = screen
        self.rules = rules
        self.properties = properties
    }
}

/// The details of a transition screen.
public struct TransitionScreenDetails: Codable {
    /// The ID of the screen.
    public var id: String
    /// The name of the screen.
    public var name: String?

    public init(id: String, name: String? = nil) {
        self.id = id
        self.name = name
    }
}

/// Details about a workflow.
public struct Workflow: Codable {
    /// Properties that identify a published workflow.
    public var id: PublishedWorkflowID
    /// The description of the workflow.
    public var description: String
    /// The transitions of the workflow.
    public var transitions: [Transition]?
    /// The statuses of the workflow.
    public var statuses: [WorkflowStatus]?
    /// Whether this is the default workflow.
    public var isDefault: Bool?
    /// The workflow schemes the workflow is assigned to.
    public var schemes: [WorkflowSchemeIDName]?
    /// The projects the workflow is assigned to, through workflow schemes.
    public var projects: [ProjectDetails]?
    /// Whether the workflow has a draft version.
    public var hasDraftWorkflow: Bool?
    /// Operations allowed on a workflow
    public var operations: WorkflowOperations?
    /// The creation date of the workflow.
    public var created: Date?
    /// The last edited date of the workflow.
    public var updated: Date?

    public init(id: PublishedWorkflowID, description: String, transitions: [Transition]? = nil, statuses: [WorkflowStatus]? = nil, isDefault: Bool? = nil, schemes: [WorkflowSchemeIDName]? = nil, projects: [ProjectDetails]? = nil, hasDraftWorkflow: Bool? = nil, operations: WorkflowOperations? = nil, created: Date? = nil, updated: Date? = nil) {
        self.id = id
        self.description = description
        self.transitions = transitions
        self.statuses = statuses
        self.isDefault = isDefault
        self.schemes = schemes
        self.projects = projects
        self.hasDraftWorkflow = hasDraftWorkflow
        self.operations = operations
        self.created = created
        self.updated = updated
    }
}

/// A compound workflow transition rule condition. This object returns `nodeType` as `compound`.
public struct WorkflowCompoundCondition: Codable {
    /// The compound condition operator.
    public var `operator`: Operator
    /// The list of workflow conditions.
    public var conditions: [WorkflowCondition]
    public var nodeType: String

    /// The compound condition operator.
    public enum Operator: String, Codable, CaseIterable {
        case and = "AND"
        case or = "OR"
    }

    public init(`operator`: Operator, conditions: [WorkflowCondition], nodeType: String) {
        self.operator = `operator`
        self.conditions = conditions
        self.nodeType = nodeType
    }

    private enum CodingKeys: String, CodingKey {
        case `operator` = "operator"
        case conditions
        case nodeType
    }
}

/// The workflow transition rule conditions tree.
public enum WorkflowCondition: Codable {
    case workflowSimpleCondition(WorkflowSimpleCondition)
    case workflowCompoundCondition(WorkflowCompoundCondition)

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(WorkflowSimpleCondition.self) {
            self = .workflowSimpleCondition(value)
        } else if let value = try? container.decode(WorkflowCompoundCondition.self) {
            self = .workflowCompoundCondition(value)
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .workflowSimpleCondition(let value): try container.encode(value)
        case .workflowCompoundCondition(let value): try container.encode(value)
        }
    }
}

/// Operations allowed on a workflow
public struct WorkflowOperations: Codable {
    /// Whether the workflow can be updated.
    public var canEdit: Bool
    /// Whether the workflow can be deleted.
    public var canDelete: Bool

    public init(canEdit: Bool, canDelete: Bool) {
        self.canEdit = canEdit
        self.canDelete = canDelete
    }
}

/// A collection of transition rules.
public struct WorkflowRules: Codable {
    /// The workflow conditions. ([Deprecated](https://community.developer.atlassian.com/t/deprecation-of-conditions-body-param/48884))
    public var conditions: [WorkflowTransitionRule]?
    public var conditionsTree: WorkflowCondition?
    /// The workflow validators.
    public var validators: [WorkflowTransitionRule]?
    /// The workflow post functions.
    public var postFunctions: [WorkflowTransitionRule]?

    public init(conditions: [WorkflowTransitionRule]? = nil, conditionsTree: WorkflowCondition? = nil, validators: [WorkflowTransitionRule]? = nil, postFunctions: [WorkflowTransitionRule]? = nil) {
        self.conditions = conditions
        self.conditionsTree = conditionsTree
        self.validators = validators
        self.postFunctions = postFunctions
    }
}

/// The ID and the name of the workflow scheme.
public struct WorkflowSchemeIDName: Codable {
    /// The ID of the workflow scheme.
    public var id: String
    /// The name of the workflow scheme.
    public var name: String

    public init(id: String, name: String) {
        self.id = id
        self.name = name
    }
}

/// A workflow transition rule condition. This object returns `nodeType` as `simple`.
public struct WorkflowSimpleCondition: Codable {
    /// The type of the transition rule.
    public var type: String
    /// EXPERIMENTAL. The configuration of the transition rule.
    public var configuration: Configuration?
    public var nodeType: String

    /// EXPERIMENTAL. The configuration of the transition rule.
    public struct Configuration: Codable {
        public init() {}
    }

    public init(type: String, configuration: Configuration? = nil, nodeType: String) {
        self.type = type
        self.configuration = configuration
        self.nodeType = nodeType
    }
}

/// Details of a workflow status.
public struct WorkflowStatus: Codable {
    /// The ID of the issue status.
    public var id: String
    /// The name of the status in the workflow.
    public var name: String
    /// Additional properties that modify the behavior of issues in this status. Supports the properties `jira.issue.editable` and `issueEditable` (deprecated) that indicate whether issues are editable.
    public var properties: [String: AnyJSON]?

    public init(id: String, name: String, properties: [String: AnyJSON]? = nil) {
        self.id = id
        self.name = name
        self.properties = properties
    }
}

/// A workflow transition rule.
public struct WorkflowTransitionRule: Codable {
    /// The type of the transition rule.
    public var type: String
    /// EXPERIMENTAL. The configuration of the transition rule.
    public var configuration: AnyJSON?

    public init(type: String, configuration: AnyJSON? = nil) {
        self.type = type
        self.configuration = configuration
    }
}

/// A workflow transition rule.
public struct ConnectWorkflowTransitionRule: Codable {
    /// The ID of the transition rule.
    public var id: String
    /// The key of the rule, as defined in the Connect app descriptor.
    public var key: String
    /// A rule configuration.
    public var configuration: RuleConfiguration
    public var transition: WorkflowTransition?

    public init(id: String, key: String, configuration: RuleConfiguration, transition: WorkflowTransition? = nil) {
        self.id = id
        self.key = key
        self.configuration = configuration
        self.transition = transition
    }
}

/// A page of items.
public struct PageBeanWorkflowTransitionRules: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [WorkflowTransitionRules]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [WorkflowTransitionRules]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// A rule configuration.
public struct RuleConfiguration: Codable {
    /// Configuration of the rule, as it is stored by the Connect app on the rule configuration page.
    public var value: String
    /// EXPERIMENTAL: Whether the rule is disabled.
    public var isDisabled: Bool
    /// EXPERIMENTAL: A tag used to filter rules in [Get workflow transition rule configurations](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-workflow-transition-rules/#api-rest-api-3-workflow-rule-config-get).
    public var tag: String?

    public init(value: String, isDisabled: Bool? = nil, tag: String? = nil) {
        self.value = value
        self.isDisabled = isDisabled ?? false
        self.tag = tag
    }

    private enum CodingKeys: String, CodingKey {
        case value
        case isDisabled = "disabled"
        case tag
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.value = try values.decode(String.self, forKey: .value)
        self.isDisabled = try values.decodeIfPresent(Bool.self, forKey: .isDisabled) ?? false
        self.tag = try values.decodeIfPresent(String.self, forKey: .tag)
    }
}

/// Properties that identify a workflow.
public struct WorkflowID: Codable {
    /// The name of the workflow.
    public var name: String
    /// Whether the workflow is in the draft state.
    public var isDraft: Bool

    public init(name: String, isDraft: Bool) {
        self.name = name
        self.isDraft = isDraft
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case isDraft = "draft"
    }
}

/// A workflow transition.
public struct WorkflowTransition: Codable {
    /// The transition ID.
    public var id: Int
    /// The transition name.
    public var name: String

    public init(id: Int, name: String) {
        self.id = id
        self.name = name
    }
}

/// A workflow with transition rules.
public struct WorkflowTransitionRules: Codable {
    /// Properties that identify a workflow.
    public var workflowID: WorkflowID
    /// The list of post functions within the workflow.
    public var postFunctions: [ConnectWorkflowTransitionRule]
    /// The list of conditions within the workflow.
    public var conditions: [ConnectWorkflowTransitionRule]
    /// The list of validators within the workflow.
    public var validators: [ConnectWorkflowTransitionRule]

    public init(workflowID: WorkflowID, postFunctions: [ConnectWorkflowTransitionRule], conditions: [ConnectWorkflowTransitionRule], validators: [ConnectWorkflowTransitionRule]) {
        self.workflowID = workflowID
        self.postFunctions = postFunctions
        self.conditions = conditions
        self.validators = validators
    }

    private enum CodingKeys: String, CodingKey {
        case workflowID = "workflowId"
        case postFunctions
        case conditions
        case validators
    }
}

/// Details about a workflow configuration update request.
public struct WorkflowTransitionRulesUpdate: Codable {
    /// The list of workflows with transition rules to update.
    public var workflows: [WorkflowTransitionRules]

    public init(workflows: [WorkflowTransitionRules]) {
        self.workflows = workflows
    }
}

/// Details of any errors encountered while updating workflow transition rules for a workflow.
public struct WorkflowTransitionRulesUpdateErrorDetails: Codable {
    /// Properties that identify a workflow.
    public var workflowID: WorkflowID
    /// A list of transition rule update errors, indexed by the transition rule ID. Any transition rule that appears here wasn't updated.
    public var ruleUpdateErrors: [String: [String]]
    /// The list of errors that specify why the workflow update failed. The workflow was not updated if the list contains any entries.
    public var updateErrors: [String]

    public init(workflowID: WorkflowID, ruleUpdateErrors: [String: [String]], updateErrors: [String]) {
        self.workflowID = workflowID
        self.ruleUpdateErrors = ruleUpdateErrors
        self.updateErrors = updateErrors
    }

    private enum CodingKeys: String, CodingKey {
        case workflowID = "workflowId"
        case ruleUpdateErrors
        case updateErrors
    }
}

/// Details of any errors encountered while updating workflow transition rules.
public struct WorkflowTransitionRulesUpdateErrors: Codable {
    /// A list of workflows.
    public var updateResults: [WorkflowTransitionRulesUpdateErrorDetails]

    public init(updateResults: [WorkflowTransitionRulesUpdateErrorDetails]) {
        self.updateResults = updateResults
    }
}

/// Details about a workflow configuration update request.
public struct WorkflowTransitionRulesDetails: Codable {
    /// Properties that identify a workflow.
    public var workflowID: WorkflowID
    /// The list of connect workflow rule IDs.
    public var workflowRuleIDs: [String]

    public init(workflowID: WorkflowID, workflowRuleIDs: [String]) {
        self.workflowID = workflowID
        self.workflowRuleIDs = workflowRuleIDs
    }

    private enum CodingKeys: String, CodingKey {
        case workflowID = "workflowId"
        case workflowRuleIDs = "workflowRuleIds"
    }
}

/// Details of workflows and their transition rules to delete.
public struct WorkflowsWithTransitionRulesDetails: Codable {
    /// The list of workflows with transition rules to delete.
    public var workflows: [WorkflowTransitionRulesDetails]

    public init(workflows: [WorkflowTransitionRulesDetails]) {
        self.workflows = workflows
    }
}

/// Details about the time tracking provider.
public struct TimeTrackingProvider: Codable {
    /// The key for the time tracking provider. For example, *JIRA*.
    public var key: String
    /// The name of the time tracking provider. For example, *JIRA provided time tracking*.
    public var name: String?
    /// The URL of the configuration page for the time tracking provider app. For example, */example/config/url*. This property is only returned if the `adminPageKey` property is set in the module descriptor of the time tracking provider app.
    public var url: String?

    public init(key: String, name: String? = nil, url: String? = nil) {
        self.key = key
        self.name = name
        self.url = url
    }
}

/// Details of an item associated with the changed record.
public struct AssociatedItemBean: Codable {
    /// The ID of the associated record.
    public var id: String?
    /// The name of the associated record.
    public var name: String?
    /// The type of the associated record.
    public var typeName: String?
    /// The ID of the associated parent record.
    public var parentID: String?
    /// The name of the associated parent record.
    public var parentName: String?

    public init(id: String? = nil, name: String? = nil, typeName: String? = nil, parentID: String? = nil, parentName: String? = nil) {
        self.id = id
        self.name = name
        self.typeName = typeName
        self.parentID = parentID
        self.parentName = parentName
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case typeName
        case parentID = "parentId"
        case parentName
    }
}

/// An audit record.
public struct AuditRecordBean: Codable {
    /// The ID of the audit record.
    public var id: Int?
    /// The summary of the audit record.
    public var summary: String?
    /// The URL of the computer where the creation of the audit record was initiated.
    public var remoteAddress: String?
    /// Deprecated, use `authorAccountId` instead. The key of the user who created the audit record.
    public var authorKey: String?
    /// The date and time on which the audit record was created.
    public var created: Date?
    /// The category of the audit record. For a list of these categories, see the help article [Auditing in Jira applications](https://confluence.atlassian.com/x/noXKM).
    public var category: String?
    /// The event the audit record originated from.
    public var eventSource: String?
    /// The description of the audit record.
    public var description: String?
    /// Details of an item associated with the changed record.
    public var objectItem: AssociatedItemBean?
    /// The list of values changed in the record event.
    public var changedValues: [ChangedValueBean]?
    /// The list of items associated with the changed record.
    public var associatedItems: [AssociatedItemBean]?

    public init(id: Int? = nil, summary: String? = nil, remoteAddress: String? = nil, authorKey: String? = nil, created: Date? = nil, category: String? = nil, eventSource: String? = nil, description: String? = nil, objectItem: AssociatedItemBean? = nil, changedValues: [ChangedValueBean]? = nil, associatedItems: [AssociatedItemBean]? = nil) {
        self.id = id
        self.summary = summary
        self.remoteAddress = remoteAddress
        self.authorKey = authorKey
        self.created = created
        self.category = category
        self.eventSource = eventSource
        self.description = description
        self.objectItem = objectItem
        self.changedValues = changedValues
        self.associatedItems = associatedItems
    }
}

/// Container for a list of audit records.
public struct AuditRecords: Codable {
    /// The number of audit items skipped before the first item in this list.
    public var offset: Int?
    /// The requested or default limit on the number of audit items to be returned.
    public var limit: Int?
    /// The total number of audit items returned.
    public var total: Int?
    /// The list of audit items.
    public var records: [AuditRecordBean]?

    public init(offset: Int? = nil, limit: Int? = nil, total: Int? = nil, records: [AuditRecordBean]? = nil) {
        self.offset = offset
        self.limit = limit
        self.total = total
        self.records = records
    }
}

/// Details of names changed in the record event.
public struct ChangedValueBean: Codable {
    /// The name of the field changed.
    public var fieldName: String?
    /// The value of the field before the change.
    public var changedFrom: String?
    /// The value of the field after the change.
    public var changedTo: String?

    public init(fieldName: String? = nil, changedFrom: String? = nil, changedTo: String? = nil) {
        self.fieldName = fieldName
        self.changedFrom = changedFrom
        self.changedTo = changedTo
    }
}

/// Details about a group.
public struct GroupDetails: Codable {
    /// The name of the group.
    public var name: String?
    /// The ID of the group, if available, which uniquely identifies the group across all Atlassian products. For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*.
    public var groupID: String?

    public init(name: String? = nil, groupID: String? = nil) {
        self.name = name
        self.groupID = groupID
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case groupID = "groupId"
    }
}

/// A page of items.
public struct PageBeanGroupDetails: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [GroupDetails]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [GroupDetails]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// A project's sender email address.
public struct ProjectEmailAddress: Codable {
    /// The email address.
    public var emailAddress: String?
    /// When using a custom domain, the status of the email address.
    public var emailAddressStatus: [String]?

    public init(emailAddress: String? = nil, emailAddressStatus: [String]? = nil) {
        self.emailAddress = emailAddress
        self.emailAddressStatus = emailAddressStatus
    }
}

/// Details about a project type.
public struct ProjectType: Codable {
    /// The key of the project type.
    public var key: String?
    /// The formatted key of the project type.
    public var formattedKey: String?
    /// The key of the project type's description.
    public var descriptionI18nKey: String?
    /// The icon of the project type.
    public var icon: String?
    /// The color of the project type.
    public var color: String?

    public init(key: String? = nil, formattedKey: String? = nil, descriptionI18nKey: String? = nil, icon: String? = nil, color: String? = nil) {
        self.key = key
        self.formattedKey = formattedKey
        self.descriptionI18nKey = descriptionI18nKey
        self.icon = icon
        self.color = color
    }
}

/// A page of items.
public struct PageBeanString: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [String]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [String]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// A page of items.
public struct PageBeanUserKey: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [UserKey]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [UserKey]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// List of user account IDs.
public struct UserKey: Codable {
    /// This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
    public var key: String?
    /// The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. Returns *unknown* if the record is deleted and corrupted, for example, as the result of a server import.
    public var accountID: String?

    public init(key: String? = nil, accountID: String? = nil) {
        self.key = key
        self.accountID = accountID
    }

    private enum CodingKeys: String, CodingKey {
        case key
        case accountID = "accountId"
    }
}

/// A page of items.
public struct PageBeanUser: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [User]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [User]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// A change item.
public struct ChangeDetails: Codable {
    /// The name of the field changed.
    public var field: String?
    /// The type of the field changed.
    public var fieldtype: String?
    /// The ID of the field changed.
    public var fieldID: String?
    /// The details of the original value.
    public var from: String?
    /// The details of the original value as a string.
    public var fromString: String?
    /// The details of the new value.
    public var to: String?
    /// The details of the new value as a string.
    public var toString: String?

    public init(field: String? = nil, fieldtype: String? = nil, fieldID: String? = nil, from: String? = nil, fromString: String? = nil, to: String? = nil, toString: String? = nil) {
        self.field = field
        self.fieldtype = fieldtype
        self.fieldID = fieldID
        self.from = from
        self.fromString = fromString
        self.to = to
        self.toString = toString
    }

    private enum CodingKeys: String, CodingKey {
        case field
        case fieldtype
        case fieldID = "fieldId"
        case from
        case fromString
        case to
        case toString
    }
}

/// A changelog.
public struct Changelog: Codable {
    /// The ID of the changelog.
    public var id: String?
    /// The user who made the change.
    public var author: UserDetails?
    /// The date on which the change took place.
    public var created: Date?
    /// The list of items changed.
    public var items: [ChangeDetails]?
    /// The history metadata associated with the changed.
    public var historyMetadata: HistoryMetadata?

    public init(id: String? = nil, author: UserDetails? = nil, created: Date? = nil, items: [ChangeDetails]? = nil, historyMetadata: HistoryMetadata? = nil) {
        self.id = id
        self.author = author
        self.created = created
        self.items = items
        self.historyMetadata = historyMetadata
    }
}

/// The metadata describing an issue field.
public struct FieldMetadata: Codable {
    /// Whether the field is required.
    public var isRequired: Bool
    /// The data type of the field.
    public var schema: JSONTypeBean
    /// The name of the field.
    public var name: String
    /// The key of the field.
    public var key: String
    /// The URL that can be used to automatically complete the field.
    public var autoCompleteURL: String?
    /// Whether the field has a default value.
    public var hasDefaultValue: Bool?
    /// The list of operations that can be performed on the field.
    public var operations: [String]
    /// The list of values allowed in the field.
    public var allowedValues: [AnyJSON]?
    /// The default value of the field.
    public var defaultValue: AnyJSON?

    public init(isRequired: Bool, schema: JSONTypeBean, name: String, key: String, autoCompleteURL: String? = nil, hasDefaultValue: Bool? = nil, operations: [String], allowedValues: [AnyJSON]? = nil, defaultValue: AnyJSON? = nil) {
        self.isRequired = isRequired
        self.schema = schema
        self.name = name
        self.key = key
        self.autoCompleteURL = autoCompleteURL
        self.hasDefaultValue = hasDefaultValue
        self.operations = operations
        self.allowedValues = allowedValues
        self.defaultValue = defaultValue
    }

    private enum CodingKeys: String, CodingKey {
        case isRequired = "required"
        case schema
        case name
        case key
        case autoCompleteURL = "autoCompleteUrl"
        case hasDefaultValue
        case operations
        case allowedValues
        case defaultValue
    }
}

/// Details of issue history metadata.
public struct HistoryMetadata: Codable {
    /// The type of the history record.
    public var type: String?
    /// The description of the history record.
    public var description: String?
    /// The description key of the history record.
    public var descriptionKey: String?
    /// The activity described in the history record.
    public var activityDescription: String?
    /// The key of the activity described in the history record.
    public var activityDescriptionKey: String?
    /// The description of the email address associated the history record.
    public var emailDescription: String?
    /// The description key of the email address associated the history record.
    public var emailDescriptionKey: String?
    /// Details of the user whose action created the history record.
    public var actor: HistoryMetadataParticipant?
    /// Details of the system that generated the history record.
    public var generator: HistoryMetadataParticipant?
    /// Details of the cause that triggered the creation the history record.
    public var cause: HistoryMetadataParticipant?
    /// Additional arbitrary information about the history record.
    public var extraData: [String: String]?

    public init(type: String? = nil, description: String? = nil, descriptionKey: String? = nil, activityDescription: String? = nil, activityDescriptionKey: String? = nil, emailDescription: String? = nil, emailDescriptionKey: String? = nil, actor: HistoryMetadataParticipant? = nil, generator: HistoryMetadataParticipant? = nil, cause: HistoryMetadataParticipant? = nil, extraData: [String: String]? = nil) {
        self.type = type
        self.description = description
        self.descriptionKey = descriptionKey
        self.activityDescription = activityDescription
        self.activityDescriptionKey = activityDescriptionKey
        self.emailDescription = emailDescription
        self.emailDescriptionKey = emailDescriptionKey
        self.actor = actor
        self.generator = generator
        self.cause = cause
        self.extraData = extraData
    }
}

/// Details of user or system associated with a issue history metadata item.
public struct HistoryMetadataParticipant: Codable {
    /// The ID of the user or system associated with a history record.
    public var id: String?
    /// The display name of the user or system associated with a history record.
    public var displayName: String?
    /// The key of the display name of the user or system associated with a history record.
    public var displayNameKey: String?
    /// The type of the user or system associated with a history record.
    public var type: String?
    /// The URL to an avatar for the user or system associated with a history record.
    public var avatarURL: String?
    /// The URL of the user or system associated with a history record.
    public var url: String?

    public init(id: String? = nil, displayName: String? = nil, displayNameKey: String? = nil, type: String? = nil, avatarURL: String? = nil, url: String? = nil) {
        self.id = id
        self.displayName = displayName
        self.displayNameKey = displayNameKey
        self.type = type
        self.avatarURL = avatarURL
        self.url = url
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case displayName
        case displayNameKey
        case type
        case avatarURL = "avatarUrl"
        case url
    }
}

public struct IncludedFields: Codable {
    public var excluded: [String]?
    public var included: [String]?
    public var actuallyIncluded: [String]?

    public init(excluded: [String]? = nil, included: [String]? = nil, actuallyIncluded: [String]? = nil) {
        self.excluded = excluded
        self.included = included
        self.actuallyIncluded = actuallyIncluded
    }
}

/// Details about an issue.
public struct IssueBean: Codable {
    /// Expand options that include additional issue details in the response.
    public var expand: String?
    /// The ID of the issue.
    public var id: String?
    /// The URL of the issue details.
    public var this: URL?
    /// The key of the issue.
    public var key: String?
    /// The rendered value of each field present on the issue.
    public var renderedFields: [String: AnyJSON]?
    /// Details of the issue properties identified in the request.
    public var properties: [String: AnyJSON]?
    /// The ID and name of each field present on the issue.
    public var names: [String: String]?
    /// The schema describing each field present on the issue.
    public var schema: [String: JSONTypeBean]?
    /// The transitions that can be performed on the issue.
    public var transitions: [IssueTransition]?
    /// The operations that can be performed on the issue.
    public var operations: Operations?
    /// The metadata for the fields on the issue that can be amended.
    public var editmeta: IssueUpdateMetadata?
    /// Details of changelogs associated with the issue.
    public var changelog: PageOfChangelogs?
    /// The versions of each field on the issue.
    public var versionedRepresentations: [String: [String: AnyJSON]]?
    public var fieldsToInclude: IncludedFields?
    public var fields: [String: AnyJSON]?

    public init(expand: String? = nil, id: String? = nil, this: URL? = nil, key: String? = nil, renderedFields: [String: AnyJSON]? = nil, properties: [String: AnyJSON]? = nil, names: [String: String]? = nil, schema: [String: JSONTypeBean]? = nil, transitions: [IssueTransition]? = nil, operations: Operations? = nil, editmeta: IssueUpdateMetadata? = nil, changelog: PageOfChangelogs? = nil, versionedRepresentations: [String: [String: AnyJSON]]? = nil, fieldsToInclude: IncludedFields? = nil, fields: [String: AnyJSON]? = nil) {
        self.expand = expand
        self.id = id
        self.this = this
        self.key = key
        self.renderedFields = renderedFields
        self.properties = properties
        self.names = names
        self.schema = schema
        self.transitions = transitions
        self.operations = operations
        self.editmeta = editmeta
        self.changelog = changelog
        self.versionedRepresentations = versionedRepresentations
        self.fieldsToInclude = fieldsToInclude
        self.fields = fields
    }

    private enum CodingKeys: String, CodingKey {
        case expand
        case id
        case this = "self"
        case key
        case renderedFields
        case properties
        case names
        case schema
        case transitions
        case operations
        case editmeta
        case changelog
        case versionedRepresentations
        case fieldsToInclude
        case fields
    }
}

/// Details of an issue transition.
public struct IssueTransition: Codable {
    /// The ID of the issue transition. Required when specifying a transition to undertake.
    public var id: String?
    /// The name of the issue transition.
    public var name: String?
    /// Details of the issue status after the transition.
    public var to: StatusDetails?
    /// Whether there is a screen associated with the issue transition.
    public var hasScreen: Bool?
    /// Whether the issue transition is global, that is, the transition is applied to issues regardless of their status.
    public var isGlobal: Bool?
    /// Whether this is the initial issue transition for the workflow.
    public var isInitial: Bool?
    /// Whether the transition is available to be performed.
    public var isAvailable: Bool?
    /// Whether the issue has to meet criteria before the issue transition is applied.
    public var isConditional: Bool?
    /// Details of the fields associated with the issue transition screen. Use this information to populate `fields` and `update` in a transition request.
    public var fields: [String: FieldMetadata]?
    /// Expand options that include additional transition details in the response.
    public var expand: String?
    public var isLooped: Bool?

    public init(id: String? = nil, name: String? = nil, to: StatusDetails? = nil, hasScreen: Bool? = nil, isGlobal: Bool? = nil, isInitial: Bool? = nil, isAvailable: Bool? = nil, isConditional: Bool? = nil, fields: [String: FieldMetadata]? = nil, expand: String? = nil, isLooped: Bool? = nil) {
        self.id = id
        self.name = name
        self.to = to
        self.hasScreen = hasScreen
        self.isGlobal = isGlobal
        self.isInitial = isInitial
        self.isAvailable = isAvailable
        self.isConditional = isConditional
        self.fields = fields
        self.expand = expand
        self.isLooped = isLooped
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case to
        case hasScreen
        case isGlobal
        case isInitial
        case isAvailable
        case isConditional
        case fields
        case expand
        case isLooped = "looped"
    }
}

/// A list of editable field details.
public struct IssueUpdateMetadata: Codable {
    /// A list of editable field details.
    public var fields: [String: FieldMetadata]?

    public init(fields: [String: FieldMetadata]? = nil) {
        self.fields = fields
    }
}

/// The schema of a field.
public struct JSONTypeBean: Codable {
    /// The data type of the field.
    public var type: String
    /// When the data type is an array, the name of the field items within the array.
    public var items: String?
    /// If the field is a system field, the name of the field.
    public var system: String?
    /// If the field is a custom field, the URI of the field.
    public var custom: String?
    /// If the field is a custom field, the custom ID of the field.
    public var customID: Int?
    /// If the field is a custom field, the configuration of the field.
    public var configuration: [String: AnyJSON]?

    public init(type: String, items: String? = nil, system: String? = nil, custom: String? = nil, customID: Int? = nil, configuration: [String: AnyJSON]? = nil) {
        self.type = type
        self.items = items
        self.system = system
        self.custom = custom
        self.customID = customID
        self.configuration = configuration
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case items
        case system
        case custom
        case customID = "customId"
        case configuration
    }
}

/// Details a link group, which defines issue operations.
public struct LinkGroup: Codable {
    public var id: String?
    public var styleClass: String?
    /// Details about the operations available in this version.
    public var header: SimpleLink?
    public var weight: Int?
    public var links: [SimpleLink]?
    public var groups: [LinkGroup]?

    public init(id: String? = nil, styleClass: String? = nil, header: SimpleLink? = nil, weight: Int? = nil, links: [SimpleLink]? = nil, groups: [LinkGroup]? = nil) {
        self.id = id
        self.styleClass = styleClass
        self.header = header
        self.weight = weight
        self.links = links
        self.groups = groups
    }
}

/// Details of the operations that can be performed on the issue.
public struct Operations: Codable {
    /// Details of the link groups defining issue operations.
    public var linkGroups: [LinkGroup]?

    public init(linkGroups: [LinkGroup]? = nil) {
        self.linkGroups = linkGroups
    }
}

/// A page of changelogs.
public struct PageOfChangelogs: Codable {
    /// The index of the first item returned on the page.
    public var startAt: Int?
    /// The maximum number of results that could be on the page.
    public var maxResults: Int?
    /// The number of results on the page.
    public var total: Int?
    /// The list of changelogs.
    public var histories: [Changelog]?

    public init(startAt: Int? = nil, maxResults: Int? = nil, total: Int? = nil, histories: [Changelog]? = nil) {
        self.startAt = startAt
        self.maxResults = maxResults
        self.total = total
        self.histories = histories
    }
}

/// The result of a JQL search.
public struct SearchResults: Codable {
    /// Expand options that include additional search result details in the response.
    public var expand: String?
    /// The index of the first item returned on the page.
    public var startAt: Int?
    /// The maximum number of results that could be on the page.
    public var maxResults: Int?
    /// The number of results on the page.
    public var total: Int?
    /// The list of issues found by the search.
    public var issues: [IssueBean]?
    /// Any warnings related to the JQL query.
    public var warningMessages: [String]?
    /// The ID and name of each field in the search results.
    public var names: [String: String]?
    /// The schema describing the field types in the search results.
    public var schema: [String: JSONTypeBean]?

    public init(expand: String? = nil, startAt: Int? = nil, maxResults: Int? = nil, total: Int? = nil, issues: [IssueBean]? = nil, warningMessages: [String]? = nil, names: [String: String]? = nil, schema: [String: JSONTypeBean]? = nil) {
        self.expand = expand
        self.startAt = startAt
        self.maxResults = maxResults
        self.total = total
        self.issues = issues
        self.warningMessages = warningMessages
        self.names = names
        self.schema = schema
    }
}

/// Details about the operations available in this version.
public struct SimpleLink: Codable {
    public var id: String?
    public var styleClass: String?
    public var iconClass: String?
    public var label: String?
    public var title: String?
    public var href: String?
    public var weight: Int?

    public init(id: String? = nil, styleClass: String? = nil, iconClass: String? = nil, label: String? = nil, title: String? = nil, href: String? = nil, weight: Int? = nil) {
        self.id = id
        self.styleClass = styleClass
        self.iconClass = iconClass
        self.label = label
        self.title = title
        self.href = href
        self.weight = weight
    }
}

/// A status category.
public struct StatusCategory: Codable {
    /// The URL of the status category.
    public var this: String?
    /// The ID of the status category.
    public var id: Int?
    /// The key of the status category.
    public var key: String?
    /// The name of the color used to represent the status category.
    public var colorName: String?
    /// The name of the status category.
    public var name: String?

    public init(this: String? = nil, id: Int? = nil, key: String? = nil, colorName: String? = nil, name: String? = nil) {
        self.this = this
        self.id = id
        self.key = key
        self.colorName = colorName
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case id
        case key
        case colorName
        case name
    }
}

/// A status.
public struct StatusDetails: Codable {
    /// The URL of the status.
    public var this: String?
    /// The description of the status.
    public var description: String?
    /// The URL of the icon used to represent the status.
    public var iconURL: String?
    /// The name of the status.
    public var name: String?
    /// The ID of the status.
    public var id: String?
    /// The category assigned to the status.
    public var statusCategory: StatusCategory?

    public init(this: String? = nil, description: String? = nil, iconURL: String? = nil, name: String? = nil, id: String? = nil, statusCategory: StatusCategory? = nil) {
        self.this = this
        self.description = description
        self.iconURL = iconURL
        self.name = name
        self.id = id
        self.statusCategory = statusCategory
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case description
        case iconURL = "iconUrl"
        case name
        case id
        case statusCategory
    }
}

/// User details permitted by the user's Atlassian Account privacy settings. However, be aware of these exceptions:
/// 
///  *  User record deleted from Atlassian: This occurs as the result of a right to be forgotten request. In this case, `displayName` provides an indication and other parameters have default values or are blank (for example, email is blank).
///  *  User record corrupted: This occurs as a results of events such as a server import and can only happen to deleted users. In this case, `accountId` returns *unknown* and all other parameters have fallback values.
///  *  User record unavailable: This usually occurs due to an internal service outage. In this case, all parameters have fallback values.
public struct UserDetails: Codable {
    /// The URL of the user.
    public var this: String?
    /// This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
    public var name: String?
    /// This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
    public var key: String?
    /// The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
    public var accountID: String?
    /// The email address of the user. Depending on the user’s privacy settings, this may be returned as null.
    public var emailAddress: String?
    /// The avatars of the user.
    public var avatarURLs: AvatarURLsBean?
    /// The display name of the user. Depending on the user’s privacy settings, this may return an alternative value.
    public var displayName: String?
    /// Whether the user is active.
    public var isActive: Bool?
    /// The time zone specified in the user's profile. Depending on the user’s privacy settings, this may be returned as null.
    public var timeZone: String?
    /// The type of account represented by this user. This will be one of 'atlassian' (normal users), 'app' (application user) or 'customer' (Jira Service Desk customer user)
    public var accountType: String?

    public init(this: String? = nil, name: String? = nil, key: String? = nil, accountID: String? = nil, emailAddress: String? = nil, avatarURLs: AvatarURLsBean? = nil, displayName: String? = nil, isActive: Bool? = nil, timeZone: String? = nil, accountType: String? = nil) {
        self.this = this
        self.name = name
        self.key = key
        self.accountID = accountID
        self.emailAddress = emailAddress
        self.avatarURLs = avatarURLs
        self.displayName = displayName
        self.isActive = isActive
        self.timeZone = timeZone
        self.accountType = accountType
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case name
        case key
        case accountID = "accountId"
        case emailAddress
        case avatarURLs = "avatarUrls"
        case displayName
        case isActive = "active"
        case timeZone
        case accountType
    }
}

public struct SearchRequestBean: Codable {
    /// A [JQL](https://confluence.atlassian.com/x/egORLQ) expression.
    public var jql: String?
    /// The index of the first item to return in the page of results (page offset). The base index is `0`.
    public var startAt: Int?
    /// The maximum number of items to return per page.
    public var maxResults: Int?
    /// A list of fields to return for each issue, use it to retrieve a subset of fields. This parameter accepts a comma-separated list. Expand options include:
    /// 
    ///  *  `*all` Returns all fields.
    ///  *  `*navigable` Returns navigable fields.
    ///  *  Any issue field, prefixed with a minus to exclude.
    /// 
    /// The default is `*navigable`.
    /// 
    /// Examples:
    /// 
    ///  *  `summary,comment` Returns the summary and comments fields only.
    ///  *  `-description` Returns all navigable (default) fields except description.
    ///  *  `*all,-comment` Returns all fields except comments.
    /// 
    /// Multiple `fields` parameters can be included in a request.
    /// 
    /// Note: All navigable fields are returned by default. This differs from [GET issue](#api-rest-api-3-issue-issueIdOrKey-get) where the default is all fields.
    public var fields: [String]?
    /// Determines how to validate the JQL query and treat the validation results. Supported values:
    /// 
    ///  *  `strict` Returns a 400 response code if any errors are found, along with a list of all errors (and warnings).
    ///  *  `warn` Returns all errors as warnings.
    ///  *  `none` No validation is performed.
    ///  *  `true` *Deprecated* A legacy synonym for `strict`.
    ///  *  `false` *Deprecated* A legacy synonym for `warn`.
    /// 
    /// The default is `strict`.
    /// 
    /// Note: If the JQL is not correctly formed a 400 response code is returned, regardless of the `validateQuery` value.
    public var validateQuery: ValidateQuery?
    /// Use [expand](em>#expansion) to include additional information about issues in the response. Note that, unlike the majority of instances where `expand` is specified, `expand` is defined as a list of values. The expand options are:
    /// 
    ///  *  `renderedFields` Returns field values rendered in HTML format.
    ///  *  `names` Returns the display name of each field.
    ///  *  `schema` Returns the schema describing a field type.
    ///  *  `transitions` Returns all possible transitions for the issue.
    ///  *  `operations` Returns all possible operations for the issue.
    ///  *  `editmeta` Returns information about how each field can be edited.
    ///  *  `changelog` Returns a list of recent updates to an issue, sorted by date, starting from the most recent.
    ///  *  `versionedRepresentations` Instead of `fields`, returns `versionedRepresentations` a JSON array containing each version of a field's value, with the highest numbered item representing the most recent version.
    public var expand: [String]?
    /// A list of up to 5 issue properties to include in the results. This parameter accepts a comma-separated list.
    public var properties: [String]?
    /// Reference fields by their key (rather than ID). The default is `false`.
    public var isFieldsByKeys: Bool?

    /// Determines how to validate the JQL query and treat the validation results. Supported values:
    /// 
    ///  *  `strict` Returns a 400 response code if any errors are found, along with a list of all errors (and warnings).
    ///  *  `warn` Returns all errors as warnings.
    ///  *  `none` No validation is performed.
    ///  *  `true` *Deprecated* A legacy synonym for `strict`.
    ///  *  `false` *Deprecated* A legacy synonym for `warn`.
    /// 
    /// The default is `strict`.
    /// 
    /// Note: If the JQL is not correctly formed a 400 response code is returned, regardless of the `validateQuery` value.
    public enum ValidateQuery: String, Codable, CaseIterable {
        case strict
        case warn
        case `none`
        case `true`
        case `false`
    }

    public init(jql: String? = nil, startAt: Int? = nil, maxResults: Int? = nil, fields: [String]? = nil, validateQuery: ValidateQuery? = nil, expand: [String]? = nil, properties: [String]? = nil, isFieldsByKeys: Bool? = nil) {
        self.jql = jql
        self.startAt = startAt
        self.maxResults = maxResults
        self.fields = fields
        self.validateQuery = validateQuery
        self.expand = expand
        self.properties = properties
        self.isFieldsByKeys = isFieldsByKeys
    }

    private enum CodingKeys: String, CodingKey {
        case jql
        case startAt
        case maxResults
        case fields
        case validateQuery
        case expand
        case properties
        case isFieldsByKeys = "fieldsByKeys"
    }
}

/// Details of a field that can be used in advanced searches.
public struct FieldReferenceData: Codable {
    /// The field identifier.
    public var value: String?
    /// The display name contains the following:
    /// 
    ///  *  for system fields, the field name. For example, `Summary`.
    ///  *  for collapsed custom fields, the field name followed by a hyphen and then the field name and field type. For example, `Component - Component[Dropdown]`.
    ///  *  for other custom fields, the field name followed by a hyphen and then the custom field ID. For example, `Component - cf[10061]`.
    public var displayName: String?
    /// Whether the field can be used in a query's `ORDER BY` clause.
    public var orderable: Orderable?
    /// Whether the content of this field can be searched.
    public var searchable: Searchable?
    /// Whether the field provide auto-complete suggestions.
    public var auto: Auto?
    /// If the item is a custom field, the ID of the custom field.
    public var cfid: String?
    /// The valid search operators for the field.
    public var operators: [String]?
    /// The data types of items in the field.
    public var types: [String]?

    /// Whether the field can be used in a query's `ORDER BY` clause.
    public enum Orderable: String, Codable, CaseIterable {
        case `true`
        case `false`
    }

    /// Whether the content of this field can be searched.
    public enum Searchable: String, Codable, CaseIterable {
        case `true`
        case `false`
    }

    /// Whether the field provide auto-complete suggestions.
    public enum Auto: String, Codable, CaseIterable {
        case `true`
        case `false`
    }

    public init(value: String? = nil, displayName: String? = nil, orderable: Orderable? = nil, searchable: Searchable? = nil, auto: Auto? = nil, cfid: String? = nil, operators: [String]? = nil, types: [String]? = nil) {
        self.value = value
        self.displayName = displayName
        self.orderable = orderable
        self.searchable = searchable
        self.auto = auto
        self.cfid = cfid
        self.operators = operators
        self.types = types
    }
}

/// Details of functions that can be used in advanced searches.
public struct FunctionReferenceData: Codable {
    /// The function identifier.
    public var value: String?
    /// The display name of the function.
    public var displayName: String?
    /// Whether the function can take a list of arguments.
    public var isList: IsList?
    /// The data types returned by the function.
    public var types: [String]?

    /// Whether the function can take a list of arguments.
    public enum IsList: String, Codable, CaseIterable {
        case `true`
        case `false`
    }

    public init(value: String? = nil, displayName: String? = nil, isList: IsList? = nil, types: [String]? = nil) {
        self.value = value
        self.displayName = displayName
        self.isList = isList
        self.types = types
    }
}

/// Lists of JQL reference data.
public struct JQLReferenceData: Codable {
    /// List of fields usable in JQL queries.
    public var visibleFieldNames: [FieldReferenceData]?
    /// List of functions usable in JQL queries.
    public var visibleFunctionNames: [FunctionReferenceData]?
    /// List of JQL query reserved words.
    public var jqlReservedWords: [String]?

    public init(visibleFieldNames: [FieldReferenceData]? = nil, visibleFunctionNames: [FunctionReferenceData]? = nil, jqlReservedWords: [String]? = nil) {
        self.visibleFieldNames = visibleFieldNames
        self.visibleFunctionNames = visibleFunctionNames
        self.jqlReservedWords = jqlReservedWords
    }
}

/// Details of how to filter and list search auto complete information.
public struct SearchAutoCompleteFilter: Codable {
    /// List of project IDs used to filter the visible field details returned.
    public var projectIDs: [Int]?
    /// Include collapsed fields for fields that have non-unique names.
    public var isIncludeCollapsedFields: Bool

    public init(projectIDs: [Int]? = nil, isIncludeCollapsedFields: Bool? = nil) {
        self.projectIDs = projectIDs
        self.isIncludeCollapsedFields = isIncludeCollapsedFields ?? false
    }

    private enum CodingKeys: String, CodingKey {
        case projectIDs = "projectIds"
        case isIncludeCollapsedFields = "includeCollapsedFields"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.projectIDs = try values.decodeIfPresent([Int].self, forKey: .projectIDs)
        self.isIncludeCollapsedFields = try values.decodeIfPresent(Bool.self, forKey: .isIncludeCollapsedFields) ?? false
    }
}

/// A field auto-complete suggestion.
public struct AutoCompleteSuggestion: Codable {
    /// The value of a suggested item.
    public var value: String?
    /// The display name of a suggested item. If `fieldValue` or `predicateValue` are provided, the matching text is highlighted with the HTML bold tag.
    public var displayName: String?

    public init(value: String? = nil, displayName: String? = nil) {
        self.value = value
        self.displayName = displayName
    }
}

/// The results from a JQL query.
public struct AutoCompleteSuggestions: Codable {
    /// The list of suggested item.
    public var results: [AutoCompleteSuggestion]?

    public init(results: [AutoCompleteSuggestion]? = nil) {
        self.results = results
    }
}

/// The JQL queries to be converted.
public struct JQLPersonalDataMigrationRequest: Codable {
    /// A list of queries with user identifiers. Maximum of 100 queries.
    public var queryStrings: [String]?

    public init(queryStrings: [String]? = nil) {
        self.queryStrings = queryStrings
    }
}

/// The converted JQL queries.
public struct ConvertedJQLQueries: Codable {
    /// The list of converted query strings with account IDs in place of user identifiers.
    public var queryStrings: [String]?
    /// List of queries containing user information that could not be mapped to an existing user
    public var queriesWithUnknownUsers: [JQLQueryWithUnknownUsers]?

    public init(queryStrings: [String]? = nil, queriesWithUnknownUsers: [JQLQueryWithUnknownUsers]? = nil) {
        self.queryStrings = queryStrings
        self.queriesWithUnknownUsers = queriesWithUnknownUsers
    }
}

/// JQL queries that contained users that could not be found
public struct JQLQueryWithUnknownUsers: Codable {
    /// The original query, for reference
    public var originalQuery: String?
    /// The converted query, with accountIDs instead of user identifiers, or 'unknown' for users that could not be found
    public var convertedQuery: String?

    public init(originalQuery: String? = nil, convertedQuery: String? = nil) {
        self.originalQuery = originalQuery
        self.convertedQuery = convertedQuery
    }
}

/// Details about a filter.
public struct Filter: Codable {
    /// The URL of the filter.
    public var this: URL?
    /// The unique identifier for the filter.
    public var id: String?
    /// The name of the filter. Must be unique.
    public var name: String
    /// A description of the filter.
    public var description: String?
    /// The user who owns the filter. This is defaulted to the creator of the filter, however Jira administrators can change the owner of a shared filter in the admin settings.
    public var owner: User?
    /// The JQL query for the filter. For example, *project = SSP AND issuetype = Bug*.
    public var jql: String?
    /// A URL to view the filter results in Jira, using the ID of the filter. For example, *https://your-domain.atlassian.net/issues/?filter=10100*.
    public var viewURL: URL?
    /// A URL to view the filter results in Jira, using the [Search for issues using JQL](#api-rest-api-3-filter-search-get) operation with the filter's JQL string to return the filter results. For example, *https://your-domain.atlassian.net/rest/api/3/search?jql=project+%3D+SSP+AND+issuetype+%3D+Bug*.
    public var searchURL: URL?
    /// Whether the filter is selected as a favorite.
    public var isFavourite: Bool?
    /// The count of how many users have selected this filter as a favorite, including the filter owner.
    public var favouritedCount: Int?
    /// The groups and projects that the filter is shared with.
    public var sharePermissions: [SharePermission]?
    /// The groups and projects that can edit the filter.
    public var editPermissions: [SharePermission]?
    /// A paginated list of the users that the filter is shared with. This includes users that are members of the groups or can browse the projects that the filter is shared with.
    public var sharedUsers: UserList?
    /// A paginated list of the users that are subscribed to the filter.
    public var subscriptions: FilterSubscriptionsList?

    public init(this: URL? = nil, id: String? = nil, name: String, description: String? = nil, owner: User? = nil, jql: String? = nil, viewURL: URL? = nil, searchURL: URL? = nil, isFavourite: Bool? = nil, favouritedCount: Int? = nil, sharePermissions: [SharePermission]? = nil, editPermissions: [SharePermission]? = nil, sharedUsers: UserList? = nil, subscriptions: FilterSubscriptionsList? = nil) {
        self.this = this
        self.id = id
        self.name = name
        self.description = description
        self.owner = owner
        self.jql = jql
        self.viewURL = viewURL
        self.searchURL = searchURL
        self.isFavourite = isFavourite
        self.favouritedCount = favouritedCount
        self.sharePermissions = sharePermissions
        self.editPermissions = editPermissions
        self.sharedUsers = sharedUsers
        self.subscriptions = subscriptions
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case id
        case name
        case description
        case owner
        case jql
        case viewURL = "viewUrl"
        case searchURL = "searchUrl"
        case isFavourite = "favourite"
        case favouritedCount
        case sharePermissions
        case editPermissions
        case sharedUsers
        case subscriptions
    }
}

/// Details of a user or group subscribing to a filter.
public struct FilterSubscription: Codable {
    /// The ID of the filter subscription.
    public var id: Int?
    /// The user subscribing to filter.
    public var user: User?
    /// The group subscribing to filter.
    public var group: GroupName?

    public init(id: Int? = nil, user: User? = nil, group: GroupName? = nil) {
        self.id = id
        self.user = user
        self.group = group
    }
}

/// A paginated list of subscriptions to a filter.
public struct FilterSubscriptionsList: Codable {
    /// The number of items on the page.
    public var size: Int?
    /// The list of items.
    public var items: [FilterSubscription]?
    /// The maximum number of results that could be on the page.
    public var maxResults: Int?
    /// The index of the first item returned on the page.
    public var startIndex: Int?
    /// The index of the last item returned on the page.
    public var endIndex: Int?

    public init(size: Int? = nil, items: [FilterSubscription]? = nil, maxResults: Int? = nil, startIndex: Int? = nil, endIndex: Int? = nil) {
        self.size = size
        self.items = items
        self.maxResults = maxResults
        self.startIndex = startIndex
        self.endIndex = endIndex
    }

    private enum CodingKeys: String, CodingKey {
        case size
        case items
        case maxResults = "max-results"
        case startIndex = "start-index"
        case endIndex = "end-index"
    }
}

/// The project issue type hierarchy.
public struct Hierarchy: Codable {
    /// The ID of the base level. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).
    public var baseLevelID: Int?
    /// Details about the hierarchy level.
    public var levels: [HierarchyLevel]?

    public init(baseLevelID: Int? = nil, levels: [HierarchyLevel]? = nil) {
        self.baseLevelID = baseLevelID
        self.levels = levels
    }

    private enum CodingKeys: String, CodingKey {
        case baseLevelID = "baseLevelId"
        case levels
    }
}

public struct HierarchyLevel: Codable {
    /// The ID of the hierarchy level. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).
    public var id: Int?
    /// The name of this hierarchy level.
    public var name: String?
    /// The ID of the level above this one in the hierarchy. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).
    public var aboveLevelID: Int?
    /// The ID of the level below this one in the hierarchy. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).
    public var belowLevelID: Int?
    /// The ID of the project configuration. This property is deprecated, see [Change oticen: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).
    public var projectConfigurationID: Int?
    /// The level of this item in the hierarchy.
    public var level: Int?
    /// The issue types available in this hierarchy level.
    public var issueTypeIDs: [Int]?
    /// The external UUID of the hierarchy level. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).
    public var externalUUID: String?
    public var globalHierarchyLevel: GlobalHierarchyLevel?

    public enum GlobalHierarchyLevel: String, Codable, CaseIterable {
        case subtask = "SUBTASK"
        case base = "BASE"
        case epic = "EPIC"
    }

    public init(id: Int? = nil, name: String? = nil, aboveLevelID: Int? = nil, belowLevelID: Int? = nil, projectConfigurationID: Int? = nil, level: Int? = nil, issueTypeIDs: [Int]? = nil, externalUUID: String? = nil, globalHierarchyLevel: GlobalHierarchyLevel? = nil) {
        self.id = id
        self.name = name
        self.aboveLevelID = aboveLevelID
        self.belowLevelID = belowLevelID
        self.projectConfigurationID = projectConfigurationID
        self.level = level
        self.issueTypeIDs = issueTypeIDs
        self.externalUUID = externalUUID
        self.globalHierarchyLevel = globalHierarchyLevel
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case aboveLevelID = "aboveLevelId"
        case belowLevelID = "belowLevelId"
        case projectConfigurationID = "projectConfigurationId"
        case level
        case issueTypeIDs = "issueTypeIds"
        case externalUUID = "externalUuid"
        case globalHierarchyLevel
    }
}

/// Details about a project.
public struct Project: Codable {
    /// Expand options that include additional project details in the response.
    public var expand: String?
    /// The URL of the project details.
    public var this: URL?
    /// The ID of the project.
    public var id: String?
    /// The key of the project.
    public var key: String?
    /// A brief description of the project.
    public var description: String?
    /// The username of the project lead.
    public var lead: User?
    /// List of the components contained in the project.
    public var components: [ProjectComponent]?
    /// List of the issue types available in the project.
    public var issueTypes: [IssueTypeDetails]?
    /// A link to information about this project, such as project documentation.
    public var url: String?
    /// An email address associated with the project.
    public var email: String?
    /// The default assignee when creating issues for this project.
    public var assigneeType: AssigneeType?
    /// The versions defined in the project. For more information, see [Create version](#api-rest-api-3-version-post).
    public var versions: [Version]?
    /// The name of the project.
    public var name: String?
    /// The name and self URL for each role defined in the project. For more information, see [Create project role](#api-rest-api-3-role-post).
    public var roles: [String: URL]?
    /// The URLs of the project's avatars.
    public var avatarURLs: AvatarURLsBean?
    /// The category the project belongs to.
    public var projectCategory: ProjectCategory?
    /// The [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes) of the project.
    public var projectTypeKey: ProjectTypeKey?
    /// Whether the project is simplified.
    public var isSimplified: Bool?
    /// The type of the project.
    public var style: Style?
    /// Whether the project is selected as a favorite.
    public var isFavourite: Bool?
    /// Whether the project is private.
    public var isPrivate: Bool?
    /// The issue type hierarchy for the project.
    public var issueTypeHierarchy: Hierarchy?
    /// User permissions on the project
    public var permissions: ProjectPermissions?
    /// Map of project properties
    public var properties: [String: AnyJSON]?
    /// Unique ID for next-gen projects.
    public var uuid: String?
    /// Insights about the project.
    public var insight: ProjectInsight?
    /// Whether the project is marked as deleted.
    public var isDeleted: Bool?
    /// The date when the project is deleted permanently.
    public var retentionTillDate: Date?
    /// The date when the project was marked as deleted.
    public var deletedDate: Date?
    /// The user who marked the project as deleted.
    public var deletedBy: User?
    /// Whether the project is archived.
    public var isArchived: Bool?
    /// The date when the project was archived.
    public var archivedDate: Date?
    /// The user who archived the project.
    public var archivedBy: User?
    /// The project landing page info.
    public var landingPageInfo: ProjectLandingPageInfo?

    /// The default assignee when creating issues for this project.
    public enum AssigneeType: String, Codable, CaseIterable {
        case projectLead = "PROJECT_LEAD"
        case unassigned = "UNASSIGNED"
    }

    /// The [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes) of the project.
    public enum ProjectTypeKey: String, Codable, CaseIterable {
        case software
        case serviceDesk = "service_desk"
        case business
    }

    /// The type of the project.
    public enum Style: String, Codable, CaseIterable {
        case classic
        case nextGen = "next-gen"
    }

    public init(expand: String? = nil, this: URL? = nil, id: String? = nil, key: String? = nil, description: String? = nil, lead: User? = nil, components: [ProjectComponent]? = nil, issueTypes: [IssueTypeDetails]? = nil, url: String? = nil, email: String? = nil, assigneeType: AssigneeType? = nil, versions: [Version]? = nil, name: String? = nil, roles: [String: URL]? = nil, avatarURLs: AvatarURLsBean? = nil, projectCategory: ProjectCategory? = nil, projectTypeKey: ProjectTypeKey? = nil, isSimplified: Bool? = nil, style: Style? = nil, isFavourite: Bool? = nil, isPrivate: Bool? = nil, issueTypeHierarchy: Hierarchy? = nil, permissions: ProjectPermissions? = nil, properties: [String: AnyJSON]? = nil, uuid: String? = nil, insight: ProjectInsight? = nil, isDeleted: Bool? = nil, retentionTillDate: Date? = nil, deletedDate: Date? = nil, deletedBy: User? = nil, isArchived: Bool? = nil, archivedDate: Date? = nil, archivedBy: User? = nil, landingPageInfo: ProjectLandingPageInfo? = nil) {
        self.expand = expand
        self.this = this
        self.id = id
        self.key = key
        self.description = description
        self.lead = lead
        self.components = components
        self.issueTypes = issueTypes
        self.url = url
        self.email = email
        self.assigneeType = assigneeType
        self.versions = versions
        self.name = name
        self.roles = roles
        self.avatarURLs = avatarURLs
        self.projectCategory = projectCategory
        self.projectTypeKey = projectTypeKey
        self.isSimplified = isSimplified
        self.style = style
        self.isFavourite = isFavourite
        self.isPrivate = isPrivate
        self.issueTypeHierarchy = issueTypeHierarchy
        self.permissions = permissions
        self.properties = properties
        self.uuid = uuid
        self.insight = insight
        self.isDeleted = isDeleted
        self.retentionTillDate = retentionTillDate
        self.deletedDate = deletedDate
        self.deletedBy = deletedBy
        self.isArchived = isArchived
        self.archivedDate = archivedDate
        self.archivedBy = archivedBy
        self.landingPageInfo = landingPageInfo
    }

    private enum CodingKeys: String, CodingKey {
        case expand
        case this = "self"
        case id
        case key
        case description
        case lead
        case components
        case issueTypes
        case url
        case email
        case assigneeType
        case versions
        case name
        case roles
        case avatarURLs = "avatarUrls"
        case projectCategory
        case projectTypeKey
        case isSimplified = "simplified"
        case style
        case isFavourite = "favourite"
        case isPrivate
        case issueTypeHierarchy
        case permissions
        case properties
        case uuid
        case insight
        case isDeleted = "deleted"
        case retentionTillDate
        case deletedDate
        case deletedBy
        case isArchived = "archived"
        case archivedDate
        case archivedBy
        case landingPageInfo
    }
}

/// A project category.
public struct ProjectCategory: Codable {
    /// The URL of the project category.
    public var this: URL?
    /// The ID of the project category.
    public var id: String?
    /// The name of the project category. Required on create, optional on update.
    public var name: String?
    /// The description of the project category.
    public var description: String?

    public init(this: URL? = nil, id: String? = nil, name: String? = nil, description: String? = nil) {
        self.this = this
        self.id = id
        self.name = name
        self.description = description
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case id
        case name
        case description
    }
}

/// Details about a project component.
public struct ProjectComponent: Codable {
    /// The URL of the component.
    public var this: URL?
    /// The unique identifier for the component.
    public var id: String?
    /// The unique name for the component in the project. Required when creating a component. Optional when updating a component. The maximum length is 255 characters.
    public var name: String?
    /// The description for the component. Optional when creating or updating a component.
    public var description: String?
    /// The user details for the component's lead user.
    public var lead: User?
    /// This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
    public var leadUserName: String?
    /// The accountId of the component's lead user. The accountId uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
    public var leadAccountID: String?
    /// The nominal user type used to determine the assignee for issues created with this component. See `realAssigneeType` for details on how the type of the user, and hence the user, assigned to issues is determined. Can take the following values:
    /// 
    ///  *  `PROJECT_LEAD` the assignee to any issues created with this component is nominally the lead for the project the component is in.
    ///  *  `COMPONENT_LEAD` the assignee to any issues created with this component is nominally the lead for the component.
    ///  *  `UNASSIGNED` an assignee is not set for issues created with this component.
    ///  *  `PROJECT_DEFAULT` the assignee to any issues created with this component is nominally the default assignee for the project that the component is in.
    /// 
    /// Default value: `PROJECT_DEFAULT`.
    /// Optional when creating or updating a component.
    public var assigneeType: AssigneeType?
    /// The details of the user associated with `assigneeType`, if any. See `realAssignee` for details of the user assigned to issues created with this component.
    public var assignee: User?
    /// The type of the assignee that is assigned to issues created with this component, when an assignee cannot be set from the `assigneeType`. For example, `assigneeType` is set to `COMPONENT_LEAD` but no component lead is set. This property is set to one of the following values:
    /// 
    ///  *  `PROJECT_LEAD` when `assigneeType` is `PROJECT_LEAD` and the project lead has permission to be assigned issues in the project that the component is in.
    ///  *  `COMPONENT_LEAD` when `assignee`Type is `COMPONENT_LEAD` and the component lead has permission to be assigned issues in the project that the component is in.
    ///  *  `UNASSIGNED` when `assigneeType` is `UNASSIGNED` and Jira is configured to allow unassigned issues.
    ///  *  `PROJECT_DEFAULT` when none of the preceding cases are true.
    public var realAssigneeType: RealAssigneeType?
    /// The user assigned to issues created with this component, when `assigneeType` does not identify a valid assignee.
    public var realAssignee: User?
    /// Whether a user is associated with `assigneeType`. For example, if the `assigneeType` is set to `COMPONENT_LEAD` but the component lead is not set, then `false` is returned.
    public var isAssigneeTypeValid: Bool?
    /// The key of the project the component is assigned to. Required when creating a component. Can't be updated.
    public var project: String?
    /// The ID of the project the component is assigned to.
    public var projectID: Int?

    /// The nominal user type used to determine the assignee for issues created with this component. See `realAssigneeType` for details on how the type of the user, and hence the user, assigned to issues is determined. Can take the following values:
    /// 
    ///  *  `PROJECT_LEAD` the assignee to any issues created with this component is nominally the lead for the project the component is in.
    ///  *  `COMPONENT_LEAD` the assignee to any issues created with this component is nominally the lead for the component.
    ///  *  `UNASSIGNED` an assignee is not set for issues created with this component.
    ///  *  `PROJECT_DEFAULT` the assignee to any issues created with this component is nominally the default assignee for the project that the component is in.
    /// 
    /// Default value: `PROJECT_DEFAULT`.
    /// Optional when creating or updating a component.
    public enum AssigneeType: String, Codable, CaseIterable {
        case projectDefault = "PROJECT_DEFAULT"
        case componentLead = "COMPONENT_LEAD"
        case projectLead = "PROJECT_LEAD"
        case unassigned = "UNASSIGNED"
    }

    /// The type of the assignee that is assigned to issues created with this component, when an assignee cannot be set from the `assigneeType`. For example, `assigneeType` is set to `COMPONENT_LEAD` but no component lead is set. This property is set to one of the following values:
    /// 
    ///  *  `PROJECT_LEAD` when `assigneeType` is `PROJECT_LEAD` and the project lead has permission to be assigned issues in the project that the component is in.
    ///  *  `COMPONENT_LEAD` when `assignee`Type is `COMPONENT_LEAD` and the component lead has permission to be assigned issues in the project that the component is in.
    ///  *  `UNASSIGNED` when `assigneeType` is `UNASSIGNED` and Jira is configured to allow unassigned issues.
    ///  *  `PROJECT_DEFAULT` when none of the preceding cases are true.
    public enum RealAssigneeType: String, Codable, CaseIterable {
        case projectDefault = "PROJECT_DEFAULT"
        case componentLead = "COMPONENT_LEAD"
        case projectLead = "PROJECT_LEAD"
        case unassigned = "UNASSIGNED"
    }

    public init(this: URL? = nil, id: String? = nil, name: String? = nil, description: String? = nil, lead: User? = nil, leadUserName: String? = nil, leadAccountID: String? = nil, assigneeType: AssigneeType? = nil, assignee: User? = nil, realAssigneeType: RealAssigneeType? = nil, realAssignee: User? = nil, isAssigneeTypeValid: Bool? = nil, project: String? = nil, projectID: Int? = nil) {
        self.this = this
        self.id = id
        self.name = name
        self.description = description
        self.lead = lead
        self.leadUserName = leadUserName
        self.leadAccountID = leadAccountID
        self.assigneeType = assigneeType
        self.assignee = assignee
        self.realAssigneeType = realAssigneeType
        self.realAssignee = realAssignee
        self.isAssigneeTypeValid = isAssigneeTypeValid
        self.project = project
        self.projectID = projectID
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case id
        case name
        case description
        case lead
        case leadUserName
        case leadAccountID = "leadAccountId"
        case assigneeType
        case assignee
        case realAssigneeType
        case realAssignee
        case isAssigneeTypeValid
        case project
        case projectID = "projectId"
    }
}

/// Additional details about a project.
public struct ProjectInsight: Codable {
    /// Total issue count.
    public var totalIssueCount: Int?
    /// The last issue update time.
    public var lastIssueUpdateTime: Date?

    public init(totalIssueCount: Int? = nil, lastIssueUpdateTime: Date? = nil) {
        self.totalIssueCount = totalIssueCount
        self.lastIssueUpdateTime = lastIssueUpdateTime
    }
}

public struct ProjectLandingPageInfo: Codable {
    public var url: String?
    public var projectKey: String?
    public var projectType: String?
    public var boardID: Int?
    public var isSimplified: Bool?

    public init(url: String? = nil, projectKey: String? = nil, projectType: String? = nil, boardID: Int? = nil, isSimplified: Bool? = nil) {
        self.url = url
        self.projectKey = projectKey
        self.projectType = projectType
        self.boardID = boardID
        self.isSimplified = isSimplified
    }

    private enum CodingKeys: String, CodingKey {
        case url
        case projectKey
        case projectType
        case boardID = "boardId"
        case isSimplified = "simplified"
    }
}

/// Permissions which a user has on a project.
public struct ProjectPermissions: Codable {
    /// Whether the logged user can edit the project.
    public var canEdit: Bool?

    public init(canEdit: Bool? = nil) {
        self.canEdit = canEdit
    }
}

/// Details about the roles in a project.
public struct ProjectRole: Codable {
    /// The URL the project role details.
    public var this: URL?
    /// The name of the project role.
    public var name: String?
    /// The ID of the project role.
    public var id: Int?
    /// The description of the project role.
    public var description: String?
    /// The list of users who act in this role.
    public var actors: [RoleActor]?
    /// The scope of the role. Indicated for roles associated with [next-gen projects](https://confluence.atlassian.com/x/loMyO).
    public var scope: Scope?
    /// The translated name of the project role.
    public var translatedName: String?
    /// Whether the calling user is part of this role.
    public var isCurrentUserRole: Bool?
    /// Whether the roles are configurable for this project.
    public var isRoleConfigurable: Bool?
    /// Whether this role is the admin role for the project.
    public var isAdmin: Bool?
    /// Whether this role is the default role for the project
    public var isDefault: Bool?

    public init(this: URL? = nil, name: String? = nil, id: Int? = nil, description: String? = nil, actors: [RoleActor]? = nil, scope: Scope? = nil, translatedName: String? = nil, isCurrentUserRole: Bool? = nil, isRoleConfigurable: Bool? = nil, isAdmin: Bool? = nil, isDefault: Bool? = nil) {
        self.this = this
        self.name = name
        self.id = id
        self.description = description
        self.actors = actors
        self.scope = scope
        self.translatedName = translatedName
        self.isCurrentUserRole = isCurrentUserRole
        self.isRoleConfigurable = isRoleConfigurable
        self.isAdmin = isAdmin
        self.isDefault = isDefault
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case name
        case id
        case description
        case actors
        case scope
        case translatedName
        case isCurrentUserRole = "currentUserRole"
        case isRoleConfigurable = "roleConfigurable"
        case isAdmin = "admin"
        case isDefault = "default"
    }
}

/// Details of the group associated with the role.
public struct ProjectRoleGroup: Codable {
    /// The display name of the group.
    public var displayName: String?
    /// The name of the group
    public var name: String?

    public init(displayName: String? = nil, name: String? = nil) {
        self.displayName = displayName
        self.name = name
    }
}

/// Details of the user associated with the role.
public struct ProjectRoleUser: Codable {
    /// The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. Returns *unknown* if the record is deleted and corrupted, for example, as the result of a server import.
    public var accountID: String?

    public init(accountID: String? = nil) {
        self.accountID = accountID
    }

    private enum CodingKeys: String, CodingKey {
        case accountID = "accountId"
    }
}

/// Details about a user assigned to a project role.
public struct RoleActor: Codable {
    /// The ID of the role actor.
    public var id: Int?
    /// The display name of the role actor. For users, depending on the user’s privacy setting, this may return an alternative value for the user's name.
    public var displayName: String?
    /// The type of role actor.
    public var type: `Type`?
    /// This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
    public var name: String?
    /// The avatar of the role actor.
    public var avatarURL: URL?
    public var actorUser: ProjectRoleUser?
    public var actorGroup: ProjectRoleGroup?

    /// The type of role actor.
    public enum `Type`: String, Codable, CaseIterable {
        case atlassianGroupRoleActor = "atlassian-group-role-actor"
        case atlassianUserRoleActor = "atlassian-user-role-actor"
    }

    public init(id: Int? = nil, displayName: String? = nil, type: `Type`? = nil, name: String? = nil, avatarURL: URL? = nil, actorUser: ProjectRoleUser? = nil, actorGroup: ProjectRoleGroup? = nil) {
        self.id = id
        self.displayName = displayName
        self.type = type
        self.name = name
        self.avatarURL = avatarURL
        self.actorUser = actorUser
        self.actorGroup = actorGroup
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case displayName
        case type
        case name
        case avatarURL = "avatarUrl"
        case actorUser
        case actorGroup
    }
}

/// Details of a share permission for the filter.
public struct SharePermission: Codable {
    /// The unique identifier of the share permission.
    public var id: Int?
    /// The type of share permission:
    /// 
    ///  *  `user` Shared with a user.
    ///  *  `group` Shared with a group. If set in a request, then specify `sharePermission.group` as well.
    ///  *  `project` Shared with a project. If set in a request, then specify `sharePermission.project` as well.
    ///  *  `projectRole` Share with a project role in a project. This value is not returned in responses. It is used in requests, where it needs to be specify with `projectId` and `projectRoleId`.
    ///  *  `global` Shared globally. If set in a request, no other `sharePermission` properties need to be specified.
    ///  *  `loggedin` Shared with all logged-in users. Note: This value is set in a request by specifying `authenticated` as the `type`.
    ///  *  `project-unknown` Shared with a project that the user does not have access to. Cannot be set in a request.
    public var type: `Type`
    /// The project that the filter is shared with. This is similar to the project object returned by [Get project](#api-rest-api-3-project-projectIdOrKey-get) but it contains a subset of the properties, which are: `self`, `id`, `key`, `assigneeType`, `name`, `roles`, `avatarUrls`, `projectType`, `simplified`.
    /// For a request, specify the `id` for the project.
    public var project: Project?
    /// The project role that the filter is shared with.
    /// For a request, specify the `id` for the role. You must also specify the `project` object and `id` for the project that the role is in.
    public var role: ProjectRole?
    /// The group that the filter is shared with. For a request, specify the `name` property for the group.
    public var group: GroupName?
    /// The user account ID that the filter is shared with. For a request, specify the `accountId` property for the user.
    public var user: UserBean?

    /// The type of share permission:
    /// 
    ///  *  `user` Shared with a user.
    ///  *  `group` Shared with a group. If set in a request, then specify `sharePermission.group` as well.
    ///  *  `project` Shared with a project. If set in a request, then specify `sharePermission.project` as well.
    ///  *  `projectRole` Share with a project role in a project. This value is not returned in responses. It is used in requests, where it needs to be specify with `projectId` and `projectRoleId`.
    ///  *  `global` Shared globally. If set in a request, no other `sharePermission` properties need to be specified.
    ///  *  `loggedin` Shared with all logged-in users. Note: This value is set in a request by specifying `authenticated` as the `type`.
    ///  *  `project-unknown` Shared with a project that the user does not have access to. Cannot be set in a request.
    public enum `Type`: String, Codable, CaseIterable {
        case user
        case group
        case project
        case projectRole
        case global
        case loggedin
        case authenticated
        case projectUnknown = "project-unknown"
    }

    public init(id: Int? = nil, type: `Type`, project: Project? = nil, role: ProjectRole? = nil, group: GroupName? = nil, user: UserBean? = nil) {
        self.id = id
        self.type = type
        self.project = project
        self.role = role
        self.group = group
        self.user = user
    }
}

public struct UserBean: Codable {
    /// This property is deprecated in favor of `accountId` because of privacy changes. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
    /// The key of the user.
    public var key: String?
    /// The URL of the user.
    public var this: URL?
    /// This property is deprecated in favor of `accountId` because of privacy changes. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
    /// The username of the user.
    public var name: String?
    /// The display name of the user. Depending on the user’s privacy setting, this may return an alternative value.
    public var displayName: String?
    /// Whether the user is active.
    public var isActive: Bool?
    /// The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
    public var accountID: String?
    /// The avatars of the user.
    public var avatarURLs: UserBeanAvatarURLs?

    public init(key: String? = nil, this: URL? = nil, name: String? = nil, displayName: String? = nil, isActive: Bool? = nil, accountID: String? = nil, avatarURLs: UserBeanAvatarURLs? = nil) {
        self.key = key
        self.this = this
        self.name = name
        self.displayName = displayName
        self.isActive = isActive
        self.accountID = accountID
        self.avatarURLs = avatarURLs
    }

    private enum CodingKeys: String, CodingKey {
        case key
        case this = "self"
        case name
        case displayName
        case isActive = "active"
        case accountID = "accountId"
        case avatarURLs = "avatarUrls"
    }
}

public struct UserBeanAvatarURLs: Codable {
    /// The URL of the user's 16x16 pixel avatar.
    public var _16x16: URL?
    /// The URL of the user's 32x32 pixel avatar.
    public var _32x32: URL?
    /// The URL of the user's 48x48 pixel avatar.
    public var _48x48: URL?
    /// The URL of the user's 24x24 pixel avatar.
    public var _24x24: URL?

    public init(_16x16: URL? = nil, _32x32: URL? = nil, _48x48: URL? = nil, _24x24: URL? = nil) {
        self._16x16 = _16x16
        self._32x32 = _32x32
        self._48x48 = _48x48
        self._24x24 = _24x24
    }

    private enum CodingKeys: String, CodingKey {
        case _16x16 = "16x16"
        case _32x32 = "32x32"
        case _48x48 = "48x48"
        case _24x24 = "24x24"
    }
}

/// A paginated list of users sharing the filter. This includes users that are members of the groups or can browse the projects that the filter is shared with.
public struct UserList: Codable {
    /// The number of items on the page.
    public var size: Int?
    /// The list of items.
    public var items: [User]?
    /// The maximum number of results that could be on the page.
    public var maxResults: Int?
    /// The index of the first item returned on the page.
    public var startIndex: Int?
    /// The index of the last item returned on the page.
    public var endIndex: Int?

    public init(size: Int? = nil, items: [User]? = nil, maxResults: Int? = nil, startIndex: Int? = nil, endIndex: Int? = nil) {
        self.size = size
        self.items = items
        self.maxResults = maxResults
        self.startIndex = startIndex
        self.endIndex = endIndex
    }

    private enum CodingKeys: String, CodingKey {
        case size
        case items
        case maxResults = "max-results"
        case startIndex = "start-index"
        case endIndex = "end-index"
    }
}

/// Details about a project version.
public struct Version: Codable {
    /// Use [expand](em>#expansion) to include additional information about version in the response. This parameter accepts a comma-separated list. Expand options include:
    /// 
    ///  *  `operations` Returns the list of operations available for this version.
    ///  *  `issuesstatus` Returns the count of issues in this version for each of the status categories *to do*, *in progress*, *done*, and *unmapped*. The *unmapped* property contains a count of issues with a status other than *to do*, *in progress*, and *done*.
    /// 
    /// Optional for create and update.
    public var expand: String?
    /// The URL of the version.
    public var this: URL?
    /// The ID of the version.
    public var id: String?
    /// The description of the version. Optional when creating or updating a version.
    public var description: String?
    /// The unique name of the version. Required when creating a version. Optional when updating a version. The maximum length is 255 characters.
    public var name: String?
    /// Indicates that the version is archived. Optional when creating or updating a version.
    public var isArchived: Bool?
    /// Indicates that the version is released. If the version is released a request to release again is ignored. Not applicable when creating a version. Optional when updating a version.
    public var isReleased: Bool?
    /// The start date of the version. Expressed in ISO 8601 format (yyyy-mm-dd). Optional when creating or updating a version.
    public var startDate: NaiveDate?
    /// The release date of the version. Expressed in ISO 8601 format (yyyy-mm-dd). Optional when creating or updating a version.
    public var releaseDate: NaiveDate?
    /// Indicates that the version is overdue.
    public var isOverdue: Bool?
    /// The date on which work on this version is expected to start, expressed in the instance's *Day/Month/Year Format* date format.
    public var userStartDate: String?
    /// The date on which work on this version is expected to finish, expressed in the instance's *Day/Month/Year Format* date format.
    public var userReleaseDate: String?
    /// Deprecated. Use `projectId`.
    public var project: String?
    /// The ID of the project to which this version is attached. Required when creating a version. Not applicable when updating a version.
    public var projectID: Int?
    /// The URL of the self link to the version to which all unfixed issues are moved when a version is released. Not applicable when creating a version. Optional when updating a version.
    public var moveUnfixedIssuesTo: URL?
    /// If the expand option `operations` is used, returns the list of operations available for this version.
    public var operations: [SimpleLink]?
    /// If the expand option `issuesstatus` is used, returns the count of issues in this version for each of the status categories *to do*, *in progress*, *done*, and *unmapped*. The *unmapped* property contains a count of issues with a status other than *to do*, *in progress*, and *done*.
    public var issuesStatusForFixVersion: VersionIssuesStatus?

    public init(expand: String? = nil, this: URL? = nil, id: String? = nil, description: String? = nil, name: String? = nil, isArchived: Bool? = nil, isReleased: Bool? = nil, startDate: NaiveDate? = nil, releaseDate: NaiveDate? = nil, isOverdue: Bool? = nil, userStartDate: String? = nil, userReleaseDate: String? = nil, project: String? = nil, projectID: Int? = nil, moveUnfixedIssuesTo: URL? = nil, operations: [SimpleLink]? = nil, issuesStatusForFixVersion: VersionIssuesStatus? = nil) {
        self.expand = expand
        self.this = this
        self.id = id
        self.description = description
        self.name = name
        self.isArchived = isArchived
        self.isReleased = isReleased
        self.startDate = startDate
        self.releaseDate = releaseDate
        self.isOverdue = isOverdue
        self.userStartDate = userStartDate
        self.userReleaseDate = userReleaseDate
        self.project = project
        self.projectID = projectID
        self.moveUnfixedIssuesTo = moveUnfixedIssuesTo
        self.operations = operations
        self.issuesStatusForFixVersion = issuesStatusForFixVersion
    }

    private enum CodingKeys: String, CodingKey {
        case expand
        case this = "self"
        case id
        case description
        case name
        case isArchived = "archived"
        case isReleased = "released"
        case startDate
        case releaseDate
        case isOverdue = "overdue"
        case userStartDate
        case userReleaseDate
        case project
        case projectID = "projectId"
        case moveUnfixedIssuesTo
        case operations
        case issuesStatusForFixVersion
    }
}

/// Counts of the number of issues in various statuses.
public struct VersionIssuesStatus: Codable {
    /// Count of issues with a status other than *to do*, *in progress*, and *done*.
    public var unmapped: Int?
    /// Count of issues with status *to do*.
    public var toDo: Int?
    /// Count of issues with status *in progress*.
    public var inProgress: Int?
    /// Count of issues with status *done*.
    public var done: Int?

    public init(unmapped: Int? = nil, toDo: Int? = nil, inProgress: Int? = nil, done: Int? = nil) {
        self.unmapped = unmapped
        self.toDo = toDo
        self.inProgress = inProgress
        self.done = done
    }
}

/// Details of a filter.
public struct FilterDetails: Codable {
    /// Expand options that include additional filter details in the response.
    public var expand: String?
    /// The URL of the filter.
    public var this: URL?
    /// The unique identifier for the filter.
    public var id: String?
    /// The name of the filter.
    public var name: String
    /// The description of the filter.
    public var description: String?
    /// The user who owns the filter. Defaults to the creator of the filter, however, Jira administrators can change the owner of a shared filter in the admin settings.
    public var owner: User?
    /// The JQL query for the filter. For example, *project = SSP AND issuetype = Bug*.
    public var jql: String?
    /// A URL to view the filter results in Jira, using the ID of the filter. For example, *https://your-domain.atlassian.net/issues/?filter=10100*.
    public var viewURL: URL?
    /// A URL to view the filter results in Jira, using the [Search for issues using JQL](#api-rest-api-3-filter-search-get) operation with the filter's JQL string to return the filter results. For example, *https://your-domain.atlassian.net/rest/api/3/search?jql=project+%3D+SSP+AND+issuetype+%3D+Bug*.
    public var searchURL: URL?
    /// Whether the filter is selected as a favorite by any users, not including the filter owner.
    public var isFavourite: Bool?
    /// The count of how many users have selected this filter as a favorite, including the filter owner.
    public var favouritedCount: Int?
    /// The groups and projects that the filter is shared with. This can be specified when updating a filter, but not when creating a filter.
    public var sharePermissions: [SharePermission]?
    /// The groups and projects that can edit the filter. This can be specified when updating a filter, but not when creating a filter.
    public var editPermissions: [SharePermission]?
    /// The users that are subscribed to the filter.
    public var subscriptions: [FilterSubscription]?

    public init(expand: String? = nil, this: URL? = nil, id: String? = nil, name: String, description: String? = nil, owner: User? = nil, jql: String? = nil, viewURL: URL? = nil, searchURL: URL? = nil, isFavourite: Bool? = nil, favouritedCount: Int? = nil, sharePermissions: [SharePermission]? = nil, editPermissions: [SharePermission]? = nil, subscriptions: [FilterSubscription]? = nil) {
        self.expand = expand
        self.this = this
        self.id = id
        self.name = name
        self.description = description
        self.owner = owner
        self.jql = jql
        self.viewURL = viewURL
        self.searchURL = searchURL
        self.isFavourite = isFavourite
        self.favouritedCount = favouritedCount
        self.sharePermissions = sharePermissions
        self.editPermissions = editPermissions
        self.subscriptions = subscriptions
    }

    private enum CodingKeys: String, CodingKey {
        case expand
        case this = "self"
        case id
        case name
        case description
        case owner
        case jql
        case viewURL = "viewUrl"
        case searchURL = "searchUrl"
        case isFavourite = "favourite"
        case favouritedCount
        case sharePermissions
        case editPermissions
        case subscriptions
    }
}

/// A page of items.
public struct PageBeanFilterDetails: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [FilterDetails]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [FilterDetails]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// Details of the scope of the default sharing for new filters and dashboards.
public struct DefaultShareScope: Codable {
    /// The scope of the default sharing for new filters and dashboards:
    /// 
    ///  *  `AUTHENTICATED` Shared with all logged-in users.
    ///  *  `GLOBAL` Shared with all logged-in users. This shows as `AUTHENTICATED` in the response.
    ///  *  `PRIVATE` Not shared with any users.
    public var scope: Scope

    /// The scope of the default sharing for new filters and dashboards:
    /// 
    ///  *  `AUTHENTICATED` Shared with all logged-in users.
    ///  *  `GLOBAL` Shared with all logged-in users. This shows as `AUTHENTICATED` in the response.
    ///  *  `PRIVATE` Not shared with any users.
    public enum Scope: String, Codable, CaseIterable {
        case global = "GLOBAL"
        case authenticated = "AUTHENTICATED"
        case `private` = "PRIVATE"
    }

    public init(scope: Scope) {
        self.scope = scope
    }
}

public struct SharePermissionInputBean: Codable {
    /// The type of the share permission.Specify the type as follows:
    /// 
    ///  *  `user` Share with a user.
    ///  *  `group` Share with a group. Specify `groupname` as well.
    ///  *  `project` Share with a project. Specify `projectId` as well.
    ///  *  `projectRole` Share with a project role in a project. Specify `projectId` and `projectRoleId` as well.
    ///  *  `global` Share globally, including anonymous users. If set, this type overrides all existing share permissions and must be deleted before any non-global share permissions is set.
    ///  *  `authenticated` Share with all logged-in users. This shows as `loggedin` in the response. If set, this type overrides all existing share permissions and must be deleted before any non-global share permissions is set.
    public var type: `Type`
    /// The ID of the project to share the filter with. Set `type` to `project`.
    public var projectID: String?
    /// The name of the group to share the filter with. Set `type` to `group`.
    public var groupname: String?
    /// The ID of the project role to share the filter with. Set `type` to `projectRole` and the `projectId` for the project that the role is in.
    public var projectRoleID: String?
    /// The user account ID that the filter is shared with. For a request, specify the `accountId` property for the user.
    public var accountID: String?
    /// The rights for the share permission.
    public var rights: Int?

    /// The type of the share permission.Specify the type as follows:
    /// 
    ///  *  `user` Share with a user.
    ///  *  `group` Share with a group. Specify `groupname` as well.
    ///  *  `project` Share with a project. Specify `projectId` as well.
    ///  *  `projectRole` Share with a project role in a project. Specify `projectId` and `projectRoleId` as well.
    ///  *  `global` Share globally, including anonymous users. If set, this type overrides all existing share permissions and must be deleted before any non-global share permissions is set.
    ///  *  `authenticated` Share with all logged-in users. This shows as `loggedin` in the response. If set, this type overrides all existing share permissions and must be deleted before any non-global share permissions is set.
    public enum `Type`: String, Codable, CaseIterable {
        case user
        case project
        case group
        case projectRole
        case global
        case authenticated
    }

    public init(type: `Type`, projectID: String? = nil, groupname: String? = nil, projectRoleID: String? = nil, accountID: String? = nil, rights: Int? = nil) {
        self.type = type
        self.projectID = projectID
        self.groupname = groupname
        self.projectRoleID = projectRoleID
        self.accountID = accountID
        self.rights = rights
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case projectID = "projectId"
        case groupname
        case projectRoleID = "projectRoleId"
        case accountID = "accountId"
        case rights
    }
}

public struct IDBean: Codable {
    /// The ID of the permission scheme to associate with the project. Use the [Get all permission schemes](#api-rest-api-3-permissionscheme-get) resource to get a list of permission scheme IDs.
    public var id: Int

    public init(id: Int) {
        self.id = id
    }
}

/// Details about permissions.
public struct Permissions: Codable {
    /// List of permissions.
    public var permissions: [String: UserPermission]?

    public init(permissions: [String: UserPermission]? = nil) {
        self.permissions = permissions
    }
}

/// Details of a permission and its availability to a user.
public struct UserPermission: Codable {
    /// The ID of the permission. Either `id` or `key` must be specified. Use [Get all permissions](#api-rest-api-3-permissions-get) to get the list of permissions.
    public var id: String?
    /// The key of the permission. Either `id` or `key` must be specified. Use [Get all permissions](#api-rest-api-3-permissions-get) to get the list of permissions.
    public var key: String?
    /// The name of the permission.
    public var name: String?
    /// The type of the permission.
    public var type: `Type`?
    /// The description of the permission.
    public var description: String?
    /// Whether the permission is available to the user in the queried context.
    public var havePermission: Bool?
    /// Indicate whether the permission key is deprecated. Note that deprecated keys cannot be used in the `permissions parameter of Get my permissions. Deprecated keys are not returned by Get all permissions.`
    public var isDeprecatedKey: Bool?

    /// The type of the permission.
    public enum `Type`: String, Codable, CaseIterable {
        case global = "GLOBAL"
        case project = "PROJECT"
    }

    public init(id: String? = nil, key: String? = nil, name: String? = nil, type: `Type`? = nil, description: String? = nil, havePermission: Bool? = nil, isDeprecatedKey: Bool? = nil) {
        self.id = id
        self.key = key
        self.name = name
        self.type = type
        self.description = description
        self.havePermission = havePermission
        self.isDeprecatedKey = isDeprecatedKey
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case key
        case name
        case type
        case description
        case havePermission
        case isDeprecatedKey = "deprecatedKey"
    }
}

/// Details of global permissions to look up and project permissions with associated projects and issues to look up.
public struct BulkPermissionsRequestBean: Codable {
    /// Project permissions with associated projects and issues to look up.
    public var projectPermissions: [BulkProjectPermissions]?
    /// Global permissions to look up.
    public var globalPermissions: [String]?
    /// The account ID of a user.
    public var accountID: String?

    public init(projectPermissions: [BulkProjectPermissions]? = nil, globalPermissions: [String]? = nil, accountID: String? = nil) {
        self.projectPermissions = projectPermissions
        self.globalPermissions = globalPermissions
        self.accountID = accountID
    }

    private enum CodingKeys: String, CodingKey {
        case projectPermissions
        case globalPermissions
        case accountID = "accountId"
    }
}

/// Details of project permissions and associated issues and projects to look up.
public struct BulkProjectPermissions: Codable {
    /// List of issue IDs.
    public var issues: [Int]?
    /// List of project IDs.
    public var projects: [Int]?
    /// List of project permissions.
    public var permissions: [String]

    public init(issues: [Int]? = nil, projects: [Int]? = nil, permissions: [String]) {
        self.issues = issues
        self.projects = projects
        self.permissions = permissions
    }
}

/// Details of global and project permissions granted to the user.
public struct BulkPermissionGrants: Codable {
    /// List of project permissions and the projects and issues those permissions provide access to.
    public var projectPermissions: [BulkProjectPermissionGrants]
    /// List of permissions granted to the user.
    public var globalPermissions: [String]

    public init(projectPermissions: [BulkProjectPermissionGrants], globalPermissions: [String]) {
        self.projectPermissions = projectPermissions
        self.globalPermissions = globalPermissions
    }
}

/// List of project permissions and the projects and issues those permissions grant access to.
public struct BulkProjectPermissionGrants: Codable {
    /// A project permission,
    public var permission: String
    /// IDs of the issues the user has the permission for.
    public var issues: [Int]
    /// IDs of the projects the user has the permission for.
    public var projects: [Int]

    public init(permission: String, issues: [Int], projects: [Int]) {
        self.permission = permission
        self.issues = issues
        self.projects = projects
    }
}

public struct PermissionsKeysBean: Codable {
    /// A list of permission keys.
    public var permissions: [String]

    public init(permissions: [String]) {
        self.permissions = permissions
    }
}

/// A list of projects in which a user is granted permissions.
public struct PermittedProjects: Codable {
    /// A list of projects.
    public var projects: [ProjectIdentifierBean]?

    public init(projects: [ProjectIdentifierBean]? = nil) {
        self.projects = projects
    }
}

/// The identifiers for a project.
public struct ProjectIdentifierBean: Codable {
    /// The ID of the project.
    public var id: Int?
    /// The key of the project.
    public var key: String?

    public init(id: Int? = nil, key: String? = nil) {
        self.id = id
        self.key = key
    }
}

/// Details of a locale.
public struct Locale: Codable {
    /// The locale code. The Java the locale format is used: a two character language code (ISO 639), an underscore, and two letter country code (ISO 3166). For example, en\_US represents a locale of English (United States). Required on create.
    public var locale: String?

    public init(locale: String? = nil) {
        self.locale = locale
    }
}

public struct UserMigrationBean: Codable {
    public var key: String?
    public var username: String?
    public var accountID: String?

    public init(key: String? = nil, username: String? = nil, accountID: String? = nil) {
        self.key = key
        self.username = username
        self.accountID = accountID
    }

    private enum CodingKeys: String, CodingKey {
        case key
        case username
        case accountID = "accountId"
    }
}

public struct UnrestrictedUserEmail: Codable {
    /// The accountId of the user
    public var accountID: String?
    /// The email of the user
    public var email: String?

    public init(accountID: String? = nil, email: String? = nil) {
        self.accountID = accountID
        self.email = email
    }

    private enum CodingKeys: String, CodingKey {
        case accountID = "accountId"
        case email
    }
}

/// Bulk issue property update request details.
public struct BulkIssuePropertyUpdateRequest: Codable {
    /// The value of the property. The value must be a [valid](https://tools.ietf.org/html/rfc4627), non-empty JSON blob. The maximum length is 32768 characters.
    public var value: AnyJSON?
    /// EXPERIMENTAL. The Jira expression to calculate the value of the property. The value of the expression must be an object that can be converted to JSON, such as a number, boolean, string, list, or map. The context variables available to the expression are `issue` and `user`. Issues for which the expression returns a value whose JSON representation is longer than 32768 characters are ignored.
    public var expression: String?
    /// The bulk operation filter.
    public var filter: IssueFilterForBulkPropertySet?

    public init(value: AnyJSON? = nil, expression: String? = nil, filter: IssueFilterForBulkPropertySet? = nil) {
        self.value = value
        self.expression = expression
        self.filter = filter
    }
}

/// Bulk operation filter details.
public struct IssueFilterForBulkPropertySet: Codable {
    /// List of issues to perform the bulk operation on.
    public var entityIDs: [Int]?
    /// The value of properties to perform the bulk operation on.
    public var currentValue: AnyJSON?
    /// Whether the bulk operation occurs only when the property is present on or absent from an issue.
    public var hasProperty: Bool?

    public init(entityIDs: [Int]? = nil, currentValue: AnyJSON? = nil, hasProperty: Bool? = nil) {
        self.entityIDs = entityIDs
        self.currentValue = currentValue
        self.hasProperty = hasProperty
    }

    private enum CodingKeys: String, CodingKey {
        case entityIDs = "entityIds"
        case currentValue
        case hasProperty
    }
}

/// Bulk operation filter details.
public struct IssueFilterForBulkPropertyDelete: Codable {
    /// List of issues to perform the bulk delete operation on.
    public var entityIDs: [Int]?
    /// The value of properties to perform the bulk operation on.
    public var currentValue: AnyJSON?

    public init(entityIDs: [Int]? = nil, currentValue: AnyJSON? = nil) {
        self.entityIDs = entityIDs
        self.currentValue = currentValue
    }

    private enum CodingKeys: String, CodingKey {
        case entityIDs = "entityIds"
        case currentValue
    }
}

/// Lists of issues and entity properties. See [Entity properties](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/) for more information.
public struct IssueEntityProperties: Codable {
    /// A list of entity property IDs.
    public var entitiesIDs: [Int]?
    /// A list of entity property keys and values.
    public var properties: [String: JSONNode]?

    public init(entitiesIDs: [Int]? = nil, properties: [String: JSONNode]? = nil) {
        self.entitiesIDs = entitiesIDs
        self.properties = properties
    }

    private enum CodingKeys: String, CodingKey {
        case entitiesIDs = "entitiesIds"
        case properties
    }
}

public struct JSONNode: Codable {
    public var elements: Elements?
    public var isPojo: Bool?
    public var isNumber: Bool?
    public var isIntegralNumber: Bool?
    public var isFloatingPointNumber: Bool?
    public var isInt: Bool?
    public var isLong: Bool?
    public var isDouble: Bool?
    public var isBigDecimal: Bool?
    public var isBigInteger: Bool?
    public var isTextual: Bool?
    public var isBoolean: Bool?
    public var isBinary: Bool?
    public var isContainerNode: Bool?
    public var isMissingNode: Bool?
    public var isObject: Bool?
    public var isValueNode: Bool?
    public var numberValue: Double?
    public var numberType: NumberType?
    public var intValue: Int?
    public var longValue: Int?
    public var bigIntegerValue: Int?
    public var doubleValue: Double?
    public var decimalValue: Double?
    public var isBooleanValue: Bool?
    public var binaryValue: [String]?
    public var valueAsInt: Int?
    public var valueAsLong: Int?
    public var valueAsDouble: Double?
    public var isValueAsBoolean: Bool?
    public var textValue: String?
    public var valueAsText: String?
    public var fieldNames: FieldNames?
    public var isArray: Bool?
    public var fields: Fields?
    public var isNull: Bool?

    public struct Elements: Codable {
        public init() {}
    }

    public enum NumberType: String, Codable, CaseIterable {
        case int = "INT"
        case long = "LONG"
        case bigInteger = "BIG_INTEGER"
        case float = "FLOAT"
        case double = "DOUBLE"
        case bigDecimal = "BIG_DECIMAL"
    }

    public struct FieldNames: Codable {
        public init() {}
    }

    public struct Fields: Codable {
        public init() {}
    }

    public init(elements: Elements? = nil, isPojo: Bool? = nil, isNumber: Bool? = nil, isIntegralNumber: Bool? = nil, isFloatingPointNumber: Bool? = nil, isInt: Bool? = nil, isLong: Bool? = nil, isDouble: Bool? = nil, isBigDecimal: Bool? = nil, isBigInteger: Bool? = nil, isTextual: Bool? = nil, isBoolean: Bool? = nil, isBinary: Bool? = nil, isContainerNode: Bool? = nil, isMissingNode: Bool? = nil, isObject: Bool? = nil, isValueNode: Bool? = nil, numberValue: Double? = nil, numberType: NumberType? = nil, intValue: Int? = nil, longValue: Int? = nil, bigIntegerValue: Int? = nil, doubleValue: Double? = nil, decimalValue: Double? = nil, isBooleanValue: Bool? = nil, binaryValue: [String]? = nil, valueAsInt: Int? = nil, valueAsLong: Int? = nil, valueAsDouble: Double? = nil, isValueAsBoolean: Bool? = nil, textValue: String? = nil, valueAsText: String? = nil, fieldNames: FieldNames? = nil, isArray: Bool? = nil, fields: Fields? = nil, isNull: Bool? = nil) {
        self.elements = elements
        self.isPojo = isPojo
        self.isNumber = isNumber
        self.isIntegralNumber = isIntegralNumber
        self.isFloatingPointNumber = isFloatingPointNumber
        self.isInt = isInt
        self.isLong = isLong
        self.isDouble = isDouble
        self.isBigDecimal = isBigDecimal
        self.isBigInteger = isBigInteger
        self.isTextual = isTextual
        self.isBoolean = isBoolean
        self.isBinary = isBinary
        self.isContainerNode = isContainerNode
        self.isMissingNode = isMissingNode
        self.isObject = isObject
        self.isValueNode = isValueNode
        self.numberValue = numberValue
        self.numberType = numberType
        self.intValue = intValue
        self.longValue = longValue
        self.bigIntegerValue = bigIntegerValue
        self.doubleValue = doubleValue
        self.decimalValue = decimalValue
        self.isBooleanValue = isBooleanValue
        self.binaryValue = binaryValue
        self.valueAsInt = valueAsInt
        self.valueAsLong = valueAsLong
        self.valueAsDouble = valueAsDouble
        self.isValueAsBoolean = isValueAsBoolean
        self.textValue = textValue
        self.valueAsText = valueAsText
        self.fieldNames = fieldNames
        self.isArray = isArray
        self.fields = fields
        self.isNull = isNull
    }

    private enum CodingKeys: String, CodingKey {
        case elements
        case isPojo = "pojo"
        case isNumber = "number"
        case isIntegralNumber = "integralNumber"
        case isFloatingPointNumber = "floatingPointNumber"
        case isInt = "int"
        case isLong = "long"
        case isDouble = "double"
        case isBigDecimal = "bigDecimal"
        case isBigInteger = "bigInteger"
        case isTextual = "textual"
        case isBoolean = "boolean"
        case isBinary = "binary"
        case isContainerNode = "containerNode"
        case isMissingNode = "missingNode"
        case isObject = "object"
        case isValueNode = "valueNode"
        case numberValue
        case numberType
        case intValue
        case longValue
        case bigIntegerValue
        case doubleValue
        case decimalValue
        case isBooleanValue = "booleanValue"
        case binaryValue
        case valueAsInt
        case valueAsLong
        case valueAsDouble
        case isValueAsBoolean = "valueAsBoolean"
        case textValue
        case valueAsText
        case fieldNames
        case isArray = "array"
        case fields
        case isNull = "null"
    }
}

/// An issue ID with entity property values. See [Entity properties](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/) for more information.
public struct IssueEntityPropertiesForMultiUpdate: Codable {
    /// The ID of the issue.
    public var issueID: Int?
    /// Entity properties to set on the issue. The maximum length of an issue property value is 32768 characters.
    public var properties: [String: JSONNode]?

    public init(issueID: Int? = nil, properties: [String: JSONNode]? = nil) {
        self.issueID = issueID
        self.properties = properties
    }
}

/// A list of issues and their respective properties to set or update. See [Entity properties](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/) for more information.
public struct MultiIssueEntityProperties: Codable {
    /// A list of issue IDs and their respective properties.
    public var issues: [IssueEntityPropertiesForMultiUpdate]?

    public init(issues: [IssueEntityPropertiesForMultiUpdate]? = nil) {
        self.issues = issues
    }
}

/// List of issue level security items in a project.
public struct ProjectIssueSecurityLevels: Codable {
    /// Issue level security items list.
    public var levels: [SecurityLevel]

    public init(levels: [SecurityLevel]) {
        self.levels = levels
    }
}

/// Details of an issue level security item.
public struct SecurityLevel: Codable {
    /// The URL of the issue level security item.
    public var this: String?
    /// The ID of the issue level security item.
    public var id: String?
    /// The description of the issue level security item.
    public var description: String?
    /// The name of the issue level security item.
    public var name: String?

    public init(this: String? = nil, id: String? = nil, description: String? = nil, name: String? = nil) {
        self.this = this
        self.id = id
        self.description = description
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case id
        case description
        case name
    }
}

/// List of issues and JQL queries.
public struct IssuesAndJQLQueries: Codable {
    /// A list of JQL queries.
    public var jqls: [String]
    /// A list of issue IDs.
    public var issueIDs: [Int]

    public init(jqls: [String], issueIDs: [Int]) {
        self.jqls = jqls
        self.issueIDs = issueIDs
    }

    private enum CodingKeys: String, CodingKey {
        case jqls
        case issueIDs = "issueIds"
    }
}

/// A list of matched issues or errors for each JQL query, in the order the JQL queries were passed.
public struct IssueMatches: Codable {
    public var matches: [IssueMatchesForJQL]

    public init(matches: [IssueMatchesForJQL]) {
        self.matches = matches
    }
}

/// A list of the issues matched to a JQL query or details of errors encountered during matching.
public struct IssueMatchesForJQL: Codable {
    /// A list of issue IDs.
    public var matchedIssues: [Int]
    /// A list of errors.
    public var errors: [String]

    public init(matchedIssues: [Int], errors: [String]) {
        self.matchedIssues = matchedIssues
        self.errors = errors
    }
}

/// Property key details.
public struct PropertyKey: Codable {
    /// The URL of the property.
    public var this: String?
    /// The key of the property.
    public var key: String?

    public init(this: String? = nil, key: String? = nil) {
        self.this = this
        self.key = key
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case key
    }
}

/// List of property keys.
public struct PropertyKeys: Codable {
    /// Property key details.
    public var keys: [PropertyKey]?

    public init(keys: [PropertyKey]? = nil) {
        self.keys = keys
    }
}

/// An entity property, for more information see [Entity properties](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/).
public struct EntityProperty: Codable {
    /// The key of the property. Required on create and update.
    public var key: String?
    /// The value of the property. Required on create and update.
    public var value: AnyJSON?

    public init(key: String? = nil, value: AnyJSON? = nil) {
        self.key = key
        self.value = value
    }
}

/// Details about a notification associated with an event.
public struct EventNotification: Codable {
    /// Expand options that include additional event notification details in the response.
    public var expand: String?
    /// The ID of the notification.
    public var id: Int?
    /// Identifies the recipients of the notification.
    public var notificationType: NotificationType?
    /// The value of the `notificationType`:
    /// 
    ///  *  `User` The `parameter` is the user account ID.
    ///  *  `Group` The `parameter` is the group name.
    ///  *  `ProjectRole` The `parameter` is the project role ID.
    ///  *  `UserCustomField` The `parameter` is the ID of the custom field.
    ///  *  `GroupCustomField` The `parameter` is the ID of the custom field.
    public var parameter: String?
    /// The specified group.
    public var group: GroupName?
    /// The custom user or group field.
    public var field: FieldDetails?
    /// The email address.
    public var emailAddress: String?
    /// The specified project role.
    public var projectRole: ProjectRole?
    /// The specified user.
    public var user: UserDetails?

    /// Identifies the recipients of the notification.
    public enum NotificationType: String, Codable, CaseIterable {
        case currentAssignee = "CurrentAssignee"
        case reporter = "Reporter"
        case currentUser = "CurrentUser"
        case projectLead = "ProjectLead"
        case componentLead = "ComponentLead"
        case user = "User"
        case group = "Group"
        case projectRole = "ProjectRole"
        case emailAddress = "EmailAddress"
        case allWatchers = "AllWatchers"
        case userCustomField = "UserCustomField"
        case groupCustomField = "GroupCustomField"
    }

    public init(expand: String? = nil, id: Int? = nil, notificationType: NotificationType? = nil, parameter: String? = nil, group: GroupName? = nil, field: FieldDetails? = nil, emailAddress: String? = nil, projectRole: ProjectRole? = nil, user: UserDetails? = nil) {
        self.expand = expand
        self.id = id
        self.notificationType = notificationType
        self.parameter = parameter
        self.group = group
        self.field = field
        self.emailAddress = emailAddress
        self.projectRole = projectRole
        self.user = user
    }
}

/// Details about a field.
public struct FieldDetails: Codable {
    /// The ID of the field.
    public var id: String?
    /// The key of the field.
    public var key: String?
    /// The name of the field.
    public var name: String?
    /// Whether the field is a custom field.
    public var isCustom: Bool?
    /// Whether the content of the field can be used to order lists.
    public var isOrderable: Bool?
    /// Whether the field can be used as a column on the issue navigator.
    public var isNavigable: Bool?
    /// Whether the content of the field can be searched.
    public var isSearchable: Bool?
    /// The names that can be used to reference the field in an advanced search. For more information, see [Advanced searching - fields reference](https://confluence.atlassian.com/x/gwORLQ).
    public var clauseNames: [String]?
    /// The scope of the field.
    public var scope: Scope?
    /// The data schema for the field.
    public var schema: JSONTypeBean?

    public init(id: String? = nil, key: String? = nil, name: String? = nil, isCustom: Bool? = nil, isOrderable: Bool? = nil, isNavigable: Bool? = nil, isSearchable: Bool? = nil, clauseNames: [String]? = nil, scope: Scope? = nil, schema: JSONTypeBean? = nil) {
        self.id = id
        self.key = key
        self.name = name
        self.isCustom = isCustom
        self.isOrderable = isOrderable
        self.isNavigable = isNavigable
        self.isSearchable = isSearchable
        self.clauseNames = clauseNames
        self.scope = scope
        self.schema = schema
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case key
        case name
        case isCustom = "custom"
        case isOrderable = "orderable"
        case isNavigable = "navigable"
        case isSearchable = "searchable"
        case clauseNames
        case scope
        case schema
    }
}

/// Details about a notification event.
public final class NotificationEvent: Codable {
    /// The ID of the event. The event can be a [Jira system event](https://confluence.atlassian.com/x/8YdKLg#Creatinganotificationscheme-eventsEvents) or a [custom event](https://confluence.atlassian.com/x/AIlKLg).
    public var id: Int?
    /// The name of the event.
    public var name: String?
    /// The description of the event.
    public var description: String?
    /// The template of the event. Only custom events configured by Jira administrators have template.
    public var templateEvent: NotificationEvent?

    public init(id: Int? = nil, name: String? = nil, description: String? = nil, templateEvent: NotificationEvent? = nil) {
        self.id = id
        self.name = name
        self.description = description
        self.templateEvent = templateEvent
    }
}

/// Details about a notification scheme.
public struct NotificationScheme: Codable {
    /// Expand options that include additional notification scheme details in the response.
    public var expand: String?
    /// The ID of the notification scheme.
    public var id: Int?
    public var this: String?
    /// The name of the notification scheme.
    public var name: String?
    /// The description of the notification scheme.
    public var description: String?
    /// The notification events and associated recipients.
    public var notificationSchemeEvents: [NotificationSchemeEvent]?
    /// The scope of the notification scheme.
    public var scope: Scope?

    public init(expand: String? = nil, id: Int? = nil, this: String? = nil, name: String? = nil, description: String? = nil, notificationSchemeEvents: [NotificationSchemeEvent]? = nil, scope: Scope? = nil) {
        self.expand = expand
        self.id = id
        self.this = this
        self.name = name
        self.description = description
        self.notificationSchemeEvents = notificationSchemeEvents
        self.scope = scope
    }

    private enum CodingKeys: String, CodingKey {
        case expand
        case id
        case this = "self"
        case name
        case description
        case notificationSchemeEvents
        case scope
    }
}

/// Details about a notification scheme event.
public struct NotificationSchemeEvent: Codable {
    public var event: NotificationEvent?
    public var notifications: [EventNotification]?

    public init(event: NotificationEvent? = nil, notifications: [EventNotification]? = nil) {
        self.event = event
        self.notifications = notifications
    }
}

/// A page of items.
public struct PageBeanNotificationScheme: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [NotificationScheme]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [NotificationScheme]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// Details of a dashboard.
public struct Dashboard: Codable {
    public var description: String?
    /// The ID of the dashboard.
    public var id: String?
    /// Whether the dashboard is selected as a favorite by the user.
    public var isFavourite: Bool?
    /// The name of the dashboard.
    public var name: String?
    /// The owner of the dashboard.
    public var owner: UserBean?
    /// The number of users who have this dashboard as a favorite.
    public var popularity: Int?
    /// The rank of this dashboard.
    public var rank: Int?
    /// The URL of these dashboard details.
    public var this: URL?
    /// The details of any view share permissions for the dashboard.
    public var sharePermissions: [SharePermission]?
    /// The details of any edit share permissions for the dashboard.
    public var editPermissions: [SharePermission]?
    /// The URL of the dashboard.
    public var view: String?
    /// Whether the current user has permission to edit the dashboard.
    public var isWritable: Bool?

    public init(description: String? = nil, id: String? = nil, isFavourite: Bool? = nil, name: String? = nil, owner: UserBean? = nil, popularity: Int? = nil, rank: Int? = nil, this: URL? = nil, sharePermissions: [SharePermission]? = nil, editPermissions: [SharePermission]? = nil, view: String? = nil, isWritable: Bool? = nil) {
        self.description = description
        self.id = id
        self.isFavourite = isFavourite
        self.name = name
        self.owner = owner
        self.popularity = popularity
        self.rank = rank
        self.this = this
        self.sharePermissions = sharePermissions
        self.editPermissions = editPermissions
        self.view = view
        self.isWritable = isWritable
    }

    private enum CodingKeys: String, CodingKey {
        case description
        case id
        case isFavourite
        case name
        case owner
        case popularity
        case rank
        case this = "self"
        case sharePermissions
        case editPermissions
        case view
        case isWritable
    }
}

/// A page containing dashboard details.
public struct PageOfDashboards: Codable {
    /// The index of the first item returned on the page.
    public var startAt: Int?
    /// The maximum number of results that could be on the page.
    public var maxResults: Int?
    /// The number of results on the page.
    public var total: Int?
    /// The URL of the previous page of results, if any.
    public var prev: String?
    /// The URL of the next page of results, if any.
    public var next: String?
    /// List of dashboards.
    public var dashboards: [Dashboard]?

    public init(startAt: Int? = nil, maxResults: Int? = nil, total: Int? = nil, prev: String? = nil, next: String? = nil, dashboards: [Dashboard]? = nil) {
        self.startAt = startAt
        self.maxResults = maxResults
        self.total = total
        self.prev = prev
        self.next = next
        self.dashboards = dashboards
    }
}

/// A page of items.
public struct PageBeanDashboard: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [Dashboard]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [Dashboard]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// Details of a dashboard.
public struct DashboardDetails: Codable {
    /// The name of the dashboard.
    public var name: String
    /// The description of the dashboard.
    public var description: String?
    /// The share permissions for the dashboard.
    public var sharePermissions: [SharePermission]
    /// The edit permissions for the dashboard.
    public var editPermissions: [SharePermission]

    public init(name: String, description: String? = nil, sharePermissions: [SharePermission], editPermissions: [SharePermission]) {
        self.name = name
        self.description = description
        self.sharePermissions = sharePermissions
        self.editPermissions = editPermissions
    }
}

/// Details of an issue type.
public struct IssueTypeInfo: Codable {
    /// The ID of the issue type.
    public var id: Int?
    /// The name of the issue type.
    public var name: String?
    /// The avatar of the issue type.
    public var avatarID: Int?

    public init(id: Int? = nil, name: String? = nil, avatarID: Int? = nil) {
        self.id = id
        self.name = name
        self.avatarID = avatarID
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case avatarID = "avatarId"
    }
}

/// The hierarchy of issue types within a project.
public struct ProjectIssueTypeHierarchy: Codable {
    /// The ID of the project.
    public var projectID: Int?
    /// Details of an issue type hierarchy level.
    public var hierarchy: [ProjectIssueTypesHierarchyLevel]?

    public init(projectID: Int? = nil, hierarchy: [ProjectIssueTypesHierarchyLevel]? = nil) {
        self.projectID = projectID
        self.hierarchy = hierarchy
    }

    private enum CodingKeys: String, CodingKey {
        case projectID = "projectId"
        case hierarchy
    }
}

/// Details of an issue type hierarchy level.
public struct ProjectIssueTypesHierarchyLevel: Codable {
    /// The ID of the issue type hierarchy level. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).
    public var entityID: String?
    /// The level of the issue type hierarchy level.
    public var level: Int?
    /// The name of the issue type hierarchy level.
    public var name: String?
    /// The list of issue types in the hierarchy level.
    public var issueTypes: [IssueTypeInfo]?

    public init(entityID: String? = nil, level: Int? = nil, name: String? = nil, issueTypes: [IssueTypeInfo]? = nil) {
        self.entityID = entityID
        self.level = level
        self.name = name
        self.issueTypes = issueTypes
    }

    private enum CodingKeys: String, CodingKey {
        case entityID = "entityId"
        case level
        case name
        case issueTypes
    }
}

/// Details about a failed webhook.
public struct FailedWebhook: Codable {
    /// The webhook ID, as sent in the `X-Atlassian-Webhook-Identifier` header with the webhook.
    public var id: String
    /// The webhook body.
    public var body: String?
    /// The original webhook destination.
    public var url: String
    /// The time the webhook was added to the list of failed webhooks (that is, the time of the last failed retry).
    public var failureTime: Int

    public init(id: String, body: String? = nil, url: String, failureTime: Int) {
        self.id = id
        self.body = body
        self.url = url
        self.failureTime = failureTime
    }
}

/// A page of failed webhooks.
public struct FailedWebhooks: Codable {
    /// The list of webhooks.
    public var values: [FailedWebhook]
    /// The maximum number of items on the page. If the list of values is shorter than this number, then there are no more pages.
    public var maxResults: Int
    /// The URL to the next page of results. Present only if the request returned at least one result.The next page may be empty at the time of receiving the response, but new failed webhooks may appear in time. You can save the URL to the next page and query for new results periodically (for example, every hour).
    public var next: URL?

    public init(values: [FailedWebhook], maxResults: Int, next: URL? = nil) {
        self.values = values
        self.maxResults = maxResults
        self.next = next
    }
}

/// A list of webhooks.
public struct WebhookDetails: Codable {
    /// The JQL filter that specifies which issues the webhook is sent for. Only a subset of JQL can be used. The supported elements are:
    /// 
    ///  *  Fields: `issueKey`, `project`, `issuetype`, `status`, `assignee`, `reporter`, `issue.property`, and `cf[id]`. For custom fields (`cf[id]`), only the epic label custom field is supported.".
    ///  *  Operators: `=`, `!=`, `IN`, and `NOT IN`.
    public var jqlFilter: String
    /// A list of field IDs. When the issue changelog contains any of the fields, the webhook `jira:issue_updated` is sent. If this parameter is not present, the app is notified about all field updates.
    public var fieldIDsFilter: [String]?
    /// A list of issue property keys. A change of those issue properties triggers the `issue_property_set` or `issue_property_deleted` webhooks. If this parameter is not present, the app is notified about all issue property updates.
    public var issuePropertyKeysFilter: [String]?
    /// The Jira events that trigger the webhook.
    public var events: [Event]

    public enum Event: String, Codable, CaseIterable {
        case jiraIssueCreated = "jira:issue_created"
        case jiraIssueUpdated = "jira:issue_updated"
        case jiraIssueDeleted = "jira:issue_deleted"
        case commentCreated = "comment_created"
        case commentUpdated = "comment_updated"
        case commentDeleted = "comment_deleted"
        case issuePropertySet = "issue_property_set"
        case issuePropertyDeleted = "issue_property_deleted"
    }

    public init(jqlFilter: String, fieldIDsFilter: [String]? = nil, issuePropertyKeysFilter: [String]? = nil, events: [Event]) {
        self.jqlFilter = jqlFilter
        self.fieldIDsFilter = fieldIDsFilter
        self.issuePropertyKeysFilter = issuePropertyKeysFilter
        self.events = events
    }

    private enum CodingKeys: String, CodingKey {
        case jqlFilter
        case fieldIDsFilter = "fieldIdsFilter"
        case issuePropertyKeysFilter
        case events
    }
}

/// Details of webhooks to register.
public struct WebhookRegistrationDetails: Codable {
    /// A list of webhooks.
    public var webhooks: [WebhookDetails]
    /// The URL that specifies where to send the webhooks. This URL must use the same base URL as the Connect app.
    public var url: String

    public init(webhooks: [WebhookDetails], url: String) {
        self.webhooks = webhooks
        self.url = url
    }
}

/// Container for a list of registered webhooks. Webhook details are returned in the same order as the request.
public struct ContainerForRegisteredWebhooks: Codable {
    /// A list of registered webhooks.
    public var webhookRegistrationResult: [RegisteredWebhook]?

    public init(webhookRegistrationResult: [RegisteredWebhook]? = nil) {
        self.webhookRegistrationResult = webhookRegistrationResult
    }
}

/// ID of a registered webhook or error messages explaining why a webhook wasn't registered.
public struct RegisteredWebhook: Codable {
    /// The ID of the webhook. Returned if the webhook is created.
    public var createdWebhookID: Int?
    /// Error messages specifying why the webhook creation failed.
    public var errors: [String]?

    public init(createdWebhookID: Int? = nil, errors: [String]? = nil) {
        self.createdWebhookID = createdWebhookID
        self.errors = errors
    }

    private enum CodingKeys: String, CodingKey {
        case createdWebhookID = "createdWebhookId"
        case errors
    }
}

/// A page of items.
public struct PageBeanWebhook: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [Webhook]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [Webhook]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// A webhook.
public struct Webhook: Codable {
    /// The ID of the webhook.
    public var id: Int
    /// The JQL filter that specifies which issues the webhook is sent for.
    public var jqlFilter: String
    /// A list of field IDs. When the issue changelog contains any of the fields, the webhook `jira:issue_updated` is sent. If this parameter is not present, the app is notified about all field updates.
    public var fieldIDsFilter: [String]?
    /// A list of issue property keys. A change of those issue properties triggers the `issue_property_set` or `issue_property_deleted` webhooks. If this parameter is not present, the app is notified about all issue property updates.
    public var issuePropertyKeysFilter: [String]?
    /// The Jira events that trigger the webhook.
    public var events: [Event]
    public var expirationDate: Int?

    public enum Event: String, Codable, CaseIterable {
        case jiraIssueCreated = "jira:issue_created"
        case jiraIssueUpdated = "jira:issue_updated"
        case jiraIssueDeleted = "jira:issue_deleted"
        case commentCreated = "comment_created"
        case commentUpdated = "comment_updated"
        case commentDeleted = "comment_deleted"
        case issuePropertySet = "issue_property_set"
        case issuePropertyDeleted = "issue_property_deleted"
    }

    public init(id: Int, jqlFilter: String, fieldIDsFilter: [String]? = nil, issuePropertyKeysFilter: [String]? = nil, events: [Event], expirationDate: Int? = nil) {
        self.id = id
        self.jqlFilter = jqlFilter
        self.fieldIDsFilter = fieldIDsFilter
        self.issuePropertyKeysFilter = issuePropertyKeysFilter
        self.events = events
        self.expirationDate = expirationDate
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case jqlFilter
        case fieldIDsFilter = "fieldIdsFilter"
        case issuePropertyKeysFilter
        case events
        case expirationDate
    }
}

/// Container for a list of webhook IDs.
public struct ContainerForWebhookIDs: Codable {
    /// A list of webhook IDs.
    public var webhookIDs: [Int]

    public init(webhookIDs: [Int]) {
        self.webhookIDs = webhookIDs
    }

    private enum CodingKeys: String, CodingKey {
        case webhookIDs = "webhookIds"
    }
}

/// The date the newly refreshed webhooks expire.
public struct WebhooksExpirationDate: Codable {
    public var expirationDate: Int

    public init(expirationDate: Int) {
        self.expirationDate = expirationDate
    }
}

/// Details about the replacement for a deleted version.
public struct CustomFieldReplacement: Codable {
    /// The ID of the custom field in which to replace the version number.
    public var customFieldID: Int?
    /// The version number to use as a replacement for the deleted version.
    public var moveTo: Int?

    public init(customFieldID: Int? = nil, moveTo: Int? = nil) {
        self.customFieldID = customFieldID
        self.moveTo = moveTo
    }

    private enum CodingKeys: String, CodingKey {
        case customFieldID = "customFieldId"
        case moveTo
    }
}

public struct DeleteAndReplaceVersionBean: Codable {
    /// The ID of the version to update `fixVersion` to when the field contains the deleted version.
    public var moveFixIssuesTo: Int?
    /// The ID of the version to update `affectedVersion` to when the field contains the deleted version.
    public var moveAffectedIssuesTo: Int?
    /// An array of custom field IDs (`customFieldId`) and version IDs (`moveTo`) to update when the fields contain the deleted version.
    public var customFieldReplacementList: [CustomFieldReplacement]?

    public init(moveFixIssuesTo: Int? = nil, moveAffectedIssuesTo: Int? = nil, customFieldReplacementList: [CustomFieldReplacement]? = nil) {
        self.moveFixIssuesTo = moveFixIssuesTo
        self.moveAffectedIssuesTo = moveAffectedIssuesTo
        self.customFieldReplacementList = customFieldReplacementList
    }
}

/// Various counts of issues within a version.
public struct VersionIssueCounts: Codable {
    /// The URL of these count details.
    public var this: URL?
    /// Count of issues where the `fixVersion` is set to the version.
    public var issuesFixedCount: Int?
    /// Count of issues where the `affectedVersion` is set to the version.
    public var issuesAffectedCount: Int?
    /// Count of issues where a version custom field is set to the version.
    public var issueCountWithCustomFieldsShowingVersion: Int?
    /// List of custom fields using the version.
    public var customFieldUsage: [VersionUsageInCustomField]?

    public init(this: URL? = nil, issuesFixedCount: Int? = nil, issuesAffectedCount: Int? = nil, issueCountWithCustomFieldsShowingVersion: Int? = nil, customFieldUsage: [VersionUsageInCustomField]? = nil) {
        self.this = this
        self.issuesFixedCount = issuesFixedCount
        self.issuesAffectedCount = issuesAffectedCount
        self.issueCountWithCustomFieldsShowingVersion = issueCountWithCustomFieldsShowingVersion
        self.customFieldUsage = customFieldUsage
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case issuesFixedCount
        case issuesAffectedCount
        case issueCountWithCustomFieldsShowingVersion
        case customFieldUsage
    }
}

/// List of custom fields using the version.
public struct VersionUsageInCustomField: Codable {
    /// The name of the custom field.
    public var fieldName: String?
    /// The ID of the custom field.
    public var customFieldID: Int?
    /// Count of the issues where the custom field contains the version.
    public var issueCountWithVersionInCustomField: Int?

    public init(fieldName: String? = nil, customFieldID: Int? = nil, issueCountWithVersionInCustomField: Int? = nil) {
        self.fieldName = fieldName
        self.customFieldID = customFieldID
        self.issueCountWithVersionInCustomField = issueCountWithVersionInCustomField
    }

    private enum CodingKeys: String, CodingKey {
        case fieldName
        case customFieldID = "customFieldId"
        case issueCountWithVersionInCustomField
    }
}

/// Count of a version's unresolved issues.
public struct VersionUnresolvedIssuesCount: Codable {
    /// The URL of these count details.
    public var this: URL?
    /// Count of unresolved issues.
    public var issuesUnresolvedCount: Int?
    /// Count of issues.
    public var issuesCount: Int?

    public init(this: URL? = nil, issuesUnresolvedCount: Int? = nil, issuesCount: Int? = nil) {
        self.this = this
        self.issuesUnresolvedCount = issuesUnresolvedCount
        self.issuesCount = issuesCount
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case issuesUnresolvedCount
        case issuesCount
    }
}

public struct VersionMoveBean: Codable {
    /// The URL (self link) of the version after which to place the moved version. Cannot be used with `position`.
    public var after: URL?
    /// An absolute position in which to place the moved version. Cannot be used with `after`.
    public var position: Position?

    /// An absolute position in which to place the moved version. Cannot be used with `after`.
    public enum Position: String, Codable, CaseIterable {
        case earlier = "Earlier"
        case later = "Later"
        case first = "First"
        case last = "Last"
    }

    public init(after: URL? = nil, position: Position? = nil) {
        self.after = after
        self.position = position
    }
}

/// The list of users found in a search, including header text (Showing X of Y matching users) and total of matched users.
public struct FoundUsers: Codable {
    public var users: [UserPickerUser]?
    /// The total number of users found in the search.
    public var total: Int?
    /// Header text indicating the number of users in the response and the total number of users found in the search.
    public var header: String?

    public init(users: [UserPickerUser]? = nil, total: Int? = nil, header: String? = nil) {
        self.users = users
        self.total = total
        self.header = header
    }
}

/// A user found in a search.
public struct UserPickerUser: Codable {
    /// The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
    public var accountID: String?
    /// This property is no longer available . See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
    public var name: String?
    /// This property is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
    public var key: String?
    /// The display name, email address, and key of the user with the matched query string highlighted with the HTML bold tag.
    public var html: String?
    /// The display name of the user. Depending on the user’s privacy setting, this may be returned as null.
    public var displayName: String?
    /// The avatar URL of the user.
    public var avatarURL: URL?

    public init(accountID: String? = nil, name: String? = nil, key: String? = nil, html: String? = nil, displayName: String? = nil, avatarURL: URL? = nil) {
        self.accountID = accountID
        self.name = name
        self.key = key
        self.html = html
        self.displayName = displayName
        self.avatarURL = avatarURL
    }

    private enum CodingKeys: String, CodingKey {
        case accountID = "accountId"
        case name
        case key
        case html
        case displayName
        case avatarURL = "avatarUrl"
    }
}

/// The user details.
public struct NewUserDetails: Codable {
    /// The URL of the user.
    public var this: String?
    /// This property is no longer available. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
    public var key: String?
    /// This property is no longer available. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
    public var name: String?
    /// This property is no longer available. If the user has an Atlassian account, their password is not changed. If the user does not have an Atlassian account, they are sent an email asking them set up an account.
    public var password: String?
    /// The email address for the user.
    public var emailAddress: String
    /// A suggested display name for the user. If the user has an Atlassian account, their display name is not changed. If the user does not have an Atlassian account, this display name is used as a suggestion for creating an account. The user is sent an email asking them to set their display name and privacy preferences.
    public var displayName: String
    /// Deprecated, do not use.
    public var applicationKeys: [String]?

    public init(this: String? = nil, key: String? = nil, name: String? = nil, password: String? = nil, emailAddress: String, displayName: String, applicationKeys: [String]? = nil) {
        self.this = this
        self.key = key
        self.name = name
        self.password = password
        self.emailAddress = emailAddress
        self.displayName = displayName
        self.applicationKeys = applicationKeys
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case key
        case name
        case password
        case emailAddress
        case displayName
        case applicationKeys
    }
}

/// Details of an avatar.
public struct Avatar: Codable {
    /// The ID of the avatar.
    public var id: String
    /// The owner of the avatar. For a system avatar the owner is null (and nothing is returned). For non-system avatars this is the appropriate identifier, such as the ID for a project or the account ID for a user.
    public var owner: String?
    /// Whether the avatar is a system avatar.
    public var isSystemAvatar: Bool?
    /// Whether the avatar is used in Jira. For example, shown as a project's avatar.
    public var isSelected: Bool?
    /// Whether the avatar can be deleted.
    public var isDeletable: Bool?
    /// The file name of the avatar icon. Returned for system avatars.
    public var fileName: String?
    /// The list of avatar icon URLs.
    public var urls: [String: URL]?

    public init(id: String, owner: String? = nil, isSystemAvatar: Bool? = nil, isSelected: Bool? = nil, isDeletable: Bool? = nil, fileName: String? = nil, urls: [String: URL]? = nil) {
        self.id = id
        self.owner = owner
        self.isSystemAvatar = isSystemAvatar
        self.isSelected = isSelected
        self.isDeletable = isDeletable
        self.fileName = fileName
        self.urls = urls
    }
}

/// Details about system and custom avatars.
public struct Avatars: Codable {
    /// System avatars list.
    public var system: [Avatar]?
    /// Custom avatars list.
    public var custom: [Avatar]?

    public init(system: [Avatar]? = nil, custom: [Avatar]? = nil) {
        self.system = system
        self.custom = custom
    }
}

/// A screen tab.
public struct ScreenableTab: Codable {
    /// The ID of the screen tab.
    public var id: Int?
    /// The name of the screen tab. The maximum length is 255 characters.
    public var name: String

    public init(id: Int? = nil, name: String) {
        self.id = id
        self.name = name
    }
}

/// A page of items.
public struct PageBeanScreen: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [Screen]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [Screen]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// A screen.
public struct Screen: Codable {
    /// The ID of the screen.
    public var id: Int?
    /// The name of the screen.
    public var name: String?
    /// The description of the screen.
    public var description: String?
    /// The scope of the screen.
    public var scope: Scope?

    public init(id: Int? = nil, name: String? = nil, description: String? = nil, scope: Scope? = nil) {
        self.id = id
        self.name = name
        self.description = description
        self.scope = scope
    }
}

/// A screen tab field.
public struct ScreenableField: Codable {
    /// The ID of the screen tab field.
    public var id: String?
    /// The name of the screen tab field. Required on create and update. The maximum length is 255 characters.
    public var name: String?

    public init(id: String? = nil, name: String? = nil) {
        self.id = id
        self.name = name
    }
}

public struct MoveFieldBean: Codable {
    /// The ID of the screen tab field after which to place the moved screen tab field. Required if `position` isn't provided.
    public var after: URL?
    /// The named position to which the screen tab field should be moved. Required if `after` isn't provided.
    public var position: Position?

    /// The named position to which the screen tab field should be moved. Required if `after` isn't provided.
    public enum Position: String, Codable, CaseIterable {
        case earlier = "Earlier"
        case later = "Later"
        case first = "First"
        case last = "Last"
    }

    public init(after: URL? = nil, position: Position? = nil) {
        self.after = after
        self.position = position
    }
}

public struct AddFieldBean: Codable {
    /// The ID of the field to add.
    public var fieldID: String

    public init(fieldID: String) {
        self.fieldID = fieldID
    }

    private enum CodingKeys: String, CodingKey {
        case fieldID = "fieldId"
    }
}

/// Details of a screen.
public struct ScreenDetails: Codable {
    /// The name of the screen. The name must be unique. The maximum length is 255 characters.
    public var name: String
    /// The description of the screen. The maximum length is 255 characters.
    public var description: String?

    public init(name: String, description: String? = nil) {
        self.name = name
        self.description = description
    }
}

/// Details of a screen.
public struct UpdateScreenDetails: Codable {
    /// The name of the screen. The name must be unique. The maximum length is 255 characters.
    public var name: String?
    /// The description of the screen. The maximum length is 255 characters.
    public var description: String?

    public init(name: String? = nil, description: String? = nil) {
        self.name = name
        self.description = description
    }
}

/// Details of an issue resolution.
public struct Resolution: Codable {
    /// The URL of the issue resolution.
    public var this: URL?
    /// The ID of the issue resolution.
    public var id: String?
    /// The description of the issue resolution.
    public var description: String?
    /// The name of the issue resolution.
    public var name: String?

    public init(this: URL? = nil, id: String? = nil, description: String? = nil, name: String? = nil) {
        self.this = this
        self.id = id
        self.description = description
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case id
        case description
        case name
    }
}

/// Details about the project.
public struct CreateProjectDetails: Codable {
    /// Project keys must be unique and start with an uppercase letter followed by one or more uppercase alphanumeric characters. The maximum length is 10 characters.
    public var key: String
    /// The name of the project.
    public var name: String
    /// A brief description of the project.
    public var description: String?
    /// This parameter is deprecated because of privacy changes. Use `leadAccountId` instead. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. The user name of the project lead. Either `lead` or `leadAccountId` must be set when creating a project. Cannot be provided with `leadAccountId`.
    public var lead: String?
    /// The account ID of the project lead. Either `lead` or `leadAccountId` must be set when creating a project. Cannot be provided with `lead`.
    public var leadAccountID: String?
    /// A link to information about this project, such as project documentation
    public var url: String?
    /// The default assignee when creating issues for this project.
    public var assigneeType: AssigneeType?
    /// An integer value for the project's avatar.
    public var avatarID: Int?
    /// The ID of the issue security scheme for the project, which enables you to control who can and cannot view issues. Use the [Get issue security schemes](#api-rest-api-3-issuesecurityschemes-get) resource to get all issue security scheme IDs.
    public var issueSecurityScheme: Int?
    /// The ID of the permission scheme for the project. Use the [Get all permission schemes](#api-rest-api-3-permissionscheme-get) resource to see a list of all permission scheme IDs.
    public var permissionScheme: Int?
    /// The ID of the notification scheme for the project. Use the [Get notification schemes](#api-rest-api-3-notificationscheme-get) resource to get a list of notification scheme IDs.
    public var notificationScheme: Int?
    /// The ID of the project's category. A complete list of category IDs is found using the [Get all project categories](#api-rest-api-3-projectCategory-get) operation.
    public var categoryID: Int?
    /// The [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes), which defines the application-specific feature set. If you don't specify the project template you have to specify the project type.
    public var projectTypeKey: ProjectTypeKey?
    /// A predefined configuration for a project. The type of the `projectTemplateKey` must match with the type of the `projectTypeKey`.
    public var projectTemplateKey: ProjectTemplateKey?
    /// The ID of the workflow scheme for the project. Use the [Get all workflow schemes](#api-rest-api-3-workflowscheme-get) operation to get a list of workflow scheme IDs. If you specify the workflow scheme you cannot specify the project template key.
    public var workflowScheme: Int?
    /// The ID of the issue type screen scheme for the project. Use the [Get all issue type screen schemes](#api-rest-api-3-issuetypescreenscheme-get) operation to get a list of issue type screen scheme IDs. If you specify the issue type screen scheme you cannot specify the project template key.
    public var issueTypeScreenScheme: Int?
    /// The ID of the issue type scheme for the project. Use the [Get all issue type schemes](#api-rest-api-3-issuetypescheme-get) operation to get a list of issue type scheme IDs. If you specify the issue type scheme you cannot specify the project template key.
    public var issueTypeScheme: Int?
    /// The ID of the field configuration scheme for the project. Use the [Get all field configuration schemes](#api-rest-api-3-fieldconfigurationscheme-get) operation to get a list of field configuration scheme IDs. If you specify the field configuration scheme you cannot specify the project template key.
    public var fieldConfigurationScheme: Int?

    /// The default assignee when creating issues for this project.
    public enum AssigneeType: String, Codable, CaseIterable {
        case projectLead = "PROJECT_LEAD"
        case unassigned = "UNASSIGNED"
    }

    /// The [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes), which defines the application-specific feature set. If you don't specify the project template you have to specify the project type.
    public enum ProjectTypeKey: String, Codable, CaseIterable {
        case software
        case serviceDesk = "service_desk"
        case business
    }

    /// A predefined configuration for a project. The type of the `projectTemplateKey` must match with the type of the `projectTypeKey`.
    public enum ProjectTemplateKey: String, Codable, CaseIterable {
        case comPyxisGreenhopperJiraGhSimplifiedAgilityKanban = "com.pyxis.greenhopper.jira:gh-simplified-agility-kanban"
        case comPyxisGreenhopperJiraGhSimplifiedAgilityScrum = "com.pyxis.greenhopper.jira:gh-simplified-agility-scrum"
        case comPyxisGreenhopperJiraGhSimplifiedBasic = "com.pyxis.greenhopper.jira:gh-simplified-basic"
        case comPyxisGreenhopperJiraGhSimplifiedKanbanClassic = "com.pyxis.greenhopper.jira:gh-simplified-kanban-classic"
        case comPyxisGreenhopperJiraGhSimplifiedScrumClassic = "com.pyxis.greenhopper.jira:gh-simplified-scrum-classic"
        case comAtlassianServicedeskSimplifiedItServiceManagement = "com.atlassian.servicedesk:simplified-it-service-management"
        case comAtlassianServicedeskSimplifiedGeneralServiceDesk = "com.atlassian.servicedesk:simplified-general-service-desk"
        case comAtlassianServicedeskSimplifiedInternalServiceDesk = "com.atlassian.servicedesk:simplified-internal-service-desk"
        case comAtlassianServicedeskSimplifiedExternalServiceDesk = "com.atlassian.servicedesk:simplified-external-service-desk"
        case comAtlassianServicedeskSimplifiedHrServiceDesk = "com.atlassian.servicedesk:simplified-hr-service-desk"
        case comAtlassianServicedeskSimplifiedFacilitiesServiceDesk = "com.atlassian.servicedesk:simplified-facilities-service-desk"
        case comAtlassianServicedeskSimplifiedLegalServiceDesk = "com.atlassian.servicedesk:simplified-legal-service-desk"
        case comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedContentManagement = "com.atlassian.jira-core-project-templates:jira-core-simplified-content-management"
        case comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedDocumentApproval = "com.atlassian.jira-core-project-templates:jira-core-simplified-document-approval"
        case comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedLeadTracking = "com.atlassian.jira-core-project-templates:jira-core-simplified-lead-tracking"
        case comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedProcessControl = "com.atlassian.jira-core-project-templates:jira-core-simplified-process-control"
        case comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedProcurement = "com.atlassian.jira-core-project-templates:jira-core-simplified-procurement"
        case comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedProjectManagement = "com.atlassian.jira-core-project-templates:jira-core-simplified-project-management"
        case comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedRecruitment = "com.atlassian.jira-core-project-templates:jira-core-simplified-recruitment"
        case comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedTask = "com.atlassian.jira-core-project-templates:jira-core-simplified-task-"
    }

    public init(key: String, name: String, description: String? = nil, lead: String? = nil, leadAccountID: String? = nil, url: String? = nil, assigneeType: AssigneeType? = nil, avatarID: Int? = nil, issueSecurityScheme: Int? = nil, permissionScheme: Int? = nil, notificationScheme: Int? = nil, categoryID: Int? = nil, projectTypeKey: ProjectTypeKey? = nil, projectTemplateKey: ProjectTemplateKey? = nil, workflowScheme: Int? = nil, issueTypeScreenScheme: Int? = nil, issueTypeScheme: Int? = nil, fieldConfigurationScheme: Int? = nil) {
        self.key = key
        self.name = name
        self.description = description
        self.lead = lead
        self.leadAccountID = leadAccountID
        self.url = url
        self.assigneeType = assigneeType
        self.avatarID = avatarID
        self.issueSecurityScheme = issueSecurityScheme
        self.permissionScheme = permissionScheme
        self.notificationScheme = notificationScheme
        self.categoryID = categoryID
        self.projectTypeKey = projectTypeKey
        self.projectTemplateKey = projectTemplateKey
        self.workflowScheme = workflowScheme
        self.issueTypeScreenScheme = issueTypeScreenScheme
        self.issueTypeScheme = issueTypeScheme
        self.fieldConfigurationScheme = fieldConfigurationScheme
    }

    private enum CodingKeys: String, CodingKey {
        case key
        case name
        case description
        case lead
        case leadAccountID = "leadAccountId"
        case url
        case assigneeType
        case avatarID = "avatarId"
        case issueSecurityScheme
        case permissionScheme
        case notificationScheme
        case categoryID = "categoryId"
        case projectTypeKey
        case projectTemplateKey
        case workflowScheme
        case issueTypeScreenScheme
        case issueTypeScheme
        case fieldConfigurationScheme
    }
}

/// Identifiers for a project.
public struct ProjectIdentifiers: Codable {
    /// The URL of the created project.
    public var this: URL
    /// The ID of the created project.
    public var id: Int
    /// The key of the created project.
    public var key: String

    public init(this: URL, id: Int, key: String) {
        self.this = this
        self.id = id
        self.key = key
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case id
        case key
    }
}

/// Details about the project.
public struct UpdateProjectDetails: Codable {
    /// Project keys must be unique and start with an uppercase letter followed by one or more uppercase alphanumeric characters. The maximum length is 10 characters.
    public var key: String?
    /// The name of the project.
    public var name: String?
    /// A brief description of the project.
    public var description: String?
    /// This parameter is deprecated because of privacy changes. Use `leadAccountId` instead. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. The user name of the project lead. Cannot be provided with `leadAccountId`.
    public var lead: String?
    /// The account ID of the project lead. Cannot be provided with `lead`.
    public var leadAccountID: String?
    /// A link to information about this project, such as project documentation
    public var url: String?
    /// The default assignee when creating issues for this project.
    public var assigneeType: AssigneeType?
    /// An integer value for the project's avatar.
    public var avatarID: Int?
    /// The ID of the issue security scheme for the project, which enables you to control who can and cannot view issues. Use the [Get issue security schemes](#api-rest-api-3-issuesecurityschemes-get) resource to get all issue security scheme IDs.
    public var issueSecurityScheme: Int?
    /// The ID of the permission scheme for the project. Use the [Get all permission schemes](#api-rest-api-3-permissionscheme-get) resource to see a list of all permission scheme IDs.
    public var permissionScheme: Int?
    /// The ID of the notification scheme for the project. Use the [Get notification schemes](#api-rest-api-3-notificationscheme-get) resource to get a list of notification scheme IDs.
    public var notificationScheme: Int?
    /// The ID of the project's category. A complete list of category IDs is found using the [Get all project categories](#api-rest-api-3-projectCategory-get) operation. To remove the project category from the project, set the value to `-1.`
    public var categoryID: Int?

    /// The default assignee when creating issues for this project.
    public enum AssigneeType: String, Codable, CaseIterable {
        case projectLead = "PROJECT_LEAD"
        case unassigned = "UNASSIGNED"
    }

    public init(key: String? = nil, name: String? = nil, description: String? = nil, lead: String? = nil, leadAccountID: String? = nil, url: String? = nil, assigneeType: AssigneeType? = nil, avatarID: Int? = nil, issueSecurityScheme: Int? = nil, permissionScheme: Int? = nil, notificationScheme: Int? = nil, categoryID: Int? = nil) {
        self.key = key
        self.name = name
        self.description = description
        self.lead = lead
        self.leadAccountID = leadAccountID
        self.url = url
        self.assigneeType = assigneeType
        self.avatarID = avatarID
        self.issueSecurityScheme = issueSecurityScheme
        self.permissionScheme = permissionScheme
        self.notificationScheme = notificationScheme
        self.categoryID = categoryID
    }

    private enum CodingKeys: String, CodingKey {
        case key
        case name
        case description
        case lead
        case leadAccountID = "leadAccountId"
        case url
        case assigneeType
        case avatarID = "avatarId"
        case issueSecurityScheme
        case permissionScheme
        case notificationScheme
        case categoryID = "categoryId"
    }
}

/// A page of items.
public struct PageBeanVersion: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [Version]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [Version]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// Details about a component with a count of the issues it contains.
public struct ComponentWithIssueCount: Codable {
    /// Count of issues for the component.
    public var issueCount: Int?
    /// The details of the user associated with `assigneeType`, if any. See `realAssignee` for details of the user assigned to issues created with this component.
    public var assignee: User?
    /// The user assigned to issues created with this component, when `assigneeType` does not identify a valid assignee.
    public var realAssignee: User?
    /// Whether a user is associated with `assigneeType`. For example, if the `assigneeType` is set to `COMPONENT_LEAD` but the component lead is not set, then `false` is returned.
    public var isAssigneeTypeValid: Bool?
    /// The type of the assignee that is assigned to issues created with this component, when an assignee cannot be set from the `assigneeType`. For example, `assigneeType` is set to `COMPONENT_LEAD` but no component lead is set. This property is set to one of the following values:
    /// 
    ///  *  `PROJECT_LEAD` when `assigneeType` is `PROJECT_LEAD` and the project lead has permission to be assigned issues in the project that the component is in.
    ///  *  `COMPONENT_LEAD` when `assignee`Type is `COMPONENT_LEAD` and the component lead has permission to be assigned issues in the project that the component is in.
    ///  *  `UNASSIGNED` when `assigneeType` is `UNASSIGNED` and Jira is configured to allow unassigned issues.
    ///  *  `PROJECT_DEFAULT` when none of the preceding cases are true.
    public var realAssigneeType: RealAssigneeType?
    /// The description for the component.
    public var description: String?
    /// The URL for this count of the issues contained in the component.
    public var this: URL?
    /// The key of the project to which the component is assigned.
    public var project: String?
    /// The nominal user type used to determine the assignee for issues created with this component. See `realAssigneeType` for details on how the type of the user, and hence the user, assigned to issues is determined. Takes the following values:
    /// 
    ///  *  `PROJECT_LEAD` the assignee to any issues created with this component is nominally the lead for the project the component is in.
    ///  *  `COMPONENT_LEAD` the assignee to any issues created with this component is nominally the lead for the component.
    ///  *  `UNASSIGNED` an assignee is not set for issues created with this component.
    ///  *  `PROJECT_DEFAULT` the assignee to any issues created with this component is nominally the default assignee for the project that the component is in.
    public var assigneeType: AssigneeType?
    /// The user details for the component's lead user.
    public var lead: User?
    /// Not used.
    public var projectID: Int?
    /// The name for the component.
    public var name: String?
    /// The unique identifier for the component.
    public var id: String?

    /// The type of the assignee that is assigned to issues created with this component, when an assignee cannot be set from the `assigneeType`. For example, `assigneeType` is set to `COMPONENT_LEAD` but no component lead is set. This property is set to one of the following values:
    /// 
    ///  *  `PROJECT_LEAD` when `assigneeType` is `PROJECT_LEAD` and the project lead has permission to be assigned issues in the project that the component is in.
    ///  *  `COMPONENT_LEAD` when `assignee`Type is `COMPONENT_LEAD` and the component lead has permission to be assigned issues in the project that the component is in.
    ///  *  `UNASSIGNED` when `assigneeType` is `UNASSIGNED` and Jira is configured to allow unassigned issues.
    ///  *  `PROJECT_DEFAULT` when none of the preceding cases are true.
    public enum RealAssigneeType: String, Codable, CaseIterable {
        case projectDefault = "PROJECT_DEFAULT"
        case componentLead = "COMPONENT_LEAD"
        case projectLead = "PROJECT_LEAD"
        case unassigned = "UNASSIGNED"
    }

    /// The nominal user type used to determine the assignee for issues created with this component. See `realAssigneeType` for details on how the type of the user, and hence the user, assigned to issues is determined. Takes the following values:
    /// 
    ///  *  `PROJECT_LEAD` the assignee to any issues created with this component is nominally the lead for the project the component is in.
    ///  *  `COMPONENT_LEAD` the assignee to any issues created with this component is nominally the lead for the component.
    ///  *  `UNASSIGNED` an assignee is not set for issues created with this component.
    ///  *  `PROJECT_DEFAULT` the assignee to any issues created with this component is nominally the default assignee for the project that the component is in.
    public enum AssigneeType: String, Codable, CaseIterable {
        case projectDefault = "PROJECT_DEFAULT"
        case componentLead = "COMPONENT_LEAD"
        case projectLead = "PROJECT_LEAD"
        case unassigned = "UNASSIGNED"
    }

    public init(issueCount: Int? = nil, assignee: User? = nil, realAssignee: User? = nil, isAssigneeTypeValid: Bool? = nil, realAssigneeType: RealAssigneeType? = nil, description: String? = nil, this: URL? = nil, project: String? = nil, assigneeType: AssigneeType? = nil, lead: User? = nil, projectID: Int? = nil, name: String? = nil, id: String? = nil) {
        self.issueCount = issueCount
        self.assignee = assignee
        self.realAssignee = realAssignee
        self.isAssigneeTypeValid = isAssigneeTypeValid
        self.realAssigneeType = realAssigneeType
        self.description = description
        self.this = this
        self.project = project
        self.assigneeType = assigneeType
        self.lead = lead
        self.projectID = projectID
        self.name = name
        self.id = id
    }

    private enum CodingKeys: String, CodingKey {
        case issueCount
        case assignee
        case realAssignee
        case isAssigneeTypeValid
        case realAssigneeType
        case description
        case this = "self"
        case project
        case assigneeType
        case lead
        case projectID = "projectId"
        case name
        case id
    }
}

/// A page of items.
public struct PageBeanComponentWithIssueCount: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [ComponentWithIssueCount]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [ComponentWithIssueCount]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

public struct StringList: Codable {
    public init() {}
}

/// A page of items.
public struct PageBeanProject: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [Project]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [Project]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// List of project avatars.
public struct ProjectAvatars: Codable {
    /// List of avatars included with Jira. These avatars cannot be deleted.
    public var system: [Avatar]?
    /// List of avatars added to Jira. These avatars may be deleted.
    public var custom: [Avatar]?

    public init(system: [Avatar]? = nil, custom: [Avatar]? = nil) {
        self.system = system
        self.custom = custom
    }
}

/// Status details for an issue type.
public struct IssueTypeWithStatus: Codable {
    /// The URL of the issue type's status details.
    public var this: String
    /// The ID of the issue type.
    public var id: String
    /// The name of the issue type.
    public var name: String
    /// Whether this issue type represents subtasks.
    public var isSubtask: Bool
    /// List of status details for the issue type.
    public var statuses: [StatusDetails]

    public init(this: String, id: String, name: String, isSubtask: Bool, statuses: [StatusDetails]) {
        self.this = this
        self.id = id
        self.name = name
        self.isSubtask = isSubtask
        self.statuses = statuses
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case id
        case name
        case isSubtask = "subtask"
        case statuses
    }
}

/// Details about a security scheme.
public struct SecurityScheme: Codable {
    /// The URL of the issue security scheme.
    public var this: String?
    /// The ID of the issue security scheme.
    public var id: Int?
    /// The name of the issue security scheme.
    public var name: String?
    /// The description of the issue security scheme.
    public var description: String?
    /// The ID of the default security level.
    public var defaultSecurityLevelID: Int?
    public var levels: [SecurityLevel]?

    public init(this: String? = nil, id: Int? = nil, name: String? = nil, description: String? = nil, defaultSecurityLevelID: Int? = nil, levels: [SecurityLevel]? = nil) {
        self.this = this
        self.id = id
        self.name = name
        self.description = description
        self.defaultSecurityLevelID = defaultSecurityLevelID
        self.levels = levels
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case id
        case name
        case description
        case defaultSecurityLevelID = "defaultSecurityLevelId"
        case levels
    }
}

/// The list of features on a project.
public struct ContainerForProjectFeatures: Codable {
    /// The project features.
    public var features: [ProjectFeature]?

    public init(features: [ProjectFeature]? = nil) {
        self.features = features
    }
}

/// Details of a project feature.
public struct ProjectFeature: Codable {
    /// The ID of the project.
    public var projectID: Int?
    /// The state of the feature. When updating the state of a feature, only ENABLED and DISABLED are supported. Responses can contain all values
    public var state: State?
    /// Whether the state of the feature can be updated.
    public var isToggleLocked: Bool?
    /// The key of the feature.
    public var feature: String?
    /// List of keys of the features required to enable the feature.
    public var prerequisites: [String]?
    /// Localized display name for the feature.
    public var localisedName: String?
    /// Localized display description for the feature.
    public var localisedDescription: String?
    /// URI for the image representing the feature.
    public var imageUri: String?

    /// The state of the feature. When updating the state of a feature, only ENABLED and DISABLED are supported. Responses can contain all values
    public enum State: String, Codable, CaseIterable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        case comingSoon = "COMING_SOON"
    }

    public init(projectID: Int? = nil, state: State? = nil, isToggleLocked: Bool? = nil, feature: String? = nil, prerequisites: [String]? = nil, localisedName: String? = nil, localisedDescription: String? = nil, imageUri: String? = nil) {
        self.projectID = projectID
        self.state = state
        self.isToggleLocked = isToggleLocked
        self.feature = feature
        self.prerequisites = prerequisites
        self.localisedName = localisedName
        self.localisedDescription = localisedDescription
        self.imageUri = imageUri
    }

    private enum CodingKeys: String, CodingKey {
        case projectID = "projectId"
        case state
        case isToggleLocked = "toggleLocked"
        case feature
        case prerequisites
        case localisedName
        case localisedDescription
        case imageUri
    }
}

/// Details of the feature state.
public struct ProjectFeatureState: Codable {
    /// The feature state.
    public var state: State?

    /// The feature state.
    public enum State: String, Codable, CaseIterable {
        case enabled = "ENABLED"
        case disabled = "DISABLED"
        case comingSoon = "COMING_SOON"
    }

    public init(state: State? = nil) {
        self.state = state
    }
}

/// An issue priority.
public struct Priority: Codable {
    /// The URL of the issue priority.
    public var this: String?
    /// The color used to indicate the issue priority.
    public var statusColor: String?
    /// The description of the issue priority.
    public var description: String?
    /// The URL of the icon for the issue priority.
    public var iconURL: String?
    /// The name of the issue priority.
    public var name: String?
    /// The ID of the issue priority.
    public var id: String?

    public init(this: String? = nil, statusColor: String? = nil, description: String? = nil, iconURL: String? = nil, name: String? = nil, id: String? = nil) {
        self.this = this
        self.statusColor = statusColor
        self.description = description
        self.iconURL = iconURL
        self.name = name
        self.id = id
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case statusColor
        case description
        case iconURL = "iconUrl"
        case name
        case id
    }
}

/// A comment.
public struct Comment: Codable {
    /// The URL of the comment.
    public var this: String?
    /// The ID of the comment.
    public var id: String?
    /// The ID of the user who created the comment.
    public var author: UserDetails?
    /// The comment text in [Atlassian Document Format](https://developer.atlassian.com/cloud/jira/platform/apis/document/structure/).
    public var body: AnyJSON?
    /// The rendered version of the comment.
    public var renderedBody: String?
    /// The ID of the user who updated the comment last.
    public var updateAuthor: UserDetails?
    /// The date and time at which the comment was created.
    public var created: Date?
    /// The date and time at which the comment was updated last.
    public var updated: Date?
    /// The group or role to which this comment is visible. Optional on create and update.
    public var visibility: Visibility?
    /// Whether the comment is visible in Jira Service Desk. Defaults to true when comments are created in the Jira Cloud Platform. This includes when the site doesn't use Jira Service Desk or the project isn't a Jira Service Desk project and, therefore, there is no Jira Service Desk for the issue to be visible on. To create a comment with its visibility in Jira Service Desk set to false, use the Jira Service Desk REST API [Create request comment](https://developer.atlassian.com/cloud/jira/service-desk/rest/#api-rest-servicedeskapi-request-issueIdOrKey-comment-post) operation.
    public var isJsdPublic: Bool?
    /// Whether the comment is made by an outsider who is not part of the issue.
    public var jsdAuthorCanSeeRequest: Bool?
    /// A list of comment properties. Optional on create and update.
    public var properties: [EntityProperty]?

    public init(this: String? = nil, id: String? = nil, author: UserDetails? = nil, body: AnyJSON? = nil, renderedBody: String? = nil, updateAuthor: UserDetails? = nil, created: Date? = nil, updated: Date? = nil, visibility: Visibility? = nil, isJsdPublic: Bool? = nil, jsdAuthorCanSeeRequest: Bool? = nil, properties: [EntityProperty]? = nil) {
        self.this = this
        self.id = id
        self.author = author
        self.body = body
        self.renderedBody = renderedBody
        self.updateAuthor = updateAuthor
        self.created = created
        self.updated = updated
        self.visibility = visibility
        self.isJsdPublic = isJsdPublic
        self.jsdAuthorCanSeeRequest = jsdAuthorCanSeeRequest
        self.properties = properties
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case id
        case author
        case body
        case renderedBody
        case updateAuthor
        case created
        case updated
        case visibility
        case isJsdPublic = "jsdPublic"
        case jsdAuthorCanSeeRequest
        case properties
    }
}

/// Key fields from the linked issue.
public struct Fields: Codable {
    /// The summary description of the linked issue.
    public var summary: String?
    /// The status of the linked issue.
    public var status: StatusDetails?
    /// The priority of the linked issue.
    public var priority: Priority?
    /// The assignee of the linked issue.
    public var assignee: UserDetails?
    /// The time tracking of the linked issue.
    public var timetracking: TimeTrackingDetails?
    /// Details about an issue type.
    public var issuetype: IssueTypeDetails?
    /// The type of the linked issue.
    public var issueType: IssueTypeDetails?

    public init(summary: String? = nil, status: StatusDetails? = nil, priority: Priority? = nil, assignee: UserDetails? = nil, timetracking: TimeTrackingDetails? = nil, issuetype: IssueTypeDetails? = nil, issueType: IssueTypeDetails? = nil) {
        self.summary = summary
        self.status = status
        self.priority = priority
        self.assignee = assignee
        self.timetracking = timetracking
        self.issuetype = issuetype
        self.issueType = issueType
    }
}

/// This object is used as follows:
/// 
///  *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it defines and reports on the type of link between the issues. Find a list of issue link types with [Get issue link types](#api-rest-api-3-issueLinkType-get).
///  *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource it defines and reports on issue link types.
public struct IssueLinkType: Codable {
    /// The ID of the issue link type and is used as follows:
    /// 
    ///  *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is the type of issue link. Required on create when `name` isn't provided. Otherwise, read only.
    ///  *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource it is read only.
    public var id: String?
    /// The name of the issue link type and is used as follows:
    /// 
    ///  *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is the type of issue link. Required on create when `id` isn't provided. Otherwise, read only.
    ///  *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource it is required on create and optional on update. Otherwise, read only.
    public var name: String?
    /// The description of the issue link type inward link and is used as follows:
    /// 
    ///  *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is read only.
    ///  *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource it is required on create and optional on update. Otherwise, read only.
    public var inward: String?
    /// The description of the issue link type outward link and is used as follows:
    /// 
    ///  *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is read only.
    ///  *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource it is required on create and optional on update. Otherwise, read only.
    public var outward: String?
    /// The URL of the issue link type. Read only.
    public var this: URL?

    public init(id: String? = nil, name: String? = nil, inward: String? = nil, outward: String? = nil, this: URL? = nil) {
        self.id = id
        self.name = name
        self.inward = inward
        self.outward = outward
        self.this = this
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case inward
        case outward
        case this = "self"
    }
}

public struct LinkIssueRequestJSONBean: Codable {
    /// This object is used as follows:
    /// 
    ///  *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it defines and reports on the type of link between the issues. Find a list of issue link types with [Get issue link types](#api-rest-api-3-issueLinkType-get).
    ///  *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource it defines and reports on issue link types.
    public var type: IssueLinkType
    /// The ID or key of a linked issue.
    public var inwardIssue: LinkedIssue
    /// The ID or key of a linked issue.
    public var outwardIssue: LinkedIssue
    /// A comment.
    public var comment: Comment?

    public init(type: IssueLinkType, inwardIssue: LinkedIssue, outwardIssue: LinkedIssue, comment: Comment? = nil) {
        self.type = type
        self.inwardIssue = inwardIssue
        self.outwardIssue = outwardIssue
        self.comment = comment
    }
}

/// The ID or key of a linked issue.
public struct LinkedIssue: Codable {
    /// The ID of an issue. Required if `key` isn't provided.
    public var id: String?
    /// The key of an issue. Required if `id` isn't provided.
    public var key: String?
    /// The URL of the issue.
    public var this: URL?
    /// The fields associated with the issue.
    public var fields: Fields?

    public init(id: String? = nil, key: String? = nil, this: URL? = nil, fields: Fields? = nil) {
        self.id = id
        self.key = key
        self.this = this
        self.fields = fields
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case key
        case this = "self"
        case fields
    }
}

public struct RichText: Codable {
    public var isEmptyAdf: Bool?
    public var isValueSet: Bool?
    public var isFinalised: Bool?

    public init(isEmptyAdf: Bool? = nil, isValueSet: Bool? = nil, isFinalised: Bool? = nil) {
        self.isEmptyAdf = isEmptyAdf
        self.isValueSet = isValueSet
        self.isFinalised = isFinalised
    }

    private enum CodingKeys: String, CodingKey {
        case isEmptyAdf = "emptyAdf"
        case isValueSet = "valueSet"
        case isFinalised = "finalised"
    }
}

/// Time tracking details.
public struct TimeTrackingDetails: Codable {
    /// The original estimate of time needed for this issue in readable format.
    public var originalEstimate: String?
    /// The remaining estimate of time needed for this issue in readable format.
    public var remainingEstimate: String?
    /// Time worked on this issue in readable format.
    public var timeSpent: String?
    /// The original estimate of time needed for this issue in seconds.
    public var originalEstimateSeconds: Int?
    /// The remaining estimate of time needed for this issue in seconds.
    public var remainingEstimateSeconds: Int?
    /// Time worked on this issue in seconds.
    public var timeSpentSeconds: Int?

    public init(originalEstimate: String? = nil, remainingEstimate: String? = nil, timeSpent: String? = nil, originalEstimateSeconds: Int? = nil, remainingEstimateSeconds: Int? = nil, timeSpentSeconds: Int? = nil) {
        self.originalEstimate = originalEstimate
        self.remainingEstimate = remainingEstimate
        self.timeSpent = timeSpent
        self.originalEstimateSeconds = originalEstimateSeconds
        self.remainingEstimateSeconds = remainingEstimateSeconds
        self.timeSpentSeconds = timeSpentSeconds
    }
}

/// The group or role to which this item is visible.
public struct Visibility: Codable {
    /// Whether visibility of this item is restricted to a group or role.
    public var type: `Type`?
    /// The name of the group or role to which visibility of this item is restricted.
    public var value: String?

    /// Whether visibility of this item is restricted to a group or role.
    public enum `Type`: String, Codable, CaseIterable {
        case group
        case role
    }

    public init(type: `Type`? = nil, value: String? = nil) {
        self.type = type
        self.value = value
    }
}

/// Details of a link between issues.
public struct IssueLink: Codable {
    /// The ID of the issue link.
    public var id: String?
    /// The URL of the issue link.
    public var this: URL?
    /// The type of link between the issues.
    public var type: IssueLinkType
    /// The issue the link joins to.
    public var inwardIssue: LinkedIssue
    /// The issue the link originates from.
    public var outwardIssue: LinkedIssue

    public init(id: String? = nil, this: URL? = nil, type: IssueLinkType, inwardIssue: LinkedIssue, outwardIssue: LinkedIssue) {
        self.id = id
        self.this = this
        self.type = type
        self.inwardIssue = inwardIssue
        self.outwardIssue = outwardIssue
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case this = "self"
        case type
        case inwardIssue
        case outwardIssue
    }
}

/// Paginated list of worklog details
public struct PageOfWorklogs: Codable {
    /// The index of the first item returned on the page.
    public var startAt: Int?
    /// The maximum number of results that could be on the page.
    public var maxResults: Int?
    /// The number of results on the page.
    public var total: Int?
    /// List of worklogs.
    public var worklogs: [Worklog]?

    public init(startAt: Int? = nil, maxResults: Int? = nil, total: Int? = nil, worklogs: [Worklog]? = nil) {
        self.startAt = startAt
        self.maxResults = maxResults
        self.total = total
        self.worklogs = worklogs
    }
}

/// Details of a worklog.
public struct Worklog: Codable {
    /// The URL of the worklog item.
    public var this: URL?
    /// Details of the user who created the worklog.
    public var author: UserDetails?
    /// Details of the user who last updated the worklog.
    public var updateAuthor: UserDetails?
    /// A comment about the worklog in [Atlassian Document Format](https://developer.atlassian.com/cloud/jira/platform/apis/document/structure/). Optional when creating or updating a worklog.
    public var comment: AnyJSON?
    /// The datetime on which the worklog was created.
    public var created: Date?
    /// The datetime on which the worklog was last updated.
    public var updated: Date?
    /// Details about any restrictions in the visibility of the worklog. Optional when creating or updating a worklog.
    public var visibility: Visibility?
    /// The datetime on which the worklog effort was started. Required when creating a worklog. Optional when updating a worklog.
    public var started: Date?
    /// The time spent working on the issue as days (\#d), hours (\#h), or minutes (\#m or \#). Required when creating a worklog if `timeSpentSeconds` isn't provided. Optional when updating a worklog. Cannot be provided if `timeSpentSecond` is provided.
    public var timeSpent: String?
    /// The time in seconds spent working on the issue. Required when creating a worklog if `timeSpent` isn't provided. Optional when updating a worklog. Cannot be provided if `timeSpent` is provided.
    public var timeSpentSeconds: Int?
    /// The ID of the worklog record.
    public var id: String?
    /// The ID of the issue this worklog is for.
    public var issueID: String?
    /// Details of properties for the worklog. Optional when creating or updating a worklog.
    public var properties: [EntityProperty]?

    public init(this: URL? = nil, author: UserDetails? = nil, updateAuthor: UserDetails? = nil, comment: AnyJSON? = nil, created: Date? = nil, updated: Date? = nil, visibility: Visibility? = nil, started: Date? = nil, timeSpent: String? = nil, timeSpentSeconds: Int? = nil, id: String? = nil, issueID: String? = nil, properties: [EntityProperty]? = nil) {
        self.this = this
        self.author = author
        self.updateAuthor = updateAuthor
        self.comment = comment
        self.created = created
        self.updated = updated
        self.visibility = visibility
        self.started = started
        self.timeSpent = timeSpent
        self.timeSpentSeconds = timeSpentSeconds
        self.id = id
        self.issueID = issueID
        self.properties = properties
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case author
        case updateAuthor
        case comment
        case created
        case updated
        case visibility
        case started
        case timeSpent
        case timeSpentSeconds
        case id
        case issueID = "issueId"
        case properties
    }
}

public struct IssueTypeCreateBean: Codable {
    /// The unique name for the issue type. The maximum length is 60 characters.
    public var name: String
    /// The description of the issue type.
    public var description: String?
    /// Deprecated. Use `hierarchyLevel` instead.
    /// 
    /// Whether the issue type is `subtype` or `standard`. Defaults to `standard`.
    public var type: `Type`?
    /// The hierarchy level of the issue type. Use:
    /// 
    ///  *  `-1` for Subtask.
    ///  *  `0` for Base.
    /// 
    /// Defaults to `0`.
    public var hierarchyLevel: Int?

    /// Deprecated. Use `hierarchyLevel` instead.
    /// 
    /// Whether the issue type is `subtype` or `standard`. Defaults to `standard`.
    public enum `Type`: String, Codable, CaseIterable {
        case subtask
        case standard
    }

    public init(name: String, description: String? = nil, type: `Type`? = nil, hierarchyLevel: Int? = nil) {
        self.name = name
        self.description = description
        self.type = type
        self.hierarchyLevel = hierarchyLevel
    }
}

public struct IssueTypeUpdateBean: Codable {
    /// The unique name for the issue type. The maximum length is 60 characters.
    public var name: String?
    /// The description of the issue type.
    public var description: String?
    /// The ID of an issue type avatar.
    public var avatarID: Int?

    public init(name: String? = nil, description: String? = nil, avatarID: Int? = nil) {
        self.name = name
        self.description = description
        self.avatarID = avatarID
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case description
        case avatarID = "avatarId"
    }
}

/// List of security schemes.
public struct SecuritySchemes: Codable {
    /// List of security schemes.
    public var issueSecuritySchemes: [SecurityScheme]?

    public init(issueSecuritySchemes: [SecurityScheme]? = nil) {
        self.issueSecuritySchemes = issueSecuritySchemes
    }
}

/// Issue security level member.
public struct IssueSecurityLevelMember: Codable {
    /// The ID of the issue security level member.
    public var id: Int
    /// The ID of the issue security level.
    public var issueSecurityLevelID: Int
    /// The user or group being granted the permission. It consists of a `type` and a type-dependent `parameter`. See [Holder object](../api-group-permission-schemes/#holder-object) in *Get all permission schemes* for more information.
    public var holder: PermissionHolder

    public init(id: Int, issueSecurityLevelID: Int, holder: PermissionHolder) {
        self.id = id
        self.issueSecurityLevelID = issueSecurityLevelID
        self.holder = holder
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case issueSecurityLevelID = "issueSecurityLevelId"
        case holder
    }
}

/// A page of items.
public struct PageBeanIssueSecurityLevelMember: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [IssueSecurityLevelMember]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [IssueSecurityLevelMember]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// List of issue transitions.
public struct Transitions: Codable {
    /// Expand options that include additional transitions details in the response.
    public var expand: String?
    /// List of issue transitions.
    public var transitions: [IssueTransition]?

    public init(expand: String? = nil, transitions: [IssueTransition]? = nil) {
        self.expand = expand
        self.transitions = transitions
    }
}

/// A list of issues suggested for use in auto-completion.
public struct IssuePickerSuggestions: Codable {
    /// A list of issues for an issue type suggested for use in auto-completion.
    public var sections: [IssuePickerSuggestionsIssueType]?

    public init(sections: [IssuePickerSuggestionsIssueType]? = nil) {
        self.sections = sections
    }
}

/// A type of issue suggested for use in auto-completion.
public struct IssuePickerSuggestionsIssueType: Codable {
    /// The label of the type of issues suggested for use in auto-completion.
    public var label: String?
    /// If issue suggestions are found, returns a message indicating the number of issues suggestions found and returned.
    public var sub: String?
    /// The ID of the type of issues suggested for use in auto-completion.
    public var id: String?
    /// If no issue suggestions are found, returns a message indicating no suggestions were found,
    public var msg: String?
    /// A list of issues suggested for use in auto-completion.
    public var issues: [SuggestedIssue]?

    public init(label: String? = nil, sub: String? = nil, id: String? = nil, msg: String? = nil, issues: [SuggestedIssue]? = nil) {
        self.label = label
        self.sub = sub
        self.id = id
        self.msg = msg
        self.issues = issues
    }
}

/// An issue suggested for use in the issue picker auto-completion.
public struct SuggestedIssue: Codable {
    /// The ID of the issue.
    public var id: Int?
    /// The key of the issue.
    public var key: String?
    /// The key of the issue in HTML format.
    public var keyHTML: String?
    /// The URL of the issue type's avatar.
    public var img: String?
    /// The phrase containing the query string in HTML format, with the string highlighted with HTML bold tags.
    public var summary: String?
    /// The phrase containing the query string, as plain text.
    public var summaryText: String?

    public init(id: Int? = nil, key: String? = nil, keyHTML: String? = nil, img: String? = nil, summary: String? = nil, summaryText: String? = nil) {
        self.id = id
        self.key = key
        self.keyHTML = keyHTML
        self.img = img
        self.summary = summary
        self.summaryText = summaryText
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case key
        case keyHTML = "keyHtml"
        case img
        case summary
        case summaryText
    }
}

/// Details of an operation to perform on a field.
public struct FieldUpdateOperation: Codable {
    /// The value to add to the field.
    ///
    /// Example: "triaged"
    public var add: AnyJSON?
    /// The value to set in the field.
    ///
    /// Example: "A new summary"
    public var set: AnyJSON?
    /// The value to removed from the field.
    ///
    /// Example: "blocker"
    public var remove: AnyJSON?
    /// The value to edit in the field.
    ///
    /// Example:
    ///
    /// {
    ///   "originalEstimate" : "1w 1d",
    ///   "remainingEstimate" : "4d"
    /// }
    public var edit: AnyJSON?

    public init(add: AnyJSON? = nil, set: AnyJSON? = nil, remove: AnyJSON? = nil, edit: AnyJSON? = nil) {
        self.add = add
        self.set = set
        self.remove = remove
        self.edit = edit
    }
}

/// Details of an issue update request.
public struct IssueUpdateDetails: Codable {
    /// Details of a transition. Required when performing a transition, optional when creating or editing an issue.
    public var transition: IssueTransition?
    /// List of issue screen fields to update, specifying the sub-field to update and its value for each field. This field provides a straightforward option when setting a sub-field. When multiple sub-fields or other operations are required, use `update`. Fields included in here cannot be included in `update`.
    public var fields: [String: AnyJSON]?
    /// A Map containing the field field name and a list of operations to perform on the issue screen field. Note that fields included in here cannot be included in `fields`.
    public var update: [String: [FieldUpdateOperation]]?
    /// Additional issue history details.
    public var historyMetadata: HistoryMetadata?
    /// Details of issue properties to be add or update.
    public var properties: [EntityProperty]?

    public init(transition: IssueTransition? = nil, fields: [String: AnyJSON]? = nil, update: [String: [FieldUpdateOperation]]? = nil, historyMetadata: HistoryMetadata? = nil, properties: [EntityProperty]? = nil) {
        self.transition = transition
        self.fields = fields
        self.update = update
        self.historyMetadata = historyMetadata
        self.properties = properties
    }
}

/// The details of votes on an issue.
public struct Votes: Codable {
    /// The URL of these issue vote details.
    public var this: URL?
    /// The number of votes on the issue.
    public var votes: Int?
    /// Whether the user making this request has voted on the issue.
    public var hasVoted: Bool?
    /// List of the users who have voted on this issue. An empty list is returned when the calling user doesn't have the *View voters and watchers* project permission.
    public var voters: [User]?

    public init(this: URL? = nil, votes: Int? = nil, hasVoted: Bool? = nil, voters: [User]? = nil) {
        self.this = this
        self.votes = votes
        self.hasVoted = hasVoted
        self.voters = voters
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case votes
        case hasVoted
        case voters
    }
}

/// A list of issue IDs.
public struct IssueList: Codable {
    /// The list of issue IDs.
    public var issueIDs: [String]

    public init(issueIDs: [String]) {
        self.issueIDs = issueIDs
    }

    private enum CodingKeys: String, CodingKey {
        case issueIDs = "issueIds"
    }
}

/// A container for the watch status of a list of issues.
public struct BulkIssueIsWatching: Codable {
    /// The map of issue ID to boolean watch status.
    public var issuesIsWatching: [String: Bool]?

    public init(issuesIsWatching: [String: Bool]? = nil) {
        self.issuesIsWatching = issuesIsWatching
    }
}

/// The details of watchers on an issue.
public struct Watchers: Codable {
    /// The URL of these issue watcher details.
    public var this: String?
    /// Whether the calling user is watching this issue.
    public var isWatching: Bool?
    /// The number of users watching this issue.
    public var watchCount: Int?
    /// Details of the users watching this issue.
    public var watchers: [UserDetails]?

    public init(this: String? = nil, isWatching: Bool? = nil, watchCount: Int? = nil, watchers: [UserDetails]? = nil) {
        self.this = this
        self.isWatching = isWatching
        self.watchCount = watchCount
        self.watchers = watchers
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case isWatching
        case watchCount
        case watchers
    }
}

/// Details about a created issue or subtask.
public struct CreatedIssue: Codable {
    /// The ID of the created issue or subtask.
    public var id: String?
    /// The key of the created issue or subtask.
    public var key: String?
    /// The URL of the created issue or subtask.
    public var this: String?
    /// The response code and messages related to any requested transition.
    public var transition: NestedResponse?

    public init(id: String? = nil, key: String? = nil, this: String? = nil, transition: NestedResponse? = nil) {
        self.id = id
        self.key = key
        self.this = this
        self.transition = transition
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case key
        case this = "self"
        case transition
    }
}

public struct NestedResponse: Codable {
    public var status: Int?
    /// Error messages from an operation.
    public var errorCollection: ErrorCollection?

    public init(status: Int? = nil, errorCollection: ErrorCollection? = nil) {
        self.status = status
        self.errorCollection = errorCollection
    }
}

public struct IssuesUpdateBean: Codable {
    public var issueUpdates: [IssueUpdateDetails]?

    public init(issueUpdates: [IssueUpdateDetails]? = nil) {
        self.issueUpdates = issueUpdates
    }
}

public struct BulkOperationErrorResult: Codable {
    public var status: Int?
    /// Error messages from an operation.
    public var elementErrors: ErrorCollection?
    public var failedElementNumber: Int?

    public init(status: Int? = nil, elementErrors: ErrorCollection? = nil, failedElementNumber: Int? = nil) {
        self.status = status
        self.elementErrors = elementErrors
        self.failedElementNumber = failedElementNumber
    }
}

/// Details about the issues created and the errors for requests that failed.
public struct CreatedIssues: Codable {
    /// Details of the issues created.
    public var issues: [CreatedIssue]?
    /// Error details for failed issue creation requests.
    public var errors: [BulkOperationErrorResult]?

    public init(issues: [CreatedIssue]? = nil, errors: [BulkOperationErrorResult]? = nil) {
        self.issues = issues
        self.errors = errors
    }
}

/// The wrapper for the issue creation metadata for a list of projects.
public struct IssueCreateMetadata: Codable {
    /// Expand options that include additional project details in the response.
    public var expand: String?
    /// List of projects and their issue creation metadata.
    public var projects: [ProjectIssueCreateMetadata]?

    public init(expand: String? = nil, projects: [ProjectIssueCreateMetadata]? = nil) {
        self.expand = expand
        self.projects = projects
    }
}

/// Details of the issue creation metadata for an issue type.
public struct IssueTypeIssueCreateMetadata: Codable {
    /// The URL of these issue type details.
    public var this: String?
    /// The ID of the issue type.
    public var id: String?
    /// The description of the issue type.
    public var description: String?
    /// The URL of the issue type's avatar.
    public var iconURL: String?
    /// The name of the issue type.
    public var name: String?
    /// Whether this issue type is used to create subtasks.
    public var isSubtask: Bool?
    /// The ID of the issue type's avatar.
    public var avatarID: Int?
    /// Unique ID for next-gen projects.
    public var entityID: String?
    /// Hierarchy level of the issue type.
    public var hierarchyLevel: Int?
    /// Details of the next-gen projects the issue type is available in.
    public var scope: Scope?
    /// Expand options that include additional issue type metadata details in the response.
    public var expand: String?
    /// List of the fields available when creating an issue for the issue type.
    public var fields: [String: FieldMetadata]?

    public init(this: String? = nil, id: String? = nil, description: String? = nil, iconURL: String? = nil, name: String? = nil, isSubtask: Bool? = nil, avatarID: Int? = nil, entityID: String? = nil, hierarchyLevel: Int? = nil, scope: Scope? = nil, expand: String? = nil, fields: [String: FieldMetadata]? = nil) {
        self.this = this
        self.id = id
        self.description = description
        self.iconURL = iconURL
        self.name = name
        self.isSubtask = isSubtask
        self.avatarID = avatarID
        self.entityID = entityID
        self.hierarchyLevel = hierarchyLevel
        self.scope = scope
        self.expand = expand
        self.fields = fields
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case id
        case description
        case iconURL = "iconUrl"
        case name
        case isSubtask = "subtask"
        case avatarID = "avatarId"
        case entityID = "entityId"
        case hierarchyLevel
        case scope
        case expand
        case fields
    }
}

/// Details of the issue creation metadata for a project.
public struct ProjectIssueCreateMetadata: Codable {
    /// Expand options that include additional project issue create metadata details in the response.
    public var expand: String?
    /// The URL of the project.
    public var this: String?
    /// The ID of the project.
    public var id: String?
    /// The key of the project.
    public var key: String?
    /// The name of the project.
    public var name: String?
    /// List of the project's avatars, returning the avatar size and associated URL.
    public var avatarURLs: AvatarURLsBean?
    /// List of the issue types supported by the project.
    public var issuetypes: [IssueTypeIssueCreateMetadata]?

    public init(expand: String? = nil, this: String? = nil, id: String? = nil, key: String? = nil, name: String? = nil, avatarURLs: AvatarURLsBean? = nil, issuetypes: [IssueTypeIssueCreateMetadata]? = nil) {
        self.expand = expand
        self.this = this
        self.id = id
        self.key = key
        self.name = name
        self.avatarURLs = avatarURLs
        self.issuetypes = issuetypes
    }

    private enum CodingKeys: String, CodingKey {
        case expand
        case this = "self"
        case id
        case key
        case name
        case avatarURLs = "avatarUrls"
        case issuetypes
    }
}

/// The application the linked item is in.
public struct Application: Codable {
    /// The name-spaced type of the application, used by registered rendering apps.
    public var type: String?
    /// The name of the application. Used in conjunction with the (remote) object icon title to display a tooltip for the link's icon. The tooltip takes the format "\[application name\] icon title". Blank items are excluded from the tooltip title. If both items are blank, the icon tooltop displays as "Web Link". Grouping and sorting of links may place links without an application name last.
    public var name: String?

    public init(type: String? = nil, name: String? = nil) {
        self.type = type
        self.name = name
    }
}

/// An icon.
public struct IconBean: Codable {
    /// The URL of a 16x16 pixel icon.
    public var url16x16: String?
    /// The title of the icon, for use as a tooltip on the icon.
    public var title: String?
    /// The URL of the tooltip, used only for a status icon.
    public var link: String?

    public init(url16x16: String? = nil, title: String? = nil, link: String? = nil) {
        self.url16x16 = url16x16
        self.title = title
        self.link = link
    }
}

/// Details of an issue remote link.
public struct RemoteIssueLink: Codable {
    /// The ID of the link.
    public var id: Int?
    /// The URL of the link.
    public var this: URL?
    /// The global ID of the link, such as the ID of the item on the remote system.
    public var globalID: String?
    /// Details of the remote application the linked item is in.
    public var application: Application?
    /// Description of the relationship between the issue and the linked item.
    public var relationship: String?
    /// Details of the item linked to.
    public var object: RemoteObject?

    public init(id: Int? = nil, this: URL? = nil, globalID: String? = nil, application: Application? = nil, relationship: String? = nil, object: RemoteObject? = nil) {
        self.id = id
        self.this = this
        self.globalID = globalID
        self.application = application
        self.relationship = relationship
        self.object = object
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case this = "self"
        case globalID = "globalId"
        case application
        case relationship
        case object
    }
}

/// The linked item.
public struct RemoteObject: Codable {
    /// The URL of the item.
    public var url: String
    /// The title of the item.
    public var title: String
    /// The summary details of the item.
    public var summary: String?
    /// Details of the icon for the item. If no icon is defined, the default link icon is used in Jira.
    public var icon: Icon?
    /// The status of the item.
    public var status: Status?

    public init(url: String, title: String, summary: String? = nil, icon: Icon? = nil, status: Status? = nil) {
        self.url = url
        self.title = title
        self.summary = summary
        self.icon = icon
        self.status = status
    }
}

/// The status of the item.
public struct Status: Codable {
    /// Whether the item is resolved. If set to "true", the link to the issue is displayed in a strikethrough font, otherwise the link displays in normal font.
    public var isResolved: Bool?
    /// Details of the icon representing the status. If not provided, no status icon displays in Jira.
    public var icon: Icon?

    public init(isResolved: Bool? = nil, icon: Icon? = nil) {
        self.isResolved = isResolved
        self.icon = icon
    }

    private enum CodingKeys: String, CodingKey {
        case isResolved = "resolved"
        case icon
    }
}

/// An icon. If no icon is defined:
/// 
///  *  for a status icon, no status icon displays in Jira.
///  *  for the remote object icon, the default link icon displays in Jira.
public struct Icon: Codable {
    /// The URL of an icon that displays at 16x16 pixel in Jira.
    public var url16x16: String?
    /// The title of the icon. This is used as follows:
    /// 
    ///  *  For a status icon it is used as a tooltip on the icon. If not set, the status icon doesn't display a tooltip in Jira.
    ///  *  For the remote object icon it is used in conjunction with the application name to display a tooltip for the link's icon. The tooltip takes the format "\[application name\] icon title". Blank itemsare excluded from the tooltip title. If both items are blank, the icon tooltop displays as "Web Link".
    public var title: String?
    /// The URL of the tooltip, used only for a status icon. If not set, the status icon in Jira is not clickable.
    public var link: String?

    public init(url16x16: String? = nil, title: String? = nil, link: String? = nil) {
        self.url16x16 = url16x16
        self.title = title
        self.link = link
    }
}

/// Details of a remote issue link.
public struct RemoteIssueLinkRequest: Codable {
    /// An identifier for the remote item in the remote system. For example, the global ID for a remote item in Confluence would consist of the app ID and page ID, like this: `appId=456&pageId=123`.
    /// 
    /// Setting this field enables the remote issue link details to be updated or deleted using remote system and item details as the record identifier, rather than using the record's Jira ID.
    /// 
    /// The maximum length is 255 characters.
    public var globalID: String?
    /// Details of the remote application the linked item is in. For example, trello.
    public var application: Application?
    /// Description of the relationship between the issue and the linked item. If not set, the relationship description "links to" is used in Jira.
    public var relationship: String?
    /// Details of the item linked to.
    public var object: RemoteObject

    public init(globalID: String? = nil, application: Application? = nil, relationship: String? = nil, object: RemoteObject) {
        self.globalID = globalID
        self.application = application
        self.relationship = relationship
        self.object = object
    }

    private enum CodingKeys: String, CodingKey {
        case globalID = "globalId"
        case application
        case relationship
        case object
    }
}

/// Details of the identifiers for a created or updated remote issue link.
public struct RemoteIssueLinkIdentifies: Codable {
    /// The ID of the remote issue link, such as the ID of the item on the remote system.
    public var id: Int?
    /// The URL of the remote issue link.
    public var this: String?

    public init(id: Int? = nil, this: String? = nil) {
        self.id = id
        self.this = this
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case this = "self"
    }
}

/// Details about a notification.
public struct Notification: Codable {
    /// The subject of the email notification for the issue. If this is not specified, then the subject is set to the issue key and summary.
    public var subject: String?
    /// The plain text body of the email notification for the issue.
    public var textBody: String?
    /// The HTML body of the email notification for the issue.
    public var htmlBody: String?
    /// The recipients of the email notification for the issue.
    public var to: NotificationRecipients?
    /// Restricts the notifications to users with the specified permissions.
    public var restrict: NotificationRecipientsRestrictions?

    public init(subject: String? = nil, textBody: String? = nil, htmlBody: String? = nil, to: NotificationRecipients? = nil, restrict: NotificationRecipientsRestrictions? = nil) {
        self.subject = subject
        self.textBody = textBody
        self.htmlBody = htmlBody
        self.to = to
        self.restrict = restrict
    }
}

/// Details of the users and groups to receive the notification.
public struct NotificationRecipients: Codable {
    /// Whether the notification should be sent to the issue's reporter.
    public var isReporter: Bool?
    /// Whether the notification should be sent to the issue's assignees.
    public var isAssignee: Bool?
    /// Whether the notification should be sent to the issue's watchers.
    public var isWatchers: Bool?
    /// Whether the notification should be sent to the issue's voters.
    public var isVoters: Bool?
    /// List of users to receive the notification.
    public var users: [UserDetails]?
    /// List of groups to receive the notification.
    public var groups: [GroupName]?

    public init(isReporter: Bool? = nil, isAssignee: Bool? = nil, isWatchers: Bool? = nil, isVoters: Bool? = nil, users: [UserDetails]? = nil, groups: [GroupName]? = nil) {
        self.isReporter = isReporter
        self.isAssignee = isAssignee
        self.isWatchers = isWatchers
        self.isVoters = isVoters
        self.users = users
        self.groups = groups
    }

    private enum CodingKeys: String, CodingKey {
        case isReporter = "reporter"
        case isAssignee = "assignee"
        case isWatchers = "watchers"
        case isVoters = "voters"
        case users
        case groups
    }
}

/// Details of the group membership or permissions needed to receive the notification.
public struct NotificationRecipientsRestrictions: Codable {
    /// List of group memberships required to receive the notification.
    public var groups: [GroupName]?
    /// List of permissions required to receive the notification.
    public var permissions: [RestrictedPermission]?

    public init(groups: [GroupName]? = nil, permissions: [RestrictedPermission]? = nil) {
        self.groups = groups
        self.permissions = permissions
    }
}

/// Details of the permission.
public struct RestrictedPermission: Codable {
    /// The ID of the permission. Either `id` or `key` must be specified. Use [Get all permissions](#api-rest-api-3-permissions-get) to get the list of permissions.
    public var id: String?
    /// The key of the permission. Either `id` or `key` must be specified. Use [Get all permissions](#api-rest-api-3-permissions-get) to get the list of permissions.
    public var key: String?

    public init(id: String? = nil, key: String? = nil) {
        self.id = id
        self.key = key
    }
}

/// A list of issue link type beans.
public struct IssueLinkTypes: Codable {
    /// The issue link type bean.
    public var issueLinkTypes: [IssueLinkType]?

    public init(issueLinkTypes: [IssueLinkType]? = nil) {
        self.issueLinkTypes = issueLinkTypes
    }
}

/// A page of comments.
public struct PageOfComments: Codable {
    /// The index of the first item returned.
    public var startAt: Int?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The number of items returned.
    public var total: Int?
    /// The list of comments.
    public var comments: [Comment]?

    public init(startAt: Int? = nil, maxResults: Int? = nil, total: Int? = nil, comments: [Comment]? = nil) {
        self.startAt = startAt
        self.maxResults = maxResults
        self.total = total
        self.comments = comments
    }
}

public struct PaginatedResponseComment: Codable {
    public var total: Int?
    public var results: [Comment]?
    public var startAt: Int?
    public var maxResults: Int?

    public init(total: Int? = nil, results: [Comment]? = nil, startAt: Int? = nil, maxResults: Int? = nil) {
        self.total = total
        self.results = results
        self.startAt = startAt
        self.maxResults = maxResults
    }
}

public struct IssueCommentListRequestBean: Codable {
    /// The list of comment IDs. A maximum of 1000 IDs can be specified.
    public var ids: [Int]

    public init(ids: [Int]) {
        self.ids = ids
    }
}

/// A page of items.
public struct PageBeanComment: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [Comment]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [Comment]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// A page of items.
public struct PageBeanChangelog: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [Changelog]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [Changelog]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// A list of changelog IDs.
public struct IssueChangelogIDs: Codable {
    /// The list of changelog IDs.
    public var changelogIDs: [Int]

    public init(changelogIDs: [Int]) {
        self.changelogIDs = changelogIDs
    }

    private enum CodingKeys: String, CodingKey {
        case changelogIDs = "changelogIds"
    }
}

/// Details about an attachment.
public struct Attachment: Codable {
    /// The URL of the attachment details response.
    public var this: String?
    /// The ID of the attachment.
    public var id: String?
    /// The file name of the attachment.
    public var filename: String?
    /// Details of the user who added the attachment.
    public var author: UserDetails?
    /// The datetime the attachment was created.
    public var created: Date?
    /// The size of the attachment.
    public var size: Int?
    /// The MIME type of the attachment.
    public var mimeType: String?
    /// The content of the attachment.
    public var content: String?
    /// The URL of a thumbnail representing the attachment.
    public var thumbnail: String?

    public init(this: String? = nil, id: String? = nil, filename: String? = nil, author: UserDetails? = nil, created: Date? = nil, size: Int? = nil, mimeType: String? = nil, content: String? = nil, thumbnail: String? = nil) {
        self.this = this
        self.id = id
        self.filename = filename
        self.author = author
        self.created = created
        self.size = size
        self.mimeType = mimeType
        self.content = content
        self.thumbnail = thumbnail
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case id
        case filename
        case author
        case created
        case size
        case mimeType
        case content
        case thumbnail
    }
}

public struct Group: Codable {
    /// The name of group.
    public var name: String?
    /// The URL for these group details.
    public var this: URL?
    /// A paginated list of the users that are members of the group. A maximum of 50 users is returned in the list, to access additional users append `[start-index:end-index]` to the expand request. For example, to access the next 50 users, use`?expand=users[51:100]`.
    public var users: PagedListUserDetailsApplicationUser?
    /// Expand options that include additional group details in the response.
    public var expand: String?

    public init(name: String? = nil, this: URL? = nil, users: PagedListUserDetailsApplicationUser? = nil, expand: String? = nil) {
        self.name = name
        self.this = this
        self.users = users
        self.expand = expand
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case this = "self"
        case users
        case expand
    }
}

/// A paged list. To access additional details append `[start-index:end-index]` to the expand request. For example, `?expand=sharedUsers[10:40]` returns a list starting at item 10 and finishing at item 40.
public struct PagedListUserDetailsApplicationUser: Codable {
    /// The number of items on the page.
    public var size: Int?
    /// The list of items.
    public var items: [UserDetails]?
    /// The maximum number of results that could be on the page.
    public var maxResults: Int?
    /// The index of the first item returned on the page.
    public var startIndex: Int?
    /// The index of the last item returned on the page.
    public var endIndex: Int?

    public init(size: Int? = nil, items: [UserDetails]? = nil, maxResults: Int? = nil, startIndex: Int? = nil, endIndex: Int? = nil) {
        self.size = size
        self.items = items
        self.maxResults = maxResults
        self.startIndex = startIndex
        self.endIndex = endIndex
    }

    private enum CodingKeys: String, CodingKey {
        case size
        case items
        case maxResults = "max-results"
        case startIndex = "start-index"
        case endIndex = "end-index"
    }
}

/// A page of items.
public struct PageBeanUserDetails: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [UserDetails]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [UserDetails]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

public struct AddGroupBean: Codable {
    /// The name of the group.
    public var name: String

    public init(name: String) {
        self.name = name
    }
}

public struct UpdateUserToGroupBean: Codable {
    /// This property is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
    public var name: String?
    /// The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
    public var accountID: String?

    public init(name: String? = nil, accountID: String? = nil) {
        self.name = name
        self.accountID = accountID
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case accountID = "accountId"
    }
}

/// A group found in a search.
public struct FoundGroup: Codable {
    /// The name of the group.
    public var name: String?
    /// The group name with the matched query string highlighted with the HTML bold tag.
    public var html: String?
    public var labels: [GroupLabel]?
    /// The ID of the group, if available, which uniquely identifies the group across all Atlassian products. For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*.
    public var groupID: String?

    public init(name: String? = nil, html: String? = nil, labels: [GroupLabel]? = nil, groupID: String? = nil) {
        self.name = name
        self.html = html
        self.labels = labels
        self.groupID = groupID
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case html
        case labels
        case groupID = "groupId"
    }
}

/// The list of groups found in a search, including header text (Showing X of Y matching groups) and total of matched groups.
public struct FoundGroups: Codable {
    /// Header text indicating the number of groups in the response and the total number of groups found in the search.
    public var header: String?
    /// The total number of groups found in the search.
    public var total: Int?
    public var groups: [FoundGroup]?

    public init(header: String? = nil, total: Int? = nil, groups: [FoundGroup]? = nil) {
        self.header = header
        self.total = total
        self.groups = groups
    }
}

/// A group label.
public struct GroupLabel: Codable {
    /// The group label name.
    public var text: String?
    /// The title of the group label.
    public var title: String?
    /// The type of the group label.
    public var type: `Type`?

    /// The type of the group label.
    public enum `Type`: String, Codable, CaseIterable {
        case admin = "ADMIN"
        case single = "SINGLE"
        case multiple = "MULTIPLE"
    }

    public init(text: String? = nil, title: String? = nil, type: `Type`? = nil) {
        self.text = text
        self.title = title
        self.type = type
    }
}

/// List of users and groups found in a search.
public struct FoundUsersAndGroups: Codable {
    /// The list of users found in a search, including header text (Showing X of Y matching users) and total of matched users.
    public var users: FoundUsers?
    /// The list of groups found in a search, including header text (Showing X of Y matching groups) and total of matched groups.
    public var groups: FoundGroups?

    public init(users: FoundUsers? = nil, groups: FoundGroups? = nil) {
        self.users = users
        self.groups = groups
    }
}

public struct CustomFieldDefinitionJSONBean: Codable {
    /// The name of the custom field, which is displayed in Jira. This is not the unique identifier.
    public var name: String
    /// The description of the custom field, which is displayed in Jira.
    public var description: String?
    /// The type of the custom field. These built-in custom field types are available:
    /// 
    ///  *  `cascadingselect`: Enables values to be selected from two levels of select lists (value: `com.atlassian.jira.plugin.system.customfieldtypes:cascadingselect`)
    ///  *  `datepicker`: Stores a date using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:datepicker`)
    ///  *  `datetime`: Stores a date with a time component (value: `com.atlassian.jira.plugin.system.customfieldtypes:datetime`)
    ///  *  `float`: Stores and validates a numeric (floating point) input (value: `com.atlassian.jira.plugin.system.customfieldtypes:float`)
    ///  *  `grouppicker`: Stores a user group using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:grouppicker`)
    ///  *  `importid`: A read-only field that stores the ID the issue had in the system it was imported from (value: `com.atlassian.jira.plugin.system.customfieldtypes:importid`)
    ///  *  `labels`: Stores labels (value: `com.atlassian.jira.plugin.system.customfieldtypes:labels`)
    ///  *  `multicheckboxes`: Stores multiple values using checkboxes (value: ``)
    ///  *  `multigrouppicker`: Stores multiple user groups using a picker control (value: ``)
    ///  *  `multiselect`: Stores multiple values using a select list (value: `com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes`)
    ///  *  `multiuserpicker`: Stores multiple users using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:multigrouppicker`)
    ///  *  `multiversion`: Stores multiple versions from the versions available in a project using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:multiversion`)
    ///  *  `project`: Stores a project from a list of projects that the user is permitted to view (value: `com.atlassian.jira.plugin.system.customfieldtypes:project`)
    ///  *  `radiobuttons`: Stores a value using radio buttons (value: `com.atlassian.jira.plugin.system.customfieldtypes:radiobuttons`)
    ///  *  `readonlyfield`: Stores a read-only text value, which can only be populated via the API (value: `com.atlassian.jira.plugin.system.customfieldtypes:readonlyfield`)
    ///  *  `select`: Stores a value from a configurable list of options (value: `com.atlassian.jira.plugin.system.customfieldtypes:select`)
    ///  *  `textarea`: Stores a long text string using a multiline text area (value: `com.atlassian.jira.plugin.system.customfieldtypes:textarea`)
    ///  *  `textfield`: Stores a text string using a single-line text box (value: `com.atlassian.jira.plugin.system.customfieldtypes:textfield`)
    ///  *  `url`: Stores a URL (value: `com.atlassian.jira.plugin.system.customfieldtypes:url`)
    ///  *  `userpicker`: Stores a user using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:userpicker`)
    ///  *  `version`: Stores a version using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:version`)
    /// 
    /// To create a field based on a [Forge custom field type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/#jira-custom-field-type--beta-), use the ID of the Forge custom field type as the value. For example, `ari:cloud:ecosystem::extension/e62f20a2-4b61-4dbe-bfb9-9a88b5e3ac84/548c5df1-24aa-4f7c-bbbb-3038d947cb05/static/my-cf-type-key`.
    public var type: String
    /// The searcher defines the way the field is searched in Jira. For example, *com.atlassian.jira.plugin.system.customfieldtypes:grouppickersearcher*.
    /// The search UI (basic search and JQL search) will display different operations and values for the field, based on the field searcher. You must specify a searcher that is valid for the field type, as listed below (abbreviated values shown):
    /// 
    ///  *  `cascadingselect`: `cascadingselectsearcher`
    ///  *  `datepicker`: `daterange`
    ///  *  `datetime`: `datetimerange`
    ///  *  `float`: `exactnumber` or `numberrange`
    ///  *  `grouppicker`: `grouppickersearcher`
    ///  *  `importid`: `exactnumber` or `numberrange`
    ///  *  `labels`: `labelsearcher`
    ///  *  `multicheckboxes`: `multiselectsearcher`
    ///  *  `multigrouppicker`: `multiselectsearcher`
    ///  *  `multiselect`: `multiselectsearcher`
    ///  *  `multiuserpicker`: `userpickergroupsearcher`
    ///  *  `multiversion`: `versionsearcher`
    ///  *  `project`: `projectsearcher`
    ///  *  `radiobuttons`: `multiselectsearcher`
    ///  *  `readonlyfield`: `textsearcher`
    ///  *  `select`: `multiselectsearcher`
    ///  *  `textarea`: `textsearcher`
    ///  *  `textfield`: `textsearcher`
    ///  *  `url`: `exacttextsearcher`
    ///  *  `userpicker`: `userpickergroupsearcher`
    ///  *  `version`: `versionsearcher`
    /// 
    /// If no searcher is provided, the field isn't searchable. However, [Forge custom fields](https://developer.atlassian.com/platform/forge/manifest-reference/modules/#jira-custom-field-type--beta-) have a searcher set automatically, so are always searchable.
    public var searcherKey: SearcherKey?

    /// The searcher defines the way the field is searched in Jira. For example, *com.atlassian.jira.plugin.system.customfieldtypes:grouppickersearcher*.
    /// The search UI (basic search and JQL search) will display different operations and values for the field, based on the field searcher. You must specify a searcher that is valid for the field type, as listed below (abbreviated values shown):
    /// 
    ///  *  `cascadingselect`: `cascadingselectsearcher`
    ///  *  `datepicker`: `daterange`
    ///  *  `datetime`: `datetimerange`
    ///  *  `float`: `exactnumber` or `numberrange`
    ///  *  `grouppicker`: `grouppickersearcher`
    ///  *  `importid`: `exactnumber` or `numberrange`
    ///  *  `labels`: `labelsearcher`
    ///  *  `multicheckboxes`: `multiselectsearcher`
    ///  *  `multigrouppicker`: `multiselectsearcher`
    ///  *  `multiselect`: `multiselectsearcher`
    ///  *  `multiuserpicker`: `userpickergroupsearcher`
    ///  *  `multiversion`: `versionsearcher`
    ///  *  `project`: `projectsearcher`
    ///  *  `radiobuttons`: `multiselectsearcher`
    ///  *  `readonlyfield`: `textsearcher`
    ///  *  `select`: `multiselectsearcher`
    ///  *  `textarea`: `textsearcher`
    ///  *  `textfield`: `textsearcher`
    ///  *  `url`: `exacttextsearcher`
    ///  *  `userpicker`: `userpickergroupsearcher`
    ///  *  `version`: `versionsearcher`
    /// 
    /// If no searcher is provided, the field isn't searchable. However, [Forge custom fields](https://developer.atlassian.com/platform/forge/manifest-reference/modules/#jira-custom-field-type--beta-) have a searcher set automatically, so are always searchable.
    public enum SearcherKey: String, Codable, CaseIterable {
        case comAtlassianJiraPluginSystemCustomfieldtypesCascadingselectsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:cascadingselectsearcher"
        case comAtlassianJiraPluginSystemCustomfieldtypesDaterange = "com.atlassian.jira.plugin.system.customfieldtypes:daterange"
        case comAtlassianJiraPluginSystemCustomfieldtypesDatetimerange = "com.atlassian.jira.plugin.system.customfieldtypes:datetimerange"
        case comAtlassianJiraPluginSystemCustomfieldtypesExactnumber = "com.atlassian.jira.plugin.system.customfieldtypes:exactnumber"
        case comAtlassianJiraPluginSystemCustomfieldtypesExacttextsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:exacttextsearcher"
        case comAtlassianJiraPluginSystemCustomfieldtypesGrouppickersearcher = "com.atlassian.jira.plugin.system.customfieldtypes:grouppickersearcher"
        case comAtlassianJiraPluginSystemCustomfieldtypesLabelsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:labelsearcher"
        case comAtlassianJiraPluginSystemCustomfieldtypesMultiselectsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:multiselectsearcher"
        case comAtlassianJiraPluginSystemCustomfieldtypesNumberrange = "com.atlassian.jira.plugin.system.customfieldtypes:numberrange"
        case comAtlassianJiraPluginSystemCustomfieldtypesProjectsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:projectsearcher"
        case comAtlassianJiraPluginSystemCustomfieldtypesTextsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:textsearcher"
        case comAtlassianJiraPluginSystemCustomfieldtypesUserpickergroupsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:userpickergroupsearcher"
        case comAtlassianJiraPluginSystemCustomfieldtypesVersionsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:versionsearcher"
    }

    public init(name: String, description: String? = nil, type: String, searcherKey: SearcherKey? = nil) {
        self.name = name
        self.description = description
        self.type = type
        self.searcherKey = searcherKey
    }
}

/// Details of a custom field.
public struct UpdateCustomFieldDetails: Codable {
    /// The name of the custom field. It doesn't have to be unique. The maximum length is 255 characters.
    public var name: String?
    /// The description of the custom field. The maximum length is 40000 characters.
    public var description: String?
    /// The searcher that defines the way the field is searched in Jira. It can be set to `null`, otherwise you must specify the valid searcher for the field type, as listed below (abbreviated values shown):
    /// 
    ///  *  `cascadingselect`: `cascadingselectsearcher`
    ///  *  `datepicker`: `daterange`
    ///  *  `datetime`: `datetimerange`
    ///  *  `float`: `exactnumber` or `numberrange`
    ///  *  `grouppicker`: `grouppickersearcher`
    ///  *  `importid`: `exactnumber` or `numberrange`
    ///  *  `labels`: `labelsearcher`
    ///  *  `multicheckboxes`: `multiselectsearcher`
    ///  *  `multigrouppicker`: `multiselectsearcher`
    ///  *  `multiselect`: `multiselectsearcher`
    ///  *  `multiuserpicker`: `userpickergroupsearcher`
    ///  *  `multiversion`: `versionsearcher`
    ///  *  `project`: `projectsearcher`
    ///  *  `radiobuttons`: `multiselectsearcher`
    ///  *  `readonlyfield`: `textsearcher`
    ///  *  `select`: `multiselectsearcher`
    ///  *  `textarea`: `textsearcher`
    ///  *  `textfield`: `textsearcher`
    ///  *  `url`: `exacttextsearcher`
    ///  *  `userpicker`: `userpickergroupsearcher`
    ///  *  `version`: `versionsearcher`
    public var searcherKey: SearcherKey?

    /// The searcher that defines the way the field is searched in Jira. It can be set to `null`, otherwise you must specify the valid searcher for the field type, as listed below (abbreviated values shown):
    /// 
    ///  *  `cascadingselect`: `cascadingselectsearcher`
    ///  *  `datepicker`: `daterange`
    ///  *  `datetime`: `datetimerange`
    ///  *  `float`: `exactnumber` or `numberrange`
    ///  *  `grouppicker`: `grouppickersearcher`
    ///  *  `importid`: `exactnumber` or `numberrange`
    ///  *  `labels`: `labelsearcher`
    ///  *  `multicheckboxes`: `multiselectsearcher`
    ///  *  `multigrouppicker`: `multiselectsearcher`
    ///  *  `multiselect`: `multiselectsearcher`
    ///  *  `multiuserpicker`: `userpickergroupsearcher`
    ///  *  `multiversion`: `versionsearcher`
    ///  *  `project`: `projectsearcher`
    ///  *  `radiobuttons`: `multiselectsearcher`
    ///  *  `readonlyfield`: `textsearcher`
    ///  *  `select`: `multiselectsearcher`
    ///  *  `textarea`: `textsearcher`
    ///  *  `textfield`: `textsearcher`
    ///  *  `url`: `exacttextsearcher`
    ///  *  `userpicker`: `userpickergroupsearcher`
    ///  *  `version`: `versionsearcher`
    public enum SearcherKey: String, Codable, CaseIterable {
        case comAtlassianJiraPluginSystemCustomfieldtypesCascadingselectsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:cascadingselectsearcher"
        case comAtlassianJiraPluginSystemCustomfieldtypesDaterange = "com.atlassian.jira.plugin.system.customfieldtypes:daterange"
        case comAtlassianJiraPluginSystemCustomfieldtypesDatetimerange = "com.atlassian.jira.plugin.system.customfieldtypes:datetimerange"
        case comAtlassianJiraPluginSystemCustomfieldtypesExactnumber = "com.atlassian.jira.plugin.system.customfieldtypes:exactnumber"
        case comAtlassianJiraPluginSystemCustomfieldtypesExacttextsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:exacttextsearcher"
        case comAtlassianJiraPluginSystemCustomfieldtypesGrouppickersearcher = "com.atlassian.jira.plugin.system.customfieldtypes:grouppickersearcher"
        case comAtlassianJiraPluginSystemCustomfieldtypesLabelsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:labelsearcher"
        case comAtlassianJiraPluginSystemCustomfieldtypesMultiselectsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:multiselectsearcher"
        case comAtlassianJiraPluginSystemCustomfieldtypesNumberrange = "com.atlassian.jira.plugin.system.customfieldtypes:numberrange"
        case comAtlassianJiraPluginSystemCustomfieldtypesProjectsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:projectsearcher"
        case comAtlassianJiraPluginSystemCustomfieldtypesTextsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:textsearcher"
        case comAtlassianJiraPluginSystemCustomfieldtypesUserpickergroupsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:userpickergroupsearcher"
        case comAtlassianJiraPluginSystemCustomfieldtypesVersionsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:versionsearcher"
    }

    public init(name: String? = nil, description: String? = nil, searcherKey: SearcherKey? = nil) {
        self.name = name
        self.description = description
        self.searcherKey = searcherKey
    }
}

/// A page of items.
public struct PageBeanScreenWithTab: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [ScreenWithTab]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [ScreenWithTab]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// A screen with tab details.
public struct ScreenWithTab: Codable {
    /// The ID of the screen.
    public var id: Int?
    /// The name of the screen.
    public var name: String?
    /// The description of the screen.
    public var description: String?
    /// The scope of the screen.
    public var scope: Scope?
    /// The tab for the screen.
    public var tab: ScreenableTab?

    public init(id: Int? = nil, name: String? = nil, description: String? = nil, scope: Scope? = nil, tab: ScreenableTab? = nil) {
        self.id = id
        self.name = name
        self.description = description
        self.scope = scope
        self.tab = tab
    }
}

/// A context.
public struct Context: Codable {
    /// The ID of the context.
    public var id: Int?
    /// The name of the context.
    public var name: String?
    /// The scope of the context.
    public var scope: Scope?

    public init(id: Int? = nil, name: String? = nil, scope: Scope? = nil) {
        self.id = id
        self.name = name
        self.scope = scope
    }
}

/// A page of items.
public struct PageBeanContext: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [Context]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [Context]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// Details of the custom field options for a context.
public struct CustomFieldContextOption: Codable {
    /// The ID of the custom field option.
    public var id: String
    /// The value of the custom field option.
    public var value: String
    /// For cascading options, the ID of the custom field option containing the cascading option.
    public var optionID: String?
    /// Whether the option is disabled.
    public var isDisabled: Bool

    public init(id: String, value: String, optionID: String? = nil, isDisabled: Bool) {
        self.id = id
        self.value = value
        self.optionID = optionID
        self.isDisabled = isDisabled
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case value
        case optionID = "optionId"
        case isDisabled = "disabled"
    }
}

/// A page of items.
public struct PageBeanCustomFieldContextOption: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [CustomFieldContextOption]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [CustomFieldContextOption]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// Details of the options to create for a custom field.
public struct BulkCustomFieldOptionCreateRequest: Codable {
    /// Details of options to create.
    public var options: [CustomFieldOptionCreate]?

    public init(options: [CustomFieldOptionCreate]? = nil) {
        self.options = options
    }
}

/// Details of a custom field option to create.
public struct CustomFieldOptionCreate: Codable {
    /// The value of the custom field option.
    public var value: String
    /// For cascading options, the ID of the custom field object containing the cascading option.
    public var optionID: String?
    /// Whether the option is disabled.
    public var isDisabled: Bool?

    public init(value: String, optionID: String? = nil, isDisabled: Bool? = nil) {
        self.value = value
        self.optionID = optionID
        self.isDisabled = isDisabled
    }

    private enum CodingKeys: String, CodingKey {
        case value
        case optionID = "optionId"
        case isDisabled = "disabled"
    }
}

/// A list of custom field options for a context.
public struct CustomFieldCreatedContextOptionsList: Codable {
    /// The created custom field options.
    public var options: [CustomFieldContextOption]?

    public init(options: [CustomFieldContextOption]? = nil) {
        self.options = options
    }
}

/// An ordered list of custom field option IDs and information on where to move them.
public struct OrderOfCustomFieldOptions: Codable {
    /// A list of IDs of custom field options to move. The order of the custom field option IDs in the list is the order they are given after the move. The list must contain custom field options or cascading options, but not both.
    public var customFieldOptionIDs: [String]
    /// The ID of the custom field option or cascading option to place the moved options after. Required if `position` isn't provided.
    public var after: String?
    /// The position the custom field options should be moved to. Required if `after` isn't provided.
    public var position: Position?

    /// The position the custom field options should be moved to. Required if `after` isn't provided.
    public enum Position: String, Codable, CaseIterable {
        case first = "First"
        case last = "Last"
    }

    public init(customFieldOptionIDs: [String], after: String? = nil, position: Position? = nil) {
        self.customFieldOptionIDs = customFieldOptionIDs
        self.after = after
        self.position = position
    }

    private enum CodingKeys: String, CodingKey {
        case customFieldOptionIDs = "customFieldOptionIds"
        case after
        case position
    }
}

/// Details of the options to update for a custom field.
public struct BulkCustomFieldOptionUpdateRequest: Codable {
    /// Details of the options to update.
    public var options: [CustomFieldOptionUpdate]?

    public init(options: [CustomFieldOptionUpdate]? = nil) {
        self.options = options
    }
}

/// Details of a custom field option for a context.
public struct CustomFieldOptionUpdate: Codable {
    /// The ID of the custom field option.
    public var id: String
    /// The value of the custom field option.
    public var value: String?
    /// Whether the option is disabled.
    public var isDisabled: Bool?

    public init(id: String, value: String? = nil, isDisabled: Bool? = nil) {
        self.id = id
        self.value = value
        self.isDisabled = isDisabled
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case value
        case isDisabled = "disabled"
    }
}

/// A list of custom field options for a context.
public struct CustomFieldUpdatedContextOptionsList: Codable {
    /// The updated custom field options.
    public var options: [CustomFieldOptionUpdate]?

    public init(options: [CustomFieldOptionUpdate]? = nil) {
        self.options = options
    }
}

/// Count of issues assigned to a component.
public struct ComponentIssuesCount: Codable {
    /// The URL for this count of issues for a component.
    public var this: URL?
    /// The count of issues assigned to a component.
    public var issueCount: Int?

    public init(this: URL? = nil, issueCount: Int? = nil) {
        self.this = this
        self.issueCount = issueCount
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case issueCount
    }
}

/// List of system avatars.
public struct SystemAvatars: Codable {
    /// A list of avatar details.
    public var system: [Avatar]?

    public init(system: [Avatar]? = nil) {
        self.system = system
    }
}

/// Details of an issue type scheme.
public struct IssueTypeScheme: Codable {
    /// The ID of the issue type scheme.
    public var id: String
    /// The name of the issue type scheme.
    public var name: String
    /// The description of the issue type scheme.
    public var description: String?
    /// The ID of the default issue type of the issue type scheme.
    public var defaultIssueTypeID: String?
    /// Whether the issue type scheme is the default.
    public var isDefault: Bool?

    public init(id: String, name: String, description: String? = nil, defaultIssueTypeID: String? = nil, isDefault: Bool? = nil) {
        self.id = id
        self.name = name
        self.description = description
        self.defaultIssueTypeID = defaultIssueTypeID
        self.isDefault = isDefault
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case description
        case defaultIssueTypeID = "defaultIssueTypeId"
        case isDefault
    }
}

/// A page of items.
public struct PageBeanIssueTypeScheme: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [IssueTypeScheme]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [IssueTypeScheme]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// Issue type scheme with a list of the projects that use it.
public struct IssueTypeSchemeProjects: Codable {
    /// Details of an issue type scheme.
    public var issueTypeScheme: IssueTypeScheme
    /// The IDs of the projects using the issue type scheme.
    public var projectIDs: [String]

    public init(issueTypeScheme: IssueTypeScheme, projectIDs: [String]) {
        self.issueTypeScheme = issueTypeScheme
        self.projectIDs = projectIDs
    }

    private enum CodingKeys: String, CodingKey {
        case issueTypeScheme
        case projectIDs = "projectIds"
    }
}

/// A page of items.
public struct PageBeanIssueTypeSchemeProjects: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [IssueTypeSchemeProjects]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [IssueTypeSchemeProjects]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// Issue type scheme item.
public struct IssueTypeSchemeMapping: Codable {
    /// The ID of the issue type scheme.
    public var issueTypeSchemeID: String
    /// The ID of the issue type.
    public var issueTypeID: String

    public init(issueTypeSchemeID: String, issueTypeID: String) {
        self.issueTypeSchemeID = issueTypeSchemeID
        self.issueTypeID = issueTypeID
    }

    private enum CodingKeys: String, CodingKey {
        case issueTypeSchemeID = "issueTypeSchemeId"
        case issueTypeID = "issueTypeId"
    }
}

/// A page of items.
public struct PageBeanIssueTypeSchemeMapping: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [IssueTypeSchemeMapping]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [IssueTypeSchemeMapping]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// Details of the association between an issue type scheme and project.
public struct IssueTypeSchemeProjectAssociation: Codable {
    /// The ID of the issue type scheme.
    public var issueTypeSchemeID: String
    /// The ID of the project.
    public var projectID: String

    public init(issueTypeSchemeID: String, projectID: String) {
        self.issueTypeSchemeID = issueTypeSchemeID
        self.projectID = projectID
    }

    private enum CodingKeys: String, CodingKey {
        case issueTypeSchemeID = "issueTypeSchemeId"
        case projectID = "projectId"
    }
}

/// Details of an issue type scheme and its associated issue types.
public struct IssueTypeSchemeDetails: Codable {
    /// The name of the issue type scheme. The name must be unique. The maximum length is 255 characters.
    public var name: String
    /// The description of the issue type scheme. The maximum length is 4000 characters.
    public var description: String?
    /// The ID of the default issue type of the issue type scheme. This ID must be included in `issueTypeIds`.
    public var defaultIssueTypeID: String?
    /// The list of issue types IDs of the issue type scheme. At least one standard issue type ID is required.
    public var issueTypeIDs: [String]

    public init(name: String, description: String? = nil, defaultIssueTypeID: String? = nil, issueTypeIDs: [String]) {
        self.name = name
        self.description = description
        self.defaultIssueTypeID = defaultIssueTypeID
        self.issueTypeIDs = issueTypeIDs
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case description
        case defaultIssueTypeID = "defaultIssueTypeId"
        case issueTypeIDs = "issueTypeIds"
    }
}

/// The ID of an issue type scheme.
public struct IssueTypeSchemeID: Codable {
    /// The ID of the issue type scheme.
    public var issueTypeSchemeID: String

    public init(issueTypeSchemeID: String) {
        self.issueTypeSchemeID = issueTypeSchemeID
    }

    private enum CodingKeys: String, CodingKey {
        case issueTypeSchemeID = "issueTypeSchemeId"
    }
}

/// The list of issue type IDs.
public struct IssueTypeIDs: Codable {
    /// The list of issue type IDs.
    public var issueTypeIDs: [String]

    public init(issueTypeIDs: [String]) {
        self.issueTypeIDs = issueTypeIDs
    }

    private enum CodingKeys: String, CodingKey {
        case issueTypeIDs = "issueTypeIds"
    }
}

/// Details of the name, description, and default issue type for an issue type scheme.
public struct IssueTypeSchemeUpdateDetails: Codable {
    /// The name of the issue type scheme. The name must be unique. The maximum length is 255 characters.
    public var name: String?
    /// The description of the issue type scheme. The maximum length is 4000 characters.
    public var description: String?
    /// The ID of the default issue type of the issue type scheme.
    public var defaultIssueTypeID: String?

    public init(name: String? = nil, description: String? = nil, defaultIssueTypeID: String? = nil) {
        self.name = name
        self.description = description
        self.defaultIssueTypeID = defaultIssueTypeID
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case description
        case defaultIssueTypeID = "defaultIssueTypeId"
    }
}

/// An ordered list of issue type IDs and information about where to move them.
public struct OrderOfIssueTypes: Codable {
    /// A list of the issue type IDs to move. The order of the issue type IDs in the list is the order they are given after the move.
    public var issueTypeIDs: [String]
    /// The ID of the issue type to place the moved issue types after. Required if `position` isn't provided.
    public var after: String?
    /// The position the issue types should be moved to. Required if `after` isn't provided.
    public var position: Position?

    /// The position the issue types should be moved to. Required if `after` isn't provided.
    public enum Position: String, Codable, CaseIterable {
        case first = "First"
        case last = "Last"
    }

    public init(issueTypeIDs: [String], after: String? = nil, position: Position? = nil) {
        self.issueTypeIDs = issueTypeIDs
        self.after = after
        self.position = position
    }

    private enum CodingKeys: String, CodingKey {
        case issueTypeIDs = "issueTypeIds"
        case after
        case position
    }
}

public struct CreateUpdateRoleRequestBean: Codable {
    /// The name of the project role. Must be unique. Cannot begin or end with whitespace. The maximum length is 255 characters. Required when creating a project role. Optional when partially updating a project role.
    public var name: String?
    /// A description of the project role. Required when fully updating a project role. Optional when creating or partially updating a project role.
    public var description: String?

    public init(name: String? = nil, description: String? = nil) {
        self.name = name
        self.description = description
    }
}

public struct ActorInputBean: Codable {
    /// The account IDs of the users to add as default actors. This parameter accepts a comma-separated list. For example, `"user":["5b10a2844c20165700ede21g", "5b109f2e9729b51b54dc274d"]`.
    public var user: [String]?
    /// The name of the group to add as a default actor. This parameter accepts a comma-separated list. For example, `"group":["project-admin", "jira-developers"]`.
    public var group: [String]?

    public init(user: [String]? = nil, group: [String]? = nil) {
        self.user = user
        self.group = group
    }
}

public struct ProjectRoleActorsUpdateBean: Codable {
    /// The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.
    public var id: Int?
    /// The actors to add to the project role. Add groups using `atlassian-group-role-actor` and a list of group names. For example, `"atlassian-group-role-actor":["another","administrators"]}`. Add users using `atlassian-user-role-actor` and a list of account IDs. For example, `"atlassian-user-role-actor":["12345678-9abc-def1-2345-6789abcdef12", "abcdef12-3456-789a-bcde-f123456789ab"]`.
    public var categorisedActors: [String: [String]]?

    public init(id: Int? = nil, categorisedActors: [String: [String]]? = nil) {
        self.id = id
        self.categorisedActors = categorisedActors
    }
}

public struct ActorsMap: Codable {
    /// The user account ID of the user to add.
    public var user: [String]?
    /// The name of the group to add.
    public var group: [String]?

    public init(user: [String]? = nil, group: [String]? = nil) {
        self.user = user
        self.group = group
    }
}

/// Details about a project role.
public struct ProjectRoleDetails: Codable {
    /// The URL the project role details.
    public var this: URL?
    /// The name of the project role.
    public var name: String?
    /// The ID of the project role.
    public var id: Int?
    /// The description of the project role.
    public var description: String?
    /// Whether this role is the admin role for the project.
    public var isAdmin: Bool?
    /// The scope of the role. Indicated for roles associated with [next-gen projects](https://confluence.atlassian.com/x/loMyO).
    public var scope: Scope?
    /// Whether the roles are configurable for this project.
    public var isRoleConfigurable: Bool?
    /// The translated name of the project role.
    public var translatedName: String?
    /// Whether this role is the default role for the project.
    public var isDefault: Bool?

    public init(this: URL? = nil, name: String? = nil, id: Int? = nil, description: String? = nil, isAdmin: Bool? = nil, scope: Scope? = nil, isRoleConfigurable: Bool? = nil, translatedName: String? = nil, isDefault: Bool? = nil) {
        self.this = this
        self.name = name
        self.id = id
        self.description = description
        self.isAdmin = isAdmin
        self.scope = scope
        self.isRoleConfigurable = isRoleConfigurable
        self.translatedName = translatedName
        self.isDefault = isDefault
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case name
        case id
        case description
        case isAdmin = "admin"
        case scope
        case isRoleConfigurable = "roleConfigurable"
        case translatedName
        case isDefault = "default"
    }
}

public struct GlobalScopeBean: Codable {
    /// Defines the behavior of the option in the global context.If notSelectable is set, the option cannot be set as the field's value. This is useful for archiving an option that has previously been selected but shouldn't be used anymore.If defaultValue is set, the option is selected by default.
    public var attributes: [Attribute]?

    public enum Attribute: String, Codable, CaseIterable {
        case notSelectable
        case defaultValue
    }

    public init(attributes: [Attribute]? = nil) {
        self.attributes = attributes
    }
}

/// Details of the options for a select list issue field.
public struct IssueFieldOption: Codable {
    /// The unique identifier for the option. This is only unique within the select field's set of options.
    public var id: Int
    /// The option's name, which is displayed in Jira.
    public var value: String
    /// The properties of the object, as arbitrary key-value pairs. These properties can be searched using JQL, if the extractions (see [Issue Field Option Property Index](https://developer.atlassian.com/cloud/jira/platform/modules/issue-field-option-property-index/)) are defined in the descriptor for the issue field module.
    public var properties: [String: AnyJSON]?
    /// Details of the projects the option is available in.
    public var config: IssueFieldOptionConfiguration?

    public init(id: Int, value: String, properties: [String: AnyJSON]? = nil, config: IssueFieldOptionConfiguration? = nil) {
        self.id = id
        self.value = value
        self.properties = properties
        self.config = config
    }
}

/// Details of the projects the option is available in.
public struct IssueFieldOptionConfiguration: Codable {
    /// Defines the projects that the option is available in. If the scope is not defined, then the option is available in all projects.
    public var scope: IssueFieldOptionScopeBean?
    /// DEPRECATED
    public var attributes: [Attribute]?

    public enum Attribute: String, Codable, CaseIterable {
        case notSelectable
        case defaultValue
    }

    public init(scope: IssueFieldOptionScopeBean? = nil, attributes: [Attribute]? = nil) {
        self.scope = scope
        self.attributes = attributes
    }
}

public struct IssueFieldOptionScopeBean: Codable {
    /// DEPRECATED
    public var projects: [Int]?
    /// Defines the projects in which the option is available and the behavior of the option within each project. Specify one object per project. The behavior of the option in a project context overrides the behavior in the global context.
    public var projects2: [ProjectScopeBean]?
    /// Defines the behavior of the option within the global context. If this property is set, even if set to an empty object, then the option is available in all projects.
    public var global: GlobalScopeBean?

    public init(projects: [Int]? = nil, projects2: [ProjectScopeBean]? = nil, global: GlobalScopeBean? = nil) {
        self.projects = projects
        self.projects2 = projects2
        self.global = global
    }
}

/// A page of items.
public struct PageBeanIssueFieldOption: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [IssueFieldOption]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [IssueFieldOption]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

public struct ProjectScopeBean: Codable {
    /// The ID of the project that the option's behavior applies to.
    public var id: Int?
    /// Defines the behavior of the option in the project.If notSelectable is set, the option cannot be set as the field's value. This is useful for archiving an option that has previously been selected but shouldn't be used anymore.If defaultValue is set, the option is selected by default.
    public var attributes: [Attribute]?

    public enum Attribute: String, Codable, CaseIterable {
        case notSelectable
        case defaultValue
    }

    public init(id: Int? = nil, attributes: [Attribute]? = nil) {
        self.id = id
        self.attributes = attributes
    }
}

public struct IssueFieldOptionCreateBean: Codable {
    /// The option's name, which is displayed in Jira.
    public var value: String
    /// The properties of the option as arbitrary key-value pairs. These properties can be searched using JQL, if the extractions (see https://developer.atlassian.com/cloud/jira/platform/modules/issue-field-option-property-index/) are defined in the descriptor for the issue field module.
    public var properties: [String: AnyJSON]?
    /// Details of the projects the option is available in.
    public var config: IssueFieldOptionConfiguration?

    public init(value: String, properties: [String: AnyJSON]? = nil, config: IssueFieldOptionConfiguration? = nil) {
        self.value = value
        self.properties = properties
        self.config = config
    }
}

public struct RemoveOptionFromIssuesResult: Codable {
    /// The IDs of the modified issues.
    public var modifiedIssues: [Int]?
    /// The IDs of the unchanged issues, those issues where errors prevent modification.
    public var unmodifiedIssues: [Int]?
    /// A collection of errors related to unchanged issues. The collection size is limited, which means not all errors may be returned.
    public var errors: SimpleErrorCollection?

    public init(modifiedIssues: [Int]? = nil, unmodifiedIssues: [Int]? = nil, errors: SimpleErrorCollection? = nil) {
        self.modifiedIssues = modifiedIssues
        self.unmodifiedIssues = unmodifiedIssues
        self.errors = errors
    }
}

public struct SimpleErrorCollection: Codable {
    /// The list of errors by parameter returned by the operation. For example,"projectKey": "Project keys must start with an uppercase letter, followed by one or more uppercase alphanumeric characters."
    public var errors: [String: String]?
    /// The list of error messages produced by this operation. For example, "input parameter 'key' must be provided"
    public var errorMessages: [String]?
    public var httpstatusCode: Int?

    public init(errors: [String: String]? = nil, errorMessages: [String]? = nil, httpstatusCode: Int? = nil) {
        self.errors = errors
        self.errorMessages = errorMessages
        self.httpstatusCode = httpstatusCode
    }

    private enum CodingKeys: String, CodingKey {
        case errors
        case errorMessages
        case httpstatusCode = "httpStatusCode"
    }
}

/// Details about a task.
public struct TaskProgressBeanRemoveOptionFromIssuesResult: Codable {
    /// The URL of the task.
    public var this: URL
    /// The ID of the task.
    public var id: String
    /// The description of the task.
    public var description: String?
    /// The status of the task.
    public var status: Status
    /// Information about the progress of the task.
    public var message: String?
    /// The result of the task execution.
    public var result: RemoveOptionFromIssuesResult?
    /// The ID of the user who submitted the task.
    public var submittedBy: Int
    /// The progress of the task, as a percentage complete.
    public var progress: Int
    /// The execution time of the task, in milliseconds.
    public var elapsedRuntime: Int
    /// A timestamp recording when the task was submitted.
    public var submitted: Int
    /// A timestamp recording when the task was started.
    public var started: Int?
    /// A timestamp recording when the task was finished.
    public var finished: Int?
    /// A timestamp recording when the task progress was last updated.
    public var lastUpdate: Int

    /// The status of the task.
    public enum Status: String, Codable, CaseIterable {
        case enqueued = "ENQUEUED"
        case running = "RUNNING"
        case complete = "COMPLETE"
        case failed = "FAILED"
        case cancelRequested = "CANCEL_REQUESTED"
        case cancelled = "CANCELLED"
        case dead = "DEAD"
    }

    public init(this: URL, id: String, description: String? = nil, status: Status, message: String? = nil, result: RemoveOptionFromIssuesResult? = nil, submittedBy: Int, progress: Int, elapsedRuntime: Int, submitted: Int, started: Int? = nil, finished: Int? = nil, lastUpdate: Int) {
        self.this = this
        self.id = id
        self.description = description
        self.status = status
        self.message = message
        self.result = result
        self.submittedBy = submittedBy
        self.progress = progress
        self.elapsedRuntime = elapsedRuntime
        self.submitted = submitted
        self.started = started
        self.finished = finished
        self.lastUpdate = lastUpdate
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case id
        case description
        case status
        case message
        case result
        case submittedBy
        case progress
        case elapsedRuntime
        case submitted
        case started
        case finished
        case lastUpdate
    }
}

/// Details of a field.
public struct Field: Codable {
    /// The ID of the field.
    public var id: String
    /// The name of the field.
    public var name: String
    /// The schema of a field.
    public var schema: JSONTypeBean
    /// The description of the field.
    public var description: String?
    /// The key of the field.
    public var key: String?
    /// Whether the field is locked.
    public var isLocked: Bool?
    /// Whether the field is shown on screen or not.
    public var isUnscreenable: Bool?
    /// The searcher key of the field. Returned for custom fields.
    public var searcherKey: String?
    /// Number of screens where the field is used.
    public var screensCount: Int?
    /// Number of contexts where the field is used.
    public var contextsCount: Int?
    /// Information about the most recent use of a field.
    public var lastUsed: FieldLastUsed?

    public init(id: String, name: String, schema: JSONTypeBean, description: String? = nil, key: String? = nil, isLocked: Bool? = nil, isUnscreenable: Bool? = nil, searcherKey: String? = nil, screensCount: Int? = nil, contextsCount: Int? = nil, lastUsed: FieldLastUsed? = nil) {
        self.id = id
        self.name = name
        self.schema = schema
        self.description = description
        self.key = key
        self.isLocked = isLocked
        self.isUnscreenable = isUnscreenable
        self.searcherKey = searcherKey
        self.screensCount = screensCount
        self.contextsCount = contextsCount
        self.lastUsed = lastUsed
    }
}

/// Information about the most recent use of a field.
public struct FieldLastUsed: Codable {
    /// Last used value type:
    /// 
    ///  *  *TRACKED*: field is tracked and a last used date is available.
    ///  *  *NOT\_TRACKED*: field is not tracked, last used date is not available.
    ///  *  *NO\_INFORMATION*: field is tracked, but no last used date is available.
    public var type: `Type`?
    /// The date when the value of the field last changed.
    public var value: Date?

    /// Last used value type:
    /// 
    ///  *  *TRACKED*: field is tracked and a last used date is available.
    ///  *  *NOT\_TRACKED*: field is not tracked, last used date is not available.
    ///  *  *NO\_INFORMATION*: field is tracked, but no last used date is available.
    public enum `Type`: String, Codable, CaseIterable {
        case tracked = "TRACKED"
        case notTracked = "NOT_TRACKED"
        case noInformation = "NO_INFORMATION"
    }

    public init(type: `Type`? = nil, value: Date? = nil) {
        self.type = type
        self.value = value
    }
}

/// A page of items.
public struct PageBeanField: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [Field]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [Field]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// Details of a field configuration scheme.
public struct FieldConfigurationScheme: Codable {
    /// The ID of the field configuration scheme.
    public var id: String
    /// The name of the field configuration scheme.
    public var name: String
    /// The description of the field configuration scheme.
    public var description: String?

    public init(id: String, name: String, description: String? = nil) {
        self.id = id
        self.name = name
        self.description = description
    }
}

/// A page of items.
public struct PageBeanFieldConfigurationScheme: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [FieldConfigurationScheme]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [FieldConfigurationScheme]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// The field configuration for an issue type.
public struct FieldConfigurationIssueTypeItem: Codable {
    /// The ID of the field configuration scheme.
    public var fieldConfigurationSchemeID: String
    /// The ID of the issue type or *default*. When set to *default* this field configuration issue type item applies to all issue types without a field configuration.
    public var issueTypeID: String
    /// The ID of the field configuration.
    public var fieldConfigurationID: String

    public init(fieldConfigurationSchemeID: String, issueTypeID: String, fieldConfigurationID: String) {
        self.fieldConfigurationSchemeID = fieldConfigurationSchemeID
        self.issueTypeID = issueTypeID
        self.fieldConfigurationID = fieldConfigurationID
    }

    private enum CodingKeys: String, CodingKey {
        case fieldConfigurationSchemeID = "fieldConfigurationSchemeId"
        case issueTypeID = "issueTypeId"
        case fieldConfigurationID = "fieldConfigurationId"
    }
}

/// A page of items.
public struct PageBeanFieldConfigurationIssueTypeItem: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [FieldConfigurationIssueTypeItem]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [FieldConfigurationIssueTypeItem]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// Details of a field configuration to issue type mappings.
public struct AssociateFieldConfigurationsWithIssueTypesRequest: Codable {
    /// Field configuration to issue type mappings.
    public var mappings: [FieldConfigurationToIssueTypeMapping]

    public init(mappings: [FieldConfigurationToIssueTypeMapping]) {
        self.mappings = mappings
    }
}

/// The field configuration to issue type mapping.
public struct FieldConfigurationToIssueTypeMapping: Codable {
    /// The ID of the issue type or *default*. When set to *default* this field configuration issue type item applies to all issue types without a field configuration. An issue type can be included only once in a request.
    public var issueTypeID: String
    /// The ID of the field configuration.
    public var fieldConfigurationID: String

    public init(issueTypeID: String, fieldConfigurationID: String) {
        self.issueTypeID = issueTypeID
        self.fieldConfigurationID = fieldConfigurationID
    }

    private enum CodingKeys: String, CodingKey {
        case issueTypeID = "issueTypeId"
        case fieldConfigurationID = "fieldConfigurationId"
    }
}

/// Project list with assigned field configuration schema.
public struct FieldConfigurationSchemeProjects: Codable {
    /// Details of a field configuration scheme.
    public var fieldConfigurationScheme: FieldConfigurationScheme?
    /// The IDs of projects using the field configuration scheme.
    public var projectIDs: [String]

    public init(fieldConfigurationScheme: FieldConfigurationScheme? = nil, projectIDs: [String]) {
        self.fieldConfigurationScheme = fieldConfigurationScheme
        self.projectIDs = projectIDs
    }

    private enum CodingKeys: String, CodingKey {
        case fieldConfigurationScheme
        case projectIDs = "projectIds"
    }
}

/// A page of items.
public struct PageBeanFieldConfigurationSchemeProjects: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [FieldConfigurationSchemeProjects]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [FieldConfigurationSchemeProjects]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// Associated field configuration scheme and project.
public struct FieldConfigurationSchemeProjectAssociation: Codable {
    /// The ID of the field configuration scheme. If the field configuration scheme ID is `null`, the operation assigns the default field configuration scheme.
    public var fieldConfigurationSchemeID: String?
    /// The ID of the project.
    public var projectID: String

    public init(fieldConfigurationSchemeID: String? = nil, projectID: String) {
        self.fieldConfigurationSchemeID = fieldConfigurationSchemeID
        self.projectID = projectID
    }

    private enum CodingKeys: String, CodingKey {
        case fieldConfigurationSchemeID = "fieldConfigurationSchemeId"
        case projectID = "projectId"
    }
}

/// The details of the field configuration scheme.
public struct UpdateFieldConfigurationSchemeDetails: Codable {
    /// The name of the field configuration scheme. The name must be unique.
    public var name: String
    /// The description of the field configuration scheme.
    public var description: String?

    public init(name: String, description: String? = nil) {
        self.name = name
        self.description = description
    }
}

/// The list of issue type IDs to be removed from the field configuration scheme.
public struct IssueTypeIDsToRemove: Codable {
    /// The list of issue type IDs. Must contain unique values not longer than 255 characters and not be empty. Maximum of 100 IDs.
    public var issueTypeIDs: [String]

    public init(issueTypeIDs: [String]) {
        self.issueTypeIDs = issueTypeIDs
    }

    private enum CodingKeys: String, CodingKey {
        case issueTypeIDs = "issueTypeIds"
    }
}

/// Details of a field configuration.
public struct FieldConfigurationDetails: Codable {
    /// The name of the field configuration. Must be unique.
    public var name: String
    /// The description of the field configuration.
    public var description: String?

    public init(name: String, description: String? = nil) {
        self.name = name
        self.description = description
    }
}

/// A page of items.
public struct PageBeanFieldConfigurationDetails: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [FieldConfigurationDetails]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [FieldConfigurationDetails]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// A field within a field configuration.
public struct FieldConfigurationItem: Codable {
    /// The ID of the field within the field configuration.
    public var id: String
    /// The description of the field within the field configuration.
    public var description: String?
    /// Whether the field is hidden in the field configuration.
    public var isHidden: Bool?
    /// Whether the field is required in the field configuration.
    public var isRequired: Bool?
    /// The renderer type for the field within the field configuration.
    public var renderer: String?

    public init(id: String, description: String? = nil, isHidden: Bool? = nil, isRequired: Bool? = nil, renderer: String? = nil) {
        self.id = id
        self.description = description
        self.isHidden = isHidden
        self.isRequired = isRequired
        self.renderer = renderer
    }
}

/// A page of items.
public struct PageBeanFieldConfigurationItem: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [FieldConfigurationItem]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [FieldConfigurationItem]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// Details of a field configuration.
public struct FieldConfiguration: Codable {
    /// The ID of the field configuration.
    public var id: Int
    /// The name of the field configuration.
    public var name: String
    /// The description of the field configuration.
    public var description: String
    /// Whether the field configuration is the default.
    public var isDefault: Bool?

    public init(id: Int, name: String, description: String, isDefault: Bool? = nil) {
        self.id = id
        self.name = name
        self.description = description
        self.isDefault = isDefault
    }
}

/// Details of field configuration items.
public struct FieldConfigurationItemsDetails: Codable {
    /// Details of fields in a field configuration.
    public var fieldConfigurationItems: [FieldConfigurationItem]

    public init(fieldConfigurationItems: [FieldConfigurationItem]) {
        self.fieldConfigurationItems = fieldConfigurationItems
    }
}

/// Metadata for an issue attachment.
public struct AttachmentMetadata: Codable {
    /// The ID of the attachment.
    public var id: Int?
    /// The URL of the attachment metadata details.
    public var this: URL?
    /// The name of the attachment file.
    public var filename: String?
    /// Details of the user who attached the file.
    public var author: User?
    /// The datetime the attachment was created.
    public var created: Date?
    /// The size of the attachment.
    public var size: Int?
    /// The MIME type of the attachment.
    public var mimeType: String?
    /// Additional properties of the attachment.
    public var properties: [String: AnyJSON]?
    /// The URL of the attachment.
    public var content: String?
    /// The URL of a thumbnail representing the attachment.
    public var thumbnail: String?
    /// \[EXPERIMENTAL\] - The file ID of the attachment in the media store.
    public var mediaAPIFileID: String?

    public init(id: Int? = nil, this: URL? = nil, filename: String? = nil, author: User? = nil, created: Date? = nil, size: Int? = nil, mimeType: String? = nil, properties: [String: AnyJSON]? = nil, content: String? = nil, thumbnail: String? = nil, mediaAPIFileID: String? = nil) {
        self.id = id
        self.this = this
        self.filename = filename
        self.author = author
        self.created = created
        self.size = size
        self.mimeType = mimeType
        self.properties = properties
        self.content = content
        self.thumbnail = thumbnail
        self.mediaAPIFileID = mediaAPIFileID
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case this = "self"
        case filename
        case author
        case created
        case size
        case mimeType
        case properties
        case content
        case thumbnail
        case mediaAPIFileID = "mediaApiFileId"
    }
}

/// Details of the instance's attachment settings.
public struct AttachmentSettings: Codable {
    /// Whether the ability to add attachments is enabled.
    public var isEnabled: Bool?
    /// The maximum size of attachments permitted, in bytes.
    public var uploadLimit: Int?

    public init(isEnabled: Bool? = nil, uploadLimit: Int? = nil) {
        self.isEnabled = isEnabled
        self.uploadLimit = uploadLimit
    }

    private enum CodingKeys: String, CodingKey {
        case isEnabled = "enabled"
        case uploadLimit
    }
}

public struct AttachmentArchiveEntry: Codable {
    public var abbreviatedName: String?
    public var entryIndex: Int?
    public var mediaType: String?
    public var name: String?
    public var size: Int?

    public init(abbreviatedName: String? = nil, entryIndex: Int? = nil, mediaType: String? = nil, name: String? = nil, size: Int? = nil) {
        self.abbreviatedName = abbreviatedName
        self.entryIndex = entryIndex
        self.mediaType = mediaType
        self.name = name
        self.size = size
    }
}

public struct AttachmentArchiveImpl: Codable {
    /// The list of the items included in the archive.
    public var entries: [AttachmentArchiveEntry]?
    /// The number of items in the archive.
    public var totalEntryCount: Int?

    public init(entries: [AttachmentArchiveEntry]? = nil, totalEntryCount: Int? = nil) {
        self.entries = entries
        self.totalEntryCount = totalEntryCount
    }
}

public struct AttachmentArchive: Codable {
    public var totalNumberOfEntriesAvailable: Int?
    public var totalEntryCount: Int?
    public var isMoreAvailable: Bool?
    public var entries: [AttachmentArchiveEntry]?

    public init(totalNumberOfEntriesAvailable: Int? = nil, totalEntryCount: Int? = nil, isMoreAvailable: Bool? = nil, entries: [AttachmentArchiveEntry]? = nil) {
        self.totalNumberOfEntriesAvailable = totalNumberOfEntriesAvailable
        self.totalEntryCount = totalEntryCount
        self.isMoreAvailable = isMoreAvailable
        self.entries = entries
    }

    private enum CodingKeys: String, CodingKey {
        case totalNumberOfEntriesAvailable
        case totalEntryCount
        case isMoreAvailable = "moreAvailable"
        case entries
    }
}

/// Metadata for an item in an attachment archive.
public struct AttachmentArchiveItemReadable: Codable {
    /// The path of the archive item.
    public var path: String?
    /// The position of the item within the archive.
    public var index: Int?
    /// The size of the archive item.
    public var size: String?
    /// The MIME type of the archive item.
    public var mediaType: String?
    /// The label for the archive item.
    public var label: String?

    public init(path: String? = nil, index: Int? = nil, size: String? = nil, mediaType: String? = nil, label: String? = nil) {
        self.path = path
        self.index = index
        self.size = size
        self.mediaType = mediaType
        self.label = label
    }
}

/// Metadata for an archive (for example a zip) and its contents.
public struct AttachmentArchiveMetadataReadable: Codable {
    /// The ID of the attachment.
    public var id: Int?
    /// The name of the archive file.
    public var name: String?
    /// The list of the items included in the archive.
    public var entries: [AttachmentArchiveItemReadable]?
    /// The number of items included in the archive.
    public var totalEntryCount: Int?
    /// The MIME type of the attachment.
    public var mediaType: String?

    public init(id: Int? = nil, name: String? = nil, entries: [AttachmentArchiveItemReadable]? = nil, totalEntryCount: Int? = nil, mediaType: String? = nil) {
        self.id = id
        self.name = name
        self.entries = entries
        self.totalEntryCount = totalEntryCount
        self.mediaType = mediaType
    }
}

/// Details of a changed worklog.
public struct ChangedWorklog: Codable {
    /// The ID of the worklog.
    public var worklogID: Int?
    /// The datetime of the change.
    public var updatedTime: Int?
    /// Details of properties associated with the change.
    public var properties: [EntityProperty]?

    public init(worklogID: Int? = nil, updatedTime: Int? = nil, properties: [EntityProperty]? = nil) {
        self.worklogID = worklogID
        self.updatedTime = updatedTime
        self.properties = properties
    }

    private enum CodingKeys: String, CodingKey {
        case worklogID = "worklogId"
        case updatedTime
        case properties
    }
}

/// List of changed worklogs.
public struct ChangedWorklogs: Codable {
    /// Changed worklog list.
    public var values: [ChangedWorklog]?
    /// The datetime of the first worklog item in the list.
    public var since: Int?
    /// The datetime of the last worklog item in the list.
    public var until: Int?
    /// The URL of this changed worklogs list.
    public var this: URL?
    /// The URL of the next list of changed worklogs.
    public var nextPage: URL?
    public var isLastPage: Bool?

    public init(values: [ChangedWorklog]? = nil, since: Int? = nil, until: Int? = nil, this: URL? = nil, nextPage: URL? = nil, isLastPage: Bool? = nil) {
        self.values = values
        self.since = since
        self.until = until
        self.this = this
        self.nextPage = nextPage
        self.isLastPage = isLastPage
    }

    private enum CodingKeys: String, CodingKey {
        case values
        case since
        case until
        case this = "self"
        case nextPage
        case isLastPage = "lastPage"
    }
}

public struct WorklogIDsRequestBean: Codable {
    /// A list of worklog IDs.
    public var ids: [Int]

    public init(ids: [Int]) {
        self.ids = ids
    }
}

/// The screen scheme for an issue type.
public struct IssueTypeScreenSchemeItem: Codable {
    /// The ID of the issue type screen scheme.
    public var issueTypeScreenSchemeID: String
    /// The ID of the issue type or *default*. Only issue types used in classic projects are accepted. When creating an issue screen scheme, an entry for *default* must be provided and defines the mapping for all issue types without a screen scheme. Otherwise, a *default* entry can't be provided.
    public var issueTypeID: String
    /// The ID of the screen scheme.
    public var screenSchemeID: String

    public init(issueTypeScreenSchemeID: String, issueTypeID: String, screenSchemeID: String) {
        self.issueTypeScreenSchemeID = issueTypeScreenSchemeID
        self.issueTypeID = issueTypeID
        self.screenSchemeID = screenSchemeID
    }

    private enum CodingKeys: String, CodingKey {
        case issueTypeScreenSchemeID = "issueTypeScreenSchemeId"
        case issueTypeID = "issueTypeId"
        case screenSchemeID = "screenSchemeId"
    }
}

/// A page of items.
public struct PageBeanIssueTypeScreenSchemeItem: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [IssueTypeScreenSchemeItem]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [IssueTypeScreenSchemeItem]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// Details of an issue type screen scheme.
public struct IssueTypeScreenScheme: Codable {
    /// The ID of the issue type screen scheme.
    public var id: String
    /// The name of the issue type screen scheme.
    public var name: String
    /// The description of the issue type screen scheme.
    public var description: String?

    public init(id: String, name: String, description: String? = nil) {
        self.id = id
        self.name = name
        self.description = description
    }
}

/// Issue type screen scheme with a list of the projects that use it.
public struct IssueTypeScreenSchemesProjects: Codable {
    /// Details of an issue type screen scheme.
    public var issueTypeScreenScheme: IssueTypeScreenScheme
    /// The IDs of the projects using the issue type screen scheme.
    public var projectIDs: [String]

    public init(issueTypeScreenScheme: IssueTypeScreenScheme, projectIDs: [String]) {
        self.issueTypeScreenScheme = issueTypeScreenScheme
        self.projectIDs = projectIDs
    }

    private enum CodingKeys: String, CodingKey {
        case issueTypeScreenScheme
        case projectIDs = "projectIds"
    }
}

/// A page of items.
public struct PageBeanIssueTypeScreenSchemesProjects: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [IssueTypeScreenSchemesProjects]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [IssueTypeScreenSchemesProjects]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// A page of items.
public struct PageBeanIssueTypeScreenScheme: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [IssueTypeScreenScheme]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [IssueTypeScreenScheme]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// A page of items.
public struct PageBeanProjectDetails: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [ProjectDetails]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [ProjectDetails]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// Associated issue type screen scheme and project.
public struct IssueTypeScreenSchemeProjectAssociation: Codable {
    /// The ID of the issue type screen scheme.
    public var issueTypeScreenSchemeID: String?
    /// The ID of the project.
    public var projectID: String?

    public init(issueTypeScreenSchemeID: String? = nil, projectID: String? = nil) {
        self.issueTypeScreenSchemeID = issueTypeScreenSchemeID
        self.projectID = projectID
    }

    private enum CodingKeys: String, CodingKey {
        case issueTypeScreenSchemeID = "issueTypeScreenSchemeId"
        case projectID = "projectId"
    }
}

/// The details of an issue type screen scheme.
public struct IssueTypeScreenSchemeDetails: Codable {
    /// The name of the issue type screen scheme. The name must be unique. The maximum length is 255 characters.
    public var name: String
    /// The description of the issue type screen scheme. The maximum length is 255 characters.
    public var description: String?
    /// The IDs of the screen schemes for the issue type IDs and *default*. A *default* entry is required to create an issue type screen scheme, it defines the mapping for all issue types without a screen scheme.
    public var issueTypeMappings: [IssueTypeScreenSchemeMapping]

    public init(name: String, description: String? = nil, issueTypeMappings: [IssueTypeScreenSchemeMapping]) {
        self.name = name
        self.description = description
        self.issueTypeMappings = issueTypeMappings
    }
}

/// The IDs of the screen schemes for the issue type IDs.
public struct IssueTypeScreenSchemeMapping: Codable {
    /// The ID of the issue type or *default*. Only issue types used in classic projects are accepted. An entry for *default* must be provided and defines the mapping for all issue types without a screen scheme.
    public var issueTypeID: String
    /// The ID of the screen scheme. Only screen schemes used in classic projects are accepted.
    public var screenSchemeID: String

    public init(issueTypeID: String, screenSchemeID: String) {
        self.issueTypeID = issueTypeID
        self.screenSchemeID = screenSchemeID
    }

    private enum CodingKeys: String, CodingKey {
        case issueTypeID = "issueTypeId"
        case screenSchemeID = "screenSchemeId"
    }
}

/// The ID of an issue type screen scheme.
public struct IssueTypeScreenSchemeID: Codable {
    /// The ID of the issue type screen scheme.
    public var id: String

    public init(id: String) {
        self.id = id
    }
}

/// Details of an issue type screen scheme.
public struct IssueTypeScreenSchemeUpdateDetails: Codable {
    /// The name of the issue type screen scheme. The name must be unique. The maximum length is 255 characters.
    public var name: String?
    /// The description of the issue type screen scheme. The maximum length is 255 characters.
    public var description: String?

    public init(name: String? = nil, description: String? = nil) {
        self.name = name
        self.description = description
    }
}

/// A list of issue type screen scheme mappings.
public struct IssueTypeScreenSchemeMappingDetails: Codable {
    /// The list of issue type to screen scheme mappings. A *default* entry cannot be specified because a default entry is added when an issue type screen scheme is created.
    public var issueTypeMappings: [IssueTypeScreenSchemeMapping]

    public init(issueTypeMappings: [IssueTypeScreenSchemeMapping]) {
        self.issueTypeMappings = issueTypeMappings
    }
}

/// The ID of a screen scheme.
public struct UpdateDefaultScreenScheme: Codable {
    /// The ID of the screen scheme.
    public var screenSchemeID: String

    public init(screenSchemeID: String) {
        self.screenSchemeID = screenSchemeID
    }

    private enum CodingKeys: String, CodingKey {
        case screenSchemeID = "screenSchemeId"
    }
}

/// A page of items.
public struct PageBeanScreenScheme: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [ScreenScheme]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [ScreenScheme]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// A screen scheme.
public struct ScreenScheme: Codable {
    /// The ID of the screen scheme.
    public var id: Int?
    /// The name of the screen scheme.
    public var name: String?
    /// The description of the screen scheme.
    public var description: String?
    /// The IDs of the screens for the screen types of the screen scheme.
    public var screens: ScreenTypes?
    /// Details of the issue type screen schemes associated with the screen scheme.
    public var issueTypeScreenSchemes: PageBeanIssueTypeScreenScheme?

    public init(id: Int? = nil, name: String? = nil, description: String? = nil, screens: ScreenTypes? = nil, issueTypeScreenSchemes: PageBeanIssueTypeScreenScheme? = nil) {
        self.id = id
        self.name = name
        self.description = description
        self.screens = screens
        self.issueTypeScreenSchemes = issueTypeScreenSchemes
    }
}

/// The IDs of the screens for the screen types of the screen scheme.
public struct ScreenTypes: Codable {
    /// The ID of the edit screen.
    public var edit: Int?
    /// The ID of the create screen.
    public var create: Int?
    /// The ID of the view screen.
    public var view: Int?
    /// The ID of the default screen. Required when creating a screen scheme.
    public var `default`: Int?
    public var defaultScreen: AnyJSON

    public init(edit: Int? = nil, create: Int? = nil, view: Int? = nil, `default`: Int? = nil, defaultScreen: AnyJSON) {
        self.edit = edit
        self.create = create
        self.view = view
        self.default = `default`
        self.defaultScreen = defaultScreen
    }

    private enum CodingKeys: String, CodingKey {
        case edit
        case create
        case view
        case `default` = "default"
        case defaultScreen
    }
}

/// Details of a screen scheme.
public struct ScreenSchemeDetails: Codable {
    /// The name of the screen scheme. The name must be unique. The maximum length is 255 characters.
    public var name: String
    /// The description of the screen scheme. The maximum length is 255 characters.
    public var description: String?
    /// The IDs of the screens for the screen types of the screen scheme. Only screens used in classic projects are accepted.
    public var screens: ScreenTypes

    public init(name: String, description: String? = nil, screens: ScreenTypes) {
        self.name = name
        self.description = description
        self.screens = screens
    }
}

/// The ID of a screen scheme.
public struct ScreenSchemeID: Codable {
    /// The ID of the screen scheme.
    public var id: Int

    public init(id: Int) {
        self.id = id
    }
}

/// Details of a screen scheme.
public struct UpdateScreenSchemeDetails: Codable {
    /// The name of the screen scheme. The name must be unique. The maximum length is 255 characters.
    public var name: String?
    /// The description of the screen scheme. The maximum length is 255 characters.
    public var description: String?
    /// The IDs of the screens for the screen types of the screen scheme. Only screens used in classic projects are accepted.
    public var screens: UpdateScreenTypes?

    public init(name: String? = nil, description: String? = nil, screens: UpdateScreenTypes? = nil) {
        self.name = name
        self.description = description
        self.screens = screens
    }
}

/// The IDs of the screens for the screen types of the screen scheme.
public struct UpdateScreenTypes: Codable {
    /// The ID of the edit screen. To remove the screen association, pass a null.
    public var edit: String?
    /// The ID of the create screen. To remove the screen association, pass a null.
    public var create: String?
    /// The ID of the view screen. To remove the screen association, pass a null.
    public var view: String?
    /// The ID of the default screen. When specified, must include a screen ID as a default screen is required.
    public var `default`: String?

    public init(edit: String? = nil, create: String? = nil, view: String? = nil, `default`: String? = nil) {
        self.edit = edit
        self.create = create
        self.view = view
        self.default = `default`
    }

    private enum CodingKeys: String, CodingKey {
        case edit
        case create
        case view
        case `default` = "default"
    }
}

/// Details of a custom option for a field.
public struct CustomFieldOption: Codable {
    /// The URL of these custom field option details.
    public var this: URL?
    /// The value of the custom field option.
    public var value: String?

    public init(this: URL? = nil, value: String? = nil) {
        self.this = this
        self.value = value
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case value
    }
}

/// Details of a context to project association.
public struct CustomFieldContextProjectMapping: Codable {
    /// The ID of the context.
    public var contextID: String
    /// The ID of the project.
    public var projectID: String?
    /// Whether context is global.
    public var isGlobalContext: Bool?

    public init(contextID: String, projectID: String? = nil, isGlobalContext: Bool? = nil) {
        self.contextID = contextID
        self.projectID = projectID
        self.isGlobalContext = isGlobalContext
    }

    private enum CodingKeys: String, CodingKey {
        case contextID = "contextId"
        case projectID = "projectId"
        case isGlobalContext
    }
}

/// A page of items.
public struct PageBeanCustomFieldContextProjectMapping: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [CustomFieldContextProjectMapping]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [CustomFieldContextProjectMapping]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// The details of a custom field context.
public struct CustomFieldContext: Codable {
    /// The ID of the context.
    public var id: String
    /// The name of the context.
    public var name: String
    /// The description of the context.
    public var description: String
    /// Whether the context is global.
    public var isGlobalContext: Bool
    /// Whether the context apply to all issue types.
    public var isAnyIssueType: Bool

    public init(id: String, name: String, description: String, isGlobalContext: Bool, isAnyIssueType: Bool) {
        self.id = id
        self.name = name
        self.description = description
        self.isGlobalContext = isGlobalContext
        self.isAnyIssueType = isAnyIssueType
    }
}

/// A page of items.
public struct PageBeanCustomFieldContext: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [CustomFieldContext]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [CustomFieldContext]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

public enum CustomFieldContextDefaultValue: Codable {
    case customFieldContextDefaultValueCascadingOption(CustomFieldContextDefaultValueCascadingOption)
    case customFieldContextDefaultValueMultipleOption(CustomFieldContextDefaultValueMultipleOption)
    case customFieldContextDefaultValueSingleOption(CustomFieldContextDefaultValueSingleOption)
    case customFieldContextSingleUserPickerDefaults(CustomFieldContextSingleUserPickerDefaults)
    case customFieldContextDefaultValueMultiUserPicker(CustomFieldContextDefaultValueMultiUserPicker)
    case customFieldContextDefaultValueSingleGroupPicker(CustomFieldContextDefaultValueSingleGroupPicker)
    case customFieldContextDefaultValueMultipleGroupPicker(CustomFieldContextDefaultValueMultipleGroupPicker)
    case customFieldContextDefaultValueDate(CustomFieldContextDefaultValueDate)
    case customFieldContextDefaultValueDateTime(CustomFieldContextDefaultValueDateTime)
    case customFieldContextDefaultValueURL(CustomFieldContextDefaultValueURL)
    case customFieldContextDefaultValueProject(CustomFieldContextDefaultValueProject)
    case customFieldContextDefaultValueFloat(CustomFieldContextDefaultValueFloat)
    case customFieldContextDefaultValueLabels(CustomFieldContextDefaultValueLabels)
    case customFieldContextDefaultValueTextField(CustomFieldContextDefaultValueTextField)
    case customFieldContextDefaultValueTextArea(CustomFieldContextDefaultValueTextArea)
    case customFieldContextDefaultValueReadOnly(CustomFieldContextDefaultValueReadOnly)
    case customFieldContextDefaultValueSingleVersionPicker(CustomFieldContextDefaultValueSingleVersionPicker)
    case customFieldContextDefaultValueMultipleVersionPicker(CustomFieldContextDefaultValueMultipleVersionPicker)

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(CustomFieldContextDefaultValueCascadingOption.self) {
            self = .customFieldContextDefaultValueCascadingOption(value)
        } else if let value = try? container.decode(CustomFieldContextDefaultValueMultipleOption.self) {
            self = .customFieldContextDefaultValueMultipleOption(value)
        } else if let value = try? container.decode(CustomFieldContextDefaultValueSingleOption.self) {
            self = .customFieldContextDefaultValueSingleOption(value)
        } else if let value = try? container.decode(CustomFieldContextSingleUserPickerDefaults.self) {
            self = .customFieldContextSingleUserPickerDefaults(value)
        } else if let value = try? container.decode(CustomFieldContextDefaultValueMultiUserPicker.self) {
            self = .customFieldContextDefaultValueMultiUserPicker(value)
        } else if let value = try? container.decode(CustomFieldContextDefaultValueSingleGroupPicker.self) {
            self = .customFieldContextDefaultValueSingleGroupPicker(value)
        } else if let value = try? container.decode(CustomFieldContextDefaultValueMultipleGroupPicker.self) {
            self = .customFieldContextDefaultValueMultipleGroupPicker(value)
        } else if let value = try? container.decode(CustomFieldContextDefaultValueDate.self) {
            self = .customFieldContextDefaultValueDate(value)
        } else if let value = try? container.decode(CustomFieldContextDefaultValueDateTime.self) {
            self = .customFieldContextDefaultValueDateTime(value)
        } else if let value = try? container.decode(CustomFieldContextDefaultValueURL.self) {
            self = .customFieldContextDefaultValueURL(value)
        } else if let value = try? container.decode(CustomFieldContextDefaultValueProject.self) {
            self = .customFieldContextDefaultValueProject(value)
        } else if let value = try? container.decode(CustomFieldContextDefaultValueFloat.self) {
            self = .customFieldContextDefaultValueFloat(value)
        } else if let value = try? container.decode(CustomFieldContextDefaultValueLabels.self) {
            self = .customFieldContextDefaultValueLabels(value)
        } else if let value = try? container.decode(CustomFieldContextDefaultValueTextField.self) {
            self = .customFieldContextDefaultValueTextField(value)
        } else if let value = try? container.decode(CustomFieldContextDefaultValueTextArea.self) {
            self = .customFieldContextDefaultValueTextArea(value)
        } else if let value = try? container.decode(CustomFieldContextDefaultValueReadOnly.self) {
            self = .customFieldContextDefaultValueReadOnly(value)
        } else if let value = try? container.decode(CustomFieldContextDefaultValueSingleVersionPicker.self) {
            self = .customFieldContextDefaultValueSingleVersionPicker(value)
        } else if let value = try? container.decode(CustomFieldContextDefaultValueMultipleVersionPicker.self) {
            self = .customFieldContextDefaultValueMultipleVersionPicker(value)
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .customFieldContextDefaultValueCascadingOption(let value): try container.encode(value)
        case .customFieldContextDefaultValueMultipleOption(let value): try container.encode(value)
        case .customFieldContextDefaultValueSingleOption(let value): try container.encode(value)
        case .customFieldContextSingleUserPickerDefaults(let value): try container.encode(value)
        case .customFieldContextDefaultValueMultiUserPicker(let value): try container.encode(value)
        case .customFieldContextDefaultValueSingleGroupPicker(let value): try container.encode(value)
        case .customFieldContextDefaultValueMultipleGroupPicker(let value): try container.encode(value)
        case .customFieldContextDefaultValueDate(let value): try container.encode(value)
        case .customFieldContextDefaultValueDateTime(let value): try container.encode(value)
        case .customFieldContextDefaultValueURL(let value): try container.encode(value)
        case .customFieldContextDefaultValueProject(let value): try container.encode(value)
        case .customFieldContextDefaultValueFloat(let value): try container.encode(value)
        case .customFieldContextDefaultValueLabels(let value): try container.encode(value)
        case .customFieldContextDefaultValueTextField(let value): try container.encode(value)
        case .customFieldContextDefaultValueTextArea(let value): try container.encode(value)
        case .customFieldContextDefaultValueReadOnly(let value): try container.encode(value)
        case .customFieldContextDefaultValueSingleVersionPicker(let value): try container.encode(value)
        case .customFieldContextDefaultValueMultipleVersionPicker(let value): try container.encode(value)
        }
    }
}

/// The default value for a cascading select custom field.
public struct CustomFieldContextDefaultValueCascadingOption: Codable {
    /// The ID of the context.
    public var contextID: String
    /// The ID of the default option.
    public var optionID: String
    /// The ID of the default cascading option.
    public var cascadingOptionID: String?
    public var type: String

    public init(contextID: String, optionID: String, cascadingOptionID: String? = nil, type: String) {
        self.contextID = contextID
        self.optionID = optionID
        self.cascadingOptionID = cascadingOptionID
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case contextID = "contextId"
        case optionID = "optionId"
        case cascadingOptionID = "cascadingOptionId"
        case type
    }
}

/// The default value for a Date custom field.
public struct CustomFieldContextDefaultValueDate: Codable {
    /// The default date in ISO format. Ignored if `useCurrent` is true.
    public var date: String?
    /// Whether to use the current date.
    public var useCurrent: Bool
    public var type: String

    public init(date: String? = nil, useCurrent: Bool? = nil, type: String) {
        self.date = date
        self.useCurrent = useCurrent ?? false
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.date = try values.decodeIfPresent(String.self, forKey: .date)
        self.useCurrent = try values.decodeIfPresent(Bool.self, forKey: .useCurrent) ?? false
        self.type = try values.decode(String.self, forKey: .type)
    }
}

/// The default value for a date time custom field.
public struct CustomFieldContextDefaultValueDateTime: Codable {
    /// The default date-time in ISO format. Ignored if `useCurrent` is true.
    public var dateTime: String?
    /// Whether to use the current date.
    public var useCurrent: Bool
    public var type: String

    public init(dateTime: String? = nil, useCurrent: Bool? = nil, type: String) {
        self.dateTime = dateTime
        self.useCurrent = useCurrent ?? false
        self.type = type
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.dateTime = try values.decodeIfPresent(String.self, forKey: .dateTime)
        self.useCurrent = try values.decodeIfPresent(Bool.self, forKey: .useCurrent) ?? false
        self.type = try values.decode(String.self, forKey: .type)
    }
}

/// Default value for a float (number) custom field.
public struct CustomFieldContextDefaultValueFloat: Codable {
    /// The default floating-point number.
    public var number: Double
    public var type: String

    public init(number: Double, type: String) {
        self.number = number
        self.type = type
    }
}

/// Default value for a labels custom field.
public struct CustomFieldContextDefaultValueLabels: Codable {
    /// The default labels value.
    public var labels: [String]
    public var type: String

    public init(labels: [String], type: String) {
        self.labels = labels
        self.type = type
    }
}

/// The default value for a User Picker (multiple) custom field.
public struct CustomFieldContextDefaultValueMultiUserPicker: Codable {
    /// The ID of the context.
    public var contextID: String
    /// The IDs of the default users.
    public var accountIDs: [String]
    public var type: String

    public init(contextID: String, accountIDs: [String], type: String) {
        self.contextID = contextID
        self.accountIDs = accountIDs
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case contextID = "contextId"
        case accountIDs = "accountIds"
        case type
    }
}

/// The default value for a multiple group picker custom field.
public struct CustomFieldContextDefaultValueMultipleGroupPicker: Codable {
    /// The ID of the context.
    public var contextID: String
    /// The IDs of the default groups.
    public var groupIDs: [String]
    public var type: String

    public init(contextID: String, groupIDs: [String], type: String) {
        self.contextID = contextID
        self.groupIDs = groupIDs
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case contextID = "contextId"
        case groupIDs = "groupIds"
        case type
    }
}

/// The default value for a multi-select custom field.
public struct CustomFieldContextDefaultValueMultipleOption: Codable {
    /// The ID of the context.
    public var contextID: String
    /// The list of IDs of the default options.
    public var optionIDs: [String]
    public var type: String

    public init(contextID: String, optionIDs: [String], type: String) {
        self.contextID = contextID
        self.optionIDs = optionIDs
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case contextID = "contextId"
        case optionIDs = "optionIds"
        case type
    }
}

/// The default value for a multiple version picker custom field.
public struct CustomFieldContextDefaultValueMultipleVersionPicker: Codable {
    /// The IDs of the default versions.
    public var versionIDs: [String]
    /// The order the pickable versions are displayed in. If not provided, the released-first order is used. Available version orders are `"releasedFirst"` and `"unreleasedFirst"`.
    public var versionOrder: String?
    public var type: String

    public init(versionIDs: [String], versionOrder: String? = nil, type: String) {
        self.versionIDs = versionIDs
        self.versionOrder = versionOrder
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case versionIDs = "versionIds"
        case versionOrder
        case type
    }
}

/// The default value for a project custom field.
public struct CustomFieldContextDefaultValueProject: Codable {
    /// The ID of the context.
    public var contextID: String
    /// The ID of the default project.
    public var projectID: String
    public var type: String

    public init(contextID: String, projectID: String, type: String) {
        self.contextID = contextID
        self.projectID = projectID
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case contextID = "contextId"
        case projectID = "projectId"
        case type
    }
}

/// The default text for a read only custom field.
public struct CustomFieldContextDefaultValueReadOnly: Codable {
    /// The default text. The maximum length is 255 characters.
    public var text: String?
    public var type: String

    public init(text: String? = nil, type: String) {
        self.text = text
        self.type = type
    }
}

/// The default value for a group picker custom field.
public struct CustomFieldContextDefaultValueSingleGroupPicker: Codable {
    /// The ID of the context.
    public var contextID: String
    /// The ID of the the default group.
    public var groupID: String
    public var type: String

    public init(contextID: String, groupID: String, type: String) {
        self.contextID = contextID
        self.groupID = groupID
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case contextID = "contextId"
        case groupID = "groupId"
        case type
    }
}

/// The default value for a single select custom field.
public struct CustomFieldContextDefaultValueSingleOption: Codable {
    /// The ID of the context.
    public var contextID: String
    /// The ID of the default option.
    public var optionID: String
    public var type: String

    public init(contextID: String, optionID: String, type: String) {
        self.contextID = contextID
        self.optionID = optionID
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case contextID = "contextId"
        case optionID = "optionId"
        case type
    }
}

/// The default value for a version picker custom field.
public struct CustomFieldContextDefaultValueSingleVersionPicker: Codable {
    /// The ID of the default version.
    public var versionID: String
    /// The order the pickable versions are displayed in. If not provided, the released-first order is used. Available version orders are `"releasedFirst"` and `"unreleasedFirst"`.
    public var versionOrder: String?
    public var type: String

    public init(versionID: String, versionOrder: String? = nil, type: String) {
        self.versionID = versionID
        self.versionOrder = versionOrder
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case versionID = "versionId"
        case versionOrder
        case type
    }
}

/// The default text for a text area custom field.
public struct CustomFieldContextDefaultValueTextArea: Codable {
    /// The default text. The maximum length is 32767 characters.
    public var text: String?
    public var type: String

    public init(text: String? = nil, type: String) {
        self.text = text
        self.type = type
    }
}

/// The default text for a text custom field.
public struct CustomFieldContextDefaultValueTextField: Codable {
    /// The default text. The maximum length is 254 characters.
    public var text: String?
    public var type: String

    public init(text: String? = nil, type: String) {
        self.text = text
        self.type = type
    }
}

/// The default value for a URL custom field.
public struct CustomFieldContextDefaultValueURL: Codable {
    /// The ID of the context.
    public var contextID: String
    /// The default URL.
    public var url: String
    public var type: String

    public init(contextID: String, url: String, type: String) {
        self.contextID = contextID
        self.url = url
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case contextID = "contextId"
        case url
        case type
    }
}

/// Defaults for a User Picker (single) custom field.
public struct CustomFieldContextSingleUserPickerDefaults: Codable {
    /// The ID of the context.
    public var contextID: String
    /// The ID of the default user.
    public var accountID: String
    /// Filter for a User Picker (single) custom field.
    public var userFilter: UserFilter
    public var type: String

    public init(contextID: String, accountID: String, userFilter: UserFilter, type: String) {
        self.contextID = contextID
        self.accountID = accountID
        self.userFilter = userFilter
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case contextID = "contextId"
        case accountID = "accountId"
        case userFilter
        case type
    }
}

/// A page of items.
public struct PageBeanCustomFieldContextDefaultValue: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [CustomFieldContextDefaultValue]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [CustomFieldContextDefaultValue]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// Filter for a User Picker (single) custom field.
public struct UserFilter: Codable {
    /// Whether the filter is enabled.
    public var isEnabled: Bool
    /// User groups autocomplete suggestion users must belong to. If not provided, the default values are used. A maximum of 10 groups can be provided.
    public var groups: [String]?
    /// Roles that autocomplete suggestion users must belong to. If not provided, the default values are used. A maximum of 10 roles can be provided.
    public var roleIDs: [Int]?

    public init(isEnabled: Bool, groups: [String]? = nil, roleIDs: [Int]? = nil) {
        self.isEnabled = isEnabled
        self.groups = groups
        self.roleIDs = roleIDs
    }

    private enum CodingKeys: String, CodingKey {
        case isEnabled = "enabled"
        case groups
        case roleIDs = "roleIds"
    }
}

/// The details of a created custom field context.
public struct CreateCustomFieldContext: Codable {
    /// The ID of the context.
    public var id: String?
    /// The name of the context.
    public var name: String
    /// The description of the context.
    public var description: String?
    /// The list of project IDs associated with the context. If the list is empty, the context is global.
    public var projectIDs: [String]?
    /// The list of issue types IDs for the context. If the list is empty, the context refers to all issue types.
    public var issueTypeIDs: [String]?

    public init(id: String? = nil, name: String, description: String? = nil, projectIDs: [String]? = nil, issueTypeIDs: [String]? = nil) {
        self.id = id
        self.name = name
        self.description = description
        self.projectIDs = projectIDs
        self.issueTypeIDs = issueTypeIDs
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case description
        case projectIDs = "projectIds"
        case issueTypeIDs = "issueTypeIds"
    }
}

/// A list of project IDs.
public struct ProjectIDs: Codable {
    /// The IDs of projects.
    public var projectIDs: [String]

    public init(projectIDs: [String]) {
        self.projectIDs = projectIDs
    }

    private enum CodingKeys: String, CodingKey {
        case projectIDs = "projectIds"
    }
}

/// Details of a custom field context.
public struct CustomFieldContextUpdateDetails: Codable {
    /// The name of the custom field context. The name must be unique. The maximum length is 255 characters.
    public var name: String?
    /// The description of the custom field context. The maximum length is 255 characters.
    public var description: String?

    public init(name: String? = nil, description: String? = nil) {
        self.name = name
        self.description = description
    }
}

/// The project and issue type mapping.
public struct ProjectIssueTypeMapping: Codable {
    /// The ID of the project.
    public var projectID: String
    /// The ID of the issue type.
    public var issueTypeID: String

    public init(projectID: String, issueTypeID: String) {
        self.projectID = projectID
        self.issueTypeID = issueTypeID
    }

    private enum CodingKeys: String, CodingKey {
        case projectID = "projectId"
        case issueTypeID = "issueTypeId"
    }
}

/// The project and issue type mappings.
public struct ProjectIssueTypeMappings: Codable {
    /// The project and issue type mappings.
    public var mappings: [ProjectIssueTypeMapping]

    public init(mappings: [ProjectIssueTypeMapping]) {
        self.mappings = mappings
    }
}

/// The project and issue type mapping with a matching custom field context.
public struct ContextForProjectAndIssueType: Codable {
    /// The ID of the project.
    public var projectID: String
    /// The ID of the issue type.
    public var issueTypeID: String
    /// The ID of the custom field context.
    public var contextID: String

    public init(projectID: String, issueTypeID: String, contextID: String) {
        self.projectID = projectID
        self.issueTypeID = issueTypeID
        self.contextID = contextID
    }

    private enum CodingKeys: String, CodingKey {
        case projectID = "projectId"
        case issueTypeID = "issueTypeId"
        case contextID = "contextId"
    }
}

/// A page of items.
public struct PageBeanContextForProjectAndIssueType: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [ContextForProjectAndIssueType]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [ContextForProjectAndIssueType]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// Default values to update.
public struct CustomFieldContextDefaultValueUpdate: Codable {
    public var defaultValues: [CustomFieldContextDefaultValue]?

    public init(defaultValues: [CustomFieldContextDefaultValue]? = nil) {
        self.defaultValues = defaultValues
    }
}

/// Mapping of an issue type to a context.
public struct IssueTypeToContextMapping: Codable {
    /// The ID of the context.
    public var contextID: String
    /// The ID of the issue type.
    public var issueTypeID: String?
    /// Whether the context is mapped to any issue type.
    public var isAnyIssueType: Bool?

    public init(contextID: String, issueTypeID: String? = nil, isAnyIssueType: Bool? = nil) {
        self.contextID = contextID
        self.issueTypeID = issueTypeID
        self.isAnyIssueType = isAnyIssueType
    }

    private enum CodingKeys: String, CodingKey {
        case contextID = "contextId"
        case issueTypeID = "issueTypeId"
        case isAnyIssueType
    }
}

/// A page of items.
public struct PageBeanIssueTypeToContextMapping: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [IssueTypeToContextMapping]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [IssueTypeToContextMapping]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// A list of issue IDs and the value to update a custom field to.
public struct CustomFieldValueUpdate: Codable {
    /// The list of issue IDs.
    public var issueIDs: [Int]
    /// The value for the custom field. The value must be compatible with the [custom field type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field/#data-types) as follows:
    /// 
    ///  *  `string` the value must be a string.
    ///  *  `number` the value must be a number.
    ///  *  `datetime` the value must be a string that represents a date in the ISO format, for example `"2021-01-18T12:00:00-03:00"`.
    ///  *  `user` the value must be an object that contains the `accountId` field.
    ///  *  `group` the value must be an object that contains the group `name` field.
    /// 
    /// A list of appropriate values must be provided if the field is of the `list` [collection type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field/#collection-types).
    public var value: AnyJSON

    public init(issueIDs: [Int], value: AnyJSON) {
        self.issueIDs = issueIDs
        self.value = value
    }

    private enum CodingKeys: String, CodingKey {
        case issueIDs = "issueIds"
        case value
    }
}

/// Details of updates for a custom field.
public struct CustomFieldValueUpdateDetails: Codable {
    /// The list of custom field update details.
    public var updates: [CustomFieldValueUpdate]?

    public init(updates: [CustomFieldValueUpdate]? = nil) {
        self.updates = updates
    }
}

/// A custom field and its new value with a list of issue to update.
public struct MultipleCustomFieldValuesUpdate: Codable {
    /// The ID or key of the custom field. For example, `customfield_10010`.
    public var customField: String
    /// The list of issue IDs.
    public var issueIDs: [Int]
    /// The value for the custom field. The value must be compatible with the [custom field type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field/#data-types) as follows:
    /// 
    ///  *  `string` the value must be a string.
    ///  *  `number` the value must be a number.
    ///  *  `datetime` the value must be a string that represents a date in the ISO format, for example `"2021-01-18T12:00:00-03:00"`.
    ///  *  `user` the value must be an object that contains the `accountId` field.
    ///  *  `group` the value must be an object that contains the group `name` field.
    /// 
    /// A list of appropriate values must be provided if the field is of the `list` [collection type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field/#collection-types).
    public var value: AnyJSON

    public init(customField: String, issueIDs: [Int], value: AnyJSON) {
        self.customField = customField
        self.issueIDs = issueIDs
        self.value = value
    }

    private enum CodingKeys: String, CodingKey {
        case customField
        case issueIDs = "issueIds"
        case value
    }
}

/// List of updates for a custom fields.
public struct MultipleCustomFieldValuesUpdateDetails: Codable {
    public var updates: [MultipleCustomFieldValuesUpdate]?

    public init(updates: [MultipleCustomFieldValuesUpdate]? = nil) {
        self.updates = updates
    }
}

/// Details of the contextual configuration for a custom field.
public struct ContextualConfiguration: Codable {
    /// The ID of the configuration.
    public var id: String
    /// Deprecated, do not use.
    ///
    /// - warning: Deprecated.
    public var contextID: Int?
    /// The ID of the field context the configuration is associated with.
    public var fieldContextID: String
    /// The field configuration.
    public var configuration: AnyJSON?
    /// The field value schema.
    public var schema: AnyJSON?

    public init(id: String, contextID: Int? = nil, fieldContextID: String, configuration: AnyJSON? = nil, schema: AnyJSON? = nil) {
        self.id = id
        self.contextID = contextID
        self.fieldContextID = fieldContextID
        self.configuration = configuration
        self.schema = schema
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case contextID = "contextId"
        case fieldContextID = "fieldContextId"
        case configuration
        case schema
    }
}

/// A page of items.
public struct PageBeanContextualConfiguration: Codable {
    /// The URL of the page.
    public var this: URL?
    /// If there is another page of results, the URL of the next page.
    public var nextPage: URL?
    /// The maximum number of items that could be returned.
    public var maxResults: Int?
    /// The index of the first item returned.
    public var startAt: Int?
    /// The number of items returned.
    public var total: Int?
    /// Whether this is the last page.
    public var isLast: Bool?
    /// The list of items.
    public var values: [ContextualConfiguration]?

    public init(this: URL? = nil, nextPage: URL? = nil, maxResults: Int? = nil, startAt: Int? = nil, total: Int? = nil, isLast: Bool? = nil, values: [ContextualConfiguration]? = nil) {
        self.this = this
        self.nextPage = nextPage
        self.maxResults = maxResults
        self.startAt = startAt
        self.total = total
        self.isLast = isLast
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case nextPage
        case maxResults
        case startAt
        case total
        case isLast
        case values
    }
}

/// Details of configurations for a custom field.
public struct CustomFieldConfigurations: Codable {
    /// The list of custom field configuration details.
    public var configurations: [ContextualConfiguration]

    public init(configurations: [ContextualConfiguration]) {
        self.configurations = configurations
    }
}

public enum CustomContextVariable: Codable {
    case userContextVariable(UserContextVariable)
    case issueContextVariable(IssueContextVariable)
    case jsonContextVariable(JSONContextVariable)

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(UserContextVariable.self) {
            self = .userContextVariable(value)
        } else if let value = try? container.decode(IssueContextVariable.self) {
            self = .issueContextVariable(value)
        } else if let value = try? container.decode(JSONContextVariable.self) {
            self = .jsonContextVariable(value)
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .userContextVariable(let value): try container.encode(value)
        case .issueContextVariable(let value): try container.encode(value)
        case .jsonContextVariable(let value): try container.encode(value)
        }
    }
}

public struct IDOrKeyBean: Codable {
    /// The ID of the referenced item.
    public var id: Int?
    /// The key of the referenced item.
    public var key: String?

    public init(id: Int? = nil, key: String? = nil) {
        self.id = id
        self.key = key
    }
}

/// An [issue](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#issue) specified by ID or key. All the fields of the issue object are available in the Jira expression.
public struct IssueContextVariable: Codable {
    /// Type of custom context variable.
    public var type: String
    /// The issue ID.
    public var id: Int?
    /// The issue key.
    public var key: String?

    public init(type: String, id: Int? = nil, key: String? = nil) {
        self.type = type
        self.id = id
        self.key = key
    }
}

/// The JQL specifying the issues available in the evaluated Jira expression under the `issues` context variable.
public struct JexpIssues: Codable {
    /// The JQL query that specifies the set of issues available in the Jira expression.
    public var jql: JexpJqlIssues?

    public init(jql: JexpJqlIssues? = nil) {
        self.jql = jql
    }
}

/// The JQL specifying the issues available in the evaluated Jira expression under the `issues` context variable. Not all issues returned by the JQL query are loaded, only those described by the `startAt` and `maxResults` properties. To determine whether it is necessary to iterate to ensure all the issues returned by the JQL query are evaluated, inspect `meta.issues.jql.count` in the response.
public struct JexpJqlIssues: Codable {
    /// The JQL query.
    public var query: String?
    /// The index of the first issue to return from the JQL query.
    public var startAt: Int?
    /// The maximum number of issues to return from the JQL query. Inspect `meta.issues.jql.maxResults` in the response to ensure the maximum value has not been exceeded.
    public var maxResults: Int?
    /// Determines how to validate the JQL query and treat the validation results.
    public var validation: Validation?

    /// Determines how to validate the JQL query and treat the validation results.
    public enum Validation: String, Codable, CaseIterable {
        case strict
        case warn
        case `none`
    }

    public init(query: String? = nil, startAt: Int? = nil, maxResults: Int? = nil, validation: Validation? = nil) {
        self.query = query
        self.startAt = startAt
        self.maxResults = maxResults
        self.validation = validation
    }
}

public struct JiraExpressionEvalContextBean: Codable {
    /// The issue that is available under the `issue` variable when evaluating the expression.
    public var issue: IDOrKeyBean?
    /// The collection of issues that is available under the `issues` variable when evaluating the expression.
    public var issues: JexpIssues?
    /// The project that is available under the `project` variable when evaluating the expression.
    public var project: IDOrKeyBean?
    /// The ID of the sprint that is available under the `sprint` variable when evaluating the expression.
    public var sprint: Int?
    /// The ID of the board that is available under the `board` variable when evaluating the expression.
    public var board: Int?
    /// The ID of the service desk that is available under the `serviceDesk` variable when evaluating the expression.
    public var serviceDesk: Int?
    /// The ID of the customer request that is available under the `customerRequest` variable when evaluating the expression. This is the same as the ID of the underlying Jira issue, but the customer request context variable will have a different type.
    public var customerRequest: Int?
    /// Custom context variables and their types. These variable types are available for use in a custom context:
    /// 
    ///  *  `user`: A [user](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#user) specified as an Atlassian account ID.
    ///  *  `issue`: An [issue](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#issue) specified by ID or key. All the fields of the issue object are available in the Jira expression.
    ///  *  `json`: A JSON object containing custom content.
    ///  *  `list`: A JSON list of `user`, `issue`, or `json` variable types.
    public var custom: [CustomContextVariable]?

    public init(issue: IDOrKeyBean? = nil, issues: JexpIssues? = nil, project: IDOrKeyBean? = nil, sprint: Int? = nil, board: Int? = nil, serviceDesk: Int? = nil, customerRequest: Int? = nil, custom: [CustomContextVariable]? = nil) {
        self.issue = issue
        self.issues = issues
        self.project = project
        self.sprint = sprint
        self.board = board
        self.serviceDesk = serviceDesk
        self.customerRequest = customerRequest
        self.custom = custom
    }
}

public struct JiraExpressionEvalRequestBean: Codable {
    /// The Jira expression to evaluate.
    ///
    /// Example: "{ key: issue.key, type: issue.issueType.name, links: issue.links.map(link => link.linkedIssue.id) }"
    public var expression: String
    /// The context in which the Jira expression is evaluated.
    public var context: JiraExpressionEvalContextBean?

    public init(expression: String, context: JiraExpressionEvalContextBean? = nil) {
        self.expression = expression
        self.context = context
    }
}

/// A JSON object with custom content.
public struct JSONContextVariable: Codable {
    /// Type of custom context variable.
    public var type: String
    /// A JSON object containing custom content.
    public var value: Value?

    /// A JSON object containing custom content.
    public struct Value: Codable {
        public init() {}
    }

    public init(type: String, value: Value? = nil) {
        self.type = type
        self.value = value
    }
}

/// A [user](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#user) specified as an Atlassian account ID.
public struct UserContextVariable: Codable {
    /// Type of custom context variable.
    public var type: String
    /// The account ID of the user.
    public var accountID: String

    public init(type: String, accountID: String) {
        self.type = type
        self.accountID = accountID
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case accountID = "accountId"
    }
}

/// The description of the page of issues loaded by the provided JQL query.
public struct IssuesJqlMetaDataBean: Codable {
    /// The index of the first issue.
    public var startAt: Int
    /// The maximum number of issues that could be loaded in this evaluation.
    public var maxResults: Int
    /// The number of issues that were loaded in this evaluation.
    public var count: Int
    /// The total number of issues the JQL returned.
    public var totalCount: Int
    /// Any warnings related to the JQL query. Present only if the validation mode was set to `warn`.
    public var validationWarnings: [String]?

    public init(startAt: Int, maxResults: Int, count: Int, totalCount: Int, validationWarnings: [String]? = nil) {
        self.startAt = startAt
        self.maxResults = maxResults
        self.count = count
        self.totalCount = totalCount
        self.validationWarnings = validationWarnings
    }
}

/// Meta data describing the `issues` context variable.
public struct IssuesMetaBean: Codable {
    /// The description of the page of issues loaded by the provided JQL query.
    public var jql: IssuesJqlMetaDataBean?

    public init(jql: IssuesJqlMetaDataBean? = nil) {
        self.jql = jql
    }
}

public struct JiraExpressionEvaluationMetaDataBean: Codable {
    /// Contains information about the expression complexity. For example, the number of steps it took to evaluate the expression.
    public var complexity: JiraExpressionsComplexityBean?
    /// Contains information about the `issues` variable in the context. For example, is the issues were loaded with JQL, information about the page will be included here.
    public var issues: IssuesMetaBean?

    public init(complexity: JiraExpressionsComplexityBean? = nil, issues: IssuesMetaBean? = nil) {
        self.complexity = complexity
        self.issues = issues
    }
}

/// The result of evaluating a Jira expression.
public struct JiraExpressionResult: Codable {
    /// The value of the evaluated expression. It may be a primitive JSON value or a Jira REST API object. (Some expressions do not produce any meaningful results—for example, an expression that returns a lambda function—if that's the case a simple string representation is returned. These string representations should not be relied upon and may change without notice.)
    public var value: AnyJSON
    /// Contains various characteristics of the performed expression evaluation.
    public var meta: JiraExpressionEvaluationMetaDataBean?

    public init(value: AnyJSON, meta: JiraExpressionEvaluationMetaDataBean? = nil) {
        self.value = value
        self.meta = meta
    }
}

public struct JiraExpressionsComplexityBean: Codable {
    /// The number of steps it took to evaluate the expression, where a step is a high-level operation performed by the expression. A step is an operation such as arithmetic, accessing a property, accessing a context variable, or calling a function.
    public var steps: JiraExpressionsComplexityValueBean
    /// The number of expensive operations executed while evaluating the expression. Expensive operations are those that load additional data, such as entity properties, comments, or custom fields.
    public var expensiveOperations: JiraExpressionsComplexityValueBean
    /// The number of Jira REST API beans returned in the response.
    public var beans: JiraExpressionsComplexityValueBean
    /// The number of primitive values returned in the response.
    public var primitiveValues: JiraExpressionsComplexityValueBean

    public init(steps: JiraExpressionsComplexityValueBean, expensiveOperations: JiraExpressionsComplexityValueBean, beans: JiraExpressionsComplexityValueBean, primitiveValues: JiraExpressionsComplexityValueBean) {
        self.steps = steps
        self.expensiveOperations = expensiveOperations
        self.beans = beans
        self.primitiveValues = primitiveValues
    }
}

public struct JiraExpressionsComplexityValueBean: Codable {
    /// The complexity value of the current expression.
    public var value: Int
    /// The maximum allowed complexity. The evaluation will fail if this value is exceeded.
    public var limit: Int

    public init(value: Int, limit: Int) {
        self.value = value
        self.limit = limit
    }
}

/// Details of Jira expressions for analysis.
public struct JiraExpressionForAnalysis: Codable {
    /// The list of Jira expressions to analyse.
    ///
    /// Example: "issues.map(issue => issue.properties['property_key'])"
    public var expressions: [String]
    /// Context variables and their types. The type checker assumes that [common context variables](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/#context-variables), such as `issue` or `project`, are available in context and sets their type. Use this property to override the default types or provide details of new variables.
    public var contextVariables: [String: String]?

    public init(expressions: [String], contextVariables: [String: String]? = nil) {
        self.expressions = expressions
        self.contextVariables = contextVariables
    }
}

/// Details about the analysed Jira expression.
public struct JiraExpressionAnalysis: Codable {
    /// The analysed expression.
    public var expression: String
    /// A list of validation errors. Not included if the expression is valid.
    public var errors: [JiraExpressionValidationError]?
    /// Whether the expression is valid and the interpreter will evaluate it. Note that the expression may fail at runtime (for example, if it executes too many expensive operations).
    public var isValid: Bool
    /// EXPERIMENTAL. The inferred type of the expression.
    public var type: String?
    /// Details about the complexity of the analysed Jira expression.
    public var complexity: JiraExpressionComplexity?

    public init(expression: String, errors: [JiraExpressionValidationError]? = nil, isValid: Bool, type: String? = nil, complexity: JiraExpressionComplexity? = nil) {
        self.expression = expression
        self.errors = errors
        self.isValid = isValid
        self.type = type
        self.complexity = complexity
    }

    private enum CodingKeys: String, CodingKey {
        case expression
        case errors
        case isValid = "valid"
        case type
        case complexity
    }
}

/// Details about the complexity of the analysed Jira expression.
public struct JiraExpressionComplexity: Codable {
    /// Information that can be used to determine how many [expensive operations](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/#expensive-operations) the evaluation of the expression will perform. This information may be a formula or number. For example:
    /// 
    ///  *  `issues.map(i => i.comments)` performs as many expensive operations as there are issues on the issues list. So this parameter returns `N`, where `N` is the size of issue list.
    ///  *  `new Issue(10010).comments` gets comments for one issue, so its complexity is `2` (`1` to retrieve issue 10010 from the database plus `1` to get its comments).
    public var expensiveOperations: String
    /// Variables used in the formula, mapped to the parts of the expression they refer to.
    public var variables: [String: String]?

    public init(expensiveOperations: String, variables: [String: String]? = nil) {
        self.expensiveOperations = expensiveOperations
        self.variables = variables
    }
}

/// Details about syntax and type errors. The error details apply to the entire expression, unless the object includes:
/// 
///  *  `line` and `column`
///  *  `expression`
public struct JiraExpressionValidationError: Codable {
    /// The text line in which the error occurred.
    public var line: Int?
    /// The text column in which the error occurred.
    public var column: Int?
    /// The part of the expression in which the error occurred.
    public var expression: String?
    /// Details about the error.
    ///
    /// Example: "!, -, typeof, (, IDENTIFIER, null, true, false, NUMBER, STRING, TEMPLATE_LITERAL, new, [ or { expected, > encountered."
    public var message: String
    /// The error type.
    public var type: `Type`

    /// The error type.
    public enum `Type`: String, Codable, CaseIterable {
        case syntax
        case type
        case other
    }

    public init(line: Int? = nil, column: Int? = nil, expression: String? = nil, message: String, type: `Type`) {
        self.line = line
        self.column = column
        self.expression = expression
        self.message = message
        self.type = type
    }
}

/// Details about the analysed Jira expression.
public struct JiraExpressionsAnalysis: Codable {
    /// The results of Jira expressions analysis.
    public var results: [JiraExpressionAnalysis]

    public init(results: [JiraExpressionAnalysis]) {
        self.results = results
    }
}

/// Example:
///
/// {
///   "message" : "An example message.",
///   "statusCode" : 200
/// }
public struct OperationMessage: Codable {
    /// The human-readable message that describes the result.
    public var message: String
    /// The status code of the response.
    public var statusCode: Int

    public init(message: String, statusCode: Int) {
        self.message = message
        self.statusCode = statusCode
    }
}

/// Example:
///
/// {
///   "message" : "The request is not from a Connect app."
/// }
public struct ErrorMessage: Codable {
    /// The error message.
    public var message: String

    public init(message: String) {
        self.message = message
    }
}

/// Example:
///
/// {
///   "jiraEntityProperties" : [
///     {
///       "entityType" : "issue",
///       "key" : "dynamic-attachment-entity-property",
///       "keyConfigurations" : [
///         {
///           "extractions" : [
///             {
///               "alias" : "attachmentExtension",
///               "objectName" : "extension",
///               "type" : "text"
///             }
///           ],
///           "propertyKey" : "attachment"
///         }
///       ],
///       "name" : {
///         "value" : "Attachment Index Document"
///       }
///     }
///   ],
///   "jiraIssueFields" : [
///     {
///       "description" : {
///         "value" : "A dynamically added single-select field"
///       },
///       "extractions" : [
///         {
///           "name" : "categoryName",
///           "path" : "category",
///           "type" : "text"
///         }
///       ],
///       "key" : "dynamic-select-field",
///       "name" : {
///         "value" : "Dynamic single select"
///       },
///       "type" : "single_select"
///     }
///   ]
/// }
public struct ConnectModules: Codable {
    /// A list of app modules in the same format as the `modules` property in the
    /// [app descriptor](https://developer.atlassian.com/cloud/jira/platform/app-descriptor/).
    public var modules: [ConnectModule]

    public init(modules: [ConnectModule]) {
        self.modules = modules
    }
}

/// A [Connect module](https://developer.atlassian.com/cloud/jira/platform/about-jira-modules/) in the same format as in the
/// [app descriptor](https://developer.atlassian.com/cloud/jira/platform/app-descriptor/).
///
/// Example:
///
/// {
///   "description" : {
///     "value" : "field with team"
///   },
///   "extractions" : [
///     {
///       "name" : "categoryName",
///       "path" : "category",
///       "type" : "text"
///     }
///   ],
///   "key" : "team-field",
///   "name" : {
///     "value" : "Team"
///   },
///   "type" : "single_select"
/// }
public struct ConnectModule: Codable {
    public init() {}
}

/// Details of the workflow and its transition rules.
public struct WorkflowRulesSearch: Codable {
    /// The workflow ID.
    ///
    /// Example: "a498d711-685d-428d-8c3e-bc03bb450ea7"
    public var workflowEntityID: String
    /// The list of workflow rule IDs.
    public var ruleIDs: [String]
    /// Use expand to include additional information in the response. This parameter accepts `transition` which, for each rule, returns information about the transition the rule is assigned to.
    ///
    /// Example: "transition"
    public var expand: String?

    public init(workflowEntityID: String, ruleIDs: [String], expand: String? = nil) {
        self.workflowEntityID = workflowEntityID
        self.ruleIDs = ruleIDs
        self.expand = expand
    }

    private enum CodingKeys: String, CodingKey {
        case workflowEntityID = "workflowEntityId"
        case ruleIDs = "ruleIds"
        case expand
    }
}

/// Details of workflow transition rules.
public struct WorkflowRulesSearchDetails: Codable {
    /// The workflow ID.
    ///
    /// Example: "a498d711-685d-428d-8c3e-bc03bb450ea7"
    public var workflowEntityID: String?
    /// List of workflow rule IDs that do not belong to the workflow or can not be found.
    public var invalidRules: [String]?
    /// List of valid workflow transition rules.
    public var validRules: [WorkflowTransitionRules]?

    public init(workflowEntityID: String? = nil, invalidRules: [String]? = nil, validRules: [WorkflowTransitionRules]? = nil) {
        self.workflowEntityID = workflowEntityID
        self.invalidRules = invalidRules
        self.validRules = validRules
    }

    private enum CodingKeys: String, CodingKey {
        case workflowEntityID = "workflowEntityId"
        case invalidRules
        case validRules
    }
}

public struct EntityPropertyDetails: Codable {
    /// The entity property ID.
    ///
    /// Example: 123
    public var entityID: Double
    /// The entity property key.
    ///
    /// Example: "mykey"
    public var key: String
    /// The new value of the entity property.
    ///
    /// Example: "newValue"
    public var value: String

    public init(entityID: Double, key: String, value: String) {
        self.entityID = entityID
        self.key = key
        self.value = value
    }

    private enum CodingKeys: String, CodingKey {
        case entityID = "entityId"
        case key
        case value
    }
}

/// A list of custom field details.
public struct ConnectCustomFieldValue: Codable {
    /// The type of custom field.
    public var type: `Type`
    /// The issue ID.
    public var issueID: Int
    /// The custom field ID.
    public var fieldID: Int
    /// The value of string type custom field when `_type` is `StringIssueField`.
    public var string: String?
    /// The value of number type custom field when `_type` is `NumberIssueField`.
    public var number: Double?
    /// The value of richText type custom field when `_type` is `RichTextIssueField`.
    public var richText: String?
    /// The value of single select and multiselect custom field type when `_type` is `SingleSelectIssueField` or `MultiSelectIssueField`.
    public var optionID: String?
    /// The value of of text custom field type when `_type` is `TextIssueField`.
    public var text: String?

    /// The type of custom field.
    public enum `Type`: String, Codable, CaseIterable {
        case stringIssueField = "StringIssueField"
        case numberIssueField = "NumberIssueField"
        case richTextIssueField = "RichTextIssueField"
        case singleSelectIssueField = "SingleSelectIssueField"
        case multiSelectIssueField = "MultiSelectIssueField"
        case textIssueField = "TextIssueField"
    }

    public init(type: `Type`, issueID: Int, fieldID: Int, string: String? = nil, number: Double? = nil, richText: String? = nil, optionID: String? = nil, text: String? = nil) {
        self.type = type
        self.issueID = issueID
        self.fieldID = fieldID
        self.string = string
        self.number = number
        self.richText = richText
        self.optionID = optionID
        self.text = text
    }

    private enum CodingKeys: String, CodingKey {
        case type = "_type"
        case issueID
        case fieldID
        case string
        case number
        case richText
        case optionID
        case text
    }
}

/// Details of updates for a custom field.
public struct ConnectCustomFieldValues: Codable {
    /// The list of custom field update details.
    public var updateValueList: [ConnectCustomFieldValue]?

    public init(updateValueList: [ConnectCustomFieldValue]? = nil) {
        self.updateValueList = updateValueList
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
