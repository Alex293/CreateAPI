// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var account: Account {
        Account(path: "/account")
    }

    public struct Account {
        /// Path: `/account`
        public let path: String
    }
}

extension Paths.Account {
    public var info: Info {
        Info(path: path + "/info")
    }

    public struct Info {
        /// Path: `/account/info`
        public let path: String

        /// Get information about your account
        ///
        /// Get information about your account.
        public func get(details: Int? = nil) -> Request<RowshotAPI.Account> {
            .get(path, query: makeGetQuery(details))
        }

        private func makeGetQuery(_ details: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(details, forKey: "details")
            return encoder.items
        }
    }
}

extension Paths {
    public static var batch: Batch {
        Batch(path: "/batch")
    }

    public struct Batch {
        /// Path: `/batch`
        public let path: String
    }
}

extension Paths.Batch {
    public var ceate: Ceate {
        Ceate(path: path + "/ceate")
    }

    public struct Ceate {
        /// Path: `/batch/ceate`
        public let path: String

        /// Requests thousands of screenshtos at once
        ///
        /// Get hundreds or thousands of screenshots from a text file. You can use this API call or the dashboard. Unlike the other API calls, you must issue a POST request with the Content-Type "multipart/form-data" in order to upload the text file. The text file must contain the list of URLs to request, 1 URL per line. Failed screenshots will be tried up to 3 times before giving up.
        public func post(parameters: PostParameters? = nil, _ body: Data) -> Request<[RowshotAPI.Batch]> {
            .post(path, query: parameters?.asQuery, body: body)
        }

        public struct PostParameters {
            public var hosting: Hosting?
            public var hostingHeight: Int?
            public var hostingWidth: Int?
            public var hostingScale: Double?
            public var hostingBucket: String?
            public var hostingFile: String?
            public var hostingHeaders: String?

            public enum Hosting: String, Codable, CaseIterable {
                case s3
            }

            public init(hosting: Hosting? = nil, hostingHeight: Int? = nil, hostingWidth: Int? = nil, hostingScale: Double? = nil, hostingBucket: String? = nil, hostingFile: String? = nil, hostingHeaders: String? = nil) {
                self.hosting = hosting
                self.hostingHeight = hostingHeight
                self.hostingWidth = hostingWidth
                self.hostingScale = hostingScale
                self.hostingBucket = hostingBucket
                self.hostingFile = hostingFile
                self.hostingHeaders = hostingHeaders
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(hosting, forKey: "hosting")
                encoder.encode(hostingHeight, forKey: "hosting_height")
                encoder.encode(hostingWidth, forKey: "hosting_width")
                encoder.encode(hostingScale, forKey: "hosting_scale")
                encoder.encode(hostingBucket, forKey: "hosting_bucket")
                encoder.encode(hostingFile, forKey: "hosting_file")
                encoder.encode(hostingHeaders, forKey: "hosting_headers")
                return encoder.items
            }
        }
    }
}

extension Paths.Batch {
    public var info: Info {
        Info(path: path + "/info")
    }

    public struct Info {
        /// Path: `/batch/info`
        public let path: String

        /// Get the batch status
        ///
        /// Get the status of a batch requested through the API or through the dashboard.
        public func get(id: Int) -> Request<RowshotAPI.Batch> {
            .get(path, query: makeGetQuery(id))
        }

        private func makeGetQuery(_ id: Int) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(id, forKey: "id")
            return encoder.items
        }
    }
}

extension Paths {
    public static var browser: Browser {
        Browser(path: "/browser")
    }

    public struct Browser {
        /// Path: `/browser`
        public let path: String
    }
}

extension Paths.Browser {
    public var info: Info {
        Info(path: path + "/info")
    }

    public struct Info {
        /// Path: `/browser/info`
        public let path: String

        /// Get information about a browser
        ///
        /// Get information about a browser.
        public func get(id: Int) -> Request<RowshotAPI.Browser> {
            .get(path, query: makeGetQuery(id))
        }

        private func makeGetQuery(_ id: Int) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(id, forKey: "id")
            return encoder.items
        }
    }
}

extension Paths.Browser {
    public var list: List {
        List(path: path + "/list")
    }

    public struct List {
        /// Path: `/browser/list`
        public let path: String

        /// Get all browsers
        ///
        /// Get all browsers.
        public var get: Request<[String: RowshotAPI.Browser]> {
            .get(path)
        }
    }
}

extension Paths {
    public static var instance: Instance {
        Instance(path: "/instance")
    }

    public struct Instance {
        /// Path: `/instance`
        public let path: String
    }
}

extension Paths.Instance {
    public var info: Info {
        Info(path: path + "/info")
    }

    public struct Info {
        /// Path: `/instance/info`
        public let path: String

        /// Get information about an instance
        ///
        /// Get information about an instance.
        public func get(id: Int) -> Request<RowshotAPI.Instance> {
            .get(path, query: makeGetQuery(id))
        }

        private func makeGetQuery(_ id: Int) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(id, forKey: "id")
            return encoder.items
        }
    }
}

extension Paths.Instance {
    public var list: List {
        List(path: path + "/list")
    }

    public struct List {
        /// Path: `/instance/list`
        public let path: String

        /// Get all instances
        ///
        /// Get all instances.
        public var get: Request<RowshotAPI.InstanceList> {
            .get(path)
        }
    }
}

extension Paths {
    public static var screenshot: Screenshot {
        Screenshot(path: "/screenshot")
    }

    public struct Screenshot {
        /// Path: `/screenshot`
        public let path: String
    }
}

extension Paths.Screenshot {
    public var create: Create {
        Create(path: path + "/create")
    }

    public struct Create {
        /// Path: `/screenshot/create`
        public let path: String

        /// Request a screenshot
        ///
        /// Screenshots requests to private and shared instances require a positive balance.
        /// 
        /// *IMPORTANT*: Remember that you can only do 100 free screenshots per month. To used a premium instance, use instance_id=65 for example.
        public func get(parameters: GetParameters) -> Request<RowshotAPI.Screenshot> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var url: String
            public var instanceID: Int
            public var size: Size?
            public var cache: Int?
            public var delay: Int?
            public var flashDelay: Int?
            public var screenWidth: Int?
            public var screenHeight: Int?
            public var priority: Int?
            public var referer: String?
            public var postData: String?
            public var cookie: String?
            public var script: String?
            public var details: Int?
            public var html: Int?
            public var maxWait: Int?
            public var headers: String?
            public var shots: Int?
            public var shotInterval: Int?
            public var hosting: Hosting?
            public var hostingHeight: Int?
            public var hostingWidth: Int?
            public var hostingScale: Double?
            public var hostingBucket: String?
            public var hostingFile: String?
            public var hostingHeaders: String?

            public enum Size: String, Codable, CaseIterable {
                case screen
                case page
            }

            public enum Hosting: String, Codable, CaseIterable {
                case s3
                case browshot
            }

            public init(url: String, instanceID: Int, size: Size? = nil, cache: Int? = nil, delay: Int? = nil, flashDelay: Int? = nil, screenWidth: Int? = nil, screenHeight: Int? = nil, priority: Int? = nil, referer: String? = nil, postData: String? = nil, cookie: String? = nil, script: String? = nil, details: Int? = nil, html: Int? = nil, maxWait: Int? = nil, headers: String? = nil, shots: Int? = nil, shotInterval: Int? = nil, hosting: Hosting? = nil, hostingHeight: Int? = nil, hostingWidth: Int? = nil, hostingScale: Double? = nil, hostingBucket: String? = nil, hostingFile: String? = nil, hostingHeaders: String? = nil) {
                self.url = url
                self.instanceID = instanceID
                self.size = size
                self.cache = cache
                self.delay = delay
                self.flashDelay = flashDelay
                self.screenWidth = screenWidth
                self.screenHeight = screenHeight
                self.priority = priority
                self.referer = referer
                self.postData = postData
                self.cookie = cookie
                self.script = script
                self.details = details
                self.html = html
                self.maxWait = maxWait
                self.headers = headers
                self.shots = shots
                self.shotInterval = shotInterval
                self.hosting = hosting
                self.hostingHeight = hostingHeight
                self.hostingWidth = hostingWidth
                self.hostingScale = hostingScale
                self.hostingBucket = hostingBucket
                self.hostingFile = hostingFile
                self.hostingHeaders = hostingHeaders
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(url, forKey: "url")
                encoder.encode(instanceID, forKey: "instance_id")
                encoder.encode(size, forKey: "size")
                encoder.encode(cache, forKey: "cache")
                encoder.encode(delay, forKey: "delay")
                encoder.encode(flashDelay, forKey: "flash_delay")
                encoder.encode(screenWidth, forKey: "screen_width")
                encoder.encode(screenHeight, forKey: "screen_height")
                encoder.encode(priority, forKey: "priority")
                encoder.encode(referer, forKey: "referer")
                encoder.encode(postData, forKey: "post_data")
                encoder.encode(cookie, forKey: "cookie")
                encoder.encode(script, forKey: "script")
                encoder.encode(details, forKey: "details")
                encoder.encode(html, forKey: "html")
                encoder.encode(maxWait, forKey: "max_wait")
                encoder.encode(headers, forKey: "headers")
                encoder.encode(shots, forKey: "shots")
                encoder.encode(shotInterval, forKey: "shot_interval")
                encoder.encode(hosting, forKey: "hosting")
                encoder.encode(hostingHeight, forKey: "hosting_height")
                encoder.encode(hostingWidth, forKey: "hosting_width")
                encoder.encode(hostingScale, forKey: "hosting_scale")
                encoder.encode(hostingBucket, forKey: "hosting_bucket")
                encoder.encode(hostingFile, forKey: "hosting_file")
                encoder.encode(hostingHeaders, forKey: "hosting_headers")
                return encoder.items
            }
        }
    }
}

extension Paths.Screenshot {
    public var delete: Delete {
        Delete(path: path + "/delete")
    }

    public struct Delete {
        /// Path: `/screenshot/delete`
        public let path: String

        /// Delete screenshot data
        ///
        /// You can delete details of your screenshots to remove any confidential information.
        public func get(id: Int, data: String? = nil) -> Request<[RowshotAPI.ScreenshotShort]> {
            .get(path, query: makeGetQuery(id, data))
        }

        private func makeGetQuery(_ id: Int, _ data: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(id, forKey: "id")
            encoder.encode(data, forKey: "data")
            return encoder.items
        }
    }
}

extension Paths.Screenshot {
    public var host: Host {
        Host(path: path + "/host")
    }

    public struct Host {
        /// Path: `/screenshot/host`
        public let path: String

        /// Host thumbnails on your own S3 account or on Browshot.
        ///
        /// You can host screenshots and thumbnails on your own S3 account or on Browshot.
        public func get(parameters: GetParameters) -> Request<[RowshotAPI.ScreenshotHost]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var id: Int
            public var hosting: Hosting
            public var width: Int?
            public var height: Int?
            public var scale: Double?
            public var bucket: String?
            public var file: String?
            public var headers: String?

            public enum Hosting: String, Codable, CaseIterable {
                case s3
                case browshot
            }

            public init(id: Int, hosting: Hosting, width: Int? = nil, height: Int? = nil, scale: Double? = nil, bucket: String? = nil, file: String? = nil, headers: String? = nil) {
                self.id = id
                self.hosting = hosting
                self.width = width
                self.height = height
                self.scale = scale
                self.bucket = bucket
                self.file = file
                self.headers = headers
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(id, forKey: "id")
                encoder.encode(hosting, forKey: "hosting")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(scale, forKey: "scale")
                encoder.encode(bucket, forKey: "bucket")
                encoder.encode(file, forKey: "file")
                encoder.encode(headers, forKey: "headers")
                return encoder.items
            }
        }
    }
}

extension Paths.Screenshot {
    public var html: HTML {
        HTML(path: path + "/html")
    }

    public struct HTML {
        /// Path: `/screenshot/html`
        public let path: String

        /// Get the HTML code
        ///
        /// Retrieve the HTML code of the rendered page. This API call should be used when html=1 was specified in the screenshot request.
        public func get(id: Int) -> Request<Void> {
            .get(path, query: makeGetQuery(id))
        }

        private func makeGetQuery(_ id: Int) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(id, forKey: "id")
            return encoder.items
        }
    }
}

extension Paths.Screenshot {
    public var info: Info {
        Info(path: path + "/info")
    }

    public struct Info {
        /// Path: `/screenshot/info`
        public let path: String

        /// Query screenshot status
        ///
        /// Once a screenshot has been requested, its status must be checked until it is either "error" or "finished".
        public func get(id: Int, details: Int? = nil) -> Request<[RowshotAPI.Screenshot]> {
            .get(path, query: makeGetQuery(id, details))
        }

        private func makeGetQuery(_ id: Int, _ details: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(id, forKey: "id")
            encoder.encode(details, forKey: "details")
            return encoder.items
        }
    }
}

extension Paths.Screenshot {
    public var list: List {
        List(path: path + "/list")
    }

    public struct List {
        /// Path: `/screenshot/list`
        public let path: String

        /// Get information about screenshots
        ///
        /// Get information about the last 100 screenshots requested.
        public func get(limit: Int? = nil, status: Status? = nil) -> Request<[[String: RowshotAPI.Screenshot]]> {
            .get(path, query: makeGetQuery(limit, status))
        }

        private func makeGetQuery(_ limit: Int?, _ status: Status?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(limit, forKey: "limit")
            encoder.encode(status, forKey: "status")
            return encoder.items
        }

        public enum Status: String, Codable, CaseIterable {
            case error
            case finished
            case inProcess = "in_process"
        }
    }
}

extension Paths.Screenshot {
    public var multiple: Multiple {
        Multiple(path: path + "/multiple")
    }

    public struct Multiple {
        /// Path: `/screenshot/multiple`
        public let path: String

        /// Request multiple screenshots
        ///
        /// Request multiple screenshots in one API call. The API call accepts all the parameters supported by screenshot/create.
        /// You can specify up to 10 URLs and 10 instances for a total of 100 screenshots in one API call.
        public func get(parameters: GetParameters) -> Request<[String: RowshotAPI.Screenshot]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var url: String
            public var instanceID: Int
            public var size: Size?
            public var cache: Int?
            public var delay: Int?
            public var flashDelay: Int?
            public var screenWidth: Int?
            public var screenHeight: Int?
            public var priority: Int?
            public var referer: String?
            public var postData: String?
            public var cookie: String?
            public var script: String?
            public var details: Int?
            public var html: Int?
            public var maxWait: Int?
            public var headers: String?
            public var hosting: Hosting?
            public var hostingHeight: Int?
            public var hostingWidth: Int?
            public var hostingScale: Double?
            public var hostingBucket: String?
            public var hostingFile: String?
            public var hostingHeaders: String?

            public enum Size: String, Codable, CaseIterable {
                case screen
                case page
            }

            public enum Hosting: String, Codable, CaseIterable {
                case s3
                case browshot
            }

            public init(url: String, instanceID: Int, size: Size? = nil, cache: Int? = nil, delay: Int? = nil, flashDelay: Int? = nil, screenWidth: Int? = nil, screenHeight: Int? = nil, priority: Int? = nil, referer: String? = nil, postData: String? = nil, cookie: String? = nil, script: String? = nil, details: Int? = nil, html: Int? = nil, maxWait: Int? = nil, headers: String? = nil, hosting: Hosting? = nil, hostingHeight: Int? = nil, hostingWidth: Int? = nil, hostingScale: Double? = nil, hostingBucket: String? = nil, hostingFile: String? = nil, hostingHeaders: String? = nil) {
                self.url = url
                self.instanceID = instanceID
                self.size = size
                self.cache = cache
                self.delay = delay
                self.flashDelay = flashDelay
                self.screenWidth = screenWidth
                self.screenHeight = screenHeight
                self.priority = priority
                self.referer = referer
                self.postData = postData
                self.cookie = cookie
                self.script = script
                self.details = details
                self.html = html
                self.maxWait = maxWait
                self.headers = headers
                self.hosting = hosting
                self.hostingHeight = hostingHeight
                self.hostingWidth = hostingWidth
                self.hostingScale = hostingScale
                self.hostingBucket = hostingBucket
                self.hostingFile = hostingFile
                self.hostingHeaders = hostingHeaders
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(url, forKey: "url")
                encoder.encode(instanceID, forKey: "instance_id")
                encoder.encode(size, forKey: "size")
                encoder.encode(cache, forKey: "cache")
                encoder.encode(delay, forKey: "delay")
                encoder.encode(flashDelay, forKey: "flash_delay")
                encoder.encode(screenWidth, forKey: "screen_width")
                encoder.encode(screenHeight, forKey: "screen_height")
                encoder.encode(priority, forKey: "priority")
                encoder.encode(referer, forKey: "referer")
                encoder.encode(postData, forKey: "post_data")
                encoder.encode(cookie, forKey: "cookie")
                encoder.encode(script, forKey: "script")
                encoder.encode(details, forKey: "details")
                encoder.encode(html, forKey: "html")
                encoder.encode(maxWait, forKey: "max_wait")
                encoder.encode(headers, forKey: "headers")
                encoder.encode(hosting, forKey: "hosting")
                encoder.encode(hostingHeight, forKey: "hosting_height")
                encoder.encode(hostingWidth, forKey: "hosting_width")
                encoder.encode(hostingScale, forKey: "hosting_scale")
                encoder.encode(hostingBucket, forKey: "hosting_bucket")
                encoder.encode(hostingFile, forKey: "hosting_file")
                encoder.encode(hostingHeaders, forKey: "hosting_headers")
                return encoder.items
            }
        }
    }
}

extension Paths.Screenshot {
    public var search: Search {
        Search(path: path + "/search")
    }

    public struct Search {
        /// Path: `/screenshot/search`
        public let path: String

        /// Search for screenshots
        ///
        /// Search for screenshots of a specific URL.
        public func get(parameters: GetParameters) -> Request<[[String: RowshotAPI.Screenshot]]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var url: String
            public var limit: Int?
            public var status: Status?

            public enum Status: String, Codable, CaseIterable {
                case error
                case finished
                case inProcess = "in_process"
            }

            public init(url: String, limit: Int? = nil, status: Status? = nil) {
                self.url = url
                self.limit = limit
                self.status = status
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(url, forKey: "url")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(status, forKey: "status")
                return encoder.items
            }
        }
    }
}

extension Paths.Screenshot {
    public var share: Share {
        Share(path: path + "/share")
    }

    public struct Share {
        /// Path: `/screenshot/share`
        public let path: String

        /// Share a screenshot
        ///
        /// You can make your screenshots public, add notes, and share it with your friends and colleagues. Only screenshots which are successfully completed can be shared.n the thumbnail. You can take a 1024x768 screenshot, crop it to 768x768, and get it scaled down to 300x300.
        public func get(id: Int, note: String? = nil) -> Request<[RowshotAPI.ScreenshotHost]> {
            .get(path, query: makeGetQuery(id, note))
        }

        private func makeGetQuery(_ id: Int, _ note: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(id, forKey: "id")
            encoder.encode(note, forKey: "note")
            return encoder.items
        }
    }
}

extension Paths.Screenshot {
    public var thumbnail: Thumbnail {
        Thumbnail(path: path + "/thumbnail")
    }

    public struct Thumbnail {
        /// Path: `/screenshot/thumbnail`
        public let path: String

        /// Retrieve a thumbnail image
        ///
        /// Unlike the other API calls, this API sends back the thumbnail as a PNG file, not JSON. The HTTP response code indicates whether the screenshot was successful (200), or incomplete (404) or failed (404). If the screenshot failed or is not finished, a default image "Not found" is sent.
        /// 
        /// You can crop your screenshots. The crop is done first, then the thumbnail. You can take a 1024x768 screenshot, crop it to 768x768, and get it scaled down to 300x300.
        public func get(parameters: GetParameters) -> Request<Void> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var id: Int
            public var width: Int?
            public var height: Int?
            public var scale: Double?
            public var zoom: Int?
            public var ratio: Ratio?
            public var left: Int?
            public var right: Int?
            public var top: Int?
            public var bottom: Int?
            public var format: Format?
            public var shot: Int?
            public var quality: Int?

            public enum Ratio: String, Codable, CaseIterable {
                case fit
                case fill
            }

            public enum Format: String, Codable, CaseIterable {
                case png
                case jpeg
            }

            public init(id: Int, width: Int? = nil, height: Int? = nil, scale: Double? = nil, zoom: Int? = nil, ratio: Ratio? = nil, left: Int? = nil, right: Int? = nil, top: Int? = nil, bottom: Int? = nil, format: Format? = nil, shot: Int? = nil, quality: Int? = nil) {
                self.id = id
                self.width = width
                self.height = height
                self.scale = scale
                self.zoom = zoom
                self.ratio = ratio
                self.left = left
                self.right = right
                self.top = top
                self.bottom = bottom
                self.format = format
                self.shot = shot
                self.quality = quality
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(id, forKey: "id")
                encoder.encode(width, forKey: "width")
                encoder.encode(height, forKey: "height")
                encoder.encode(scale, forKey: "scale")
                encoder.encode(zoom, forKey: "zoom")
                encoder.encode(ratio, forKey: "ratio")
                encoder.encode(left, forKey: "left")
                encoder.encode(right, forKey: "right")
                encoder.encode(top, forKey: "top")
                encoder.encode(bottom, forKey: "bottom")
                encoder.encode(format, forKey: "format")
                encoder.encode(shot, forKey: "shot")
                encoder.encode(quality, forKey: "quality")
                return encoder.items
            }
        }
    }
}

public enum Paths {}
