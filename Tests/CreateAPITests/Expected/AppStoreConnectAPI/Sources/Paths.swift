// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get

extension Paths {
    public static var ageRatingDeclarations: AgeRatingDeclarations {
        AgeRatingDeclarations(path: "/v1/ageRatingDeclarations")
    }

    public struct AgeRatingDeclarations {
        /// Path: `/v1/ageRatingDeclarations`
        public let path: String
    }
}

extension Paths.AgeRatingDeclarations {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/ageRatingDeclarations/{id}`
        public let path: String

        public func patch(_ body: AppStoreConnectAPI.AgeRatingDeclarationUpdateRequest) -> Request<AppStoreConnectAPI.AgeRatingDeclarationResponse> {
            .patch(path, body: body)
        }
    }
}

extension Paths {
    public static var appCategories: AppCategories {
        AppCategories(path: "/v1/appCategories")
    }

    public struct AppCategories {
        /// Path: `/v1/appCategories`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppCategoriesResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterPlatforms: [FilterPlatforms]?
            public var existsParent: [String]?
            public var fieldsAppCategories: [FieldsAppCategories]?
            public var limit: Int?
            public var include: [Include]?
            public var limitSubcategories: Int?

            public enum FilterPlatforms: String, Codable, CaseIterable {
                case ios = "IOS"
                case macOs = "MAC_OS"
                case tvOs = "TV_OS"
            }

            public enum FieldsAppCategories: String, Codable, CaseIterable {
                case parent
                case platforms
                case subcategories
            }

            public enum Include: String, Codable, CaseIterable {
                case parent
                case subcategories
            }

            public init(filterPlatforms: [FilterPlatforms]? = nil, existsParent: [String]? = nil, fieldsAppCategories: [FieldsAppCategories]? = nil, limit: Int? = nil, include: [Include]? = nil, limitSubcategories: Int? = nil) {
                self.filterPlatforms = filterPlatforms
                self.existsParent = existsParent
                self.fieldsAppCategories = fieldsAppCategories
                self.limit = limit
                self.include = include
                self.limitSubcategories = limitSubcategories
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[platforms]", filterPlatforms?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("exists[parent]", existsParent?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appCategories]", fieldsAppCategories?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[subcategories]", limitSubcategories)
                return query
            }
        }
    }
}

extension Paths.AppCategories {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/appCategories/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppCategoryResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsAppCategories: [FieldsAppCategories]?
            public var include: [Include]?
            public var limitSubcategories: Int?

            public enum FieldsAppCategories: String, Codable, CaseIterable {
                case parent
                case platforms
                case subcategories
            }

            public enum Include: String, Codable, CaseIterable {
                case parent
                case subcategories
            }

            public init(fieldsAppCategories: [FieldsAppCategories]? = nil, include: [Include]? = nil, limitSubcategories: Int? = nil) {
                self.fieldsAppCategories = fieldsAppCategories
                self.include = include
                self.limitSubcategories = limitSubcategories
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[appCategories]", fieldsAppCategories?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[subcategories]", limitSubcategories)
                return query
            }
        }
    }
}

extension Paths.AppCategories.WithID {
    public var parent: Parent {
        Parent(path: path + "/parent")
    }

    public struct Parent {
        /// Path: `/v1/appCategories/{id}/parent`
        public let path: String

        public func get(fieldsAppCategories: [FieldsAppCategories]? = nil) -> Request<AppStoreConnectAPI.AppCategoryResponse> {
            .get(path, query: makeGetQuery(fieldsAppCategories))
        }

        private func makeGetQuery(_ fieldsAppCategories: [FieldsAppCategories]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[appCategories]", fieldsAppCategories?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsAppCategories: String, Codable, CaseIterable {
            case parent
            case platforms
            case subcategories
        }
    }
}

extension Paths.AppCategories.WithID {
    public var subcategories: Subcategories {
        Subcategories(path: path + "/subcategories")
    }

    public struct Subcategories {
        /// Path: `/v1/appCategories/{id}/subcategories`
        public let path: String

        public func get(fieldsAppCategories: [FieldsAppCategories]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.AppCategoriesResponse> {
            .get(path, query: makeGetQuery(fieldsAppCategories, limit))
        }

        private func makeGetQuery(_ fieldsAppCategories: [FieldsAppCategories]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[appCategories]", fieldsAppCategories?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsAppCategories: String, Codable, CaseIterable {
            case parent
            case platforms
            case subcategories
        }
    }
}

extension Paths {
    public static var appEncryptionDeclarations: AppEncryptionDeclarations {
        AppEncryptionDeclarations(path: "/v1/appEncryptionDeclarations")
    }

    public struct AppEncryptionDeclarations {
        /// Path: `/v1/appEncryptionDeclarations`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppEncryptionDeclarationsResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterPlatform: [FilterPlatform]?
            public var filterApp: [String]?
            public var filterBuilds: [String]?
            public var fieldsAppEncryptionDeclarations: [FieldsAppEncryptionDeclarations]?
            public var limit: Int?
            public var include: [Include]?
            public var fieldsApps: [FieldsApps]?

            public enum FilterPlatform: String, Codable, CaseIterable {
                case ios = "IOS"
                case macOs = "MAC_OS"
                case tvOs = "TV_OS"
            }

            public enum FieldsAppEncryptionDeclarations: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclarationState
                case availableOnFrenchStore
                case builds
                case codeValue
                case containsProprietaryCryptography
                case containsThirdPartyCryptography
                case documentName
                case documentType
                case documentURL = "documentUrl"
                case exempt
                case platform
                case uploadedDate
                case usesEncryption
            }

            public enum Include: String, Codable, CaseIterable {
                case app
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public init(filterPlatform: [FilterPlatform]? = nil, filterApp: [String]? = nil, filterBuilds: [String]? = nil, fieldsAppEncryptionDeclarations: [FieldsAppEncryptionDeclarations]? = nil, limit: Int? = nil, include: [Include]? = nil, fieldsApps: [FieldsApps]? = nil) {
                self.filterPlatform = filterPlatform
                self.filterApp = filterApp
                self.filterBuilds = filterBuilds
                self.fieldsAppEncryptionDeclarations = fieldsAppEncryptionDeclarations
                self.limit = limit
                self.include = include
                self.fieldsApps = fieldsApps
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[platform]", filterPlatform?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[app]", filterApp?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[builds]", filterBuilds?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appEncryptionDeclarations]", fieldsAppEncryptionDeclarations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.AppEncryptionDeclarations {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/appEncryptionDeclarations/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppEncryptionDeclarationResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsAppEncryptionDeclarations: [FieldsAppEncryptionDeclarations]?
            public var include: [Include]?
            public var fieldsApps: [FieldsApps]?

            public enum FieldsAppEncryptionDeclarations: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclarationState
                case availableOnFrenchStore
                case builds
                case codeValue
                case containsProprietaryCryptography
                case containsThirdPartyCryptography
                case documentName
                case documentType
                case documentURL = "documentUrl"
                case exempt
                case platform
                case uploadedDate
                case usesEncryption
            }

            public enum Include: String, Codable, CaseIterable {
                case app
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public init(fieldsAppEncryptionDeclarations: [FieldsAppEncryptionDeclarations]? = nil, include: [Include]? = nil, fieldsApps: [FieldsApps]? = nil) {
                self.fieldsAppEncryptionDeclarations = fieldsAppEncryptionDeclarations
                self.include = include
                self.fieldsApps = fieldsApps
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[appEncryptionDeclarations]", fieldsAppEncryptionDeclarations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.AppEncryptionDeclarations.WithID {
    public var app: App {
        App(path: path + "/app")
    }

    public struct App {
        /// Path: `/v1/appEncryptionDeclarations/{id}/app`
        public let path: String

        public func get(fieldsApps: [FieldsApps]? = nil) -> Request<AppStoreConnectAPI.AppResponse> {
            .get(path, query: makeGetQuery(fieldsApps))
        }

        private func makeGetQuery(_ fieldsApps: [FieldsApps]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsApps: String, Codable, CaseIterable {
            case appInfos
            case appStoreVersions
            case availableInNewTerritories
            case availableTerritories
            case betaAppLocalizations
            case betaAppReviewDetail
            case betaGroups
            case betaLicenseAgreement
            case betaTesters
            case builds
            case bundleID = "bundleId"
            case contentRightsDeclaration
            case endUserLicenseAgreement
            case gameCenterEnabledVersions
            case inAppPurchases
            case isOrEverWasMadeForKids
            case name
            case perfPowerMetrics
            case preOrder
            case preReleaseVersions
            case prices
            case primaryLocale
            case sku
        }
    }
}

extension Paths.AppEncryptionDeclarations.WithID {
    public var relationships: Relationships {
        Relationships(path: path + "/relationships")
    }

    public struct Relationships {
        /// Path: `/v1/appEncryptionDeclarations/{id}/relationships`
        public let path: String
    }
}

extension Paths.AppEncryptionDeclarations.WithID.Relationships {
    public var builds: Builds {
        Builds(path: path + "/builds")
    }

    public struct Builds {
        /// Path: `/v1/appEncryptionDeclarations/{id}/relationships/builds`
        public let path: String

        public func post(_ body: AppStoreConnectAPI.AppEncryptionDeclarationBuildsLinkagesRequest) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths {
    public static var appInfoLocalizations: AppInfoLocalizations {
        AppInfoLocalizations(path: "/v1/appInfoLocalizations")
    }

    public struct AppInfoLocalizations {
        /// Path: `/v1/appInfoLocalizations`
        public let path: String

        public func post(_ body: AppStoreConnectAPI.AppInfoLocalizationCreateRequest) -> Request<AppStoreConnectAPI.AppInfoLocalizationResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.AppInfoLocalizations {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/appInfoLocalizations/{id}`
        public let path: String

        public func get(fieldsAppInfoLocalizations: [FieldsAppInfoLocalizations]? = nil, include: [Include]? = nil) -> Request<AppStoreConnectAPI.AppInfoLocalizationResponse> {
            .get(path, query: makeGetQuery(fieldsAppInfoLocalizations, include))
        }

        private func makeGetQuery(_ fieldsAppInfoLocalizations: [FieldsAppInfoLocalizations]?, _ include: [Include]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[appInfoLocalizations]", fieldsAppInfoLocalizations?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsAppInfoLocalizations: String, Codable, CaseIterable {
            case appInfo
            case locale
            case name
            case privacyPolicyText
            case privacyPolicyURL = "privacyPolicyUrl"
            case subtitle
        }

        public enum Include: String, Codable, CaseIterable {
            case appInfo
        }

        public func patch(_ body: AppStoreConnectAPI.AppInfoLocalizationUpdateRequest) -> Request<AppStoreConnectAPI.AppInfoLocalizationResponse> {
            .patch(path, body: body)
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var appInfos: AppInfos {
        AppInfos(path: "/v1/appInfos")
    }

    public struct AppInfos {
        /// Path: `/v1/appInfos`
        public let path: String
    }
}

extension Paths.AppInfos {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/appInfos/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppInfoResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsAppInfos: [FieldsAppInfos]?
            public var include: [Include]?
            public var fieldsAgeRatingDeclarations: [FieldsAgeRatingDeclarations]?
            public var fieldsAppCategories: [FieldsAppCategories]?
            public var fieldsAppInfoLocalizations: [FieldsAppInfoLocalizations]?
            public var limitAppInfoLocalizations: Int?

            public enum FieldsAppInfos: String, Codable, CaseIterable {
                case ageRatingDeclaration
                case app
                case appInfoLocalizations
                case appStoreAgeRating
                case appStoreState
                case brazilAgeRating
                case kidsAgeBand
                case primaryCategory
                case primarySubcategoryOne
                case primarySubcategoryTwo
                case secondaryCategory
                case secondarySubcategoryOne
                case secondarySubcategoryTwo
            }

            public enum Include: String, Codable, CaseIterable {
                case ageRatingDeclaration
                case app
                case appInfoLocalizations
                case primaryCategory
                case primarySubcategoryOne
                case primarySubcategoryTwo
                case secondaryCategory
                case secondarySubcategoryOne
                case secondarySubcategoryTwo
            }

            public enum FieldsAgeRatingDeclarations: String, Codable, CaseIterable {
                case alcoholTobaccoOrDrugUseOrReferences
                case contests
                case gambling
                case gamblingAndContests
                case gamblingSimulated
                case horrorOrFearThemes
                case kidsAgeBand
                case matureOrSuggestiveThemes
                case medicalOrTreatmentInformation
                case profanityOrCrudeHumor
                case seventeenPlus
                case sexualContentGraphicAndNudity
                case sexualContentOrNudity
                case unrestrictedWebAccess
                case violenceCartoonOrFantasy
                case violenceRealistic
                case violenceRealisticProlongedGraphicOrSadistic
            }

            public enum FieldsAppCategories: String, Codable, CaseIterable {
                case parent
                case platforms
                case subcategories
            }

            public enum FieldsAppInfoLocalizations: String, Codable, CaseIterable {
                case appInfo
                case locale
                case name
                case privacyPolicyText
                case privacyPolicyURL = "privacyPolicyUrl"
                case subtitle
            }

            public init(fieldsAppInfos: [FieldsAppInfos]? = nil, include: [Include]? = nil, fieldsAgeRatingDeclarations: [FieldsAgeRatingDeclarations]? = nil, fieldsAppCategories: [FieldsAppCategories]? = nil, fieldsAppInfoLocalizations: [FieldsAppInfoLocalizations]? = nil, limitAppInfoLocalizations: Int? = nil) {
                self.fieldsAppInfos = fieldsAppInfos
                self.include = include
                self.fieldsAgeRatingDeclarations = fieldsAgeRatingDeclarations
                self.fieldsAppCategories = fieldsAppCategories
                self.fieldsAppInfoLocalizations = fieldsAppInfoLocalizations
                self.limitAppInfoLocalizations = limitAppInfoLocalizations
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[appInfos]", fieldsAppInfos?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[ageRatingDeclarations]", fieldsAgeRatingDeclarations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appCategories]", fieldsAppCategories?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appInfoLocalizations]", fieldsAppInfoLocalizations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[appInfoLocalizations]", limitAppInfoLocalizations)
                return query
            }
        }

        public func patch(_ body: AppStoreConnectAPI.AppInfoUpdateRequest) -> Request<AppStoreConnectAPI.AppInfoResponse> {
            .patch(path, body: body)
        }
    }
}

extension Paths.AppInfos.WithID {
    public var ageRatingDeclaration: AgeRatingDeclaration {
        AgeRatingDeclaration(path: path + "/ageRatingDeclaration")
    }

    public struct AgeRatingDeclaration {
        /// Path: `/v1/appInfos/{id}/ageRatingDeclaration`
        public let path: String

        public func get(fieldsAgeRatingDeclarations: [FieldsAgeRatingDeclarations]? = nil) -> Request<AppStoreConnectAPI.AgeRatingDeclarationResponse> {
            .get(path, query: makeGetQuery(fieldsAgeRatingDeclarations))
        }

        private func makeGetQuery(_ fieldsAgeRatingDeclarations: [FieldsAgeRatingDeclarations]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[ageRatingDeclarations]", fieldsAgeRatingDeclarations?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsAgeRatingDeclarations: String, Codable, CaseIterable {
            case alcoholTobaccoOrDrugUseOrReferences
            case contests
            case gambling
            case gamblingAndContests
            case gamblingSimulated
            case horrorOrFearThemes
            case kidsAgeBand
            case matureOrSuggestiveThemes
            case medicalOrTreatmentInformation
            case profanityOrCrudeHumor
            case seventeenPlus
            case sexualContentGraphicAndNudity
            case sexualContentOrNudity
            case unrestrictedWebAccess
            case violenceCartoonOrFantasy
            case violenceRealistic
            case violenceRealisticProlongedGraphicOrSadistic
        }
    }
}

extension Paths.AppInfos.WithID {
    public var appInfoLocalizations: AppInfoLocalizations {
        AppInfoLocalizations(path: path + "/appInfoLocalizations")
    }

    public struct AppInfoLocalizations {
        /// Path: `/v1/appInfos/{id}/appInfoLocalizations`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppInfoLocalizationsResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterLocale: [String]?
            public var fieldsAppInfos: [FieldsAppInfos]?
            public var fieldsAppInfoLocalizations: [FieldsAppInfoLocalizations]?
            public var limit: Int?
            public var include: [Include]?

            public enum FieldsAppInfos: String, Codable, CaseIterable {
                case ageRatingDeclaration
                case app
                case appInfoLocalizations
                case appStoreAgeRating
                case appStoreState
                case brazilAgeRating
                case kidsAgeBand
                case primaryCategory
                case primarySubcategoryOne
                case primarySubcategoryTwo
                case secondaryCategory
                case secondarySubcategoryOne
                case secondarySubcategoryTwo
            }

            public enum FieldsAppInfoLocalizations: String, Codable, CaseIterable {
                case appInfo
                case locale
                case name
                case privacyPolicyText
                case privacyPolicyURL = "privacyPolicyUrl"
                case subtitle
            }

            public enum Include: String, Codable, CaseIterable {
                case appInfo
            }

            public init(filterLocale: [String]? = nil, fieldsAppInfos: [FieldsAppInfos]? = nil, fieldsAppInfoLocalizations: [FieldsAppInfoLocalizations]? = nil, limit: Int? = nil, include: [Include]? = nil) {
                self.filterLocale = filterLocale
                self.fieldsAppInfos = fieldsAppInfos
                self.fieldsAppInfoLocalizations = fieldsAppInfoLocalizations
                self.limit = limit
                self.include = include
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[locale]", filterLocale?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appInfos]", fieldsAppInfos?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appInfoLocalizations]", fieldsAppInfoLocalizations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.AppInfos.WithID {
    public var primaryCategory: PrimaryCategory {
        PrimaryCategory(path: path + "/primaryCategory")
    }

    public struct PrimaryCategory {
        /// Path: `/v1/appInfos/{id}/primaryCategory`
        public let path: String

        public func get(fieldsAppCategories: [FieldsAppCategories]? = nil) -> Request<AppStoreConnectAPI.AppCategoryResponse> {
            .get(path, query: makeGetQuery(fieldsAppCategories))
        }

        private func makeGetQuery(_ fieldsAppCategories: [FieldsAppCategories]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[appCategories]", fieldsAppCategories?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsAppCategories: String, Codable, CaseIterable {
            case parent
            case platforms
            case subcategories
        }
    }
}

extension Paths.AppInfos.WithID {
    public var primarySubcategoryOne: PrimarySubcategoryOne {
        PrimarySubcategoryOne(path: path + "/primarySubcategoryOne")
    }

    public struct PrimarySubcategoryOne {
        /// Path: `/v1/appInfos/{id}/primarySubcategoryOne`
        public let path: String

        public func get(fieldsAppCategories: [FieldsAppCategories]? = nil) -> Request<AppStoreConnectAPI.AppCategoryResponse> {
            .get(path, query: makeGetQuery(fieldsAppCategories))
        }

        private func makeGetQuery(_ fieldsAppCategories: [FieldsAppCategories]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[appCategories]", fieldsAppCategories?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsAppCategories: String, Codable, CaseIterable {
            case parent
            case platforms
            case subcategories
        }
    }
}

extension Paths.AppInfos.WithID {
    public var primarySubcategoryTwo: PrimarySubcategoryTwo {
        PrimarySubcategoryTwo(path: path + "/primarySubcategoryTwo")
    }

    public struct PrimarySubcategoryTwo {
        /// Path: `/v1/appInfos/{id}/primarySubcategoryTwo`
        public let path: String

        public func get(fieldsAppCategories: [FieldsAppCategories]? = nil) -> Request<AppStoreConnectAPI.AppCategoryResponse> {
            .get(path, query: makeGetQuery(fieldsAppCategories))
        }

        private func makeGetQuery(_ fieldsAppCategories: [FieldsAppCategories]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[appCategories]", fieldsAppCategories?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsAppCategories: String, Codable, CaseIterable {
            case parent
            case platforms
            case subcategories
        }
    }
}

extension Paths.AppInfos.WithID {
    public var secondaryCategory: SecondaryCategory {
        SecondaryCategory(path: path + "/secondaryCategory")
    }

    public struct SecondaryCategory {
        /// Path: `/v1/appInfos/{id}/secondaryCategory`
        public let path: String

        public func get(fieldsAppCategories: [FieldsAppCategories]? = nil) -> Request<AppStoreConnectAPI.AppCategoryResponse> {
            .get(path, query: makeGetQuery(fieldsAppCategories))
        }

        private func makeGetQuery(_ fieldsAppCategories: [FieldsAppCategories]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[appCategories]", fieldsAppCategories?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsAppCategories: String, Codable, CaseIterable {
            case parent
            case platforms
            case subcategories
        }
    }
}

extension Paths.AppInfos.WithID {
    public var secondarySubcategoryOne: SecondarySubcategoryOne {
        SecondarySubcategoryOne(path: path + "/secondarySubcategoryOne")
    }

    public struct SecondarySubcategoryOne {
        /// Path: `/v1/appInfos/{id}/secondarySubcategoryOne`
        public let path: String

        public func get(fieldsAppCategories: [FieldsAppCategories]? = nil) -> Request<AppStoreConnectAPI.AppCategoryResponse> {
            .get(path, query: makeGetQuery(fieldsAppCategories))
        }

        private func makeGetQuery(_ fieldsAppCategories: [FieldsAppCategories]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[appCategories]", fieldsAppCategories?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsAppCategories: String, Codable, CaseIterable {
            case parent
            case platforms
            case subcategories
        }
    }
}

extension Paths.AppInfos.WithID {
    public var secondarySubcategoryTwo: SecondarySubcategoryTwo {
        SecondarySubcategoryTwo(path: path + "/secondarySubcategoryTwo")
    }

    public struct SecondarySubcategoryTwo {
        /// Path: `/v1/appInfos/{id}/secondarySubcategoryTwo`
        public let path: String

        public func get(fieldsAppCategories: [FieldsAppCategories]? = nil) -> Request<AppStoreConnectAPI.AppCategoryResponse> {
            .get(path, query: makeGetQuery(fieldsAppCategories))
        }

        private func makeGetQuery(_ fieldsAppCategories: [FieldsAppCategories]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[appCategories]", fieldsAppCategories?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsAppCategories: String, Codable, CaseIterable {
            case parent
            case platforms
            case subcategories
        }
    }
}

extension Paths {
    public static var appPreOrders: AppPreOrders {
        AppPreOrders(path: "/v1/appPreOrders")
    }

    public struct AppPreOrders {
        /// Path: `/v1/appPreOrders`
        public let path: String

        public func post(_ body: AppStoreConnectAPI.AppPreOrderCreateRequest) -> Request<AppStoreConnectAPI.AppPreOrderResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.AppPreOrders {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/appPreOrders/{id}`
        public let path: String

        public func get(fieldsAppPreOrders: [FieldsAppPreOrders]? = nil, include: [Include]? = nil) -> Request<AppStoreConnectAPI.AppPreOrderResponse> {
            .get(path, query: makeGetQuery(fieldsAppPreOrders, include))
        }

        private func makeGetQuery(_ fieldsAppPreOrders: [FieldsAppPreOrders]?, _ include: [Include]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[appPreOrders]", fieldsAppPreOrders?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsAppPreOrders: String, Codable, CaseIterable {
            case app
            case appReleaseDate
            case preOrderAvailableDate
        }

        public enum Include: String, Codable, CaseIterable {
            case app
        }

        public func patch(_ body: AppStoreConnectAPI.AppPreOrderUpdateRequest) -> Request<AppStoreConnectAPI.AppPreOrderResponse> {
            .patch(path, body: body)
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var appPreviewSets: AppPreviewSets {
        AppPreviewSets(path: "/v1/appPreviewSets")
    }

    public struct AppPreviewSets {
        /// Path: `/v1/appPreviewSets`
        public let path: String

        public func post(_ body: AppStoreConnectAPI.AppPreviewSetCreateRequest) -> Request<AppStoreConnectAPI.AppPreviewSetResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.AppPreviewSets {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/appPreviewSets/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppPreviewSetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsAppPreviewSets: [FieldsAppPreviewSets]?
            public var include: [Include]?
            public var fieldsAppPreviews: [FieldsAppPreviews]?
            public var limitAppPreviews: Int?

            public enum FieldsAppPreviewSets: String, Codable, CaseIterable {
                case appPreviews
                case appStoreVersionLocalization
                case previewType
            }

            public enum Include: String, Codable, CaseIterable {
                case appPreviews
                case appStoreVersionLocalization
            }

            public enum FieldsAppPreviews: String, Codable, CaseIterable {
                case appPreviewSet
                case assetDeliveryState
                case fileName
                case fileSize
                case mimeType
                case previewFrameTimeCode
                case previewImage
                case sourceFileChecksum
                case uploadOperations
                case uploaded
                case videoURL = "videoUrl"
            }

            public init(fieldsAppPreviewSets: [FieldsAppPreviewSets]? = nil, include: [Include]? = nil, fieldsAppPreviews: [FieldsAppPreviews]? = nil, limitAppPreviews: Int? = nil) {
                self.fieldsAppPreviewSets = fieldsAppPreviewSets
                self.include = include
                self.fieldsAppPreviews = fieldsAppPreviews
                self.limitAppPreviews = limitAppPreviews
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[appPreviewSets]", fieldsAppPreviewSets?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appPreviews]", fieldsAppPreviews?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[appPreviews]", limitAppPreviews)
                return query
            }
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.AppPreviewSets.WithID {
    public var appPreviews: AppPreviews {
        AppPreviews(path: path + "/appPreviews")
    }

    public struct AppPreviews {
        /// Path: `/v1/appPreviewSets/{id}/appPreviews`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppPreviewsResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsAppPreviews: [FieldsAppPreviews]?
            public var fieldsAppPreviewSets: [FieldsAppPreviewSets]?
            public var limit: Int?
            public var include: [Include]?

            public enum FieldsAppPreviews: String, Codable, CaseIterable {
                case appPreviewSet
                case assetDeliveryState
                case fileName
                case fileSize
                case mimeType
                case previewFrameTimeCode
                case previewImage
                case sourceFileChecksum
                case uploadOperations
                case uploaded
                case videoURL = "videoUrl"
            }

            public enum FieldsAppPreviewSets: String, Codable, CaseIterable {
                case appPreviews
                case appStoreVersionLocalization
                case previewType
            }

            public enum Include: String, Codable, CaseIterable {
                case appPreviewSet
            }

            public init(fieldsAppPreviews: [FieldsAppPreviews]? = nil, fieldsAppPreviewSets: [FieldsAppPreviewSets]? = nil, limit: Int? = nil, include: [Include]? = nil) {
                self.fieldsAppPreviews = fieldsAppPreviews
                self.fieldsAppPreviewSets = fieldsAppPreviewSets
                self.limit = limit
                self.include = include
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[appPreviews]", fieldsAppPreviews?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appPreviewSets]", fieldsAppPreviewSets?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.AppPreviewSets.WithID {
    public var relationships: Relationships {
        Relationships(path: path + "/relationships")
    }

    public struct Relationships {
        /// Path: `/v1/appPreviewSets/{id}/relationships`
        public let path: String
    }
}

extension Paths.AppPreviewSets.WithID.Relationships {
    public var appPreviews: AppPreviews {
        AppPreviews(path: path + "/appPreviews")
    }

    public struct AppPreviews {
        /// Path: `/v1/appPreviewSets/{id}/relationships/appPreviews`
        public let path: String

        public func get(limit: Int? = nil) -> Request<AppStoreConnectAPI.AppPreviewSetAppPreviewsLinkagesResponse> {
            .get(path, query: makeGetQuery(limit))
        }

        private func makeGetQuery(_ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("limit", limit)
            return query
        }

        public func patch(_ body: AppStoreConnectAPI.AppPreviewSetAppPreviewsLinkagesRequest) -> Request<Void> {
            .patch(path, body: body)
        }
    }
}

extension Paths {
    public static var appPreviews: AppPreviews {
        AppPreviews(path: "/v1/appPreviews")
    }

    public struct AppPreviews {
        /// Path: `/v1/appPreviews`
        public let path: String

        public func post(_ body: AppStoreConnectAPI.AppPreviewCreateRequest) -> Request<AppStoreConnectAPI.AppPreviewResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.AppPreviews {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/appPreviews/{id}`
        public let path: String

        public func get(fieldsAppPreviews: [FieldsAppPreviews]? = nil, include: [Include]? = nil) -> Request<AppStoreConnectAPI.AppPreviewResponse> {
            .get(path, query: makeGetQuery(fieldsAppPreviews, include))
        }

        private func makeGetQuery(_ fieldsAppPreviews: [FieldsAppPreviews]?, _ include: [Include]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[appPreviews]", fieldsAppPreviews?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsAppPreviews: String, Codable, CaseIterable {
            case appPreviewSet
            case assetDeliveryState
            case fileName
            case fileSize
            case mimeType
            case previewFrameTimeCode
            case previewImage
            case sourceFileChecksum
            case uploadOperations
            case uploaded
            case videoURL = "videoUrl"
        }

        public enum Include: String, Codable, CaseIterable {
            case appPreviewSet
        }

        public func patch(_ body: AppStoreConnectAPI.AppPreviewUpdateRequest) -> Request<AppStoreConnectAPI.AppPreviewResponse> {
            .patch(path, body: body)
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var appPricePoints: AppPricePoints {
        AppPricePoints(path: "/v1/appPricePoints")
    }

    public struct AppPricePoints {
        /// Path: `/v1/appPricePoints`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppPricePointsResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterPriceTier: [String]?
            public var filterTerritory: [String]?
            public var fieldsAppPricePoints: [FieldsAppPricePoints]?
            public var limit: Int?
            public var include: [Include]?
            public var fieldsTerritories: [FieldsTerritories]?

            public enum FieldsAppPricePoints: String, Codable, CaseIterable {
                case customerPrice
                case priceTier
                case proceeds
                case territory
            }

            public enum Include: String, Codable, CaseIterable {
                case priceTier
                case territory
            }

            public enum FieldsTerritories: String, Codable, CaseIterable {
                case currency
            }

            public init(filterPriceTier: [String]? = nil, filterTerritory: [String]? = nil, fieldsAppPricePoints: [FieldsAppPricePoints]? = nil, limit: Int? = nil, include: [Include]? = nil, fieldsTerritories: [FieldsTerritories]? = nil) {
                self.filterPriceTier = filterPriceTier
                self.filterTerritory = filterTerritory
                self.fieldsAppPricePoints = fieldsAppPricePoints
                self.limit = limit
                self.include = include
                self.fieldsTerritories = fieldsTerritories
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[priceTier]", filterPriceTier?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[territory]", filterTerritory?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appPricePoints]", fieldsAppPricePoints?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[territories]", fieldsTerritories?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.AppPricePoints {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/appPricePoints/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppPricePointResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsAppPricePoints: [FieldsAppPricePoints]?
            public var include: [Include]?
            public var fieldsTerritories: [FieldsTerritories]?

            public enum FieldsAppPricePoints: String, Codable, CaseIterable {
                case customerPrice
                case priceTier
                case proceeds
                case territory
            }

            public enum Include: String, Codable, CaseIterable {
                case priceTier
                case territory
            }

            public enum FieldsTerritories: String, Codable, CaseIterable {
                case currency
            }

            public init(fieldsAppPricePoints: [FieldsAppPricePoints]? = nil, include: [Include]? = nil, fieldsTerritories: [FieldsTerritories]? = nil) {
                self.fieldsAppPricePoints = fieldsAppPricePoints
                self.include = include
                self.fieldsTerritories = fieldsTerritories
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[appPricePoints]", fieldsAppPricePoints?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[territories]", fieldsTerritories?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.AppPricePoints.WithID {
    public var territory: Territory {
        Territory(path: path + "/territory")
    }

    public struct Territory {
        /// Path: `/v1/appPricePoints/{id}/territory`
        public let path: String

        public func get(fieldsTerritories: [FieldsTerritories]? = nil) -> Request<AppStoreConnectAPI.TerritoryResponse> {
            .get(path, query: makeGetQuery(fieldsTerritories))
        }

        private func makeGetQuery(_ fieldsTerritories: [FieldsTerritories]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[territories]", fieldsTerritories?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsTerritories: String, Codable, CaseIterable {
            case currency
        }
    }
}

extension Paths {
    public static var appPriceTiers: AppPriceTiers {
        AppPriceTiers(path: "/v1/appPriceTiers")
    }

    public struct AppPriceTiers {
        /// Path: `/v1/appPriceTiers`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppPriceTiersResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterID: [String]?
            public var fieldsAppPriceTiers: [FieldsAppPriceTiers]?
            public var limit: Int?
            public var include: [Include]?
            public var fieldsAppPricePoints: [FieldsAppPricePoints]?
            public var limitPricePoints: Int?

            public enum FieldsAppPriceTiers: String, Codable, CaseIterable {
                case pricePoints
            }

            public enum Include: String, Codable, CaseIterable {
                case pricePoints
            }

            public enum FieldsAppPricePoints: String, Codable, CaseIterable {
                case customerPrice
                case priceTier
                case proceeds
                case territory
            }

            public init(filterID: [String]? = nil, fieldsAppPriceTiers: [FieldsAppPriceTiers]? = nil, limit: Int? = nil, include: [Include]? = nil, fieldsAppPricePoints: [FieldsAppPricePoints]? = nil, limitPricePoints: Int? = nil) {
                self.filterID = filterID
                self.fieldsAppPriceTiers = fieldsAppPriceTiers
                self.limit = limit
                self.include = include
                self.fieldsAppPricePoints = fieldsAppPricePoints
                self.limitPricePoints = limitPricePoints
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[id]", filterID?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appPriceTiers]", fieldsAppPriceTiers?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appPricePoints]", fieldsAppPricePoints?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[pricePoints]", limitPricePoints)
                return query
            }
        }
    }
}

extension Paths.AppPriceTiers {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/appPriceTiers/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppPriceTierResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsAppPriceTiers: [FieldsAppPriceTiers]?
            public var include: [Include]?
            public var fieldsAppPricePoints: [FieldsAppPricePoints]?
            public var limitPricePoints: Int?

            public enum FieldsAppPriceTiers: String, Codable, CaseIterable {
                case pricePoints
            }

            public enum Include: String, Codable, CaseIterable {
                case pricePoints
            }

            public enum FieldsAppPricePoints: String, Codable, CaseIterable {
                case customerPrice
                case priceTier
                case proceeds
                case territory
            }

            public init(fieldsAppPriceTiers: [FieldsAppPriceTiers]? = nil, include: [Include]? = nil, fieldsAppPricePoints: [FieldsAppPricePoints]? = nil, limitPricePoints: Int? = nil) {
                self.fieldsAppPriceTiers = fieldsAppPriceTiers
                self.include = include
                self.fieldsAppPricePoints = fieldsAppPricePoints
                self.limitPricePoints = limitPricePoints
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[appPriceTiers]", fieldsAppPriceTiers?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appPricePoints]", fieldsAppPricePoints?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[pricePoints]", limitPricePoints)
                return query
            }
        }
    }
}

extension Paths.AppPriceTiers.WithID {
    public var pricePoints: PricePoints {
        PricePoints(path: path + "/pricePoints")
    }

    public struct PricePoints {
        /// Path: `/v1/appPriceTiers/{id}/pricePoints`
        public let path: String

        public func get(fieldsAppPricePoints: [FieldsAppPricePoints]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.AppPricePointsResponse> {
            .get(path, query: makeGetQuery(fieldsAppPricePoints, limit))
        }

        private func makeGetQuery(_ fieldsAppPricePoints: [FieldsAppPricePoints]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[appPricePoints]", fieldsAppPricePoints?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsAppPricePoints: String, Codable, CaseIterable {
            case customerPrice
            case priceTier
            case proceeds
            case territory
        }
    }
}

extension Paths {
    public static var appPrices: AppPrices {
        AppPrices(path: "/v1/appPrices")
    }

    public struct AppPrices {
        /// Path: `/v1/appPrices`
        public let path: String
    }
}

extension Paths.AppPrices {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/appPrices/{id}`
        public let path: String

        public func get(fieldsAppPrices: [FieldsAppPrices]? = nil, include: [Include]? = nil) -> Request<AppStoreConnectAPI.AppPriceResponse> {
            .get(path, query: makeGetQuery(fieldsAppPrices, include))
        }

        private func makeGetQuery(_ fieldsAppPrices: [FieldsAppPrices]?, _ include: [Include]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[appPrices]", fieldsAppPrices?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsAppPrices: String, Codable, CaseIterable {
            case app
            case priceTier
        }

        public enum Include: String, Codable, CaseIterable {
            case app
            case priceTier
        }
    }
}

extension Paths {
    public static var appScreenshotSets: AppScreenshotSets {
        AppScreenshotSets(path: "/v1/appScreenshotSets")
    }

    public struct AppScreenshotSets {
        /// Path: `/v1/appScreenshotSets`
        public let path: String

        public func post(_ body: AppStoreConnectAPI.AppScreenshotSetCreateRequest) -> Request<AppStoreConnectAPI.AppScreenshotSetResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.AppScreenshotSets {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/appScreenshotSets/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppScreenshotSetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsAppScreenshotSets: [FieldsAppScreenshotSets]?
            public var include: [Include]?
            public var fieldsAppScreenshots: [FieldsAppScreenshots]?
            public var limitAppScreenshots: Int?

            public enum FieldsAppScreenshotSets: String, Codable, CaseIterable {
                case appScreenshots
                case appStoreVersionLocalization
                case screenshotDisplayType
            }

            public enum Include: String, Codable, CaseIterable {
                case appScreenshots
                case appStoreVersionLocalization
            }

            public enum FieldsAppScreenshots: String, Codable, CaseIterable {
                case appScreenshotSet
                case assetDeliveryState
                case assetToken
                case assetType
                case fileName
                case fileSize
                case imageAsset
                case sourceFileChecksum
                case uploadOperations
                case uploaded
            }

            public init(fieldsAppScreenshotSets: [FieldsAppScreenshotSets]? = nil, include: [Include]? = nil, fieldsAppScreenshots: [FieldsAppScreenshots]? = nil, limitAppScreenshots: Int? = nil) {
                self.fieldsAppScreenshotSets = fieldsAppScreenshotSets
                self.include = include
                self.fieldsAppScreenshots = fieldsAppScreenshots
                self.limitAppScreenshots = limitAppScreenshots
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[appScreenshotSets]", fieldsAppScreenshotSets?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appScreenshots]", fieldsAppScreenshots?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[appScreenshots]", limitAppScreenshots)
                return query
            }
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.AppScreenshotSets.WithID {
    public var appScreenshots: AppScreenshots {
        AppScreenshots(path: path + "/appScreenshots")
    }

    public struct AppScreenshots {
        /// Path: `/v1/appScreenshotSets/{id}/appScreenshots`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppScreenshotsResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsAppScreenshotSets: [FieldsAppScreenshotSets]?
            public var fieldsAppScreenshots: [FieldsAppScreenshots]?
            public var limit: Int?
            public var include: [Include]?

            public enum FieldsAppScreenshotSets: String, Codable, CaseIterable {
                case appScreenshots
                case appStoreVersionLocalization
                case screenshotDisplayType
            }

            public enum FieldsAppScreenshots: String, Codable, CaseIterable {
                case appScreenshotSet
                case assetDeliveryState
                case assetToken
                case assetType
                case fileName
                case fileSize
                case imageAsset
                case sourceFileChecksum
                case uploadOperations
                case uploaded
            }

            public enum Include: String, Codable, CaseIterable {
                case appScreenshotSet
            }

            public init(fieldsAppScreenshotSets: [FieldsAppScreenshotSets]? = nil, fieldsAppScreenshots: [FieldsAppScreenshots]? = nil, limit: Int? = nil, include: [Include]? = nil) {
                self.fieldsAppScreenshotSets = fieldsAppScreenshotSets
                self.fieldsAppScreenshots = fieldsAppScreenshots
                self.limit = limit
                self.include = include
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[appScreenshotSets]", fieldsAppScreenshotSets?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appScreenshots]", fieldsAppScreenshots?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.AppScreenshotSets.WithID {
    public var relationships: Relationships {
        Relationships(path: path + "/relationships")
    }

    public struct Relationships {
        /// Path: `/v1/appScreenshotSets/{id}/relationships`
        public let path: String
    }
}

extension Paths.AppScreenshotSets.WithID.Relationships {
    public var appScreenshots: AppScreenshots {
        AppScreenshots(path: path + "/appScreenshots")
    }

    public struct AppScreenshots {
        /// Path: `/v1/appScreenshotSets/{id}/relationships/appScreenshots`
        public let path: String

        public func get(limit: Int? = nil) -> Request<AppStoreConnectAPI.AppScreenshotSetAppScreenshotsLinkagesResponse> {
            .get(path, query: makeGetQuery(limit))
        }

        private func makeGetQuery(_ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("limit", limit)
            return query
        }

        public func patch(_ body: AppStoreConnectAPI.AppScreenshotSetAppScreenshotsLinkagesRequest) -> Request<Void> {
            .patch(path, body: body)
        }
    }
}

extension Paths {
    public static var appScreenshots: AppScreenshots {
        AppScreenshots(path: "/v1/appScreenshots")
    }

    public struct AppScreenshots {
        /// Path: `/v1/appScreenshots`
        public let path: String

        public func post(_ body: AppStoreConnectAPI.AppScreenshotCreateRequest) -> Request<AppStoreConnectAPI.AppScreenshotResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.AppScreenshots {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/appScreenshots/{id}`
        public let path: String

        public func get(fieldsAppScreenshots: [FieldsAppScreenshots]? = nil, include: [Include]? = nil) -> Request<AppStoreConnectAPI.AppScreenshotResponse> {
            .get(path, query: makeGetQuery(fieldsAppScreenshots, include))
        }

        private func makeGetQuery(_ fieldsAppScreenshots: [FieldsAppScreenshots]?, _ include: [Include]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[appScreenshots]", fieldsAppScreenshots?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsAppScreenshots: String, Codable, CaseIterable {
            case appScreenshotSet
            case assetDeliveryState
            case assetToken
            case assetType
            case fileName
            case fileSize
            case imageAsset
            case sourceFileChecksum
            case uploadOperations
            case uploaded
        }

        public enum Include: String, Codable, CaseIterable {
            case appScreenshotSet
        }

        public func patch(_ body: AppStoreConnectAPI.AppScreenshotUpdateRequest) -> Request<AppStoreConnectAPI.AppScreenshotResponse> {
            .patch(path, body: body)
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var appStoreReviewAttachments: AppStoreReviewAttachments {
        AppStoreReviewAttachments(path: "/v1/appStoreReviewAttachments")
    }

    public struct AppStoreReviewAttachments {
        /// Path: `/v1/appStoreReviewAttachments`
        public let path: String

        public func post(_ body: AppStoreConnectAPI.AppStoreReviewAttachmentCreateRequest) -> Request<AppStoreConnectAPI.AppStoreReviewAttachmentResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.AppStoreReviewAttachments {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/appStoreReviewAttachments/{id}`
        public let path: String

        public func get(fieldsAppStoreReviewAttachments: [FieldsAppStoreReviewAttachments]? = nil, include: [Include]? = nil) -> Request<AppStoreConnectAPI.AppStoreReviewAttachmentResponse> {
            .get(path, query: makeGetQuery(fieldsAppStoreReviewAttachments, include))
        }

        private func makeGetQuery(_ fieldsAppStoreReviewAttachments: [FieldsAppStoreReviewAttachments]?, _ include: [Include]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[appStoreReviewAttachments]", fieldsAppStoreReviewAttachments?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsAppStoreReviewAttachments: String, Codable, CaseIterable {
            case appStoreReviewDetail
            case assetDeliveryState
            case fileName
            case fileSize
            case sourceFileChecksum
            case uploadOperations
            case uploaded
        }

        public enum Include: String, Codable, CaseIterable {
            case appStoreReviewDetail
        }

        public func patch(_ body: AppStoreConnectAPI.AppStoreReviewAttachmentUpdateRequest) -> Request<AppStoreConnectAPI.AppStoreReviewAttachmentResponse> {
            .patch(path, body: body)
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var appStoreReviewDetails: AppStoreReviewDetails {
        AppStoreReviewDetails(path: "/v1/appStoreReviewDetails")
    }

    public struct AppStoreReviewDetails {
        /// Path: `/v1/appStoreReviewDetails`
        public let path: String

        public func post(_ body: AppStoreConnectAPI.AppStoreReviewDetailCreateRequest) -> Request<AppStoreConnectAPI.AppStoreReviewDetailResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.AppStoreReviewDetails {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/appStoreReviewDetails/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppStoreReviewDetailResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsAppStoreReviewDetails: [FieldsAppStoreReviewDetails]?
            public var include: [Include]?
            public var fieldsAppStoreReviewAttachments: [FieldsAppStoreReviewAttachments]?
            public var limitAppStoreReviewAttachments: Int?

            public enum FieldsAppStoreReviewDetails: String, Codable, CaseIterable {
                case appStoreReviewAttachments
                case appStoreVersion
                case contactEmail
                case contactFirstName
                case contactLastName
                case contactPhone
                case demoAccountName
                case demoAccountPassword
                case demoAccountRequired
                case notes
            }

            public enum Include: String, Codable, CaseIterable {
                case appStoreReviewAttachments
                case appStoreVersion
            }

            public enum FieldsAppStoreReviewAttachments: String, Codable, CaseIterable {
                case appStoreReviewDetail
                case assetDeliveryState
                case fileName
                case fileSize
                case sourceFileChecksum
                case uploadOperations
                case uploaded
            }

            public init(fieldsAppStoreReviewDetails: [FieldsAppStoreReviewDetails]? = nil, include: [Include]? = nil, fieldsAppStoreReviewAttachments: [FieldsAppStoreReviewAttachments]? = nil, limitAppStoreReviewAttachments: Int? = nil) {
                self.fieldsAppStoreReviewDetails = fieldsAppStoreReviewDetails
                self.include = include
                self.fieldsAppStoreReviewAttachments = fieldsAppStoreReviewAttachments
                self.limitAppStoreReviewAttachments = limitAppStoreReviewAttachments
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[appStoreReviewDetails]", fieldsAppStoreReviewDetails?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appStoreReviewAttachments]", fieldsAppStoreReviewAttachments?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[appStoreReviewAttachments]", limitAppStoreReviewAttachments)
                return query
            }
        }

        public func patch(_ body: AppStoreConnectAPI.AppStoreReviewDetailUpdateRequest) -> Request<AppStoreConnectAPI.AppStoreReviewDetailResponse> {
            .patch(path, body: body)
        }
    }
}

extension Paths.AppStoreReviewDetails.WithID {
    public var appStoreReviewAttachments: AppStoreReviewAttachments {
        AppStoreReviewAttachments(path: path + "/appStoreReviewAttachments")
    }

    public struct AppStoreReviewAttachments {
        /// Path: `/v1/appStoreReviewDetails/{id}/appStoreReviewAttachments`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppStoreReviewAttachmentsResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsAppStoreReviewDetails: [FieldsAppStoreReviewDetails]?
            public var fieldsAppStoreReviewAttachments: [FieldsAppStoreReviewAttachments]?
            public var limit: Int?
            public var include: [Include]?

            public enum FieldsAppStoreReviewDetails: String, Codable, CaseIterable {
                case appStoreReviewAttachments
                case appStoreVersion
                case contactEmail
                case contactFirstName
                case contactLastName
                case contactPhone
                case demoAccountName
                case demoAccountPassword
                case demoAccountRequired
                case notes
            }

            public enum FieldsAppStoreReviewAttachments: String, Codable, CaseIterable {
                case appStoreReviewDetail
                case assetDeliveryState
                case fileName
                case fileSize
                case sourceFileChecksum
                case uploadOperations
                case uploaded
            }

            public enum Include: String, Codable, CaseIterable {
                case appStoreReviewDetail
            }

            public init(fieldsAppStoreReviewDetails: [FieldsAppStoreReviewDetails]? = nil, fieldsAppStoreReviewAttachments: [FieldsAppStoreReviewAttachments]? = nil, limit: Int? = nil, include: [Include]? = nil) {
                self.fieldsAppStoreReviewDetails = fieldsAppStoreReviewDetails
                self.fieldsAppStoreReviewAttachments = fieldsAppStoreReviewAttachments
                self.limit = limit
                self.include = include
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[appStoreReviewDetails]", fieldsAppStoreReviewDetails?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appStoreReviewAttachments]", fieldsAppStoreReviewAttachments?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths {
    public static var appStoreVersionLocalizations: AppStoreVersionLocalizations {
        AppStoreVersionLocalizations(path: "/v1/appStoreVersionLocalizations")
    }

    public struct AppStoreVersionLocalizations {
        /// Path: `/v1/appStoreVersionLocalizations`
        public let path: String

        public func post(_ body: AppStoreConnectAPI.AppStoreVersionLocalizationCreateRequest) -> Request<AppStoreConnectAPI.AppStoreVersionLocalizationResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.AppStoreVersionLocalizations {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/appStoreVersionLocalizations/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppStoreVersionLocalizationResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsAppStoreVersionLocalizations: [FieldsAppStoreVersionLocalizations]?
            public var include: [Include]?
            public var fieldsAppScreenshotSets: [FieldsAppScreenshotSets]?
            public var fieldsAppPreviewSets: [FieldsAppPreviewSets]?
            public var limitAppPreviewSets: Int?
            public var limitAppScreenshotSets: Int?

            public enum FieldsAppStoreVersionLocalizations: String, Codable, CaseIterable {
                case appPreviewSets
                case appScreenshotSets
                case appStoreVersion
                case description
                case keywords
                case locale
                case marketingURL = "marketingUrl"
                case promotionalText
                case supportURL = "supportUrl"
                case whatsNew
            }

            public enum Include: String, Codable, CaseIterable {
                case appPreviewSets
                case appScreenshotSets
                case appStoreVersion
            }

            public enum FieldsAppScreenshotSets: String, Codable, CaseIterable {
                case appScreenshots
                case appStoreVersionLocalization
                case screenshotDisplayType
            }

            public enum FieldsAppPreviewSets: String, Codable, CaseIterable {
                case appPreviews
                case appStoreVersionLocalization
                case previewType
            }

            public init(fieldsAppStoreVersionLocalizations: [FieldsAppStoreVersionLocalizations]? = nil, include: [Include]? = nil, fieldsAppScreenshotSets: [FieldsAppScreenshotSets]? = nil, fieldsAppPreviewSets: [FieldsAppPreviewSets]? = nil, limitAppPreviewSets: Int? = nil, limitAppScreenshotSets: Int? = nil) {
                self.fieldsAppStoreVersionLocalizations = fieldsAppStoreVersionLocalizations
                self.include = include
                self.fieldsAppScreenshotSets = fieldsAppScreenshotSets
                self.fieldsAppPreviewSets = fieldsAppPreviewSets
                self.limitAppPreviewSets = limitAppPreviewSets
                self.limitAppScreenshotSets = limitAppScreenshotSets
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[appStoreVersionLocalizations]", fieldsAppStoreVersionLocalizations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appScreenshotSets]", fieldsAppScreenshotSets?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appPreviewSets]", fieldsAppPreviewSets?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[appPreviewSets]", limitAppPreviewSets)
                query.addQueryItem("limit[appScreenshotSets]", limitAppScreenshotSets)
                return query
            }
        }

        public func patch(_ body: AppStoreConnectAPI.AppStoreVersionLocalizationUpdateRequest) -> Request<AppStoreConnectAPI.AppStoreVersionLocalizationResponse> {
            .patch(path, body: body)
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.AppStoreVersionLocalizations.WithID {
    public var appPreviewSets: AppPreviewSets {
        AppPreviewSets(path: path + "/appPreviewSets")
    }

    public struct AppPreviewSets {
        /// Path: `/v1/appStoreVersionLocalizations/{id}/appPreviewSets`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppPreviewSetsResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterPreviewType: [FilterPreviewType]?
            public var fieldsAppStoreVersionLocalizations: [FieldsAppStoreVersionLocalizations]?
            public var fieldsAppPreviews: [FieldsAppPreviews]?
            public var fieldsAppPreviewSets: [FieldsAppPreviewSets]?
            public var limit: Int?
            public var include: [Include]?

            public enum FilterPreviewType: String, Codable, CaseIterable {
                case iphone65 = "IPHONE_65"
                case iphone58 = "IPHONE_58"
                case iphone55 = "IPHONE_55"
                case iphone47 = "IPHONE_47"
                case iphone40 = "IPHONE_40"
                case iphone35 = "IPHONE_35"
                case ipadPro3gen129 = "IPAD_PRO_3GEN_129"
                case ipadPro3gen11 = "IPAD_PRO_3GEN_11"
                case ipadPro129 = "IPAD_PRO_129"
                case ipad105 = "IPAD_105"
                case ipad97 = "IPAD_97"
                case desktop = "DESKTOP"
                case watchSeries4 = "WATCH_SERIES_4"
                case watchSeries3 = "WATCH_SERIES_3"
                case appleTv = "APPLE_TV"
            }

            public enum FieldsAppStoreVersionLocalizations: String, Codable, CaseIterable {
                case appPreviewSets
                case appScreenshotSets
                case appStoreVersion
                case description
                case keywords
                case locale
                case marketingURL = "marketingUrl"
                case promotionalText
                case supportURL = "supportUrl"
                case whatsNew
            }

            public enum FieldsAppPreviews: String, Codable, CaseIterable {
                case appPreviewSet
                case assetDeliveryState
                case fileName
                case fileSize
                case mimeType
                case previewFrameTimeCode
                case previewImage
                case sourceFileChecksum
                case uploadOperations
                case uploaded
                case videoURL = "videoUrl"
            }

            public enum FieldsAppPreviewSets: String, Codable, CaseIterable {
                case appPreviews
                case appStoreVersionLocalization
                case previewType
            }

            public enum Include: String, Codable, CaseIterable {
                case appPreviews
                case appStoreVersionLocalization
            }

            public init(filterPreviewType: [FilterPreviewType]? = nil, fieldsAppStoreVersionLocalizations: [FieldsAppStoreVersionLocalizations]? = nil, fieldsAppPreviews: [FieldsAppPreviews]? = nil, fieldsAppPreviewSets: [FieldsAppPreviewSets]? = nil, limit: Int? = nil, include: [Include]? = nil) {
                self.filterPreviewType = filterPreviewType
                self.fieldsAppStoreVersionLocalizations = fieldsAppStoreVersionLocalizations
                self.fieldsAppPreviews = fieldsAppPreviews
                self.fieldsAppPreviewSets = fieldsAppPreviewSets
                self.limit = limit
                self.include = include
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[previewType]", filterPreviewType?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appStoreVersionLocalizations]", fieldsAppStoreVersionLocalizations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appPreviews]", fieldsAppPreviews?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appPreviewSets]", fieldsAppPreviewSets?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.AppStoreVersionLocalizations.WithID {
    public var appScreenshotSets: AppScreenshotSets {
        AppScreenshotSets(path: path + "/appScreenshotSets")
    }

    public struct AppScreenshotSets {
        /// Path: `/v1/appStoreVersionLocalizations/{id}/appScreenshotSets`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppScreenshotSetsResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterScreenshotDisplayType: [FilterScreenshotDisplayType]?
            public var fieldsAppStoreVersionLocalizations: [FieldsAppStoreVersionLocalizations]?
            public var fieldsAppScreenshotSets: [FieldsAppScreenshotSets]?
            public var fieldsAppScreenshots: [FieldsAppScreenshots]?
            public var limit: Int?
            public var include: [Include]?

            public enum FilterScreenshotDisplayType: String, Codable, CaseIterable {
                case appIphone65 = "APP_IPHONE_65"
                case appIphone58 = "APP_IPHONE_58"
                case appIphone55 = "APP_IPHONE_55"
                case appIphone47 = "APP_IPHONE_47"
                case appIphone40 = "APP_IPHONE_40"
                case appIphone35 = "APP_IPHONE_35"
                case appIpadPro3gen129 = "APP_IPAD_PRO_3GEN_129"
                case appIpadPro3gen11 = "APP_IPAD_PRO_3GEN_11"
                case appIpadPro129 = "APP_IPAD_PRO_129"
                case appIpad105 = "APP_IPAD_105"
                case appIpad97 = "APP_IPAD_97"
                case appDesktop = "APP_DESKTOP"
                case appWatchSeries4 = "APP_WATCH_SERIES_4"
                case appWatchSeries3 = "APP_WATCH_SERIES_3"
                case appAppleTv = "APP_APPLE_TV"
                case imessageAppIphone65 = "IMESSAGE_APP_IPHONE_65"
                case imessageAppIphone58 = "IMESSAGE_APP_IPHONE_58"
                case imessageAppIphone55 = "IMESSAGE_APP_IPHONE_55"
                case imessageAppIphone47 = "IMESSAGE_APP_IPHONE_47"
                case imessageAppIphone40 = "IMESSAGE_APP_IPHONE_40"
                case imessageAppIpadPro3gen129 = "IMESSAGE_APP_IPAD_PRO_3GEN_129"
                case imessageAppIpadPro3gen11 = "IMESSAGE_APP_IPAD_PRO_3GEN_11"
                case imessageAppIpadPro129 = "IMESSAGE_APP_IPAD_PRO_129"
                case imessageAppIpad105 = "IMESSAGE_APP_IPAD_105"
                case imessageAppIpad97 = "IMESSAGE_APP_IPAD_97"
            }

            public enum FieldsAppStoreVersionLocalizations: String, Codable, CaseIterable {
                case appPreviewSets
                case appScreenshotSets
                case appStoreVersion
                case description
                case keywords
                case locale
                case marketingURL = "marketingUrl"
                case promotionalText
                case supportURL = "supportUrl"
                case whatsNew
            }

            public enum FieldsAppScreenshotSets: String, Codable, CaseIterable {
                case appScreenshots
                case appStoreVersionLocalization
                case screenshotDisplayType
            }

            public enum FieldsAppScreenshots: String, Codable, CaseIterable {
                case appScreenshotSet
                case assetDeliveryState
                case assetToken
                case assetType
                case fileName
                case fileSize
                case imageAsset
                case sourceFileChecksum
                case uploadOperations
                case uploaded
            }

            public enum Include: String, Codable, CaseIterable {
                case appScreenshots
                case appStoreVersionLocalization
            }

            public init(filterScreenshotDisplayType: [FilterScreenshotDisplayType]? = nil, fieldsAppStoreVersionLocalizations: [FieldsAppStoreVersionLocalizations]? = nil, fieldsAppScreenshotSets: [FieldsAppScreenshotSets]? = nil, fieldsAppScreenshots: [FieldsAppScreenshots]? = nil, limit: Int? = nil, include: [Include]? = nil) {
                self.filterScreenshotDisplayType = filterScreenshotDisplayType
                self.fieldsAppStoreVersionLocalizations = fieldsAppStoreVersionLocalizations
                self.fieldsAppScreenshotSets = fieldsAppScreenshotSets
                self.fieldsAppScreenshots = fieldsAppScreenshots
                self.limit = limit
                self.include = include
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[screenshotDisplayType]", filterScreenshotDisplayType?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appStoreVersionLocalizations]", fieldsAppStoreVersionLocalizations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appScreenshotSets]", fieldsAppScreenshotSets?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appScreenshots]", fieldsAppScreenshots?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths {
    public static var appStoreVersionPhasedReleases: AppStoreVersionPhasedReleases {
        AppStoreVersionPhasedReleases(path: "/v1/appStoreVersionPhasedReleases")
    }

    public struct AppStoreVersionPhasedReleases {
        /// Path: `/v1/appStoreVersionPhasedReleases`
        public let path: String

        public func post(_ body: AppStoreConnectAPI.AppStoreVersionPhasedReleaseCreateRequest) -> Request<AppStoreConnectAPI.AppStoreVersionPhasedReleaseResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.AppStoreVersionPhasedReleases {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/appStoreVersionPhasedReleases/{id}`
        public let path: String

        public func patch(_ body: AppStoreConnectAPI.AppStoreVersionPhasedReleaseUpdateRequest) -> Request<AppStoreConnectAPI.AppStoreVersionPhasedReleaseResponse> {
            .patch(path, body: body)
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var appStoreVersionSubmissions: AppStoreVersionSubmissions {
        AppStoreVersionSubmissions(path: "/v1/appStoreVersionSubmissions")
    }

    public struct AppStoreVersionSubmissions {
        /// Path: `/v1/appStoreVersionSubmissions`
        public let path: String

        public func post(_ body: AppStoreConnectAPI.AppStoreVersionSubmissionCreateRequest) -> Request<AppStoreConnectAPI.AppStoreVersionSubmissionResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.AppStoreVersionSubmissions {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/appStoreVersionSubmissions/{id}`
        public let path: String

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var appStoreVersions: AppStoreVersions {
        AppStoreVersions(path: "/v1/appStoreVersions")
    }

    public struct AppStoreVersions {
        /// Path: `/v1/appStoreVersions`
        public let path: String

        public func post(_ body: AppStoreConnectAPI.AppStoreVersionCreateRequest) -> Request<AppStoreConnectAPI.AppStoreVersionResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.AppStoreVersions {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/appStoreVersions/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppStoreVersionResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsAppStoreVersions: [FieldsAppStoreVersions]?
            public var include: [Include]?
            public var fieldsAppStoreVersionLocalizations: [FieldsAppStoreVersionLocalizations]?
            public var fieldsIdfaDeclarations: [FieldsIdfaDeclarations]?
            public var fieldsRoutingAppCoverages: [FieldsRoutingAppCoverages]?
            public var fieldsAppStoreVersionPhasedReleases: [FieldsAppStoreVersionPhasedReleases]?
            public var fieldsAgeRatingDeclarations: [FieldsAgeRatingDeclarations]?
            public var fieldsAppStoreReviewDetails: [FieldsAppStoreReviewDetails]?
            public var fieldsBuilds: [FieldsBuilds]?
            public var fieldsAppStoreVersionSubmissions: [FieldsAppStoreVersionSubmissions]?
            public var limitAppStoreVersionLocalizations: Int?

            public enum FieldsAppStoreVersions: String, Codable, CaseIterable {
                case ageRatingDeclaration
                case app
                case appStoreReviewDetail
                case appStoreState
                case appStoreVersionLocalizations
                case appStoreVersionPhasedRelease
                case appStoreVersionSubmission
                case build
                case copyright
                case createdDate
                case downloadable
                case earliestReleaseDate
                case idfaDeclaration
                case platform
                case releaseType
                case routingAppCoverage
                case usesIdfa
                case versionString
            }

            public enum Include: String, Codable, CaseIterable {
                case ageRatingDeclaration
                case app
                case appStoreReviewDetail
                case appStoreVersionLocalizations
                case appStoreVersionPhasedRelease
                case appStoreVersionSubmission
                case build
                case idfaDeclaration
                case routingAppCoverage
            }

            public enum FieldsAppStoreVersionLocalizations: String, Codable, CaseIterable {
                case appPreviewSets
                case appScreenshotSets
                case appStoreVersion
                case description
                case keywords
                case locale
                case marketingURL = "marketingUrl"
                case promotionalText
                case supportURL = "supportUrl"
                case whatsNew
            }

            public enum FieldsIdfaDeclarations: String, Codable, CaseIterable {
                case appStoreVersion
                case attributesActionWithPreviousAd
                case attributesAppInstallationToPreviousAd
                case honorsLimitedAdTracking
                case servesAds
            }

            public enum FieldsRoutingAppCoverages: String, Codable, CaseIterable {
                case appStoreVersion
                case assetDeliveryState
                case fileName
                case fileSize
                case sourceFileChecksum
                case uploadOperations
                case uploaded
            }

            public enum FieldsAppStoreVersionPhasedReleases: String, Codable, CaseIterable {
                case appStoreVersion
                case currentDayNumber
                case phasedReleaseState
                case startDate
                case totalPauseDuration
            }

            public enum FieldsAgeRatingDeclarations: String, Codable, CaseIterable {
                case alcoholTobaccoOrDrugUseOrReferences
                case gamblingAndContests
                case gamblingSimulated
                case horrorOrFearThemes
                case kidsAgeBand
                case matureOrSuggestiveThemes
                case medicalOrTreatmentInformation
                case profanityOrCrudeHumor
                case sexualContentGraphicAndNudity
                case sexualContentOrNudity
                case unrestrictedWebAccess
                case violenceCartoonOrFantasy
                case violenceRealistic
                case violenceRealisticProlongedGraphicOrSadistic
            }

            public enum FieldsAppStoreReviewDetails: String, Codable, CaseIterable {
                case appStoreReviewAttachments
                case appStoreVersion
                case contactEmail
                case contactFirstName
                case contactLastName
                case contactPhone
                case demoAccountName
                case demoAccountPassword
                case demoAccountRequired
                case notes
            }

            public enum FieldsBuilds: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case betaGroups
                case buildBetaDetail
                case diagnosticSignatures
                case expirationDate
                case expired
                case iconAssetToken
                case icons
                case individualTesters
                case minOsVersion
                case perfPowerMetrics
                case preReleaseVersion
                case processingState
                case uploadedDate
                case usesNonExemptEncryption
                case version
            }

            public enum FieldsAppStoreVersionSubmissions: String, Codable, CaseIterable {
                case appStoreVersion
            }

            public init(fieldsAppStoreVersions: [FieldsAppStoreVersions]? = nil, include: [Include]? = nil, fieldsAppStoreVersionLocalizations: [FieldsAppStoreVersionLocalizations]? = nil, fieldsIdfaDeclarations: [FieldsIdfaDeclarations]? = nil, fieldsRoutingAppCoverages: [FieldsRoutingAppCoverages]? = nil, fieldsAppStoreVersionPhasedReleases: [FieldsAppStoreVersionPhasedReleases]? = nil, fieldsAgeRatingDeclarations: [FieldsAgeRatingDeclarations]? = nil, fieldsAppStoreReviewDetails: [FieldsAppStoreReviewDetails]? = nil, fieldsBuilds: [FieldsBuilds]? = nil, fieldsAppStoreVersionSubmissions: [FieldsAppStoreVersionSubmissions]? = nil, limitAppStoreVersionLocalizations: Int? = nil) {
                self.fieldsAppStoreVersions = fieldsAppStoreVersions
                self.include = include
                self.fieldsAppStoreVersionLocalizations = fieldsAppStoreVersionLocalizations
                self.fieldsIdfaDeclarations = fieldsIdfaDeclarations
                self.fieldsRoutingAppCoverages = fieldsRoutingAppCoverages
                self.fieldsAppStoreVersionPhasedReleases = fieldsAppStoreVersionPhasedReleases
                self.fieldsAgeRatingDeclarations = fieldsAgeRatingDeclarations
                self.fieldsAppStoreReviewDetails = fieldsAppStoreReviewDetails
                self.fieldsBuilds = fieldsBuilds
                self.fieldsAppStoreVersionSubmissions = fieldsAppStoreVersionSubmissions
                self.limitAppStoreVersionLocalizations = limitAppStoreVersionLocalizations
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[appStoreVersions]", fieldsAppStoreVersions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appStoreVersionLocalizations]", fieldsAppStoreVersionLocalizations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[idfaDeclarations]", fieldsIdfaDeclarations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[routingAppCoverages]", fieldsRoutingAppCoverages?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appStoreVersionPhasedReleases]", fieldsAppStoreVersionPhasedReleases?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[ageRatingDeclarations]", fieldsAgeRatingDeclarations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appStoreReviewDetails]", fieldsAppStoreReviewDetails?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appStoreVersionSubmissions]", fieldsAppStoreVersionSubmissions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[appStoreVersionLocalizations]", limitAppStoreVersionLocalizations)
                return query
            }
        }

        public func patch(_ body: AppStoreConnectAPI.AppStoreVersionUpdateRequest) -> Request<AppStoreConnectAPI.AppStoreVersionResponse> {
            .patch(path, body: body)
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.AppStoreVersions.WithID {
    public var ageRatingDeclaration: AgeRatingDeclaration {
        AgeRatingDeclaration(path: path + "/ageRatingDeclaration")
    }

    public struct AgeRatingDeclaration {
        /// Path: `/v1/appStoreVersions/{id}/ageRatingDeclaration`
        public let path: String

        @available(*, deprecated, message: "Deprecated")
        public func get(fieldsAgeRatingDeclarations: [FieldsAgeRatingDeclarations]? = nil) -> Request<AppStoreConnectAPI.AgeRatingDeclarationResponse> {
            .get(path, query: makeGetQuery(fieldsAgeRatingDeclarations))
        }

        private func makeGetQuery(_ fieldsAgeRatingDeclarations: [FieldsAgeRatingDeclarations]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[ageRatingDeclarations]", fieldsAgeRatingDeclarations?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsAgeRatingDeclarations: String, Codable, CaseIterable {
            case alcoholTobaccoOrDrugUseOrReferences
            case gamblingAndContests
            case gamblingSimulated
            case horrorOrFearThemes
            case kidsAgeBand
            case matureOrSuggestiveThemes
            case medicalOrTreatmentInformation
            case profanityOrCrudeHumor
            case sexualContentGraphicAndNudity
            case sexualContentOrNudity
            case unrestrictedWebAccess
            case violenceCartoonOrFantasy
            case violenceRealistic
            case violenceRealisticProlongedGraphicOrSadistic
        }
    }
}

extension Paths.AppStoreVersions.WithID {
    public var appStoreReviewDetail: AppStoreReviewDetail {
        AppStoreReviewDetail(path: path + "/appStoreReviewDetail")
    }

    public struct AppStoreReviewDetail {
        /// Path: `/v1/appStoreVersions/{id}/appStoreReviewDetail`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppStoreReviewDetailResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsAppStoreReviewDetails: [FieldsAppStoreReviewDetails]?
            public var fieldsAppStoreVersions: [FieldsAppStoreVersions]?
            public var fieldsAppStoreReviewAttachments: [FieldsAppStoreReviewAttachments]?
            public var include: [Include]?

            public enum FieldsAppStoreReviewDetails: String, Codable, CaseIterable {
                case appStoreReviewAttachments
                case appStoreVersion
                case contactEmail
                case contactFirstName
                case contactLastName
                case contactPhone
                case demoAccountName
                case demoAccountPassword
                case demoAccountRequired
                case notes
            }

            public enum FieldsAppStoreVersions: String, Codable, CaseIterable {
                case ageRatingDeclaration
                case app
                case appStoreReviewDetail
                case appStoreState
                case appStoreVersionLocalizations
                case appStoreVersionPhasedRelease
                case appStoreVersionSubmission
                case build
                case copyright
                case createdDate
                case downloadable
                case earliestReleaseDate
                case idfaDeclaration
                case platform
                case releaseType
                case routingAppCoverage
                case usesIdfa
                case versionString
            }

            public enum FieldsAppStoreReviewAttachments: String, Codable, CaseIterable {
                case appStoreReviewDetail
                case assetDeliveryState
                case fileName
                case fileSize
                case sourceFileChecksum
                case uploadOperations
                case uploaded
            }

            public enum Include: String, Codable, CaseIterable {
                case appStoreReviewAttachments
                case appStoreVersion
            }

            public init(fieldsAppStoreReviewDetails: [FieldsAppStoreReviewDetails]? = nil, fieldsAppStoreVersions: [FieldsAppStoreVersions]? = nil, fieldsAppStoreReviewAttachments: [FieldsAppStoreReviewAttachments]? = nil, include: [Include]? = nil) {
                self.fieldsAppStoreReviewDetails = fieldsAppStoreReviewDetails
                self.fieldsAppStoreVersions = fieldsAppStoreVersions
                self.fieldsAppStoreReviewAttachments = fieldsAppStoreReviewAttachments
                self.include = include
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[appStoreReviewDetails]", fieldsAppStoreReviewDetails?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appStoreVersions]", fieldsAppStoreVersions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appStoreReviewAttachments]", fieldsAppStoreReviewAttachments?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.AppStoreVersions.WithID {
    public var appStoreVersionLocalizations: AppStoreVersionLocalizations {
        AppStoreVersionLocalizations(path: path + "/appStoreVersionLocalizations")
    }

    public struct AppStoreVersionLocalizations {
        /// Path: `/v1/appStoreVersions/{id}/appStoreVersionLocalizations`
        public let path: String

        public func get(fieldsAppStoreVersionLocalizations: [FieldsAppStoreVersionLocalizations]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.AppStoreVersionLocalizationsResponse> {
            .get(path, query: makeGetQuery(fieldsAppStoreVersionLocalizations, limit))
        }

        private func makeGetQuery(_ fieldsAppStoreVersionLocalizations: [FieldsAppStoreVersionLocalizations]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[appStoreVersionLocalizations]", fieldsAppStoreVersionLocalizations?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsAppStoreVersionLocalizations: String, Codable, CaseIterable {
            case appPreviewSets
            case appScreenshotSets
            case appStoreVersion
            case description
            case keywords
            case locale
            case marketingURL = "marketingUrl"
            case promotionalText
            case supportURL = "supportUrl"
            case whatsNew
        }
    }
}

extension Paths.AppStoreVersions.WithID {
    public var appStoreVersionPhasedRelease: AppStoreVersionPhasedRelease {
        AppStoreVersionPhasedRelease(path: path + "/appStoreVersionPhasedRelease")
    }

    public struct AppStoreVersionPhasedRelease {
        /// Path: `/v1/appStoreVersions/{id}/appStoreVersionPhasedRelease`
        public let path: String

        public func get(fieldsAppStoreVersionPhasedReleases: [FieldsAppStoreVersionPhasedReleases]? = nil) -> Request<AppStoreConnectAPI.AppStoreVersionPhasedReleaseResponse> {
            .get(path, query: makeGetQuery(fieldsAppStoreVersionPhasedReleases))
        }

        private func makeGetQuery(_ fieldsAppStoreVersionPhasedReleases: [FieldsAppStoreVersionPhasedReleases]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[appStoreVersionPhasedReleases]", fieldsAppStoreVersionPhasedReleases?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsAppStoreVersionPhasedReleases: String, Codable, CaseIterable {
            case appStoreVersion
            case currentDayNumber
            case phasedReleaseState
            case startDate
            case totalPauseDuration
        }
    }
}

extension Paths.AppStoreVersions.WithID {
    public var appStoreVersionSubmission: AppStoreVersionSubmission {
        AppStoreVersionSubmission(path: path + "/appStoreVersionSubmission")
    }

    public struct AppStoreVersionSubmission {
        /// Path: `/v1/appStoreVersions/{id}/appStoreVersionSubmission`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppStoreVersionSubmissionResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsAppStoreVersions: [FieldsAppStoreVersions]?
            public var fieldsAppStoreVersionSubmissions: [FieldsAppStoreVersionSubmissions]?
            public var include: [Include]?

            public enum FieldsAppStoreVersions: String, Codable, CaseIterable {
                case ageRatingDeclaration
                case app
                case appStoreReviewDetail
                case appStoreState
                case appStoreVersionLocalizations
                case appStoreVersionPhasedRelease
                case appStoreVersionSubmission
                case build
                case copyright
                case createdDate
                case downloadable
                case earliestReleaseDate
                case idfaDeclaration
                case platform
                case releaseType
                case routingAppCoverage
                case usesIdfa
                case versionString
            }

            public enum FieldsAppStoreVersionSubmissions: String, Codable, CaseIterable {
                case appStoreVersion
            }

            public enum Include: String, Codable, CaseIterable {
                case appStoreVersion
            }

            public init(fieldsAppStoreVersions: [FieldsAppStoreVersions]? = nil, fieldsAppStoreVersionSubmissions: [FieldsAppStoreVersionSubmissions]? = nil, include: [Include]? = nil) {
                self.fieldsAppStoreVersions = fieldsAppStoreVersions
                self.fieldsAppStoreVersionSubmissions = fieldsAppStoreVersionSubmissions
                self.include = include
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[appStoreVersions]", fieldsAppStoreVersions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appStoreVersionSubmissions]", fieldsAppStoreVersionSubmissions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.AppStoreVersions.WithID {
    public var build: Build {
        Build(path: path + "/build")
    }

    public struct Build {
        /// Path: `/v1/appStoreVersions/{id}/build`
        public let path: String

        public func get(fieldsBuilds: [FieldsBuilds]? = nil) -> Request<AppStoreConnectAPI.BuildResponse> {
            .get(path, query: makeGetQuery(fieldsBuilds))
        }

        private func makeGetQuery(_ fieldsBuilds: [FieldsBuilds]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsBuilds: String, Codable, CaseIterable {
            case app
            case appEncryptionDeclaration
            case appStoreVersion
            case betaAppReviewSubmission
            case betaBuildLocalizations
            case betaGroups
            case buildBetaDetail
            case diagnosticSignatures
            case expirationDate
            case expired
            case iconAssetToken
            case icons
            case individualTesters
            case minOsVersion
            case perfPowerMetrics
            case preReleaseVersion
            case processingState
            case uploadedDate
            case usesNonExemptEncryption
            case version
        }
    }
}

extension Paths.AppStoreVersions.WithID {
    public var idfaDeclaration: IdfaDeclaration {
        IdfaDeclaration(path: path + "/idfaDeclaration")
    }

    public struct IdfaDeclaration {
        /// Path: `/v1/appStoreVersions/{id}/idfaDeclaration`
        public let path: String

        public func get(fieldsIdfaDeclarations: [FieldsIdfaDeclarations]? = nil) -> Request<AppStoreConnectAPI.IdfaDeclarationResponse> {
            .get(path, query: makeGetQuery(fieldsIdfaDeclarations))
        }

        private func makeGetQuery(_ fieldsIdfaDeclarations: [FieldsIdfaDeclarations]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[idfaDeclarations]", fieldsIdfaDeclarations?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsIdfaDeclarations: String, Codable, CaseIterable {
            case appStoreVersion
            case attributesActionWithPreviousAd
            case attributesAppInstallationToPreviousAd
            case honorsLimitedAdTracking
            case servesAds
        }
    }
}

extension Paths.AppStoreVersions.WithID {
    public var relationships: Relationships {
        Relationships(path: path + "/relationships")
    }

    public struct Relationships {
        /// Path: `/v1/appStoreVersions/{id}/relationships`
        public let path: String
    }
}

extension Paths.AppStoreVersions.WithID.Relationships {
    public var build: Build {
        Build(path: path + "/build")
    }

    public struct Build {
        /// Path: `/v1/appStoreVersions/{id}/relationships/build`
        public let path: String

        public var get: Request<AppStoreConnectAPI.AppStoreVersionBuildLinkageResponse> {
            .get(path)
        }

        public func patch(_ body: AppStoreConnectAPI.AppStoreVersionBuildLinkageRequest) -> Request<Void> {
            .patch(path, body: body)
        }
    }
}

extension Paths.AppStoreVersions.WithID {
    public var routingAppCoverage: RoutingAppCoverage {
        RoutingAppCoverage(path: path + "/routingAppCoverage")
    }

    public struct RoutingAppCoverage {
        /// Path: `/v1/appStoreVersions/{id}/routingAppCoverage`
        public let path: String

        public func get(fieldsRoutingAppCoverages: [FieldsRoutingAppCoverages]? = nil) -> Request<AppStoreConnectAPI.RoutingAppCoverageResponse> {
            .get(path, query: makeGetQuery(fieldsRoutingAppCoverages))
        }

        private func makeGetQuery(_ fieldsRoutingAppCoverages: [FieldsRoutingAppCoverages]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[routingAppCoverages]", fieldsRoutingAppCoverages?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsRoutingAppCoverages: String, Codable, CaseIterable {
            case appStoreVersion
            case assetDeliveryState
            case fileName
            case fileSize
            case sourceFileChecksum
            case uploadOperations
            case uploaded
        }
    }
}

extension Paths {
    public static var apps: Apps {
        Apps(path: "/v1/apps")
    }

    public struct Apps {
        /// Path: `/v1/apps`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppsResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterAppStoreVersionsAppStoreState: [FilterAppStoreVersionsAppStoreState]?
            public var filterAppStoreVersionsPlatform: [FilterAppStoreVersionsPlatform]?
            public var filterBundleID: [String]?
            public var filterName: [String]?
            public var filterSku: [String]?
            public var filterAppStoreVersions: [String]?
            public var filterID: [String]?
            public var existsGameCenterEnabledVersions: [String]?
            public var sort: [Sort]?
            public var fieldsApps: [FieldsApps]?
            public var limit: Int?
            public var include: [Include]?
            public var fieldsBetaGroups: [FieldsBetaGroups]?
            public var fieldsPerfPowerMetrics: [FieldsPerfPowerMetrics]?
            public var fieldsAppInfos: [FieldsAppInfos]?
            public var fieldsAppPreOrders: [FieldsAppPreOrders]?
            public var fieldsPreReleaseVersions: [FieldsPreReleaseVersions]?
            public var fieldsAppPrices: [FieldsAppPrices]?
            public var fieldsInAppPurchases: [FieldsInAppPurchases]?
            public var fieldsBetaAppReviewDetails: [FieldsBetaAppReviewDetails]?
            public var fieldsTerritories: [FieldsTerritories]?
            public var fieldsGameCenterEnabledVersions: [FieldsGameCenterEnabledVersions]?
            public var fieldsAppStoreVersions: [FieldsAppStoreVersions]?
            public var fieldsBuilds: [FieldsBuilds]?
            public var fieldsBetaAppLocalizations: [FieldsBetaAppLocalizations]?
            public var fieldsBetaLicenseAgreements: [FieldsBetaLicenseAgreements]?
            public var fieldsEndUserLicenseAgreements: [FieldsEndUserLicenseAgreements]?
            public var limitAppInfos: Int?
            public var limitAppStoreVersions: Int?
            public var limitAvailableTerritories: Int?
            public var limitBetaAppLocalizations: Int?
            public var limitBetaGroups: Int?
            public var limitBuilds: Int?
            public var limitGameCenterEnabledVersions: Int?
            public var limitInAppPurchases: Int?
            public var limitPreReleaseVersions: Int?
            public var limitPrices: Int?

            public enum FilterAppStoreVersionsAppStoreState: String, Codable, CaseIterable {
                case developerRemovedFromSale = "DEVELOPER_REMOVED_FROM_SALE"
                case developerRejected = "DEVELOPER_REJECTED"
                case inReview = "IN_REVIEW"
                case invalidBinary = "INVALID_BINARY"
                case metadataRejected = "METADATA_REJECTED"
                case pendingAppleRelease = "PENDING_APPLE_RELEASE"
                case pendingContract = "PENDING_CONTRACT"
                case pendingDeveloperRelease = "PENDING_DEVELOPER_RELEASE"
                case prepareForSubmission = "PREPARE_FOR_SUBMISSION"
                case preorderReadyForSale = "PREORDER_READY_FOR_SALE"
                case processingForAppStore = "PROCESSING_FOR_APP_STORE"
                case readyForSale = "READY_FOR_SALE"
                case rejected = "REJECTED"
                case removedFromSale = "REMOVED_FROM_SALE"
                case waitingForExportCompliance = "WAITING_FOR_EXPORT_COMPLIANCE"
                case waitingForReview = "WAITING_FOR_REVIEW"
                case replacedWithNewVersion = "REPLACED_WITH_NEW_VERSION"
            }

            public enum FilterAppStoreVersionsPlatform: String, Codable, CaseIterable {
                case ios = "IOS"
                case macOs = "MAC_OS"
                case tvOs = "TV_OS"
            }

            public enum Sort: String, Codable, CaseIterable {
                case bundleID = "bundleId"
                case minusbundleID = "-bundleId"
                case name
                case minusname = "-name"
                case sku
                case minussku = "-sku"
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public enum Include: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case builds
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case preOrder
                case preReleaseVersions
                case prices
            }

            public enum FieldsBetaGroups: String, Codable, CaseIterable {
                case app
                case betaTesters
                case builds
                case createdDate
                case feedbackEnabled
                case isInternalGroup
                case name
                case publicLink
                case publicLinkEnabled
                case publicLinkID = "publicLinkId"
                case publicLinkLimit
                case publicLinkLimitEnabled
            }

            public enum FieldsPerfPowerMetrics: String, Codable, CaseIterable {
                case deviceType
                case metricType
                case platform
            }

            public enum FieldsAppInfos: String, Codable, CaseIterable {
                case ageRatingDeclaration
                case app
                case appInfoLocalizations
                case appStoreAgeRating
                case appStoreState
                case brazilAgeRating
                case kidsAgeBand
                case primaryCategory
                case primarySubcategoryOne
                case primarySubcategoryTwo
                case secondaryCategory
                case secondarySubcategoryOne
                case secondarySubcategoryTwo
            }

            public enum FieldsAppPreOrders: String, Codable, CaseIterable {
                case app
                case appReleaseDate
                case preOrderAvailableDate
            }

            public enum FieldsPreReleaseVersions: String, Codable, CaseIterable {
                case app
                case builds
                case platform
                case version
            }

            public enum FieldsAppPrices: String, Codable, CaseIterable {
                case app
                case priceTier
            }

            public enum FieldsInAppPurchases: String, Codable, CaseIterable {
                case apps
                case inAppPurchaseType
                case productID = "productId"
                case referenceName
                case state
            }

            public enum FieldsBetaAppReviewDetails: String, Codable, CaseIterable {
                case app
                case contactEmail
                case contactFirstName
                case contactLastName
                case contactPhone
                case demoAccountName
                case demoAccountPassword
                case demoAccountRequired
                case notes
            }

            public enum FieldsTerritories: String, Codable, CaseIterable {
                case currency
            }

            public enum FieldsGameCenterEnabledVersions: String, Codable, CaseIterable {
                case app
                case compatibleVersions
                case iconAsset
                case platform
                case versionString
            }

            public enum FieldsAppStoreVersions: String, Codable, CaseIterable {
                case ageRatingDeclaration
                case app
                case appStoreReviewDetail
                case appStoreState
                case appStoreVersionLocalizations
                case appStoreVersionPhasedRelease
                case appStoreVersionSubmission
                case build
                case copyright
                case createdDate
                case downloadable
                case earliestReleaseDate
                case idfaDeclaration
                case platform
                case releaseType
                case routingAppCoverage
                case usesIdfa
                case versionString
            }

            public enum FieldsBuilds: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case betaGroups
                case buildBetaDetail
                case diagnosticSignatures
                case expirationDate
                case expired
                case iconAssetToken
                case icons
                case individualTesters
                case minOsVersion
                case perfPowerMetrics
                case preReleaseVersion
                case processingState
                case uploadedDate
                case usesNonExemptEncryption
                case version
            }

            public enum FieldsBetaAppLocalizations: String, Codable, CaseIterable {
                case app
                case description
                case feedbackEmail
                case locale
                case marketingURL = "marketingUrl"
                case privacyPolicyURL = "privacyPolicyUrl"
                case tvOsPrivacyPolicy
            }

            public enum FieldsBetaLicenseAgreements: String, Codable, CaseIterable {
                case agreementText
                case app
            }

            public enum FieldsEndUserLicenseAgreements: String, Codable, CaseIterable {
                case agreementText
                case app
                case territories
            }

            public init(filterAppStoreVersionsAppStoreState: [FilterAppStoreVersionsAppStoreState]? = nil, filterAppStoreVersionsPlatform: [FilterAppStoreVersionsPlatform]? = nil, filterBundleID: [String]? = nil, filterName: [String]? = nil, filterSku: [String]? = nil, filterAppStoreVersions: [String]? = nil, filterID: [String]? = nil, existsGameCenterEnabledVersions: [String]? = nil, sort: [Sort]? = nil, fieldsApps: [FieldsApps]? = nil, limit: Int? = nil, include: [Include]? = nil, fieldsBetaGroups: [FieldsBetaGroups]? = nil, fieldsPerfPowerMetrics: [FieldsPerfPowerMetrics]? = nil, fieldsAppInfos: [FieldsAppInfos]? = nil, fieldsAppPreOrders: [FieldsAppPreOrders]? = nil, fieldsPreReleaseVersions: [FieldsPreReleaseVersions]? = nil, fieldsAppPrices: [FieldsAppPrices]? = nil, fieldsInAppPurchases: [FieldsInAppPurchases]? = nil, fieldsBetaAppReviewDetails: [FieldsBetaAppReviewDetails]? = nil, fieldsTerritories: [FieldsTerritories]? = nil, fieldsGameCenterEnabledVersions: [FieldsGameCenterEnabledVersions]? = nil, fieldsAppStoreVersions: [FieldsAppStoreVersions]? = nil, fieldsBuilds: [FieldsBuilds]? = nil, fieldsBetaAppLocalizations: [FieldsBetaAppLocalizations]? = nil, fieldsBetaLicenseAgreements: [FieldsBetaLicenseAgreements]? = nil, fieldsEndUserLicenseAgreements: [FieldsEndUserLicenseAgreements]? = nil, limitAppInfos: Int? = nil, limitAppStoreVersions: Int? = nil, limitAvailableTerritories: Int? = nil, limitBetaAppLocalizations: Int? = nil, limitBetaGroups: Int? = nil, limitBuilds: Int? = nil, limitGameCenterEnabledVersions: Int? = nil, limitInAppPurchases: Int? = nil, limitPreReleaseVersions: Int? = nil, limitPrices: Int? = nil) {
                self.filterAppStoreVersionsAppStoreState = filterAppStoreVersionsAppStoreState
                self.filterAppStoreVersionsPlatform = filterAppStoreVersionsPlatform
                self.filterBundleID = filterBundleID
                self.filterName = filterName
                self.filterSku = filterSku
                self.filterAppStoreVersions = filterAppStoreVersions
                self.filterID = filterID
                self.existsGameCenterEnabledVersions = existsGameCenterEnabledVersions
                self.sort = sort
                self.fieldsApps = fieldsApps
                self.limit = limit
                self.include = include
                self.fieldsBetaGroups = fieldsBetaGroups
                self.fieldsPerfPowerMetrics = fieldsPerfPowerMetrics
                self.fieldsAppInfos = fieldsAppInfos
                self.fieldsAppPreOrders = fieldsAppPreOrders
                self.fieldsPreReleaseVersions = fieldsPreReleaseVersions
                self.fieldsAppPrices = fieldsAppPrices
                self.fieldsInAppPurchases = fieldsInAppPurchases
                self.fieldsBetaAppReviewDetails = fieldsBetaAppReviewDetails
                self.fieldsTerritories = fieldsTerritories
                self.fieldsGameCenterEnabledVersions = fieldsGameCenterEnabledVersions
                self.fieldsAppStoreVersions = fieldsAppStoreVersions
                self.fieldsBuilds = fieldsBuilds
                self.fieldsBetaAppLocalizations = fieldsBetaAppLocalizations
                self.fieldsBetaLicenseAgreements = fieldsBetaLicenseAgreements
                self.fieldsEndUserLicenseAgreements = fieldsEndUserLicenseAgreements
                self.limitAppInfos = limitAppInfos
                self.limitAppStoreVersions = limitAppStoreVersions
                self.limitAvailableTerritories = limitAvailableTerritories
                self.limitBetaAppLocalizations = limitBetaAppLocalizations
                self.limitBetaGroups = limitBetaGroups
                self.limitBuilds = limitBuilds
                self.limitGameCenterEnabledVersions = limitGameCenterEnabledVersions
                self.limitInAppPurchases = limitInAppPurchases
                self.limitPreReleaseVersions = limitPreReleaseVersions
                self.limitPrices = limitPrices
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[appStoreVersions.appStoreState]", filterAppStoreVersionsAppStoreState?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[appStoreVersions.platform]", filterAppStoreVersionsPlatform?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[bundleId]", filterBundleID?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[name]", filterName?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[sku]", filterSku?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[appStoreVersions]", filterAppStoreVersions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[id]", filterID?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("exists[gameCenterEnabledVersions]", existsGameCenterEnabledVersions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("sort", sort?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaGroups]", fieldsBetaGroups?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[perfPowerMetrics]", fieldsPerfPowerMetrics?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appInfos]", fieldsAppInfos?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appPreOrders]", fieldsAppPreOrders?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[preReleaseVersions]", fieldsPreReleaseVersions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appPrices]", fieldsAppPrices?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[inAppPurchases]", fieldsInAppPurchases?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaAppReviewDetails]", fieldsBetaAppReviewDetails?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[territories]", fieldsTerritories?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[gameCenterEnabledVersions]", fieldsGameCenterEnabledVersions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appStoreVersions]", fieldsAppStoreVersions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaAppLocalizations]", fieldsBetaAppLocalizations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaLicenseAgreements]", fieldsBetaLicenseAgreements?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[endUserLicenseAgreements]", fieldsEndUserLicenseAgreements?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[appInfos]", limitAppInfos)
                query.addQueryItem("limit[appStoreVersions]", limitAppStoreVersions)
                query.addQueryItem("limit[availableTerritories]", limitAvailableTerritories)
                query.addQueryItem("limit[betaAppLocalizations]", limitBetaAppLocalizations)
                query.addQueryItem("limit[betaGroups]", limitBetaGroups)
                query.addQueryItem("limit[builds]", limitBuilds)
                query.addQueryItem("limit[gameCenterEnabledVersions]", limitGameCenterEnabledVersions)
                query.addQueryItem("limit[inAppPurchases]", limitInAppPurchases)
                query.addQueryItem("limit[preReleaseVersions]", limitPreReleaseVersions)
                query.addQueryItem("limit[prices]", limitPrices)
                return query
            }
        }
    }
}

extension Paths.Apps {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/apps/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsApps: [FieldsApps]?
            public var include: [Include]?
            public var fieldsBetaGroups: [FieldsBetaGroups]?
            public var fieldsPerfPowerMetrics: [FieldsPerfPowerMetrics]?
            public var fieldsAppInfos: [FieldsAppInfos]?
            public var fieldsAppPreOrders: [FieldsAppPreOrders]?
            public var fieldsPreReleaseVersions: [FieldsPreReleaseVersions]?
            public var fieldsAppPrices: [FieldsAppPrices]?
            public var fieldsInAppPurchases: [FieldsInAppPurchases]?
            public var fieldsBetaAppReviewDetails: [FieldsBetaAppReviewDetails]?
            public var fieldsTerritories: [FieldsTerritories]?
            public var fieldsGameCenterEnabledVersions: [FieldsGameCenterEnabledVersions]?
            public var fieldsAppStoreVersions: [FieldsAppStoreVersions]?
            public var fieldsBuilds: [FieldsBuilds]?
            public var fieldsBetaAppLocalizations: [FieldsBetaAppLocalizations]?
            public var fieldsBetaLicenseAgreements: [FieldsBetaLicenseAgreements]?
            public var fieldsEndUserLicenseAgreements: [FieldsEndUserLicenseAgreements]?
            public var limitAppInfos: Int?
            public var limitAppStoreVersions: Int?
            public var limitAvailableTerritories: Int?
            public var limitBetaAppLocalizations: Int?
            public var limitBetaGroups: Int?
            public var limitBuilds: Int?
            public var limitGameCenterEnabledVersions: Int?
            public var limitInAppPurchases: Int?
            public var limitPreReleaseVersions: Int?
            public var limitPrices: Int?

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public enum Include: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case builds
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case preOrder
                case preReleaseVersions
                case prices
            }

            public enum FieldsBetaGroups: String, Codable, CaseIterable {
                case app
                case betaTesters
                case builds
                case createdDate
                case feedbackEnabled
                case isInternalGroup
                case name
                case publicLink
                case publicLinkEnabled
                case publicLinkID = "publicLinkId"
                case publicLinkLimit
                case publicLinkLimitEnabled
            }

            public enum FieldsPerfPowerMetrics: String, Codable, CaseIterable {
                case deviceType
                case metricType
                case platform
            }

            public enum FieldsAppInfos: String, Codable, CaseIterable {
                case ageRatingDeclaration
                case app
                case appInfoLocalizations
                case appStoreAgeRating
                case appStoreState
                case brazilAgeRating
                case kidsAgeBand
                case primaryCategory
                case primarySubcategoryOne
                case primarySubcategoryTwo
                case secondaryCategory
                case secondarySubcategoryOne
                case secondarySubcategoryTwo
            }

            public enum FieldsAppPreOrders: String, Codable, CaseIterable {
                case app
                case appReleaseDate
                case preOrderAvailableDate
            }

            public enum FieldsPreReleaseVersions: String, Codable, CaseIterable {
                case app
                case builds
                case platform
                case version
            }

            public enum FieldsAppPrices: String, Codable, CaseIterable {
                case app
                case priceTier
            }

            public enum FieldsInAppPurchases: String, Codable, CaseIterable {
                case apps
                case inAppPurchaseType
                case productID = "productId"
                case referenceName
                case state
            }

            public enum FieldsBetaAppReviewDetails: String, Codable, CaseIterable {
                case app
                case contactEmail
                case contactFirstName
                case contactLastName
                case contactPhone
                case demoAccountName
                case demoAccountPassword
                case demoAccountRequired
                case notes
            }

            public enum FieldsTerritories: String, Codable, CaseIterable {
                case currency
            }

            public enum FieldsGameCenterEnabledVersions: String, Codable, CaseIterable {
                case app
                case compatibleVersions
                case iconAsset
                case platform
                case versionString
            }

            public enum FieldsAppStoreVersions: String, Codable, CaseIterable {
                case ageRatingDeclaration
                case app
                case appStoreReviewDetail
                case appStoreState
                case appStoreVersionLocalizations
                case appStoreVersionPhasedRelease
                case appStoreVersionSubmission
                case build
                case copyright
                case createdDate
                case downloadable
                case earliestReleaseDate
                case idfaDeclaration
                case platform
                case releaseType
                case routingAppCoverage
                case usesIdfa
                case versionString
            }

            public enum FieldsBuilds: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case betaGroups
                case buildBetaDetail
                case diagnosticSignatures
                case expirationDate
                case expired
                case iconAssetToken
                case icons
                case individualTesters
                case minOsVersion
                case perfPowerMetrics
                case preReleaseVersion
                case processingState
                case uploadedDate
                case usesNonExemptEncryption
                case version
            }

            public enum FieldsBetaAppLocalizations: String, Codable, CaseIterable {
                case app
                case description
                case feedbackEmail
                case locale
                case marketingURL = "marketingUrl"
                case privacyPolicyURL = "privacyPolicyUrl"
                case tvOsPrivacyPolicy
            }

            public enum FieldsBetaLicenseAgreements: String, Codable, CaseIterable {
                case agreementText
                case app
            }

            public enum FieldsEndUserLicenseAgreements: String, Codable, CaseIterable {
                case agreementText
                case app
                case territories
            }

            public init(fieldsApps: [FieldsApps]? = nil, include: [Include]? = nil, fieldsBetaGroups: [FieldsBetaGroups]? = nil, fieldsPerfPowerMetrics: [FieldsPerfPowerMetrics]? = nil, fieldsAppInfos: [FieldsAppInfos]? = nil, fieldsAppPreOrders: [FieldsAppPreOrders]? = nil, fieldsPreReleaseVersions: [FieldsPreReleaseVersions]? = nil, fieldsAppPrices: [FieldsAppPrices]? = nil, fieldsInAppPurchases: [FieldsInAppPurchases]? = nil, fieldsBetaAppReviewDetails: [FieldsBetaAppReviewDetails]? = nil, fieldsTerritories: [FieldsTerritories]? = nil, fieldsGameCenterEnabledVersions: [FieldsGameCenterEnabledVersions]? = nil, fieldsAppStoreVersions: [FieldsAppStoreVersions]? = nil, fieldsBuilds: [FieldsBuilds]? = nil, fieldsBetaAppLocalizations: [FieldsBetaAppLocalizations]? = nil, fieldsBetaLicenseAgreements: [FieldsBetaLicenseAgreements]? = nil, fieldsEndUserLicenseAgreements: [FieldsEndUserLicenseAgreements]? = nil, limitAppInfos: Int? = nil, limitAppStoreVersions: Int? = nil, limitAvailableTerritories: Int? = nil, limitBetaAppLocalizations: Int? = nil, limitBetaGroups: Int? = nil, limitBuilds: Int? = nil, limitGameCenterEnabledVersions: Int? = nil, limitInAppPurchases: Int? = nil, limitPreReleaseVersions: Int? = nil, limitPrices: Int? = nil) {
                self.fieldsApps = fieldsApps
                self.include = include
                self.fieldsBetaGroups = fieldsBetaGroups
                self.fieldsPerfPowerMetrics = fieldsPerfPowerMetrics
                self.fieldsAppInfos = fieldsAppInfos
                self.fieldsAppPreOrders = fieldsAppPreOrders
                self.fieldsPreReleaseVersions = fieldsPreReleaseVersions
                self.fieldsAppPrices = fieldsAppPrices
                self.fieldsInAppPurchases = fieldsInAppPurchases
                self.fieldsBetaAppReviewDetails = fieldsBetaAppReviewDetails
                self.fieldsTerritories = fieldsTerritories
                self.fieldsGameCenterEnabledVersions = fieldsGameCenterEnabledVersions
                self.fieldsAppStoreVersions = fieldsAppStoreVersions
                self.fieldsBuilds = fieldsBuilds
                self.fieldsBetaAppLocalizations = fieldsBetaAppLocalizations
                self.fieldsBetaLicenseAgreements = fieldsBetaLicenseAgreements
                self.fieldsEndUserLicenseAgreements = fieldsEndUserLicenseAgreements
                self.limitAppInfos = limitAppInfos
                self.limitAppStoreVersions = limitAppStoreVersions
                self.limitAvailableTerritories = limitAvailableTerritories
                self.limitBetaAppLocalizations = limitBetaAppLocalizations
                self.limitBetaGroups = limitBetaGroups
                self.limitBuilds = limitBuilds
                self.limitGameCenterEnabledVersions = limitGameCenterEnabledVersions
                self.limitInAppPurchases = limitInAppPurchases
                self.limitPreReleaseVersions = limitPreReleaseVersions
                self.limitPrices = limitPrices
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaGroups]", fieldsBetaGroups?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[perfPowerMetrics]", fieldsPerfPowerMetrics?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appInfos]", fieldsAppInfos?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appPreOrders]", fieldsAppPreOrders?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[preReleaseVersions]", fieldsPreReleaseVersions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appPrices]", fieldsAppPrices?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[inAppPurchases]", fieldsInAppPurchases?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaAppReviewDetails]", fieldsBetaAppReviewDetails?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[territories]", fieldsTerritories?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[gameCenterEnabledVersions]", fieldsGameCenterEnabledVersions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appStoreVersions]", fieldsAppStoreVersions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaAppLocalizations]", fieldsBetaAppLocalizations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaLicenseAgreements]", fieldsBetaLicenseAgreements?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[endUserLicenseAgreements]", fieldsEndUserLicenseAgreements?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[appInfos]", limitAppInfos)
                query.addQueryItem("limit[appStoreVersions]", limitAppStoreVersions)
                query.addQueryItem("limit[availableTerritories]", limitAvailableTerritories)
                query.addQueryItem("limit[betaAppLocalizations]", limitBetaAppLocalizations)
                query.addQueryItem("limit[betaGroups]", limitBetaGroups)
                query.addQueryItem("limit[builds]", limitBuilds)
                query.addQueryItem("limit[gameCenterEnabledVersions]", limitGameCenterEnabledVersions)
                query.addQueryItem("limit[inAppPurchases]", limitInAppPurchases)
                query.addQueryItem("limit[preReleaseVersions]", limitPreReleaseVersions)
                query.addQueryItem("limit[prices]", limitPrices)
                return query
            }
        }

        public func patch(_ body: AppStoreConnectAPI.AppUpdateRequest) -> Request<AppStoreConnectAPI.AppResponse> {
            .patch(path, body: body)
        }
    }
}

extension Paths.Apps.WithID {
    public var appInfos: AppInfos {
        AppInfos(path: path + "/appInfos")
    }

    public struct AppInfos {
        /// Path: `/v1/apps/{id}/appInfos`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppInfosResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsAgeRatingDeclarations: [FieldsAgeRatingDeclarations]?
            public var fieldsAppInfos: [FieldsAppInfos]?
            public var fieldsAppCategories: [FieldsAppCategories]?
            public var fieldsAppInfoLocalizations: [FieldsAppInfoLocalizations]?
            public var fieldsApps: [FieldsApps]?
            public var limit: Int?
            public var include: [Include]?

            public enum FieldsAgeRatingDeclarations: String, Codable, CaseIterable {
                case alcoholTobaccoOrDrugUseOrReferences
                case contests
                case gambling
                case gamblingAndContests
                case gamblingSimulated
                case horrorOrFearThemes
                case kidsAgeBand
                case matureOrSuggestiveThemes
                case medicalOrTreatmentInformation
                case profanityOrCrudeHumor
                case seventeenPlus
                case sexualContentGraphicAndNudity
                case sexualContentOrNudity
                case unrestrictedWebAccess
                case violenceCartoonOrFantasy
                case violenceRealistic
                case violenceRealisticProlongedGraphicOrSadistic
            }

            public enum FieldsAppInfos: String, Codable, CaseIterable {
                case ageRatingDeclaration
                case app
                case appInfoLocalizations
                case appStoreAgeRating
                case appStoreState
                case brazilAgeRating
                case kidsAgeBand
                case primaryCategory
                case primarySubcategoryOne
                case primarySubcategoryTwo
                case secondaryCategory
                case secondarySubcategoryOne
                case secondarySubcategoryTwo
            }

            public enum FieldsAppCategories: String, Codable, CaseIterable {
                case parent
                case platforms
                case subcategories
            }

            public enum FieldsAppInfoLocalizations: String, Codable, CaseIterable {
                case appInfo
                case locale
                case name
                case privacyPolicyText
                case privacyPolicyURL = "privacyPolicyUrl"
                case subtitle
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public enum Include: String, Codable, CaseIterable {
                case app
                case appInfoLocalizations
                case primaryCategory
                case primarySubcategoryOne
                case primarySubcategoryTwo
                case secondaryCategory
                case secondarySubcategoryOne
                case secondarySubcategoryTwo
            }

            public init(fieldsAgeRatingDeclarations: [FieldsAgeRatingDeclarations]? = nil, fieldsAppInfos: [FieldsAppInfos]? = nil, fieldsAppCategories: [FieldsAppCategories]? = nil, fieldsAppInfoLocalizations: [FieldsAppInfoLocalizations]? = nil, fieldsApps: [FieldsApps]? = nil, limit: Int? = nil, include: [Include]? = nil) {
                self.fieldsAgeRatingDeclarations = fieldsAgeRatingDeclarations
                self.fieldsAppInfos = fieldsAppInfos
                self.fieldsAppCategories = fieldsAppCategories
                self.fieldsAppInfoLocalizations = fieldsAppInfoLocalizations
                self.fieldsApps = fieldsApps
                self.limit = limit
                self.include = include
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[ageRatingDeclarations]", fieldsAgeRatingDeclarations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appInfos]", fieldsAppInfos?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appCategories]", fieldsAppCategories?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appInfoLocalizations]", fieldsAppInfoLocalizations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.Apps.WithID {
    public var appStoreVersions: AppStoreVersions {
        AppStoreVersions(path: path + "/appStoreVersions")
    }

    public struct AppStoreVersions {
        /// Path: `/v1/apps/{id}/appStoreVersions`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppStoreVersionsResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterAppStoreState: [FilterAppStoreState]?
            public var filterPlatform: [FilterPlatform]?
            public var filterVersionString: [String]?
            public var filterID: [String]?
            public var fieldsIdfaDeclarations: [FieldsIdfaDeclarations]?
            public var fieldsAppStoreVersionLocalizations: [FieldsAppStoreVersionLocalizations]?
            public var fieldsRoutingAppCoverages: [FieldsRoutingAppCoverages]?
            public var fieldsAppStoreVersionPhasedReleases: [FieldsAppStoreVersionPhasedReleases]?
            public var fieldsAgeRatingDeclarations: [FieldsAgeRatingDeclarations]?
            public var fieldsAppStoreReviewDetails: [FieldsAppStoreReviewDetails]?
            public var fieldsAppStoreVersions: [FieldsAppStoreVersions]?
            public var fieldsBuilds: [FieldsBuilds]?
            public var fieldsAppStoreVersionSubmissions: [FieldsAppStoreVersionSubmissions]?
            public var fieldsApps: [FieldsApps]?
            public var limit: Int?
            public var include: [Include]?

            public enum FilterAppStoreState: String, Codable, CaseIterable {
                case developerRemovedFromSale = "DEVELOPER_REMOVED_FROM_SALE"
                case developerRejected = "DEVELOPER_REJECTED"
                case inReview = "IN_REVIEW"
                case invalidBinary = "INVALID_BINARY"
                case metadataRejected = "METADATA_REJECTED"
                case pendingAppleRelease = "PENDING_APPLE_RELEASE"
                case pendingContract = "PENDING_CONTRACT"
                case pendingDeveloperRelease = "PENDING_DEVELOPER_RELEASE"
                case prepareForSubmission = "PREPARE_FOR_SUBMISSION"
                case preorderReadyForSale = "PREORDER_READY_FOR_SALE"
                case processingForAppStore = "PROCESSING_FOR_APP_STORE"
                case readyForSale = "READY_FOR_SALE"
                case rejected = "REJECTED"
                case removedFromSale = "REMOVED_FROM_SALE"
                case waitingForExportCompliance = "WAITING_FOR_EXPORT_COMPLIANCE"
                case waitingForReview = "WAITING_FOR_REVIEW"
                case replacedWithNewVersion = "REPLACED_WITH_NEW_VERSION"
            }

            public enum FilterPlatform: String, Codable, CaseIterable {
                case ios = "IOS"
                case macOs = "MAC_OS"
                case tvOs = "TV_OS"
            }

            public enum FieldsIdfaDeclarations: String, Codable, CaseIterable {
                case appStoreVersion
                case attributesActionWithPreviousAd
                case attributesAppInstallationToPreviousAd
                case honorsLimitedAdTracking
                case servesAds
            }

            public enum FieldsAppStoreVersionLocalizations: String, Codable, CaseIterable {
                case appPreviewSets
                case appScreenshotSets
                case appStoreVersion
                case description
                case keywords
                case locale
                case marketingURL = "marketingUrl"
                case promotionalText
                case supportURL = "supportUrl"
                case whatsNew
            }

            public enum FieldsRoutingAppCoverages: String, Codable, CaseIterable {
                case appStoreVersion
                case assetDeliveryState
                case fileName
                case fileSize
                case sourceFileChecksum
                case uploadOperations
                case uploaded
            }

            public enum FieldsAppStoreVersionPhasedReleases: String, Codable, CaseIterable {
                case appStoreVersion
                case currentDayNumber
                case phasedReleaseState
                case startDate
                case totalPauseDuration
            }

            public enum FieldsAgeRatingDeclarations: String, Codable, CaseIterable {
                case alcoholTobaccoOrDrugUseOrReferences
                case gamblingAndContests
                case gamblingSimulated
                case horrorOrFearThemes
                case kidsAgeBand
                case matureOrSuggestiveThemes
                case medicalOrTreatmentInformation
                case profanityOrCrudeHumor
                case sexualContentGraphicAndNudity
                case sexualContentOrNudity
                case unrestrictedWebAccess
                case violenceCartoonOrFantasy
                case violenceRealistic
                case violenceRealisticProlongedGraphicOrSadistic
            }

            public enum FieldsAppStoreReviewDetails: String, Codable, CaseIterable {
                case appStoreReviewAttachments
                case appStoreVersion
                case contactEmail
                case contactFirstName
                case contactLastName
                case contactPhone
                case demoAccountName
                case demoAccountPassword
                case demoAccountRequired
                case notes
            }

            public enum FieldsAppStoreVersions: String, Codable, CaseIterable {
                case ageRatingDeclaration
                case app
                case appStoreReviewDetail
                case appStoreState
                case appStoreVersionLocalizations
                case appStoreVersionPhasedRelease
                case appStoreVersionSubmission
                case build
                case copyright
                case createdDate
                case downloadable
                case earliestReleaseDate
                case idfaDeclaration
                case platform
                case releaseType
                case routingAppCoverage
                case usesIdfa
                case versionString
            }

            public enum FieldsBuilds: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case betaGroups
                case buildBetaDetail
                case diagnosticSignatures
                case expirationDate
                case expired
                case iconAssetToken
                case icons
                case individualTesters
                case minOsVersion
                case perfPowerMetrics
                case preReleaseVersion
                case processingState
                case uploadedDate
                case usesNonExemptEncryption
                case version
            }

            public enum FieldsAppStoreVersionSubmissions: String, Codable, CaseIterable {
                case appStoreVersion
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public enum Include: String, Codable, CaseIterable {
                case ageRatingDeclaration
                case app
                case appStoreReviewDetail
                case appStoreVersionLocalizations
                case appStoreVersionPhasedRelease
                case appStoreVersionSubmission
                case build
                case idfaDeclaration
                case routingAppCoverage
            }

            public init(filterAppStoreState: [FilterAppStoreState]? = nil, filterPlatform: [FilterPlatform]? = nil, filterVersionString: [String]? = nil, filterID: [String]? = nil, fieldsIdfaDeclarations: [FieldsIdfaDeclarations]? = nil, fieldsAppStoreVersionLocalizations: [FieldsAppStoreVersionLocalizations]? = nil, fieldsRoutingAppCoverages: [FieldsRoutingAppCoverages]? = nil, fieldsAppStoreVersionPhasedReleases: [FieldsAppStoreVersionPhasedReleases]? = nil, fieldsAgeRatingDeclarations: [FieldsAgeRatingDeclarations]? = nil, fieldsAppStoreReviewDetails: [FieldsAppStoreReviewDetails]? = nil, fieldsAppStoreVersions: [FieldsAppStoreVersions]? = nil, fieldsBuilds: [FieldsBuilds]? = nil, fieldsAppStoreVersionSubmissions: [FieldsAppStoreVersionSubmissions]? = nil, fieldsApps: [FieldsApps]? = nil, limit: Int? = nil, include: [Include]? = nil) {
                self.filterAppStoreState = filterAppStoreState
                self.filterPlatform = filterPlatform
                self.filterVersionString = filterVersionString
                self.filterID = filterID
                self.fieldsIdfaDeclarations = fieldsIdfaDeclarations
                self.fieldsAppStoreVersionLocalizations = fieldsAppStoreVersionLocalizations
                self.fieldsRoutingAppCoverages = fieldsRoutingAppCoverages
                self.fieldsAppStoreVersionPhasedReleases = fieldsAppStoreVersionPhasedReleases
                self.fieldsAgeRatingDeclarations = fieldsAgeRatingDeclarations
                self.fieldsAppStoreReviewDetails = fieldsAppStoreReviewDetails
                self.fieldsAppStoreVersions = fieldsAppStoreVersions
                self.fieldsBuilds = fieldsBuilds
                self.fieldsAppStoreVersionSubmissions = fieldsAppStoreVersionSubmissions
                self.fieldsApps = fieldsApps
                self.limit = limit
                self.include = include
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[appStoreState]", filterAppStoreState?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[platform]", filterPlatform?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[versionString]", filterVersionString?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[id]", filterID?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[idfaDeclarations]", fieldsIdfaDeclarations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appStoreVersionLocalizations]", fieldsAppStoreVersionLocalizations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[routingAppCoverages]", fieldsRoutingAppCoverages?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appStoreVersionPhasedReleases]", fieldsAppStoreVersionPhasedReleases?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[ageRatingDeclarations]", fieldsAgeRatingDeclarations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appStoreReviewDetails]", fieldsAppStoreReviewDetails?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appStoreVersions]", fieldsAppStoreVersions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appStoreVersionSubmissions]", fieldsAppStoreVersionSubmissions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.Apps.WithID {
    public var availableTerritories: AvailableTerritories {
        AvailableTerritories(path: path + "/availableTerritories")
    }

    public struct AvailableTerritories {
        /// Path: `/v1/apps/{id}/availableTerritories`
        public let path: String

        public func get(fieldsTerritories: [FieldsTerritories]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.TerritoriesResponse> {
            .get(path, query: makeGetQuery(fieldsTerritories, limit))
        }

        private func makeGetQuery(_ fieldsTerritories: [FieldsTerritories]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[territories]", fieldsTerritories?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsTerritories: String, Codable, CaseIterable {
            case currency
        }
    }
}

extension Paths.Apps.WithID {
    public var betaAppLocalizations: BetaAppLocalizations {
        BetaAppLocalizations(path: path + "/betaAppLocalizations")
    }

    public struct BetaAppLocalizations {
        /// Path: `/v1/apps/{id}/betaAppLocalizations`
        public let path: String

        public func get(fieldsBetaAppLocalizations: [FieldsBetaAppLocalizations]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.BetaAppLocalizationsResponse> {
            .get(path, query: makeGetQuery(fieldsBetaAppLocalizations, limit))
        }

        private func makeGetQuery(_ fieldsBetaAppLocalizations: [FieldsBetaAppLocalizations]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[betaAppLocalizations]", fieldsBetaAppLocalizations?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsBetaAppLocalizations: String, Codable, CaseIterable {
            case app
            case description
            case feedbackEmail
            case locale
            case marketingURL = "marketingUrl"
            case privacyPolicyURL = "privacyPolicyUrl"
            case tvOsPrivacyPolicy
        }
    }
}

extension Paths.Apps.WithID {
    public var betaAppReviewDetail: BetaAppReviewDetail {
        BetaAppReviewDetail(path: path + "/betaAppReviewDetail")
    }

    public struct BetaAppReviewDetail {
        /// Path: `/v1/apps/{id}/betaAppReviewDetail`
        public let path: String

        public func get(fieldsBetaAppReviewDetails: [FieldsBetaAppReviewDetails]? = nil) -> Request<AppStoreConnectAPI.BetaAppReviewDetailResponse> {
            .get(path, query: makeGetQuery(fieldsBetaAppReviewDetails))
        }

        private func makeGetQuery(_ fieldsBetaAppReviewDetails: [FieldsBetaAppReviewDetails]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[betaAppReviewDetails]", fieldsBetaAppReviewDetails?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsBetaAppReviewDetails: String, Codable, CaseIterable {
            case app
            case contactEmail
            case contactFirstName
            case contactLastName
            case contactPhone
            case demoAccountName
            case demoAccountPassword
            case demoAccountRequired
            case notes
        }
    }
}

extension Paths.Apps.WithID {
    public var betaGroups: BetaGroups {
        BetaGroups(path: path + "/betaGroups")
    }

    public struct BetaGroups {
        /// Path: `/v1/apps/{id}/betaGroups`
        public let path: String

        public func get(fieldsBetaGroups: [FieldsBetaGroups]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.BetaGroupsResponse> {
            .get(path, query: makeGetQuery(fieldsBetaGroups, limit))
        }

        private func makeGetQuery(_ fieldsBetaGroups: [FieldsBetaGroups]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[betaGroups]", fieldsBetaGroups?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsBetaGroups: String, Codable, CaseIterable {
            case app
            case betaTesters
            case builds
            case createdDate
            case feedbackEnabled
            case isInternalGroup
            case name
            case publicLink
            case publicLinkEnabled
            case publicLinkID = "publicLinkId"
            case publicLinkLimit
            case publicLinkLimitEnabled
        }
    }
}

extension Paths.Apps.WithID {
    public var betaLicenseAgreement: BetaLicenseAgreement {
        BetaLicenseAgreement(path: path + "/betaLicenseAgreement")
    }

    public struct BetaLicenseAgreement {
        /// Path: `/v1/apps/{id}/betaLicenseAgreement`
        public let path: String

        public func get(fieldsBetaLicenseAgreements: [FieldsBetaLicenseAgreements]? = nil) -> Request<AppStoreConnectAPI.BetaLicenseAgreementResponse> {
            .get(path, query: makeGetQuery(fieldsBetaLicenseAgreements))
        }

        private func makeGetQuery(_ fieldsBetaLicenseAgreements: [FieldsBetaLicenseAgreements]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[betaLicenseAgreements]", fieldsBetaLicenseAgreements?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsBetaLicenseAgreements: String, Codable, CaseIterable {
            case agreementText
            case app
        }
    }
}

extension Paths.Apps.WithID {
    public var builds: Builds {
        Builds(path: path + "/builds")
    }

    public struct Builds {
        /// Path: `/v1/apps/{id}/builds`
        public let path: String

        public func get(fieldsBuilds: [FieldsBuilds]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.BuildsResponse> {
            .get(path, query: makeGetQuery(fieldsBuilds, limit))
        }

        private func makeGetQuery(_ fieldsBuilds: [FieldsBuilds]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsBuilds: String, Codable, CaseIterable {
            case app
            case appEncryptionDeclaration
            case appStoreVersion
            case betaAppReviewSubmission
            case betaBuildLocalizations
            case betaGroups
            case buildBetaDetail
            case diagnosticSignatures
            case expirationDate
            case expired
            case iconAssetToken
            case icons
            case individualTesters
            case minOsVersion
            case perfPowerMetrics
            case preReleaseVersion
            case processingState
            case uploadedDate
            case usesNonExemptEncryption
            case version
        }
    }
}

extension Paths.Apps.WithID {
    public var endUserLicenseAgreement: EndUserLicenseAgreement {
        EndUserLicenseAgreement(path: path + "/endUserLicenseAgreement")
    }

    public struct EndUserLicenseAgreement {
        /// Path: `/v1/apps/{id}/endUserLicenseAgreement`
        public let path: String

        public func get(fieldsEndUserLicenseAgreements: [FieldsEndUserLicenseAgreements]? = nil) -> Request<AppStoreConnectAPI.EndUserLicenseAgreementResponse> {
            .get(path, query: makeGetQuery(fieldsEndUserLicenseAgreements))
        }

        private func makeGetQuery(_ fieldsEndUserLicenseAgreements: [FieldsEndUserLicenseAgreements]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[endUserLicenseAgreements]", fieldsEndUserLicenseAgreements?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsEndUserLicenseAgreements: String, Codable, CaseIterable {
            case agreementText
            case app
            case territories
        }
    }
}

extension Paths.Apps.WithID {
    public var gameCenterEnabledVersions: GameCenterEnabledVersions {
        GameCenterEnabledVersions(path: path + "/gameCenterEnabledVersions")
    }

    public struct GameCenterEnabledVersions {
        /// Path: `/v1/apps/{id}/gameCenterEnabledVersions`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.GameCenterEnabledVersionsResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterPlatform: [FilterPlatform]?
            public var filterVersionString: [String]?
            public var filterID: [String]?
            public var sort: [Sort]?
            public var fieldsGameCenterEnabledVersions: [FieldsGameCenterEnabledVersions]?
            public var fieldsApps: [FieldsApps]?
            public var limit: Int?
            public var include: [Include]?

            public enum FilterPlatform: String, Codable, CaseIterable {
                case ios = "IOS"
                case macOs = "MAC_OS"
                case tvOs = "TV_OS"
            }

            public enum Sort: String, Codable, CaseIterable {
                case versionString
                case minusversionString = "-versionString"
            }

            public enum FieldsGameCenterEnabledVersions: String, Codable, CaseIterable {
                case app
                case compatibleVersions
                case iconAsset
                case platform
                case versionString
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public enum Include: String, Codable, CaseIterable {
                case app
                case compatibleVersions
            }

            public init(filterPlatform: [FilterPlatform]? = nil, filterVersionString: [String]? = nil, filterID: [String]? = nil, sort: [Sort]? = nil, fieldsGameCenterEnabledVersions: [FieldsGameCenterEnabledVersions]? = nil, fieldsApps: [FieldsApps]? = nil, limit: Int? = nil, include: [Include]? = nil) {
                self.filterPlatform = filterPlatform
                self.filterVersionString = filterVersionString
                self.filterID = filterID
                self.sort = sort
                self.fieldsGameCenterEnabledVersions = fieldsGameCenterEnabledVersions
                self.fieldsApps = fieldsApps
                self.limit = limit
                self.include = include
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[platform]", filterPlatform?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[versionString]", filterVersionString?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[id]", filterID?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("sort", sort?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[gameCenterEnabledVersions]", fieldsGameCenterEnabledVersions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.Apps.WithID {
    public var inAppPurchases: InAppPurchases {
        InAppPurchases(path: path + "/inAppPurchases")
    }

    public struct InAppPurchases {
        /// Path: `/v1/apps/{id}/inAppPurchases`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.InAppPurchasesResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterInAppPurchaseType: [FilterInAppPurchaseType]?
            public var filterCanBeSubmitted: [String]?
            public var sort: [Sort]?
            public var fieldsInAppPurchases: [FieldsInAppPurchases]?
            public var fieldsApps: [FieldsApps]?
            public var limit: Int?
            public var include: [Include]?

            public enum FilterInAppPurchaseType: String, Codable, CaseIterable {
                case automaticallyRenewableSubscription = "AUTOMATICALLY_RENEWABLE_SUBSCRIPTION"
                case nonConsumable = "NON_CONSUMABLE"
                case consumable = "CONSUMABLE"
                case nonRenewingSubscription = "NON_RENEWING_SUBSCRIPTION"
                case freeSubscription = "FREE_SUBSCRIPTION"
            }

            public enum Sort: String, Codable, CaseIterable {
                case inAppPurchaseType
                case minusinAppPurchaseType = "-inAppPurchaseType"
                case productID = "productId"
                case minusproductID = "-productId"
                case referenceName
                case minusreferenceName = "-referenceName"
            }

            public enum FieldsInAppPurchases: String, Codable, CaseIterable {
                case apps
                case inAppPurchaseType
                case productID = "productId"
                case referenceName
                case state
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public enum Include: String, Codable, CaseIterable {
                case apps
            }

            public init(filterInAppPurchaseType: [FilterInAppPurchaseType]? = nil, filterCanBeSubmitted: [String]? = nil, sort: [Sort]? = nil, fieldsInAppPurchases: [FieldsInAppPurchases]? = nil, fieldsApps: [FieldsApps]? = nil, limit: Int? = nil, include: [Include]? = nil) {
                self.filterInAppPurchaseType = filterInAppPurchaseType
                self.filterCanBeSubmitted = filterCanBeSubmitted
                self.sort = sort
                self.fieldsInAppPurchases = fieldsInAppPurchases
                self.fieldsApps = fieldsApps
                self.limit = limit
                self.include = include
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[inAppPurchaseType]", filterInAppPurchaseType?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[canBeSubmitted]", filterCanBeSubmitted?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("sort", sort?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[inAppPurchases]", fieldsInAppPurchases?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.Apps.WithID {
    public var perfPowerMetrics: PerfPowerMetrics {
        PerfPowerMetrics(path: path + "/perfPowerMetrics")
    }

    public struct PerfPowerMetrics {
        /// Path: `/v1/apps/{id}/perfPowerMetrics`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.PerfPowerMetricsResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterDeviceType: [String]?
            public var filterMetricType: [FilterMetricType]?
            public var filterPlatform: [FilterPlatform]?

            public enum FilterMetricType: String, Codable, CaseIterable {
                case disk = "DISK"
                case hang = "HANG"
                case battery = "BATTERY"
                case launch = "LAUNCH"
                case memory = "MEMORY"
                case animation = "ANIMATION"
                case termination = "TERMINATION"
            }

            public enum FilterPlatform: String, Codable, CaseIterable {
                case ios = "IOS"
            }

            public init(filterDeviceType: [String]? = nil, filterMetricType: [FilterMetricType]? = nil, filterPlatform: [FilterPlatform]? = nil) {
                self.filterDeviceType = filterDeviceType
                self.filterMetricType = filterMetricType
                self.filterPlatform = filterPlatform
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[deviceType]", filterDeviceType?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[metricType]", filterMetricType?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[platform]", filterPlatform?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.Apps.WithID {
    public var preOrder: PreOrder {
        PreOrder(path: path + "/preOrder")
    }

    public struct PreOrder {
        /// Path: `/v1/apps/{id}/preOrder`
        public let path: String

        public func get(fieldsAppPreOrders: [FieldsAppPreOrders]? = nil) -> Request<AppStoreConnectAPI.AppPreOrderResponse> {
            .get(path, query: makeGetQuery(fieldsAppPreOrders))
        }

        private func makeGetQuery(_ fieldsAppPreOrders: [FieldsAppPreOrders]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[appPreOrders]", fieldsAppPreOrders?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsAppPreOrders: String, Codable, CaseIterable {
            case app
            case appReleaseDate
            case preOrderAvailableDate
        }
    }
}

extension Paths.Apps.WithID {
    public var preReleaseVersions: PreReleaseVersions {
        PreReleaseVersions(path: path + "/preReleaseVersions")
    }

    public struct PreReleaseVersions {
        /// Path: `/v1/apps/{id}/preReleaseVersions`
        public let path: String

        public func get(fieldsPreReleaseVersions: [FieldsPreReleaseVersions]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.PreReleaseVersionsResponse> {
            .get(path, query: makeGetQuery(fieldsPreReleaseVersions, limit))
        }

        private func makeGetQuery(_ fieldsPreReleaseVersions: [FieldsPreReleaseVersions]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[preReleaseVersions]", fieldsPreReleaseVersions?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsPreReleaseVersions: String, Codable, CaseIterable {
            case app
            case builds
            case platform
            case version
        }
    }
}

extension Paths.Apps.WithID {
    public var prices: Prices {
        Prices(path: path + "/prices")
    }

    public struct Prices {
        /// Path: `/v1/apps/{id}/prices`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.AppPricesResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsAppPrices: [FieldsAppPrices]?
            public var fieldsAppPriceTiers: [FieldsAppPriceTiers]?
            public var fieldsApps: [FieldsApps]?
            public var limit: Int?
            public var include: [Include]?

            public enum FieldsAppPrices: String, Codable, CaseIterable {
                case app
                case priceTier
            }

            public enum FieldsAppPriceTiers: String, Codable, CaseIterable {
                case pricePoints
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public enum Include: String, Codable, CaseIterable {
                case app
                case priceTier
            }

            public init(fieldsAppPrices: [FieldsAppPrices]? = nil, fieldsAppPriceTiers: [FieldsAppPriceTiers]? = nil, fieldsApps: [FieldsApps]? = nil, limit: Int? = nil, include: [Include]? = nil) {
                self.fieldsAppPrices = fieldsAppPrices
                self.fieldsAppPriceTiers = fieldsAppPriceTiers
                self.fieldsApps = fieldsApps
                self.limit = limit
                self.include = include
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[appPrices]", fieldsAppPrices?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appPriceTiers]", fieldsAppPriceTiers?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.Apps.WithID {
    public var relationships: Relationships {
        Relationships(path: path + "/relationships")
    }

    public struct Relationships {
        /// Path: `/v1/apps/{id}/relationships`
        public let path: String
    }
}

extension Paths.Apps.WithID.Relationships {
    public var betaTesters: BetaTesters {
        BetaTesters(path: path + "/betaTesters")
    }

    public struct BetaTesters {
        /// Path: `/v1/apps/{id}/relationships/betaTesters`
        public let path: String

        public func delete(_ body: AppStoreConnectAPI.AppBetaTestersLinkagesRequest) -> Request<Void> {
            .delete(path, body: body)
        }
    }
}

extension Paths {
    public static var betaAppLocalizations: BetaAppLocalizations {
        BetaAppLocalizations(path: "/v1/betaAppLocalizations")
    }

    public struct BetaAppLocalizations {
        /// Path: `/v1/betaAppLocalizations`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.BetaAppLocalizationsResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterLocale: [String]?
            public var filterApp: [String]?
            public var fieldsBetaAppLocalizations: [FieldsBetaAppLocalizations]?
            public var limit: Int?
            public var include: [Include]?
            public var fieldsApps: [FieldsApps]?

            public enum FieldsBetaAppLocalizations: String, Codable, CaseIterable {
                case app
                case description
                case feedbackEmail
                case locale
                case marketingURL = "marketingUrl"
                case privacyPolicyURL = "privacyPolicyUrl"
                case tvOsPrivacyPolicy
            }

            public enum Include: String, Codable, CaseIterable {
                case app
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public init(filterLocale: [String]? = nil, filterApp: [String]? = nil, fieldsBetaAppLocalizations: [FieldsBetaAppLocalizations]? = nil, limit: Int? = nil, include: [Include]? = nil, fieldsApps: [FieldsApps]? = nil) {
                self.filterLocale = filterLocale
                self.filterApp = filterApp
                self.fieldsBetaAppLocalizations = fieldsBetaAppLocalizations
                self.limit = limit
                self.include = include
                self.fieldsApps = fieldsApps
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[locale]", filterLocale?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[app]", filterApp?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaAppLocalizations]", fieldsBetaAppLocalizations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }

        public func post(_ body: AppStoreConnectAPI.BetaAppLocalizationCreateRequest) -> Request<AppStoreConnectAPI.BetaAppLocalizationResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.BetaAppLocalizations {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/betaAppLocalizations/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.BetaAppLocalizationResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsBetaAppLocalizations: [FieldsBetaAppLocalizations]?
            public var include: [Include]?
            public var fieldsApps: [FieldsApps]?

            public enum FieldsBetaAppLocalizations: String, Codable, CaseIterable {
                case app
                case description
                case feedbackEmail
                case locale
                case marketingURL = "marketingUrl"
                case privacyPolicyURL = "privacyPolicyUrl"
                case tvOsPrivacyPolicy
            }

            public enum Include: String, Codable, CaseIterable {
                case app
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public init(fieldsBetaAppLocalizations: [FieldsBetaAppLocalizations]? = nil, include: [Include]? = nil, fieldsApps: [FieldsApps]? = nil) {
                self.fieldsBetaAppLocalizations = fieldsBetaAppLocalizations
                self.include = include
                self.fieldsApps = fieldsApps
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[betaAppLocalizations]", fieldsBetaAppLocalizations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }

        public func patch(_ body: AppStoreConnectAPI.BetaAppLocalizationUpdateRequest) -> Request<AppStoreConnectAPI.BetaAppLocalizationResponse> {
            .patch(path, body: body)
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.BetaAppLocalizations.WithID {
    public var app: App {
        App(path: path + "/app")
    }

    public struct App {
        /// Path: `/v1/betaAppLocalizations/{id}/app`
        public let path: String

        public func get(fieldsApps: [FieldsApps]? = nil) -> Request<AppStoreConnectAPI.AppResponse> {
            .get(path, query: makeGetQuery(fieldsApps))
        }

        private func makeGetQuery(_ fieldsApps: [FieldsApps]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsApps: String, Codable, CaseIterable {
            case appInfos
            case appStoreVersions
            case availableInNewTerritories
            case availableTerritories
            case betaAppLocalizations
            case betaAppReviewDetail
            case betaGroups
            case betaLicenseAgreement
            case betaTesters
            case builds
            case bundleID = "bundleId"
            case contentRightsDeclaration
            case endUserLicenseAgreement
            case gameCenterEnabledVersions
            case inAppPurchases
            case isOrEverWasMadeForKids
            case name
            case perfPowerMetrics
            case preOrder
            case preReleaseVersions
            case prices
            case primaryLocale
            case sku
        }
    }
}

extension Paths {
    public static var betaAppReviewDetails: BetaAppReviewDetails {
        BetaAppReviewDetails(path: "/v1/betaAppReviewDetails")
    }

    public struct BetaAppReviewDetails {
        /// Path: `/v1/betaAppReviewDetails`
        public let path: String

        public func get(parameters: GetParameters) -> Request<AppStoreConnectAPI.BetaAppReviewDetailsResponse> {
            .get(path, query: parameters.asQuery())
        }

        public struct GetParameters {
            public var filterApp: [String]
            public var fieldsBetaAppReviewDetails: [FieldsBetaAppReviewDetails]?
            public var limit: Int?
            public var include: [Include]?
            public var fieldsApps: [FieldsApps]?

            public enum FieldsBetaAppReviewDetails: String, Codable, CaseIterable {
                case app
                case contactEmail
                case contactFirstName
                case contactLastName
                case contactPhone
                case demoAccountName
                case demoAccountPassword
                case demoAccountRequired
                case notes
            }

            public enum Include: String, Codable, CaseIterable {
                case app
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public init(filterApp: [String], fieldsBetaAppReviewDetails: [FieldsBetaAppReviewDetails]? = nil, limit: Int? = nil, include: [Include]? = nil, fieldsApps: [FieldsApps]? = nil) {
                self.filterApp = filterApp
                self.fieldsBetaAppReviewDetails = fieldsBetaAppReviewDetails
                self.limit = limit
                self.include = include
                self.fieldsApps = fieldsApps
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[app]", filterApp.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaAppReviewDetails]", fieldsBetaAppReviewDetails?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.BetaAppReviewDetails {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/betaAppReviewDetails/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.BetaAppReviewDetailResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsBetaAppReviewDetails: [FieldsBetaAppReviewDetails]?
            public var include: [Include]?
            public var fieldsApps: [FieldsApps]?

            public enum FieldsBetaAppReviewDetails: String, Codable, CaseIterable {
                case app
                case contactEmail
                case contactFirstName
                case contactLastName
                case contactPhone
                case demoAccountName
                case demoAccountPassword
                case demoAccountRequired
                case notes
            }

            public enum Include: String, Codable, CaseIterable {
                case app
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public init(fieldsBetaAppReviewDetails: [FieldsBetaAppReviewDetails]? = nil, include: [Include]? = nil, fieldsApps: [FieldsApps]? = nil) {
                self.fieldsBetaAppReviewDetails = fieldsBetaAppReviewDetails
                self.include = include
                self.fieldsApps = fieldsApps
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[betaAppReviewDetails]", fieldsBetaAppReviewDetails?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }

        public func patch(_ body: AppStoreConnectAPI.BetaAppReviewDetailUpdateRequest) -> Request<AppStoreConnectAPI.BetaAppReviewDetailResponse> {
            .patch(path, body: body)
        }
    }
}

extension Paths.BetaAppReviewDetails.WithID {
    public var app: App {
        App(path: path + "/app")
    }

    public struct App {
        /// Path: `/v1/betaAppReviewDetails/{id}/app`
        public let path: String

        public func get(fieldsApps: [FieldsApps]? = nil) -> Request<AppStoreConnectAPI.AppResponse> {
            .get(path, query: makeGetQuery(fieldsApps))
        }

        private func makeGetQuery(_ fieldsApps: [FieldsApps]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsApps: String, Codable, CaseIterable {
            case appInfos
            case appStoreVersions
            case availableInNewTerritories
            case availableTerritories
            case betaAppLocalizations
            case betaAppReviewDetail
            case betaGroups
            case betaLicenseAgreement
            case betaTesters
            case builds
            case bundleID = "bundleId"
            case contentRightsDeclaration
            case endUserLicenseAgreement
            case gameCenterEnabledVersions
            case inAppPurchases
            case isOrEverWasMadeForKids
            case name
            case perfPowerMetrics
            case preOrder
            case preReleaseVersions
            case prices
            case primaryLocale
            case sku
        }
    }
}

extension Paths {
    public static var betaAppReviewSubmissions: BetaAppReviewSubmissions {
        BetaAppReviewSubmissions(path: "/v1/betaAppReviewSubmissions")
    }

    public struct BetaAppReviewSubmissions {
        /// Path: `/v1/betaAppReviewSubmissions`
        public let path: String

        public func get(parameters: GetParameters) -> Request<AppStoreConnectAPI.BetaAppReviewSubmissionsResponse> {
            .get(path, query: parameters.asQuery())
        }

        public struct GetParameters {
            public var filterBetaReviewState: [FilterBetaReviewState]?
            public var filterBuild: [String]
            public var fieldsBetaAppReviewSubmissions: [FieldsBetaAppReviewSubmissions]?
            public var limit: Int?
            public var include: [Include]?
            public var fieldsBuilds: [FieldsBuilds]?

            public enum FilterBetaReviewState: String, Codable, CaseIterable {
                case waitingForReview = "WAITING_FOR_REVIEW"
                case inReview = "IN_REVIEW"
                case rejected = "REJECTED"
                case approved = "APPROVED"
            }

            public enum FieldsBetaAppReviewSubmissions: String, Codable, CaseIterable {
                case betaReviewState
                case build
            }

            public enum Include: String, Codable, CaseIterable {
                case build
            }

            public enum FieldsBuilds: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case betaGroups
                case buildBetaDetail
                case diagnosticSignatures
                case expirationDate
                case expired
                case iconAssetToken
                case icons
                case individualTesters
                case minOsVersion
                case perfPowerMetrics
                case preReleaseVersion
                case processingState
                case uploadedDate
                case usesNonExemptEncryption
                case version
            }

            public init(filterBetaReviewState: [FilterBetaReviewState]? = nil, filterBuild: [String], fieldsBetaAppReviewSubmissions: [FieldsBetaAppReviewSubmissions]? = nil, limit: Int? = nil, include: [Include]? = nil, fieldsBuilds: [FieldsBuilds]? = nil) {
                self.filterBetaReviewState = filterBetaReviewState
                self.filterBuild = filterBuild
                self.fieldsBetaAppReviewSubmissions = fieldsBetaAppReviewSubmissions
                self.limit = limit
                self.include = include
                self.fieldsBuilds = fieldsBuilds
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[betaReviewState]", filterBetaReviewState?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[build]", filterBuild.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaAppReviewSubmissions]", fieldsBetaAppReviewSubmissions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }

        public func post(_ body: AppStoreConnectAPI.BetaAppReviewSubmissionCreateRequest) -> Request<AppStoreConnectAPI.BetaAppReviewSubmissionResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.BetaAppReviewSubmissions {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/betaAppReviewSubmissions/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.BetaAppReviewSubmissionResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsBetaAppReviewSubmissions: [FieldsBetaAppReviewSubmissions]?
            public var include: [Include]?
            public var fieldsBuilds: [FieldsBuilds]?

            public enum FieldsBetaAppReviewSubmissions: String, Codable, CaseIterable {
                case betaReviewState
                case build
            }

            public enum Include: String, Codable, CaseIterable {
                case build
            }

            public enum FieldsBuilds: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case betaGroups
                case buildBetaDetail
                case diagnosticSignatures
                case expirationDate
                case expired
                case iconAssetToken
                case icons
                case individualTesters
                case minOsVersion
                case perfPowerMetrics
                case preReleaseVersion
                case processingState
                case uploadedDate
                case usesNonExemptEncryption
                case version
            }

            public init(fieldsBetaAppReviewSubmissions: [FieldsBetaAppReviewSubmissions]? = nil, include: [Include]? = nil, fieldsBuilds: [FieldsBuilds]? = nil) {
                self.fieldsBetaAppReviewSubmissions = fieldsBetaAppReviewSubmissions
                self.include = include
                self.fieldsBuilds = fieldsBuilds
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[betaAppReviewSubmissions]", fieldsBetaAppReviewSubmissions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.BetaAppReviewSubmissions.WithID {
    public var build: Build {
        Build(path: path + "/build")
    }

    public struct Build {
        /// Path: `/v1/betaAppReviewSubmissions/{id}/build`
        public let path: String

        public func get(fieldsBuilds: [FieldsBuilds]? = nil) -> Request<AppStoreConnectAPI.BuildResponse> {
            .get(path, query: makeGetQuery(fieldsBuilds))
        }

        private func makeGetQuery(_ fieldsBuilds: [FieldsBuilds]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsBuilds: String, Codable, CaseIterable {
            case app
            case appEncryptionDeclaration
            case appStoreVersion
            case betaAppReviewSubmission
            case betaBuildLocalizations
            case betaGroups
            case buildBetaDetail
            case diagnosticSignatures
            case expirationDate
            case expired
            case iconAssetToken
            case icons
            case individualTesters
            case minOsVersion
            case perfPowerMetrics
            case preReleaseVersion
            case processingState
            case uploadedDate
            case usesNonExemptEncryption
            case version
        }
    }
}

extension Paths {
    public static var betaBuildLocalizations: BetaBuildLocalizations {
        BetaBuildLocalizations(path: "/v1/betaBuildLocalizations")
    }

    public struct BetaBuildLocalizations {
        /// Path: `/v1/betaBuildLocalizations`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.BetaBuildLocalizationsResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterLocale: [String]?
            public var filterBuild: [String]?
            public var fieldsBetaBuildLocalizations: [FieldsBetaBuildLocalizations]?
            public var limit: Int?
            public var include: [Include]?
            public var fieldsBuilds: [FieldsBuilds]?

            public enum FieldsBetaBuildLocalizations: String, Codable, CaseIterable {
                case build
                case locale
                case whatsNew
            }

            public enum Include: String, Codable, CaseIterable {
                case build
            }

            public enum FieldsBuilds: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case betaGroups
                case buildBetaDetail
                case diagnosticSignatures
                case expirationDate
                case expired
                case iconAssetToken
                case icons
                case individualTesters
                case minOsVersion
                case perfPowerMetrics
                case preReleaseVersion
                case processingState
                case uploadedDate
                case usesNonExemptEncryption
                case version
            }

            public init(filterLocale: [String]? = nil, filterBuild: [String]? = nil, fieldsBetaBuildLocalizations: [FieldsBetaBuildLocalizations]? = nil, limit: Int? = nil, include: [Include]? = nil, fieldsBuilds: [FieldsBuilds]? = nil) {
                self.filterLocale = filterLocale
                self.filterBuild = filterBuild
                self.fieldsBetaBuildLocalizations = fieldsBetaBuildLocalizations
                self.limit = limit
                self.include = include
                self.fieldsBuilds = fieldsBuilds
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[locale]", filterLocale?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[build]", filterBuild?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaBuildLocalizations]", fieldsBetaBuildLocalizations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }

        public func post(_ body: AppStoreConnectAPI.BetaBuildLocalizationCreateRequest) -> Request<AppStoreConnectAPI.BetaBuildLocalizationResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.BetaBuildLocalizations {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/betaBuildLocalizations/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.BetaBuildLocalizationResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsBetaBuildLocalizations: [FieldsBetaBuildLocalizations]?
            public var include: [Include]?
            public var fieldsBuilds: [FieldsBuilds]?

            public enum FieldsBetaBuildLocalizations: String, Codable, CaseIterable {
                case build
                case locale
                case whatsNew
            }

            public enum Include: String, Codable, CaseIterable {
                case build
            }

            public enum FieldsBuilds: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case betaGroups
                case buildBetaDetail
                case diagnosticSignatures
                case expirationDate
                case expired
                case iconAssetToken
                case icons
                case individualTesters
                case minOsVersion
                case perfPowerMetrics
                case preReleaseVersion
                case processingState
                case uploadedDate
                case usesNonExemptEncryption
                case version
            }

            public init(fieldsBetaBuildLocalizations: [FieldsBetaBuildLocalizations]? = nil, include: [Include]? = nil, fieldsBuilds: [FieldsBuilds]? = nil) {
                self.fieldsBetaBuildLocalizations = fieldsBetaBuildLocalizations
                self.include = include
                self.fieldsBuilds = fieldsBuilds
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[betaBuildLocalizations]", fieldsBetaBuildLocalizations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }

        public func patch(_ body: AppStoreConnectAPI.BetaBuildLocalizationUpdateRequest) -> Request<AppStoreConnectAPI.BetaBuildLocalizationResponse> {
            .patch(path, body: body)
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.BetaBuildLocalizations.WithID {
    public var build: Build {
        Build(path: path + "/build")
    }

    public struct Build {
        /// Path: `/v1/betaBuildLocalizations/{id}/build`
        public let path: String

        public func get(fieldsBuilds: [FieldsBuilds]? = nil) -> Request<AppStoreConnectAPI.BuildResponse> {
            .get(path, query: makeGetQuery(fieldsBuilds))
        }

        private func makeGetQuery(_ fieldsBuilds: [FieldsBuilds]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsBuilds: String, Codable, CaseIterable {
            case app
            case appEncryptionDeclaration
            case appStoreVersion
            case betaAppReviewSubmission
            case betaBuildLocalizations
            case betaGroups
            case buildBetaDetail
            case diagnosticSignatures
            case expirationDate
            case expired
            case iconAssetToken
            case icons
            case individualTesters
            case minOsVersion
            case perfPowerMetrics
            case preReleaseVersion
            case processingState
            case uploadedDate
            case usesNonExemptEncryption
            case version
        }
    }
}

extension Paths {
    public static var betaGroups: BetaGroups {
        BetaGroups(path: "/v1/betaGroups")
    }

    public struct BetaGroups {
        /// Path: `/v1/betaGroups`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.BetaGroupsResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterIsInternalGroup: [String]?
            public var filterName: [String]?
            public var filterPublicLink: [String]?
            public var filterPublicLinkEnabled: [String]?
            public var filterPublicLinkLimitEnabled: [String]?
            public var filterApp: [String]?
            public var filterBuilds: [String]?
            public var filterID: [String]?
            public var sort: [Sort]?
            public var fieldsBetaGroups: [FieldsBetaGroups]?
            public var limit: Int?
            public var include: [Include]?
            public var fieldsBuilds: [FieldsBuilds]?
            public var fieldsBetaTesters: [FieldsBetaTesters]?
            public var fieldsApps: [FieldsApps]?
            public var limitBetaTesters: Int?
            public var limitBuilds: Int?

            public enum Sort: String, Codable, CaseIterable {
                case createdDate
                case minuscreatedDate = "-createdDate"
                case name
                case minusname = "-name"
                case publicLinkEnabled
                case minuspublicLinkEnabled = "-publicLinkEnabled"
                case publicLinkLimit
                case minuspublicLinkLimit = "-publicLinkLimit"
            }

            public enum FieldsBetaGroups: String, Codable, CaseIterable {
                case app
                case betaTesters
                case builds
                case createdDate
                case feedbackEnabled
                case isInternalGroup
                case name
                case publicLink
                case publicLinkEnabled
                case publicLinkID = "publicLinkId"
                case publicLinkLimit
                case publicLinkLimitEnabled
            }

            public enum Include: String, Codable, CaseIterable {
                case app
                case betaTesters
                case builds
            }

            public enum FieldsBuilds: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case betaGroups
                case buildBetaDetail
                case diagnosticSignatures
                case expirationDate
                case expired
                case iconAssetToken
                case icons
                case individualTesters
                case minOsVersion
                case perfPowerMetrics
                case preReleaseVersion
                case processingState
                case uploadedDate
                case usesNonExemptEncryption
                case version
            }

            public enum FieldsBetaTesters: String, Codable, CaseIterable {
                case apps
                case betaGroups
                case builds
                case email
                case firstName
                case inviteType
                case lastName
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public init(filterIsInternalGroup: [String]? = nil, filterName: [String]? = nil, filterPublicLink: [String]? = nil, filterPublicLinkEnabled: [String]? = nil, filterPublicLinkLimitEnabled: [String]? = nil, filterApp: [String]? = nil, filterBuilds: [String]? = nil, filterID: [String]? = nil, sort: [Sort]? = nil, fieldsBetaGroups: [FieldsBetaGroups]? = nil, limit: Int? = nil, include: [Include]? = nil, fieldsBuilds: [FieldsBuilds]? = nil, fieldsBetaTesters: [FieldsBetaTesters]? = nil, fieldsApps: [FieldsApps]? = nil, limitBetaTesters: Int? = nil, limitBuilds: Int? = nil) {
                self.filterIsInternalGroup = filterIsInternalGroup
                self.filterName = filterName
                self.filterPublicLink = filterPublicLink
                self.filterPublicLinkEnabled = filterPublicLinkEnabled
                self.filterPublicLinkLimitEnabled = filterPublicLinkLimitEnabled
                self.filterApp = filterApp
                self.filterBuilds = filterBuilds
                self.filterID = filterID
                self.sort = sort
                self.fieldsBetaGroups = fieldsBetaGroups
                self.limit = limit
                self.include = include
                self.fieldsBuilds = fieldsBuilds
                self.fieldsBetaTesters = fieldsBetaTesters
                self.fieldsApps = fieldsApps
                self.limitBetaTesters = limitBetaTesters
                self.limitBuilds = limitBuilds
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[isInternalGroup]", filterIsInternalGroup?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[name]", filterName?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[publicLink]", filterPublicLink?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[publicLinkEnabled]", filterPublicLinkEnabled?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[publicLinkLimitEnabled]", filterPublicLinkLimitEnabled?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[app]", filterApp?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[builds]", filterBuilds?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[id]", filterID?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("sort", sort?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaGroups]", fieldsBetaGroups?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaTesters]", fieldsBetaTesters?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[betaTesters]", limitBetaTesters)
                query.addQueryItem("limit[builds]", limitBuilds)
                return query
            }
        }

        public func post(_ body: AppStoreConnectAPI.BetaGroupCreateRequest) -> Request<AppStoreConnectAPI.BetaGroupResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.BetaGroups {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/betaGroups/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.BetaGroupResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsBetaGroups: [FieldsBetaGroups]?
            public var include: [Include]?
            public var fieldsBuilds: [FieldsBuilds]?
            public var fieldsBetaTesters: [FieldsBetaTesters]?
            public var fieldsApps: [FieldsApps]?
            public var limitBetaTesters: Int?
            public var limitBuilds: Int?

            public enum FieldsBetaGroups: String, Codable, CaseIterable {
                case app
                case betaTesters
                case builds
                case createdDate
                case feedbackEnabled
                case isInternalGroup
                case name
                case publicLink
                case publicLinkEnabled
                case publicLinkID = "publicLinkId"
                case publicLinkLimit
                case publicLinkLimitEnabled
            }

            public enum Include: String, Codable, CaseIterable {
                case app
                case betaTesters
                case builds
            }

            public enum FieldsBuilds: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case betaGroups
                case buildBetaDetail
                case diagnosticSignatures
                case expirationDate
                case expired
                case iconAssetToken
                case icons
                case individualTesters
                case minOsVersion
                case perfPowerMetrics
                case preReleaseVersion
                case processingState
                case uploadedDate
                case usesNonExemptEncryption
                case version
            }

            public enum FieldsBetaTesters: String, Codable, CaseIterable {
                case apps
                case betaGroups
                case builds
                case email
                case firstName
                case inviteType
                case lastName
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public init(fieldsBetaGroups: [FieldsBetaGroups]? = nil, include: [Include]? = nil, fieldsBuilds: [FieldsBuilds]? = nil, fieldsBetaTesters: [FieldsBetaTesters]? = nil, fieldsApps: [FieldsApps]? = nil, limitBetaTesters: Int? = nil, limitBuilds: Int? = nil) {
                self.fieldsBetaGroups = fieldsBetaGroups
                self.include = include
                self.fieldsBuilds = fieldsBuilds
                self.fieldsBetaTesters = fieldsBetaTesters
                self.fieldsApps = fieldsApps
                self.limitBetaTesters = limitBetaTesters
                self.limitBuilds = limitBuilds
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[betaGroups]", fieldsBetaGroups?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaTesters]", fieldsBetaTesters?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[betaTesters]", limitBetaTesters)
                query.addQueryItem("limit[builds]", limitBuilds)
                return query
            }
        }

        public func patch(_ body: AppStoreConnectAPI.BetaGroupUpdateRequest) -> Request<AppStoreConnectAPI.BetaGroupResponse> {
            .patch(path, body: body)
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.BetaGroups.WithID {
    public var app: App {
        App(path: path + "/app")
    }

    public struct App {
        /// Path: `/v1/betaGroups/{id}/app`
        public let path: String

        public func get(fieldsApps: [FieldsApps]? = nil) -> Request<AppStoreConnectAPI.AppResponse> {
            .get(path, query: makeGetQuery(fieldsApps))
        }

        private func makeGetQuery(_ fieldsApps: [FieldsApps]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsApps: String, Codable, CaseIterable {
            case appInfos
            case appStoreVersions
            case availableInNewTerritories
            case availableTerritories
            case betaAppLocalizations
            case betaAppReviewDetail
            case betaGroups
            case betaLicenseAgreement
            case betaTesters
            case builds
            case bundleID = "bundleId"
            case contentRightsDeclaration
            case endUserLicenseAgreement
            case gameCenterEnabledVersions
            case inAppPurchases
            case isOrEverWasMadeForKids
            case name
            case perfPowerMetrics
            case preOrder
            case preReleaseVersions
            case prices
            case primaryLocale
            case sku
        }
    }
}

extension Paths.BetaGroups.WithID {
    public var betaTesters: BetaTesters {
        BetaTesters(path: path + "/betaTesters")
    }

    public struct BetaTesters {
        /// Path: `/v1/betaGroups/{id}/betaTesters`
        public let path: String

        public func get(fieldsBetaTesters: [FieldsBetaTesters]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.BetaTestersResponse> {
            .get(path, query: makeGetQuery(fieldsBetaTesters, limit))
        }

        private func makeGetQuery(_ fieldsBetaTesters: [FieldsBetaTesters]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[betaTesters]", fieldsBetaTesters?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsBetaTesters: String, Codable, CaseIterable {
            case apps
            case betaGroups
            case builds
            case email
            case firstName
            case inviteType
            case lastName
        }
    }
}

extension Paths.BetaGroups.WithID {
    public var builds: Builds {
        Builds(path: path + "/builds")
    }

    public struct Builds {
        /// Path: `/v1/betaGroups/{id}/builds`
        public let path: String

        public func get(fieldsBuilds: [FieldsBuilds]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.BuildsResponse> {
            .get(path, query: makeGetQuery(fieldsBuilds, limit))
        }

        private func makeGetQuery(_ fieldsBuilds: [FieldsBuilds]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsBuilds: String, Codable, CaseIterable {
            case app
            case appEncryptionDeclaration
            case appStoreVersion
            case betaAppReviewSubmission
            case betaBuildLocalizations
            case betaGroups
            case buildBetaDetail
            case diagnosticSignatures
            case expirationDate
            case expired
            case iconAssetToken
            case icons
            case individualTesters
            case minOsVersion
            case perfPowerMetrics
            case preReleaseVersion
            case processingState
            case uploadedDate
            case usesNonExemptEncryption
            case version
        }
    }
}

extension Paths.BetaGroups.WithID {
    public var relationships: Relationships {
        Relationships(path: path + "/relationships")
    }

    public struct Relationships {
        /// Path: `/v1/betaGroups/{id}/relationships`
        public let path: String
    }
}

extension Paths.BetaGroups.WithID.Relationships {
    public var betaTesters: BetaTesters {
        BetaTesters(path: path + "/betaTesters")
    }

    public struct BetaTesters {
        /// Path: `/v1/betaGroups/{id}/relationships/betaTesters`
        public let path: String

        public func get(limit: Int? = nil) -> Request<AppStoreConnectAPI.BetaGroupBetaTestersLinkagesResponse> {
            .get(path, query: makeGetQuery(limit))
        }

        private func makeGetQuery(_ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("limit", limit)
            return query
        }

        public func post(_ body: AppStoreConnectAPI.BetaGroupBetaTestersLinkagesRequest) -> Request<Void> {
            .post(path, body: body)
        }

        public func delete(_ body: AppStoreConnectAPI.BetaGroupBetaTestersLinkagesRequest) -> Request<Void> {
            .delete(path, body: body)
        }
    }
}

extension Paths.BetaGroups.WithID.Relationships {
    public var builds: Builds {
        Builds(path: path + "/builds")
    }

    public struct Builds {
        /// Path: `/v1/betaGroups/{id}/relationships/builds`
        public let path: String

        public func get(limit: Int? = nil) -> Request<AppStoreConnectAPI.BetaGroupBuildsLinkagesResponse> {
            .get(path, query: makeGetQuery(limit))
        }

        private func makeGetQuery(_ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("limit", limit)
            return query
        }

        public func post(_ body: AppStoreConnectAPI.BetaGroupBuildsLinkagesRequest) -> Request<Void> {
            .post(path, body: body)
        }

        public func delete(_ body: AppStoreConnectAPI.BetaGroupBuildsLinkagesRequest) -> Request<Void> {
            .delete(path, body: body)
        }
    }
}

extension Paths {
    public static var betaLicenseAgreements: BetaLicenseAgreements {
        BetaLicenseAgreements(path: "/v1/betaLicenseAgreements")
    }

    public struct BetaLicenseAgreements {
        /// Path: `/v1/betaLicenseAgreements`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.BetaLicenseAgreementsResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterApp: [String]?
            public var fieldsBetaLicenseAgreements: [FieldsBetaLicenseAgreements]?
            public var limit: Int?
            public var include: [Include]?
            public var fieldsApps: [FieldsApps]?

            public enum FieldsBetaLicenseAgreements: String, Codable, CaseIterable {
                case agreementText
                case app
            }

            public enum Include: String, Codable, CaseIterable {
                case app
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public init(filterApp: [String]? = nil, fieldsBetaLicenseAgreements: [FieldsBetaLicenseAgreements]? = nil, limit: Int? = nil, include: [Include]? = nil, fieldsApps: [FieldsApps]? = nil) {
                self.filterApp = filterApp
                self.fieldsBetaLicenseAgreements = fieldsBetaLicenseAgreements
                self.limit = limit
                self.include = include
                self.fieldsApps = fieldsApps
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[app]", filterApp?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaLicenseAgreements]", fieldsBetaLicenseAgreements?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.BetaLicenseAgreements {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/betaLicenseAgreements/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.BetaLicenseAgreementResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsBetaLicenseAgreements: [FieldsBetaLicenseAgreements]?
            public var include: [Include]?
            public var fieldsApps: [FieldsApps]?

            public enum FieldsBetaLicenseAgreements: String, Codable, CaseIterable {
                case agreementText
                case app
            }

            public enum Include: String, Codable, CaseIterable {
                case app
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public init(fieldsBetaLicenseAgreements: [FieldsBetaLicenseAgreements]? = nil, include: [Include]? = nil, fieldsApps: [FieldsApps]? = nil) {
                self.fieldsBetaLicenseAgreements = fieldsBetaLicenseAgreements
                self.include = include
                self.fieldsApps = fieldsApps
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[betaLicenseAgreements]", fieldsBetaLicenseAgreements?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }

        public func patch(_ body: AppStoreConnectAPI.BetaLicenseAgreementUpdateRequest) -> Request<AppStoreConnectAPI.BetaLicenseAgreementResponse> {
            .patch(path, body: body)
        }
    }
}

extension Paths.BetaLicenseAgreements.WithID {
    public var app: App {
        App(path: path + "/app")
    }

    public struct App {
        /// Path: `/v1/betaLicenseAgreements/{id}/app`
        public let path: String

        public func get(fieldsApps: [FieldsApps]? = nil) -> Request<AppStoreConnectAPI.AppResponse> {
            .get(path, query: makeGetQuery(fieldsApps))
        }

        private func makeGetQuery(_ fieldsApps: [FieldsApps]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsApps: String, Codable, CaseIterable {
            case appInfos
            case appStoreVersions
            case availableInNewTerritories
            case availableTerritories
            case betaAppLocalizations
            case betaAppReviewDetail
            case betaGroups
            case betaLicenseAgreement
            case betaTesters
            case builds
            case bundleID = "bundleId"
            case contentRightsDeclaration
            case endUserLicenseAgreement
            case gameCenterEnabledVersions
            case inAppPurchases
            case isOrEverWasMadeForKids
            case name
            case perfPowerMetrics
            case preOrder
            case preReleaseVersions
            case prices
            case primaryLocale
            case sku
        }
    }
}

extension Paths {
    public static var betaTesterInvitations: BetaTesterInvitations {
        BetaTesterInvitations(path: "/v1/betaTesterInvitations")
    }

    public struct BetaTesterInvitations {
        /// Path: `/v1/betaTesterInvitations`
        public let path: String

        public func post(_ body: AppStoreConnectAPI.BetaTesterInvitationCreateRequest) -> Request<AppStoreConnectAPI.BetaTesterInvitationResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths {
    public static var betaTesters: BetaTesters {
        BetaTesters(path: "/v1/betaTesters")
    }

    public struct BetaTesters {
        /// Path: `/v1/betaTesters`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.BetaTestersResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterEmail: [String]?
            public var filterFirstName: [String]?
            public var filterInviteType: [FilterInviteType]?
            public var filterLastName: [String]?
            public var filterApps: [String]?
            public var filterBetaGroups: [String]?
            public var filterBuilds: [String]?
            public var sort: [Sort]?
            public var fieldsBetaTesters: [FieldsBetaTesters]?
            public var limit: Int?
            public var include: [Include]?
            public var fieldsBetaGroups: [FieldsBetaGroups]?
            public var fieldsBuilds: [FieldsBuilds]?
            public var fieldsApps: [FieldsApps]?
            public var limitApps: Int?
            public var limitBetaGroups: Int?
            public var limitBuilds: Int?

            public enum FilterInviteType: String, Codable, CaseIterable {
                case email = "EMAIL"
                case publicLink = "PUBLIC_LINK"
            }

            public enum Sort: String, Codable, CaseIterable {
                case email
                case minusemail = "-email"
                case firstName
                case minusfirstName = "-firstName"
                case inviteType
                case minusinviteType = "-inviteType"
                case lastName
                case minuslastName = "-lastName"
            }

            public enum FieldsBetaTesters: String, Codable, CaseIterable {
                case apps
                case betaGroups
                case builds
                case email
                case firstName
                case inviteType
                case lastName
            }

            public enum Include: String, Codable, CaseIterable {
                case apps
                case betaGroups
                case builds
            }

            public enum FieldsBetaGroups: String, Codable, CaseIterable {
                case app
                case betaTesters
                case builds
                case createdDate
                case feedbackEnabled
                case isInternalGroup
                case name
                case publicLink
                case publicLinkEnabled
                case publicLinkID = "publicLinkId"
                case publicLinkLimit
                case publicLinkLimitEnabled
            }

            public enum FieldsBuilds: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case betaGroups
                case buildBetaDetail
                case diagnosticSignatures
                case expirationDate
                case expired
                case iconAssetToken
                case icons
                case individualTesters
                case minOsVersion
                case perfPowerMetrics
                case preReleaseVersion
                case processingState
                case uploadedDate
                case usesNonExemptEncryption
                case version
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public init(filterEmail: [String]? = nil, filterFirstName: [String]? = nil, filterInviteType: [FilterInviteType]? = nil, filterLastName: [String]? = nil, filterApps: [String]? = nil, filterBetaGroups: [String]? = nil, filterBuilds: [String]? = nil, sort: [Sort]? = nil, fieldsBetaTesters: [FieldsBetaTesters]? = nil, limit: Int? = nil, include: [Include]? = nil, fieldsBetaGroups: [FieldsBetaGroups]? = nil, fieldsBuilds: [FieldsBuilds]? = nil, fieldsApps: [FieldsApps]? = nil, limitApps: Int? = nil, limitBetaGroups: Int? = nil, limitBuilds: Int? = nil) {
                self.filterEmail = filterEmail
                self.filterFirstName = filterFirstName
                self.filterInviteType = filterInviteType
                self.filterLastName = filterLastName
                self.filterApps = filterApps
                self.filterBetaGroups = filterBetaGroups
                self.filterBuilds = filterBuilds
                self.sort = sort
                self.fieldsBetaTesters = fieldsBetaTesters
                self.limit = limit
                self.include = include
                self.fieldsBetaGroups = fieldsBetaGroups
                self.fieldsBuilds = fieldsBuilds
                self.fieldsApps = fieldsApps
                self.limitApps = limitApps
                self.limitBetaGroups = limitBetaGroups
                self.limitBuilds = limitBuilds
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[email]", filterEmail?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[firstName]", filterFirstName?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[inviteType]", filterInviteType?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[lastName]", filterLastName?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[apps]", filterApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[betaGroups]", filterBetaGroups?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[builds]", filterBuilds?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("sort", sort?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaTesters]", fieldsBetaTesters?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaGroups]", fieldsBetaGroups?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[apps]", limitApps)
                query.addQueryItem("limit[betaGroups]", limitBetaGroups)
                query.addQueryItem("limit[builds]", limitBuilds)
                return query
            }
        }

        public func post(_ body: AppStoreConnectAPI.BetaTesterCreateRequest) -> Request<AppStoreConnectAPI.BetaTesterResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.BetaTesters {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/betaTesters/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.BetaTesterResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsBetaTesters: [FieldsBetaTesters]?
            public var include: [Include]?
            public var fieldsBetaGroups: [FieldsBetaGroups]?
            public var fieldsBuilds: [FieldsBuilds]?
            public var fieldsApps: [FieldsApps]?
            public var limitApps: Int?
            public var limitBetaGroups: Int?
            public var limitBuilds: Int?

            public enum FieldsBetaTesters: String, Codable, CaseIterable {
                case apps
                case betaGroups
                case builds
                case email
                case firstName
                case inviteType
                case lastName
            }

            public enum Include: String, Codable, CaseIterable {
                case apps
                case betaGroups
                case builds
            }

            public enum FieldsBetaGroups: String, Codable, CaseIterable {
                case app
                case betaTesters
                case builds
                case createdDate
                case feedbackEnabled
                case isInternalGroup
                case name
                case publicLink
                case publicLinkEnabled
                case publicLinkID = "publicLinkId"
                case publicLinkLimit
                case publicLinkLimitEnabled
            }

            public enum FieldsBuilds: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case betaGroups
                case buildBetaDetail
                case diagnosticSignatures
                case expirationDate
                case expired
                case iconAssetToken
                case icons
                case individualTesters
                case minOsVersion
                case perfPowerMetrics
                case preReleaseVersion
                case processingState
                case uploadedDate
                case usesNonExemptEncryption
                case version
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public init(fieldsBetaTesters: [FieldsBetaTesters]? = nil, include: [Include]? = nil, fieldsBetaGroups: [FieldsBetaGroups]? = nil, fieldsBuilds: [FieldsBuilds]? = nil, fieldsApps: [FieldsApps]? = nil, limitApps: Int? = nil, limitBetaGroups: Int? = nil, limitBuilds: Int? = nil) {
                self.fieldsBetaTesters = fieldsBetaTesters
                self.include = include
                self.fieldsBetaGroups = fieldsBetaGroups
                self.fieldsBuilds = fieldsBuilds
                self.fieldsApps = fieldsApps
                self.limitApps = limitApps
                self.limitBetaGroups = limitBetaGroups
                self.limitBuilds = limitBuilds
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[betaTesters]", fieldsBetaTesters?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaGroups]", fieldsBetaGroups?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[apps]", limitApps)
                query.addQueryItem("limit[betaGroups]", limitBetaGroups)
                query.addQueryItem("limit[builds]", limitBuilds)
                return query
            }
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.BetaTesters.WithID {
    public var apps: Apps {
        Apps(path: path + "/apps")
    }

    public struct Apps {
        /// Path: `/v1/betaTesters/{id}/apps`
        public let path: String

        public func get(fieldsApps: [FieldsApps]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.AppsResponse> {
            .get(path, query: makeGetQuery(fieldsApps, limit))
        }

        private func makeGetQuery(_ fieldsApps: [FieldsApps]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsApps: String, Codable, CaseIterable {
            case appInfos
            case appStoreVersions
            case availableInNewTerritories
            case availableTerritories
            case betaAppLocalizations
            case betaAppReviewDetail
            case betaGroups
            case betaLicenseAgreement
            case betaTesters
            case builds
            case bundleID = "bundleId"
            case contentRightsDeclaration
            case endUserLicenseAgreement
            case gameCenterEnabledVersions
            case inAppPurchases
            case isOrEverWasMadeForKids
            case name
            case perfPowerMetrics
            case preOrder
            case preReleaseVersions
            case prices
            case primaryLocale
            case sku
        }
    }
}

extension Paths.BetaTesters.WithID {
    public var betaGroups: BetaGroups {
        BetaGroups(path: path + "/betaGroups")
    }

    public struct BetaGroups {
        /// Path: `/v1/betaTesters/{id}/betaGroups`
        public let path: String

        public func get(fieldsBetaGroups: [FieldsBetaGroups]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.BetaGroupsResponse> {
            .get(path, query: makeGetQuery(fieldsBetaGroups, limit))
        }

        private func makeGetQuery(_ fieldsBetaGroups: [FieldsBetaGroups]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[betaGroups]", fieldsBetaGroups?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsBetaGroups: String, Codable, CaseIterable {
            case app
            case betaTesters
            case builds
            case createdDate
            case feedbackEnabled
            case isInternalGroup
            case name
            case publicLink
            case publicLinkEnabled
            case publicLinkID = "publicLinkId"
            case publicLinkLimit
            case publicLinkLimitEnabled
        }
    }
}

extension Paths.BetaTesters.WithID {
    public var builds: Builds {
        Builds(path: path + "/builds")
    }

    public struct Builds {
        /// Path: `/v1/betaTesters/{id}/builds`
        public let path: String

        public func get(fieldsBuilds: [FieldsBuilds]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.BuildsResponse> {
            .get(path, query: makeGetQuery(fieldsBuilds, limit))
        }

        private func makeGetQuery(_ fieldsBuilds: [FieldsBuilds]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsBuilds: String, Codable, CaseIterable {
            case app
            case appEncryptionDeclaration
            case appStoreVersion
            case betaAppReviewSubmission
            case betaBuildLocalizations
            case betaGroups
            case buildBetaDetail
            case diagnosticSignatures
            case expirationDate
            case expired
            case iconAssetToken
            case icons
            case individualTesters
            case minOsVersion
            case perfPowerMetrics
            case preReleaseVersion
            case processingState
            case uploadedDate
            case usesNonExemptEncryption
            case version
        }
    }
}

extension Paths.BetaTesters.WithID {
    public var relationships: Relationships {
        Relationships(path: path + "/relationships")
    }

    public struct Relationships {
        /// Path: `/v1/betaTesters/{id}/relationships`
        public let path: String
    }
}

extension Paths.BetaTesters.WithID.Relationships {
    public var apps: Apps {
        Apps(path: path + "/apps")
    }

    public struct Apps {
        /// Path: `/v1/betaTesters/{id}/relationships/apps`
        public let path: String

        public func get(limit: Int? = nil) -> Request<AppStoreConnectAPI.BetaTesterAppsLinkagesResponse> {
            .get(path, query: makeGetQuery(limit))
        }

        private func makeGetQuery(_ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("limit", limit)
            return query
        }

        public func delete(_ body: AppStoreConnectAPI.BetaTesterAppsLinkagesRequest) -> Request<Void> {
            .delete(path, body: body)
        }
    }
}

extension Paths.BetaTesters.WithID.Relationships {
    public var betaGroups: BetaGroups {
        BetaGroups(path: path + "/betaGroups")
    }

    public struct BetaGroups {
        /// Path: `/v1/betaTesters/{id}/relationships/betaGroups`
        public let path: String

        public func get(limit: Int? = nil) -> Request<AppStoreConnectAPI.BetaTesterBetaGroupsLinkagesResponse> {
            .get(path, query: makeGetQuery(limit))
        }

        private func makeGetQuery(_ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("limit", limit)
            return query
        }

        public func post(_ body: AppStoreConnectAPI.BetaTesterBetaGroupsLinkagesRequest) -> Request<Void> {
            .post(path, body: body)
        }

        public func delete(_ body: AppStoreConnectAPI.BetaTesterBetaGroupsLinkagesRequest) -> Request<Void> {
            .delete(path, body: body)
        }
    }
}

extension Paths.BetaTesters.WithID.Relationships {
    public var builds: Builds {
        Builds(path: path + "/builds")
    }

    public struct Builds {
        /// Path: `/v1/betaTesters/{id}/relationships/builds`
        public let path: String

        public func get(limit: Int? = nil) -> Request<AppStoreConnectAPI.BetaTesterBuildsLinkagesResponse> {
            .get(path, query: makeGetQuery(limit))
        }

        private func makeGetQuery(_ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("limit", limit)
            return query
        }

        public func post(_ body: AppStoreConnectAPI.BetaTesterBuildsLinkagesRequest) -> Request<Void> {
            .post(path, body: body)
        }

        public func delete(_ body: AppStoreConnectAPI.BetaTesterBuildsLinkagesRequest) -> Request<Void> {
            .delete(path, body: body)
        }
    }
}

extension Paths {
    public static var buildBetaDetails: BuildBetaDetails {
        BuildBetaDetails(path: "/v1/buildBetaDetails")
    }

    public struct BuildBetaDetails {
        /// Path: `/v1/buildBetaDetails`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.BuildBetaDetailsResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterBuild: [String]?
            public var filterID: [String]?
            public var fieldsBuildBetaDetails: [FieldsBuildBetaDetails]?
            public var limit: Int?
            public var include: [Include]?
            public var fieldsBuilds: [FieldsBuilds]?

            public enum FieldsBuildBetaDetails: String, Codable, CaseIterable {
                case autoNotifyEnabled
                case build
                case externalBuildState
                case internalBuildState
            }

            public enum Include: String, Codable, CaseIterable {
                case build
            }

            public enum FieldsBuilds: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case betaGroups
                case buildBetaDetail
                case diagnosticSignatures
                case expirationDate
                case expired
                case iconAssetToken
                case icons
                case individualTesters
                case minOsVersion
                case perfPowerMetrics
                case preReleaseVersion
                case processingState
                case uploadedDate
                case usesNonExemptEncryption
                case version
            }

            public init(filterBuild: [String]? = nil, filterID: [String]? = nil, fieldsBuildBetaDetails: [FieldsBuildBetaDetails]? = nil, limit: Int? = nil, include: [Include]? = nil, fieldsBuilds: [FieldsBuilds]? = nil) {
                self.filterBuild = filterBuild
                self.filterID = filterID
                self.fieldsBuildBetaDetails = fieldsBuildBetaDetails
                self.limit = limit
                self.include = include
                self.fieldsBuilds = fieldsBuilds
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[build]", filterBuild?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[id]", filterID?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[buildBetaDetails]", fieldsBuildBetaDetails?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.BuildBetaDetails {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/buildBetaDetails/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.BuildBetaDetailResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsBuildBetaDetails: [FieldsBuildBetaDetails]?
            public var include: [Include]?
            public var fieldsBuilds: [FieldsBuilds]?

            public enum FieldsBuildBetaDetails: String, Codable, CaseIterable {
                case autoNotifyEnabled
                case build
                case externalBuildState
                case internalBuildState
            }

            public enum Include: String, Codable, CaseIterable {
                case build
            }

            public enum FieldsBuilds: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case betaGroups
                case buildBetaDetail
                case diagnosticSignatures
                case expirationDate
                case expired
                case iconAssetToken
                case icons
                case individualTesters
                case minOsVersion
                case perfPowerMetrics
                case preReleaseVersion
                case processingState
                case uploadedDate
                case usesNonExemptEncryption
                case version
            }

            public init(fieldsBuildBetaDetails: [FieldsBuildBetaDetails]? = nil, include: [Include]? = nil, fieldsBuilds: [FieldsBuilds]? = nil) {
                self.fieldsBuildBetaDetails = fieldsBuildBetaDetails
                self.include = include
                self.fieldsBuilds = fieldsBuilds
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[buildBetaDetails]", fieldsBuildBetaDetails?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }

        public func patch(_ body: AppStoreConnectAPI.BuildBetaDetailUpdateRequest) -> Request<AppStoreConnectAPI.BuildBetaDetailResponse> {
            .patch(path, body: body)
        }
    }
}

extension Paths.BuildBetaDetails.WithID {
    public var build: Build {
        Build(path: path + "/build")
    }

    public struct Build {
        /// Path: `/v1/buildBetaDetails/{id}/build`
        public let path: String

        public func get(fieldsBuilds: [FieldsBuilds]? = nil) -> Request<AppStoreConnectAPI.BuildResponse> {
            .get(path, query: makeGetQuery(fieldsBuilds))
        }

        private func makeGetQuery(_ fieldsBuilds: [FieldsBuilds]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsBuilds: String, Codable, CaseIterable {
            case app
            case appEncryptionDeclaration
            case appStoreVersion
            case betaAppReviewSubmission
            case betaBuildLocalizations
            case betaGroups
            case buildBetaDetail
            case diagnosticSignatures
            case expirationDate
            case expired
            case iconAssetToken
            case icons
            case individualTesters
            case minOsVersion
            case perfPowerMetrics
            case preReleaseVersion
            case processingState
            case uploadedDate
            case usesNonExemptEncryption
            case version
        }
    }
}

extension Paths {
    public static var buildBetaNotifications: BuildBetaNotifications {
        BuildBetaNotifications(path: "/v1/buildBetaNotifications")
    }

    public struct BuildBetaNotifications {
        /// Path: `/v1/buildBetaNotifications`
        public let path: String

        public func post(_ body: AppStoreConnectAPI.BuildBetaNotificationCreateRequest) -> Request<AppStoreConnectAPI.BuildBetaNotificationResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths {
    public static var builds: Builds {
        Builds(path: "/v1/builds")
    }

    public struct Builds {
        /// Path: `/v1/builds`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.BuildsResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterBetaAppReviewSubmissionBetaReviewState: [FilterBetaAppReviewSubmissionBetaReviewState]?
            public var filterExpired: [String]?
            public var filterPreReleaseVersionPlatform: [FilterPreReleaseVersionPlatform]?
            public var filterPreReleaseVersionVersion: [String]?
            public var filterProcessingState: [FilterProcessingState]?
            public var filterUsesNonExemptEncryption: [String]?
            public var filterVersion: [String]?
            public var filterApp: [String]?
            public var filterAppStoreVersion: [String]?
            public var filterBetaGroups: [String]?
            public var filterPreReleaseVersion: [String]?
            public var filterID: [String]?
            public var sort: [Sort]?
            public var fieldsBuilds: [FieldsBuilds]?
            public var limit: Int?
            public var include: [Include]?
            public var fieldsAppEncryptionDeclarations: [FieldsAppEncryptionDeclarations]?
            public var fieldsBetaAppReviewSubmissions: [FieldsBetaAppReviewSubmissions]?
            public var fieldsBuildBetaDetails: [FieldsBuildBetaDetails]?
            public var fieldsBuildIcons: [FieldsBuildIcons]?
            public var fieldsPerfPowerMetrics: [FieldsPerfPowerMetrics]?
            public var fieldsPreReleaseVersions: [FieldsPreReleaseVersions]?
            public var fieldsAppStoreVersions: [FieldsAppStoreVersions]?
            public var fieldsDiagnosticSignatures: [FieldsDiagnosticSignatures]?
            public var fieldsBetaTesters: [FieldsBetaTesters]?
            public var fieldsBetaBuildLocalizations: [FieldsBetaBuildLocalizations]?
            public var fieldsApps: [FieldsApps]?
            public var limitBetaBuildLocalizations: Int?
            public var limitIcons: Int?
            public var limitIndividualTesters: Int?

            public enum FilterBetaAppReviewSubmissionBetaReviewState: String, Codable, CaseIterable {
                case waitingForReview = "WAITING_FOR_REVIEW"
                case inReview = "IN_REVIEW"
                case rejected = "REJECTED"
                case approved = "APPROVED"
            }

            public enum FilterPreReleaseVersionPlatform: String, Codable, CaseIterable {
                case ios = "IOS"
                case macOs = "MAC_OS"
                case tvOs = "TV_OS"
            }

            public enum FilterProcessingState: String, Codable, CaseIterable {
                case processing = "PROCESSING"
                case failed = "FAILED"
                case invalid = "INVALID"
                case valid = "VALID"
            }

            public enum Sort: String, Codable, CaseIterable {
                case preReleaseVersion
                case minuspreReleaseVersion = "-preReleaseVersion"
                case uploadedDate
                case minusuploadedDate = "-uploadedDate"
                case version
                case minusversion = "-version"
            }

            public enum FieldsBuilds: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case betaGroups
                case buildBetaDetail
                case diagnosticSignatures
                case expirationDate
                case expired
                case iconAssetToken
                case icons
                case individualTesters
                case minOsVersion
                case perfPowerMetrics
                case preReleaseVersion
                case processingState
                case uploadedDate
                case usesNonExemptEncryption
                case version
            }

            public enum Include: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case buildBetaDetail
                case icons
                case individualTesters
                case preReleaseVersion
            }

            public enum FieldsAppEncryptionDeclarations: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclarationState
                case availableOnFrenchStore
                case builds
                case codeValue
                case containsProprietaryCryptography
                case containsThirdPartyCryptography
                case documentName
                case documentType
                case documentURL = "documentUrl"
                case exempt
                case platform
                case uploadedDate
                case usesEncryption
            }

            public enum FieldsBetaAppReviewSubmissions: String, Codable, CaseIterable {
                case betaReviewState
                case build
            }

            public enum FieldsBuildBetaDetails: String, Codable, CaseIterable {
                case autoNotifyEnabled
                case build
                case externalBuildState
                case internalBuildState
            }

            public enum FieldsBuildIcons: String, Codable, CaseIterable {
                case iconAsset
                case iconType
            }

            public enum FieldsPerfPowerMetrics: String, Codable, CaseIterable {
                case deviceType
                case metricType
                case platform
            }

            public enum FieldsPreReleaseVersions: String, Codable, CaseIterable {
                case app
                case builds
                case platform
                case version
            }

            public enum FieldsAppStoreVersions: String, Codable, CaseIterable {
                case ageRatingDeclaration
                case app
                case appStoreReviewDetail
                case appStoreState
                case appStoreVersionLocalizations
                case appStoreVersionPhasedRelease
                case appStoreVersionSubmission
                case build
                case copyright
                case createdDate
                case downloadable
                case earliestReleaseDate
                case idfaDeclaration
                case platform
                case releaseType
                case routingAppCoverage
                case usesIdfa
                case versionString
            }

            public enum FieldsDiagnosticSignatures: String, Codable, CaseIterable {
                case diagnosticType
                case logs
                case signature
                case weight
            }

            public enum FieldsBetaTesters: String, Codable, CaseIterable {
                case apps
                case betaGroups
                case builds
                case email
                case firstName
                case inviteType
                case lastName
            }

            public enum FieldsBetaBuildLocalizations: String, Codable, CaseIterable {
                case build
                case locale
                case whatsNew
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public init(filterBetaAppReviewSubmissionBetaReviewState: [FilterBetaAppReviewSubmissionBetaReviewState]? = nil, filterExpired: [String]? = nil, filterPreReleaseVersionPlatform: [FilterPreReleaseVersionPlatform]? = nil, filterPreReleaseVersionVersion: [String]? = nil, filterProcessingState: [FilterProcessingState]? = nil, filterUsesNonExemptEncryption: [String]? = nil, filterVersion: [String]? = nil, filterApp: [String]? = nil, filterAppStoreVersion: [String]? = nil, filterBetaGroups: [String]? = nil, filterPreReleaseVersion: [String]? = nil, filterID: [String]? = nil, sort: [Sort]? = nil, fieldsBuilds: [FieldsBuilds]? = nil, limit: Int? = nil, include: [Include]? = nil, fieldsAppEncryptionDeclarations: [FieldsAppEncryptionDeclarations]? = nil, fieldsBetaAppReviewSubmissions: [FieldsBetaAppReviewSubmissions]? = nil, fieldsBuildBetaDetails: [FieldsBuildBetaDetails]? = nil, fieldsBuildIcons: [FieldsBuildIcons]? = nil, fieldsPerfPowerMetrics: [FieldsPerfPowerMetrics]? = nil, fieldsPreReleaseVersions: [FieldsPreReleaseVersions]? = nil, fieldsAppStoreVersions: [FieldsAppStoreVersions]? = nil, fieldsDiagnosticSignatures: [FieldsDiagnosticSignatures]? = nil, fieldsBetaTesters: [FieldsBetaTesters]? = nil, fieldsBetaBuildLocalizations: [FieldsBetaBuildLocalizations]? = nil, fieldsApps: [FieldsApps]? = nil, limitBetaBuildLocalizations: Int? = nil, limitIcons: Int? = nil, limitIndividualTesters: Int? = nil) {
                self.filterBetaAppReviewSubmissionBetaReviewState = filterBetaAppReviewSubmissionBetaReviewState
                self.filterExpired = filterExpired
                self.filterPreReleaseVersionPlatform = filterPreReleaseVersionPlatform
                self.filterPreReleaseVersionVersion = filterPreReleaseVersionVersion
                self.filterProcessingState = filterProcessingState
                self.filterUsesNonExemptEncryption = filterUsesNonExemptEncryption
                self.filterVersion = filterVersion
                self.filterApp = filterApp
                self.filterAppStoreVersion = filterAppStoreVersion
                self.filterBetaGroups = filterBetaGroups
                self.filterPreReleaseVersion = filterPreReleaseVersion
                self.filterID = filterID
                self.sort = sort
                self.fieldsBuilds = fieldsBuilds
                self.limit = limit
                self.include = include
                self.fieldsAppEncryptionDeclarations = fieldsAppEncryptionDeclarations
                self.fieldsBetaAppReviewSubmissions = fieldsBetaAppReviewSubmissions
                self.fieldsBuildBetaDetails = fieldsBuildBetaDetails
                self.fieldsBuildIcons = fieldsBuildIcons
                self.fieldsPerfPowerMetrics = fieldsPerfPowerMetrics
                self.fieldsPreReleaseVersions = fieldsPreReleaseVersions
                self.fieldsAppStoreVersions = fieldsAppStoreVersions
                self.fieldsDiagnosticSignatures = fieldsDiagnosticSignatures
                self.fieldsBetaTesters = fieldsBetaTesters
                self.fieldsBetaBuildLocalizations = fieldsBetaBuildLocalizations
                self.fieldsApps = fieldsApps
                self.limitBetaBuildLocalizations = limitBetaBuildLocalizations
                self.limitIcons = limitIcons
                self.limitIndividualTesters = limitIndividualTesters
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[betaAppReviewSubmission.betaReviewState]", filterBetaAppReviewSubmissionBetaReviewState?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[expired]", filterExpired?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[preReleaseVersion.platform]", filterPreReleaseVersionPlatform?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[preReleaseVersion.version]", filterPreReleaseVersionVersion?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[processingState]", filterProcessingState?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[usesNonExemptEncryption]", filterUsesNonExemptEncryption?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[version]", filterVersion?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[app]", filterApp?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[appStoreVersion]", filterAppStoreVersion?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[betaGroups]", filterBetaGroups?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[preReleaseVersion]", filterPreReleaseVersion?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[id]", filterID?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("sort", sort?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appEncryptionDeclarations]", fieldsAppEncryptionDeclarations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaAppReviewSubmissions]", fieldsBetaAppReviewSubmissions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[buildBetaDetails]", fieldsBuildBetaDetails?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[buildIcons]", fieldsBuildIcons?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[perfPowerMetrics]", fieldsPerfPowerMetrics?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[preReleaseVersions]", fieldsPreReleaseVersions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appStoreVersions]", fieldsAppStoreVersions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[diagnosticSignatures]", fieldsDiagnosticSignatures?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaTesters]", fieldsBetaTesters?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaBuildLocalizations]", fieldsBetaBuildLocalizations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[betaBuildLocalizations]", limitBetaBuildLocalizations)
                query.addQueryItem("limit[icons]", limitIcons)
                query.addQueryItem("limit[individualTesters]", limitIndividualTesters)
                return query
            }
        }
    }
}

extension Paths.Builds {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/builds/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.BuildResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsBuilds: [FieldsBuilds]?
            public var include: [Include]?
            public var fieldsAppEncryptionDeclarations: [FieldsAppEncryptionDeclarations]?
            public var fieldsBetaAppReviewSubmissions: [FieldsBetaAppReviewSubmissions]?
            public var fieldsBuildBetaDetails: [FieldsBuildBetaDetails]?
            public var fieldsBuildIcons: [FieldsBuildIcons]?
            public var fieldsPerfPowerMetrics: [FieldsPerfPowerMetrics]?
            public var fieldsPreReleaseVersions: [FieldsPreReleaseVersions]?
            public var fieldsAppStoreVersions: [FieldsAppStoreVersions]?
            public var fieldsDiagnosticSignatures: [FieldsDiagnosticSignatures]?
            public var fieldsBetaTesters: [FieldsBetaTesters]?
            public var fieldsBetaBuildLocalizations: [FieldsBetaBuildLocalizations]?
            public var fieldsApps: [FieldsApps]?
            public var limitBetaBuildLocalizations: Int?
            public var limitIcons: Int?
            public var limitIndividualTesters: Int?

            public enum FieldsBuilds: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case betaGroups
                case buildBetaDetail
                case diagnosticSignatures
                case expirationDate
                case expired
                case iconAssetToken
                case icons
                case individualTesters
                case minOsVersion
                case perfPowerMetrics
                case preReleaseVersion
                case processingState
                case uploadedDate
                case usesNonExemptEncryption
                case version
            }

            public enum Include: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case buildBetaDetail
                case icons
                case individualTesters
                case preReleaseVersion
            }

            public enum FieldsAppEncryptionDeclarations: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclarationState
                case availableOnFrenchStore
                case builds
                case codeValue
                case containsProprietaryCryptography
                case containsThirdPartyCryptography
                case documentName
                case documentType
                case documentURL = "documentUrl"
                case exempt
                case platform
                case uploadedDate
                case usesEncryption
            }

            public enum FieldsBetaAppReviewSubmissions: String, Codable, CaseIterable {
                case betaReviewState
                case build
            }

            public enum FieldsBuildBetaDetails: String, Codable, CaseIterable {
                case autoNotifyEnabled
                case build
                case externalBuildState
                case internalBuildState
            }

            public enum FieldsBuildIcons: String, Codable, CaseIterable {
                case iconAsset
                case iconType
            }

            public enum FieldsPerfPowerMetrics: String, Codable, CaseIterable {
                case deviceType
                case metricType
                case platform
            }

            public enum FieldsPreReleaseVersions: String, Codable, CaseIterable {
                case app
                case builds
                case platform
                case version
            }

            public enum FieldsAppStoreVersions: String, Codable, CaseIterable {
                case ageRatingDeclaration
                case app
                case appStoreReviewDetail
                case appStoreState
                case appStoreVersionLocalizations
                case appStoreVersionPhasedRelease
                case appStoreVersionSubmission
                case build
                case copyright
                case createdDate
                case downloadable
                case earliestReleaseDate
                case idfaDeclaration
                case platform
                case releaseType
                case routingAppCoverage
                case usesIdfa
                case versionString
            }

            public enum FieldsDiagnosticSignatures: String, Codable, CaseIterable {
                case diagnosticType
                case logs
                case signature
                case weight
            }

            public enum FieldsBetaTesters: String, Codable, CaseIterable {
                case apps
                case betaGroups
                case builds
                case email
                case firstName
                case inviteType
                case lastName
            }

            public enum FieldsBetaBuildLocalizations: String, Codable, CaseIterable {
                case build
                case locale
                case whatsNew
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public init(fieldsBuilds: [FieldsBuilds]? = nil, include: [Include]? = nil, fieldsAppEncryptionDeclarations: [FieldsAppEncryptionDeclarations]? = nil, fieldsBetaAppReviewSubmissions: [FieldsBetaAppReviewSubmissions]? = nil, fieldsBuildBetaDetails: [FieldsBuildBetaDetails]? = nil, fieldsBuildIcons: [FieldsBuildIcons]? = nil, fieldsPerfPowerMetrics: [FieldsPerfPowerMetrics]? = nil, fieldsPreReleaseVersions: [FieldsPreReleaseVersions]? = nil, fieldsAppStoreVersions: [FieldsAppStoreVersions]? = nil, fieldsDiagnosticSignatures: [FieldsDiagnosticSignatures]? = nil, fieldsBetaTesters: [FieldsBetaTesters]? = nil, fieldsBetaBuildLocalizations: [FieldsBetaBuildLocalizations]? = nil, fieldsApps: [FieldsApps]? = nil, limitBetaBuildLocalizations: Int? = nil, limitIcons: Int? = nil, limitIndividualTesters: Int? = nil) {
                self.fieldsBuilds = fieldsBuilds
                self.include = include
                self.fieldsAppEncryptionDeclarations = fieldsAppEncryptionDeclarations
                self.fieldsBetaAppReviewSubmissions = fieldsBetaAppReviewSubmissions
                self.fieldsBuildBetaDetails = fieldsBuildBetaDetails
                self.fieldsBuildIcons = fieldsBuildIcons
                self.fieldsPerfPowerMetrics = fieldsPerfPowerMetrics
                self.fieldsPreReleaseVersions = fieldsPreReleaseVersions
                self.fieldsAppStoreVersions = fieldsAppStoreVersions
                self.fieldsDiagnosticSignatures = fieldsDiagnosticSignatures
                self.fieldsBetaTesters = fieldsBetaTesters
                self.fieldsBetaBuildLocalizations = fieldsBetaBuildLocalizations
                self.fieldsApps = fieldsApps
                self.limitBetaBuildLocalizations = limitBetaBuildLocalizations
                self.limitIcons = limitIcons
                self.limitIndividualTesters = limitIndividualTesters
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appEncryptionDeclarations]", fieldsAppEncryptionDeclarations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaAppReviewSubmissions]", fieldsBetaAppReviewSubmissions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[buildBetaDetails]", fieldsBuildBetaDetails?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[buildIcons]", fieldsBuildIcons?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[perfPowerMetrics]", fieldsPerfPowerMetrics?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[preReleaseVersions]", fieldsPreReleaseVersions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[appStoreVersions]", fieldsAppStoreVersions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[diagnosticSignatures]", fieldsDiagnosticSignatures?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaTesters]", fieldsBetaTesters?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[betaBuildLocalizations]", fieldsBetaBuildLocalizations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[betaBuildLocalizations]", limitBetaBuildLocalizations)
                query.addQueryItem("limit[icons]", limitIcons)
                query.addQueryItem("limit[individualTesters]", limitIndividualTesters)
                return query
            }
        }

        public func patch(_ body: AppStoreConnectAPI.BuildUpdateRequest) -> Request<AppStoreConnectAPI.BuildResponse> {
            .patch(path, body: body)
        }
    }
}

extension Paths.Builds.WithID {
    public var app: App {
        App(path: path + "/app")
    }

    public struct App {
        /// Path: `/v1/builds/{id}/app`
        public let path: String

        public func get(fieldsApps: [FieldsApps]? = nil) -> Request<AppStoreConnectAPI.AppResponse> {
            .get(path, query: makeGetQuery(fieldsApps))
        }

        private func makeGetQuery(_ fieldsApps: [FieldsApps]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsApps: String, Codable, CaseIterable {
            case appInfos
            case appStoreVersions
            case availableInNewTerritories
            case availableTerritories
            case betaAppLocalizations
            case betaAppReviewDetail
            case betaGroups
            case betaLicenseAgreement
            case betaTesters
            case builds
            case bundleID = "bundleId"
            case contentRightsDeclaration
            case endUserLicenseAgreement
            case gameCenterEnabledVersions
            case inAppPurchases
            case isOrEverWasMadeForKids
            case name
            case perfPowerMetrics
            case preOrder
            case preReleaseVersions
            case prices
            case primaryLocale
            case sku
        }
    }
}

extension Paths.Builds.WithID {
    public var appEncryptionDeclaration: AppEncryptionDeclaration {
        AppEncryptionDeclaration(path: path + "/appEncryptionDeclaration")
    }

    public struct AppEncryptionDeclaration {
        /// Path: `/v1/builds/{id}/appEncryptionDeclaration`
        public let path: String

        public func get(fieldsAppEncryptionDeclarations: [FieldsAppEncryptionDeclarations]? = nil) -> Request<AppStoreConnectAPI.AppEncryptionDeclarationResponse> {
            .get(path, query: makeGetQuery(fieldsAppEncryptionDeclarations))
        }

        private func makeGetQuery(_ fieldsAppEncryptionDeclarations: [FieldsAppEncryptionDeclarations]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[appEncryptionDeclarations]", fieldsAppEncryptionDeclarations?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsAppEncryptionDeclarations: String, Codable, CaseIterable {
            case app
            case appEncryptionDeclarationState
            case availableOnFrenchStore
            case builds
            case codeValue
            case containsProprietaryCryptography
            case containsThirdPartyCryptography
            case documentName
            case documentType
            case documentURL = "documentUrl"
            case exempt
            case platform
            case uploadedDate
            case usesEncryption
        }
    }
}

extension Paths.Builds.WithID {
    public var appStoreVersion: AppStoreVersion {
        AppStoreVersion(path: path + "/appStoreVersion")
    }

    public struct AppStoreVersion {
        /// Path: `/v1/builds/{id}/appStoreVersion`
        public let path: String

        public func get(fieldsAppStoreVersions: [FieldsAppStoreVersions]? = nil) -> Request<AppStoreConnectAPI.AppStoreVersionResponse> {
            .get(path, query: makeGetQuery(fieldsAppStoreVersions))
        }

        private func makeGetQuery(_ fieldsAppStoreVersions: [FieldsAppStoreVersions]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[appStoreVersions]", fieldsAppStoreVersions?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsAppStoreVersions: String, Codable, CaseIterable {
            case ageRatingDeclaration
            case app
            case appStoreReviewDetail
            case appStoreState
            case appStoreVersionLocalizations
            case appStoreVersionPhasedRelease
            case appStoreVersionSubmission
            case build
            case copyright
            case createdDate
            case downloadable
            case earliestReleaseDate
            case idfaDeclaration
            case platform
            case releaseType
            case routingAppCoverage
            case usesIdfa
            case versionString
        }
    }
}

extension Paths.Builds.WithID {
    public var betaAppReviewSubmission: BetaAppReviewSubmission {
        BetaAppReviewSubmission(path: path + "/betaAppReviewSubmission")
    }

    public struct BetaAppReviewSubmission {
        /// Path: `/v1/builds/{id}/betaAppReviewSubmission`
        public let path: String

        public func get(fieldsBetaAppReviewSubmissions: [FieldsBetaAppReviewSubmissions]? = nil) -> Request<AppStoreConnectAPI.BetaAppReviewSubmissionResponse> {
            .get(path, query: makeGetQuery(fieldsBetaAppReviewSubmissions))
        }

        private func makeGetQuery(_ fieldsBetaAppReviewSubmissions: [FieldsBetaAppReviewSubmissions]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[betaAppReviewSubmissions]", fieldsBetaAppReviewSubmissions?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsBetaAppReviewSubmissions: String, Codable, CaseIterable {
            case betaReviewState
            case build
        }
    }
}

extension Paths.Builds.WithID {
    public var betaBuildLocalizations: BetaBuildLocalizations {
        BetaBuildLocalizations(path: path + "/betaBuildLocalizations")
    }

    public struct BetaBuildLocalizations {
        /// Path: `/v1/builds/{id}/betaBuildLocalizations`
        public let path: String

        public func get(fieldsBetaBuildLocalizations: [FieldsBetaBuildLocalizations]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.BetaBuildLocalizationsResponse> {
            .get(path, query: makeGetQuery(fieldsBetaBuildLocalizations, limit))
        }

        private func makeGetQuery(_ fieldsBetaBuildLocalizations: [FieldsBetaBuildLocalizations]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[betaBuildLocalizations]", fieldsBetaBuildLocalizations?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsBetaBuildLocalizations: String, Codable, CaseIterable {
            case build
            case locale
            case whatsNew
        }
    }
}

extension Paths.Builds.WithID {
    public var buildBetaDetail: BuildBetaDetail {
        BuildBetaDetail(path: path + "/buildBetaDetail")
    }

    public struct BuildBetaDetail {
        /// Path: `/v1/builds/{id}/buildBetaDetail`
        public let path: String

        public func get(fieldsBuildBetaDetails: [FieldsBuildBetaDetails]? = nil) -> Request<AppStoreConnectAPI.BuildBetaDetailResponse> {
            .get(path, query: makeGetQuery(fieldsBuildBetaDetails))
        }

        private func makeGetQuery(_ fieldsBuildBetaDetails: [FieldsBuildBetaDetails]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[buildBetaDetails]", fieldsBuildBetaDetails?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsBuildBetaDetails: String, Codable, CaseIterable {
            case autoNotifyEnabled
            case build
            case externalBuildState
            case internalBuildState
        }
    }
}

extension Paths.Builds.WithID {
    public var diagnosticSignatures: DiagnosticSignatures {
        DiagnosticSignatures(path: path + "/diagnosticSignatures")
    }

    public struct DiagnosticSignatures {
        /// Path: `/v1/builds/{id}/diagnosticSignatures`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.DiagnosticSignaturesResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterDiagnosticType: [FilterDiagnosticType]?
            public var fieldsDiagnosticSignatures: [FieldsDiagnosticSignatures]?
            public var limit: Int?

            public enum FilterDiagnosticType: String, Codable, CaseIterable {
                case diskWrites = "DISK_WRITES"
            }

            public enum FieldsDiagnosticSignatures: String, Codable, CaseIterable {
                case diagnosticType
                case logs
                case signature
                case weight
            }

            public init(filterDiagnosticType: [FilterDiagnosticType]? = nil, fieldsDiagnosticSignatures: [FieldsDiagnosticSignatures]? = nil, limit: Int? = nil) {
                self.filterDiagnosticType = filterDiagnosticType
                self.fieldsDiagnosticSignatures = fieldsDiagnosticSignatures
                self.limit = limit
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[diagnosticType]", filterDiagnosticType?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[diagnosticSignatures]", fieldsDiagnosticSignatures?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                return query
            }
        }
    }
}

extension Paths.Builds.WithID {
    public var icons: Icons {
        Icons(path: path + "/icons")
    }

    public struct Icons {
        /// Path: `/v1/builds/{id}/icons`
        public let path: String

        public func get(fieldsBuildIcons: [FieldsBuildIcons]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.BuildIconsResponse> {
            .get(path, query: makeGetQuery(fieldsBuildIcons, limit))
        }

        private func makeGetQuery(_ fieldsBuildIcons: [FieldsBuildIcons]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[buildIcons]", fieldsBuildIcons?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsBuildIcons: String, Codable, CaseIterable {
            case iconAsset
            case iconType
        }
    }
}

extension Paths.Builds.WithID {
    public var individualTesters: IndividualTesters {
        IndividualTesters(path: path + "/individualTesters")
    }

    public struct IndividualTesters {
        /// Path: `/v1/builds/{id}/individualTesters`
        public let path: String

        public func get(fieldsBetaTesters: [FieldsBetaTesters]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.BetaTestersResponse> {
            .get(path, query: makeGetQuery(fieldsBetaTesters, limit))
        }

        private func makeGetQuery(_ fieldsBetaTesters: [FieldsBetaTesters]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[betaTesters]", fieldsBetaTesters?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsBetaTesters: String, Codable, CaseIterable {
            case apps
            case betaGroups
            case builds
            case email
            case firstName
            case inviteType
            case lastName
        }
    }
}

extension Paths.Builds.WithID {
    public var perfPowerMetrics: PerfPowerMetrics {
        PerfPowerMetrics(path: path + "/perfPowerMetrics")
    }

    public struct PerfPowerMetrics {
        /// Path: `/v1/builds/{id}/perfPowerMetrics`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.PerfPowerMetricsResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterDeviceType: [String]?
            public var filterMetricType: [FilterMetricType]?
            public var filterPlatform: [FilterPlatform]?

            public enum FilterMetricType: String, Codable, CaseIterable {
                case disk = "DISK"
                case hang = "HANG"
                case battery = "BATTERY"
                case launch = "LAUNCH"
                case memory = "MEMORY"
                case animation = "ANIMATION"
                case termination = "TERMINATION"
            }

            public enum FilterPlatform: String, Codable, CaseIterable {
                case ios = "IOS"
            }

            public init(filterDeviceType: [String]? = nil, filterMetricType: [FilterMetricType]? = nil, filterPlatform: [FilterPlatform]? = nil) {
                self.filterDeviceType = filterDeviceType
                self.filterMetricType = filterMetricType
                self.filterPlatform = filterPlatform
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[deviceType]", filterDeviceType?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[metricType]", filterMetricType?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[platform]", filterPlatform?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.Builds.WithID {
    public var preReleaseVersion: PreReleaseVersion {
        PreReleaseVersion(path: path + "/preReleaseVersion")
    }

    public struct PreReleaseVersion {
        /// Path: `/v1/builds/{id}/preReleaseVersion`
        public let path: String

        public func get(fieldsPreReleaseVersions: [FieldsPreReleaseVersions]? = nil) -> Request<AppStoreConnectAPI.PrereleaseVersionResponse> {
            .get(path, query: makeGetQuery(fieldsPreReleaseVersions))
        }

        private func makeGetQuery(_ fieldsPreReleaseVersions: [FieldsPreReleaseVersions]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[preReleaseVersions]", fieldsPreReleaseVersions?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsPreReleaseVersions: String, Codable, CaseIterable {
            case app
            case builds
            case platform
            case version
        }
    }
}

extension Paths.Builds.WithID {
    public var relationships: Relationships {
        Relationships(path: path + "/relationships")
    }

    public struct Relationships {
        /// Path: `/v1/builds/{id}/relationships`
        public let path: String
    }
}

extension Paths.Builds.WithID.Relationships {
    public var appEncryptionDeclaration: AppEncryptionDeclaration {
        AppEncryptionDeclaration(path: path + "/appEncryptionDeclaration")
    }

    public struct AppEncryptionDeclaration {
        /// Path: `/v1/builds/{id}/relationships/appEncryptionDeclaration`
        public let path: String

        public var get: Request<AppStoreConnectAPI.BuildAppEncryptionDeclarationLinkageResponse> {
            .get(path)
        }

        public func patch(_ body: AppStoreConnectAPI.BuildAppEncryptionDeclarationLinkageRequest) -> Request<Void> {
            .patch(path, body: body)
        }
    }
}

extension Paths.Builds.WithID.Relationships {
    public var betaGroups: BetaGroups {
        BetaGroups(path: path + "/betaGroups")
    }

    public struct BetaGroups {
        /// Path: `/v1/builds/{id}/relationships/betaGroups`
        public let path: String

        public func post(_ body: AppStoreConnectAPI.BuildBetaGroupsLinkagesRequest) -> Request<Void> {
            .post(path, body: body)
        }

        public func delete(_ body: AppStoreConnectAPI.BuildBetaGroupsLinkagesRequest) -> Request<Void> {
            .delete(path, body: body)
        }
    }
}

extension Paths.Builds.WithID.Relationships {
    public var individualTesters: IndividualTesters {
        IndividualTesters(path: path + "/individualTesters")
    }

    public struct IndividualTesters {
        /// Path: `/v1/builds/{id}/relationships/individualTesters`
        public let path: String

        public func get(limit: Int? = nil) -> Request<AppStoreConnectAPI.BuildIndividualTestersLinkagesResponse> {
            .get(path, query: makeGetQuery(limit))
        }

        private func makeGetQuery(_ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("limit", limit)
            return query
        }

        public func post(_ body: AppStoreConnectAPI.BuildIndividualTestersLinkagesRequest) -> Request<Void> {
            .post(path, body: body)
        }

        public func delete(_ body: AppStoreConnectAPI.BuildIndividualTestersLinkagesRequest) -> Request<Void> {
            .delete(path, body: body)
        }
    }
}

extension Paths {
    public static var bundleIDCapabilities: BundleIDCapabilities {
        BundleIDCapabilities(path: "/v1/bundleIdCapabilities")
    }

    public struct BundleIDCapabilities {
        /// Path: `/v1/bundleIdCapabilities`
        public let path: String

        public func post(_ body: AppStoreConnectAPI.BundleIDCapabilityCreateRequest) -> Request<AppStoreConnectAPI.BundleIDCapabilityResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.BundleIDCapabilities {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/bundleIdCapabilities/{id}`
        public let path: String

        public func patch(_ body: AppStoreConnectAPI.BundleIDCapabilityUpdateRequest) -> Request<AppStoreConnectAPI.BundleIDCapabilityResponse> {
            .patch(path, body: body)
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var bundleIDs: BundleIDs {
        BundleIDs(path: "/v1/bundleIds")
    }

    public struct BundleIDs {
        /// Path: `/v1/bundleIds`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.BundleIDsResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterIdentifier: [String]?
            public var filterName: [String]?
            public var filterPlatform: [FilterPlatform]?
            public var filterSeedID: [String]?
            public var filterID: [String]?
            public var sort: [Sort]?
            public var fieldsBundleIDs: [FieldsBundleIDs]?
            public var limit: Int?
            public var include: [Include]?
            public var fieldsBundleIDCapabilities: [FieldsBundleIDCapabilities]?
            public var fieldsProfiles: [FieldsProfiles]?
            public var fieldsApps: [FieldsApps]?
            public var limitBundleIDCapabilities: Int?
            public var limitProfiles: Int?

            public enum FilterPlatform: String, Codable, CaseIterable {
                case ios = "IOS"
                case macOs = "MAC_OS"
            }

            public enum Sort: String, Codable, CaseIterable {
                case id
                case minusid = "-id"
                case identifier
                case minusidentifier = "-identifier"
                case name
                case minusname = "-name"
                case platform
                case minusplatform = "-platform"
                case seedID = "seedId"
                case minusseedID = "-seedId"
            }

            public enum FieldsBundleIDs: String, Codable, CaseIterable {
                case app
                case bundleIDCapabilities = "bundleIdCapabilities"
                case identifier
                case name
                case platform
                case profiles
                case seedID = "seedId"
            }

            public enum Include: String, Codable, CaseIterable {
                case app
                case bundleIDCapabilities = "bundleIdCapabilities"
                case profiles
            }

            public enum FieldsBundleIDCapabilities: String, Codable, CaseIterable {
                case bundleID = "bundleId"
                case capabilityType
                case settings
            }

            public enum FieldsProfiles: String, Codable, CaseIterable {
                case bundleID = "bundleId"
                case certificates
                case createdDate
                case devices
                case expirationDate
                case name
                case platform
                case profileContent
                case profileState
                case profileType
                case uuid
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public init(filterIdentifier: [String]? = nil, filterName: [String]? = nil, filterPlatform: [FilterPlatform]? = nil, filterSeedID: [String]? = nil, filterID: [String]? = nil, sort: [Sort]? = nil, fieldsBundleIDs: [FieldsBundleIDs]? = nil, limit: Int? = nil, include: [Include]? = nil, fieldsBundleIDCapabilities: [FieldsBundleIDCapabilities]? = nil, fieldsProfiles: [FieldsProfiles]? = nil, fieldsApps: [FieldsApps]? = nil, limitBundleIDCapabilities: Int? = nil, limitProfiles: Int? = nil) {
                self.filterIdentifier = filterIdentifier
                self.filterName = filterName
                self.filterPlatform = filterPlatform
                self.filterSeedID = filterSeedID
                self.filterID = filterID
                self.sort = sort
                self.fieldsBundleIDs = fieldsBundleIDs
                self.limit = limit
                self.include = include
                self.fieldsBundleIDCapabilities = fieldsBundleIDCapabilities
                self.fieldsProfiles = fieldsProfiles
                self.fieldsApps = fieldsApps
                self.limitBundleIDCapabilities = limitBundleIDCapabilities
                self.limitProfiles = limitProfiles
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[identifier]", filterIdentifier?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[name]", filterName?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[platform]", filterPlatform?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[seedId]", filterSeedID?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[id]", filterID?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("sort", sort?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[bundleIds]", fieldsBundleIDs?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[bundleIdCapabilities]", fieldsBundleIDCapabilities?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[profiles]", fieldsProfiles?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[bundleIdCapabilities]", limitBundleIDCapabilities)
                query.addQueryItem("limit[profiles]", limitProfiles)
                return query
            }
        }

        public func post(_ body: AppStoreConnectAPI.BundleIDCreateRequest) -> Request<AppStoreConnectAPI.BundleIDResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.BundleIDs {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/bundleIds/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.BundleIDResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsBundleIDs: [FieldsBundleIDs]?
            public var include: [Include]?
            public var fieldsBundleIDCapabilities: [FieldsBundleIDCapabilities]?
            public var fieldsProfiles: [FieldsProfiles]?
            public var fieldsApps: [FieldsApps]?
            public var limitBundleIDCapabilities: Int?
            public var limitProfiles: Int?

            public enum FieldsBundleIDs: String, Codable, CaseIterable {
                case app
                case bundleIDCapabilities = "bundleIdCapabilities"
                case identifier
                case name
                case platform
                case profiles
                case seedID = "seedId"
            }

            public enum Include: String, Codable, CaseIterable {
                case app
                case bundleIDCapabilities = "bundleIdCapabilities"
                case profiles
            }

            public enum FieldsBundleIDCapabilities: String, Codable, CaseIterable {
                case bundleID = "bundleId"
                case capabilityType
                case settings
            }

            public enum FieldsProfiles: String, Codable, CaseIterable {
                case bundleID = "bundleId"
                case certificates
                case createdDate
                case devices
                case expirationDate
                case name
                case platform
                case profileContent
                case profileState
                case profileType
                case uuid
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public init(fieldsBundleIDs: [FieldsBundleIDs]? = nil, include: [Include]? = nil, fieldsBundleIDCapabilities: [FieldsBundleIDCapabilities]? = nil, fieldsProfiles: [FieldsProfiles]? = nil, fieldsApps: [FieldsApps]? = nil, limitBundleIDCapabilities: Int? = nil, limitProfiles: Int? = nil) {
                self.fieldsBundleIDs = fieldsBundleIDs
                self.include = include
                self.fieldsBundleIDCapabilities = fieldsBundleIDCapabilities
                self.fieldsProfiles = fieldsProfiles
                self.fieldsApps = fieldsApps
                self.limitBundleIDCapabilities = limitBundleIDCapabilities
                self.limitProfiles = limitProfiles
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[bundleIds]", fieldsBundleIDs?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[bundleIdCapabilities]", fieldsBundleIDCapabilities?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[profiles]", fieldsProfiles?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[bundleIdCapabilities]", limitBundleIDCapabilities)
                query.addQueryItem("limit[profiles]", limitProfiles)
                return query
            }
        }

        public func patch(_ body: AppStoreConnectAPI.BundleIDUpdateRequest) -> Request<AppStoreConnectAPI.BundleIDResponse> {
            .patch(path, body: body)
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.BundleIDs.WithID {
    public var app: App {
        App(path: path + "/app")
    }

    public struct App {
        /// Path: `/v1/bundleIds/{id}/app`
        public let path: String

        public func get(fieldsApps: [FieldsApps]? = nil) -> Request<AppStoreConnectAPI.AppResponse> {
            .get(path, query: makeGetQuery(fieldsApps))
        }

        private func makeGetQuery(_ fieldsApps: [FieldsApps]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsApps: String, Codable, CaseIterable {
            case appInfos
            case appStoreVersions
            case availableInNewTerritories
            case availableTerritories
            case betaAppLocalizations
            case betaAppReviewDetail
            case betaGroups
            case betaLicenseAgreement
            case betaTesters
            case builds
            case bundleID = "bundleId"
            case contentRightsDeclaration
            case endUserLicenseAgreement
            case gameCenterEnabledVersions
            case inAppPurchases
            case isOrEverWasMadeForKids
            case name
            case perfPowerMetrics
            case preOrder
            case preReleaseVersions
            case prices
            case primaryLocale
            case sku
        }
    }
}

extension Paths.BundleIDs.WithID {
    public var bundleIDCapabilities: BundleIDCapabilities {
        BundleIDCapabilities(path: path + "/bundleIdCapabilities")
    }

    public struct BundleIDCapabilities {
        /// Path: `/v1/bundleIds/{id}/bundleIdCapabilities`
        public let path: String

        public func get(fieldsBundleIDCapabilities: [FieldsBundleIDCapabilities]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.BundleIDCapabilitiesResponse> {
            .get(path, query: makeGetQuery(fieldsBundleIDCapabilities, limit))
        }

        private func makeGetQuery(_ fieldsBundleIDCapabilities: [FieldsBundleIDCapabilities]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[bundleIdCapabilities]", fieldsBundleIDCapabilities?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsBundleIDCapabilities: String, Codable, CaseIterable {
            case bundleID = "bundleId"
            case capabilityType
            case settings
        }
    }
}

extension Paths.BundleIDs.WithID {
    public var profiles: Profiles {
        Profiles(path: path + "/profiles")
    }

    public struct Profiles {
        /// Path: `/v1/bundleIds/{id}/profiles`
        public let path: String

        public func get(fieldsProfiles: [FieldsProfiles]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.ProfilesResponse> {
            .get(path, query: makeGetQuery(fieldsProfiles, limit))
        }

        private func makeGetQuery(_ fieldsProfiles: [FieldsProfiles]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[profiles]", fieldsProfiles?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsProfiles: String, Codable, CaseIterable {
            case bundleID = "bundleId"
            case certificates
            case createdDate
            case devices
            case expirationDate
            case name
            case platform
            case profileContent
            case profileState
            case profileType
            case uuid
        }
    }
}

extension Paths {
    public static var certificates: Certificates {
        Certificates(path: "/v1/certificates")
    }

    public struct Certificates {
        /// Path: `/v1/certificates`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.CertificatesResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterCertificateType: [FilterCertificateType]?
            public var filterDisplayName: [String]?
            public var filterSerialNumber: [String]?
            public var filterID: [String]?
            public var sort: [Sort]?
            public var fieldsCertificates: [FieldsCertificates]?
            public var limit: Int?

            public enum FilterCertificateType: String, Codable, CaseIterable {
                case iosDevelopment = "IOS_DEVELOPMENT"
                case iosDistribution = "IOS_DISTRIBUTION"
                case macAppDistribution = "MAC_APP_DISTRIBUTION"
                case macInstallerDistribution = "MAC_INSTALLER_DISTRIBUTION"
                case macAppDevelopment = "MAC_APP_DEVELOPMENT"
                case developerIDKext = "DEVELOPER_ID_KEXT"
                case developerIDApplication = "DEVELOPER_ID_APPLICATION"
                case development = "DEVELOPMENT"
                case distribution = "DISTRIBUTION"
            }

            public enum Sort: String, Codable, CaseIterable {
                case certificateType
                case minuscertificateType = "-certificateType"
                case displayName
                case minusdisplayName = "-displayName"
                case id
                case minusid = "-id"
                case serialNumber
                case minusserialNumber = "-serialNumber"
            }

            public enum FieldsCertificates: String, Codable, CaseIterable {
                case certificateContent
                case certificateType
                case csrContent
                case displayName
                case expirationDate
                case name
                case platform
                case serialNumber
            }

            public init(filterCertificateType: [FilterCertificateType]? = nil, filterDisplayName: [String]? = nil, filterSerialNumber: [String]? = nil, filterID: [String]? = nil, sort: [Sort]? = nil, fieldsCertificates: [FieldsCertificates]? = nil, limit: Int? = nil) {
                self.filterCertificateType = filterCertificateType
                self.filterDisplayName = filterDisplayName
                self.filterSerialNumber = filterSerialNumber
                self.filterID = filterID
                self.sort = sort
                self.fieldsCertificates = fieldsCertificates
                self.limit = limit
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[certificateType]", filterCertificateType?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[displayName]", filterDisplayName?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[serialNumber]", filterSerialNumber?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[id]", filterID?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("sort", sort?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[certificates]", fieldsCertificates?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                return query
            }
        }

        public func post(_ body: AppStoreConnectAPI.CertificateCreateRequest) -> Request<AppStoreConnectAPI.CertificateResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Certificates {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/certificates/{id}`
        public let path: String

        public func get(fieldsCertificates: [FieldsCertificates]? = nil) -> Request<AppStoreConnectAPI.CertificateResponse> {
            .get(path, query: makeGetQuery(fieldsCertificates))
        }

        private func makeGetQuery(_ fieldsCertificates: [FieldsCertificates]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[certificates]", fieldsCertificates?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsCertificates: String, Codable, CaseIterable {
            case certificateContent
            case certificateType
            case csrContent
            case displayName
            case expirationDate
            case name
            case platform
            case serialNumber
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var devices: Devices {
        Devices(path: "/v1/devices")
    }

    public struct Devices {
        /// Path: `/v1/devices`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.DevicesResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterName: [String]?
            public var filterPlatform: [FilterPlatform]?
            public var filterStatus: [FilterStatus]?
            public var filterUdid: [String]?
            public var filterID: [String]?
            public var sort: [Sort]?
            public var fieldsDevices: [FieldsDevices]?
            public var limit: Int?

            public enum FilterPlatform: String, Codable, CaseIterable {
                case ios = "IOS"
                case macOs = "MAC_OS"
            }

            public enum FilterStatus: String, Codable, CaseIterable {
                case enabled = "ENABLED"
                case disabled = "DISABLED"
            }

            public enum Sort: String, Codable, CaseIterable {
                case id
                case minusid = "-id"
                case name
                case minusname = "-name"
                case platform
                case minusplatform = "-platform"
                case status
                case minusstatus = "-status"
                case udid
                case minusudid = "-udid"
            }

            public enum FieldsDevices: String, Codable, CaseIterable {
                case addedDate
                case deviceClass
                case model
                case name
                case platform
                case status
                case udid
            }

            public init(filterName: [String]? = nil, filterPlatform: [FilterPlatform]? = nil, filterStatus: [FilterStatus]? = nil, filterUdid: [String]? = nil, filterID: [String]? = nil, sort: [Sort]? = nil, fieldsDevices: [FieldsDevices]? = nil, limit: Int? = nil) {
                self.filterName = filterName
                self.filterPlatform = filterPlatform
                self.filterStatus = filterStatus
                self.filterUdid = filterUdid
                self.filterID = filterID
                self.sort = sort
                self.fieldsDevices = fieldsDevices
                self.limit = limit
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[name]", filterName?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[platform]", filterPlatform?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[status]", filterStatus?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[udid]", filterUdid?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[id]", filterID?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("sort", sort?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[devices]", fieldsDevices?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                return query
            }
        }

        public func post(_ body: AppStoreConnectAPI.DeviceCreateRequest) -> Request<AppStoreConnectAPI.DeviceResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Devices {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/devices/{id}`
        public let path: String

        public func get(fieldsDevices: [FieldsDevices]? = nil) -> Request<AppStoreConnectAPI.DeviceResponse> {
            .get(path, query: makeGetQuery(fieldsDevices))
        }

        private func makeGetQuery(_ fieldsDevices: [FieldsDevices]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[devices]", fieldsDevices?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsDevices: String, Codable, CaseIterable {
            case addedDate
            case deviceClass
            case model
            case name
            case platform
            case status
            case udid
        }

        public func patch(_ body: AppStoreConnectAPI.DeviceUpdateRequest) -> Request<AppStoreConnectAPI.DeviceResponse> {
            .patch(path, body: body)
        }
    }
}

extension Paths {
    public static var diagnosticSignatures: DiagnosticSignatures {
        DiagnosticSignatures(path: "/v1/diagnosticSignatures")
    }

    public struct DiagnosticSignatures {
        /// Path: `/v1/diagnosticSignatures`
        public let path: String
    }
}

extension Paths.DiagnosticSignatures {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/diagnosticSignatures/{id}`
        public let path: String
    }
}

extension Paths.DiagnosticSignatures.WithID {
    public var logs: Logs {
        Logs(path: path + "/logs")
    }

    public struct Logs {
        /// Path: `/v1/diagnosticSignatures/{id}/logs`
        public let path: String

        public func get(limit: Int? = nil) -> Request<AppStoreConnectAPI.DiagnosticLogsResponse> {
            .get(path, query: makeGetQuery(limit))
        }

        private func makeGetQuery(_ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("limit", limit)
            return query
        }
    }
}

extension Paths {
    public static var endUserLicenseAgreements: EndUserLicenseAgreements {
        EndUserLicenseAgreements(path: "/v1/endUserLicenseAgreements")
    }

    public struct EndUserLicenseAgreements {
        /// Path: `/v1/endUserLicenseAgreements`
        public let path: String

        public func post(_ body: AppStoreConnectAPI.EndUserLicenseAgreementCreateRequest) -> Request<AppStoreConnectAPI.EndUserLicenseAgreementResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.EndUserLicenseAgreements {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/endUserLicenseAgreements/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.EndUserLicenseAgreementResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsEndUserLicenseAgreements: [FieldsEndUserLicenseAgreements]?
            public var include: [Include]?
            public var fieldsTerritories: [FieldsTerritories]?
            public var limitTerritories: Int?

            public enum FieldsEndUserLicenseAgreements: String, Codable, CaseIterable {
                case agreementText
                case app
                case territories
            }

            public enum Include: String, Codable, CaseIterable {
                case app
                case territories
            }

            public enum FieldsTerritories: String, Codable, CaseIterable {
                case currency
            }

            public init(fieldsEndUserLicenseAgreements: [FieldsEndUserLicenseAgreements]? = nil, include: [Include]? = nil, fieldsTerritories: [FieldsTerritories]? = nil, limitTerritories: Int? = nil) {
                self.fieldsEndUserLicenseAgreements = fieldsEndUserLicenseAgreements
                self.include = include
                self.fieldsTerritories = fieldsTerritories
                self.limitTerritories = limitTerritories
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[endUserLicenseAgreements]", fieldsEndUserLicenseAgreements?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[territories]", fieldsTerritories?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[territories]", limitTerritories)
                return query
            }
        }

        public func patch(_ body: AppStoreConnectAPI.EndUserLicenseAgreementUpdateRequest) -> Request<AppStoreConnectAPI.EndUserLicenseAgreementResponse> {
            .patch(path, body: body)
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.EndUserLicenseAgreements.WithID {
    public var territories: Territories {
        Territories(path: path + "/territories")
    }

    public struct Territories {
        /// Path: `/v1/endUserLicenseAgreements/{id}/territories`
        public let path: String

        public func get(fieldsTerritories: [FieldsTerritories]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.TerritoriesResponse> {
            .get(path, query: makeGetQuery(fieldsTerritories, limit))
        }

        private func makeGetQuery(_ fieldsTerritories: [FieldsTerritories]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[territories]", fieldsTerritories?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsTerritories: String, Codable, CaseIterable {
            case currency
        }
    }
}

extension Paths {
    public static var financeReports: FinanceReports {
        FinanceReports(path: "/v1/financeReports")
    }

    public struct FinanceReports {
        /// Path: `/v1/financeReports`
        public let path: String

        public func get(parameters: GetParameters) -> Request<Data> {
            .get(path, query: parameters.asQuery())
        }

        public struct GetParameters {
            public var filterRegionCode: [String]
            public var filterReportDate: [String]
            public var filterReportType: [FilterReportType]
            public var filterVendorNumber: [String]

            public enum FilterReportType: String, Codable, CaseIterable {
                case financial = "FINANCIAL"
                case financeDetail = "FINANCE_DETAIL"
            }

            public init(filterRegionCode: [String], filterReportDate: [String], filterReportType: [FilterReportType], filterVendorNumber: [String]) {
                self.filterRegionCode = filterRegionCode
                self.filterReportDate = filterReportDate
                self.filterReportType = filterReportType
                self.filterVendorNumber = filterVendorNumber
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[regionCode]", filterRegionCode.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[reportDate]", filterReportDate.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[reportType]", filterReportType.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[vendorNumber]", filterVendorNumber.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths {
    public static var gameCenterEnabledVersions: GameCenterEnabledVersions {
        GameCenterEnabledVersions(path: "/v1/gameCenterEnabledVersions")
    }

    public struct GameCenterEnabledVersions {
        /// Path: `/v1/gameCenterEnabledVersions`
        public let path: String
    }
}

extension Paths.GameCenterEnabledVersions {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/gameCenterEnabledVersions/{id}`
        public let path: String
    }
}

extension Paths.GameCenterEnabledVersions.WithID {
    public var compatibleVersions: CompatibleVersions {
        CompatibleVersions(path: path + "/compatibleVersions")
    }

    public struct CompatibleVersions {
        /// Path: `/v1/gameCenterEnabledVersions/{id}/compatibleVersions`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.GameCenterEnabledVersionsResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterPlatform: [FilterPlatform]?
            public var filterVersionString: [String]?
            public var filterApp: [String]?
            public var filterID: [String]?
            public var sort: [Sort]?
            public var fieldsGameCenterEnabledVersions: [FieldsGameCenterEnabledVersions]?
            public var fieldsApps: [FieldsApps]?
            public var limit: Int?
            public var include: [Include]?

            public enum FilterPlatform: String, Codable, CaseIterable {
                case ios = "IOS"
                case macOs = "MAC_OS"
                case tvOs = "TV_OS"
            }

            public enum Sort: String, Codable, CaseIterable {
                case versionString
                case minusversionString = "-versionString"
            }

            public enum FieldsGameCenterEnabledVersions: String, Codable, CaseIterable {
                case app
                case compatibleVersions
                case iconAsset
                case platform
                case versionString
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public enum Include: String, Codable, CaseIterable {
                case app
                case compatibleVersions
            }

            public init(filterPlatform: [FilterPlatform]? = nil, filterVersionString: [String]? = nil, filterApp: [String]? = nil, filterID: [String]? = nil, sort: [Sort]? = nil, fieldsGameCenterEnabledVersions: [FieldsGameCenterEnabledVersions]? = nil, fieldsApps: [FieldsApps]? = nil, limit: Int? = nil, include: [Include]? = nil) {
                self.filterPlatform = filterPlatform
                self.filterVersionString = filterVersionString
                self.filterApp = filterApp
                self.filterID = filterID
                self.sort = sort
                self.fieldsGameCenterEnabledVersions = fieldsGameCenterEnabledVersions
                self.fieldsApps = fieldsApps
                self.limit = limit
                self.include = include
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[platform]", filterPlatform?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[versionString]", filterVersionString?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[app]", filterApp?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[id]", filterID?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("sort", sort?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[gameCenterEnabledVersions]", fieldsGameCenterEnabledVersions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths.GameCenterEnabledVersions.WithID {
    public var relationships: Relationships {
        Relationships(path: path + "/relationships")
    }

    public struct Relationships {
        /// Path: `/v1/gameCenterEnabledVersions/{id}/relationships`
        public let path: String
    }
}

extension Paths.GameCenterEnabledVersions.WithID.Relationships {
    public var compatibleVersions: CompatibleVersions {
        CompatibleVersions(path: path + "/compatibleVersions")
    }

    public struct CompatibleVersions {
        /// Path: `/v1/gameCenterEnabledVersions/{id}/relationships/compatibleVersions`
        public let path: String

        public func get(limit: Int? = nil) -> Request<AppStoreConnectAPI.GameCenterEnabledVersionCompatibleVersionsLinkagesResponse> {
            .get(path, query: makeGetQuery(limit))
        }

        private func makeGetQuery(_ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("limit", limit)
            return query
        }

        public func post(_ body: AppStoreConnectAPI.GameCenterEnabledVersionCompatibleVersionsLinkagesRequest) -> Request<Void> {
            .post(path, body: body)
        }

        public func patch(_ body: AppStoreConnectAPI.GameCenterEnabledVersionCompatibleVersionsLinkagesRequest) -> Request<Void> {
            .patch(path, body: body)
        }

        public func delete(_ body: AppStoreConnectAPI.GameCenterEnabledVersionCompatibleVersionsLinkagesRequest) -> Request<Void> {
            .delete(path, body: body)
        }
    }
}

extension Paths {
    public static var idfaDeclarations: IdfaDeclarations {
        IdfaDeclarations(path: "/v1/idfaDeclarations")
    }

    public struct IdfaDeclarations {
        /// Path: `/v1/idfaDeclarations`
        public let path: String

        public func post(_ body: AppStoreConnectAPI.IdfaDeclarationCreateRequest) -> Request<AppStoreConnectAPI.IdfaDeclarationResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.IdfaDeclarations {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/idfaDeclarations/{id}`
        public let path: String

        public func patch(_ body: AppStoreConnectAPI.IdfaDeclarationUpdateRequest) -> Request<AppStoreConnectAPI.IdfaDeclarationResponse> {
            .patch(path, body: body)
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var inAppPurchases: InAppPurchases {
        InAppPurchases(path: "/v1/inAppPurchases")
    }

    public struct InAppPurchases {
        /// Path: `/v1/inAppPurchases`
        public let path: String
    }
}

extension Paths.InAppPurchases {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/inAppPurchases/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.InAppPurchaseResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsInAppPurchases: [FieldsInAppPurchases]?
            public var include: [Include]?
            public var limitApps: Int?

            public enum FieldsInAppPurchases: String, Codable, CaseIterable {
                case apps
                case inAppPurchaseType
                case productID = "productId"
                case referenceName
                case state
            }

            public enum Include: String, Codable, CaseIterable {
                case apps
            }

            public init(fieldsInAppPurchases: [FieldsInAppPurchases]? = nil, include: [Include]? = nil, limitApps: Int? = nil) {
                self.fieldsInAppPurchases = fieldsInAppPurchases
                self.include = include
                self.limitApps = limitApps
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[inAppPurchases]", fieldsInAppPurchases?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[apps]", limitApps)
                return query
            }
        }
    }
}

extension Paths {
    public static var preReleaseVersions: PreReleaseVersions {
        PreReleaseVersions(path: "/v1/preReleaseVersions")
    }

    public struct PreReleaseVersions {
        /// Path: `/v1/preReleaseVersions`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.PreReleaseVersionsResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterBuildsExpired: [String]?
            public var filterBuildsProcessingState: [FilterBuildsProcessingState]?
            public var filterPlatform: [FilterPlatform]?
            public var filterVersion: [String]?
            public var filterApp: [String]?
            public var filterBuilds: [String]?
            public var sort: [Sort]?
            public var fieldsPreReleaseVersions: [FieldsPreReleaseVersions]?
            public var limit: Int?
            public var include: [Include]?
            public var fieldsBuilds: [FieldsBuilds]?
            public var fieldsApps: [FieldsApps]?
            public var limitBuilds: Int?

            public enum FilterBuildsProcessingState: String, Codable, CaseIterable {
                case processing = "PROCESSING"
                case failed = "FAILED"
                case invalid = "INVALID"
                case valid = "VALID"
            }

            public enum FilterPlatform: String, Codable, CaseIterable {
                case ios = "IOS"
                case macOs = "MAC_OS"
                case tvOs = "TV_OS"
            }

            public enum Sort: String, Codable, CaseIterable {
                case version
                case minusversion = "-version"
            }

            public enum FieldsPreReleaseVersions: String, Codable, CaseIterable {
                case app
                case builds
                case platform
                case version
            }

            public enum Include: String, Codable, CaseIterable {
                case app
                case builds
            }

            public enum FieldsBuilds: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case betaGroups
                case buildBetaDetail
                case diagnosticSignatures
                case expirationDate
                case expired
                case iconAssetToken
                case icons
                case individualTesters
                case minOsVersion
                case perfPowerMetrics
                case preReleaseVersion
                case processingState
                case uploadedDate
                case usesNonExemptEncryption
                case version
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public init(filterBuildsExpired: [String]? = nil, filterBuildsProcessingState: [FilterBuildsProcessingState]? = nil, filterPlatform: [FilterPlatform]? = nil, filterVersion: [String]? = nil, filterApp: [String]? = nil, filterBuilds: [String]? = nil, sort: [Sort]? = nil, fieldsPreReleaseVersions: [FieldsPreReleaseVersions]? = nil, limit: Int? = nil, include: [Include]? = nil, fieldsBuilds: [FieldsBuilds]? = nil, fieldsApps: [FieldsApps]? = nil, limitBuilds: Int? = nil) {
                self.filterBuildsExpired = filterBuildsExpired
                self.filterBuildsProcessingState = filterBuildsProcessingState
                self.filterPlatform = filterPlatform
                self.filterVersion = filterVersion
                self.filterApp = filterApp
                self.filterBuilds = filterBuilds
                self.sort = sort
                self.fieldsPreReleaseVersions = fieldsPreReleaseVersions
                self.limit = limit
                self.include = include
                self.fieldsBuilds = fieldsBuilds
                self.fieldsApps = fieldsApps
                self.limitBuilds = limitBuilds
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[builds.expired]", filterBuildsExpired?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[builds.processingState]", filterBuildsProcessingState?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[platform]", filterPlatform?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[version]", filterVersion?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[app]", filterApp?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[builds]", filterBuilds?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("sort", sort?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[preReleaseVersions]", fieldsPreReleaseVersions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[builds]", limitBuilds)
                return query
            }
        }
    }
}

extension Paths.PreReleaseVersions {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/preReleaseVersions/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.PrereleaseVersionResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsPreReleaseVersions: [FieldsPreReleaseVersions]?
            public var include: [Include]?
            public var fieldsBuilds: [FieldsBuilds]?
            public var fieldsApps: [FieldsApps]?
            public var limitBuilds: Int?

            public enum FieldsPreReleaseVersions: String, Codable, CaseIterable {
                case app
                case builds
                case platform
                case version
            }

            public enum Include: String, Codable, CaseIterable {
                case app
                case builds
            }

            public enum FieldsBuilds: String, Codable, CaseIterable {
                case app
                case appEncryptionDeclaration
                case appStoreVersion
                case betaAppReviewSubmission
                case betaBuildLocalizations
                case betaGroups
                case buildBetaDetail
                case diagnosticSignatures
                case expirationDate
                case expired
                case iconAssetToken
                case icons
                case individualTesters
                case minOsVersion
                case perfPowerMetrics
                case preReleaseVersion
                case processingState
                case uploadedDate
                case usesNonExemptEncryption
                case version
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public init(fieldsPreReleaseVersions: [FieldsPreReleaseVersions]? = nil, include: [Include]? = nil, fieldsBuilds: [FieldsBuilds]? = nil, fieldsApps: [FieldsApps]? = nil, limitBuilds: Int? = nil) {
                self.fieldsPreReleaseVersions = fieldsPreReleaseVersions
                self.include = include
                self.fieldsBuilds = fieldsBuilds
                self.fieldsApps = fieldsApps
                self.limitBuilds = limitBuilds
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[preReleaseVersions]", fieldsPreReleaseVersions?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[builds]", limitBuilds)
                return query
            }
        }
    }
}

extension Paths.PreReleaseVersions.WithID {
    public var app: App {
        App(path: path + "/app")
    }

    public struct App {
        /// Path: `/v1/preReleaseVersions/{id}/app`
        public let path: String

        public func get(fieldsApps: [FieldsApps]? = nil) -> Request<AppStoreConnectAPI.AppResponse> {
            .get(path, query: makeGetQuery(fieldsApps))
        }

        private func makeGetQuery(_ fieldsApps: [FieldsApps]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsApps: String, Codable, CaseIterable {
            case appInfos
            case appStoreVersions
            case availableInNewTerritories
            case availableTerritories
            case betaAppLocalizations
            case betaAppReviewDetail
            case betaGroups
            case betaLicenseAgreement
            case betaTesters
            case builds
            case bundleID = "bundleId"
            case contentRightsDeclaration
            case endUserLicenseAgreement
            case gameCenterEnabledVersions
            case inAppPurchases
            case isOrEverWasMadeForKids
            case name
            case perfPowerMetrics
            case preOrder
            case preReleaseVersions
            case prices
            case primaryLocale
            case sku
        }
    }
}

extension Paths.PreReleaseVersions.WithID {
    public var builds: Builds {
        Builds(path: path + "/builds")
    }

    public struct Builds {
        /// Path: `/v1/preReleaseVersions/{id}/builds`
        public let path: String

        public func get(fieldsBuilds: [FieldsBuilds]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.BuildsResponse> {
            .get(path, query: makeGetQuery(fieldsBuilds, limit))
        }

        private func makeGetQuery(_ fieldsBuilds: [FieldsBuilds]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[builds]", fieldsBuilds?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsBuilds: String, Codable, CaseIterable {
            case app
            case appEncryptionDeclaration
            case appStoreVersion
            case betaAppReviewSubmission
            case betaBuildLocalizations
            case betaGroups
            case buildBetaDetail
            case diagnosticSignatures
            case expirationDate
            case expired
            case iconAssetToken
            case icons
            case individualTesters
            case minOsVersion
            case perfPowerMetrics
            case preReleaseVersion
            case processingState
            case uploadedDate
            case usesNonExemptEncryption
            case version
        }
    }
}

extension Paths {
    public static var profiles: Profiles {
        Profiles(path: "/v1/profiles")
    }

    public struct Profiles {
        /// Path: `/v1/profiles`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.ProfilesResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterName: [String]?
            public var filterProfileState: [FilterProfileState]?
            public var filterProfileType: [FilterProfileType]?
            public var filterID: [String]?
            public var sort: [Sort]?
            public var fieldsProfiles: [FieldsProfiles]?
            public var limit: Int?
            public var include: [Include]?
            public var fieldsCertificates: [FieldsCertificates]?
            public var fieldsDevices: [FieldsDevices]?
            public var fieldsBundleIDs: [FieldsBundleIDs]?
            public var limitCertificates: Int?
            public var limitDevices: Int?

            public enum FilterProfileState: String, Codable, CaseIterable {
                case active = "ACTIVE"
                case invalid = "INVALID"
            }

            public enum FilterProfileType: String, Codable, CaseIterable {
                case iosAppDevelopment = "IOS_APP_DEVELOPMENT"
                case iosAppStore = "IOS_APP_STORE"
                case iosAppAdhoc = "IOS_APP_ADHOC"
                case iosAppInhouse = "IOS_APP_INHOUSE"
                case macAppDevelopment = "MAC_APP_DEVELOPMENT"
                case macAppStore = "MAC_APP_STORE"
                case macAppDirect = "MAC_APP_DIRECT"
                case tvosAppDevelopment = "TVOS_APP_DEVELOPMENT"
                case tvosAppStore = "TVOS_APP_STORE"
                case tvosAppAdhoc = "TVOS_APP_ADHOC"
                case tvosAppInhouse = "TVOS_APP_INHOUSE"
                case macCatalystAppDevelopment = "MAC_CATALYST_APP_DEVELOPMENT"
                case macCatalystAppStore = "MAC_CATALYST_APP_STORE"
                case macCatalystAppDirect = "MAC_CATALYST_APP_DIRECT"
            }

            public enum Sort: String, Codable, CaseIterable {
                case id
                case minusid = "-id"
                case name
                case minusname = "-name"
                case profileState
                case minusprofileState = "-profileState"
                case profileType
                case minusprofileType = "-profileType"
            }

            public enum FieldsProfiles: String, Codable, CaseIterable {
                case bundleID = "bundleId"
                case certificates
                case createdDate
                case devices
                case expirationDate
                case name
                case platform
                case profileContent
                case profileState
                case profileType
                case uuid
            }

            public enum Include: String, Codable, CaseIterable {
                case bundleID = "bundleId"
                case certificates
                case devices
            }

            public enum FieldsCertificates: String, Codable, CaseIterable {
                case certificateContent
                case certificateType
                case csrContent
                case displayName
                case expirationDate
                case name
                case platform
                case serialNumber
            }

            public enum FieldsDevices: String, Codable, CaseIterable {
                case addedDate
                case deviceClass
                case model
                case name
                case platform
                case status
                case udid
            }

            public enum FieldsBundleIDs: String, Codable, CaseIterable {
                case app
                case bundleIDCapabilities = "bundleIdCapabilities"
                case identifier
                case name
                case platform
                case profiles
                case seedID = "seedId"
            }

            public init(filterName: [String]? = nil, filterProfileState: [FilterProfileState]? = nil, filterProfileType: [FilterProfileType]? = nil, filterID: [String]? = nil, sort: [Sort]? = nil, fieldsProfiles: [FieldsProfiles]? = nil, limit: Int? = nil, include: [Include]? = nil, fieldsCertificates: [FieldsCertificates]? = nil, fieldsDevices: [FieldsDevices]? = nil, fieldsBundleIDs: [FieldsBundleIDs]? = nil, limitCertificates: Int? = nil, limitDevices: Int? = nil) {
                self.filterName = filterName
                self.filterProfileState = filterProfileState
                self.filterProfileType = filterProfileType
                self.filterID = filterID
                self.sort = sort
                self.fieldsProfiles = fieldsProfiles
                self.limit = limit
                self.include = include
                self.fieldsCertificates = fieldsCertificates
                self.fieldsDevices = fieldsDevices
                self.fieldsBundleIDs = fieldsBundleIDs
                self.limitCertificates = limitCertificates
                self.limitDevices = limitDevices
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[name]", filterName?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[profileState]", filterProfileState?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[profileType]", filterProfileType?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[id]", filterID?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("sort", sort?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[profiles]", fieldsProfiles?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[certificates]", fieldsCertificates?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[devices]", fieldsDevices?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[bundleIds]", fieldsBundleIDs?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[certificates]", limitCertificates)
                query.addQueryItem("limit[devices]", limitDevices)
                return query
            }
        }

        public func post(_ body: AppStoreConnectAPI.ProfileCreateRequest) -> Request<AppStoreConnectAPI.ProfileResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.Profiles {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/profiles/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.ProfileResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsProfiles: [FieldsProfiles]?
            public var include: [Include]?
            public var fieldsCertificates: [FieldsCertificates]?
            public var fieldsDevices: [FieldsDevices]?
            public var fieldsBundleIDs: [FieldsBundleIDs]?
            public var limitCertificates: Int?
            public var limitDevices: Int?

            public enum FieldsProfiles: String, Codable, CaseIterable {
                case bundleID = "bundleId"
                case certificates
                case createdDate
                case devices
                case expirationDate
                case name
                case platform
                case profileContent
                case profileState
                case profileType
                case uuid
            }

            public enum Include: String, Codable, CaseIterable {
                case bundleID = "bundleId"
                case certificates
                case devices
            }

            public enum FieldsCertificates: String, Codable, CaseIterable {
                case certificateContent
                case certificateType
                case csrContent
                case displayName
                case expirationDate
                case name
                case platform
                case serialNumber
            }

            public enum FieldsDevices: String, Codable, CaseIterable {
                case addedDate
                case deviceClass
                case model
                case name
                case platform
                case status
                case udid
            }

            public enum FieldsBundleIDs: String, Codable, CaseIterable {
                case app
                case bundleIDCapabilities = "bundleIdCapabilities"
                case identifier
                case name
                case platform
                case profiles
                case seedID = "seedId"
            }

            public init(fieldsProfiles: [FieldsProfiles]? = nil, include: [Include]? = nil, fieldsCertificates: [FieldsCertificates]? = nil, fieldsDevices: [FieldsDevices]? = nil, fieldsBundleIDs: [FieldsBundleIDs]? = nil, limitCertificates: Int? = nil, limitDevices: Int? = nil) {
                self.fieldsProfiles = fieldsProfiles
                self.include = include
                self.fieldsCertificates = fieldsCertificates
                self.fieldsDevices = fieldsDevices
                self.fieldsBundleIDs = fieldsBundleIDs
                self.limitCertificates = limitCertificates
                self.limitDevices = limitDevices
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[profiles]", fieldsProfiles?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[certificates]", fieldsCertificates?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[devices]", fieldsDevices?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[bundleIds]", fieldsBundleIDs?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[certificates]", limitCertificates)
                query.addQueryItem("limit[devices]", limitDevices)
                return query
            }
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Profiles.WithID {
    public var bundleID: BundleID {
        BundleID(path: path + "/bundleId")
    }

    public struct BundleID {
        /// Path: `/v1/profiles/{id}/bundleId`
        public let path: String

        public func get(fieldsBundleIDs: [FieldsBundleIDs]? = nil) -> Request<AppStoreConnectAPI.BundleIDResponse> {
            .get(path, query: makeGetQuery(fieldsBundleIDs))
        }

        private func makeGetQuery(_ fieldsBundleIDs: [FieldsBundleIDs]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[bundleIds]", fieldsBundleIDs?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsBundleIDs: String, Codable, CaseIterable {
            case app
            case bundleIDCapabilities = "bundleIdCapabilities"
            case identifier
            case name
            case platform
            case profiles
            case seedID = "seedId"
        }
    }
}

extension Paths.Profiles.WithID {
    public var certificates: Certificates {
        Certificates(path: path + "/certificates")
    }

    public struct Certificates {
        /// Path: `/v1/profiles/{id}/certificates`
        public let path: String

        public func get(fieldsCertificates: [FieldsCertificates]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.CertificatesResponse> {
            .get(path, query: makeGetQuery(fieldsCertificates, limit))
        }

        private func makeGetQuery(_ fieldsCertificates: [FieldsCertificates]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[certificates]", fieldsCertificates?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsCertificates: String, Codable, CaseIterable {
            case certificateContent
            case certificateType
            case csrContent
            case displayName
            case expirationDate
            case name
            case platform
            case serialNumber
        }
    }
}

extension Paths.Profiles.WithID {
    public var devices: Devices {
        Devices(path: path + "/devices")
    }

    public struct Devices {
        /// Path: `/v1/profiles/{id}/devices`
        public let path: String

        public func get(fieldsDevices: [FieldsDevices]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.DevicesResponse> {
            .get(path, query: makeGetQuery(fieldsDevices, limit))
        }

        private func makeGetQuery(_ fieldsDevices: [FieldsDevices]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[devices]", fieldsDevices?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsDevices: String, Codable, CaseIterable {
            case addedDate
            case deviceClass
            case model
            case name
            case platform
            case status
            case udid
        }
    }
}

extension Paths {
    public static var routingAppCoverages: RoutingAppCoverages {
        RoutingAppCoverages(path: "/v1/routingAppCoverages")
    }

    public struct RoutingAppCoverages {
        /// Path: `/v1/routingAppCoverages`
        public let path: String

        public func post(_ body: AppStoreConnectAPI.RoutingAppCoverageCreateRequest) -> Request<AppStoreConnectAPI.RoutingAppCoverageResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.RoutingAppCoverages {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/routingAppCoverages/{id}`
        public let path: String

        public func get(fieldsRoutingAppCoverages: [FieldsRoutingAppCoverages]? = nil, include: [Include]? = nil) -> Request<AppStoreConnectAPI.RoutingAppCoverageResponse> {
            .get(path, query: makeGetQuery(fieldsRoutingAppCoverages, include))
        }

        private func makeGetQuery(_ fieldsRoutingAppCoverages: [FieldsRoutingAppCoverages]?, _ include: [Include]?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[routingAppCoverages]", fieldsRoutingAppCoverages?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
            return query
        }

        public enum FieldsRoutingAppCoverages: String, Codable, CaseIterable {
            case appStoreVersion
            case assetDeliveryState
            case fileName
            case fileSize
            case sourceFileChecksum
            case uploadOperations
            case uploaded
        }

        public enum Include: String, Codable, CaseIterable {
            case appStoreVersion
        }

        public func patch(_ body: AppStoreConnectAPI.RoutingAppCoverageUpdateRequest) -> Request<AppStoreConnectAPI.RoutingAppCoverageResponse> {
            .patch(path, body: body)
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var salesReports: SalesReports {
        SalesReports(path: "/v1/salesReports")
    }

    public struct SalesReports {
        /// Path: `/v1/salesReports`
        public let path: String

        public func get(parameters: GetParameters) -> Request<Data> {
            .get(path, query: parameters.asQuery())
        }

        public struct GetParameters {
            public var filterFrequency: [FilterFrequency]
            public var filterReportDate: [String]?
            public var filterReportSubType: [FilterReportSubType]
            public var filterReportType: [FilterReportType]
            public var filterVendorNumber: [String]
            public var filterVersion: [String]?

            public enum FilterFrequency: String, Codable, CaseIterable {
                case daily = "DAILY"
                case weekly = "WEEKLY"
                case monthly = "MONTHLY"
                case yearly = "YEARLY"
            }

            public enum FilterReportSubType: String, Codable, CaseIterable {
                case summary = "SUMMARY"
                case detailed = "DETAILED"
                case optIn = "OPT_IN"
            }

            public enum FilterReportType: String, Codable, CaseIterable {
                case sales = "SALES"
                case preOrder = "PRE_ORDER"
                case newsstand = "NEWSSTAND"
                case subscription = "SUBSCRIPTION"
                case subscriptionEvent = "SUBSCRIPTION_EVENT"
                case subscriber = "SUBSCRIBER"
            }

            public init(filterFrequency: [FilterFrequency], filterReportDate: [String]? = nil, filterReportSubType: [FilterReportSubType], filterReportType: [FilterReportType], filterVendorNumber: [String], filterVersion: [String]? = nil) {
                self.filterFrequency = filterFrequency
                self.filterReportDate = filterReportDate
                self.filterReportSubType = filterReportSubType
                self.filterReportType = filterReportType
                self.filterVendorNumber = filterVendorNumber
                self.filterVersion = filterVersion
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[frequency]", filterFrequency.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[reportDate]", filterReportDate?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[reportSubType]", filterReportSubType.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[reportType]", filterReportType.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[vendorNumber]", filterVendorNumber.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[version]", filterVersion?.map(\.asQueryValue).joined(separator: ","))
                return query
            }
        }
    }
}

extension Paths {
    public static var territories: Territories {
        Territories(path: "/v1/territories")
    }

    public struct Territories {
        /// Path: `/v1/territories`
        public let path: String

        public func get(fieldsTerritories: [FieldsTerritories]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.TerritoriesResponse> {
            .get(path, query: makeGetQuery(fieldsTerritories, limit))
        }

        private func makeGetQuery(_ fieldsTerritories: [FieldsTerritories]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[territories]", fieldsTerritories?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsTerritories: String, Codable, CaseIterable {
            case currency
        }
    }
}

extension Paths {
    public static var userInvitations: UserInvitations {
        UserInvitations(path: "/v1/userInvitations")
    }

    public struct UserInvitations {
        /// Path: `/v1/userInvitations`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.UserInvitationsResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterEmail: [String]?
            public var filterRoles: [FilterRoles]?
            public var filterVisibleApps: [String]?
            public var sort: [Sort]?
            public var fieldsUserInvitations: [FieldsUserInvitations]?
            public var limit: Int?
            public var include: [Include]?
            public var fieldsApps: [FieldsApps]?
            public var limitVisibleApps: Int?

            public enum FilterRoles: String, Codable, CaseIterable {
                case admin = "ADMIN"
                case finance = "FINANCE"
                case technical = "TECHNICAL"
                case accountHolder = "ACCOUNT_HOLDER"
                case readOnly = "READ_ONLY"
                case sales = "SALES"
                case marketing = "MARKETING"
                case appManager = "APP_MANAGER"
                case developer = "DEVELOPER"
                case accessToReports = "ACCESS_TO_REPORTS"
                case customerSupport = "CUSTOMER_SUPPORT"
                case createApps = "CREATE_APPS"
                case cloudManagedDeveloperID = "CLOUD_MANAGED_DEVELOPER_ID"
                case cloudManagedAppDistribution = "CLOUD_MANAGED_APP_DISTRIBUTION"
            }

            public enum Sort: String, Codable, CaseIterable {
                case email
                case minusemail = "-email"
                case lastName
                case minuslastName = "-lastName"
            }

            public enum FieldsUserInvitations: String, Codable, CaseIterable {
                case allAppsVisible
                case email
                case expirationDate
                case firstName
                case lastName
                case provisioningAllowed
                case roles
                case visibleApps
            }

            public enum Include: String, Codable, CaseIterable {
                case visibleApps
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public init(filterEmail: [String]? = nil, filterRoles: [FilterRoles]? = nil, filterVisibleApps: [String]? = nil, sort: [Sort]? = nil, fieldsUserInvitations: [FieldsUserInvitations]? = nil, limit: Int? = nil, include: [Include]? = nil, fieldsApps: [FieldsApps]? = nil, limitVisibleApps: Int? = nil) {
                self.filterEmail = filterEmail
                self.filterRoles = filterRoles
                self.filterVisibleApps = filterVisibleApps
                self.sort = sort
                self.fieldsUserInvitations = fieldsUserInvitations
                self.limit = limit
                self.include = include
                self.fieldsApps = fieldsApps
                self.limitVisibleApps = limitVisibleApps
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[email]", filterEmail?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[roles]", filterRoles?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[visibleApps]", filterVisibleApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("sort", sort?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[userInvitations]", fieldsUserInvitations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[visibleApps]", limitVisibleApps)
                return query
            }
        }

        public func post(_ body: AppStoreConnectAPI.UserInvitationCreateRequest) -> Request<AppStoreConnectAPI.UserInvitationResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.UserInvitations {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/userInvitations/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.UserInvitationResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsUserInvitations: [FieldsUserInvitations]?
            public var include: [Include]?
            public var fieldsApps: [FieldsApps]?
            public var limitVisibleApps: Int?

            public enum FieldsUserInvitations: String, Codable, CaseIterable {
                case allAppsVisible
                case email
                case expirationDate
                case firstName
                case lastName
                case provisioningAllowed
                case roles
                case visibleApps
            }

            public enum Include: String, Codable, CaseIterable {
                case visibleApps
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public init(fieldsUserInvitations: [FieldsUserInvitations]? = nil, include: [Include]? = nil, fieldsApps: [FieldsApps]? = nil, limitVisibleApps: Int? = nil) {
                self.fieldsUserInvitations = fieldsUserInvitations
                self.include = include
                self.fieldsApps = fieldsApps
                self.limitVisibleApps = limitVisibleApps
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[userInvitations]", fieldsUserInvitations?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[visibleApps]", limitVisibleApps)
                return query
            }
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.UserInvitations.WithID {
    public var visibleApps: VisibleApps {
        VisibleApps(path: path + "/visibleApps")
    }

    public struct VisibleApps {
        /// Path: `/v1/userInvitations/{id}/visibleApps`
        public let path: String

        public func get(fieldsApps: [FieldsApps]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.AppsResponse> {
            .get(path, query: makeGetQuery(fieldsApps, limit))
        }

        private func makeGetQuery(_ fieldsApps: [FieldsApps]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsApps: String, Codable, CaseIterable {
            case appInfos
            case appStoreVersions
            case availableInNewTerritories
            case availableTerritories
            case betaAppLocalizations
            case betaAppReviewDetail
            case betaGroups
            case betaLicenseAgreement
            case betaTesters
            case builds
            case bundleID = "bundleId"
            case contentRightsDeclaration
            case endUserLicenseAgreement
            case gameCenterEnabledVersions
            case inAppPurchases
            case isOrEverWasMadeForKids
            case name
            case perfPowerMetrics
            case preOrder
            case preReleaseVersions
            case prices
            case primaryLocale
            case sku
        }
    }
}

extension Paths {
    public static var users: Users {
        Users(path: "/v1/users")
    }

    public struct Users {
        /// Path: `/v1/users`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.UsersResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var filterRoles: [FilterRoles]?
            public var filterUsername: [String]?
            public var filterVisibleApps: [String]?
            public var sort: [Sort]?
            public var fieldsUsers: [FieldsUsers]?
            public var limit: Int?
            public var include: [Include]?
            public var fieldsApps: [FieldsApps]?
            public var limitVisibleApps: Int?

            public enum FilterRoles: String, Codable, CaseIterable {
                case admin = "ADMIN"
                case finance = "FINANCE"
                case technical = "TECHNICAL"
                case accountHolder = "ACCOUNT_HOLDER"
                case readOnly = "READ_ONLY"
                case sales = "SALES"
                case marketing = "MARKETING"
                case appManager = "APP_MANAGER"
                case developer = "DEVELOPER"
                case accessToReports = "ACCESS_TO_REPORTS"
                case customerSupport = "CUSTOMER_SUPPORT"
                case createApps = "CREATE_APPS"
                case cloudManagedDeveloperID = "CLOUD_MANAGED_DEVELOPER_ID"
                case cloudManagedAppDistribution = "CLOUD_MANAGED_APP_DISTRIBUTION"
            }

            public enum Sort: String, Codable, CaseIterable {
                case lastName
                case minuslastName = "-lastName"
                case username
                case minususername = "-username"
            }

            public enum FieldsUsers: String, Codable, CaseIterable {
                case allAppsVisible
                case firstName
                case lastName
                case provisioningAllowed
                case roles
                case username
                case visibleApps
            }

            public enum Include: String, Codable, CaseIterable {
                case visibleApps
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public init(filterRoles: [FilterRoles]? = nil, filterUsername: [String]? = nil, filterVisibleApps: [String]? = nil, sort: [Sort]? = nil, fieldsUsers: [FieldsUsers]? = nil, limit: Int? = nil, include: [Include]? = nil, fieldsApps: [FieldsApps]? = nil, limitVisibleApps: Int? = nil) {
                self.filterRoles = filterRoles
                self.filterUsername = filterUsername
                self.filterVisibleApps = filterVisibleApps
                self.sort = sort
                self.fieldsUsers = fieldsUsers
                self.limit = limit
                self.include = include
                self.fieldsApps = fieldsApps
                self.limitVisibleApps = limitVisibleApps
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("filter[roles]", filterRoles?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[username]", filterUsername?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("filter[visibleApps]", filterVisibleApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("sort", sort?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[users]", fieldsUsers?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit", limit)
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[visibleApps]", limitVisibleApps)
                return query
            }
        }
    }
}

extension Paths.Users {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v1/users/{id}`
        public let path: String

        public func get(parameters: GetParameters? = nil) -> Request<AppStoreConnectAPI.UserResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var fieldsUsers: [FieldsUsers]?
            public var include: [Include]?
            public var fieldsApps: [FieldsApps]?
            public var limitVisibleApps: Int?

            public enum FieldsUsers: String, Codable, CaseIterable {
                case allAppsVisible
                case firstName
                case lastName
                case provisioningAllowed
                case roles
                case username
                case visibleApps
            }

            public enum Include: String, Codable, CaseIterable {
                case visibleApps
            }

            public enum FieldsApps: String, Codable, CaseIterable {
                case appInfos
                case appStoreVersions
                case availableInNewTerritories
                case availableTerritories
                case betaAppLocalizations
                case betaAppReviewDetail
                case betaGroups
                case betaLicenseAgreement
                case betaTesters
                case builds
                case bundleID = "bundleId"
                case contentRightsDeclaration
                case endUserLicenseAgreement
                case gameCenterEnabledVersions
                case inAppPurchases
                case isOrEverWasMadeForKids
                case name
                case perfPowerMetrics
                case preOrder
                case preReleaseVersions
                case prices
                case primaryLocale
                case sku
            }

            public init(fieldsUsers: [FieldsUsers]? = nil, include: [Include]? = nil, fieldsApps: [FieldsApps]? = nil, limitVisibleApps: Int? = nil) {
                self.fieldsUsers = fieldsUsers
                self.include = include
                self.fieldsApps = fieldsApps
                self.limitVisibleApps = limitVisibleApps
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("fields[users]", fieldsUsers?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("include", include?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
                query.addQueryItem("limit[visibleApps]", limitVisibleApps)
                return query
            }
        }

        public func patch(_ body: AppStoreConnectAPI.UserUpdateRequest) -> Request<AppStoreConnectAPI.UserResponse> {
            .patch(path, body: body)
        }

        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithID {
    public var relationships: Relationships {
        Relationships(path: path + "/relationships")
    }

    public struct Relationships {
        /// Path: `/v1/users/{id}/relationships`
        public let path: String
    }
}

extension Paths.Users.WithID.Relationships {
    public var visibleApps: VisibleApps {
        VisibleApps(path: path + "/visibleApps")
    }

    public struct VisibleApps {
        /// Path: `/v1/users/{id}/relationships/visibleApps`
        public let path: String

        public func get(limit: Int? = nil) -> Request<AppStoreConnectAPI.UserVisibleAppsLinkagesResponse> {
            .get(path, query: makeGetQuery(limit))
        }

        private func makeGetQuery(_ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("limit", limit)
            return query
        }

        public func post(_ body: AppStoreConnectAPI.UserVisibleAppsLinkagesRequest) -> Request<Void> {
            .post(path, body: body)
        }

        public func patch(_ body: AppStoreConnectAPI.UserVisibleAppsLinkagesRequest) -> Request<Void> {
            .patch(path, body: body)
        }

        public func delete(_ body: AppStoreConnectAPI.UserVisibleAppsLinkagesRequest) -> Request<Void> {
            .delete(path, body: body)
        }
    }
}

extension Paths.Users.WithID {
    public var visibleApps: VisibleApps {
        VisibleApps(path: path + "/visibleApps")
    }

    public struct VisibleApps {
        /// Path: `/v1/users/{id}/visibleApps`
        public let path: String

        public func get(fieldsApps: [FieldsApps]? = nil, limit: Int? = nil) -> Request<AppStoreConnectAPI.AppsResponse> {
            .get(path, query: makeGetQuery(fieldsApps, limit))
        }

        private func makeGetQuery(_ fieldsApps: [FieldsApps]?, _ limit: Int?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("fields[apps]", fieldsApps?.map(\.asQueryValue).joined(separator: ","))
            query.addQueryItem("limit", limit)
            return query
        }

        public enum FieldsApps: String, Codable, CaseIterable {
            case appInfos
            case appStoreVersions
            case availableInNewTerritories
            case availableTerritories
            case betaAppLocalizations
            case betaAppReviewDetail
            case betaGroups
            case betaLicenseAgreement
            case betaTesters
            case builds
            case bundleID = "bundleId"
            case contentRightsDeclaration
            case endUserLicenseAgreement
            case gameCenterEnabledVersions
            case inAppPurchases
            case isOrEverWasMadeForKids
            case name
            case perfPowerMetrics
            case preOrder
            case preReleaseVersions
            case prices
            case primaryLocale
            case sku
        }
    }
}

public enum Paths {}

protocol QueryEncodable {
    var asQueryValue: String { get }
}

extension Bool: QueryEncodable {
    var asQueryValue: String {
        self ? "true" : "false"
    }
}

extension Date: QueryEncodable {
    var asQueryValue: String {
        ISO8601DateFormatter().string(from: self)
    }
}

extension Double: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int32: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int64: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension String: QueryEncodable {
    var asQueryValue: String {
        self
    }
}

extension URL: QueryEncodable {
    var asQueryValue: String {
        absoluteString
    }
}

extension RawRepresentable where RawValue == String {
    var asQueryValue: String {
        rawValue
    }
}

extension Array where Element == (String, String?) {
    mutating func addQueryItem<T: RawRepresentable>(_ name: String, _ value: T?) where T.RawValue == String {
        addQueryItem(name, value?.rawValue)
    }
    
    mutating func addQueryItem(_ name: String, _ value: QueryEncodable?) {
        guard let value = value?.asQueryValue, !value.isEmpty else { return }
        append((name, value))
    }
    
    mutating func addDeepObject(_ name: String, _ query: [(String, String?)]) {
        for (key, value) in query {
            addQueryItem("\(name)[\(key)]", value)
        }
    }

    var asPercentEncodedQuery: String {
        var components = URLComponents()
        components.queryItems = self.map(URLQueryItem.init)
        return components.percentEncodedQuery ?? ""
    }
    
    // [("role", "admin"), ("name": "kean)] -> "role,admin,name,kean"
    var asCompactQuery: String {
        flatMap { [$0, $1] }.compactMap { $0 }.joined(separator: ",")
    }
}
