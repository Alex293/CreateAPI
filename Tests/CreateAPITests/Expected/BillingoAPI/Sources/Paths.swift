// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import NaiveDate
import Get
import HTTPHeaders
import URLQueryEncoder

extension Paths {
    public static var bankAccounts: BankAccounts {
        BankAccounts(path: "/bank-accounts")
    }

    public struct BankAccounts {
        /// Path: `/bank-accounts`
        public let path: String

        /// List all bank account
        ///
        /// Returns a list of your bank accounts. The bank accounts are returned sorted by creation date, with the most recent bank account appearing first.
        public func get(page: Int? = nil, perPage: Int? = nil) -> Request<BillingoAPI.BankAccountList> {
            .get(path, query: makeGetQuery(page, perPage))
        }

        public enum GetResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }

        private func makeGetQuery(_ page: Int?, _ perPage: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(page, forKey: "page")
            encoder.encode(perPage, forKey: "per_page")
            return encoder.items
        }

        /// Create a bank account
        ///
        /// Create a new bank account. Returns a bank account object if the create is succeded.
        public func post(_ body: BillingoAPI.BankAccount) -> Request<BillingoAPI.BankAccount> {
            .post(path, body: body)
        }

        public enum PostResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }
    }
}

extension Paths.BankAccounts {
    public func id(_ id: Int) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/bank-accounts/{id}`
        public let path: String

        /// Retrieve a bank account
        ///
        /// Retrieves the details of an existing bank account.
        public var get: Request<BillingoAPI.BankAccount> {
            .get(path)
        }

        public enum GetResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }

        /// Update a bank account
        ///
        /// Update an existing bank accounts. Returns a bank account object if the update is succeded.
        public func put(_ body: BillingoAPI.BankAccount) -> Request<BillingoAPI.BankAccount> {
            .put(path, body: body)
        }

        public enum PutResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }

        /// Delete a bank account
        ///
        /// Delete an existing bank account.
        public var delete: Request<Void> {
            .delete(path)
        }

        public enum DeleteResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }
    }
}

extension Paths {
    public static var currencies: Currencies {
        Currencies(path: "/currencies")
    }

    public struct Currencies {
        /// Path: `/currencies`
        public let path: String

        /// Get currencies exchange rate.
        ///
        /// Return with the exchange value of given currencies.
        public func get(from: From, to: To) -> Request<BillingoAPI.ConversationRate> {
            .get(path, query: makeGetQuery(from, to))
        }

        public enum GetResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }

        private func makeGetQuery(_ from: From, _ to: To) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(from, forKey: "from")
            encoder.encode(to, forKey: "to")
            return encoder.items
        }

        public enum From: String, Codable, CaseIterable {
            case aud = "AUD"
            case bgn = "BGN"
            case brl = "BRL"
            case cad = "CAD"
            case chf = "CHF"
            case cny = "CNY"
            case czk = "CZK"
            case dkk = "DKK"
            case eur = "EUR"
            case gbp = "GBP"
            case hkd = "HKD"
            case hrk = "HRK"
            case huf = "HUF"
            case idr = "IDR"
            case ils = "ILS"
            case inr = "INR"
            case isk = "ISK"
            case jpy = "JPY"
            case krw = "KRW"
            case ltl = "LTL"
            case lvl = "LVL"
            case mxn = "MXN"
            case myr = "MYR"
            case nok = "NOK"
            case nzd = "NZD"
            case php = "PHP"
            case pln = "PLN"
            case ron = "RON"
            case rsd = "RSD"
            case rub = "RUB"
            case sek = "SEK"
            case sgd = "SGD"
            case thb = "THB"
            case `try` = "TRY"
            case uah = "UAH"
            case usd = "USD"
            case zar = "ZAR"
        }

        public enum To: String, Codable, CaseIterable {
            case aud = "AUD"
            case bgn = "BGN"
            case brl = "BRL"
            case cad = "CAD"
            case chf = "CHF"
            case cny = "CNY"
            case czk = "CZK"
            case dkk = "DKK"
            case eur = "EUR"
            case gbp = "GBP"
            case hkd = "HKD"
            case hrk = "HRK"
            case huf = "HUF"
            case idr = "IDR"
            case ils = "ILS"
            case inr = "INR"
            case isk = "ISK"
            case jpy = "JPY"
            case krw = "KRW"
            case ltl = "LTL"
            case lvl = "LVL"
            case mxn = "MXN"
            case myr = "MYR"
            case nok = "NOK"
            case nzd = "NZD"
            case php = "PHP"
            case pln = "PLN"
            case ron = "RON"
            case rsd = "RSD"
            case rub = "RUB"
            case sek = "SEK"
            case sgd = "SGD"
            case thb = "THB"
            case `try` = "TRY"
            case uah = "UAH"
            case usd = "USD"
            case zar = "ZAR"
        }
    }
}

extension Paths {
    public static var documentBlocks: DocumentBlocks {
        DocumentBlocks(path: "/document-blocks")
    }

    public struct DocumentBlocks {
        /// Path: `/document-blocks`
        public let path: String

        /// List all document blocks
        ///
        /// Returns a list of your document blocks. The document blocks are returned sorted by creation date, with the most recent document blocks appearing first.
        public func get(page: Int? = nil, perPage: Int? = nil) -> Request<BillingoAPI.DocumentBlockList> {
            .get(path, query: makeGetQuery(page, perPage))
        }

        public enum GetResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }

        private func makeGetQuery(_ page: Int?, _ perPage: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(page, forKey: "page")
            encoder.encode(perPage, forKey: "per_page")
            return encoder.items
        }
    }
}

extension Paths {
    public static var documents: Documents {
        Documents(path: "/documents")
    }

    public struct Documents {
        /// Path: `/documents`
        public let path: String

        /// List all documents
        ///
        /// Returns a list of your documents. The documents are returned sorted by creation date, with the most recent documents appearing first.
        public func get(parameters: GetParameters? = nil) -> Request<BillingoAPI.DocumentList> {
            .get(path, query: parameters?.asQuery)
        }

        public enum GetResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }

        public struct GetParameters {
            public var page: Int?
            public var perPage: Int?
            public var blockID: Int?
            public var partnerID: Int?
            public var paymentMethod: PaymentMethod?
            public var paymentStatus: PaymentStatus?
            public var startDate: NaiveDate?
            public var endDate: NaiveDate?
            public var startNumber: Int?
            public var endNumber: Int?
            public var startYear: Int?
            public var endYear: Int?

            public enum PaymentMethod: String, Codable, CaseIterable {
                case aruhitel
                case bankcard
                case barion
                case barter
                case cash
                case cashOnDelivery = "cash_on_delivery"
                case coupon
                case eloreUtalas = "elore_utalas"
                case epKartya = "ep_kartya"
                case kompenzacio
                case levonas
                case onlineBankcard = "online_bankcard"
                case payoneer
                case paypal
                case paypalUtolag = "paypal_utolag"
                case payu
                case pickPackPont = "pick_pack_pont"
                case postaiCsekk = "postai_csekk"
                case postautalvany
                case skrill
                case szepCard = "szep_card"
                case transferwise
                case upwork
                case utalvany
                case valto
                case wireTransfer = "wire_transfer"
            }

            public enum PaymentStatus: String, Codable, CaseIterable {
                case expired
                case `none`
                case outstanding
                case paid
                case partiallyPaid = "partially_paid"
            }

            public init(page: Int? = nil, perPage: Int? = nil, blockID: Int? = nil, partnerID: Int? = nil, paymentMethod: PaymentMethod? = nil, paymentStatus: PaymentStatus? = nil, startDate: NaiveDate? = nil, endDate: NaiveDate? = nil, startNumber: Int? = nil, endNumber: Int? = nil, startYear: Int? = nil, endYear: Int? = nil) {
                self.page = page
                self.perPage = perPage
                self.blockID = blockID
                self.partnerID = partnerID
                self.paymentMethod = paymentMethod
                self.paymentStatus = paymentStatus
                self.startDate = startDate
                self.endDate = endDate
                self.startNumber = startNumber
                self.endNumber = endNumber
                self.startYear = startYear
                self.endYear = endYear
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(page, forKey: "page")
                encoder.encode(perPage, forKey: "per_page")
                encoder.encode(blockID, forKey: "block_id")
                encoder.encode(partnerID, forKey: "partner_id")
                encoder.encode(paymentMethod, forKey: "payment_method")
                encoder.encode(paymentStatus, forKey: "payment_status")
                encoder.encode(startDate, forKey: "start_date")
                encoder.encode(endDate, forKey: "end_date")
                encoder.encode(startNumber, forKey: "start_number")
                encoder.encode(endNumber, forKey: "end_number")
                encoder.encode(startYear, forKey: "start_year")
                encoder.encode(endYear, forKey: "end_year")
                return encoder.items
            }
        }

        /// Create a document
        ///
        /// Create a new document. Returns a document object if the create is succeded.
        public func post(_ body: BillingoAPI.DocumentInsert) -> Request<BillingoAPI.Document> {
            .post(path, body: body)
        }

        public enum PostResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }
    }
}

extension Paths.Documents {
    public func id(_ id: Int) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/documents/{id}`
        public let path: String

        /// Retrieve a document
        ///
        /// Retrieves the details of an existing document.
        public var get: Request<BillingoAPI.Document> {
            .get(path)
        }

        public enum GetResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }
    }
}

extension Paths.Documents.WithID {
    public var cancel: Cancel {
        Cancel(path: path + "/cancel")
    }

    public struct Cancel {
        /// Path: `/documents/{id}/cancel`
        public let path: String

        /// Cancel a document
        ///
        /// Cancel a document. Returns a cancellation document object if the cancellation is succeded.
        public var post: Request<BillingoAPI.Document> {
            .post(path)
        }

        public enum PostResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }
    }
}

extension Paths.Documents.WithID {
    public var createFromProforma: CreateFromProforma {
        CreateFromProforma(path: path + "/create-from-proforma")
    }

    public struct CreateFromProforma {
        /// Path: `/documents/{id}/create-from-proforma`
        public let path: String

        /// Create a document from proforma.
        ///
        /// Create a new document from proforma. Returns a document object if the create is succeded.
        public var post: Request<BillingoAPI.Document> {
            .post(path)
        }

        public enum PostResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }
    }
}

extension Paths.Documents.WithID {
    public var download: Download {
        Download(path: path + "/download")
    }

    public struct Download {
        /// Path: `/documents/{id}/download`
        public let path: String

        /// Download a document in PDF format.
        ///
        /// Download a document. Returns a document in PDF format.
        public var get: Request<Data> {
            .get(path)
        }

        public enum GetResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }
    }
}

extension Paths.Documents.WithID {
    public var onlineSzamla: OnlineSzamla {
        OnlineSzamla(path: path + "/online-szamla")
    }

    public struct OnlineSzamla {
        /// Path: `/documents/{id}/online-szamla`
        public let path: String

        /// Retrieve a document Online SzÃ¡mla status
        ///
        /// Retrieves the details of an existing document status.
        public var get: Request<BillingoAPI.OnlineSzamlaStatus> {
            .get(path)
        }

        public enum GetResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }
    }
}

extension Paths.Documents.WithID {
    public var payments: Payments {
        Payments(path: path + "/payments")
    }

    public struct Payments {
        /// Path: `/documents/{id}/payments`
        public let path: String

        /// Retrieve a payment histroy
        ///
        /// Retrieves the details of payment history an existing document.
        public var get: Request<[BillingoAPI.PaymentHistory]> {
            .get(path)
        }

        public enum GetResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }

        /// Update payment history
        ///
        /// Update payment history an existing document. Returns a payment history object if the update is succeded.
        public func put(_ body: [BillingoAPI.PaymentHistory]) -> Request<[BillingoAPI.PaymentHistory]> {
            .put(path, body: body)
        }

        public enum PutResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }

        /// Delete all payment history on document
        ///
        /// Delete all exist payment history on document.
        public var delete: Request<[BillingoAPI.PaymentHistory]> {
            .delete(path)
        }

        public enum DeleteResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }
    }
}

extension Paths.Documents.WithID {
    public var publicURL: PublicURL {
        PublicURL(path: path + "/public-url")
    }

    public struct PublicURL {
        /// Path: `/documents/{id}/public-url`
        public let path: String

        /// Retrieve a document download public url.
        ///
        /// Retrieves public url to download an existing document.
        public var get: Request<BillingoAPI.DocumentPublicURL> {
            .get(path)
        }

        public enum GetResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }
    }
}

extension Paths.Documents.WithID {
    public var send: Send {
        Send(path: path + "/send")
    }

    public struct Send {
        /// Path: `/documents/{id}/send`
        public let path: String

        /// Send invoice to given email adresses.
        ///
        /// Returns a list of emails, where the invoice is sent.
        public func post(_ body: BillingoAPI.SendDocument? = nil) -> Request<BillingoAPI.SendDocument> {
            .post(path, body: body)
        }

        public enum PostResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }
    }
}

extension Paths {
    public static var organization: Organization {
        Organization(path: "/organization")
    }

    public struct Organization {
        /// Path: `/organization`
        public let path: String

        /// Retrieve a organization data.
        ///
        /// Retrieves the data of organization.
        public var get: Request<BillingoAPI.OrganizationData> {
            .get(path)
        }

        public enum GetResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }
    }
}

extension Paths {
    public static var partners: Partners {
        Partners(path: "/partners")
    }

    public struct Partners {
        /// Path: `/partners`
        public let path: String

        /// List all partners
        ///
        /// Returns a list of your partners. The partners are returned sorted by creation date, with the most recent partners appearing first.
        public func get(page: Int? = nil, perPage: Int? = nil) -> Request<BillingoAPI.PartnerList> {
            .get(path, query: makeGetQuery(page, perPage))
        }

        public enum GetResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }

        private func makeGetQuery(_ page: Int?, _ perPage: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(page, forKey: "page")
            encoder.encode(perPage, forKey: "per_page")
            return encoder.items
        }

        /// Create a partner
        ///
        /// Create a new partner. Returns a partner object if the create is succeded.
        public func post(_ body: BillingoAPI.PartnerUpsert) -> Request<BillingoAPI.Partner> {
            .post(path, body: body)
        }

        public enum PostResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }
    }
}

extension Paths.Partners {
    public func id(_ id: Int) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/partners/{id}`
        public let path: String

        /// Retrieve a partner
        ///
        /// Retrieves the details of an existing partner.
        public var get: Request<BillingoAPI.Partner> {
            .get(path)
        }

        public enum GetResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }

        /// Update a partner
        ///
        /// Update an existing partner. Returns a partner object if the update is succeded.
        public func put(_ body: BillingoAPI.PartnerUpsert) -> Request<BillingoAPI.Partner> {
            .put(path, body: body)
        }

        public enum PutResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }

        /// Delete a partner
        ///
        /// Delete an existing partner.
        public var delete: Request<Void> {
            .delete(path)
        }

        public enum DeleteResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }
    }
}

extension Paths {
    public static var products: Products {
        Products(path: "/products")
    }

    public struct Products {
        /// Path: `/products`
        public let path: String

        /// List all product
        ///
        /// Returns a list of your products. The partners are returned sorted by creation date, with the most recent partners appearing first.
        public func get(page: Int? = nil, perPage: Int? = nil) -> Request<BillingoAPI.ProductList> {
            .get(path, query: makeGetQuery(page, perPage))
        }

        public enum GetResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }

        private func makeGetQuery(_ page: Int?, _ perPage: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(page, forKey: "page")
            encoder.encode(perPage, forKey: "per_page")
            return encoder.items
        }

        /// Create a product
        ///
        /// Create a new product. Returns a product object if the create is succeded.
        public func post(_ body: BillingoAPI.Product) -> Request<BillingoAPI.Product> {
            .post(path, body: body)
        }

        public enum PostResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }
    }
}

extension Paths.Products {
    public func id(_ id: Int) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/products/{id}`
        public let path: String

        /// Retrieve a product
        ///
        /// Retrieves the details of an existing product.
        public var get: Request<BillingoAPI.Product> {
            .get(path)
        }

        public enum GetResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }

        /// Update a product
        ///
        /// Update an existing product. Returns a product object if the update is succeded.
        public func put(_ body: BillingoAPI.Product) -> Request<BillingoAPI.Product> {
            .put(path, body: body)
        }

        public enum PutResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }

        /// Delete a product
        ///
        /// Delete an existing product.
        public var delete: Request<Void> {
            .delete(path)
        }

        public enum DeleteResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }
    }
}

extension Paths {
    public static var utils: Utils {
        Utils(path: "/utils")
    }

    public struct Utils {
        /// Path: `/utils`
        public let path: String
    }
}

extension Paths.Utils {
    public var convertLegacyID: ConvertLegacyID {
        ConvertLegacyID(path: path + "/convert-legacy-id")
    }

    public struct ConvertLegacyID {
        /// Path: `/utils/convert-legacy-id`
        public let path: String
    }
}

extension Paths.Utils.ConvertLegacyID {
    public func id(_ id: Int) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/utils/convert-legacy-id/{id}`
        public let path: String

        /// Convert legacy ID to v3 ID.
        ///
        /// Retrieves the API v3 ID.
        public var get: Request<BillingoAPI.ID> {
            .get(path)
        }

        public enum GetResponseHeaders {
            /// Request limit per minute.
            public static let rateLimitLimit = HTTPHeader<Int>(field: "X-RateLimit-Limit")
            /// The number of requests left for the time window.
            public static let rateLimitRemaining = HTTPHeader<Int>(field: "X-RateLimit-Remaining")
            /// The timestamp at which the current rate limit window resets.
            public static let rateLimitReset = HTTPHeader<Int>(field: "X-RateLimit-Reset")
            /// How many seconds you have to wait before making new request.
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }
    }
}

public enum Paths {}
