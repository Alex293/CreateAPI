// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import NaiveDate

/// Example:
///
/// {
///   "error" : {
///     "message" : "Authorization information (Header: %s) is missing or invalid."
///   }
/// }
public struct ClientErrorResponse: Codable {
    public var error: ClientError?

    public init(error: ClientError? = nil) {
        self.error = error
    }
}

/// Example:
///
/// {
///   "error" : {
///     "message" : "Internal Server Error.",
///     "trace_id" : "664b218f93954a3480cb0ddb8f919c3f"
///   }
/// }
public struct ServerErrorResponse: Codable {
    public var error: ServerError?

    public init(error: ServerError? = nil) {
        self.error = error
    }
}

public struct ValidationErrorResponse: Codable {
    public var message: String?
    public var errors: [ValidationError]?

    public init(message: String? = nil, errors: [ValidationError]? = nil) {
        self.message = message
        self.errors = errors
    }
}

public struct ClientError: Codable {
    public var message: String?

    public init(message: String? = nil) {
        self.message = message
    }
}

public struct ServerError: Codable {
    public var message: String?
    /// You should send us this ID to investigate the issue.
    public var traceID: String?

    public init(message: String? = nil, traceID: String? = nil) {
        self.message = message
        self.traceID = traceID
    }

    private enum CodingKeys: String, CodingKey {
        case message
        case traceID = "trace_id"
    }
}

public struct ValidationError: Codable {
    public var field: String?
    public var message: String?

    public init(field: String? = nil, message: String? = nil) {
        self.field = field
        self.message = message
    }
}

public struct BankAccount: Codable {
    public var id: Int?
    public var name: String
    public var accountNumber: String
    public var accountNumberIban: String?
    public var swift: String?
    public var currency: Currency
    public var isNeedQr: Bool

    public init(id: Int? = nil, name: String, accountNumber: String, accountNumberIban: String? = nil, swift: String? = nil, currency: Currency, isNeedQr: Bool? = nil) {
        self.id = id
        self.name = name
        self.accountNumber = accountNumber
        self.accountNumberIban = accountNumberIban
        self.swift = swift
        self.currency = currency
        self.isNeedQr = isNeedQr ?? false
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case accountNumber = "account_number"
        case accountNumberIban = "account_number_iban"
        case swift
        case currency
        case isNeedQr = "need_qr"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.id = try values.decodeIfPresent(Int.self, forKey: .id)
        self.name = try values.decode(String.self, forKey: .name)
        self.accountNumber = try values.decode(String.self, forKey: .accountNumber)
        self.accountNumberIban = try values.decodeIfPresent(String.self, forKey: .accountNumberIban)
        self.swift = try values.decodeIfPresent(String.self, forKey: .swift)
        self.currency = try values.decode(Currency.self, forKey: .currency)
        self.isNeedQr = try values.decodeIfPresent(Bool.self, forKey: .isNeedQr) ?? false
    }
}

/// A object with a data property that contains an array of up to limit bank accounts. Each entry in the array is a separate bank account object. If no more bank accounts are available, the resulting array will be empty.
public struct BankAccountList: Codable {
    public var data: [BankAccount]?
    public var total: Int?
    public var perPage: Int?
    public var currentPage: Int?
    public var lastPage: Int?
    public var prevPageURL: String?
    public var nextPageURL: String?

    public init(data: [BankAccount]? = nil, total: Int? = nil, perPage: Int? = nil, currentPage: Int? = nil, lastPage: Int? = nil, prevPageURL: String? = nil, nextPageURL: String? = nil) {
        self.data = data
        self.total = total
        self.perPage = perPage
        self.currentPage = currentPage
        self.lastPage = lastPage
        self.prevPageURL = prevPageURL
        self.nextPageURL = nextPageURL
    }

    private enum CodingKeys: String, CodingKey {
        case data
        case total
        case perPage = "per_page"
        case currentPage = "current_page"
        case lastPage = "last_page"
        case prevPageURL = "prev_page_url"
        case nextPageURL = "next_page_url"
    }
}

public struct Address: Codable {
    public var countryCode: Country
    public var postCode: String
    public var city: String
    public var address: String

    public init(countryCode: Country, postCode: String, city: String, address: String) {
        self.countryCode = countryCode
        self.postCode = postCode
        self.city = city
        self.address = address
    }

    private enum CodingKeys: String, CodingKey {
        case countryCode = "country_code"
        case postCode = "post_code"
        case city
        case address
    }
}

public enum Country: String, Codable, CaseIterable {
    case empty = ""
    case ac = "AC"
    case ad = "AD"
    case ae = "AE"
    case af = "AF"
    case ag = "AG"
    case ai = "AI"
    case al = "AL"
    case am = "AM"
    case ao = "AO"
    case aq = "AQ"
    case ar = "AR"
    case `as` = "AS"
    case at = "AT"
    case au = "AU"
    case aw = "AW"
    case ax = "AX"
    case az = "AZ"
    case ba = "BA"
    case bb = "BB"
    case bd = "BD"
    case be = "BE"
    case bf = "BF"
    case bg = "BG"
    case bh = "BH"
    case bi = "BI"
    case bj = "BJ"
    case bl = "BL"
    case bm = "BM"
    case bn = "BN"
    case bo = "BO"
    case bq = "BQ"
    case br = "BR"
    case bs = "BS"
    case bt = "BT"
    case bw = "BW"
    case by = "BY"
    case bz = "BZ"
    case ca = "CA"
    case cc = "CC"
    case cd = "CD"
    case cf = "CF"
    case cg = "CG"
    case ch = "CH"
    case ci = "CI"
    case ck = "CK"
    case cl = "CL"
    case cm = "CM"
    case cn = "CN"
    case co = "CO"
    case cr = "CR"
    case cu = "CU"
    case cv = "CV"
    case cw = "CW"
    case cx = "CX"
    case cy = "CY"
    case cz = "CZ"
    case de = "DE"
    case dg = "DG"
    case dj = "DJ"
    case dk = "DK"
    case dm = "DM"
    case `do` = "DO"
    case dz = "DZ"
    case ea = "EA"
    case ec = "EC"
    case ee = "EE"
    case eg = "EG"
    case eh = "EH"
    case er = "ER"
    case es = "ES"
    case et = "ET"
    case fi = "FI"
    case fj = "FJ"
    case fk = "FK"
    case fm = "FM"
    case fo = "FO"
    case fr = "FR"
    case ga = "GA"
    case gb = "GB"
    case gd = "GD"
    case ge = "GE"
    case gf = "GF"
    case gg = "GG"
    case gh = "GH"
    case gi = "GI"
    case gl = "GL"
    case gm = "GM"
    case gn = "GN"
    case gp = "GP"
    case gq = "GQ"
    case gr = "GR"
    case gs = "GS"
    case gt = "GT"
    case gu = "GU"
    case gw = "GW"
    case gy = "GY"
    case hk = "HK"
    case hn = "HN"
    case hr = "HR"
    case ht = "HT"
    case hu = "HU"
    case ic = "IC"
    case id = "ID"
    case ie = "IE"
    case il = "IL"
    case im = "IM"
    case `in` = "IN"
    case io = "IO"
    case iq = "IQ"
    case ir = "IR"
    case `is` = "IS"
    case it = "IT"
    case je = "JE"
    case jm = "JM"
    case jo = "JO"
    case jp = "JP"
    case ke = "KE"
    case kg = "KG"
    case kh = "KH"
    case ki = "KI"
    case km = "KM"
    case kn = "KN"
    case kp = "KP"
    case kr = "KR"
    case kw = "KW"
    case ky = "KY"
    case kz = "KZ"
    case la = "LA"
    case lb = "LB"
    case lc = "LC"
    case li = "LI"
    case lk = "LK"
    case lr = "LR"
    case ls = "LS"
    case lt = "LT"
    case lu = "LU"
    case lv = "LV"
    case ly = "LY"
    case ma = "MA"
    case mc = "MC"
    case md = "MD"
    case me = "ME"
    case mf = "MF"
    case mg = "MG"
    case mh = "MH"
    case mk = "MK"
    case ml = "ML"
    case mm = "MM"
    case mn = "MN"
    case mo = "MO"
    case mp = "MP"
    case mq = "MQ"
    case mr = "MR"
    case ms = "MS"
    case mt = "MT"
    case mu = "MU"
    case mv = "MV"
    case mw = "MW"
    case mx = "MX"
    case my = "MY"
    case mz = "MZ"
    case na = "NA"
    case nc = "NC"
    case ne = "NE"
    case nf = "NF"
    case ng = "NG"
    case ni = "NI"
    case nl = "NL"
    case no = "NO"
    case np = "NP"
    case nr = "NR"
    case nu = "NU"
    case nz = "NZ"
    case om = "OM"
    case pa = "PA"
    case pe = "PE"
    case pf = "PF"
    case pg = "PG"
    case ph = "PH"
    case pk = "PK"
    case pl = "PL"
    case pm = "PM"
    case pn = "PN"
    case pr = "PR"
    case ps = "PS"
    case pt = "PT"
    case pw = "PW"
    case py = "PY"
    case qa = "QA"
    case re = "RE"
    case ro = "RO"
    case rs = "RS"
    case ru = "RU"
    case rw = "RW"
    case sa = "SA"
    case sb = "SB"
    case sc = "SC"
    case sd = "SD"
    case se = "SE"
    case sg = "SG"
    case sh = "SH"
    case si = "SI"
    case sj = "SJ"
    case sk = "SK"
    case sl = "SL"
    case sm = "SM"
    case sn = "SN"
    case so = "SO"
    case sr = "SR"
    case ss = "SS"
    case st = "ST"
    case sv = "SV"
    case sx = "SX"
    case sy = "SY"
    case sz = "SZ"
    case ta = "TA"
    case tc = "TC"
    case td = "TD"
    case tf = "TF"
    case tg = "TG"
    case th = "TH"
    case tj = "TJ"
    case tk = "TK"
    case tl = "TL"
    case tm = "TM"
    case tn = "TN"
    case to = "TO"
    case tr = "TR"
    case tt = "TT"
    case tv = "TV"
    case tw = "TW"
    case tz = "TZ"
    case ua = "UA"
    case ug = "UG"
    case um = "UM"
    case us = "US"
    case uy = "UY"
    case uz = "UZ"
    case va = "VA"
    case vc = "VC"
    case ve = "VE"
    case vg = "VG"
    case vi = "VI"
    case vn = "VN"
    case vu = "VU"
    case wf = "WF"
    case ws = "WS"
    case xa = "XA"
    case xb = "XB"
    case xk = "XK"
    case ye = "YE"
    case yt = "YT"
    case za = "ZA"
    case zm = "ZM"
    case zw = "ZW"
}

public enum Currency: String, Codable, CaseIterable {
    case aud = "AUD"
    case bgn = "BGN"
    case brl = "BRL"
    case cad = "CAD"
    case chf = "CHF"
    case cny = "CNY"
    case czk = "CZK"
    case dkk = "DKK"
    case eur = "EUR"
    case gbp = "GBP"
    case hkd = "HKD"
    case hrk = "HRK"
    case huf = "HUF"
    case idr = "IDR"
    case ils = "ILS"
    case inr = "INR"
    case isk = "ISK"
    case jpy = "JPY"
    case krw = "KRW"
    case ltl = "LTL"
    case lvl = "LVL"
    case mxn = "MXN"
    case myr = "MYR"
    case nok = "NOK"
    case nzd = "NZD"
    case php = "PHP"
    case pln = "PLN"
    case ron = "RON"
    case rsd = "RSD"
    case rub = "RUB"
    case sek = "SEK"
    case sgd = "SGD"
    case thb = "THB"
    case `try` = "TRY"
    case uah = "UAH"
    case usd = "USD"
    case zar = "ZAR"
}

public struct ConversationRate: Codable {
    public var fromCurrency: Currency?
    public var toCurrency: Currency?
    public var conversationRate: Double?

    public init(fromCurrency: Currency? = nil, toCurrency: Currency? = nil, conversationRate: Double? = nil) {
        self.fromCurrency = fromCurrency
        self.toCurrency = toCurrency
        self.conversationRate = conversationRate
    }

    private enum CodingKeys: String, CodingKey {
        case fromCurrency = "from_currency"
        case toCurrency = "to_currency"
        case conversationRate = "conversation_rate"
    }
}

/// Document object representing your invoice.
public struct Document: Codable {
    /// The document's unique identifier.
    public var id: Int?
    /// The document's invoice number.
    ///
    /// Example: "PREFIX / 2020-000001"
    public var invoiceNumber: String?
    public var type: DocumentType?
    public var isCancelled: Bool?
    /// DocumentBlock's identifier.
    public var blockID: Int?
    public var paymentStatus: PaymentStatus?
    public var paymentMethod: PaymentMethod?
    /// The document's gross total price.
    public var grossTotal: Double?
    public var currency: Currency?
    public var conversionRate: Double?
    public var invoiceDate: NaiveDate?
    public var fulfillmentDate: NaiveDate?
    public var dueDate: NaiveDate?
    public var paidDate: NaiveDate?
    public var organization: DocumentOrganization?
    public var partner: Partner?
    public var isElectronic: Bool?
    public var comment: String?
    public var tags: [String]?
    public var notificationStatus: DocumentNotificationStatus?
    public var language: DocumentLanguage?
    public var items: [DocumentItem]?
    public var summary: DocumentSummary?
    public var settings: DocumentSettings?

    public init(id: Int? = nil, invoiceNumber: String? = nil, type: DocumentType? = nil, isCancelled: Bool? = nil, blockID: Int? = nil, paymentStatus: PaymentStatus? = nil, paymentMethod: PaymentMethod? = nil, grossTotal: Double? = nil, currency: Currency? = nil, conversionRate: Double? = nil, invoiceDate: NaiveDate? = nil, fulfillmentDate: NaiveDate? = nil, dueDate: NaiveDate? = nil, paidDate: NaiveDate? = nil, organization: DocumentOrganization? = nil, partner: Partner? = nil, isElectronic: Bool? = nil, comment: String? = nil, tags: [String]? = nil, notificationStatus: DocumentNotificationStatus? = nil, language: DocumentLanguage? = nil, items: [DocumentItem]? = nil, summary: DocumentSummary? = nil, settings: DocumentSettings? = nil) {
        self.id = id
        self.invoiceNumber = invoiceNumber
        self.type = type
        self.isCancelled = isCancelled
        self.blockID = blockID
        self.paymentStatus = paymentStatus
        self.paymentMethod = paymentMethod
        self.grossTotal = grossTotal
        self.currency = currency
        self.conversionRate = conversionRate
        self.invoiceDate = invoiceDate
        self.fulfillmentDate = fulfillmentDate
        self.dueDate = dueDate
        self.paidDate = paidDate
        self.organization = organization
        self.partner = partner
        self.isElectronic = isElectronic
        self.comment = comment
        self.tags = tags
        self.notificationStatus = notificationStatus
        self.language = language
        self.items = items
        self.summary = summary
        self.settings = settings
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case invoiceNumber = "invoice_number"
        case type
        case isCancelled = "cancelled"
        case blockID = "block_id"
        case paymentStatus = "payment_status"
        case paymentMethod = "payment_method"
        case grossTotal = "gross_total"
        case currency
        case conversionRate = "conversion_rate"
        case invoiceDate = "invoice_date"
        case fulfillmentDate = "fulfillment_date"
        case dueDate = "due_date"
        case paidDate = "paid_date"
        case organization
        case partner
        case isElectronic = "electronic"
        case comment
        case tags
        case notificationStatus = "notification_status"
        case language
        case items
        case summary
        case settings
    }
}

public struct DocumentBankAccount: Codable {
    public var id: Int?
    public var name: String
    public var accountNumber: String
    public var accountNumberIban: String?
    public var swift: String?

    public init(id: Int? = nil, name: String, accountNumber: String, accountNumberIban: String? = nil, swift: String? = nil) {
        self.id = id
        self.name = name
        self.accountNumber = accountNumber
        self.accountNumberIban = accountNumberIban
        self.swift = swift
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case accountNumber = "account_number"
        case accountNumberIban = "account_number_iban"
        case swift
    }
}

public struct DocumentInsert: Codable {
    public var vendorID: String?
    public var partnerID: Int
    public var blockID: Int
    public var bankAccountID: Int?
    public var type: DocumentInsertType
    public var fulfillmentDate: NaiveDate
    public var dueDate: NaiveDate
    public var paymentMethod: PaymentMethod
    public var language: DocumentLanguage
    public var currency: Currency
    public var conversionRate: Double?
    public var isElectronic: Bool
    public var isPaid: Bool
    public var items: [Item]?
    public var comment: String?
    public var settings: DocumentSettings?

    public enum Item: Codable {
        case documentItemData(DocumentItemData)
        case documentProductData(DocumentProductData)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(DocumentItemData.self) {
                self = .documentItemData(value)
            } else if let value = try? container.decode(DocumentProductData.self) {
                self = .documentProductData(value)
            } else {
                throw DecodingError.dataCorruptedError(in: container, debugDescription: "Failed to intialize `oneOf`")
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
            case .documentItemData(let value): try container.encode(value)
            case .documentProductData(let value): try container.encode(value)
            }
        }
    }

    public init(vendorID: String? = nil, partnerID: Int, blockID: Int, bankAccountID: Int? = nil, type: DocumentInsertType, fulfillmentDate: NaiveDate, dueDate: NaiveDate, paymentMethod: PaymentMethod, language: DocumentLanguage, currency: Currency, conversionRate: Double? = nil, isElectronic: Bool? = nil, isPaid: Bool? = nil, items: [Item]? = nil, comment: String? = nil, settings: DocumentSettings? = nil) {
        self.vendorID = vendorID
        self.partnerID = partnerID
        self.blockID = blockID
        self.bankAccountID = bankAccountID
        self.type = type
        self.fulfillmentDate = fulfillmentDate
        self.dueDate = dueDate
        self.paymentMethod = paymentMethod
        self.language = language
        self.currency = currency
        self.conversionRate = conversionRate
        self.isElectronic = isElectronic ?? false
        self.isPaid = isPaid ?? false
        self.items = items
        self.comment = comment
        self.settings = settings
    }

    private enum CodingKeys: String, CodingKey {
        case vendorID = "vendor_id"
        case partnerID = "partner_id"
        case blockID = "block_id"
        case bankAccountID = "bank_account_id"
        case type
        case fulfillmentDate = "fulfillment_date"
        case dueDate = "due_date"
        case paymentMethod = "payment_method"
        case language
        case currency
        case conversionRate = "conversion_rate"
        case isElectronic = "electronic"
        case isPaid = "paid"
        case items
        case comment
        case settings
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.vendorID = try values.decodeIfPresent(String.self, forKey: .vendorID)
        self.partnerID = try values.decode(Int.self, forKey: .partnerID)
        self.blockID = try values.decode(Int.self, forKey: .blockID)
        self.bankAccountID = try values.decodeIfPresent(Int.self, forKey: .bankAccountID)
        self.type = try values.decode(DocumentInsertType.self, forKey: .type)
        self.fulfillmentDate = try values.decode(NaiveDate.self, forKey: .fulfillmentDate)
        self.dueDate = try values.decode(NaiveDate.self, forKey: .dueDate)
        self.paymentMethod = try values.decode(PaymentMethod.self, forKey: .paymentMethod)
        self.language = try values.decode(DocumentLanguage.self, forKey: .language)
        self.currency = try values.decode(Currency.self, forKey: .currency)
        self.conversionRate = try values.decodeIfPresent(Double.self, forKey: .conversionRate)
        self.isElectronic = try values.decodeIfPresent(Bool.self, forKey: .isElectronic) ?? false
        self.isPaid = try values.decodeIfPresent(Bool.self, forKey: .isPaid) ?? false
        self.items = try values.decodeIfPresent([Item].self, forKey: .items)
        self.comment = try values.decodeIfPresent(String.self, forKey: .comment)
        self.settings = try values.decodeIfPresent(DocumentSettings.self, forKey: .settings)
    }
}

public enum DocumentInsertType: String, Codable, CaseIterable {
    case advance
    case draft
    case invoice
    case proforma
}

public struct DocumentItem: Codable {
    public var productID: Int?
    public var name: String?
    public var netUnitAmount: Double?
    public var quantity: Double?
    public var netAmount: Double?
    public var grossAmount: Double?
    public var vat: Vat?
    public var vatAmount: Double?

    public init(productID: Int? = nil, name: String? = nil, netUnitAmount: Double? = nil, quantity: Double? = nil, netAmount: Double? = nil, grossAmount: Double? = nil, vat: Vat? = nil, vatAmount: Double? = nil) {
        self.productID = productID
        self.name = name
        self.netUnitAmount = netUnitAmount
        self.quantity = quantity
        self.netAmount = netAmount
        self.grossAmount = grossAmount
        self.vat = vat
        self.vatAmount = vatAmount
    }

    private enum CodingKeys: String, CodingKey {
        case productID = "product_id"
        case name
        case netUnitAmount = "net_unit_amount"
        case quantity
        case netAmount = "net_amount"
        case grossAmount = "gross_amount"
        case vat
        case vatAmount = "vat_amount"
    }
}

public struct DocumentItemData: Codable {
    public var productID: Int
    public var quantity: Double

    public init(productID: Int, quantity: Double) {
        self.productID = productID
        self.quantity = quantity
    }

    private enum CodingKeys: String, CodingKey {
        case productID = "product_id"
        case quantity
    }
}

public enum DocumentLanguage: String, Codable, CaseIterable {
    case de
    case en
    case fr
    case hr
    case hu
    case it
    case ro
    case sk
}

/// A object with a data property that contains an array of up to limit documents. Each entry in the array is a separate document object. If no more documents are available, the resulting array will be empty.
public struct DocumentList: Codable {
    public var data: [Document]?
    public var total: Int?
    public var perPage: Int?
    public var currentPage: Int?
    public var lastPage: Int?
    public var prevPageURL: String?
    public var nextPageURL: String?

    public init(data: [Document]? = nil, total: Int? = nil, perPage: Int? = nil, currentPage: Int? = nil, lastPage: Int? = nil, prevPageURL: String? = nil, nextPageURL: String? = nil) {
        self.data = data
        self.total = total
        self.perPage = perPage
        self.currentPage = currentPage
        self.lastPage = lastPage
        self.prevPageURL = prevPageURL
        self.nextPageURL = nextPageURL
    }

    private enum CodingKeys: String, CodingKey {
        case data
        case total
        case perPage = "per_page"
        case currentPage = "current_page"
        case lastPage = "last_page"
        case prevPageURL = "prev_page_url"
        case nextPageURL = "next_page_url"
    }
}

public enum DocumentNotificationStatus: String, Codable, CaseIterable {
    case closed
    case downloaded
    case failed
    case `none`
    case opened
    case readed
}

public struct DocumentOrganization: Codable {
    public var name: String?
    public var taxNumber: String?
    public var bankAccount: DocumentBankAccount?
    public var address: Address?
    public var isSmallTaxpayer: Bool?
    public var evNumber: String?
    public var euTaxNumber: String?
    public var isCashSettled: Bool?

    public init(name: String? = nil, taxNumber: String? = nil, bankAccount: DocumentBankAccount? = nil, address: Address? = nil, isSmallTaxpayer: Bool? = nil, evNumber: String? = nil, euTaxNumber: String? = nil, isCashSettled: Bool? = nil) {
        self.name = name
        self.taxNumber = taxNumber
        self.bankAccount = bankAccount
        self.address = address
        self.isSmallTaxpayer = isSmallTaxpayer
        self.evNumber = evNumber
        self.euTaxNumber = euTaxNumber
        self.isCashSettled = isCashSettled
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case taxNumber = "tax_number"
        case bankAccount = "bank_account"
        case address
        case isSmallTaxpayer = "small_taxpayer"
        case evNumber = "ev_number"
        case euTaxNumber = "eu_tax_number"
        case isCashSettled = "cash_settled"
    }
}

public struct DocumentProductData: Codable {
    public var name: String
    public var unitPrice: Double
    public var unitPriceType: UnitPriceType
    public var quantity: Double
    public var unit: String
    public var vat: Vat
    public var comment: String?

    public init(name: String, unitPrice: Double, unitPriceType: UnitPriceType, quantity: Double, unit: String, vat: Vat, comment: String? = nil) {
        self.name = name
        self.unitPrice = unitPrice
        self.unitPriceType = unitPriceType
        self.quantity = quantity
        self.unit = unit
        self.vat = vat
        self.comment = comment
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case unitPrice = "unit_price"
        case unitPriceType = "unit_price_type"
        case quantity
        case unit
        case vat
        case comment
    }
}

public struct DocumentPublicURL: Codable {
    public var publicURL: String?

    public init(publicURL: String? = nil) {
        self.publicURL = publicURL
    }

    private enum CodingKeys: String, CodingKey {
        case publicURL = "public_url"
    }
}

public struct DocumentSettings: Codable {
    public var isMediatedService: Bool
    public var isWithoutFinancialFulfillment: Bool
    public var onlinePayment: OnlinePayment?
    public var round: Round?
    public var placeID: Int?

    public init(isMediatedService: Bool? = nil, isWithoutFinancialFulfillment: Bool? = nil, onlinePayment: OnlinePayment? = nil, round: Round? = nil, placeID: Int? = nil) {
        self.isMediatedService = isMediatedService ?? false
        self.isWithoutFinancialFulfillment = isWithoutFinancialFulfillment ?? false
        self.onlinePayment = onlinePayment
        self.round = round
        self.placeID = placeID
    }

    private enum CodingKeys: String, CodingKey {
        case isMediatedService = "mediated_service"
        case isWithoutFinancialFulfillment = "without_financial_fulfillment"
        case onlinePayment = "online_payment"
        case round
        case placeID = "place_id"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isMediatedService = try values.decodeIfPresent(Bool.self, forKey: .isMediatedService) ?? false
        self.isWithoutFinancialFulfillment = try values.decodeIfPresent(Bool.self, forKey: .isWithoutFinancialFulfillment) ?? false
        self.onlinePayment = try values.decodeIfPresent(OnlinePayment.self, forKey: .onlinePayment)
        self.round = try values.decodeIfPresent(Round.self, forKey: .round)
        self.placeID = try values.decodeIfPresent(Int.self, forKey: .placeID)
    }
}

public struct DocumentSummary: Codable {
    public var netAmount: Double?
    public var netAmountLocal: Double?
    public var grossAmountLocal: Double?
    public var vatAmount: Double?
    public var vatAmountLocal: Double?
    public var vatRateSummary: [DocumentVatRateSummary]?

    public init(netAmount: Double? = nil, netAmountLocal: Double? = nil, grossAmountLocal: Double? = nil, vatAmount: Double? = nil, vatAmountLocal: Double? = nil, vatRateSummary: [DocumentVatRateSummary]? = nil) {
        self.netAmount = netAmount
        self.netAmountLocal = netAmountLocal
        self.grossAmountLocal = grossAmountLocal
        self.vatAmount = vatAmount
        self.vatAmountLocal = vatAmountLocal
        self.vatRateSummary = vatRateSummary
    }

    private enum CodingKeys: String, CodingKey {
        case netAmount = "net_amount"
        case netAmountLocal = "net_amount_local"
        case grossAmountLocal = "gross_amount_local"
        case vatAmount = "vat_amount"
        case vatAmountLocal = "vat_amount_local"
        case vatRateSummary = "vat_rate_summary"
    }
}

public enum DocumentType: String, Codable, CaseIterable {
    case advance
    case canceled
    case cancellation
    case draft
    case invoice
    case proforma
}

public struct DocumentVatRateSummary: Codable {
    public var vatName: String?
    public var vatPercentage: Double?
    public var vatRateNetAmount: Double?
    public var vatRateVatAmount: Double?
    public var vatRateVatAmountLocal: Double?
    public var vatRateGrossAmount: Double?

    public init(vatName: String? = nil, vatPercentage: Double? = nil, vatRateNetAmount: Double? = nil, vatRateVatAmount: Double? = nil, vatRateVatAmountLocal: Double? = nil, vatRateGrossAmount: Double? = nil) {
        self.vatName = vatName
        self.vatPercentage = vatPercentage
        self.vatRateNetAmount = vatRateNetAmount
        self.vatRateVatAmount = vatRateVatAmount
        self.vatRateVatAmountLocal = vatRateVatAmountLocal
        self.vatRateGrossAmount = vatRateGrossAmount
    }

    private enum CodingKeys: String, CodingKey {
        case vatName = "vat_name"
        case vatPercentage = "vat_percentage"
        case vatRateNetAmount = "vat_rate_net_amount"
        case vatRateVatAmount = "vat_rate_vat_amount"
        case vatRateVatAmountLocal = "vat_rate_vat_amount_local"
        case vatRateGrossAmount = "vat_rate_gross_amount"
    }
}

public enum OnlinePayment: String, Codable, CaseIterable {
    case empty = ""
    case barion = "Barion"
    case simplePay = "SimplePay"
    case no
}

public struct OnlineSzamlaStatus: Codable {
    public var transactionID: String?
    public var status: String?
    public var messages: [OnlineSzamlaStatusMessage]?

    public init(transactionID: String? = nil, status: String? = nil, messages: [OnlineSzamlaStatusMessage]? = nil) {
        self.transactionID = transactionID
        self.status = status
        self.messages = messages
    }

    private enum CodingKeys: String, CodingKey {
        case transactionID = "transaction_id"
        case status
        case messages
    }
}

public struct OnlineSzamlaStatusMessage: Codable {
    public var validationResultCode: String?
    public var validationErrorCode: String?
    public var humanReadableMessage: String?

    public init(validationResultCode: String? = nil, validationErrorCode: String? = nil, humanReadableMessage: String? = nil) {
        self.validationResultCode = validationResultCode
        self.validationErrorCode = validationErrorCode
        self.humanReadableMessage = humanReadableMessage
    }

    private enum CodingKeys: String, CodingKey {
        case validationResultCode = "validation_result_code"
        case validationErrorCode = "validation_error_code"
        case humanReadableMessage = "human_readable_message"
    }
}

public struct PaymentHistory: Codable {
    public var date: NaiveDate
    public var price: Double
    public var paymentMethod: PaymentMethod
    public var voucherNumber: String?
    public var conversionRate: Double?

    public init(date: NaiveDate, price: Double, paymentMethod: PaymentMethod, voucherNumber: String? = nil, conversionRate: Double? = nil) {
        self.date = date
        self.price = price
        self.paymentMethod = paymentMethod
        self.voucherNumber = voucherNumber
        self.conversionRate = conversionRate
    }

    private enum CodingKeys: String, CodingKey {
        case date
        case price
        case paymentMethod = "payment_method"
        case voucherNumber = "voucher_number"
        case conversionRate = "conversion_rate"
    }
}

public enum PaymentMethod: String, Codable, CaseIterable {
    case aruhitel
    case bankcard
    case barion
    case barter
    case cash
    case cashOnDelivery = "cash_on_delivery"
    case coupon
    case eloreUtalas = "elore_utalas"
    case epKartya = "ep_kartya"
    case kompenzacio
    case levonas
    case onlineBankcard = "online_bankcard"
    case payoneer
    case paypal
    case paypalUtolag = "paypal_utolag"
    case payu
    case pickPackPont = "pick_pack_pont"
    case postaiCsekk = "postai_csekk"
    case postautalvany
    case skrill
    case szepCard = "szep_card"
    case transferwise
    case upwork
    case utalvany
    case valto
    case wireTransfer = "wire_transfer"
}

public enum PaymentStatus: String, Codable, CaseIterable {
    case expired
    case `none`
    case outstanding
    case paid
    case partiallyPaid = "partially_paid"
}

public enum Round: String, Codable, CaseIterable {
    case five
    case `none`
    case one
    case ten
}

public struct SendDocument: Codable {
    public var emails: [String]?

    public init(emails: [String]? = nil) {
        self.emails = emails
    }
}

public enum UnitPriceType: String, Codable, CaseIterable {
    case gross
    case net
}

public enum Vat: String, Codable, CaseIterable {
    case _0 = "0%"
    case _1 = "1%"
    case _10 = "10%"
    case _11 = "11%"
    case _12 = "12%"
    case _13 = "13%"
    case _14 = "14%"
    case _15 = "15%"
    case _16 = "16%"
    case _17 = "17%"
    case _18 = "18%"
    case _19 = "19%"
    case _2 = "2%"
    case _20 = "20%"
    case _21 = "21%"
    case _22 = "22%"
    case _23 = "23%"
    case _24 = "24%"
    case _25 = "25%"
    case _26 = "26%"
    case _27 = "27%"
    case _3 = "3%"
    case _4 = "4%"
    case _5 = "5%"
    case _6 = "6%"
    case _7 = "7%"
    case _8 = "8%"
    case _9 = "9%"
    case aam = "AAM"
    case am = "AM"
    case eu = "EU"
    case euk = "EUK"
    case fAfa = "F.AFA"
    case fad = "FAD"
    case kAfa = "K.AFA"
    case maa = "MAA"
    case tam = "TAM"
    case ãKk = "ÃKK"
    case ãThk = "ÃTHK"
}

public struct DocumentBlock: Codable {
    public var id: Int?
    public var name: String?
    public var prefix: String?
    public var customField1: String?
    public var customField2: String?

    public init(id: Int? = nil, name: String? = nil, prefix: String? = nil, customField1: String? = nil, customField2: String? = nil) {
        self.id = id
        self.name = name
        self.prefix = prefix
        self.customField1 = customField1
        self.customField2 = customField2
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case prefix
        case customField1 = "custom_field1"
        case customField2 = "custom_field2"
    }
}

/// A object with a data property that contains an array of up to limit document blocks. Each entry in the array is a separate document block object. If no more document block are available, the resulting array will be empty.
public struct DocumentBlockList: Codable {
    public var data: [DocumentBlock]?
    public var total: Int?
    public var perPage: Int?
    public var currentPage: Int?
    public var lastPage: Int?
    public var prevPageURL: String?
    public var nextPageURL: String?

    public init(data: [DocumentBlock]? = nil, total: Int? = nil, perPage: Int? = nil, currentPage: Int? = nil, lastPage: Int? = nil, prevPageURL: String? = nil, nextPageURL: String? = nil) {
        self.data = data
        self.total = total
        self.perPage = perPage
        self.currentPage = currentPage
        self.lastPage = lastPage
        self.prevPageURL = prevPageURL
        self.nextPageURL = nextPageURL
    }

    private enum CodingKeys: String, CodingKey {
        case data
        case total
        case perPage = "per_page"
        case currentPage = "current_page"
        case lastPage = "last_page"
        case prevPageURL = "prev_page_url"
        case nextPageURL = "next_page_url"
    }
}

public struct OrganizationData: Codable {
    public var taxCode: String?

    public init(taxCode: String? = nil) {
        self.taxCode = taxCode
    }

    private enum CodingKeys: String, CodingKey {
        case taxCode = "tax_code"
    }
}

public struct Partner: Codable {
    public var partnerUpsert: PartnerUpsert
    public var id: Int?

    public init(partnerUpsert: PartnerUpsert, id: Int? = nil) {
        self.partnerUpsert = partnerUpsert
        self.id = id
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.partnerUpsert = try PartnerUpsert(from: decoder)
        self.id = try values.decodeIfPresent(Int.self, forKey: "id")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(partnerUpsert, forKey: "partnerUpsert")
        try values.encodeIfPresent(id, forKey: "id")
    }
}

/// A object with a data property that contains an array of up to limit partners. Each entry in the array is a separate partner object. If no more partners are available, the resulting array will be empty.
public struct PartnerList: Codable {
    public var data: [Partner]?
    public var total: Int?
    public var perPage: Int?
    public var currentPage: Int?
    public var lastPage: Int?
    public var prevPageURL: String?
    public var nextPageURL: String?

    public init(data: [Partner]? = nil, total: Int? = nil, perPage: Int? = nil, currentPage: Int? = nil, lastPage: Int? = nil, prevPageURL: String? = nil, nextPageURL: String? = nil) {
        self.data = data
        self.total = total
        self.perPage = perPage
        self.currentPage = currentPage
        self.lastPage = lastPage
        self.prevPageURL = prevPageURL
        self.nextPageURL = nextPageURL
    }

    private enum CodingKeys: String, CodingKey {
        case data
        case total
        case perPage = "per_page"
        case currentPage = "current_page"
        case lastPage = "last_page"
        case prevPageURL = "prev_page_url"
        case nextPageURL = "next_page_url"
    }
}

public struct PartnerUpsert: Codable {
    public var name: String
    public var address: Address
    public var emails: [String]?
    public var taxcode: String?
    public var iban: String?
    public var swift: String?
    public var accountNumber: String?
    public var phone: String?
    public var generalLedgerNumber: String?

    public init(name: String, address: Address, emails: [String]? = nil, taxcode: String? = nil, iban: String? = nil, swift: String? = nil, accountNumber: String? = nil, phone: String? = nil, generalLedgerNumber: String? = nil) {
        self.name = name
        self.address = address
        self.emails = emails
        self.taxcode = taxcode
        self.iban = iban
        self.swift = swift
        self.accountNumber = accountNumber
        self.phone = phone
        self.generalLedgerNumber = generalLedgerNumber
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case address
        case emails
        case taxcode
        case iban
        case swift
        case accountNumber = "account_number"
        case phone
        case generalLedgerNumber = "general_ledger_number"
    }
}

public struct Product: Codable {
    public var id: Int?
    public var name: String
    public var comment: String?
    public var currency: Currency
    public var vat: Vat
    public var netUnitPrice: Double?
    public var unit: String
    public var generalLedgerNumber: String?
    public var generalLedgerTaxcode: String?

    public init(id: Int? = nil, name: String, comment: String? = nil, currency: Currency, vat: Vat, netUnitPrice: Double? = nil, unit: String, generalLedgerNumber: String? = nil, generalLedgerTaxcode: String? = nil) {
        self.id = id
        self.name = name
        self.comment = comment
        self.currency = currency
        self.vat = vat
        self.netUnitPrice = netUnitPrice
        self.unit = unit
        self.generalLedgerNumber = generalLedgerNumber
        self.generalLedgerTaxcode = generalLedgerTaxcode
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case comment
        case currency
        case vat
        case netUnitPrice = "net_unit_price"
        case unit
        case generalLedgerNumber = "general_ledger_number"
        case generalLedgerTaxcode = "general_ledger_taxcode"
    }
}

/// A object with a data property that contains an array of up to limit products. Each entry in the array is a separate product object. If no more products are available, the resulting array will be empty.
public struct ProductList: Codable {
    public var data: [Product]?
    public var total: Int?
    public var perPage: Int?
    public var currentPage: Int?
    public var lastPage: Int?
    public var prevPageURL: String?
    public var nextPageURL: String?

    public init(data: [Product]? = nil, total: Int? = nil, perPage: Int? = nil, currentPage: Int? = nil, lastPage: Int? = nil, prevPageURL: String? = nil, nextPageURL: String? = nil) {
        self.data = data
        self.total = total
        self.perPage = perPage
        self.currentPage = currentPage
        self.lastPage = lastPage
        self.prevPageURL = prevPageURL
        self.nextPageURL = nextPageURL
    }

    private enum CodingKeys: String, CodingKey {
        case data
        case total
        case perPage = "per_page"
        case currentPage = "current_page"
        case lastPage = "last_page"
        case prevPageURL = "prev_page_url"
        case nextPageURL = "next_page_url"
    }
}

public struct ID: Codable {
    public var id: Int?
    public var legacyID: Int?

    public init(id: Int? = nil, legacyID: Int? = nil) {
        self.id = id
        self.legacyID = legacyID
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case legacyID = "legacy_id"
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
