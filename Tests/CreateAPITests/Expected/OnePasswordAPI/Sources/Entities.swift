// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

public struct ErrorResponse: Codable {
    /// HTTP Status Code
    public var status: Int?
    /// A message detailing the error
    public var message: String?

    public init(status: Int? = nil, message: String? = nil) {
        self.status = status
        self.message = message
    }
}

/// Example:
///
/// {
///   "content" : "VGhlIGZ1dHVyZSBiZWxvbmdzIHRvIHRoZSBjdXJpb3VzLgo=",
///   "content_path" : "v1\/vaults\/ionaiwtdvgclrixbt6ztpqcxnq\/items\/p7eflcy7f5mk7vg6zrzf5rjjyu\/files\/6r65pjq33banznomn7q22sj44e\/content",
///   "id" : "6r65pjq33banznomn7q22sj44e",
///   "name" : "foo.txt",
///   "size" : 35
/// }
public struct File: Codable {
    /// ID of the file
    public var id: String?
    /// Name of the file
    public var name: String?
    /// Size in bytes of the file
    public var size: Int?
    /// Path of the Connect API that can be used to download the contents of this file.
    public var contentPath: String?
    /// For files that are in a section, this field describes the section.
    public var section: Section?
    /// Base64-encoded contents of the file. Only set if size <= OP_MAX_INLINE_FILE_SIZE_KB kb and `inline_files` is set to `true`.
    public var content: String?

    /// For files that are in a section, this field describes the section.
    public struct Section: Codable {
        public var id: String?

        public init(id: String? = nil) {
            self.id = id
        }
    }

    public init(id: String? = nil, name: String? = nil, size: Int? = nil, contentPath: String? = nil, section: Section? = nil, content: String? = nil) {
        self.id = id
        self.name = name
        self.size = size
        self.contentPath = contentPath
        self.section = section
        self.content = content
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case size
        case contentPath = "content_path"
        case section
        case content
    }
}

public struct Vault: Codable {
    public var id: String?
    public var name: String?
    public var description: String?
    /// The vault version
    public var attributeVersion: Int?
    /// The version of the vault contents
    public var contentVersion: Int?
    /// Number of active items in the vault
    public var items: Int?
    public var type: `Type`?
    public var createdAt: Date?
    public var updatedAt: Date?

    public enum `Type`: String, Codable, CaseIterable {
        case userCreated = "USER_CREATED"
        case personal = "PERSONAL"
        case everyone = "EVERYONE"
        case transfer = "TRANSFER"
    }

    public init(id: String? = nil, name: String? = nil, description: String? = nil, attributeVersion: Int? = nil, contentVersion: Int? = nil, items: Int? = nil, type: `Type`? = nil, createdAt: Date? = nil, updatedAt: Date? = nil) {
        self.id = id
        self.name = name
        self.description = description
        self.attributeVersion = attributeVersion
        self.contentVersion = contentVersion
        self.items = items
        self.type = type
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }
}

/// The recipe is used in conjunction with the "generate" property to set the character set used to generate a new secure value
public struct GeneratorRecipe: Codable {
    /// Length of the generated value
    public var length: Int?
    public var characterSets: [CharacterSet]?

    public enum CharacterSet: String, Codable, CaseIterable {
        case letters = "LETTERS"
        case digits = "DIGITS"
        case symbols = "SYMBOLS"
    }

    public init(length: Int? = nil, characterSets: [CharacterSet]? = nil) {
        self.length = length
        self.characterSets = characterSets
    }
}

public struct Item: Codable {
    public var id: String?
    public var title: String?
    public var vault: Vault
    public var category: Category
    /// Example:
    ///
    /// [
    ///   {
    ///     "href" : "https:\/\/example.com",
    ///     "primary" : true
    ///   },
    ///   {
    ///     "href" : "https:\/\/example.org"
    ///   }
    /// ]
    public var urls: [URL]?
    public var isFavorite: Bool
    public var tags: [String]?
    public var version: Int?
    public var state: State?
    public var createdAt: Date?
    public var updatedAt: Date?
    public var lastEditedBy: String?

    public struct Vault: Codable {
        public var id: String

        public init(id: String) {
            self.id = id
        }
    }

    public enum Category: String, Codable, CaseIterable {
        case login = "LOGIN"
        case password = "PASSWORD"
        case apiCredential = "API_CREDENTIAL"
        case server = "SERVER"
        case database = "DATABASE"
        case creditCard = "CREDIT_CARD"
        case membership = "MEMBERSHIP"
        case passport = "PASSPORT"
        case softwareLicense = "SOFTWARE_LICENSE"
        case outdoorLicense = "OUTDOOR_LICENSE"
        case secureNote = "SECURE_NOTE"
        case wirelessRouter = "WIRELESS_ROUTER"
        case bankAccount = "BANK_ACCOUNT"
        case driverLicense = "DRIVER_LICENSE"
        case identity = "IDENTITY"
        case rewardProgram = "REWARD_PROGRAM"
        case document = "DOCUMENT"
        case emailAccount = "EMAIL_ACCOUNT"
        case socialSecurityNumber = "SOCIAL_SECURITY_NUMBER"
        case custom = "CUSTOM"
    }

    public struct URL: Codable {
        public var isPrimary: Bool?
        public var href: String

        public init(isPrimary: Bool? = nil, href: String) {
            self.isPrimary = isPrimary
            self.href = href
        }

        private enum CodingKeys: String, CodingKey {
            case isPrimary = "primary"
            case href
        }
    }

    public enum State: String, Codable, CaseIterable {
        case archived = "ARCHIVED"
        case deleted = "DELETED"
    }

    public init(id: String? = nil, title: String? = nil, vault: Vault, category: Category, urls: [URL]? = nil, isFavorite: Bool? = nil, tags: [String]? = nil, version: Int? = nil, state: State? = nil, createdAt: Date? = nil, updatedAt: Date? = nil, lastEditedBy: String? = nil) {
        self.id = id
        self.title = title
        self.vault = vault
        self.category = category
        self.urls = urls
        self.isFavorite = isFavorite ?? false
        self.tags = tags
        self.version = version
        self.state = state
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.lastEditedBy = lastEditedBy
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case title
        case vault
        case category
        case urls
        case isFavorite = "favorite"
        case tags
        case version
        case state
        case createdAt
        case updatedAt
        case lastEditedBy
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.id = try values.decodeIfPresent(String.self, forKey: .id)
        self.title = try values.decodeIfPresent(String.self, forKey: .title)
        self.vault = try values.decode(Vault.self, forKey: .vault)
        self.category = try values.decode(Category.self, forKey: .category)
        self.urls = try values.decodeIfPresent([URL].self, forKey: .urls)
        self.isFavorite = try values.decodeIfPresent(Bool.self, forKey: .isFavorite) ?? false
        self.tags = try values.decodeIfPresent([String].self, forKey: .tags)
        self.version = try values.decodeIfPresent(Int.self, forKey: .version)
        self.state = try values.decodeIfPresent(State.self, forKey: .state)
        self.createdAt = try values.decodeIfPresent(Date.self, forKey: .createdAt)
        self.updatedAt = try values.decodeIfPresent(Date.self, forKey: .updatedAt)
        self.lastEditedBy = try values.decodeIfPresent(String.self, forKey: .lastEditedBy)
    }
}

public struct FullItem: Codable {
    public var item: Item
    public var sections: [Section]?
    public var fields: [Field]?
    public var files: [File]?

    public struct Section: Codable {
        public var id: String?
        public var label: String?

        public init(id: String? = nil, label: String? = nil) {
            self.id = id
            self.label = label
        }
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.item = try Item(from: decoder)
        self.sections = try values.decodeIfPresent([Section].self, forKey: "sections")
        self.fields = try values.decodeIfPresent([Field].self, forKey: "fields")
        self.files = try values.decodeIfPresent([File].self, forKey: "files")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(item, forKey: "item")
        try values.encodeIfPresent(sections, forKey: "sections")
        try values.encodeIfPresent(fields, forKey: "fields")
        try values.encodeIfPresent(files, forKey: "files")
    }
}

public struct Field: Codable {
    public var id: String
    public var section: Section?
    public var type: `Type`
    /// Some item types, Login and Password, have fields used for autofill. This property indicates that purpose and is required for some item types.
    public var purpose: Purpose?
    public var label: String?
    public var value: String?
    /// If value is not present then a new value should be generated for this field
    public var isGenerate: Bool
    /// The recipe is used in conjunction with the "generate" property to set the character set used to generate a new secure value
    public var recipe: GeneratorRecipe?
    /// For fields with a purpose of `PASSWORD` this is the entropy of the value
    public var entropy: Double?

    public struct Section: Codable {
        public var id: String?

        public init(id: String? = nil) {
            self.id = id
        }
    }

    public enum `Type`: String, Codable, CaseIterable {
        case string = "STRING"
        case email = "EMAIL"
        case concealed = "CONCEALED"
        case url = "URL"
        case totp = "TOTP"
        case date = "DATE"
        case monthYear = "MONTH_YEAR"
        case menu = "MENU"
    }

    /// Some item types, Login and Password, have fields used for autofill. This property indicates that purpose and is required for some item types.
    public enum Purpose: String, Codable, CaseIterable {
        case username = "USERNAME"
        case password = "PASSWORD"
        case notes = "NOTES"
    }

    public init(id: String, section: Section? = nil, type: `Type`, purpose: Purpose? = nil, label: String? = nil, value: String? = nil, isGenerate: Bool? = nil, recipe: GeneratorRecipe? = nil, entropy: Double? = nil) {
        self.id = id
        self.section = section
        self.type = type
        self.purpose = purpose
        self.label = label
        self.value = value
        self.isGenerate = isGenerate ?? false
        self.recipe = recipe
        self.entropy = entropy
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case section
        case type
        case purpose
        case label
        case value
        case isGenerate = "generate"
        case recipe
        case entropy
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.id = try values.decode(String.self, forKey: .id)
        self.section = try values.decodeIfPresent(Section.self, forKey: .section)
        self.type = try values.decode(`Type`.self, forKey: .type)
        self.purpose = try values.decodeIfPresent(Purpose.self, forKey: .purpose)
        self.label = try values.decodeIfPresent(String.self, forKey: .label)
        self.value = try values.decodeIfPresent(String.self, forKey: .value)
        self.isGenerate = try values.decodeIfPresent(Bool.self, forKey: .isGenerate) ?? false
        self.recipe = try values.decodeIfPresent(GeneratorRecipe.self, forKey: .recipe)
        self.entropy = try values.decodeIfPresent(Double.self, forKey: .entropy)
    }
}

/// Represents a request that was made to the API. Including what Token was used and what resource was accessed.
public struct APIRequest: Codable {
    /// The unique id used to identify a single request.
    public var requestID: String?
    /// The time at which the request was processed by the server.
    public var timestamp: Date?
    public var action: Action?
    public var result: Result?
    public var actor: Actor?
    public var resource: Resource?

    public enum Action: String, Codable, CaseIterable {
        case read = "READ"
        case create = "CREATE"
        case update = "UPDATE"
        case delete = "DELETE"
    }

    public enum Result: String, Codable, CaseIterable {
        case success = "SUCCESS"
        case deny = "DENY"
    }

    public struct Actor: Codable {
        public var id: String?
        public var account: String?
        public var jti: String?
        public var userAgent: String?
        public var requestIp: String?

        public init(id: String? = nil, account: String? = nil, jti: String? = nil, userAgent: String? = nil, requestIp: String? = nil) {
            self.id = id
            self.account = account
            self.jti = jti
            self.userAgent = userAgent
            self.requestIp = requestIp
        }
    }

    public struct Resource: Codable {
        public var type: `Type`?
        public var vault: Vault?
        public var item: Item?
        public var itemVersion: Int?

        public enum `Type`: String, Codable, CaseIterable {
            case item = "ITEM"
            case vault = "VAULT"
        }

        public struct Vault: Codable {
            public var id: String?

            public init(id: String? = nil) {
                self.id = id
            }
        }

        public struct Item: Codable {
            public var id: String?

            public init(id: String? = nil) {
                self.id = id
            }
        }

        public init(type: `Type`? = nil, vault: Vault? = nil, item: Item? = nil, itemVersion: Int? = nil) {
            self.type = type
            self.vault = vault
            self.item = item
            self.itemVersion = itemVersion
        }
    }

    public init(requestID: String? = nil, timestamp: Date? = nil, action: Action? = nil, result: Result? = nil, actor: Actor? = nil, resource: Resource? = nil) {
        self.requestID = requestID
        self.timestamp = timestamp
        self.action = action
        self.result = result
        self.actor = actor
        self.resource = resource
    }

    private enum CodingKeys: String, CodingKey {
        case requestID = "requestId"
        case timestamp
        case action
        case result
        case actor
        case resource
    }
}

public typealias Patch = [PatchItem]

public struct PatchItem: Codable {
    public var op: Op
    /// An RFC6901 JSON Pointer pointing to the Item document, an Item Attribute, and Item Field by Field ID, or an Item Field Attribute
    ///
    /// Example: "/fields/06gnn2b95example10q91512p5/label"
    public var path: String
    public var value: Value?

    public enum Op: String, Codable, CaseIterable {
        case add
        case remove
        case replace
    }

    public struct Value: Codable {


        public init() {}
    }

    public init(op: Op, path: String, value: Value? = nil) {
        self.op = op
        self.path = path
        self.value = value
    }
}

/// The state of a registered server dependency.
public struct ServiceDependency: Codable {
    public var service: String?
    public var status: String?
    /// Human-readable message for explaining the current state.
    public var message: String?

    public init(service: String? = nil, status: String? = nil, message: String? = nil) {
        self.service = service
        self.status = status
        self.message = message
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
