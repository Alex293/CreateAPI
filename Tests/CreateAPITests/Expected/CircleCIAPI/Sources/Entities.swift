// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

public struct Artifact: Codable {
    public var nodeIndex: Int?
    public var path: String?
    public var prettyPath: String?
    public var url: String?

    public init(nodeIndex: Int? = nil, path: String? = nil, prettyPath: String? = nil, url: String? = nil) {
        self.nodeIndex = nodeIndex
        self.path = path
        self.prettyPath = prettyPath
        self.url = url
    }

    private enum CodingKeys: String, CodingKey {
        case nodeIndex = "node_index"
        case path
        case prettyPath = "pretty_path"
        case url
    }
}

public struct Aws: Codable {
    public var keypair: String?

    public init(keypair: String? = nil) {
        self.keypair = keypair
    }
}

public struct Build: Codable {
    /// Commit message body
    public var body: String?
    public var branch: String?
    public var buildTimeMillis: Int?
    public var buildURL: URL?
    public var committerEmail: String?
    public var committerName: String?
    /// Reason why we didn't build, if we didn't build
    public var dontBuild: String?
    public var lifecycle: Lifecycle?
    /// Previous build
    public var previous: PreviousBuild?
    /// Time build was queued
    public var queuedAt: Date?
    public var reponame: String?
    /// Build_num of the build this is a retry of
    public var retryOf: Int?
    /// Time build started
    public var startTime: Date?
    /// Time build finished
    public var stopTime: Date?
    public var subject: String?
    public var username: String?
    public var vcsURL: URL?
    /// Short string explaining the reason we built
    public var why: String?

    public init(body: String? = nil, branch: String? = nil, buildTimeMillis: Int? = nil, buildURL: URL? = nil, committerEmail: String? = nil, committerName: String? = nil, dontBuild: String? = nil, lifecycle: Lifecycle? = nil, previous: PreviousBuild? = nil, queuedAt: Date? = nil, reponame: String? = nil, retryOf: Int? = nil, startTime: Date? = nil, stopTime: Date? = nil, subject: String? = nil, username: String? = nil, vcsURL: URL? = nil, why: String? = nil) {
        self.body = body
        self.branch = branch
        self.buildTimeMillis = buildTimeMillis
        self.buildURL = buildURL
        self.committerEmail = committerEmail
        self.committerName = committerName
        self.dontBuild = dontBuild
        self.lifecycle = lifecycle
        self.previous = previous
        self.queuedAt = queuedAt
        self.reponame = reponame
        self.retryOf = retryOf
        self.startTime = startTime
        self.stopTime = stopTime
        self.subject = subject
        self.username = username
        self.vcsURL = vcsURL
        self.why = why
    }

    private enum CodingKeys: String, CodingKey {
        case body
        case branch
        case buildTimeMillis = "build_time_millis"
        case buildURL = "build_url"
        case committerEmail = "committer_email"
        case committerName = "committer_name"
        case dontBuild = "dont_build"
        case lifecycle
        case previous
        case queuedAt = "queued_at"
        case reponame
        case retryOf = "retry_of"
        case startTime = "start_time"
        case stopTime = "stop_time"
        case subject
        case username
        case vcsURL = "vcs_url"
        case why
    }
}

/// Previous build
public struct BuildDetail: Codable {
    public var allCommitDetails: [CommitDetail]?
    public var compare: URL?
    public var jobName: String?
    public var node: AnyJSON?
    /// Previous build
    public var previousSuccessfulBuild: PreviousBuild?
    public var isRetries: Bool?
    public var isSshEnabled: Bool?
    public var isTimedout: Bool?
    public var usageQueuedAt: Date?
    public var user: User?

    public init(allCommitDetails: [CommitDetail]? = nil, compare: URL? = nil, jobName: String? = nil, node: AnyJSON? = nil, previousSuccessfulBuild: PreviousBuild? = nil, isRetries: Bool? = nil, isSshEnabled: Bool? = nil, isTimedout: Bool? = nil, usageQueuedAt: Date? = nil, user: User? = nil) {
        self.allCommitDetails = allCommitDetails
        self.compare = compare
        self.jobName = jobName
        self.node = node
        self.previousSuccessfulBuild = previousSuccessfulBuild
        self.isRetries = isRetries
        self.isSshEnabled = isSshEnabled
        self.isTimedout = isTimedout
        self.usageQueuedAt = usageQueuedAt
        self.user = user
    }

    private enum CodingKeys: String, CodingKey {
        case allCommitDetails = "all_commit_details"
        case compare
        case jobName = "job_name"
        case node
        case previousSuccessfulBuild = "previous_successful_build"
        case isRetries = "retries"
        case isSshEnabled = "ssh_enabled"
        case isTimedout = "timedout"
        case usageQueuedAt = "usage_queued_at"
        case user
    }
}

public struct BuildSummary: Codable {
    public var addedAt: Date?
    public var buildNum: Int?
    public var outcome: Outcome?
    public var pushedAt: Date?
    public var status: Status?
    public var vcsRevision: String?

    public init(addedAt: Date? = nil, buildNum: Int? = nil, outcome: Outcome? = nil, pushedAt: Date? = nil, status: Status? = nil, vcsRevision: String? = nil) {
        self.addedAt = addedAt
        self.buildNum = buildNum
        self.outcome = outcome
        self.pushedAt = pushedAt
        self.status = status
        self.vcsRevision = vcsRevision
    }

    private enum CodingKeys: String, CodingKey {
        case addedAt = "added_at"
        case buildNum = "build_num"
        case outcome
        case pushedAt = "pushed_at"
        case status
        case vcsRevision = "vcs_revision"
    }
}

public struct CommitDetail: Codable {
    public var authorDate: Date?
    public var authorEmail: String?
    public var authorLogin: String?
    public var authorName: String?
    public var body: String?
    public var commit: String?
    public var commitURL: URL?
    public var committerDate: Date?
    public var committerEmail: String?
    public var committerLogin: String?
    public var committerName: String?
    public var subject: String?

    public init(authorDate: Date? = nil, authorEmail: String? = nil, authorLogin: String? = nil, authorName: String? = nil, body: String? = nil, commit: String? = nil, commitURL: URL? = nil, committerDate: Date? = nil, committerEmail: String? = nil, committerLogin: String? = nil, committerName: String? = nil, subject: String? = nil) {
        self.authorDate = authorDate
        self.authorEmail = authorEmail
        self.authorLogin = authorLogin
        self.authorName = authorName
        self.body = body
        self.commit = commit
        self.commitURL = commitURL
        self.committerDate = committerDate
        self.committerEmail = committerEmail
        self.committerLogin = committerLogin
        self.committerName = committerName
        self.subject = subject
    }

    private enum CodingKeys: String, CodingKey {
        case authorDate = "author_date"
        case authorEmail = "author_email"
        case authorLogin = "author_login"
        case authorName = "author_name"
        case body
        case commit
        case commitURL = "commit_url"
        case committerDate = "committer_date"
        case committerEmail = "committer_email"
        case committerLogin = "committer_login"
        case committerName = "committer_name"
        case subject
    }
}

public struct Envvar: Codable {
    public var name: String?
    public var value: String?

    public init(name: String? = nil, value: String? = nil) {
        self.name = name
        self.value = value
    }
}

public struct Key: Codable {
    public var fingerprint: String?
    public var isPreferred: Bool?
    public var publicKey: String?
    /// When the key was issued
    public var time: Date?
    /// Can be "deploy-key" or "github-user-key"
    public var type: `Type`?

    /// Can be "deploy-key" or "github-user-key"
    public enum `Type`: String, Codable, CaseIterable {
        case deployKey = "deploy-key"
        case githubUserKey = "github-user-key"
    }

    public init(fingerprint: String? = nil, isPreferred: Bool? = nil, publicKey: String? = nil, time: Date? = nil, type: `Type`? = nil) {
        self.fingerprint = fingerprint
        self.isPreferred = isPreferred
        self.publicKey = publicKey
        self.time = time
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case fingerprint
        case isPreferred = "preferred"
        case publicKey = "public_key"
        case time
        case type
    }
}

public enum Lifecycle: String, Codable, CaseIterable {
    case queued
    case scheduled
    case notRun = "not_run"
    case notRunning = "not_running"
    case running
    case finished
}

public enum Outcome: String, Codable, CaseIterable {
    case canceled
    case infrastructureFail = "infrastructure_fail"
    case timedout
    case failed
    case noTests = "no_tests"
    case success
}

/// Previous build
public struct PreviousBuild: Codable {
    public var buildNum: Int?
    public var buildTimeMillis: Int?
    public var status: Status?

    public init(buildNum: Int? = nil, buildTimeMillis: Int? = nil, status: Status? = nil) {
        self.buildNum = buildNum
        self.buildTimeMillis = buildTimeMillis
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case buildNum = "build_num"
        case buildTimeMillis = "build_time_millis"
        case status
    }
}

public struct Project: Codable {
    public var aws: Aws?
    public var branches: [String: AnyJSON]?
    public var campfireNotifyPrefs: String?
    public var campfireRoom: String?
    public var campfireSubdomain: String?
    public var campfireToken: String?
    public var compile: String?
    public var defaultBranch: String?
    public var dependencies: String?
    public var extra: String?
    public var featureFlags: FeatureFlags?
    public var flowdockAPIToken: String?
    public var isFollowed: Bool?
    public var hasUsableKey: Bool?
    public var herokuDeployUser: String?
    public var hipchatAPIToken: String?
    public var hipchatNotify: String?
    public var hipchatNotifyPrefs: String?
    public var hipchatRoom: String?
    public var ircChannel: String?
    public var ircKeyword: String?
    public var ircNotifyPrefs: String?
    public var ircPassword: String?
    public var ircServer: String?
    public var ircUsername: String?
    public var language: String?
    public var isOss: Bool?
    public var parallel: Int?
    public var reponame: String?
    public var scopes: [Scope]?
    public var setup: String?
    public var slackAPIToken: String?
    public var slackChannel: String?
    public var slackChannelOverride: String?
    public var slackNotifyPrefs: String?
    public var slackSubdomain: String?
    public var slackWebhookURL: URL?
    public var sshKeys: [String]?
    public var test: String?
    public var username: String?
    public var vcsType: String?
    public var vcsURL: URL?

    public struct FeatureFlags: Codable {
        public var isBuildForkPrs: Bool?
        public var isFleet: Bool?
        public var isJunit: Bool?
        public var isOss: Bool?
        public var isOsx: Bool?
        public var isSetGithubStatus: Bool?
        public var isTrustyBeta: Bool?

        public init(isBuildForkPrs: Bool? = nil, isFleet: Bool? = nil, isJunit: Bool? = nil, isOss: Bool? = nil, isOsx: Bool? = nil, isSetGithubStatus: Bool? = nil, isTrustyBeta: Bool? = nil) {
            self.isBuildForkPrs = isBuildForkPrs
            self.isFleet = isFleet
            self.isJunit = isJunit
            self.isOss = isOss
            self.isOsx = isOsx
            self.isSetGithubStatus = isSetGithubStatus
            self.isTrustyBeta = isTrustyBeta
        }

        private enum CodingKeys: String, CodingKey {
            case isBuildForkPrs = "build-fork-prs"
            case isFleet = "fleet"
            case isJunit = "junit"
            case isOss = "oss"
            case isOsx = "osx"
            case isSetGithubStatus = "set-github-status"
            case isTrustyBeta = "trusty-beta"
        }
    }

    public init(aws: Aws? = nil, branches: [String: AnyJSON]? = nil, campfireNotifyPrefs: String? = nil, campfireRoom: String? = nil, campfireSubdomain: String? = nil, campfireToken: String? = nil, compile: String? = nil, defaultBranch: String? = nil, dependencies: String? = nil, extra: String? = nil, featureFlags: FeatureFlags? = nil, flowdockAPIToken: String? = nil, isFollowed: Bool? = nil, hasUsableKey: Bool? = nil, herokuDeployUser: String? = nil, hipchatAPIToken: String? = nil, hipchatNotify: String? = nil, hipchatNotifyPrefs: String? = nil, hipchatRoom: String? = nil, ircChannel: String? = nil, ircKeyword: String? = nil, ircNotifyPrefs: String? = nil, ircPassword: String? = nil, ircServer: String? = nil, ircUsername: String? = nil, language: String? = nil, isOss: Bool? = nil, parallel: Int? = nil, reponame: String? = nil, scopes: [Scope]? = nil, setup: String? = nil, slackAPIToken: String? = nil, slackChannel: String? = nil, slackChannelOverride: String? = nil, slackNotifyPrefs: String? = nil, slackSubdomain: String? = nil, slackWebhookURL: URL? = nil, sshKeys: [String]? = nil, test: String? = nil, username: String? = nil, vcsType: String? = nil, vcsURL: URL? = nil) {
        self.aws = aws
        self.branches = branches
        self.campfireNotifyPrefs = campfireNotifyPrefs
        self.campfireRoom = campfireRoom
        self.campfireSubdomain = campfireSubdomain
        self.campfireToken = campfireToken
        self.compile = compile
        self.defaultBranch = defaultBranch
        self.dependencies = dependencies
        self.extra = extra
        self.featureFlags = featureFlags
        self.flowdockAPIToken = flowdockAPIToken
        self.isFollowed = isFollowed
        self.hasUsableKey = hasUsableKey
        self.herokuDeployUser = herokuDeployUser
        self.hipchatAPIToken = hipchatAPIToken
        self.hipchatNotify = hipchatNotify
        self.hipchatNotifyPrefs = hipchatNotifyPrefs
        self.hipchatRoom = hipchatRoom
        self.ircChannel = ircChannel
        self.ircKeyword = ircKeyword
        self.ircNotifyPrefs = ircNotifyPrefs
        self.ircPassword = ircPassword
        self.ircServer = ircServer
        self.ircUsername = ircUsername
        self.language = language
        self.isOss = isOss
        self.parallel = parallel
        self.reponame = reponame
        self.scopes = scopes
        self.setup = setup
        self.slackAPIToken = slackAPIToken
        self.slackChannel = slackChannel
        self.slackChannelOverride = slackChannelOverride
        self.slackNotifyPrefs = slackNotifyPrefs
        self.slackSubdomain = slackSubdomain
        self.slackWebhookURL = slackWebhookURL
        self.sshKeys = sshKeys
        self.test = test
        self.username = username
        self.vcsType = vcsType
        self.vcsURL = vcsURL
    }

    private enum CodingKeys: String, CodingKey {
        case aws
        case branches
        case campfireNotifyPrefs = "campfire_notify_prefs"
        case campfireRoom = "campfire_room"
        case campfireSubdomain = "campfire_subdomain"
        case campfireToken = "campfire_token"
        case compile
        case defaultBranch = "default_branch"
        case dependencies
        case extra
        case featureFlags = "feature_flags"
        case flowdockAPIToken = "flowdock_api_token"
        case isFollowed = "followed"
        case hasUsableKey = "has_usable_key"
        case herokuDeployUser = "heroku_deploy_user"
        case hipchatAPIToken = "hipchat_api_token"
        case hipchatNotify = "hipchat_notify"
        case hipchatNotifyPrefs = "hipchat_notify_prefs"
        case hipchatRoom = "hipchat_room"
        case ircChannel = "irc_channel"
        case ircKeyword = "irc_keyword"
        case ircNotifyPrefs = "irc_notify_prefs"
        case ircPassword = "irc_password"
        case ircServer = "irc_server"
        case ircUsername = "irc_username"
        case language
        case isOss = "oss"
        case parallel
        case reponame
        case scopes
        case setup
        case slackAPIToken = "slack_api_token"
        case slackChannel = "slack_channel"
        case slackChannelOverride = "slack_channel_override"
        case slackNotifyPrefs = "slack_notify_prefs"
        case slackSubdomain = "slack_subdomain"
        case slackWebhookURL = "slack_webhook_url"
        case sshKeys = "ssh_keys"
        case test
        case username
        case vcsType = "vcs_type"
        case vcsURL = "vcs_url"
    }
}

public enum Scope: String, Codable, CaseIterable {
    case writeSettings = "write-settings"
    case viewBuilds = "view-builds"
    case readSettings = "read-settings"
    case triggerBuilds = "trigger-builds"
    case all
    case status
    case `none`
}

public enum Status: String, Codable, CaseIterable {
    case retried
    case canceled
    case infrastructureFail = "infrastructure_fail"
    case timedout
    case notRun = "not_run"
    case running
    case failed
    case queued
    case scheduled
    case notRunning = "not_running"
    case noTests = "no_tests"
    case fixed
    case success
}

public struct Tests: Codable {
    public var tests: [Test]?

    public struct Test: Codable {
        public var classname: String?
        public var file: String?
        public var message: String?
        public var name: String?
        public var result: Status?
        public var runTime: Double?
        public var source: String?

        public init(classname: String? = nil, file: String? = nil, message: String? = nil, name: String? = nil, result: Status? = nil, runTime: Double? = nil, source: String? = nil) {
            self.classname = classname
            self.file = file
            self.message = message
            self.name = name
            self.result = result
            self.runTime = runTime
            self.source = source
        }

        private enum CodingKeys: String, CodingKey {
            case classname
            case file
            case message
            case name
            case result
            case runTime = "run_time"
            case source
        }
    }

    public init(tests: [Test]? = nil) {
        self.tests = tests
    }
}

public struct User: Codable {
    public var isAdmin: Bool?
    public var allEmails: [String]?
    public var analyticsID: String?
    public var avatarURL: URL?
    public var basicEmailPrefs: String?
    public var bitbucket: Int?
    public var isBitbucketAuthorized: Bool?
    public var containers: Int?
    public var createdAt: Date?
    public var daysLeftInTrial: Int?
    public var isDevAdmin: Bool?
    public var enrolledBetas: [String]?
    public var githubID: Int?
    public var githubOauthScopes: [String]?
    public var gravatarID: Int?
    public var herokuAPIKey: String?
    public var isInBetaProgram: Bool?
    public var login: String?
    public var name: String?
    public var organizationPrefs: [String: AnyJSON]?
    public var parallelism: Int?
    public var plan: String?
    public var projects: [String: AnyJSON]?
    public var pusherID: String?
    public var selectedEmail: String?
    public var signInCount: Int?
    public var trialEnd: Date?

    public init(isAdmin: Bool? = nil, allEmails: [String]? = nil, analyticsID: String? = nil, avatarURL: URL? = nil, basicEmailPrefs: String? = nil, bitbucket: Int? = nil, isBitbucketAuthorized: Bool? = nil, containers: Int? = nil, createdAt: Date? = nil, daysLeftInTrial: Int? = nil, isDevAdmin: Bool? = nil, enrolledBetas: [String]? = nil, githubID: Int? = nil, githubOauthScopes: [String]? = nil, gravatarID: Int? = nil, herokuAPIKey: String? = nil, isInBetaProgram: Bool? = nil, login: String? = nil, name: String? = nil, organizationPrefs: [String: AnyJSON]? = nil, parallelism: Int? = nil, plan: String? = nil, projects: [String: AnyJSON]? = nil, pusherID: String? = nil, selectedEmail: String? = nil, signInCount: Int? = nil, trialEnd: Date? = nil) {
        self.isAdmin = isAdmin
        self.allEmails = allEmails
        self.analyticsID = analyticsID
        self.avatarURL = avatarURL
        self.basicEmailPrefs = basicEmailPrefs
        self.bitbucket = bitbucket
        self.isBitbucketAuthorized = isBitbucketAuthorized
        self.containers = containers
        self.createdAt = createdAt
        self.daysLeftInTrial = daysLeftInTrial
        self.isDevAdmin = isDevAdmin
        self.enrolledBetas = enrolledBetas
        self.githubID = githubID
        self.githubOauthScopes = githubOauthScopes
        self.gravatarID = gravatarID
        self.herokuAPIKey = herokuAPIKey
        self.isInBetaProgram = isInBetaProgram
        self.login = login
        self.name = name
        self.organizationPrefs = organizationPrefs
        self.parallelism = parallelism
        self.plan = plan
        self.projects = projects
        self.pusherID = pusherID
        self.selectedEmail = selectedEmail
        self.signInCount = signInCount
        self.trialEnd = trialEnd
    }

    private enum CodingKeys: String, CodingKey {
        case isAdmin = "admin"
        case allEmails = "all_emails"
        case analyticsID = "analytics_id"
        case avatarURL = "avatar_url"
        case basicEmailPrefs = "basic_email_prefs"
        case bitbucket
        case isBitbucketAuthorized = "bitbucket_authorized"
        case containers
        case createdAt = "created_at"
        case daysLeftInTrial = "days_left_in_trial"
        case isDevAdmin = "dev_admin"
        case enrolledBetas = "enrolled_betas"
        case githubID = "github_id"
        case githubOauthScopes = "github_oauth_scopes"
        case gravatarID = "gravatar_id"
        case herokuAPIKey = "heroku_api_key"
        case isInBetaProgram = "in_beta_program"
        case login
        case name
        case organizationPrefs = "organization_prefs"
        case parallelism
        case plan
        case projects
        case pusherID = "pusher_id"
        case selectedEmail = "selected_email"
        case signInCount = "sign_in_count"
        case trialEnd = "trial_end"
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
