// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import NaiveDate
import Get

extension Paths {
    public static var candidates: Candidates {
        Candidates(path: "/candidates")
    }

    public struct Candidates {
        /// Path: `/candidates`
        public let path: String

        /// Get candidates
        ///
        /// Get candidates based on specified filters.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetResponse: Decodable {
            public var recordsTotal: Int?
            /// The total number of filtered records returned
            public var recordsFiltered: AnyJSON?
            public var candidates: [CrucibleAPI.GetCandidatesObject]?

            public init(recordsTotal: Int? = nil, recordsFiltered: AnyJSON? = nil, candidates: [CrucibleAPI.GetCandidatesObject]? = nil) {
                self.recordsTotal = recordsTotal
                self.recordsFiltered = recordsFiltered
                self.candidates = candidates
            }
        }

        public struct GetParameters {
            public var query: String?
            public var limit: Int?
            public var sortField: String?
            public var sortDir: String?

            public init(query: String? = nil, limit: Int? = nil, sortField: String? = nil, sortDir: String? = nil) {
                self.query = query
                self.limit = limit
                self.sortField = sortField
                self.sortDir = sortDir
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("query", self.query)
                query.addQueryItem("limit", limit)
                query.addQueryItem("sort_field", sortField)
                query.addQueryItem("sort_dir", sortDir)
                return query
            }
        }

        /// Create candidate
        ///
        /// Create a new candidate. Must have 'Candidates Create` permission to access. Any additional data provided that are not in the fields specified in the body will be held in our custom_data field
        public func post(_ body: Data? = nil) -> Request<CrucibleAPI.CandidateObject> {
            .post(path, body: body)
        }
    }
}

extension Paths.Candidates {
    public func clientID(_ clientID: String) -> WithClientID {
        WithClientID(path: "\(path)/client_id=\(clientID)")
    }

    public struct WithClientID {
        /// Path: `/candidates/client_id={client_id}`
        public let path: String

        /// Get candidate
        ///
        /// Retrieve a specific candidate. Must have 'Candidates View` permission to access
        public var get: Request<CrucibleAPI.CandidateObject> {
            .get(path)
        }

        /// Update candidate
        ///
        /// Update a candidate's information. Must have 'Candidates Edit` permission to access
        public func put(_ body: PutRequest? = nil) -> Request<CrucibleAPI.CandidateUpdateObject> {
            .put(path, body: body)
        }

        public struct PutRequest: Encodable {
            /// The candidate number for the candidate
            public var number: String?
            /// The client-supplied ID for the candidate. Must be unique
            public var clientID: String?
            /// A single tag or list of tags to be associated with the candidate. Updating a candidate with tags replaces all current tag data associated with the candidate
            public var tags: [String]?
            /// An arbitrary number of additional data fields that can be stored to the candidate. Any preexisting data will remain intact. Any new data mapping to preexisting data keys will be updated with new values. All new data will be added.
            public var customData: [String: AnyJSON]?

            public init(number: String? = nil, clientID: String? = nil, tags: [String]? = nil, customData: [String: AnyJSON]? = nil) {
                self.number = number
                self.clientID = clientID
                self.tags = tags
                self.customData = customData
            }

            private enum CodingKeys: String, CodingKey {
                case number
                case clientID = "client_id"
                case tags
                case customData = "custom_data"
            }
        }

        /// Delete candidate
        ///
        /// Delete a candidate record. Must have 'Candidates Delete` permission to access
        public var delete: Request<AnyJSON> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var admin: Admin {
        Admin(path: "/admin")
    }

    public struct Admin {
        /// Path: `/admin`
        public let path: String
    }
}

extension Paths.Admin {
    public var evidence: Evidence {
        Evidence(path: path + "/evidence")
    }

    public struct Evidence {
        /// Path: `/admin/evidence`
        public let path: String

        /// Upload multiple documents as digital evidence
        ///
        /// Upload multiple documents representing digital evidence to candidate(s).
        /// 
        /// - Supported types - `.pdf, .webm, .mp4`
        /// 
        /// - Must have `Evidence: Create` permission to access
        public func post(_ body: Data) -> Request<CrucibleAPI.EvidenceArrayObject> {
            .post(path, body: body)
        }
    }
}

extension Paths.Candidates.WithClientID {
    public var evidence: Evidence {
        Evidence(path: path + "/evidence")
    }

    public struct Evidence {
        /// Path: `/candidates/client_id={client_id}/evidence`
        public let path: String

        /// Upload a document as digital evidence
        ///
        /// Upload a document representing digital evidence to a specific candidate-item pairing
        /// - Supported types - `.pdf, .webm, .mp4`
        /// 
        /// - Must have `Evidence: Create` permission to access
        public func post(_ body: Data) -> Request<CrucibleAPI.EvidenceObject> {
            .post(path, body: body)
        }
    }
}

extension Paths {
    public static var evaluations: Evaluations {
        Evaluations(path: "/evaluations")
    }

    public struct Evaluations {
        /// Path: `/evaluations`
        public let path: String

        /// Get Evaluations
        ///
        /// Get evaluations based on specified filters.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetResponse: Decodable {
            public var results: [CrucibleAPI.ResultsObject]?

            public init(results: [CrucibleAPI.ResultsObject]? = nil) {
                self.results = results
            }
        }

        public struct GetParameters {
            public var examinerTag: String?
            public var startDate: NaiveDate?
            public var endDate: NaiveDate?

            public init(examinerTag: String? = nil, startDate: NaiveDate? = nil, endDate: NaiveDate? = nil) {
                self.examinerTag = examinerTag
                self.startDate = startDate
                self.endDate = endDate
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("examiner_tag", examinerTag)
                query.addQueryItem("start_date", startDate)
                query.addQueryItem("end_date", endDate)
                return query
            }
        }
    }
}

extension Paths.Admin {
    public var examEvents: ExamEvents {
        ExamEvents(path: path + "/exam_events")
    }

    public struct ExamEvents {
        /// Path: `/admin/exam_events`
        public let path: String

        /// Create Exam Event
        ///
        /// Create an exam event. Must have 'Exam Events Create` permission to access.
        public func post(_ body: PostRequest) -> Request<CrucibleAPI.ExamEventCreateObject> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// *Required. The name of the exam event. Must be a unique, non-empty string
            public var name: String?
            /// By default, the event type is "independent_lists". If the event type is `osce`, this must be explicitly set
            public var eventType: EventType?
            /// The Crucible-generated identifier of the scoring rubric to be utilized. By default, scoring rubric is set to `None`
            public var scoringRubricID: Int?
            /// The number of stations in an OSCE event. By default, stations is set to `None`. If the event is 'OSCE', this is required minimum int of 0
            public var stations: Int?

            /// By default, the event type is "independent_lists". If the event type is `osce`, this must be explicitly set
            public enum EventType: String, Codable, CaseIterable {
                case independentLists = "independent_lists"
                case osce
            }

            public init(name: String? = nil, eventType: EventType? = nil, scoringRubricID: Int? = nil, stations: Int? = nil) {
                self.name = name
                self.eventType = eventType
                self.scoringRubricID = scoringRubricID
                self.stations = stations
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case eventType = "event_type"
                case scoringRubricID = "scoring_rubric_id"
                case stations
            }
        }
    }
}

extension Paths.Admin.ExamEvents {
    public func examID(_ examID: String) -> WithExamID {
        WithExamID(path: "\(path)/\(examID)")
    }

    public struct WithExamID {
        /// Path: `/admin/exam_events/{exam_id}`
        public let path: String

        /// Update Exam Event
        ///
        /// Update specific exam event with validated data. Must have 'Exam Events Edit` permission to access.
        public func put(_ body: PutRequest? = nil) -> Request<CrucibleAPI.ExamEventUpdatedObject> {
            .put(path, body: body)
        }

        public struct PutRequest: Encodable {
            /// The name of the exam event. If provided, must be unique, non empty
            public var name: String?
            /// How stacks are assigned to examiners. Valid types are 'external', 'auto_assign', or 'self_assign'.
            public var assignmentMethod: AssignmentMethod?
            /// Set the maximum number of examiners to grade an item
            public var maxExaminersPerItem: Int?
            /// Set the ability to hold/release examiners
            public var allowExaminerHolds: Bool?

            /// How stacks are assigned to examiners. Valid types are 'external', 'auto_assign', or 'self_assign'.
            public enum AssignmentMethod: String, Codable, CaseIterable {
                case external
                case autoAssign = "auto_assign"
                case selfAssign = "self_assign"
            }

            public init(name: String? = nil, assignmentMethod: AssignmentMethod? = nil, maxExaminersPerItem: Int? = nil, allowExaminerHolds: Bool? = nil) {
                self.name = name
                self.assignmentMethod = assignmentMethod
                self.maxExaminersPerItem = maxExaminersPerItem
                self.allowExaminerHolds = allowExaminerHolds
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case assignmentMethod = "assignment_method"
                case maxExaminersPerItem = "max_examiners_per_item"
                case allowExaminerHolds = "allow_examiner_holds"
            }
        }
    }
}

extension Paths.Admin.ExamEvents.WithExamID {
    public var formVersions: FormVersions {
        FormVersions(path: path + "/form_versions")
    }

    public struct FormVersions {
        /// Path: `/admin/exam_events/{exam_id}/form_versions`
        public let path: String

        /// Get Form Versions for Event
        ///
        /// Retrieve information about all Form Versions on an Exam Event.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var formVersions: [CrucibleAPI.FormVersionObject]?

            public init(formVersions: [CrucibleAPI.FormVersionObject]? = nil) {
                self.formVersions = formVersions
            }

            private enum CodingKeys: String, CodingKey {
                case formVersions = "form_versions"
            }
        }

        /// Add new Form Version to an event
        ///
        /// Create a new Form Version on an Exam Event.
        public func post(_ body: PostRequest? = nil) -> Request<CrucibleAPI.FormVersionObject> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// *Required. The name of the form version. Must be unique to the event and a non-empty string
            public var name: String?
            /// The client_id of the form version. Must be unique across all form versions on any event
            public var clientID: String?

            public init(name: String? = nil, clientID: String? = nil) {
                self.name = name
                self.clientID = clientID
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case clientID = "client_id"
            }
        }
    }
}

extension Paths.Admin.ExamEvents.WithExamID.FormVersions {
    public func formVersionID(_ formVersionID: String) -> WithFormVersionID {
        WithFormVersionID(path: "\(path)/\(formVersionID)")
    }

    public struct WithFormVersionID {
        /// Path: `/admin/exam_events/{exam_id}/form_versions/{form_version_id}`
        public let path: String

        /// Get a Form Version for Event
        ///
        /// Retrieve information about a specific Form Version on an Exam Event.
        public var get: Request<CrucibleAPI.SingleFormVersionObject> {
            .get(path)
        }

        /// Update a Form Version for Event
        ///
        /// Update information about a specific Form Version on an Exam Event.
        public func put(_ body: PutRequest? = nil) -> Request<CrucibleAPI.SingleFormVersionObject> {
            .put(path, body: body)
        }

        public struct PutRequest: Encodable {
            /// The name of the form version. Must be unique to the event and a non-empty string
            public var name: String?
            /// The client_id of the form version. Must be unique across all form versions on any event
            public var clientID: String?
            /// The minimum aggregate score for which candidates are exempted from the auto-close mechanism.
            /// Any candidate whose aggregated procedure score for an event falls inside the exemption range (inclusive) will not be auto-closed, and will continue to be evaluated until the appropriate number of evaluations have been completed for each procedure.
            ///     
            /// Conversely, a candidate whose aggregated procedure score is less than this value will be auto-closed once they have a first evaluation for every item they should be graded on.  They will not receive any second evaluations.
            ///     
            /// If an exemption minimum is not set, then the auto-close feature will be effectively disabled.
            public var autoCloseExemptionMinimum: Double?
            /// The maximum aggregate score for which candidates are exempted from the auto-close mechanism.
            /// Any candidate whose aggregated procedure score for an event falls inside the exemption range (inclusive) will not be auto-closed, and will continue to be evaluated until the appropriate number of evaluations have been completed for each procedure.
            ///     
            /// Conversely, a candidate whose aggregated procedure score is greater than this value will be auto-closed once they have a first evaluation for every item they should be graded on.  They will not receive any second evaluations.
            ///     
            /// If an exemption maximum is not set, then the auto-close feature will be effectively disabled.
            public var autoCloseExemptionMaximum: Double?

            public init(name: String? = nil, clientID: String? = nil, autoCloseExemptionMinimum: Double? = nil, autoCloseExemptionMaximum: Double? = nil) {
                self.name = name
                self.clientID = clientID
                self.autoCloseExemptionMinimum = autoCloseExemptionMinimum
                self.autoCloseExemptionMaximum = autoCloseExemptionMaximum
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case clientID = "client_id"
                case autoCloseExemptionMinimum = "auto_close_exemption_minimum"
                case autoCloseExemptionMaximum = "auto_close_exemption_maximum"
            }
        }

        /// Delete a Form Version for Event
        ///
        /// Remove a specific Form Version on an Exam Event.
        public var delete: Request<AnyJSON> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var stacks: Stacks {
        Stacks(path: "/stacks")
    }

    public struct Stacks {
        /// Path: `/stacks`
        public let path: String
    }
}

extension Paths.Stacks {
    public func clientID(_ clientID: String) -> WithClientID {
        WithClientID(path: "\(path)/client_id=\(clientID)")
    }

    public struct WithClientID {
        /// Path: `/stacks/client_id={client_id}`
        public let path: String

        /// Get Stack
        ///
        /// Retrieve information about a stack.
        public var get: Request<CrucibleAPI.StackInfoObject> {
            .get(path)
        }

        /// Delete stack
        ///
        /// Delete a stack record. Must have 'Stacks Delete` permission to access
        public var delete: Request<[String: AnyJSON]> {
            .delete(path)
        }
    }
}

extension Paths.Stacks.WithClientID {
    public var teams: Teams {
        Teams(path: path + "/teams")
    }

    public struct Teams {
        /// Path: `/stacks/client_id={client_id}/teams`
        public let path: String

        /// Assign Stack
        ///
        /// Assign a stack.
        public func post(_ body: PostRequest? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            public var data: [CrucibleAPI.AssignmentObject]?

            public init(data: [CrucibleAPI.AssignmentObject]? = nil) {
                self.data = data
            }
        }

        public struct PostRequest: Encodable {
            /// The Crucible-generated identifier for the team containing the examiner(s).
            public var teamID: String
            /// The Crucible-generated identifier for the examiner(s). If omitted, the stack will be assigned to all examiners on the team who haven't already been assigned.
            public var examinerIDs: [Int]?
            /// The client-supplied identifier for the stack assignment. Can only be used if making an assignment for a single examiner.
            public var clientID: String?
            /// If true, the system will shuffle the order of the stack, rather than relying on the default position of candidates in the stack.
            public var isRandomizeCandidateOrder: Bool?
            /// If true, then once an examiner has confirmed an evaluation, they will not be able to go back and change any marks they've made. They will only be able to view them.
            public var lockMarks: Bool?
            /// If true, an error will be thrown if another examiner, on any team, already has an open assignment for this stack.
            public var isFailOnOpenAssignments: Bool?

            public init(teamID: String, examinerIDs: [Int]? = nil, clientID: String? = nil, isRandomizeCandidateOrder: Bool? = nil, lockMarks: Bool? = nil, isFailOnOpenAssignments: Bool? = nil) {
                self.teamID = teamID
                self.examinerIDs = examinerIDs
                self.clientID = clientID
                self.isRandomizeCandidateOrder = isRandomizeCandidateOrder
                self.lockMarks = lockMarks
                self.isFailOnOpenAssignments = isFailOnOpenAssignments
            }

            private enum CodingKeys: String, CodingKey {
                case teamID = "team_id"
                case examinerIDs = "examiner_ids"
                case clientID = "client_id"
                case isRandomizeCandidateOrder = "randomize_candidate_order"
                case lockMarks = "lock_marks"
                case isFailOnOpenAssignments = "fail_on_open_assignments"
            }
        }
    }
}

extension Paths.Admin.ExamEvents.WithExamID {
    public var stacks: Stacks {
        Stacks(path: path + "/stacks")
    }

    public struct Stacks {
        /// Path: `/admin/exam_events/{exam_id}/stacks`
        public let path: String

        /// Create Stack
        ///
        /// Create a stack.
        public func post(_ body: PostRequest? = nil) -> Request<CrucibleAPI.StackInfoObject> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The type of import. Valid types are single or multiple. If single, all candidiates listed are put onto a single stack. For multiple, all candidates listed are put on their own individual stack.
            public var importType: ImportType
            /// The indicator if the stack is a calibration stack.
            public var isCalibration: Bool?
            /// The client-supplied identifier for the stack.
            public var clientID: String?
            /// The name of the stack.
            public var name: String?
            /// The Crucible-generated identifier for a Form Version with which the stack should be associated
            public var formVersionID: Int?
            /// A list of candidates. A comma separated pair of the candidate's client_id and number. Each separated by "\n". IE "123,456\n789,012"
            public var data: String

            /// The type of import. Valid types are single or multiple. If single, all candidiates listed are put onto a single stack. For multiple, all candidates listed are put on their own individual stack.
            public enum ImportType: String, Codable, CaseIterable {
                case single
                case multiple
            }

            public init(importType: ImportType, isCalibration: Bool? = nil, clientID: String? = nil, name: String? = nil, formVersionID: Int? = nil, data: String) {
                self.importType = importType
                self.isCalibration = isCalibration
                self.clientID = clientID
                self.name = name
                self.formVersionID = formVersionID
                self.data = data
            }

            private enum CodingKeys: String, CodingKey {
                case importType = "import_type"
                case isCalibration = "calibration"
                case clientID = "client_id"
                case name
                case formVersionID = "form_version_id"
                case data
            }
        }
    }
}

extension Paths {
    public static var stackAssignments: StackAssignments {
        StackAssignments(path: "/stack_assignments")
    }

    public struct StackAssignments {
        /// Path: `/stack_assignments`
        public let path: String
    }
}

extension Paths.StackAssignments {
    public func clientID(_ clientID: String) -> WithClientID {
        WithClientID(path: "\(path)/client_id=\(clientID)")
    }

    public struct WithClientID {
        /// Path: `/stack_assignments/client_id={client_id}`
        public let path: String

        /// Get Stack Assignment
        ///
        /// Retrieve information about a stack assignment.
        public var get: Request<CrucibleAPI.StackAssignmentObject> {
            .get(path)
        }

        /// Delete Stack Assignment
        ///
        /// Delete a single user's stack assignment. If the assignment is in progress, this will also remove associated evaluations and marks.
        public var delete: Request<AnyJSON> {
            .delete(path)
        }
    }
}

extension Paths.Admin.ExamEvents.WithExamID {
    public var teams: Teams {
        Teams(path: path + "/teams")
    }

    public struct Teams {
        /// Path: `/admin/exam_events/{exam_id}/teams`
        public let path: String

        /// Add Team to Exam Event
        ///
        /// Add a team to an exam event. Must have 'Teams Create` permission to access
        public func post(_ body: PostRequest) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            /// Team Object
            ///
            /// Information of the team added to an exam event
            public var data: CrucibleAPI.TeamObject?

            public init(data: CrucibleAPI.TeamObject? = nil) {
                self.data = data
            }
        }

        public struct PostRequest: Encodable {
            /// *Required. The client-supplied identifer for the team. Must be a unique, non-empty string
            public var clientID: String?
            /// *Required. The name of the team. Must be unique
            public var name: String?

            public init(clientID: String? = nil, name: String? = nil) {
                self.clientID = clientID
                self.name = name
            }

            private enum CodingKeys: String, CodingKey {
                case clientID = "client_id"
                case name
            }
        }
    }
}

extension Paths.Admin.ExamEvents.WithExamID.Teams {
    public func teamClientID(_ teamClientID: String) -> WithClientID {
        WithClientID(path: "\(path)/client_id=\(teamClientID)")
    }

    public struct WithClientID {
        /// Path: `/admin/exam_events/{exam_id}/teams/client_id={team_client_id}`
        public let path: String

        /// Remove a Team
        ///
        /// Remove a team from an exam event. Must have 'Teams Delete` permission to access. If the event has 'Running' status, teams cannot be deleted
        public var delete: Request<AnyJSON> {
            .delete(path)
        }
    }
}

extension Paths.Admin.ExamEvents.WithExamID.Teams.WithClientID {
    public var examiners: Examiners {
        Examiners(path: path + "/examiners")
    }

    public struct Examiners {
        /// Path: `/admin/exam_events/{exam_id}/teams/client_id={team_client_id}/examiners`
        public let path: String

        /// Get Examiners on Team
        ///
        /// Get a list of examiners on a team. Must have 'Teams View` permission to access
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// The number of examiners
            public var total: Int?
            /// An array of examiners
            public var examiners: [CrucibleAPI.TeamExaminersObject]?

            public init(total: Int? = nil, examiners: [CrucibleAPI.TeamExaminersObject]? = nil) {
                self.total = total
                self.examiners = examiners
            }
        }

        /// Assign Examiner to Team
        ///
        /// Assign an examiner to a team. Must have 'Teams Edit` permission to access
        public func post(examinerID: Int) -> Request<PostResponse> {
            .post(path, body: ["examiner_id": examinerID])
        }

        public struct PostResponse: Decodable {
            /// User Object
            ///
            /// The information about a users when assigned to a team.
            public var data: CrucibleAPI.UserTeamObject?

            public init(data: CrucibleAPI.UserTeamObject? = nil) {
                self.data = data
            }
        }
    }
}

extension Paths.Admin.ExamEvents.WithExamID.Teams.WithClientID.Examiners {
    public func examinerID(_ examinerID: String) -> WithExaminerID {
        WithExaminerID(path: "\(path)/\(examinerID)")
    }

    public struct WithExaminerID {
        /// Path: `/admin/exam_events/{exam_id}/teams/client_id={team_client_id}/examiners/{examiner_id}`
        public let path: String

        /// Remove Examiner from Team
        ///
        /// Remove an examiner from a team. Must have 'Teams Edit` permission to access
        public var delete: Request<AnyJSON> {
            .delete(path)
        }
    }
}

extension Paths.Admin.ExamEvents.WithExamID.Teams.WithClientID {
    public var items: Items {
        Items(path: path + "/items")
    }

    public struct Items {
        /// Path: `/admin/exam_events/{exam_id}/teams/client_id={team_client_id}/items`
        public let path: String

        /// Get Items on Team
        ///
        /// Get a list of items on a team. Must have 'Teams View` and 'Exam Events View' permissions to access
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var items: [CrucibleAPI.ItemsObject]?
            /// The total number of items returned
            public var total: Int?

            public init(items: [CrucibleAPI.ItemsObject]? = nil, total: Int? = nil) {
                self.items = items
                self.total = total
            }
        }

        /// Assign Item to Team
        ///
        /// Assign an item to a team. Must have 'Teams Edit` and 'Exam Events Edit' permissions to access
        public func post(itemID: String) -> Request<PostResponse> {
            .post(path, body: ["item_id": itemID])
        }

        public struct PostResponse: Decodable {
            /// Items Object
            ///
            /// Information of the item added to a team on an exam event
            public var data: CrucibleAPI.ItemsObject?

            public init(data: CrucibleAPI.ItemsObject? = nil) {
                self.data = data
            }
        }
    }
}

extension Paths.Admin.ExamEvents.WithExamID.Teams.WithClientID.Items {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/admin/exam_events/{exam_id}/teams/client_id={team_client_id}/items/{item_id}`
        public let path: String

        /// Remove Item from Team
        ///
        /// Remove an item from a team. Must have 'Teams Edit` and 'Exam Events Edit' permissions to access. If an exam event has status 'Running', the item cannot be deleted
        public var delete: Request<AnyJSON> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var users: Users {
        Users(path: "/users")
    }

    public struct Users {
        /// Path: `/users`
        public let path: String

        /// Create a User
        ///
        /// Creates a new user.
        public func post(_ body: PostRequest? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            /// User Object
            ///
            /// The information returned when a user is of user type Examiner or RolePlayer.
            public var data: CrucibleAPI.UserExaminerObject?

            public init(data: CrucibleAPI.UserExaminerObject? = nil) {
                self.data = data
            }
        }

        public struct PostRequest: Encodable {
            /// The role of user. Valid types are Administrator, Examiner, RolePlayer. More than one role can be added at the same time.
            public var roles: [String]?
            /// The user name of the user. This is what is used on the login screen. All usernames must be unique.
            public var userName: String
            /// The password for the user. The password must adhere to the currently configured password requirements.
            public var password: String
            /// Verification of the password. Must be identical to the value in the password field.
            public var password2: String
            /// The first name of the user.
            public var firstName: String?
            /// The last name of the user.
            public var lastName: String?
            /// The client-supplied identifier for the user.
            public var clientID: String?
            public var type: AnyJSON

            public init(roles: [String]? = nil, userName: String, password: String, password2: String, firstName: String? = nil, lastName: String? = nil, clientID: String? = nil, type: AnyJSON) {
                self.roles = roles
                self.userName = userName
                self.password = password
                self.password2 = password2
                self.firstName = firstName
                self.lastName = lastName
                self.clientID = clientID
                self.type = type
            }

            private enum CodingKeys: String, CodingKey {
                case roles
                case userName = "user_name"
                case password
                case password2
                case firstName = "first_name"
                case lastName = "last_name"
                case clientID = "client_id"
                case type
            }
        }
    }
}

extension Paths.Users {
    public func clientID(_ clientID: String) -> WithClientID {
        WithClientID(path: "\(path)/client_id=\(clientID)")
    }

    public struct WithClientID {
        /// Path: `/users/client_id={client_id}`
        public let path: String

        /// Get User
        ///
        /// Retrieve information about the user.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// User Object
            ///
            /// The information returned when a user is of user type Examiner or RolePlayer.
            public var data: CrucibleAPI.UserExaminerObject?

            public init(data: CrucibleAPI.UserExaminerObject? = nil) {
                self.data = data
            }
        }

        /// Update User
        ///
        /// Used to update data about a user.
        public func put(_ body: PutRequest) -> Request<PutResponse> {
            .put(path, body: body)
        }

        public struct PutResponse: Decodable {
            public var data: [CrucibleAPI.UserExaminerObject]?

            public init(data: [CrucibleAPI.UserExaminerObject]? = nil) {
                self.data = data
            }
        }

        public struct PutRequest: Encodable {
            /// The first name of the user.
            public var firstName: String?
            /// The last name of the user
            public var lastName: String?
            /// The username of the user. This is what is used on the login screen. All usernames must be unique.
            public var username: String?
            /// A list of tags to be associated with the user. Any tags that were previously associated with the user will be removed, and replaced by this new list (even if empty).
            public var tags: [String]?
            /// The indicator if the examiner is a captain. Only for use with user type Examiner.
            public var isCaptain: Bool?
            /// A list of permission group ids to be associated with the user. Any permission groups that were previously associated with the user will be removed, and replaced by this new list (even if empty).
            public var groups: [String]?
            /// The role of user. Valid types are Administrator, Examiner, RolePlayer. Must list all existing or new roles. This will replace any existing roles.
            public var roles: [String]?

            public init(firstName: String? = nil, lastName: String? = nil, username: String? = nil, tags: [String]? = nil, isCaptain: Bool? = nil, groups: [String]? = nil, roles: [String]? = nil) {
                self.firstName = firstName
                self.lastName = lastName
                self.username = username
                self.tags = tags
                self.isCaptain = isCaptain
                self.groups = groups
                self.roles = roles
            }

            private enum CodingKeys: String, CodingKey {
                case firstName = "first_name"
                case lastName = "last_name"
                case username
                case tags
                case isCaptain = "is_captain"
                case groups
                case roles
            }
        }
    }
}

extension Paths.Users.WithClientID {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/users/client_id={client_id}/status`
        public let path: String

        /// Get User Status
        ///
        /// Gets the status of a user. If user is not an examiner, an empty object will be returned. If the examiner has an open stack assignment on a running exam event, then information about the event and the stack assignment is returned. If the user does not have an open stack assignment on a running exam event, then none of the information will be included in the response.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var currentEvent: [CrucibleAPI.UserStatusObject]?
            /// The client-supplied identifier for the user.
            public var clientID: String?
            /// The Crucible-generated identifier for the user.
            public var id: String?

            public init(currentEvent: [CrucibleAPI.UserStatusObject]? = nil, clientID: String? = nil, id: String? = nil) {
                self.currentEvent = currentEvent
                self.clientID = clientID
                self.id = id
            }

            private enum CodingKeys: String, CodingKey {
                case currentEvent = "current_event"
                case clientID = "client_id"
                case id
            }
        }
    }
}

extension Paths {
    public static var groups: Groups {
        Groups(path: "/groups")
    }

    public struct Groups {
        /// Path: `/groups`
        public let path: String
    }
}

extension Paths.Groups {
    public var search: Search {
        Search(path: path + "/search")
    }

    public struct Search {
        /// Path: `/groups/search`
        public let path: String

        /// Permission Group Search
        ///
        /// Returns a list of all of the permission groups in the system.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Permission Search Object
            ///
            /// Information about each permission group.
            public var groups: CrucibleAPI.PermissionSearchObject?

            public init(groups: CrucibleAPI.PermissionSearchObject? = nil) {
                self.groups = groups
            }
        }
    }
}

extension Paths {
    public static var ping: Ping {
        Ping(path: "/ping")
    }

    public struct Ping {
        /// Path: `/ping`
        public let path: String

        /// Ping
        ///
        /// Validate that the host is running and available for API usage. Authorization is not needed.
        public var get: Request<AnyJSON> {
            .get(path)
        }
    }
}

public enum Paths {}

protocol QueryEncodable {
    var asQueryValue: String { get }
}

extension Bool: QueryEncodable {
    var asQueryValue: String {
        self ? "true" : "false"
    }
}

extension Date: QueryEncodable {
    var asQueryValue: String {
        ISO8601DateFormatter().string(from: self)
    }
}

extension Double: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int32: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int64: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension NaiveDate: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension String: QueryEncodable {
    var asQueryValue: String {
        self
    }
}

extension URL: QueryEncodable {
    var asQueryValue: String {
        absoluteString
    }
}

extension RawRepresentable where RawValue == String {
    var asQueryValue: String {
        rawValue
    }
}

extension Array where Element == (String, String?) {
    mutating func addQueryItem<T: RawRepresentable>(_ name: String, _ value: T?) where T.RawValue == String {
        addQueryItem(name, value?.rawValue)
    }
    
    mutating func addQueryItem(_ name: String, _ value: QueryEncodable?) {
        guard let value = value?.asQueryValue, !value.isEmpty else { return }
        append((name, value))
    }
    
    mutating func addDeepObject(_ name: String, _ query: [(String, String?)]) {
        for (key, value) in query {
            addQueryItem("\(name)[\(key)]", value)
        }
    }

    var asPercentEncodedQuery: String {
        var components = URLComponents()
        components.queryItems = self.map(URLQueryItem.init)
        return components.percentEncodedQuery ?? ""
    }
    
    // [("role", "admin"), ("name": "kean)] -> "role,admin,name,kean"
    var asCompactQuery: String {
        flatMap { [$0, $1] }.compactMap { $0 }.joined(separator: ",")
    }
}
