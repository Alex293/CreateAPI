// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import NaiveDate

public struct AccessToken: Codable {
    /// The token value used for authenticated requests.
    public var value: String
    /// True if this token can be refreshed, false if not.
    public var isRefreshable: Bool
    /// The timestamp this token expires.
    public var expirationDate: Date
    /// The type of the token.
    public var type: `Type`
    /// When a `UserAccount` token is issued during a single-sign-on flow
    /// a user may have been automatically registered if they didn't
    /// have an account already. If this occurs then `accountCreated`
    /// will be `true`.
    public var isAccountCreated: Bool?

    /// The type of the token.
    public enum `Type`: String, Codable, CaseIterable {
        case userAccount = "UserAccount"
        case userProfile = "UserProfile"
    }

    public init(value: String, isRefreshable: Bool, expirationDate: Date, type: `Type`, isAccountCreated: Bool? = nil) {
        self.value = value
        self.isRefreshable = isRefreshable
        self.expirationDate = expirationDate
        self.type = type
        self.isAccountCreated = isAccountCreated
    }

    private enum CodingKeys: String, CodingKey {
        case value
        case isRefreshable = "refreshable"
        case expirationDate
        case type
        case isAccountCreated = "accountCreated"
    }
}

public struct Account: Codable {
    /// The id of the account.
    public var id: String
    public var address: Address?
    /// Whether the email address has been verified.
    /// 
    /// Users who receive an emailed verification url click the link to verify their email address.
    public var isEmailVerified: Bool?
    /// The first name of the account holder.
    public var firstName: String?
    /// The last name of the account holder.
    public var lastName: String?
    /// Whether usage tracking is associated with the account or anonymous.
    public var isTrackingEnabled: Bool
    /// When an account level pin is defined this will be true.
    public var isPinEnabled: Bool
    /// Whether the account has opted in or out of marketing material.
    public var isMarketingEnabled: Bool
    /// The id of the primary profile.
    public var primaryProfileID: String
    /// Whether the account has used up their free trial period of a plan.
    public var isUsedFreeTrial: Bool?
    /// The classification rating defining the minimum rating level a user should be
    /// forced to enter the account pin code for playback. Anything at this rating
    /// level or above will require the pin for playback.
    /// 
    /// e.g. AUOFLC-MA15+
    /// 
    /// If you want to disable this guard pass an empty string or `null`.
    public var minRatingPlaybackGuard: String?
    /// The id of the payment method to use by default for account transactions.
    public var defaultPaymentMethodID: String?
    /// The id of the payment instrument to use by default for account transactions.
    /// 
    ///  **DEPRECATED** The property `defaultPaymentMethodId` is now preferred.
    public var defaultPaymentInstrumentID: String?
    /// The list of subscriptions, if any, the account has signed up to.
    public var subscriptions: [Subscription]?
    /// The active subscription code for an account.
    /// 
    /// The value of this should be passed to any endpoints accepting a `sub` query parameter.
    public var subscriptionCode: String
    /// The list of profiles under this account.
    public var profiles: [ProfileSummary]
    /// The list of entitlements to playback specific items.
    public var entitlements: [Entitlement]?
    /// The segments an account has been placed under
    public var segments: [String]?
    /// Whether the account has the very first subscription.
    public var isFirstTimeSubscriber: Bool?

    public init(id: String, address: Address? = nil, isEmailVerified: Bool? = nil, firstName: String? = nil, lastName: String? = nil, isTrackingEnabled: Bool, isPinEnabled: Bool, isMarketingEnabled: Bool, primaryProfileID: String, isUsedFreeTrial: Bool? = nil, minRatingPlaybackGuard: String? = nil, defaultPaymentMethodID: String? = nil, defaultPaymentInstrumentID: String? = nil, subscriptions: [Subscription]? = nil, subscriptionCode: String, profiles: [ProfileSummary], entitlements: [Entitlement]? = nil, segments: [String]? = nil, isFirstTimeSubscriber: Bool? = nil) {
        self.id = id
        self.address = address
        self.isEmailVerified = isEmailVerified
        self.firstName = firstName
        self.lastName = lastName
        self.isTrackingEnabled = isTrackingEnabled
        self.isPinEnabled = isPinEnabled
        self.isMarketingEnabled = isMarketingEnabled
        self.primaryProfileID = primaryProfileID
        self.isUsedFreeTrial = isUsedFreeTrial
        self.minRatingPlaybackGuard = minRatingPlaybackGuard
        self.defaultPaymentMethodID = defaultPaymentMethodID
        self.defaultPaymentInstrumentID = defaultPaymentInstrumentID
        self.subscriptions = subscriptions
        self.subscriptionCode = subscriptionCode
        self.profiles = profiles
        self.entitlements = entitlements
        self.segments = segments
        self.isFirstTimeSubscriber = isFirstTimeSubscriber
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case address
        case isEmailVerified = "emailVerified"
        case firstName
        case lastName
        case isTrackingEnabled = "trackingEnabled"
        case isPinEnabled = "pinEnabled"
        case isMarketingEnabled = "marketingEnabled"
        case primaryProfileID = "primaryProfileId"
        case isUsedFreeTrial = "usedFreeTrial"
        case minRatingPlaybackGuard
        case defaultPaymentMethodID = "defaultPaymentMethodId"
        case defaultPaymentInstrumentID = "defaultPaymentInstrumentId"
        case subscriptions
        case subscriptionCode
        case profiles
        case entitlements
        case segments
        case isFirstTimeSubscriber
    }
}

public struct AccountDevices: Codable {
    /// The array of registered playack devices.
    public var devices: [Device]
    /// The maximum number of playback devices that can be registered
    /// under an account at a single time.
    /// 
    /// If there is no maximum defined this value will be `-1`.
    public var maxRegistered: Int
    public var registrationWindow: DeviceRegistrationWindow?
    public var deregistrationWindow: DeviceRegistrationWindow?

    public init(devices: [Device], maxRegistered: Int, registrationWindow: DeviceRegistrationWindow? = nil, deregistrationWindow: DeviceRegistrationWindow? = nil) {
        self.devices = devices
        self.maxRegistered = maxRegistered
        self.registrationWindow = registrationWindow
        self.deregistrationWindow = deregistrationWindow
    }
}

public struct AccountNonce: Codable {
    /// The nonce value.
    public var value: String

    public init(value: String) {
        self.value = value
    }
}

public struct AccountTokenByCodeRequest: Codable {
    /// The unique identifier for the device e.g. serial number.
    public var id: String
    /// The generated device authorization code.
    public var code: String
    /// The scope(s) of the token(s) required.
    public var scopes: [Scope]

    public enum Scope: String, Codable, CaseIterable {
        case catalog = "Catalog"
        case commerce = "Commerce"
        case settings = "Settings"
        case playback = "Playback"
    }

    public init(id: String, code: String, scopes: [Scope]) {
        self.id = id
        self.code = code
        self.scopes = scopes
    }
}

/// Example:
///
/// {
///   "email" : null,
///   "password" : null,
///   "scopes" : [
///     "Catalog"
///   ]
/// }
public struct AccountTokenRequest: Codable {
    /// The email associated with the account.
    public var email: String
    /// The password associated with the account.
    public var password: String
    /// The scope(s) of the tokens required.
    /// For each scope listed an Account and Profile token of that scope will be returned
    public var scopes: [Scope]
    /// If you specify a cookie type then a content filter cookie will be returned
    /// along with the token(s). This is only intended for web based clients which
    /// need to pass the cookies to a server to render a page based on the user's
    /// content filters e.g subscription code.
    /// 
    /// If type `Session` the cookie will be session based.
    /// If type `Persistent` the cookie will have a medium term lifespan.
    /// If undefined no cookies will be set.
    public var cookieType: CookieType?

    public enum Scope: String, Codable, CaseIterable {
        case catalog = "Catalog"
        case commerce = "Commerce"
        case settings = "Settings"
        case playback = "Playback"
    }

    /// If you specify a cookie type then a content filter cookie will be returned
    /// along with the token(s). This is only intended for web based clients which
    /// need to pass the cookies to a server to render a page based on the user's
    /// content filters e.g subscription code.
    /// 
    /// If type `Session` the cookie will be session based.
    /// If type `Persistent` the cookie will have a medium term lifespan.
    /// If undefined no cookies will be set.
    public enum CookieType: String, Codable, CaseIterable {
        case session = "Session"
        case persistent = "Persistent"
    }

    public init(email: String, password: String, scopes: [Scope], cookieType: CookieType? = nil) {
        self.email = email
        self.password = password
        self.scopes = scopes
        self.cookieType = cookieType
    }
}

public struct AccountUpdateRequest: Codable {
    public var address: Address?
    /// The first name of the account holder.
    public var firstName: String?
    /// The last name of the account holder.
    public var lastName: String?
    /// Whether usage tracking is associated with an account or anonymous.
    public var isTrackingEnabled: Bool?
    /// The id of the payment method to use by default for account transactions.
    public var defaultPaymentMethodID: String?
    /// The id of the payment instrument to use by default for account transactions.
    /// 
    /// **DEPRECATED** The property `defaultPaymentMethodId` is now preferred.
    public var defaultPaymentInstrumentID: String?
    /// The classification rating defining the minimum rating level a user should be
    /// forced to enter the account pin code for playback. Anything at this rating
    /// level or above will require the pin for playback.
    /// 
    /// e.g. AUOFLC-MA15+
    /// 
    /// If you want to disable this guard pass an empty string or `null`.
    public var minRatingPlaybackGuard: String?
    /// The segments an account should be placed under
    public var segments: [String]?

    public init(address: Address? = nil, firstName: String? = nil, lastName: String? = nil, isTrackingEnabled: Bool? = nil, defaultPaymentMethodID: String? = nil, defaultPaymentInstrumentID: String? = nil, minRatingPlaybackGuard: String? = nil, segments: [String]? = nil) {
        self.address = address
        self.firstName = firstName
        self.lastName = lastName
        self.isTrackingEnabled = isTrackingEnabled
        self.defaultPaymentMethodID = defaultPaymentMethodID
        self.defaultPaymentInstrumentID = defaultPaymentInstrumentID
        self.minRatingPlaybackGuard = minRatingPlaybackGuard
        self.segments = segments
    }

    private enum CodingKeys: String, CodingKey {
        case address
        case firstName
        case lastName
        case isTrackingEnabled = "trackingEnabled"
        case defaultPaymentMethodID = "defaultPaymentMethodId"
        case defaultPaymentInstrumentID = "defaultPaymentInstrumentId"
        case minRatingPlaybackGuard
        case segments
    }
}

public struct AddPaymentMethodRequest: Codable {
    /// The payment provider token representing a payment method, obtained by
    /// submitting payment method details to your third party provider.
    public var token: String
    /// The type of payment method.
    public var type: `Type`
    /// Whether this payment method should become the account default when 
    /// making purchases.
    /// 
    /// Note that if this is the first payment method of type Card being added to an
    /// account then it will become the default whether this property is true or false.
    public var isMakeDefault: Bool?

    /// The type of payment method.
    public enum `Type`: String, Codable, CaseIterable {
        case card = "Card"
    }

    public init(token: String, type: `Type`, isMakeDefault: Bool? = nil) {
        self.token = token
        self.type = type
        self.isMakeDefault = isMakeDefault
    }

    private enum CodingKeys: String, CodingKey {
        case token
        case type
        case isMakeDefault = "makeDefault"
    }
}

public struct Address: Codable {
    /// The first line of the street address.
    public var addressLine1: String?
    /// The second line of the street address.
    public var addressLine2: String?
    /// The city name.
    public var city: String?
    /// The country name or code.
    public var country: String?
    /// The postal or zip code.
    public var postcode: String?
    /// The state name or abbreviation.
    public var state: String?

    public init(addressLine1: String? = nil, addressLine2: String? = nil, city: String? = nil, country: String? = nil, postcode: String? = nil, state: String? = nil) {
        self.addressLine1 = addressLine1
        self.addressLine2 = addressLine2
        self.city = city
        self.country = country
        self.postcode = postcode
        self.state = state
    }
}

public struct AppConfig: Codable {
    /// The map of classification ratings.
    public var classification: [String: Classification]?
    public var subscription: AppConfigSubscription?
    public var playback: AppConfigPlayback?
    public var general: AppConfigGeneral?
    public var navigation: Navigation?
    public var sitemap: [PageSummary]?
    public var display: AppConfigDisplay?
    public var i18n: AppConfigI18n?
    public var linear: AppConfigLinear?

    public init(classification: [String: Classification]? = nil, subscription: AppConfigSubscription? = nil, playback: AppConfigPlayback? = nil, general: AppConfigGeneral? = nil, navigation: Navigation? = nil, sitemap: [PageSummary]? = nil, display: AppConfigDisplay? = nil, i18n: AppConfigI18n? = nil, linear: AppConfigLinear? = nil) {
        self.classification = classification
        self.subscription = subscription
        self.playback = playback
        self.general = general
        self.navigation = navigation
        self.sitemap = sitemap
        self.display = display
        self.i18n = i18n
        self.linear = linear
    }
}

public struct AppConfigDisplay: Codable {
    /// An array of globally configured themes.
    public var themes: [Theme]

    public init(themes: [Theme]) {
        self.themes = themes
    }
}

public struct AppConfigGeneral: Codable {
    /// The url of the primary website.
    public var websiteURL: URL?
    /// A Google Analytics token to track applicaton user events.
    public var gaToken: String?
    /// The public Stripe key to use for payment transactions.
    public var stripeKey: String?
    /// The Facebook application id associated with an environment.
    public var facebookAppID: String?
    /// A map of default item image types where the key is the item types.
    public var itemImageTypes: [String: String]?
    /// The currency code to target.
    public var currencyCode: String?
    /// A map of custom configuration fields.
    public var customFields: [String: AnyJSON]?
    /// The maximum value allowed for user ratings.
    public var maxUserRating: Int?
    /// Whether to require sign in for customers to access content.
    public var isMandatorySignIn: Bool?
    /// The default time zone of the site. e.g. "Etc/GMT"
    public var defaultTimeZone: String?

    public init(websiteURL: URL? = nil, gaToken: String? = nil, stripeKey: String? = nil, facebookAppID: String? = nil, itemImageTypes: [String: String]? = nil, currencyCode: String? = nil, customFields: [String: AnyJSON]? = nil, maxUserRating: Int? = nil, isMandatorySignIn: Bool? = nil, defaultTimeZone: String? = nil) {
        self.websiteURL = websiteURL
        self.gaToken = gaToken
        self.stripeKey = stripeKey
        self.facebookAppID = facebookAppID
        self.itemImageTypes = itemImageTypes
        self.currencyCode = currencyCode
        self.customFields = customFields
        self.maxUserRating = maxUserRating
        self.isMandatorySignIn = isMandatorySignIn
        self.defaultTimeZone = defaultTimeZone
    }

    private enum CodingKeys: String, CodingKey {
        case websiteURL = "websiteUrl"
        case gaToken
        case stripeKey
        case facebookAppID = "facebookAppId"
        case itemImageTypes
        case currencyCode
        case customFields
        case maxUserRating
        case isMandatorySignIn = "mandatorySignIn"
        case defaultTimeZone
    }
}

public struct AppConfigI18n: Codable {
    /// An array of available languages.
    public var languages: [Language]

    public init(languages: [Language]) {
        self.languages = languages
    }
}

public struct AppConfigLinear: Codable {
    /// Number of available upcoming day schedules.
    public var viewingWindowDaysAfter: Int?
    /// Number of available day schedules in the past.
    public var viewingWindowDaysBefore: Int?
    /// The maximum minutes of schedule cache time.
    public var scheduleCacheMaxAgeMinutes: Int?

    public init(viewingWindowDaysAfter: Int? = nil, viewingWindowDaysBefore: Int? = nil, scheduleCacheMaxAgeMinutes: Int? = nil) {
        self.viewingWindowDaysAfter = viewingWindowDaysAfter
        self.viewingWindowDaysBefore = viewingWindowDaysBefore
        self.scheduleCacheMaxAgeMinutes = scheduleCacheMaxAgeMinutes
    }
}

public struct AppConfigPlayback: Codable {
    /// How often a heartbeat should be renewed during playback.
    public var heartbeatFrequency: Int
    /// An array of percentage points in which to fire off plabyack view events.
    /// For example a value of 0.5 would indicate that an event should be
    /// fired when the user is half way through the video.
    /// Often known as quartiles when four equaly spread event points.
    public var viewEventPoints: [Double]
    /// The number of seconds before the end of playback when the current video
    /// should be minimized and user options are presented within the video player.
    /// 
    /// If set to 0 there will be no squeezeback.
    public var chainPlaySqueezeback: Int
    /// The number of minutes of user inactivity before autoplay is paused.
    /// 
    /// If set to 0 there will be no autoplay timeout.
    public var chainPlayTimeout: Int
    /// The number of seconds before autoplay of next video.
    /// 
    /// If set to 0 there will be no autoplay.
    public var chainPlayCountdown: Int

    public init(heartbeatFrequency: Int, viewEventPoints: [Double], chainPlaySqueezeback: Int, chainPlayTimeout: Int, chainPlayCountdown: Int) {
        self.heartbeatFrequency = heartbeatFrequency
        self.viewEventPoints = viewEventPoints
        self.chainPlaySqueezeback = chainPlaySqueezeback
        self.chainPlayTimeout = chainPlayTimeout
        self.chainPlayCountdown = chainPlayCountdown
    }
}

public struct AppConfigSubscription: Codable {
    /// The available public plans a user can subscribe to.
    public var plans: [Plan]?

    public init(plans: [Plan]? = nil) {
        self.plans = plans
    }
}

public struct Bookmark: Codable {
    /// The id of the item bookmarked.
    public var itemID: String
    /// The date the bookmark was created.
    public var creationDate: Date

    public init(itemID: String, creationDate: Date) {
        self.itemID = itemID
        self.creationDate = creationDate
    }

    private enum CodingKeys: String, CodingKey {
        case itemID = "itemId"
        case creationDate
    }
}

public struct BtPlanListItem: Codable {
    /// The identifier of a plan.
    public var id: String
    /// The title of a plan.
    public var nickname: String
    /// The product of a plan.
    public var product: String
    /// The currency a plan is offered in.
    public var currency: String
    /// The price of a plan. If a free plan then undefined.
    public var amount: Double?
    /// The type of billing period used.
    public var interval: Interval?
    /// Given the `interval` this is how frequently it will run. e.g. every 2 weeks.
    public var intervalCount: Int?
    /// How many days a trial period runs for a plan. Only valid if `hasTrialPeriod` is true.
    public var trialPeriodDays: Int
    /// The textual description.
    public var description: String
    /// The textual description.
    public var heroText: String
    /// The textual description.
    public var ctaText: String
    /// The textual description.
    public var headerText: String
    /// The textual description.
    public var longText: String
    public var termsAndConditionsStripe: String?
    public var termsAndConditionsItunes: String?
    public var ees07Title: String?
    public var ees07PlanTitle: String?
    public var ees07PlanDescription: String?
    public var noThanksText: String?
    public var switchingText: String?

    /// The type of billing period used.
    public enum Interval: String, Codable, CaseIterable {
        case day
        case week
        case month
        case year
        case `none`
    }

    public init(id: String, nickname: String, product: String, currency: String, amount: Double? = nil, interval: Interval? = nil, intervalCount: Int? = nil, trialPeriodDays: Int, description: String, heroText: String, ctaText: String, headerText: String, longText: String, termsAndConditionsStripe: String? = nil, termsAndConditionsItunes: String? = nil, ees07Title: String? = nil, ees07PlanTitle: String? = nil, ees07PlanDescription: String? = nil, noThanksText: String? = nil, switchingText: String? = nil) {
        self.id = id
        self.nickname = nickname
        self.product = product
        self.currency = currency
        self.amount = amount
        self.interval = interval
        self.intervalCount = intervalCount
        self.trialPeriodDays = trialPeriodDays
        self.description = description
        self.heroText = heroText
        self.ctaText = ctaText
        self.headerText = headerText
        self.longText = longText
        self.termsAndConditionsStripe = termsAndConditionsStripe
        self.termsAndConditionsItunes = termsAndConditionsItunes
        self.ees07Title = ees07Title
        self.ees07PlanTitle = ees07PlanTitle
        self.ees07PlanDescription = ees07PlanDescription
        self.noThanksText = noThanksText
        self.switchingText = switchingText
    }
}

public struct BtPlans: Codable {
    /// The list of available plans.
    public var plans: [BtPlanListItem]

    public init(plans: [BtPlanListItem]) {
        self.plans = plans
    }
}

public struct ChangePasswordRequest: Codable {
    /// The new password for the account.
    public var password: String
    /// The ITV profile token.
    public var profileToken: String

    public init(password: String, profileToken: String) {
        self.password = password
        self.profileToken = profileToken
    }
}

public struct ChangePinRequest: Codable {
    /// The new pin to set.
    public var pin: String

    public init(pin: String) {
        self.pin = pin
    }
}

public struct Classification: Codable {
    public var classificationSummary: ClassificationSummary
    /// Parental advisort text.
    public var advisoryText: String?
    /// The level of this classification when compared with its siblings.
    /// A higher level means a greater restriction.
    /// Each classification in a system should have a unique level.
    public var level: Int
    /// The parent system code of the classification.
    public var system: String
    public var images: [String: URL]

    public init(classificationSummary: ClassificationSummary, advisoryText: String? = nil, level: Int, system: String, images: [String: URL]) {
        self.classificationSummary = classificationSummary
        self.advisoryText = advisoryText
        self.level = level
        self.system = system
        self.images = images
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.classificationSummary = try ClassificationSummary(from: decoder)
        self.advisoryText = try values.decodeIfPresent(String.self, forKey: "advisoryText")
        self.level = try values.decode(Int.self, forKey: "level")
        self.system = try values.decode(String.self, forKey: "system")
        self.images = try values.decode([String: URL].self, forKey: "images")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(classificationSummary, forKey: "classificationSummary")
        try values.encodeIfPresent(advisoryText, forKey: "advisoryText")
        try values.encode(level, forKey: "level")
        try values.encode(system, forKey: "system")
        try values.encode(images, forKey: "images")
    }
}

public struct ClassificationSummary: Codable {
    /// The unique code for a classification.
    public var code: String
    /// The name of the classification for display.
    public var name: String

    public init(code: String, name: String) {
        self.code = code
        self.name = name
    }
}

/// List data for ContinueWatching List
public struct ContinueWatchingListData: Codable {
    /// Object where keys are itemIds for the items in the list and values are objects
    /// containing additional items (either episode/season/show) that were requested
    /// in the "include" query option.
    /// 
    /// For example if you request the ContinueWatching list with "season" items in
    /// the list, you can specify `include=episode` and then the specific next episode
    /// will be returned in this object.
    public var itemInclusions: [String: ContinueWatchingListDataExpansion]?

    public init(itemInclusions: [String: ContinueWatchingListDataExpansion]? = nil) {
        self.itemInclusions = itemInclusions
    }
}

public struct ContinueWatchingListDataExpansion: Codable {
    public var episode: ItemSummary?
    public var season: ItemSummary?
    public var show: ItemSummary?

    public init(episode: ItemSummary? = nil, season: ItemSummary? = nil, show: ItemSummary? = nil) {
        self.episode = episode
        self.season = season
        self.show = show
    }
}

public struct Credit: Codable {
    public var person: Person
    /// The type of role the credit performed, e.g. actor.
    public var role: Role
    /// The name of the character.
    public var character: String?

    /// The type of role the credit performed, e.g. actor.
    public enum Role: String, Codable, CaseIterable {
        case actor
        case associateproducer
        case coactor
        case director
        case executiveproducer
        case filminglocation
        case guest
        case narrator
        case other
        case presenter
        case producer
        case productmanager
        case thememusicby
        case voice
        case writer
    }

    public init(person: Person, role: Role, character: String? = nil) {
        self.person = person
        self.role = role
        self.character = character
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.person = try Person(from: decoder)
        self.role = try Role(from: decoder)
        self.character = try values.decodeIfPresent(String.self, forKey: "character")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(person, forKey: "person")
        try values.encode(role, forKey: "role")
        try values.encodeIfPresent(character, forKey: "character")
    }
}

public struct Device: Codable {
    /// The unique identifier for this device e.g. serial number.
    public var id: String
    /// The human recognisable name for this device.
    public var name: String
    /// The date this device was registered.
    public var registrationDate: Date
    /// The device type e.g. web_browser.
    public var type: String

    public init(id: String, name: String, registrationDate: Date, type: String) {
        self.id = id
        self.name = name
        self.registrationDate = registrationDate
        self.type = type
    }
}

public struct DeviceAuthorizationCode: Codable {
    /// The generated device authorization code.
    public var code: String

    public init(code: String) {
        self.code = code
    }
}

public struct DeviceRegistrationRequest: Codable {
    /// The unique identifier for this device e.g. serial number.
    public var id: String
    /// A human recognisable name for this device.
    public var name: String
    /// The device type e.g. web_browser.
    public var type: String

    public init(id: String, name: String, type: String) {
        self.id = id
        self.name = name
        self.type = type
    }
}

public struct DeviceRegistrationWindow: Codable {
    /// The number of days a de/registration period runs for.
    public var periodDays: Int
    /// The maximum de/registrations that can be made in a period.
    public var limit: Int
    /// The remaining de/registrations that can be made in the current period.
    public var remaining: Int
    /// The start date of the current period.
    /// 
    /// This is based on the earliest device de/registrations in the past N days, where
    /// N is defined by `periodDays`.
    /// 
    /// If no device has been de/registered then start date will be from the current date.
    public var startDate: Date
    /// The end date of the current period.
    /// 
    /// This is based on the value of `startDate` plus the number of days defined by  `periodDays`.
    public var endDate: Date

    public init(periodDays: Int, limit: Int, remaining: Int, startDate: Date, endDate: Date) {
        self.periodDays = periodDays
        self.limit = limit
        self.remaining = remaining
        self.startDate = startDate
        self.endDate = endDate
    }
}

public struct EeBtEligibility: Codable {
    /// The identifier of a plan.
    public var plan: String?
    /// Stripe etc.
    public var source: String?
    /// Whether or not user is eligible
    public var isEligible: Bool

    public init(plan: String? = nil, source: String? = nil, isEligible: Bool) {
        self.plan = plan
        self.source = source
        self.isEligible = isEligible
    }

    private enum CodingKeys: String, CodingKey {
        case plan
        case source
        case isEligible = "eligible"
    }
}

/// Example:
///
/// {
///   "accessToken" : "wxg0fG4GQjBQVjAT0AhKxSkrxFbs",
///   "msisdn" : "447931234567",
///   "trackingHeader" : "1234E682-2C74-46A4-B8B3-5BBD3B3E165D"
/// }
public struct EeCreatePinRequest: Codable {
    /// The msisdn.
    public var msisdn: String
    /// EE API authorization Token received from GET /ee/token/create.
    public var accessToken: String
    /// TrackingHeader
    public var trackingHeader: String?

    public init(msisdn: String, accessToken: String, trackingHeader: String? = nil) {
        self.msisdn = msisdn
        self.accessToken = accessToken
        self.trackingHeader = trackingHeader
    }
}

public struct EeCreatePinResponse: Codable {
    /// The pinReference.
    public var pinReference: String
    /// TrackingHeader
    public var trackingHeader: String

    public init(pinReference: String, trackingHeader: String) {
        self.pinReference = pinReference
        self.trackingHeader = trackingHeader
    }
}

public struct EeCreateTokenResponse: Codable {
    /// The authentication token for later use to call EE endpoints.
    public var accessToken: String?
    public var tokenType: String?
    public var expiresIn: Double?

    public init(accessToken: String? = nil, tokenType: String? = nil, expiresIn: Double? = nil) {
        self.accessToken = accessToken
        self.tokenType = tokenType
        self.expiresIn = expiresIn
    }
}

/// Example:
///
/// {
///   "accessToken" : "wxg0fG4GQjBQVjAT0AhKxSkrxFbs",
///   "sessionId" : "7897E682-2C74-46A4-B8B3-5BBD3B3E165D"
/// }
public struct EeIdentityRequest: Codable {
    /// The sessionId returned in the ee/session response.
    public var sessionID: String
    /// EE API authorization Token received from GET /ee/token/create.
    public var accessToken: String

    public init(sessionID: String, accessToken: String) {
        self.sessionID = sessionID
        self.accessToken = accessToken
    }

    private enum CodingKeys: String, CodingKey {
        case sessionID = "sessionId"
        case accessToken
    }
}

public struct EeIdentityResponse: Codable {
    /// The msisdn.
    public var msisdn: String
    /// The operator brand.
    public var brand: String?
    /// The brand code.
    public var brandCode: String?
    /// TrackingHeader
    public var trackingHeader: String

    public init(msisdn: String, brand: String? = nil, brandCode: String? = nil, trackingHeader: String) {
        self.msisdn = msisdn
        self.brand = brand
        self.brandCode = brandCode
        self.trackingHeader = trackingHeader
    }
}

public struct EeOfferItem: Codable {
    /// The identifier of an offer.
    public var name: String

    public init(name: String) {
        self.name = name
    }
}

/// Example:
///
/// {
///   "accessToken" : "wxg0fG4GQjBQVjAT0AhKxSkrxFbs",
///   "msisdn" : "447931234567",
///   "trackingHeader" : "1234E682-2C74-46A4-B8B3-5BBD3B3E165D"
/// }
public struct EeOffersRequest: Codable {
    /// The msisdn.
    public var msisdn: String
    /// EE API authorization Token received from GET /ee/token/create.
    public var accessToken: String
    /// TrackingHeader.
    public var trackingHeader: String?

    public init(msisdn: String, accessToken: String, trackingHeader: String? = nil) {
        self.msisdn = msisdn
        self.accessToken = accessToken
        self.trackingHeader = trackingHeader
    }
}

public struct EeOffersResponse: Codable {
    /// The list of eligible offers.
    public var eligibleOffers: [EeOfferItem]

    public init(eligibleOffers: [EeOfferItem]) {
        self.eligibleOffers = eligibleOffers
    }
}

public struct EePlanListItem: Codable {
    /// The identifier of a plan.
    public var id: String
    /// The title of a plan.
    public var nickname: String
    /// The product of a plan.
    public var product: String
    /// The currency a plan is offered in.
    public var currency: String
    /// The price of a plan. If a free plan then undefined.
    public var amount: Double?
    /// The type of billing period used.
    public var interval: Interval?
    /// Given the `interval` this is how frequently it will run. e.g. every 2 weeks.
    public var intervalCount: Int?
    /// How many days a trial period runs for a plan. Only valid if `hasTrialPeriod` is true.
    public var trialPeriodDays: Int
    /// The textual description.
    public var description: String
    /// The textual description.
    public var heroText: String
    /// The textual description.
    public var ctaText: String
    /// The textual description.
    public var headerText: String
    /// The textual description.
    public var longText: String

    /// The type of billing period used.
    public enum Interval: String, Codable, CaseIterable {
        case day
        case week
        case month
        case year
        case `none`
    }

    public init(id: String, nickname: String, product: String, currency: String, amount: Double? = nil, interval: Interval? = nil, intervalCount: Int? = nil, trialPeriodDays: Int, description: String, heroText: String, ctaText: String, headerText: String, longText: String) {
        self.id = id
        self.nickname = nickname
        self.product = product
        self.currency = currency
        self.amount = amount
        self.interval = interval
        self.intervalCount = intervalCount
        self.trialPeriodDays = trialPeriodDays
        self.description = description
        self.heroText = heroText
        self.ctaText = ctaText
        self.headerText = headerText
        self.longText = longText
    }
}

public struct EePlans: Codable {
    /// The list of available plans.
    public var plans: [EePlanListItem]

    public init(plans: [EePlanListItem]) {
        self.plans = plans
    }
}

/// Example:
///
/// {
///   "accessToken" : "xxxDDxBoHnNG1qYWutsRqE0dHxxx",
///   "clientIP" : "123.456.789"
/// }
public struct EeSessionIDRequest: Codable {
    /// The IP address of the requesting device.
    public var clientIP: String
    /// EE API authorization Token received from GET /ee/token/create.
    public var accessToken: String

    public init(clientIP: String, accessToken: String) {
        self.clientIP = clientIP
        self.accessToken = accessToken
    }
}

public struct EeSessionIDResponse: Codable {
    /// The assigned SessionId.
    public var sessionID: String

    public init(sessionID: String) {
        self.sessionID = sessionID
    }

    private enum CodingKeys: String, CodingKey {
        case sessionID = "sessionId"
    }
}

/// Example:
///
/// {
///   "accessToken" : "wxg0fG4GQjBQVjAT0AhKxSkrxFbs",
///   "pin" : "123456",
///   "pinReference" : "9897222307534",
///   "trackingHeader" : "1234E682-2C74-46A4-B8B3-5BBD3B3E165D"
/// }
public struct EeValidatePinRequest: Codable {
    /// The pinReference.
    public var pinReference: String
    /// The pin entered by a user. 6 digits
    public var pin: String
    /// EE API authorization Token received from GET /ee/token/create.
    public var accessToken: String
    /// Tracking header to be able to search logs for a specific user requests. If not provided it will be generated. FE should store it for later user.
    public var trackingHeader: String?

    public init(pinReference: String, pin: String, accessToken: String, trackingHeader: String? = nil) {
        self.pinReference = pinReference
        self.pin = pin
        self.accessToken = accessToken
        self.trackingHeader = trackingHeader
    }
}

public struct EeValidatePinResponse: Codable {
    /// The validation status.
    public var pinValid: String?
    /// TrackingHeader
    public var trackingHeader: String

    public init(pinValid: String? = nil, trackingHeader: String) {
        self.pinValid = pinValid
        self.trackingHeader = trackingHeader
    }
}

public struct Entitlement: Codable {
    /// The base type for both Offer and Entitlement.
    public var offerRights: OfferRights
    /// The date of activation. If no date is defined the entitlement has not be activated.
    public var activationDate: Date?
    /// The date the entitlement expires.
    public var expirationDate: Date?
    /// The date the entitlement was created.
    public var creationDate: Date?
    /// How many times the media has been played.
    public var playCount: Int?
    /// How many more downloads of this media are available.
    public var remainingDownloads: Int?
    /// The id of the item this entitlement is for.
    public var itemID: String?
    /// The type of item this entitlement is for.
    public var itemType: ItemType?
    /// The id of the plan this entitlement is for.
    public var planID: String?
    /// The duration of the entitled media.
    public var mediaDuration: Int?
    public var classification: ClassificationSummary?

    /// The type of item this entitlement is for.
    public enum ItemType: String, Codable, CaseIterable {
        case movie
        case show
        case season
        case episode
        case program
        case link
        case trailer
        case channel
        case customAsset
    }

    public init(offerRights: OfferRights, activationDate: Date? = nil, expirationDate: Date? = nil, creationDate: Date? = nil, playCount: Int? = nil, remainingDownloads: Int? = nil, itemID: String? = nil, itemType: ItemType? = nil, planID: String? = nil, mediaDuration: Int? = nil, classification: ClassificationSummary? = nil) {
        self.offerRights = offerRights
        self.activationDate = activationDate
        self.expirationDate = expirationDate
        self.creationDate = creationDate
        self.playCount = playCount
        self.remainingDownloads = remainingDownloads
        self.itemID = itemID
        self.itemType = itemType
        self.planID = planID
        self.mediaDuration = mediaDuration
        self.classification = classification
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.offerRights = try OfferRights(from: decoder)
        self.activationDate = try values.decodeIfPresent(Date.self, forKey: "activationDate")
        self.expirationDate = try values.decodeIfPresent(Date.self, forKey: "expirationDate")
        self.creationDate = try values.decodeIfPresent(Date.self, forKey: "creationDate")
        self.playCount = try values.decodeIfPresent(Int.self, forKey: "playCount")
        self.remainingDownloads = try values.decodeIfPresent(Int.self, forKey: "remainingDownloads")
        self.itemID = try values.decodeIfPresent(String.self, forKey: "itemId")
        self.itemType = try ItemType(from: decoder)
        self.planID = try values.decodeIfPresent(String.self, forKey: "planId")
        self.mediaDuration = try values.decodeIfPresent(Int.self, forKey: "mediaDuration")
        self.classification = try ClassificationSummary(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(offerRights, forKey: "offerRights")
        try values.encodeIfPresent(activationDate, forKey: "activationDate")
        try values.encodeIfPresent(expirationDate, forKey: "expirationDate")
        try values.encodeIfPresent(creationDate, forKey: "creationDate")
        try values.encodeIfPresent(playCount, forKey: "playCount")
        try values.encodeIfPresent(remainingDownloads, forKey: "remainingDownloads")
        try values.encodeIfPresent(itemID, forKey: "itemId")
        try values.encodeIfPresent(itemType, forKey: "itemType")
        try values.encodeIfPresent(planID, forKey: "planId")
        try values.encodeIfPresent(mediaDuration, forKey: "mediaDuration")
        try values.encodeIfPresent(classification, forKey: "classification")
    }
}

/// Defines playback exclusion rules for an Offer or Entitlement.
public struct ExclusionRule: Codable {
    public var description: String?
    /// The device type that the exclusion rules apply to.
    public var device: String?
    /// Prevent airplay from an apple device.
    public var excludeAirplay: Bool?
    /// Prevent chromecasting.
    public var excludeChromecast: Bool?
    public var excludeDelivery: ExcludeDelivery?
    public var excludeMinResolution: ExcludeMinResolution?

    public enum ExcludeDelivery: String, Codable, CaseIterable {
        case stream = "Stream"
        case download = "Download"
        case streamOrDownload = "StreamOrDownload"
        case progressiveDownload = "ProgressiveDownload"
        case `none` = "None"
    }

    public enum ExcludeMinResolution: String, Codable, CaseIterable {
        case sd = "SD"
        case hd720 = "HD-720"
        case hd1080 = "HD-1080"
        case hd4k = "HD-4K"
        case external = "External"
        case unknown = "Unknown"
    }

    public init(description: String? = nil, device: String? = nil, excludeAirplay: Bool? = nil, excludeChromecast: Bool? = nil, excludeDelivery: ExcludeDelivery? = nil, excludeMinResolution: ExcludeMinResolution? = nil) {
        self.description = description
        self.device = device
        self.excludeAirplay = excludeAirplay
        self.excludeChromecast = excludeChromecast
        self.excludeDelivery = excludeDelivery
        self.excludeMinResolution = excludeMinResolution
    }
}

public struct ItemClipFile: Codable {
    /// The name of the media file.
    public var name: String
    /// The way in which the media file is delivered.
    public var deliveryType: DeliveryType
    /// The url to access the media file.
    public var url: URL
    /// The type of drm used to encrypt the media. 'None' if unencrypted.
    public var drm: String
    /// The format the media was encoded in.
    public var format: String
    /// The resolution of the video media.
    public var resolution: Resolution
    /// The width of the video media.
    public var width: Int
    /// The height of the video media.
    public var height: Int
    /// The number of audio channels.
    public var channels: Int?
    /// The language code for the media, e.g. 'en'.
    public var language: String

    /// The way in which the media file is delivered.
    public enum DeliveryType: String, Codable, CaseIterable {
        case stream = "Stream"
        case progressive = "Progressive"
        case download = "Download"
    }

    /// The resolution of the video media.
    public enum Resolution: String, Codable, CaseIterable {
        case sd = "SD"
        case hd720 = "HD-720"
        case hd1080 = "HD-1080"
        case hd4k = "HD-4K"
        case external = "External"
        case unknown = "Unknown"
    }

    public init(name: String, deliveryType: DeliveryType, url: URL, drm: String, format: String, resolution: Resolution, width: Int, height: Int, channels: Int? = nil, language: String) {
        self.name = name
        self.deliveryType = deliveryType
        self.url = url
        self.drm = drm
        self.format = format
        self.resolution = resolution
        self.width = width
        self.height = height
        self.channels = channels
        self.language = language
    }
}

public struct ItemClipFiles: Codable {
    /// Unique identifier for an Item
    public var id: String
    /// Array of item clip file.
    public var clips: [ItemClipFile]

    public init(id: String, clips: [ItemClipFile]) {
        self.id = id
        self.clips = clips
    }
}

/// A list of items with its clip files.
public struct ItemClipFilesList: Codable {
    /// A list of items
    public var items: [ItemClipFiles]

    public init(items: [ItemClipFiles]) {
        self.items = items
    }
}

/// Custom metadata associated with an item.
public struct ItemCustomMetadata: Codable {
    /// The name of the custom metadata.
    public var name: String
    /// The value of the custom metadata.
    public var value: String

    public init(name: String, value: String) {
        self.name = name
        self.value = value
    }
}

public final class ItemDetail: Codable {
    public var itemSummary: ItemSummary
    /// Copyright information about this item
    public var copyright: String?
    /// The distributor of this item.
    public var distributor: String?
    /// The description of this item.
    public var description: String?
    /// An ordered list of custom name-value-pair item metadata.
    /// 
    /// Usually displayed on an item detail page.
    public var customMetadata: [ItemCustomMetadata]?
    /// An array of genre paths mapping to the values within the `genres` array from ItemSummary.
    public var genrePaths: [String]?
    /// The optional location (e.g. city) of an event.
    /// Specific to a Program item type.
    public var location: String?
    /// The optional venue of an event.
    /// Specific to a Program item type.
    public var venue: String?
    /// The optional date of an event.
    /// Specific to a Program item type.
    public var eventDate: Date?
    /// A list of credits associated with this item.
    public var credits: [Credit]?
    /// A pageable list of items.
    public var seasons: ItemList?
    /// A pageable list of items.
    public var episodes: ItemList?
    public var season: ItemDetail?
    public var show: ItemDetail?
    /// A list of trailers associated with this item.
    public var trailers: [ItemSummary]?

    public init(itemSummary: ItemSummary, copyright: String? = nil, distributor: String? = nil, description: String? = nil, customMetadata: [ItemCustomMetadata]? = nil, genrePaths: [String]? = nil, location: String? = nil, venue: String? = nil, eventDate: Date? = nil, credits: [Credit]? = nil, seasons: ItemList? = nil, episodes: ItemList? = nil, season: ItemDetail? = nil, show: ItemDetail? = nil, trailers: [ItemSummary]? = nil) {
        self.itemSummary = itemSummary
        self.copyright = copyright
        self.distributor = distributor
        self.description = description
        self.customMetadata = customMetadata
        self.genrePaths = genrePaths
        self.location = location
        self.venue = venue
        self.eventDate = eventDate
        self.credits = credits
        self.seasons = seasons
        self.episodes = episodes
        self.season = season
        self.show = show
        self.trailers = trailers
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.itemSummary = try ItemSummary(from: decoder)
        self.copyright = try values.decodeIfPresent(String.self, forKey: "copyright")
        self.distributor = try values.decodeIfPresent(String.self, forKey: "distributor")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.customMetadata = try values.decodeIfPresent([ItemCustomMetadata].self, forKey: "customMetadata")
        self.genrePaths = try values.decodeIfPresent([String].self, forKey: "genrePaths")
        self.location = try values.decodeIfPresent(String.self, forKey: "location")
        self.venue = try values.decodeIfPresent(String.self, forKey: "venue")
        self.eventDate = try values.decodeIfPresent(Date.self, forKey: "eventDate")
        self.credits = try values.decodeIfPresent([Credit].self, forKey: "credits")
        self.seasons = try ItemList(from: decoder)
        self.episodes = try ItemList(from: decoder)
        self.season = try ItemDetail(from: decoder)
        self.show = try ItemDetail(from: decoder)
        self.trailers = try values.decodeIfPresent([ItemSummary].self, forKey: "trailers")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(itemSummary, forKey: "itemSummary")
        try values.encodeIfPresent(copyright, forKey: "copyright")
        try values.encodeIfPresent(distributor, forKey: "distributor")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(customMetadata, forKey: "customMetadata")
        try values.encodeIfPresent(genrePaths, forKey: "genrePaths")
        try values.encodeIfPresent(location, forKey: "location")
        try values.encodeIfPresent(venue, forKey: "venue")
        try values.encodeIfPresent(eventDate, forKey: "eventDate")
        try values.encodeIfPresent(credits, forKey: "credits")
        try values.encodeIfPresent(seasons, forKey: "seasons")
        try values.encodeIfPresent(episodes, forKey: "episodes")
        try values.encodeIfPresent(season, forKey: "season")
        try values.encodeIfPresent(show, forKey: "show")
        try values.encodeIfPresent(trailers, forKey: "trailers")
    }
}

public struct ItemDownloadable: Codable {
    /// Unique identifier for an Item
    public var id: String
    /// Is the item downloadable?
    public var isDownloadable: Bool

    public init(id: String, isDownloadable: Bool) {
        self.id = id
        self.isDownloadable = isDownloadable
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case isDownloadable = "downloadable"
    }
}

/// A list of items downloadable data.
public struct ItemDownloadableList: Codable {
    /// A list of items
    public var items: [ItemDownloadable]

    public init(items: [ItemDownloadable]) {
        self.items = items
    }
}

/// Example:
///
/// {
///   "ids" : "1234,2345,3456"
/// }
public struct ItemDownloadableRequest: Codable {
    /// Comma-separated list of AXIS item ids.
    public var ids: String

    public init(ids: String) {
        self.ids = ids
    }
}

/// A pageable list of items.
public struct ItemList: Codable {
    /// The id of this list
    public var id: String
    /// The title of this list
    public var title: String?
    /// A full description of this list.
    public var description: String?
    /// A short description of this list.
    public var shortDescription: String?
    /// The tagline of the item.
    public var tagline: String?
    /// The path of this list
    public var path: String
    /// The types of items in the list
    public var itemTypes: [ItemType]?
    /// The total size of the list
    public var size: Int
    /// A list of items
    public var items: [ItemSummary]
    public var images: [String: URL]?
    /// If this list is parameterized, then this contains the parameter of the list in the format `name:value`.
    /// For example the Movies Genre list will take a parameter `genre` with a given value. e.g. `genre:action` or `genre:drama`.
    public var parameter: String?
    public var paging: Pagination
    /// A map of custom fields defined by a curator for a list.
    public var customFields: [String: AnyJSON]?
    public var themes: [Theme]?
    /// Extra data to accompany ItemList content. The (single) key in the object is
    /// the list name and the data changes depending on the list
    public var listData: ListData?

    public enum ItemType: String, Codable, CaseIterable {
        case movie
        case show
        case season
        case episode
        case program
        case link
        case trailer
        case channel
        case customAsset
    }

    public init(id: String, title: String? = nil, description: String? = nil, shortDescription: String? = nil, tagline: String? = nil, path: String, itemTypes: [ItemType]? = nil, size: Int, items: [ItemSummary], images: [String: URL]? = nil, parameter: String? = nil, paging: Pagination, customFields: [String: AnyJSON]? = nil, themes: [Theme]? = nil, listData: ListData? = nil) {
        self.id = id
        self.title = title
        self.description = description
        self.shortDescription = shortDescription
        self.tagline = tagline
        self.path = path
        self.itemTypes = itemTypes
        self.size = size
        self.items = items
        self.images = images
        self.parameter = parameter
        self.paging = paging
        self.customFields = customFields
        self.themes = themes
        self.listData = listData
    }
}

public struct ItemPurchase: Codable {
    /// The identifier of the purchased item.
    public var id: String
    /// The ownership of the purchased item.
    public var ownership: Ownership
    /// The resolution of the purchased item.
    public var resolution: Resolution
    /// The title of the purchased item.
    public var title: String
    /// The type of item purchased.
    public var type: `Type`

    /// The ownership of the purchased item.
    public enum Ownership: String, Codable, CaseIterable {
        case subscription = "Subscription"
        case free = "Free"
        case rent = "Rent"
        case own = "Own"
        case `none` = "None"
    }

    /// The resolution of the purchased item.
    public enum Resolution: String, Codable, CaseIterable {
        case sd = "SD"
        case hd720 = "HD-720"
        case hd1080 = "HD-1080"
        case hd4k = "HD-4K"
        case external = "External"
        case unknown = "Unknown"
    }

    /// The type of item purchased.
    public enum `Type`: String, Codable, CaseIterable {
        case movie
        case show
        case season
        case episode
        case program
        case link
        case trailer
        case channel
        case customAsset
    }

    public init(id: String, ownership: Ownership, resolution: Resolution, title: String, type: `Type`) {
        self.id = id
        self.ownership = ownership
        self.resolution = resolution
        self.title = title
        self.type = type
    }
}

public struct ItemSchedule: Codable {
    public var id: String
    /// The id of the channel item this schedule belongs to.
    public var channelID: String
    /// The date and time this schedule starts.
    public var startDate: Date
    /// The date and time this schedule ends.
    public var endDate: Date
    /// True if this has been aired previously on the same channel.
    public var isRepeat: Bool?
    /// True if this is a live event.
    public var isLive: Bool?
    /// True if this is a featured item schedule.
    public var isFeatured: Bool?
    /// True if this schedule represents time when the channel is completely off air.
    public var isBlackout: Bool?

    public init(id: String, channelID: String, startDate: Date, endDate: Date, isRepeat: Bool? = nil, isLive: Bool? = nil, isFeatured: Bool? = nil, isBlackout: Bool? = nil) {
        self.id = id
        self.channelID = channelID
        self.startDate = startDate
        self.endDate = endDate
        self.isRepeat = isRepeat
        self.isLive = isLive
        self.isFeatured = isFeatured
        self.isBlackout = isBlackout
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case channelID = "channelId"
        case startDate
        case endDate
        case isRepeat = "repeat"
        case isLive = "live"
        case isFeatured = "featured"
        case isBlackout = "blackout"
    }
}

public struct ItemScheduleList: Codable {
    /// The id of the channel the schedules belong to.
    public var channelID: String
    /// The date and time this list of schedules starts.
    public var startDate: Date
    /// The date and time this list of schedules ends.
    public var endDate: Date
    /// The list of item schedules.
    public var schedules: [ItemSchedule]

    public init(channelID: String, startDate: Date, endDate: Date, schedules: [ItemSchedule]) {
        self.channelID = channelID
        self.startDate = startDate
        self.endDate = endDate
        self.schedules = schedules
    }

    private enum CodingKeys: String, CodingKey {
        case channelID = "channelId"
        case startDate
        case endDate
        case schedules
    }
}

public struct ItemSummary: Codable {
    /// Unique identifier for an Item
    public var id: String
    /// The type of item
    public var type: `Type`
    /// Subtype of the item. Mainly used to identify different types when `type`
    /// is `customAsset`
    public var subtype: String?
    /// The display title of the item.
    public var title: String
    /// A truncated description of the item
    public var shortDescription: String?
    /// The tagline of the item
    public var tagline: String?
    public var classification: ClassificationSummary?
    /// Advisory text about this item, related to the classification
    public var advisoryText: String?
    /// The path to the detail page of this item. Can be used to load the item detail page via the /page endpoint.
    public var path: String
    /// The path to watch this item, if the item is a watchable type, e.g. a `movie`, `program` and `episode`.
    public var watchPath: String?
    /// The scopes for this item
    public var scopes: [String]?
    /// The year this item was released
    public var releaseYear: Int?
    /// The number of episodes in the season, if the item is a season.
    public var episodeCount: Int?
    /// The number of available episodes in the season, if the item is a season.
    public var availableEpisodeCount: Int?
    /// The number of available seasons in the show, if the item is a show.
    public var availableSeasonCount: Int?
    /// The number of available specials in the item.
    public var availableSpecialCount: Int?
    /// The number of a season, if the item is a season.
    public var seasonNumber: Int?
    /// The number of an episode, if the item is an episode.
    public var episodeNumber: Int?
    /// The full name of an episode.
    public var episodeName: String?
    /// The identifier of the show this item belongs to, if the item is a season or episode.
    public var showID: String?
    public var showTitle: String?
    /// The identifier of the season this item belongs to, if the item is an episode.
    public var seasonID: String?
    /// The channel short code, if the item is a channel.
    public var channelShortCode: String?
    /// Whether closed captioning is available.
    public var hasClosedCaptions: Bool?
    /// The average user rating.
    /// When based on user ratings from our system this will be out of 10.
    public var averageUserRating: Double?
    /// The badge this item has.
    public var badge: String?
    /// The array of genres this item belongs to.
    public var genres: [String]?
    /// The duration of the media in seconds.
    public var duration: Int?
    /// A custom identifier for this item.
    /// For example the id for this item under a different content system.
    public var customID: String?
    /// The array of available offers for this item.
    public var offers: [Offer]?
    public var images: [String: URL]?
    /// Gets themes associated with the item
    public var themes: [Theme]?
    /// A map of custom fields defined by a curator for an item.
    public var customFields: [String: AnyJSON]?

    /// The type of item
    public enum `Type`: String, Codable, CaseIterable {
        case movie
        case show
        case season
        case episode
        case program
        case link
        case trailer
        case channel
        case customAsset
    }

    public init(id: String, type: `Type`, subtype: String? = nil, title: String, shortDescription: String? = nil, tagline: String? = nil, classification: ClassificationSummary? = nil, advisoryText: String? = nil, path: String, watchPath: String? = nil, scopes: [String]? = nil, releaseYear: Int? = nil, episodeCount: Int? = nil, availableEpisodeCount: Int? = nil, availableSeasonCount: Int? = nil, availableSpecialCount: Int? = nil, seasonNumber: Int? = nil, episodeNumber: Int? = nil, episodeName: String? = nil, showID: String? = nil, showTitle: String? = nil, seasonID: String? = nil, channelShortCode: String? = nil, hasClosedCaptions: Bool? = nil, averageUserRating: Double? = nil, badge: String? = nil, genres: [String]? = nil, duration: Int? = nil, customID: String? = nil, offers: [Offer]? = nil, images: [String: URL]? = nil, themes: [Theme]? = nil, customFields: [String: AnyJSON]? = nil) {
        self.id = id
        self.type = type
        self.subtype = subtype
        self.title = title
        self.shortDescription = shortDescription
        self.tagline = tagline
        self.classification = classification
        self.advisoryText = advisoryText
        self.path = path
        self.watchPath = watchPath
        self.scopes = scopes
        self.releaseYear = releaseYear
        self.episodeCount = episodeCount
        self.availableEpisodeCount = availableEpisodeCount
        self.availableSeasonCount = availableSeasonCount
        self.availableSpecialCount = availableSpecialCount
        self.seasonNumber = seasonNumber
        self.episodeNumber = episodeNumber
        self.episodeName = episodeName
        self.showID = showID
        self.showTitle = showTitle
        self.seasonID = seasonID
        self.channelShortCode = channelShortCode
        self.hasClosedCaptions = hasClosedCaptions
        self.averageUserRating = averageUserRating
        self.badge = badge
        self.genres = genres
        self.duration = duration
        self.customID = customID
        self.offers = offers
        self.images = images
        self.themes = themes
        self.customFields = customFields
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case type
        case subtype
        case title
        case shortDescription
        case tagline
        case classification
        case advisoryText
        case path
        case watchPath
        case scopes
        case releaseYear
        case episodeCount
        case availableEpisodeCount
        case availableSeasonCount
        case availableSpecialCount
        case seasonNumber
        case episodeNumber
        case episodeName
        case showID = "showId"
        case showTitle
        case seasonID = "seasonId"
        case channelShortCode
        case hasClosedCaptions
        case averageUserRating
        case badge
        case genres
        case duration
        case customID = "customId"
        case offers
        case images
        case themes
        case customFields
    }
}

public struct ItvAssignBtTokenRequest: Codable {
    /// The validated userToken.
    public var token: String
    /// The ITV profile token
    public var profileToken: String

    public init(token: String, profileToken: String) {
        self.token = token
        self.profileToken = profileToken
    }
}

public struct ItvAssignMsisdnRequest: Codable {
    /// The validated msisdn.
    public var msisdn: String
    /// The ITV profile token
    public var profileToken: String
    /// TrackingHeader
    public var trackingHeader: String
    /// Product id from /ee/offers
    public var eeProductID: String

    public init(msisdn: String, profileToken: String, trackingHeader: String, eeProductID: String) {
        self.msisdn = msisdn
        self.profileToken = profileToken
        self.trackingHeader = trackingHeader
        self.eeProductID = eeProductID
    }

    private enum CodingKeys: String, CodingKey {
        case msisdn
        case profileToken
        case trackingHeader
        case eeProductID = "eeProductId"
    }
}

public struct ItvBillingHistory: Codable {
    /// The array of objects with subscription payment details.
    public var paymentHistory: [ItvBillingHistoryRecord]

    public init(paymentHistory: [ItvBillingHistoryRecord]) {
        self.paymentHistory = paymentHistory
    }

    private enum CodingKeys: String, CodingKey {
        case paymentHistory = "payment_history"
    }
}

public struct ItvBillingHistoryRecord: Codable {
    /// The card info.
    public var card: [String: AnyJSON]
    /// The object with subscription payment details.
    public var subscription: [String: AnyJSON]
    /// The object with invoice details.
    public var invoice: [String: AnyJSON]
    /// The amount charged.
    public var charge: [String: AnyJSON]

    public init(card: [String: AnyJSON], subscription: [String: AnyJSON], invoice: [String: AnyJSON], charge: [String: AnyJSON]) {
        self.card = card
        self.subscription = subscription
        self.invoice = invoice
        self.charge = charge
    }
}

public struct ItvBillingHistoryRequest: Codable {
    /// The ITV profile token.
    public var profileToken: String

    public init(profileToken: String) {
        self.profileToken = profileToken
    }
}

public struct ItvCancelSubscriptionRequest: Codable {
    /// The ITV profile token.
    public var profileToken: String

    public init(profileToken: String) {
        self.profileToken = profileToken
    }
}

public struct ItvCardDetails: Codable {
    /// The payment card type (Visa/Mastercard/etc).
    public var cardType: String
    /// The last 4 digit of card number.
    public var last4: String
    /// Expiry date month.
    public var expMonth: Int
    /// Expiry date year.
    public var expYear: Int

    public init(cardType: String, last4: String, expMonth: Int, expYear: Int) {
        self.cardType = cardType
        self.last4 = last4
        self.expMonth = expMonth
        self.expYear = expYear
    }

    private enum CodingKeys: String, CodingKey {
        case cardType = "card_type"
        case last4
        case expMonth = "exp_month"
        case expYear = "exp_year"
    }
}

public struct ItvChangeCardDetailsRequest: Codable {
    /// The ITV profile token.
    public var profileToken: String
    /// The credit card token.
    public var cardToken: String

    public init(profileToken: String, cardToken: String) {
        self.profileToken = profileToken
        self.cardToken = cardToken
    }
}

public struct ItvChangeEmailRequest: Codable {
    /// New email address for account/profile.
    public var email: String
    /// The ITV profile token.
    public var profileToken: String

    public init(email: String, profileToken: String) {
        self.email = email
        self.profileToken = profileToken
    }
}

public struct ItvChangeMarketingRequest: Codable {
    /// Updated marketing preferences for account/profile.
    public var isEmailOptIn: Bool
    /// The ITV profile token.
    public var profileToken: String

    public init(isEmailOptIn: Bool, profileToken: String) {
        self.isEmailOptIn = isEmailOptIn
        self.profileToken = profileToken
    }

    private enum CodingKeys: String, CodingKey {
        case isEmailOptIn = "emailOptIn"
        case profileToken
    }
}

public struct ItvCurrentSubscription: Codable {
    /// The description of payment collection method.
    public var collectionMethod: String
    /// The cancellation period end flag.
    public var isCancelAtPeriodEnd: Bool
    /// The creation timestamp.
    public var created: Int
    /// The end of period timestamp.
    public var currentPeriodEnd: Int
    /// The start of period timestamp.
    public var currentPeriodStart: Int
    /// The plan used during subsribing.
    public var plan: [String: AnyJSON]
    /// The status of subscription.
    public var status: String

    public init(collectionMethod: String, isCancelAtPeriodEnd: Bool, created: Int, currentPeriodEnd: Int, currentPeriodStart: Int, plan: [String: AnyJSON], status: String) {
        self.collectionMethod = collectionMethod
        self.isCancelAtPeriodEnd = isCancelAtPeriodEnd
        self.created = created
        self.currentPeriodEnd = currentPeriodEnd
        self.currentPeriodStart = currentPeriodStart
        self.plan = plan
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case collectionMethod
        case isCancelAtPeriodEnd = "cancelAtPeriodEnd"
        case created
        case currentPeriodEnd
        case currentPeriodStart
        case plan
        case status
    }
}

public struct ItvDeleteAccountRequest: Codable {
    /// The ITV profile token.
    public var profileToken: String

    public init(profileToken: String) {
        self.profileToken = profileToken
    }
}

public struct ItvEntitlement: Codable {
    /// Start of subscription.
    public var cardType: Date?
    /// Expiry of subscription.
    public var expiry: Date
    /// Source platform of purchase.
    public var source: String
    /// Id of subscription.
    public var subscriptionID: String
    /// Purchased plan data.
    public var plan: [String: AnyJSON]

    public init(cardType: Date? = nil, expiry: Date, source: String, subscriptionID: String, plan: [String: AnyJSON]) {
        self.cardType = cardType
        self.expiry = expiry
        self.source = source
        self.subscriptionID = subscriptionID
        self.plan = plan
    }

    private enum CodingKeys: String, CodingKey {
        case cardType = "card_type"
        case expiry
        case source
        case subscriptionID = "subscriptionId"
        case plan
    }
}

public struct ItvEntitlementCancelation: Codable {
    /// Itv internal id.
    public var itvID: String
    /// Source platform of cancelation.
    public var source: String
    /// Cancelation datetime.
    public var cancelledAt: Date
    /// Id of subscription.
    public var subscriptionID: String

    public init(itvID: String, source: String, cancelledAt: Date, subscriptionID: String) {
        self.itvID = itvID
        self.source = source
        self.cancelledAt = cancelledAt
        self.subscriptionID = subscriptionID
    }

    private enum CodingKeys: String, CodingKey {
        case itvID = "itvId"
        case source
        case cancelledAt = "cancelled_at"
        case subscriptionID = "subscriptionId"
    }
}

public struct ItvEntitlementCurrent: Codable {
    /// One of â€œitunesâ€, â€œstripeâ€, â€œamazonâ€, â€œgoogleâ€
    public var source: String

    public init(source: String) {
        self.source = source
    }
}

public struct ItvEntitlementPlan: Codable {
    /// Type of the plan.
    public var type: String
    /// The type of billing period used.
    public var interval: Interval
    /// Source platform of purchase.
    public var cost: Int
    /// Given the `interval` this is how frequently it will run. e.g. every 2 weeks.
    public var trialLength: Int

    /// The type of billing period used.
    public enum Interval: String, Codable, CaseIterable {
        case day
        case week
        case month
        case year
        case `none`
    }

    public init(type: String, interval: Interval, cost: Int, trialLength: Int) {
        self.type = type
        self.interval = interval
        self.cost = cost
        self.trialLength = trialLength
    }
}

public struct ItvEntitlementsHistory: Codable {
    /// The results of availability checks.
    public var entitlements: [ItvEntitlement]
    /// The results of availability checks.
    public var cancellations: [ItvEntitlementCancelation]

    public init(entitlements: [ItvEntitlement], cancellations: [ItvEntitlementCancelation]) {
        self.entitlements = entitlements
        self.cancellations = cancellations
    }
}

public struct ItvFeatureFlag: Codable {
    /// Is the feature enabled?
    public var isEnabled: Bool
    /// Feature flag data.
    public var flag: String?

    public init(isEnabled: Bool, flag: String? = nil) {
        self.isEnabled = isEnabled
        self.flag = flag
    }

    private enum CodingKeys: String, CodingKey {
        case isEnabled = "enabled"
        case flag
    }
}

public struct ItvGetCardDetailsRequest: Codable {
    /// The ITV profile token.
    public var profileToken: String

    public init(profileToken: String) {
        self.profileToken = profileToken
    }
}

public struct ItvGetDiscountResponse: Codable {
    /// The if of a discount for a user.
    public var id: String
    /// Discount nickname.
    public var nickname: String?
    /// Long description
    public var longDescription: String?
    /// Short description
    public var shortDescription: String?
    /// Headline
    public var headline: String?
    /// Description
    public var description: String?
    /// Payment currency.
    public var currency: String?
    /// How long the descount will be valid for.
    public var offerdurationperiod: String?
    /// The initial cost.
    public var initialCost: Double?

    public init(id: String, nickname: String? = nil, longDescription: String? = nil, shortDescription: String? = nil, headline: String? = nil, description: String? = nil, currency: String? = nil, offerdurationperiod: String? = nil, initialCost: Double? = nil) {
        self.id = id
        self.nickname = nickname
        self.longDescription = longDescription
        self.shortDescription = shortDescription
        self.headline = headline
        self.description = description
        self.currency = currency
        self.offerdurationperiod = offerdurationperiod
        self.initialCost = initialCost
    }
}

public struct ItvGooglePaySubscriptionRequest: Codable {
    /// The unique identifier for this purchase
    public var purchaseToken: String
    /// The SKU of the item from the play console
    public var subscriptionItem: String

    public init(purchaseToken: String, subscriptionItem: String) {
        self.purchaseToken = purchaseToken
        self.subscriptionItem = subscriptionItem
    }
}

public struct ItvHadEntitlement: Codable {
    /// Whether the user has been previously entitlement
    public var hasHadEntitlements: Bool

    public init(hasHadEntitlements: Bool) {
        self.hasHadEntitlements = hasHadEntitlements
    }
}

public struct ItvPinAuthRequest: Codable {
    /// The 4-digit parental control pin.
    public var pin: String
    /// The scope(s) of the token(s) required.
    public var scopes: [Scope]?
    /// If you specify a cookie type then a content filter cookie will be returned
    /// along with the token(s). This is only intended for web based clients which
    /// need to pass the cookies to a server to render a page based on the user's
    /// content filters e.g subscription code.
    /// 
    /// If type `Session` the cookie will be session based.
    /// If type `Persistent` the cookie will have a medium term lifespan.
    /// If undefined no cookies will be set.
    public var cookieType: CookieType?

    public enum Scope: String, Codable, CaseIterable {
        case catalog = "Catalog"
        case commerce = "Commerce"
        case settings = "Settings"
        case playback = "Playback"
    }

    /// If you specify a cookie type then a content filter cookie will be returned
    /// along with the token(s). This is only intended for web based clients which
    /// need to pass the cookies to a server to render a page based on the user's
    /// content filters e.g subscription code.
    /// 
    /// If type `Session` the cookie will be session based.
    /// If type `Persistent` the cookie will have a medium term lifespan.
    /// If undefined no cookies will be set.
    public enum CookieType: String, Codable, CaseIterable {
        case session = "Session"
        case persistent = "Persistent"
    }

    public init(pin: String, scopes: [Scope]? = nil, cookieType: CookieType? = nil) {
        self.pin = pin
        self.scopes = scopes
        self.cookieType = cookieType
    }
}

public struct ItvPlanListItem: Codable {
    /// The identifier of a plan.
    public var id: String
    /// The title of a plan.
    public var nickname: String
    /// The price of a plan. If a free plan then undefined.
    public var amount: Double
    /// The currency a plan is offered in.
    public var currency: String
    /// The type of billing period used.
    public var interval: Interval
    /// Given the `interval` this is how frequently it will run. e.g. every 2 weeks.
    public var intervalCount: Int
    /// How many days a trial period runs for a plan. Only valid if `hasTrialPeriod` is true.
    public var trialPeriodDays: Int?
    /// The product description.
    public var product: String
    /// The textual description.
    public var description: String
    /// The text to switch for.
    public var switchingText: String?
    /// The saving label.
    public var savingLabel: String?

    /// The type of billing period used.
    public enum Interval: String, Codable, CaseIterable {
        case day
        case week
        case month
        case year
        case `none`
    }

    public init(id: String, nickname: String, amount: Double, currency: String, interval: Interval, intervalCount: Int, trialPeriodDays: Int? = nil, product: String, description: String, switchingText: String? = nil, savingLabel: String? = nil) {
        self.id = id
        self.nickname = nickname
        self.amount = amount
        self.currency = currency
        self.interval = interval
        self.intervalCount = intervalCount
        self.trialPeriodDays = trialPeriodDays
        self.product = product
        self.description = description
        self.switchingText = switchingText
        self.savingLabel = savingLabel
    }
}

public struct ItvPlans: Codable {
    /// The list of available plans.
    public var plans: [ItvPlanListItem]

    public init(plans: [ItvPlanListItem]) {
        self.plans = plans
    }
}

public struct ItvProfileToken: Codable {
    /// The ITV profile token.
    public var profileToken: String

    public init(profileToken: String) {
        self.profileToken = profileToken
    }
}

public struct ItvProfileTokenRequest: Codable {
    /// The password.
    public var password: String

    public init(password: String) {
        self.password = password
    }
}

public struct ItvPurchase: Codable {
    /// The identifier of subscription plan.
    public var planID: String
    /// The identifier of subscription in payment system.
    public var subscriptionID: String?
    /// The identifier of user in payment system.
    public var customerID: String?

    public init(planID: String, subscriptionID: String? = nil, customerID: String? = nil) {
        self.planID = planID
        self.subscriptionID = subscriptionID
        self.customerID = customerID
    }

    private enum CodingKeys: String, CodingKey {
        case planID = "planId"
        case subscriptionID = "subscriptionId"
        case customerID = "customerId"
    }
}

public struct ItvPurchaseRequest: Codable {
    /// The identifier of the plan to purchase.
    public var planID: String
    /// The ITV profile token.
    public var profileToken: String
    /// The credit card token.
    public var cardToken: String
    /// A coupon/voucher for a discount.
    public var voucher: String?

    public init(planID: String, profileToken: String, cardToken: String, voucher: String? = nil) {
        self.planID = planID
        self.profileToken = profileToken
        self.cardToken = cardToken
        self.voucher = voucher
    }

    private enum CodingKeys: String, CodingKey {
        case planID = "planId"
        case profileToken
        case cardToken
        case voucher
    }
}

public struct ItvPurchaseStrongRequest: Codable {
    /// The identifier of the plan to purchase.
    public var planID: String
    /// The ITV profile token.
    public var profileToken: String
    /// A paymentMethodId from Stripe.
    public var paymentMethodID: String?
    /// A coupon/voucher for a discount.
    public var voucher: String?
    /// A paymentMethodFromToken.
    public var paymentMethodFromToken: String?

    public init(planID: String, profileToken: String, paymentMethodID: String? = nil, voucher: String? = nil, paymentMethodFromToken: String? = nil) {
        self.planID = planID
        self.profileToken = profileToken
        self.paymentMethodID = paymentMethodID
        self.voucher = voucher
        self.paymentMethodFromToken = paymentMethodFromToken
    }

    private enum CodingKeys: String, CodingKey {
        case planID = "planId"
        case profileToken
        case paymentMethodID = "paymentMethodId"
        case voucher
        case paymentMethodFromToken
    }
}

public struct ItvPurchaseStrongResponse: Codable {
    /// The identifier of subscription plan.
    public var planID: String?
    /// The identifier of subscription in payment system.
    public var subscriptionID: String?
    /// The identifier of user in payment system.
    public var customerID: String?
    /// IntentId.
    public var intentID: String?
    /// IntentType.
    public var intentType: String?
    /// ClientSecret.
    public var clientSecret: String?
    /// Status.
    public var status: String?

    public init(planID: String? = nil, subscriptionID: String? = nil, customerID: String? = nil, intentID: String? = nil, intentType: String? = nil, clientSecret: String? = nil, status: String? = nil) {
        self.planID = planID
        self.subscriptionID = subscriptionID
        self.customerID = customerID
        self.intentID = intentID
        self.intentType = intentType
        self.clientSecret = clientSecret
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case planID = "planId"
        case subscriptionID = "subscriptionId"
        case customerID = "customerId"
        case intentID = "intentId"
        case intentType
        case clientSecret
        case status
    }
}

public struct ItvPurchaseWithOfferRequest: Codable {
    /// The identifier of the plan to purchase.
    public var planID: String
    /// The ITV profile token.
    public var profileToken: String
    /// A paymentMethodId from Stripe.
    public var paymentMethodID: String?
    /// A coupon/voucher for a discount. Can be retrieved from GET itv/voucher/{platform} endpoint
    public var couponID: String
    /// A paymentMethodFromToken.
    public var paymentMethodFromToken: String?

    public init(planID: String, profileToken: String, paymentMethodID: String? = nil, couponID: String, paymentMethodFromToken: String? = nil) {
        self.planID = planID
        self.profileToken = profileToken
        self.paymentMethodID = paymentMethodID
        self.couponID = couponID
        self.paymentMethodFromToken = paymentMethodFromToken
    }

    private enum CodingKeys: String, CodingKey {
        case planID = "planId"
        case profileToken
        case paymentMethodID = "paymentMethodId"
        case couponID = "couponId"
        case paymentMethodFromToken
    }
}

public struct ItvPurchaseWithOfferResponse: Codable {
    /// The identifier of subscription in payment system.
    public var subscriptionID: String?
    /// The identifier of user in payment system.
    public var customerID: String?
    /// IntentId.
    public var intentID: String?
    /// IntentType.
    public var intentType: String?
    /// ClientSecret.
    public var clientSecret: String?
    /// Status.
    public var status: String?
    /// Payment Method ID
    public var paymentMethodID: String?

    public init(subscriptionID: String? = nil, customerID: String? = nil, intentID: String? = nil, intentType: String? = nil, clientSecret: String? = nil, status: String? = nil, paymentMethodID: String? = nil) {
        self.subscriptionID = subscriptionID
        self.customerID = customerID
        self.intentID = intentID
        self.intentType = intentType
        self.clientSecret = clientSecret
        self.status = status
        self.paymentMethodID = paymentMethodID
    }

    private enum CodingKeys: String, CodingKey {
        case subscriptionID = "subscriptionId"
        case customerID = "customerId"
        case intentID = "intentId"
        case intentType
        case clientSecret
        case status
        case paymentMethodID = "paymentMethodId"
    }
}

/// Recommendation config.
public struct ItvRecsConfig: Codable {
    /// The segment of the recommendation
    public var segment: String
    /// Recommendation ID
    public var recID: String

    public init(segment: String, recID: String) {
        self.segment = segment
        self.recID = recID
    }

    private enum CodingKeys: String, CodingKey {
        case segment
        case recID = "rec_id"
    }
}

/// A list of recommendation configs.
public struct ItvRecsConfigList: Codable {
    /// The default recommendation id for fallback purpose
    public var `default`: String
    /// A list of segmentation tags and recommendation IDs
    public var mappings: [ItvRecsConfig]

    public init(`default`: String, mappings: [ItvRecsConfig]) {
        self.default = `default`
        self.mappings = mappings
    }

    private enum CodingKeys: String, CodingKey {
        case `default` = "default"
        case mappings
    }
}

public struct ItvRokuTransactionRequest: Codable {
    /// The ITV profile token.
    public var profileToken: String

    public init(profileToken: String) {
        self.profileToken = profileToken
    }
}

public struct ItvSubscriptionFullPriceRenewal: Codable {
    /// Full price renewal state.
    public var isFullPriceRenewal: Bool
    /// Reason of full price renewal state.
    public var reason: String

    public init(isFullPriceRenewal: Bool, reason: String) {
        self.isFullPriceRenewal = isFullPriceRenewal
        self.reason = reason
    }

    private enum CodingKeys: String, CodingKey {
        case isFullPriceRenewal = "fullPriceRenewal"
        case reason
    }
}

public struct ItvSubscriptionState: Codable {
    /// The results of availability checks.
    public var failedAvailabilityChecks: [String]
    /// The array of entitlement objects.
    public var effectiveEntitlements: [ItvEntitlement]
    /// The payment provider (stripe/itunes)
    public var source: String
    /// The array of entitlement names.
    public var purchased: [String]

    public init(failedAvailabilityChecks: [String], effectiveEntitlements: [ItvEntitlement], source: String, purchased: [String]) {
        self.failedAvailabilityChecks = failedAvailabilityChecks
        self.effectiveEntitlements = effectiveEntitlements
        self.source = source
        self.purchased = purchased
    }

    private enum CodingKeys: String, CodingKey {
        case failedAvailabilityChecks = "failed_availability_checks"
        case effectiveEntitlements = "effective_entitlements"
        case source
        case purchased
    }
}

public struct ItvSubscriptionStatusResponse: Codable {
    /// Defines whether last payment intent was successful or not.
    public var isActive: Bool

    public init(isActive: Bool) {
        self.isActive = isActive
    }

    private enum CodingKeys: String, CodingKey {
        case isActive = "is_active"
    }
}

public struct ItvUpdateIntentStrongRequest: Codable {
    /// The ITV profile token.
    public var profileToken: String
    /// The paymentMethodId from Stripe.
    public var paymentMethodID: String?
    /// A paymentMethodFromToken.
    public var paymentMethodFromToken: String?

    public init(profileToken: String, paymentMethodID: String? = nil, paymentMethodFromToken: String? = nil) {
        self.profileToken = profileToken
        self.paymentMethodID = paymentMethodID
        self.paymentMethodFromToken = paymentMethodFromToken
    }

    private enum CodingKeys: String, CodingKey {
        case profileToken
        case paymentMethodID = "paymentMethodId"
        case paymentMethodFromToken
    }
}

public struct ItvUpdateIntentStrongResponse: Codable {
    /// IntentId.
    public var intentID: String?
    /// IntentType.
    public var intentType: String?
    /// ClientSecret.
    public var clientSecret: String?
    /// Status.
    public var status: String?

    public init(intentID: String? = nil, intentType: String? = nil, clientSecret: String? = nil, status: String? = nil) {
        self.intentID = intentID
        self.intentType = intentType
        self.clientSecret = clientSecret
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case intentID = "intentId"
        case intentType
        case clientSecret
        case status
    }
}

public struct ItvUpdatePaymentStrongRequest: Codable {
    /// The ITV profile token.
    public var profileToken: String
    /// The paymentMethodId from Stripe.
    public var paymentMethodID: String?
    /// A paymentMethodFromToken.
    public var paymentMethodFromToken: String?

    public init(profileToken: String, paymentMethodID: String? = nil, paymentMethodFromToken: String? = nil) {
        self.profileToken = profileToken
        self.paymentMethodID = paymentMethodID
        self.paymentMethodFromToken = paymentMethodFromToken
    }

    private enum CodingKeys: String, CodingKey {
        case profileToken
        case paymentMethodID = "paymentMethodId"
        case paymentMethodFromToken
    }
}

public struct ItvUpdateProfileRequest: Codable {
    /// The ITV profile token.
    public var profileToken: String
    /// The email address.
    public var email: String?
    /// The postal code.
    public var postcode: String?
    /// The date of birth.
    public var dateOfBirth: String?
    /// First name.
    public var lastName: String?
    /// Last name.
    public var firstName: String?
    /// The title.
    public var title: String?

    public init(profileToken: String, email: String? = nil, postcode: String? = nil, dateOfBirth: String? = nil, lastName: String? = nil, firstName: String? = nil, title: String? = nil) {
        self.profileToken = profileToken
        self.email = email
        self.postcode = postcode
        self.dateOfBirth = dateOfBirth
        self.lastName = lastName
        self.firstName = firstName
        self.title = title
    }
}

public struct ItvUpgradePlanRequest: Codable {
    /// The identifier of the plan to purchase.
    public var planID: String

    public init(planID: String) {
        self.planID = planID
    }

    private enum CodingKeys: String, CodingKey {
        case planID = "planId"
    }
}

public struct ItvVoucher: Codable {
    /// The coupon/voucher.
    public var id: String
    /// The voucher offer type.
    public var offerType: OfferType
    public var display: ItvVoucherDisplay
    public var links: ItvVoucherLinks

    /// The voucher offer type.
    public enum OfferType: String, Codable, CaseIterable {
        case stripe
        case talonOne = "talon one"
    }

    public init(id: String, offerType: OfferType, display: ItvVoucherDisplay, links: ItvVoucherLinks) {
        self.id = id
        self.offerType = offerType
        self.display = display
        self.links = links
    }
}

public struct ItvVoucherDisplay: Codable {
    /// Discount price.
    public var discountPrice: String?
    /// Short description.
    public var shortDescription: String?
    /// Long description.
    public var longDescription: String?
    /// Headline label.
    public var headlineLabel: String?
    /// Percent off.
    public var percentOff: Double?
    /// Currency.
    public var currency: String?
    /// Duration.
    public var duration: String?
    /// Duration in months.
    public var durationInMonths: Double?
    /// InitialCost.
    public var initialCost: Double?
    /// SavingLabel.
    public var savingLabel: String?

    public init(discountPrice: String? = nil, shortDescription: String? = nil, longDescription: String? = nil, headlineLabel: String? = nil, percentOff: Double? = nil, currency: String? = nil, duration: String? = nil, durationInMonths: Double? = nil, initialCost: Double? = nil, savingLabel: String? = nil) {
        self.discountPrice = discountPrice
        self.shortDescription = shortDescription
        self.longDescription = longDescription
        self.headlineLabel = headlineLabel
        self.percentOff = percentOff
        self.currency = currency
        self.duration = duration
        self.durationInMonths = durationInMonths
        self.initialCost = initialCost
        self.savingLabel = savingLabel
    }
}

public struct ItvVoucherLinks: Codable {
    public var this: ItvVoucherLinksHref
    public var redeem: ItvVoucherLinksHref

    public init(this: ItvVoucherLinksHref, redeem: ItvVoucherLinksHref) {
        self.this = this
        self.redeem = redeem
    }

    private enum CodingKeys: String, CodingKey {
        case this = "self"
        case redeem
    }
}

public struct ItvVoucherLinksHref: Codable {
    /// The voucher link.
    public var href: String

    public init(href: String) {
        self.href = href
    }
}

public struct ItvVoucherRequest: Codable {
    /// The voucher.
    public var voucher: String

    public init(voucher: String) {
        self.voucher = voucher
    }
}

public struct Language: Codable {
    /// The ISO language code of the language e.g. "en-US".
    /// See https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes
    public var code: String
    /// Display label for the language.
    public var label: String
    /// Display title for the language.
    public var title: String

    public init(code: String, label: String, title: String) {
        self.code = code
        self.label = label
        self.title = title
    }
}

/// Extra data to accompany ItemList content. The (single) key in the object is
/// the list name and the data changes depending on the list
public struct ListData: Codable {
    /// List data for ContinueWatching List
    public var continueWatching: ContinueWatchingListData?

    public init(continueWatching: ContinueWatchingListData? = nil) {
        self.continueWatching = continueWatching
    }

    private enum CodingKeys: String, CodingKey {
        case continueWatching = "ContinueWatching"
    }
}

public struct MediaFile: Codable {
    /// The name of the media file.
    public var name: String
    /// The way in which the media file is delivered.
    public var deliveryType: DeliveryType
    /// The url to access the media file.
    public var url: URL
    /// The type of drm used to encrypt the media. 'None' if unencrypted.
    public var drm: String
    /// The format the media was encoded in.
    public var format: String
    /// The resolution of the video media.
    public var resolution: Resolution
    /// The width of the video media.
    public var width: Int
    /// The height of the video media.
    public var height: Int
    /// The number of audio channels.
    public var channels: Int?
    /// The language code for the media, e.g. 'en'.
    public var language: String

    /// The way in which the media file is delivered.
    public enum DeliveryType: String, Codable, CaseIterable {
        case stream = "Stream"
        case progressive = "Progressive"
        case download = "Download"
    }

    /// The resolution of the video media.
    public enum Resolution: String, Codable, CaseIterable {
        case sd = "SD"
        case hd720 = "HD-720"
        case hd1080 = "HD-1080"
        case hd4k = "HD-4K"
        case external = "External"
        case unknown = "Unknown"
    }

    public init(name: String, deliveryType: DeliveryType, url: URL, drm: String, format: String, resolution: Resolution, width: Int, height: Int, channels: Int? = nil, language: String) {
        self.name = name
        self.deliveryType = deliveryType
        self.url = url
        self.drm = drm
        self.format = format
        self.resolution = resolution
        self.width = width
        self.height = height
        self.channels = channels
        self.language = language
    }
}

public struct NavContent: Codable {
    /// The title of the embedded navigation content.
    public var title: String?
    /// A pageable list of items.
    public var list: ItemList?
    /// The image type to target when rendering items of the list.
    /// 
    /// e.g wallpaper, poster, hero3x1, logo.
    public var imageType: String?

    public init(title: String? = nil, list: ItemList? = nil, imageType: String? = nil) {
        self.title = title
        self.list = list
        self.imageType = imageType
    }
}

public struct NavEntry: Codable {
    /// The depth of the NavEntry (top level is 0)
    public var depth: Int
    /// The text label for this nav entry.
    public var label: String?
    /// The icon for this nav entry.
    public var icon: String?
    /// The path this nav entry links to.
    /// May be undefined if the nav entry is not clickable e.g. a nav heading.
    /// If the value begins with `http` then it's an external url.
    public var path: String?
    public var content: NavContent?
    /// Child nav entries.
    public var children: [NavEntry]?
    /// True if this is a featured menu item.
    /// 
    /// Featured menu items may have a more prominent presentation than others in the navigation.
    public var isFeatured: Bool?
    /// A map of custom fields defined by a curator for a nav entry.
    public var customFields: [String: AnyJSON]?

    public init(depth: Int, label: String? = nil, icon: String? = nil, path: String? = nil, content: NavContent? = nil, children: [NavEntry]? = nil, isFeatured: Bool? = nil, customFields: [String: AnyJSON]? = nil) {
        self.depth = depth
        self.label = label
        self.icon = icon
        self.path = path
        self.content = content
        self.children = children
        self.isFeatured = isFeatured
        self.customFields = customFields
    }

    private enum CodingKeys: String, CodingKey {
        case depth
        case label
        case icon
        case path
        case content
        case children
        case isFeatured = "featured"
        case customFields
    }
}

public struct Navigation: Codable {
    /// The header navigation.
    public var header: [NavEntry]
    public var mobile: NavEntry?
    public var footer: NavEntry?
    public var account: NavEntry?
    /// Copyright information.
    public var copyright: String?
    /// A map of custom fields defined by a curator for navigation.
    public var customFields: [String: AnyJSON]?

    public init(header: [NavEntry], mobile: NavEntry? = nil, footer: NavEntry? = nil, account: NavEntry? = nil, copyright: String? = nil, customFields: [String: AnyJSON]? = nil) {
        self.header = header
        self.mobile = mobile
        self.footer = footer
        self.account = account
        self.copyright = copyright
        self.customFields = customFields
    }
}

public struct NextPlaybackItem: Codable {
    /// The id of the item used to determine the next item to play.
    public var sourceItemID: String
    /// Time when the item corresponding to the itemId passed in by the client was
    /// first watched by the user. Will be `undefined` if the user has never
    /// watched the item.
    /// 
    /// It can be used to identify the scenario where the user has never watched a
    /// show and we are suggesting they watch the first episode (i.e. it is
    /// missing in this scenario)
    /// 
    /// **This will only be populated when a `showId` is passed in**
    public var firstWatchedDate: Date?
    /// Time when the item corresponding to the itemId passed in by the client was
    /// last watched by the user. Will be `undefined` if the user has never
    /// watched the item.
    /// 
    /// It can be used to identify the scenario where the user has never watched a
    /// show and we are suggesting they watch the first episode (i.e. it is
    /// missing in this scenario)
    /// 
    /// **This will only be populated when a `showId` is passed in**
    public var lastWatchedDate: Date?
    /// Field indicating the type or reason behind the suggestion.
    /// 
    /// Id Type   | Show Watched Status| Value            | Description
    /// ----------|--------------------|------------------|---------------------------------
    /// showId    | Unwatched          | StartWatching    |
    /// showId    | Completely watched | RestartWatching  |
    /// showId    | Partly watched     | ContinueWatching | Suggested episode partly watched
    /// showId    | Partly watched     | Sequential       | Suggested episode unwatched
    /// episodeId | Any                | Sequential       | Next episode in show
    public var suggestionType: SuggestionType?
    public var next: ItemDetail?

    /// Field indicating the type or reason behind the suggestion.
    /// 
    /// Id Type   | Show Watched Status| Value            | Description
    /// ----------|--------------------|------------------|---------------------------------
    /// showId    | Unwatched          | StartWatching    |
    /// showId    | Completely watched | RestartWatching  |
    /// showId    | Partly watched     | ContinueWatching | Suggested episode partly watched
    /// showId    | Partly watched     | Sequential       | Suggested episode unwatched
    /// episodeId | Any                | Sequential       | Next episode in show
    public enum SuggestionType: String, Codable, CaseIterable {
        case startWatching = "StartWatching"
        case continueWatching = "ContinueWatching"
        case restartWatching = "RestartWatching"
        case sequential = "Sequential"
        case `none` = "None"
    }

    public init(sourceItemID: String, firstWatchedDate: Date? = nil, lastWatchedDate: Date? = nil, suggestionType: SuggestionType? = nil, next: ItemDetail? = nil) {
        self.sourceItemID = sourceItemID
        self.firstWatchedDate = firstWatchedDate
        self.lastWatchedDate = lastWatchedDate
        self.suggestionType = suggestionType
        self.next = next
    }

    private enum CodingKeys: String, CodingKey {
        case sourceItemID = "sourceItemId"
        case firstWatchedDate
        case lastWatchedDate
        case suggestionType
        case next
    }
}

public struct Offer: Codable {
    /// The base type for both Offer and Entitlement.
    public var offerRights: OfferRights
    public var id: String?
    public var name: String?
    public var price: Double
    public var startDate: Date?
    public var endDate: Date?
    public var availability: Availability
    /// The code of the subscription this offer is offered under, if any.
    public var subscriptionCode: String?
    /// A map of custom fields defined by a curator for an offer.
    public var customFields: [String: AnyJSON]?

    public enum Availability: String, Codable, CaseIterable {
        case available = "Available"
        case comingSoon = "ComingSoon"
    }

    public init(offerRights: OfferRights, id: String? = nil, name: String? = nil, price: Double, startDate: Date? = nil, endDate: Date? = nil, availability: Availability, subscriptionCode: String? = nil, customFields: [String: AnyJSON]? = nil) {
        self.offerRights = offerRights
        self.id = id
        self.name = name
        self.price = price
        self.startDate = startDate
        self.endDate = endDate
        self.availability = availability
        self.subscriptionCode = subscriptionCode
        self.customFields = customFields
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.offerRights = try OfferRights(from: decoder)
        self.id = try values.decodeIfPresent(String.self, forKey: "id")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.price = try values.decode(Double.self, forKey: "price")
        self.startDate = try values.decodeIfPresent(Date.self, forKey: "startDate")
        self.endDate = try values.decodeIfPresent(Date.self, forKey: "endDate")
        self.availability = try Availability(from: decoder)
        self.subscriptionCode = try values.decodeIfPresent(String.self, forKey: "subscriptionCode")
        self.customFields = try values.decodeIfPresent([String: AnyJSON].self, forKey: "customFields")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(offerRights, forKey: "offerRights")
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encode(price, forKey: "price")
        try values.encodeIfPresent(startDate, forKey: "startDate")
        try values.encodeIfPresent(endDate, forKey: "endDate")
        try values.encode(availability, forKey: "availability")
        try values.encodeIfPresent(subscriptionCode, forKey: "subscriptionCode")
        try values.encodeIfPresent(customFields, forKey: "customFields")
    }
}

/// The base type for both Offer and Entitlement.
public struct OfferRights: Codable {
    public var deliveryType: DeliveryType
    public var scopes: [String]
    public var resolution: Resolution
    public var ownership: Ownership
    /// The maximum number of allowed plays.
    public var maxPlays: Int?
    /// The maximum number of allowed downloads.
    public var maxDownloads: Int?
    /// The length of time in minutes which the rental will last once purchased.
    public var rentalPeriod: Int?
    /// The length of time in minutes which the rental will last once played for the first time.
    public var playPeriod: Int?
    /// Any specific playback exclusion rules.
    public var exclusionRules: [ExclusionRule]?

    public enum DeliveryType: String, Codable, CaseIterable {
        case stream = "Stream"
        case download = "Download"
        case streamOrDownload = "StreamOrDownload"
        case progressiveDownload = "ProgressiveDownload"
        case `none` = "None"
    }

    public enum Resolution: String, Codable, CaseIterable {
        case sd = "SD"
        case hd720 = "HD-720"
        case hd1080 = "HD-1080"
        case hd4k = "HD-4K"
        case external = "External"
        case unknown = "Unknown"
    }

    public enum Ownership: String, Codable, CaseIterable {
        case subscription = "Subscription"
        case free = "Free"
        case rent = "Rent"
        case own = "Own"
        case `none` = "None"
    }

    public init(deliveryType: DeliveryType, scopes: [String], resolution: Resolution, ownership: Ownership, maxPlays: Int? = nil, maxDownloads: Int? = nil, rentalPeriod: Int? = nil, playPeriod: Int? = nil, exclusionRules: [ExclusionRule]? = nil) {
        self.deliveryType = deliveryType
        self.scopes = scopes
        self.resolution = resolution
        self.ownership = ownership
        self.maxPlays = maxPlays
        self.maxDownloads = maxDownloads
        self.rentalPeriod = rentalPeriod
        self.playPeriod = playPeriod
        self.exclusionRules = exclusionRules
    }
}

public struct Page: Codable {
    public var pageSummary: PageSummary
    /// Metadata associated with a page. Primarily intended for SEO usage.
    public var metadata: PageMetadata?
    /// Entries of a page
    public var entries: [PageEntry]
    /// A map of custom fields defined by a curator for a page.
    public var customFields: [String: AnyJSON]?
    public var item: ItemDetail?
    /// A pageable list of items.
    public var list: ItemList?
    public var themes: [Theme]?

    public init(pageSummary: PageSummary, metadata: PageMetadata? = nil, entries: [PageEntry], customFields: [String: AnyJSON]? = nil, item: ItemDetail? = nil, list: ItemList? = nil, themes: [Theme]? = nil) {
        self.pageSummary = pageSummary
        self.metadata = metadata
        self.entries = entries
        self.customFields = customFields
        self.item = item
        self.list = list
        self.themes = themes
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.pageSummary = try PageSummary(from: decoder)
        self.metadata = try PageMetadata(from: decoder)
        self.entries = try values.decode([PageEntry].self, forKey: "entries")
        self.customFields = try values.decodeIfPresent([String: AnyJSON].self, forKey: "customFields")
        self.item = try ItemDetail(from: decoder)
        self.list = try ItemList(from: decoder)
        self.themes = try values.decodeIfPresent([Theme].self, forKey: "themes")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(pageSummary, forKey: "pageSummary")
        try values.encodeIfPresent(metadata, forKey: "metadata")
        try values.encode(entries, forKey: "entries")
        try values.encodeIfPresent(customFields, forKey: "customFields")
        try values.encodeIfPresent(item, forKey: "item")
        try values.encodeIfPresent(list, forKey: "list")
        try values.encodeIfPresent(themes, forKey: "themes")
    }
}

/// Represents an entry of a Page.
/// Defines what specific piece of content should be presented e.g. an Item or ItemList.
/// Also defines what visual template should be used to render that content.
public struct PageEntry: Codable {
    /// The unique identifier for a page entry.
    public var id: String
    /// The type of PageEntry. Used to help identify what type of content will be presented.
    public var type: `Type`
    /// The name of the Page Entry.
    public var title: String
    /// Template type used to present the content of the PageEntry.
    public var template: String
    public var item: ItemSummary?
    /// A pageable list of items.
    public var list: ItemList?
    /// If 'type' is 'TextEntry' then this is the text to be represented.
    public var text: String?
    /// If 'type' is 'PeopleEntry' then this is the array of people to present.
    public var people: [Person]?
    /// A map of custom fields defined by a curator for a page entry.
    public var customFields: [String: AnyJSON]?
    /// The images for the page entry if any.
    /// 
    /// For example the images of an `ImageEntry`.
    public var images: [String: URL]?

    /// The type of PageEntry. Used to help identify what type of content will be presented.
    public enum `Type`: String, Codable, CaseIterable {
        case itemEntry = "ItemEntry"
        case itemDetailEntry = "ItemDetailEntry"
        case listEntry = "ListEntry"
        case listDetailEntry = "ListDetailEntry"
        case userEntry = "UserEntry"
        case textEntry = "TextEntry"
        case imageEntry = "ImageEntry"
        case customEntry = "CustomEntry"
        case peopleEntry = "PeopleEntry"
    }

    public init(id: String, type: `Type`, title: String, template: String, item: ItemSummary? = nil, list: ItemList? = nil, text: String? = nil, people: [Person]? = nil, customFields: [String: AnyJSON]? = nil, images: [String: URL]? = nil) {
        self.id = id
        self.type = type
        self.title = title
        self.template = template
        self.item = item
        self.list = list
        self.text = text
        self.people = people
        self.customFields = customFields
        self.images = images
    }
}

/// Metadata associated with a page. Primarily intended for SEO usage.
public struct PageMetadata: Codable {
    public var description: String?
    public var keywords: [String]?
    public var segments: [String]?

    public init(description: String? = nil, keywords: [String]? = nil, segments: [String]? = nil) {
        self.description = description
        self.keywords = keywords
        self.segments = segments
    }
}

public struct PageSummary: Codable {
    /// Unique identifier for the page.
    public var id: String
    /// Title of the page.
    public var title: String
    /// Unique path for the page.
    public var path: String
    /// Key used to lookup a known page.
    public var key: String?
    /// Identifier for of the page template to render this page.
    public var template: String
    /// True if this page is static and doesn't have any dynamic content to load.
    /// 
    /// Static pages don't need to go back to the page endpoint to load page content
    /// instead the page summary loaded with the sitemap should be enough to determine
    /// the page template type and render based on this.
    public var isStatic: Bool
    /// True if this page is a system page type.
    /// 
    /// **DEPRECATED** This property doesn't have any real use in client applications
    /// anymore so shouldn't be used. It especially shouldn't be used to determine if
    /// a page is static or not. Use the `isStatic` property instead.
    public var isSystemPage: Bool

    public init(id: String, title: String, path: String, key: String? = nil, template: String, isStatic: Bool, isSystemPage: Bool) {
        self.id = id
        self.title = title
        self.path = path
        self.key = key
        self.template = template
        self.isStatic = isStatic
        self.isSystemPage = isSystemPage
    }
}

public struct Pagination: Codable {
    /// Path to load next page of data, or null if not available
    public var next: String?
    /// Path to load previous page of data, or null if not available.
    public var previous: String?
    /// The current page number.
    /// 
    /// A value of 0 indicates that the fist page has not yet been loaded. This is
    /// useful when wanting to return the paging metadata to indicate how to
    /// load in the first page.
    public var page: Int
    /// The current page size.
    /// 
    /// A value of -1 indicates that the size has not yet been determined. This may
    /// arise when embedding secure list pagination info in a page which must be cached
    /// by a CDN. For example a Bookmarks list.
    public var size: Int?
    /// The total number of pages available given the current page size.
    /// 
    /// A value of -1 indicates that the total has not yet been determined. This may
    /// arise when embedding secure list pagination info in a page which must be cached
    /// by a CDN. For example a Bookmarks list.
    public var total: Int
    public var authorization: PaginationAuth?
    public var options: PaginationOptions?

    public init(next: String? = nil, previous: String? = nil, page: Int, size: Int? = nil, total: Int, authorization: PaginationAuth? = nil, options: PaginationOptions? = nil) {
        self.next = next
        self.previous = previous
        self.page = page
        self.size = size
        self.total = total
        self.authorization = authorization
        self.options = options
    }
}

public struct PaginationAuth: Codable {
    /// The token type required to load the list.
    public var type: `Type`
    /// The token scope required.
    public var scope: Scope

    /// The token type required to load the list.
    public enum `Type`: String, Codable, CaseIterable {
        case userAccount = "UserAccount"
        case userProfile = "UserProfile"
    }

    /// The token scope required.
    public enum Scope: String, Codable, CaseIterable {
        case catalog = "Catalog"
        case commerce = "Commerce"
        case settings = "Settings"
    }

    public init(type: `Type`, scope: Scope) {
        self.type = type
        self.scope = scope
    }
}

public struct PaginationOptions: Codable {
    /// The number of items to return in a list page.
    public var pageSize: Int?
    /// The applied sort order if any.
    public var order: Order?
    /// The applied sort ordering property if any.
    public var orderBy: OrderBy?
    /// The maximum rating (inclusive) of items returned, e.g. 'AUOFLC-PG'.
    public var maxRating: String?
    /// Specific item type filter.
    public var itemType: ItemType?
    /// Items filtered by whether they've been fully watched or not.
    /// 
    /// Only available on the `/account/profile/watched/list` endpoint currently.
    public var isCompleted: Bool?

    /// The applied sort order if any.
    public enum Order: String, Codable, CaseIterable {
        case asc
        case desc
    }

    /// The applied sort ordering property if any.
    public enum OrderBy: String, Codable, CaseIterable {
        case aZ = "a-z"
        case releaseYear = "release-year"
        case dateAdded = "date-added"
    }

    /// Specific item type filter.
    public enum ItemType: String, Codable, CaseIterable {
        case movie
        case show
        case season
        case episode
        case program
        case link
        case trailer
        case channel
        case customAsset
    }

    public init(pageSize: Int? = nil, order: Order? = nil, orderBy: OrderBy? = nil, maxRating: String? = nil, itemType: ItemType? = nil, isCompleted: Bool? = nil) {
        self.pageSize = pageSize
        self.order = order
        self.orderBy = orderBy
        self.maxRating = maxRating
        self.itemType = itemType
        self.isCompleted = isCompleted
    }

    private enum CodingKeys: String, CodingKey {
        case pageSize
        case order
        case orderBy
        case maxRating
        case itemType
        case isCompleted = "completed"
    }
}

public struct PasswordResetEmailRequest: Codable {
    /// The email address of the primary account profile to reset the password for.
    public var email: String

    public init(email: String) {
        self.email = email
    }
}

public struct PasswordResetRequest: Codable {
    /// The ITV reset token.
    public var resetToken: String
    /// The new password for the account.
    public var password: String

    public init(resetToken: String, password: String) {
        self.resetToken = resetToken
        self.password = password
    }
}

public struct PaymentMethod: Codable {
    /// The unique identifier of a payment method.
    public var id: String
    /// A short description of a payment method.
    /// 
    /// If the payment method is of type `Wallet` this will be "My Wallet"
    /// 
    /// For `Card` type payment methods the format of this description may differ
    /// depending on the payment gateway in use. In the case of Stripe, this will
    /// be in the format "Visa (**** 4242, exp 08/19)"
    public var description: String
    /// The type of payment method.
    public var type: `Type`
    /// The brand of the card if the payment method is a card.
    public var brand: Brand?
    /// The balance of the wallet if the payment method is a wallet.
    public var balance: Double?
    /// The currency code of the wallet if the payment method is a wallet.
    public var currency: String?
    /// The expiry month of the card if the payment method is a card.
    public var expiryMonth: Double?
    /// The expiry year of the card if the payment method is a card.
    public var expiryYear: Double?
    /// The last digits of the card if the payment method is a card.
    /// Depending on the payment gateway in use this value may be undefined.
    public var lastDigits: Double?

    /// The type of payment method.
    public enum `Type`: String, Codable, CaseIterable {
        case card = "Card"
        case wallet = "Wallet"
    }

    /// The brand of the card if the payment method is a card.
    public enum Brand: String, Codable, CaseIterable {
        case visa = "Visa"
        case masterCard = "MasterCard"
        case americanExpress = "AmericanExpress"
        case other = "Other"
    }

    public init(id: String, description: String, type: `Type`, brand: Brand? = nil, balance: Double? = nil, currency: String? = nil, expiryMonth: Double? = nil, expiryYear: Double? = nil, lastDigits: Double? = nil) {
        self.id = id
        self.description = description
        self.type = type
        self.brand = brand
        self.balance = balance
        self.currency = currency
        self.expiryMonth = expiryMonth
        self.expiryYear = expiryYear
        self.lastDigits = lastDigits
    }
}

public struct Person: Codable {
    /// The name of the person.
    public var name: String
    /// The path to the person
    public var path: String

    public init(name: String, path: String) {
        self.name = name
        self.path = path
    }
}

public struct Plan: Codable {
    /// The identifier of a plan.
    public var id: String
    /// The title of a plan.
    public var title: String
    /// The short tagline for a plan.
    public var tagline: String
    /// The type of plan.
    public var type: `Type`
    /// True if a plan should be highlighted as featured, false if not.
    public var isFeatured: Bool
    /// True if a plan is active, false if its retired.
    public var isActive: Bool
    /// True if a plan should not be presented in the primary plan options, false if not.
    public var isPrivate: Bool
    /// The revenue type a plan targets.
    public var revenueType: RevenueType
    /// The subscription code a plan targets.
    public var subscriptionCode: String
    /// An alias for a plan.
    public var alias: String
    /// The list of benefits to display for a plan.
    public var benefits: [String]
    /// The type of billing period used.
    public var billingPeriodType: BillingPeriodType
    /// Given the `billingPeriodType` this is how frequently it will run. e.g. every 2 weeks.
    public var billingPeriodFrequency: Int
    /// True if a plan has a trial period, false if not.
    public var hasTrialPeriod: Bool
    /// How many days a trial period runs for a plan. Only valid if `hasTrialPeriod` is true.
    public var trialPeriodDays: Int
    /// The terms and conditions for a plan.
    public var termsAndConditions: String
    /// The price of a plan. If a free plan then undefined.
    public var price: Double?
    /// The currency a plan is offered in.
    public var currency: String
    /// A map of custom fields defined by a curator for a plan.
    public var customFields: [String: AnyJSON]?

    /// The type of plan.
    public enum `Type`: String, Codable, CaseIterable {
        case free = "Free"
        case subscription = "Subscription"
    }

    /// The revenue type a plan targets.
    public enum RevenueType: String, Codable, CaseIterable {
        case tvod = "TVOD"
        case svod = "SVOD"
    }

    /// The type of billing period used.
    public enum BillingPeriodType: String, Codable, CaseIterable {
        case day
        case week
        case month
        case year
        case `none`
    }

    public init(id: String, title: String, tagline: String, type: `Type`, isFeatured: Bool, isActive: Bool, isPrivate: Bool, revenueType: RevenueType, subscriptionCode: String, alias: String, benefits: [String], billingPeriodType: BillingPeriodType, billingPeriodFrequency: Int, hasTrialPeriod: Bool, trialPeriodDays: Int, termsAndConditions: String, price: Double? = nil, currency: String, customFields: [String: AnyJSON]? = nil) {
        self.id = id
        self.title = title
        self.tagline = tagline
        self.type = type
        self.isFeatured = isFeatured
        self.isActive = isActive
        self.isPrivate = isPrivate
        self.revenueType = revenueType
        self.subscriptionCode = subscriptionCode
        self.alias = alias
        self.benefits = benefits
        self.billingPeriodType = billingPeriodType
        self.billingPeriodFrequency = billingPeriodFrequency
        self.hasTrialPeriod = hasTrialPeriod
        self.trialPeriodDays = trialPeriodDays
        self.termsAndConditions = termsAndConditions
        self.price = price
        self.currency = currency
        self.customFields = customFields
    }
}

public struct PlanPurchase: Codable {
    /// The identifier of the purchased plan.
    public var id: String?
    /// The price of the purchased plan.
    public var price: Double?
    /// The identifier of the subscription membership to the plan.
    public var subscriptionID: String?
    /// The title of the purchased plan.
    public var title: String
    /// The type of plan purchased.
    public var type: `Type`

    /// The type of plan purchased.
    public enum `Type`: String, Codable, CaseIterable {
        case free = "Free"
        case subscription = "Subscription"
    }

    public init(id: String? = nil, price: Double? = nil, subscriptionID: String? = nil, title: String, type: `Type`) {
        self.id = id
        self.price = price
        self.subscriptionID = subscriptionID
        self.title = title
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case price
        case subscriptionID = "subscriptionId"
        case title
        case type
    }
}

public struct ProfileCreationRequest: Codable {
    /// The unique name of the profile.
    public var name: String
    /// Whether an account pin is required to enter the profile.
    /// 
    /// If no account pin is defined this has no impact.
    public var isPinEnabled: Bool
    /// Whether the profile can make purchases with the account payment options.
    public var isPurchaseEnabled: Bool
    /// The segments a profile should be placed under
    public var segments: [String]?
    /// The code of the preferred language for the profile.
    /// Must be a valid ISO language code e.g. "en-US" and must match the code of
    /// one of the languages specified in the app config.
    /// See https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes
    public var languageCode: String?

    public init(name: String, isPinEnabled: Bool? = nil, isPurchaseEnabled: Bool? = nil, segments: [String]? = nil, languageCode: String? = nil) {
        self.name = name
        self.isPinEnabled = isPinEnabled ?? false
        self.isPurchaseEnabled = isPurchaseEnabled ?? true
        self.segments = segments
        self.languageCode = languageCode
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case isPinEnabled = "pinEnabled"
        case isPurchaseEnabled = "purchaseEnabled"
        case segments
        case languageCode
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.name = try values.decode(String.self, forKey: .name)
        self.isPinEnabled = try values.decodeIfPresent(Bool.self, forKey: .isPinEnabled) ?? false
        self.isPurchaseEnabled = try values.decodeIfPresent(Bool.self, forKey: .isPurchaseEnabled) ?? true
        self.segments = try values.decodeIfPresent([String].self, forKey: .segments)
        self.languageCode = try values.decodeIfPresent(String.self, forKey: .languageCode)
    }
}

public struct ProfileDetail: Codable {
    public var profileSummary: ProfileSummary
    /// A map of watched itemIds => last watched position
    public var watched: [String: Watched]
    /// A map of rated itemIds => rating out of 10
    public var rated: [String: Int]
    /// A map of bookmarked itemIds => created date
    public var bookmarked: [String: Date]

    public init(profileSummary: ProfileSummary, watched: [String: Watched], rated: [String: Int], bookmarked: [String: Date]) {
        self.profileSummary = profileSummary
        self.watched = watched
        self.rated = rated
        self.bookmarked = bookmarked
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.profileSummary = try ProfileSummary(from: decoder)
        self.watched = try values.decode([String: Watched].self, forKey: "watched")
        self.rated = try values.decode([String: Int].self, forKey: "rated")
        self.bookmarked = try values.decode([String: Date].self, forKey: "bookmarked")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(profileSummary, forKey: "profileSummary")
        try values.encode(watched, forKey: "watched")
        try values.encode(rated, forKey: "rated")
        try values.encode(bookmarked, forKey: "bookmarked")
    }
}

public struct ProfileSummary: Codable {
    /// The id of the profile.
    public var id: String
    /// The unique name of the profile.
    public var name: String
    /// Whether a pin is required to enter the profile.
    public var isPinEnabled: Bool
    /// Whether the profile can make purchases with the account payment options.
    public var isPurchaseEnabled: Bool
    /// Hex color value assigned to the profile.
    public var color: String?
    /// The segments a profile has been placed under
    public var segments: [String]
    /// Whether the profile is active or not.
    /// 
    /// **DEPRECATED** - Always true. Inactive profiles are no longer returned.
    public var isActive: Bool
    /// Whether the profile has opted in or out of marketing material.
    /// 
    /// **DEPRECATED** - Marketing material is no longer tied to profiles, only account. See `Account.marketingEnabled`.
    public var isMarketingEnabled: Bool
    public var maxRatingContentFilter: ClassificationSummary?
    public var minRatingPlaybackGuard: ClassificationSummary?
    /// The code of the preferred language for the profile.
    /// Must be a valid ISO language code e.g. "en-US" and must match the code of
    /// one of the languages specified in the app config.
    /// See https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes
    public var languageCode: String?
    /// Gets the Hero row clip auto playback audio enabled
    public var isHeroWithAudio: Bool?
    /// Gets the Hero row clip auto playback enabled
    public var isHeroAutoplay: Bool?

    public init(id: String, name: String, isPinEnabled: Bool, isPurchaseEnabled: Bool, color: String? = nil, segments: [String], isActive: Bool, isMarketingEnabled: Bool, maxRatingContentFilter: ClassificationSummary? = nil, minRatingPlaybackGuard: ClassificationSummary? = nil, languageCode: String? = nil, isHeroWithAudio: Bool? = nil, isHeroAutoplay: Bool? = nil) {
        self.id = id
        self.name = name
        self.isPinEnabled = isPinEnabled
        self.isPurchaseEnabled = isPurchaseEnabled
        self.color = color
        self.segments = segments
        self.isActive = isActive
        self.isMarketingEnabled = isMarketingEnabled
        self.maxRatingContentFilter = maxRatingContentFilter
        self.minRatingPlaybackGuard = minRatingPlaybackGuard
        self.languageCode = languageCode
        self.isHeroWithAudio = isHeroWithAudio
        self.isHeroAutoplay = isHeroAutoplay
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case isPinEnabled = "pinEnabled"
        case isPurchaseEnabled = "purchaseEnabled"
        case color
        case segments
        case isActive
        case isMarketingEnabled = "marketingEnabled"
        case maxRatingContentFilter
        case minRatingPlaybackGuard
        case languageCode
        case isHeroWithAudio = "heroWithAudio"
        case isHeroAutoplay = "heroAutoplay"
    }
}

public struct ProfileTokenRequest: Codable {
    /// The id of the profile the token should grant access rights to.
    public var profileID: String
    /// The pin associated with this profile, if any.
    public var pin: String?
    /// The scope(s) of the token(s) required.
    public var scopes: [Scope]
    /// If you specify a cookie type then a content filter cookie will be returned
    /// along with the token(s). This is only intended for web based clients which
    /// need to pass the cookies to a server to render a page based on the user's
    /// content filters e.g subscription code.
    /// 
    /// If type `Session` the cookie will be session based.
    /// If type `Persistent` the cookie will have a medium term lifespan.
    /// If undefined no cookies will be set.
    public var cookieType: CookieType?

    public enum Scope: String, Codable, CaseIterable {
        case catalog = "Catalog"
        case commerce = "Commerce"
        case settings = "Settings"
    }

    /// If you specify a cookie type then a content filter cookie will be returned
    /// along with the token(s). This is only intended for web based clients which
    /// need to pass the cookies to a server to render a page based on the user's
    /// content filters e.g subscription code.
    /// 
    /// If type `Session` the cookie will be session based.
    /// If type `Persistent` the cookie will have a medium term lifespan.
    /// If undefined no cookies will be set.
    public enum CookieType: String, Codable, CaseIterable {
        case session = "Session"
        case persistent = "Persistent"
    }

    public init(profileID: String, pin: String? = nil, scopes: [Scope], cookieType: CookieType? = nil) {
        self.profileID = profileID
        self.pin = pin
        self.scopes = scopes
        self.cookieType = cookieType
    }

    private enum CodingKeys: String, CodingKey {
        case profileID = "profileId"
        case pin
        case scopes
        case cookieType
    }
}

public struct ProfileUpdateRequest: Codable {
    /// The unique name of the profile.
    public var name: String?
    /// Whether an account pin is required to enter the profile.
    /// 
    /// If no account pin is defined this has no impact.
    public var isPinEnabled: Bool?
    /// Whether the profile can make purchases with the account payment options.
    public var isPurchaseEnabled: Bool?
    /// Sets the Hero row clip auto playback audio enabled
    public var isHeroWithAudio: Bool?
    /// Sets the Hero row clip auto playback enabled
    public var isHeroAutoplay: Bool?
    /// The segments a profile should be placed under
    public var segments: [String]?
    /// The code of the preferred language for the profile.
    /// Must be a valid ISO language code e.g. "en-US" and must match the code of
    /// one of the languages specified in the app config.
    /// See https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes
    public var languageCode: String?

    public init(name: String? = nil, isPinEnabled: Bool? = nil, isPurchaseEnabled: Bool? = nil, isHeroWithAudio: Bool? = nil, isHeroAutoplay: Bool? = nil, segments: [String]? = nil, languageCode: String? = nil) {
        self.name = name
        self.isPinEnabled = isPinEnabled
        self.isPurchaseEnabled = isPurchaseEnabled
        self.isHeroWithAudio = isHeroWithAudio
        self.isHeroAutoplay = isHeroAutoplay
        self.segments = segments
        self.languageCode = languageCode
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case isPinEnabled = "pinEnabled"
        case isPurchaseEnabled = "purchaseEnabled"
        case isHeroWithAudio = "heroWithAudio"
        case isHeroAutoplay = "heroAutoplay"
        case segments
        case languageCode
    }
}

public struct Purchase: Codable {
    /// The identifier of the purchase.
    public var id: String
    /// The date the purchase was authorized.
    public var authorizationDate: Date?
    /// The date the purchase was created.
    public var creationDate: Date
    /// The currency code used to make the purchase.
    public var currency: String
    public var item: ItemPurchase?
    /// The identifier of the payment method used to make the purchase.
    public var paymentMethodID: String?
    public var plan: PlanPurchase?
    /// The total cost of the purchase.
    public var total: Double

    public init(id: String, authorizationDate: Date? = nil, creationDate: Date, currency: String, item: ItemPurchase? = nil, paymentMethodID: String? = nil, plan: PlanPurchase? = nil, total: Double) {
        self.id = id
        self.authorizationDate = authorizationDate
        self.creationDate = creationDate
        self.currency = currency
        self.item = item
        self.paymentMethodID = paymentMethodID
        self.plan = plan
        self.total = total
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case authorizationDate
        case creationDate
        case currency
        case item
        case paymentMethodID = "paymentMethodId"
        case plan
        case total
    }
}

public struct PurchaseRequest: Codable {
    /// The identifier of the item to purchase.
    /// Both `itemId` and `offerId` are required for item purchases.
    public var itemID: String?
    /// The identifier of the item offer to purchase.
    /// Both `itemId` and `offerId` are required for item purchases.
    public var offerID: String?
    /// The identifier of the plan to purchase.
    public var planID: String?
    /// The identifier of the payment method to use.
    /// If omitted, or if purchasing a plan, the default payment method will be used.
    public var paymentMethodID: String?

    public init(itemID: String? = nil, offerID: String? = nil, planID: String? = nil, paymentMethodID: String? = nil) {
        self.itemID = itemID
        self.offerID = offerID
        self.planID = planID
        self.paymentMethodID = paymentMethodID
    }

    private enum CodingKeys: String, CodingKey {
        case itemID = "itemId"
        case offerID = "offerId"
        case planID = "planId"
        case paymentMethodID = "paymentMethodId"
    }
}

public struct RegistrationRequest: Codable {
    public var firstName: String?
    public var lastName: String?
    public var email: String
    public var password: String
    /// The primary account pin.
    public var pin: String?
    /// Whether to receive marketing material or not. Default to true.
    public var isMarketing: Bool
    /// The segments to apply to the primary profile.
    public var segments: [String]?
    /// The code of the preferred language for the primary profile.
    /// Must be a valid ISO language code e.g. "en-US" and must match the code of
    /// one of the languages specified in the app config.
    /// See https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes
    public var languageCode: String?

    public init(firstName: String? = nil, lastName: String? = nil, email: String, password: String, pin: String? = nil, isMarketing: Bool? = nil, segments: [String]? = nil, languageCode: String? = nil) {
        self.firstName = firstName
        self.lastName = lastName
        self.email = email
        self.password = password
        self.pin = pin
        self.isMarketing = isMarketing ?? true
        self.segments = segments
        self.languageCode = languageCode
    }

    private enum CodingKeys: String, CodingKey {
        case firstName
        case lastName
        case email
        case password
        case pin
        case isMarketing = "marketing"
        case segments
        case languageCode
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.firstName = try values.decodeIfPresent(String.self, forKey: .firstName)
        self.lastName = try values.decodeIfPresent(String.self, forKey: .lastName)
        self.email = try values.decode(String.self, forKey: .email)
        self.password = try values.decode(String.self, forKey: .password)
        self.pin = try values.decodeIfPresent(String.self, forKey: .pin)
        self.isMarketing = try values.decodeIfPresent(Bool.self, forKey: .isMarketing) ?? true
        self.segments = try values.decodeIfPresent([String].self, forKey: .segments)
        self.languageCode = try values.decodeIfPresent(String.self, forKey: .languageCode)
    }
}

public struct RokuPlanListItem: Codable {
    /// The identifier of a plan.
    public var productCode: String
    /// The title of a plan.
    public var nickname: String
    /// The product of a plan.
    public var product: String
    /// The currency a plan is offered in.
    public var currency: String
    /// The price of a plan. If a free plan then undefined.
    public var amount: Double
    /// The type of billing period used.
    public var interval: Interval
    /// Given the `interval` this is how frequently it will run. e.g. every 2 weeks.
    public var intervalCount: Int
    /// How many days a trial period runs for a plan. Only valid if `hasTrialPeriod` is true.
    public var trialPeriodDays: Int
    /// The textual description.
    public var description: String
    /// NA.
    public var savingLabel: String

    /// The type of billing period used.
    public enum Interval: String, Codable, CaseIterable {
        case day
        case week
        case month
        case year
        case `none`
    }

    public init(productCode: String, nickname: String, product: String, currency: String, amount: Double, interval: Interval, intervalCount: Int, trialPeriodDays: Int, description: String, savingLabel: String) {
        self.productCode = productCode
        self.nickname = nickname
        self.product = product
        self.currency = currency
        self.amount = amount
        self.interval = interval
        self.intervalCount = intervalCount
        self.trialPeriodDays = trialPeriodDays
        self.description = description
        self.savingLabel = savingLabel
    }
}

public struct RokuPlans: Codable {
    /// The list of available plans.
    public var plans: [RokuPlanListItem]
    /// Details of terms and conditions of the plan.
    public var termsAndConditions: String

    public init(plans: [RokuPlanListItem], termsAndConditions: String) {
        self.plans = plans
        self.termsAndConditions = termsAndConditions
    }
}

public struct SamsungPreview: Codable {
    /// For public preview only
    /// If specified, the time at which the preview content is updated.
    /// The time is at most 1 week into the future. By default, the preview
    /// content is updated every 10 minutes, whenever the TV is switched on,
    /// or the JSON file changes.
    public var expires: Int?
    /// For public preview only
    /// If this value is "true", the preview content is updated only at
    /// the time specified by the "expires" parameter.
    public var isExpiresOnly: Bool
    /// Preview sections
    public var sections: [SamsungPreviewSection]

    public init(expires: Int? = nil, isExpiresOnly: Bool? = nil, sections: [SamsungPreviewSection]) {
        self.expires = expires
        self.isExpiresOnly = isExpiresOnly ?? false
        self.sections = sections
    }

    private enum CodingKeys: String, CodingKey {
        case expires
        case isExpiresOnly = "expires_only"
        case sections
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.expires = try values.decodeIfPresent(Int.self, forKey: .expires)
        self.isExpiresOnly = try values.decodeIfPresent(Bool.self, forKey: .isExpiresOnly) ?? false
        self.sections = try values.decode([SamsungPreviewSection].self, forKey: .sections)
    }
}

public struct SamsungPreviewSection: Codable {
    /// Section title
    public var title: String?
    /// Section position. If specified, sections are shown in ascending position order.
    public var position: Int?
    /// Tiles within the section
    public var tiles: [SamsungPreviewSectionTile]

    public init(title: String? = nil, position: Int? = nil, tiles: [SamsungPreviewSectionTile]) {
        self.title = title
        self.position = position
        self.tiles = tiles
    }
}

public struct SamsungPreviewSectionTile: Codable {
    /// Tile title
    public var title: String?
    /// Tile subtitle
    public var subtitle: String?
    /// Thumbnail image URL
    public var imageURL: URL
    /// Thumbnail image aspect ratio
    ///   "16:9"
    ///   "4:3"
    ///   "1:1" (default)
    ///   "2:3"
    ///   The thumbnail height is fixed at 250 px on presentation.
    public var imageRatio: String
    /// Data to send to the application when the tile is clicked
    public var actionData: String
    /// If "true", a "Play" icon is shown over the thumbnail image
    public var isPlayable: Bool
    /// Time to begin showing the tile
    public var displayFrom: Date?
    /// Time to stop showing the tile
    public var displayUntil: Date?
    /// Section position. If specified, sections are shown in ascending position order
    public var position: Int?

    public init(title: String? = nil, subtitle: String? = nil, imageURL: URL, imageRatio: String, actionData: String, isPlayable: Bool, displayFrom: Date? = nil, displayUntil: Date? = nil, position: Int? = nil) {
        self.title = title
        self.subtitle = subtitle
        self.imageURL = imageURL
        self.imageRatio = imageRatio
        self.actionData = actionData
        self.isPlayable = isPlayable
        self.displayFrom = displayFrom
        self.displayUntil = displayUntil
        self.position = position
    }

    private enum CodingKeys: String, CodingKey {
        case title
        case subtitle
        case imageURL = "image_url"
        case imageRatio = "image_ratio"
        case actionData = "action_data"
        case isPlayable = "is_playable"
        case displayFrom = "display_from"
        case displayUntil = "display_until"
        case position
    }
}

public struct SearchResults: Codable {
    /// The search term.
    public var term: String
    /// The total number of results.
    public var total: Int
    /// A pageable list of items.
    public var items: ItemList?
    /// A pageable list of items.
    public var movies: ItemList?
    /// A pageable list of items.
    public var tv: ItemList?
    /// A pageable list of items.
    public var other: ItemList?
    /// The list of people relevant to the search term.
    public var people: [Person]?

    public init(term: String, total: Int, items: ItemList? = nil, movies: ItemList? = nil, tv: ItemList? = nil, other: ItemList? = nil, people: [Person]? = nil) {
        self.term = term
        self.total = total
        self.items = items
        self.movies = movies
        self.tv = tv
        self.other = other
        self.people = people
    }
}

public struct ServiceError: Codable {
    /// A description of the error.
    public var message: String
    /// An optional code classifying the error. Should be taken in the context of the http status code.
    public var code: Int?

    public init(message: String, code: Int? = nil) {
        self.message = message
        self.code = code
    }
}

public struct SingleSignOnRequest: Codable {
    /// The third party single-sign-on provider.
    public var provider: Provider
    /// A token from the third party single-sign-on provider e.g. an identity token from Facebook.
    public var token: String
    /// The scope(s) of the tokens required.
    /// For each scope listed an Account and Profile token of that scope will be returned.
    public var scopes: [Scope]?
    /// If you specify a cookie type then a content filter cookie will be returned
    /// along with the token(s). This is only intended for web based clients which
    /// need to pass the cookies to a server to render a page based on the user's
    /// content filters e.g subscription code.
    /// 
    /// If type `Session` the cookie will be session based.
    /// If type `Persistent` the cookie will have a medium term lifespan.
    /// If undefined no cookies will be set.
    public var cookieType: CookieType?
    /// When a user attempts to sign in using single-sign-on, we may find an account created
    /// previously through the manual sign up flow with the same email. If this is the
    /// case then an option to link the two accounts can be made available.
    /// 
    /// If this flag is set to true then accounts will be linked automatically.
    /// 
    /// If this flag is not set or set to false and an existing account is found 
    /// then an http 401 with subcode `6001` will be returned. Client apps can then present the
    /// option to link the accounts. If the user decides to accept, then the same call
    /// can be repeated with this flag set to true.
    public var isLinkAccounts: Bool?

    /// The third party single-sign-on provider.
    public enum Provider: String, Codable, CaseIterable {
        case facebook = "Facebook"
    }

    public enum Scope: String, Codable, CaseIterable {
        case catalog = "Catalog"
        case commerce = "Commerce"
        case settings = "Settings"
        case playback = "Playback"
    }

    /// If you specify a cookie type then a content filter cookie will be returned
    /// along with the token(s). This is only intended for web based clients which
    /// need to pass the cookies to a server to render a page based on the user's
    /// content filters e.g subscription code.
    /// 
    /// If type `Session` the cookie will be session based.
    /// If type `Persistent` the cookie will have a medium term lifespan.
    /// If undefined no cookies will be set.
    public enum CookieType: String, Codable, CaseIterable {
        case session = "Session"
        case persistent = "Persistent"
    }

    public init(provider: Provider, token: String, scopes: [Scope]? = nil, cookieType: CookieType? = nil, isLinkAccounts: Bool? = nil) {
        self.provider = provider
        self.token = token
        self.scopes = scopes
        self.cookieType = cookieType
        self.isLinkAccounts = isLinkAccounts
    }

    private enum CodingKeys: String, CodingKey {
        case provider
        case token
        case scopes
        case cookieType
        case isLinkAccounts = "linkAccounts"
    }
}

public struct Subscription: Codable {
    /// Unique identifier for the subscription.
    public var id: String?
    /// The unique subscription code.
    public var code: String
    /// The start date of a subscription.
    public var startDate: Date
    /// The end date of a subscription.
    /// 
    /// After this date the subscription will become expired. If this is a recurring
    /// subscription which has not been cancelled then the account holder will be
    /// automatically charged and a new subscription will be activated.
    /// 
    /// Some subscriptions may not have an end date, in which case this
    /// property will not exist.
    public var endDate: Date?
    /// True if a subscription is in its trial period, false if not.
    public var isTrialPeriod: Bool
    /// The plan a subscription belongs to.
    public var planID: String
    /// The status of a subscription.
    public var status: Status

    /// The status of a subscription.
    public enum Status: String, Codable, CaseIterable {
        case active = "Active"
        case cancelled = "Cancelled"
        case lapsed = "Lapsed"
        case expired = "Expired"
        case `none` = "None"
    }

    public init(id: String? = nil, code: String, startDate: Date, endDate: Date? = nil, isTrialPeriod: Bool, planID: String, status: Status) {
        self.id = id
        self.code = code
        self.startDate = startDate
        self.endDate = endDate
        self.isTrialPeriod = isTrialPeriod
        self.planID = planID
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case code
        case startDate
        case endDate
        case isTrialPeriod
        case planID = "planId"
        case status
    }
}

public struct SubscriptionDetails: Codable {
    /// The ITV purchased subscription data.
    public var itvDataPurchased: [String: AnyJSON]

    public init(itvDataPurchased: [String: AnyJSON]) {
        self.itvDataPurchased = itvDataPurchased
    }

    private enum CodingKeys: String, CodingKey {
        case itvDataPurchased = "itvData_purchased"
    }
}

public struct Theme: Codable {
    /// The list of colors defined for the theme.
    public var colors: [ThemeColor]
    /// The type of theme.
    public var type: `Type`

    /// The type of theme.
    public enum `Type`: String, Codable, CaseIterable {
        case background = "Background"
        case text = "Text"
        case custom = "Custom"
    }

    public init(colors: [ThemeColor], type: `Type`) {
        self.colors = colors
        self.type = type
    }
}

public struct ThemeColor: Codable {
    /// The name of the theme color.
    public var name: String
    /// The opacity of the theme color from 0 to 1.
    /// 
    /// When omitted, no opacity level is to be applied to the color, or in other words we
    /// assume the color has an opacity of 1
    public var opacity: Double?
    /// The hex value of the theme color.
    public var value: String

    public init(name: String, opacity: Double? = nil, value: String) {
        self.name = name
        self.opacity = opacity
        self.value = value
    }
}

public struct TokenRefreshRequest: Codable {
    /// The token to refresh.
    public var token: String
    /// If you specify a cookie type then a content filter cookie will be returned
    /// along with the token(s). This is only intended for web based clients which
    /// need to pass the cookies to a server to render a page based on the user's
    /// content filters e.g subscription code.
    /// 
    /// If type `Session` the cookie will be session based.
    /// If type `Persistent` the cookie will have a medium term lifespan.
    /// If undefined no cookies will be set.
    public var cookieType: CookieType?

    /// If you specify a cookie type then a content filter cookie will be returned
    /// along with the token(s). This is only intended for web based clients which
    /// need to pass the cookies to a server to render a page based on the user's
    /// content filters e.g subscription code.
    /// 
    /// If type `Session` the cookie will be session based.
    /// If type `Persistent` the cookie will have a medium term lifespan.
    /// If undefined no cookies will be set.
    public enum CookieType: String, Codable, CaseIterable {
        case session = "Session"
        case persistent = "Persistent"
    }

    public init(token: String, cookieType: CookieType? = nil) {
        self.token = token
        self.cookieType = cookieType
    }
}

public struct UserRating: Codable {
    /// The id of the item rated.
    public var itemID: String
    /// The rating out of 10
    public var rating: Int

    public init(itemID: String, rating: Int) {
        self.itemID = itemID
        self.rating = rating
    }

    private enum CodingKeys: String, CodingKey {
        case itemID = "itemId"
        case rating
    }
}

public struct Watched: Codable {
    /// The id of the item watched.
    public var itemID: String?
    /// The last playhead position watched for the item.
    public var position: Int
    public var firstWatchedDate: Date
    public var lastWatchedDate: Date
    /// True - if the item is fully watched, False - otherwise.
    public var isFullyWatched: Bool

    public init(itemID: String? = nil, position: Int, firstWatchedDate: Date, lastWatchedDate: Date, isFullyWatched: Bool? = nil) {
        self.itemID = itemID
        self.position = position
        self.firstWatchedDate = firstWatchedDate
        self.lastWatchedDate = lastWatchedDate
        self.isFullyWatched = isFullyWatched ?? false
    }

    private enum CodingKeys: String, CodingKey {
        case itemID = "itemId"
        case position
        case firstWatchedDate
        case lastWatchedDate
        case isFullyWatched
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.itemID = try values.decodeIfPresent(String.self, forKey: .itemID)
        self.position = try values.decode(Int.self, forKey: .position)
        self.firstWatchedDate = try values.decode(Date.self, forKey: .firstWatchedDate)
        self.lastWatchedDate = try values.decode(Date.self, forKey: .lastWatchedDate)
        self.isFullyWatched = try values.decodeIfPresent(Bool.self, forKey: .isFullyWatched) ?? false
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
