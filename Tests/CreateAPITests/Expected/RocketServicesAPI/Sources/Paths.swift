// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import NaiveDate
import Get
import URLQueryEncoder

extension Paths {
    public static var account: Account {
        Account(path: "/account")
    }

    public struct Account {
        /// Path: `/account`
        public let path: String

        /// Get the details of an account along with the profiles and entitlements under it.
        public func get(ff: [Ff]? = nil, lang: String? = nil) -> Request<RocketServicesAPI.Account> {
            .get(path, query: makeGetQuery(ff, lang))
        }

        private func makeGetQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }

        /// Update the details of an account.
        /// 
        /// With the exception of the address, this supports partial updates, so you can send just the
        /// properties you wish to update.
        /// 
        /// When the address is provided any properties which are omitted from the address will be cleared.
        public func patch(ff: [Ff]? = nil, lang: String? = nil, _ body: RocketServicesAPI.AccountUpdateRequest) -> Request<Void> {
            .patch(path, query: makePatchQuery(ff, lang), body: body)
        }

        private func makePatchQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Account {
    public var billing: Billing {
        Billing(path: path + "/billing")
    }

    public struct Billing {
        /// Path: `/account/billing`
        public let path: String
    }
}

extension Paths.Account.Billing {
    public var methods: Methods {
        Methods(path: path + "/methods")
    }

    public struct Methods {
        /// Path: `/account/billing/methods`
        public let path: String

        /// Get the available payment methods under an account.
        public func get(ff: [Ff]? = nil, lang: String? = nil) -> Request<[RocketServicesAPI.PaymentMethod]> {
            .get(path, query: makeGetQuery(ff, lang))
        }

        private func makeGetQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }

        /// Add a new payment method to an account.
        public func post(ff: [Ff]? = nil, lang: String? = nil, _ body: RocketServicesAPI.AddPaymentMethodRequest) -> Request<RocketServicesAPI.PaymentMethod> {
            .post(path, query: makePostQuery(ff, lang), body: body)
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Account.Billing.Methods {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/account/billing/methods/{id}`
        public let path: String

        /// Get a payment method under an account.
        public func get(ff: [Ff]? = nil, lang: String? = nil) -> Request<RocketServicesAPI.PaymentMethod> {
            .get(path, query: makeGetQuery(ff, lang))
        }

        private func makeGetQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }

        /// Remove a payment method from an account.
        public func delete(ff: [Ff]? = nil, lang: String? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(ff, lang))
        }

        private func makeDeleteQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Account.Billing {
    public var purchases: Purchases {
        Purchases(path: path + "/purchases")
    }

    public struct Purchases {
        /// Path: `/account/billing/purchases`
        public let path: String

        /// Get a list of all purchases made under an account.
        public func get(ff: [Ff]? = nil, lang: String? = nil) -> Request<[RocketServicesAPI.Purchase]> {
            .get(path, query: makeGetQuery(ff, lang))
        }

        private func makeGetQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }

        /// Purchase a plan or item offer.
        /// The result of a successful transaction is a new entitlement.
        public func post(ff: [Ff]? = nil, lang: String? = nil, _ body: RocketServicesAPI.PurchaseRequest) -> Request<RocketServicesAPI.Entitlement> {
            .post(path, query: makePostQuery(ff, lang), body: body)
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Account.Billing {
    public var subscriptions: Subscriptions {
        Subscriptions(path: path + "/subscriptions")
    }

    public struct Subscriptions {
        /// Path: `/account/billing/subscriptions`
        public let path: String
    }
}

extension Paths.Account.Billing.Subscriptions {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/account/billing/subscriptions/{id}`
        public let path: String

        /// Renew a cancelled subscription or switch subscription to a different plan.
        /// 
        /// When renewing a cancelled subscription membership, hit this endpoint with
        /// the id of subscription to renew.
        /// 
        /// To switch plans provide the id of the current active subscription membership
        /// of the account, and in the query specify the id of the plan to switch to.
        public func put(parameters: PutParameters? = nil) -> Request<Void> {
            .put(path, query: parameters?.asQuery)
        }

        public struct PutParameters {
            public var planID: String?
            public var ff: [Ff]?
            public var lang: String?

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(planID: String? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.planID = planID
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(planID, forKey: "planId")
                encoder.encode(ff, forKey: "ff", explode: false)
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }

        /// Cancel a plan subscription.
        /// 
        /// A cancelled subscription will continue to be valid until the subscription
        /// expiry date or next renewal date.
        public func delete(ff: [Ff]? = nil, lang: String? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(ff, lang))
        }

        private func makeDeleteQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths.Account {
    public var devices: Devices {
        Devices(path: path + "/devices")
    }

    public struct Devices {
        /// Path: `/account/devices`
        public let path: String

        /// Get all devices registered under this account.
        /// 
        /// Also includes information around device registration and deregistration limits.
        public func get(ff: [Ff]? = nil, lang: String? = nil) -> Request<RocketServicesAPI.AccountDevices> {
            .get(path, query: makeGetQuery(ff, lang))
        }

        private func makeGetQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }

        /// Register a playback device under an account.
        /// 
        /// If a device with the same id already exists a `409` conflict will be returned.
        public func post(ff: [Ff]? = nil, lang: String? = nil, _ body: RocketServicesAPI.DeviceRegistrationRequest) -> Request<RocketServicesAPI.Device> {
            .post(path, query: makePostQuery(ff, lang), body: body)
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Account.Devices.WithID {
    public var name: Name {
        Name(path: path + "/name")
    }

    public struct Name {
        /// Path: `/account/devices/{id}/name`
        public let path: String

        /// Rename a device
        public func put(parameters: PutParameters) -> Request<Void> {
            .put(path, query: parameters.asQuery)
        }

        public struct PutParameters {
            public var name: String
            public var ff: [Ff]?
            public var lang: String?

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(name: String, ff: [Ff]? = nil, lang: String? = nil) {
                self.name = name
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(name, forKey: "name")
                encoder.encode(ff, forKey: "ff", explode: false)
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths.Account.Devices {
    public var authorization: Authorization {
        Authorization(path: path + "/authorization")
    }

    public struct Authorization {
        /// Path: `/account/devices/authorization`
        public let path: String

        /// Authorize a device from a generated device authorization code.
        /// 
        /// This is the second step in the process of authorizing a device by pin code.
        /// 
        /// Firstly the device must request a generated authorization code via the
        /// `/authorization/device/code` endpoint.
        /// 
        /// This endpoint then authorizes the device associated with the code to sign in
        /// to a user account. Typically this endpoint will be called from a page
        /// presented in the web app under the account section.
        /// 
        /// Once authorized, the device will then be able to sign in to that account
        /// via the `/authorization/device` endpoint, without needing to provide the 
        /// credentials of the user.
        public func post(ff: [Ff]? = nil, lang: String? = nil, _ body: RocketServicesAPI.DeviceAuthorizationCode) -> Request<Void> {
            .post(path, query: makePostQuery(ff, lang), body: body)
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths.Account.Devices {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/account/devices/{id}`
        public let path: String

        /// Get a registered device.
        public func get(ff: [Ff]? = nil, lang: String? = nil) -> Request<RocketServicesAPI.Device> {
            .get(path, query: makeGetQuery(ff, lang))
        }

        private func makeGetQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }

        /// Deregister a playback device from an account.
        public func delete(ff: [Ff]? = nil, lang: String? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(ff, lang))
        }

        private func makeDeleteQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Account {
    public var entitlements: Entitlements {
        Entitlements(path: path + "/entitlements")
    }

    public struct Entitlements {
        /// Path: `/account/entitlements`
        public let path: String

        /// Get all entitlements under the account.
        /// 
        /// This list is returned under the call to get account information so a call here is
        /// only required when wishing to refresh a local copy of entitlements.
        public func get(ff: [Ff]? = nil, lang: String? = nil) -> Request<[RocketServicesAPI.Entitlement]> {
            .get(path, query: makeGetQuery(ff, lang))
        }

        private func makeGetQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths.Account {
    public var items: Items {
        Items(path: path + "/items")
    }

    public struct Items {
        /// Path: `/account/items`
        public let path: String
    }
}

extension Paths.Account.Items {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/account/items/{id}`
        public let path: String
    }
}

extension Paths.Account.Items.WithID {
    public var videos: Videos {
        Videos(path: path + "/videos")
    }

    public struct Videos {
        /// Path: `/account/items/{id}/videos`
        public let path: String

        /// Get the video files associated with an item given maximum resolution, device type
        /// and one or more delivery types.
        /// 
        /// This endpoint accepts an Account Catalog token, however if when requesting
        /// playback files you receive an *403 status code with error code 1* then the file
        /// you're requesting is classification restricted. This means you should switch
        /// to target the `/account/items/{id}/videos-guarded` endpoint, passing it an Account
        /// Playback token. If not already obtained, this token can be requested via the
        /// `/itv/pinauthorization` endpoint with an account level pin.
        /// 
        /// For convenience you may also access free / public files through this endpoint
        /// instead of the /items/{id}/videos endpoint, when authenticated.
        /// 
        /// Returns an array of video file objects which each include a url to a video.
        /// 
        /// The first entry in the array contains what is predicted to be the best match.
        /// The remainder of the entries, if any, may contain resolutions below what was
        /// requests. For example if you request HD-720 the response may also contain
        /// SD entries.
        /// 
        /// If you specify multiple delivery types, then the response array will insert
        /// types in the order you specify them in the query. For example `stream,progressive`
        /// would return an array with 0 or more stream files followed by 0 or more progressive files.
        /// 
        /// If no files are found a 404 is returned.
        public func get(parameters: GetParameters) -> Request<[RocketServicesAPI.MediaFile]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var delivery: [Delivery]
            public var resolution: Resolution
            public var formats: [Formats]?
            public var device: String?
            public var sub: String?
            public var segments: [String]?
            public var ff: [Ff]?
            public var lang: String?

            public enum Delivery: String, Codable, CaseIterable {
                case stream
                case progressive
                case download
            }

            public enum Resolution: String, Codable, CaseIterable {
                case hd4k = "HD-4K"
                case hd1080 = "HD-1080"
                case hd720 = "HD-720"
                case sd = "SD"
                case external = "External"
            }

            public enum Formats: String, Codable, CaseIterable {
                case mp4
                case mpd
                case hls
                case external
            }

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(delivery: [Delivery], resolution: Resolution, formats: [Formats]? = nil, device: String? = nil, sub: String? = nil, segments: [String]? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.delivery = delivery
                self.resolution = resolution
                self.formats = formats
                self.device = device
                self.sub = sub
                self.segments = segments
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(delivery, forKey: "delivery", explode: false)
                encoder.encode(resolution, forKey: "resolution")
                encoder.encode(formats, forKey: "formats", explode: false)
                encoder.encode(device, forKey: "device")
                encoder.encode(sub, forKey: "sub")
                encoder.encode(segments, forKey: "segments", explode: false)
                encoder.encode(ff, forKey: "ff", explode: false)
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths.Account.Items.WithID {
    public var videosGuarded: VideosGuarded {
        VideosGuarded(path: path + "/videos-guarded")
    }

    public struct VideosGuarded {
        /// Path: `/account/items/{id}/videos-guarded`
        public let path: String

        /// Get the video files associated with an item given maximum resolution, device type
        /// and one or more delivery types.
        /// 
        /// This endpoint is identical to the `/account/items/{id}/videos` however it expects
        /// an Account Playback token. This token, and in association this endpoint, is specifically
        /// for use when playback files are classification restricted and require an account
        /// level pin to access them.
        /// 
        /// Returns an array of video file objects which each include a url to a video.
        /// 
        /// The first entry in the array contains what is predicted to be the best match.
        /// The remainder of the entries, if any, may contain resolutions below what was
        /// requests. For example if you request HD-720 the response may also contain
        /// SD entries.
        /// 
        /// If you specify multiple delivery types, then the response array will insert
        /// types in the order you specify them in the query. For example `stream,progressive`
        /// would return an array with 0 or more stream files followed by 0 or more progressive files.
        /// 
        /// If no files are found a 404 is returned.
        public func get(parameters: GetParameters) -> Request<[RocketServicesAPI.MediaFile]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var delivery: [Delivery]
            public var resolution: Resolution
            public var formats: [Formats]?
            public var device: String?
            public var sub: String?
            public var segments: [String]?
            public var ff: [Ff]?
            public var lang: String?

            public enum Delivery: String, Codable, CaseIterable {
                case stream
                case progressive
                case download
            }

            public enum Resolution: String, Codable, CaseIterable {
                case hd4k = "HD-4K"
                case hd1080 = "HD-1080"
                case hd720 = "HD-720"
                case sd = "SD"
                case external = "External"
            }

            public enum Formats: String, Codable, CaseIterable {
                case mp4
                case mpd
                case hls
                case external
            }

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(delivery: [Delivery], resolution: Resolution, formats: [Formats]? = nil, device: String? = nil, sub: String? = nil, segments: [String]? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.delivery = delivery
                self.resolution = resolution
                self.formats = formats
                self.device = device
                self.sub = sub
                self.segments = segments
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(delivery, forKey: "delivery", explode: false)
                encoder.encode(resolution, forKey: "resolution")
                encoder.encode(formats, forKey: "formats", explode: false)
                encoder.encode(device, forKey: "device")
                encoder.encode(sub, forKey: "sub")
                encoder.encode(segments, forKey: "segments", explode: false)
                encoder.encode(ff, forKey: "ff", explode: false)
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths.Account {
    public var nonce: Nonce {
        Nonce(path: path + "/nonce")
    }

    public struct Nonce {
        /// Path: `/account/nonce`
        public let path: String

        /// Generate a new account nonce.
        /// 
        /// A nonce may be required to help sign a response from a third party
        /// service which will be passed back to these services.
        /// 
        /// For example a Facebook single-sign-on request initiated by a client
        /// application may first get a nonce from here to include in the request.
        /// Facebook will then include the nonce in the auth token it issues. This
        /// token can be passed back to our services and the nonce checked for validity.
        public func get(ff: [Ff]? = nil, lang: String? = nil) -> Request<RocketServicesAPI.AccountNonce> {
            .get(path, query: makeGetQuery(ff, lang))
        }

        private func makeGetQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths.Account {
    public var password: Password {
        Password(path: path + "/password")
    }

    public struct Password {
        /// Path: `/account/password`
        public let path: String

        /// Change the password of an account.
        /// 
        /// The expected token scope is Settings.
        public func put(ff: [Ff]? = nil, lang: String? = nil, _ body: RocketServicesAPI.ChangePasswordRequest) -> Request<Void> {
            .put(path, query: makePutQuery(ff, lang), body: body)
        }

        private func makePutQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths.Account {
    public var pin: Pin {
        Pin(path: path + "/pin")
    }

    public struct Pin {
        /// Path: `/account/pin`
        public let path: String

        /// Change the pin of an account.
        public func put(ff: [Ff]? = nil, lang: String? = nil, _ body: RocketServicesAPI.ChangePinRequest) -> Request<Void> {
            .put(path, query: makePutQuery(ff, lang), body: body)
        }

        private func makePutQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths.Account {
    public var profile: Profile {
        Profile(path: path + "/profile")
    }

    public struct Profile {
        /// Path: `/account/profile`
        public let path: String

        /// Get the details of the active profile, including watched, bookmarked and rated items.
        public func get(ff: [Ff]? = nil, lang: String? = nil) -> Request<RocketServicesAPI.ProfileDetail> {
            .get(path, query: makeGetQuery(ff, lang))
        }

        private func makeGetQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths.Account.Profile {
    public var bookmarks: Bookmarks {
        Bookmarks(path: path + "/bookmarks")
    }

    public struct Bookmarks {
        /// Path: `/account/profile/bookmarks`
        public let path: String

        /// Get the map of bookmarked item ids (itemId => creationDate) under the active profile.
        public func get(ff: [Ff]? = nil, lang: String? = nil) -> Request<[String: Date]> {
            .get(path, query: makeGetQuery(ff, lang))
        }

        private func makeGetQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths.Account.Profile.Bookmarks {
    public var list: List {
        List(path: path + "/list")
    }

    public struct List {
        /// Path: `/account/profile/bookmarks/list`
        public let path: String

        /// Returns the list of bookmarked items under the active profile.
        public func get(parameters: GetParameters? = nil) -> Request<RocketServicesAPI.ItemList> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var page: Int?
            public var pageSize: Int?
            public var order: Order?
            public var itemType: ItemType?
            public var device: String?
            public var sub: String?
            public var segments: [String]?
            public var ff: [Ff]?
            public var lang: String?

            public enum Order: String, Codable, CaseIterable {
                case asc
                case desc
            }

            public enum ItemType: String, Codable, CaseIterable {
                case movie
                case show
                case season
                case episode
                case program
                case link
                case trailer
                case channel
                case customAsset
            }

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(page: Int? = nil, pageSize: Int? = nil, order: Order? = nil, itemType: ItemType? = nil, device: String? = nil, sub: String? = nil, segments: [String]? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.page = page
                self.pageSize = pageSize
                self.order = order
                self.itemType = itemType
                self.device = device
                self.sub = sub
                self.segments = segments
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(page, forKey: "page")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(order, forKey: "order")
                encoder.encode(itemType, forKey: "item_type")
                encoder.encode(device, forKey: "device")
                encoder.encode(sub, forKey: "sub")
                encoder.encode(segments, forKey: "segments", explode: false)
                encoder.encode(ff, forKey: "ff", explode: false)
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths.Account.Profile.Bookmarks {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/account/profile/bookmarks/{itemId}`
        public let path: String

        /// Get the bookmark for an item under the active profile.
        public func get(ff: [Ff]? = nil, lang: String? = nil) -> Request<RocketServicesAPI.Bookmark> {
            .get(path, query: makeGetQuery(ff, lang))
        }

        private func makeGetQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }

        /// Bookmark an item under the active profile.
        /// 
        /// Creates one if it doesn't exist, overwrites one if it does.
        public func put(ff: [Ff]? = nil, lang: String? = nil) -> Request<RocketServicesAPI.Bookmark> {
            .put(path, query: makePutQuery(ff, lang))
        }

        private func makePutQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        /// Unbookmark an item under the active profile.
        public func delete(ff: [Ff]? = nil, lang: String? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(ff, lang))
        }

        private func makeDeleteQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Account.Profile {
    public var continueWatching: ContinueWatching {
        ContinueWatching(path: path + "/continue-watching")
    }

    public struct ContinueWatching {
        /// Path: `/account/profile/continue-watching`
        public let path: String
    }
}

extension Paths.Account.Profile.ContinueWatching {
    public var list: List {
        List(path: path + "/list")
    }

    public struct List {
        /// Path: `/account/profile/continue-watching/list`
        public let path: String

        /// Returns a list of items which have been watched but not completed under the active
        /// profile.
        /// 
        /// Multiple episodes under the same show may be watched or in progress, however only a
        /// single item belonging to a particular show will be included in the returned list.
        /// 
        /// The next episode to continue watching for a particular show will be the most recent
        /// incompletely watched episode, or the next episode following the most recently
        /// completely watched episode. Based on the specified `show_item_type` type, either the next
        /// episode, the season of the next episode, or the show will be included in the list.
        public func get(parameters: GetParameters? = nil) -> Request<RocketServicesAPI.ItemList> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var showItemType: ShowItemType?
            public var include: [Include]?
            public var page: Int?
            public var pageSize: Int?
            public var maxRating: String?
            public var device: String?
            public var sub: String?
            public var segments: [String]?
            public var ff: [Ff]?
            public var lang: String?

            public enum ShowItemType: String, Codable, CaseIterable {
                case episode
                case season
                case show
            }

            public enum Include: String, Codable, CaseIterable {
                case episode
                case season
                case show
            }

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(showItemType: ShowItemType? = nil, include: [Include]? = nil, page: Int? = nil, pageSize: Int? = nil, maxRating: String? = nil, device: String? = nil, sub: String? = nil, segments: [String]? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.showItemType = showItemType
                self.include = include
                self.page = page
                self.pageSize = pageSize
                self.maxRating = maxRating
                self.device = device
                self.sub = sub
                self.segments = segments
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(showItemType, forKey: "show_item_type")
                encoder.encode(include, forKey: "include", explode: false)
                encoder.encode(page, forKey: "page")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(maxRating, forKey: "max_rating")
                encoder.encode(device, forKey: "device")
                encoder.encode(sub, forKey: "sub")
                encoder.encode(segments, forKey: "segments", explode: false)
                encoder.encode(ff, forKey: "ff", explode: false)
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths.Account.Profile.ContinueWatching {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/account/profile/continue-watching/{itemId}`
        public let path: String

        /// Excludes an item from continue-watching rail. Resume points remain in all other rails.
        /// To undo save actual playback position using PUT /account/profile/watched/{itemId}.
        public func delete(segments: [String]? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(segments))
        }

        private func makeDeleteQuery(_ segments: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(segments, forKey: "segments", explode: false)
            return encoder.items
        }
    }
}

extension Paths.Account.Profile {
    public var items: Items {
        Items(path: path + "/items")
    }

    public struct Items {
        /// Path: `/account/profile/items`
        public let path: String
    }
}

extension Paths.Account.Profile.Items {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/account/profile/items/{itemId}`
        public let path: String
    }
}

extension Paths.Account.Profile.Items.WithItemID {
    public var next: Next {
        Next(path: path + "/next")
    }

    public struct Next {
        /// Path: `/account/profile/items/{itemId}/next`
        public let path: String

        /// Returns the next item to play given a source item id.
        /// 
        /// For an unwatched show it returns the first episode available to the account.
        /// 
        /// For a watched show it returns the last incompletely watched episode by the profile,
        /// or the episode that immediately follows the last completely watched episode 
        /// or nothing.
        /// 
        /// For an episode it always returns the immediately following episode, if available to
        /// the account, or nothing.
        /// 
        /// If the response does not contain a `next` property then no item was found.
        public func get(parameters: GetParameters? = nil) -> Request<RocketServicesAPI.NextPlaybackItem> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxRating: String?
            public var expand: Expand?
            public var device: String?
            public var sub: String?
            public var segments: [String]?
            public var ff: [Ff]?
            public var lang: String?

            public enum Expand: String, Codable, CaseIterable {
                case parent
                case ancestors
            }

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(maxRating: String? = nil, expand: Expand? = nil, device: String? = nil, sub: String? = nil, segments: [String]? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.maxRating = maxRating
                self.expand = expand
                self.device = device
                self.sub = sub
                self.segments = segments
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(maxRating, forKey: "max_rating")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(device, forKey: "device")
                encoder.encode(sub, forKey: "sub")
                encoder.encode(segments, forKey: "segments", explode: false)
                encoder.encode(ff, forKey: "ff", explode: false)
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths.Account.Profile.Items.WithItemID {
    public var previous: Previous {
        Previous(path: path + "/previous")
    }

    public struct Previous {
        /// Path: `/account/profile/items/{itemId}/previous`
        public let path: String

        /// Returns the previous item to play given a source item id.
        /// 
        /// For episode/special it returns the previous episode/special from current season,
        /// or from previous nearest season where available episode/special is found.
        /// or nothing.
        /// 
        /// If the response does not contain a `previous` property then no item was found.
        public func get(parameters: GetParameters? = nil) -> Request<RocketServicesAPI.NextPlaybackItem> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxRating: String?
            public var expand: Expand?
            public var device: String?
            public var sub: String?
            public var segments: [String]?
            public var ff: [Ff]?
            public var lang: String?

            public enum Expand: String, Codable, CaseIterable {
                case parent
                case ancestors
            }

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(maxRating: String? = nil, expand: Expand? = nil, device: String? = nil, sub: String? = nil, segments: [String]? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.maxRating = maxRating
                self.expand = expand
                self.device = device
                self.sub = sub
                self.segments = segments
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(maxRating, forKey: "max_rating")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(device, forKey: "device")
                encoder.encode(sub, forKey: "sub")
                encoder.encode(segments, forKey: "segments", explode: false)
                encoder.encode(ff, forKey: "ff", explode: false)
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths.Account.Profile {
    public var ratings: Ratings {
        Ratings(path: path + "/ratings")
    }

    public struct Ratings {
        /// Path: `/account/profile/ratings`
        public let path: String

        /// Get the map of rated item ids (itemId => rating out of 10) under the active profile.
        public func get(ff: [Ff]? = nil, lang: String? = nil) -> Request<[String: Int]> {
            .get(path, query: makeGetQuery(ff, lang))
        }

        private func makeGetQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths.Account.Profile.Ratings {
    public var list: List {
        List(path: path + "/list")
    }

    public struct List {
        /// Path: `/account/profile/ratings/list`
        public let path: String

        /// Returns the list of rated items under the active profile.
        public func get(parameters: GetParameters? = nil) -> Request<RocketServicesAPI.ItemList> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var page: Int?
            public var pageSize: Int?
            public var order: Order?
            public var orderBy: OrderBy?
            public var itemType: ItemType?
            public var device: String?
            public var sub: String?
            public var segments: [String]?
            public var ff: [Ff]?
            public var lang: String?

            public enum Order: String, Codable, CaseIterable {
                case asc
                case desc
            }

            public enum OrderBy: String, Codable, CaseIterable {
                case dateAdded = "date-added"
                case dateModified = "date-modified"
            }

            public enum ItemType: String, Codable, CaseIterable {
                case movie
                case show
                case season
                case episode
                case program
                case link
                case trailer
                case channel
                case customAsset
            }

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(page: Int? = nil, pageSize: Int? = nil, order: Order? = nil, orderBy: OrderBy? = nil, itemType: ItemType? = nil, device: String? = nil, sub: String? = nil, segments: [String]? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.page = page
                self.pageSize = pageSize
                self.order = order
                self.orderBy = orderBy
                self.itemType = itemType
                self.device = device
                self.sub = sub
                self.segments = segments
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(page, forKey: "page")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(order, forKey: "order")
                encoder.encode(orderBy, forKey: "order_by")
                encoder.encode(itemType, forKey: "item_type")
                encoder.encode(device, forKey: "device")
                encoder.encode(sub, forKey: "sub")
                encoder.encode(segments, forKey: "segments", explode: false)
                encoder.encode(ff, forKey: "ff", explode: false)
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths.Account.Profile.Ratings {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/account/profile/ratings/{itemId}`
        public let path: String

        /// Get the rating info for an item under the active profile.
        public func get(ff: [Ff]? = nil, lang: String? = nil) -> Request<RocketServicesAPI.UserRating> {
            .get(path, query: makeGetQuery(ff, lang))
        }

        private func makeGetQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }

        /// Rate an item under the active profile.
        /// 
        /// Creates one if it doesn't exist, overwrites one if it does.
        public func put(parameters: PutParameters) -> Request<RocketServicesAPI.UserRating> {
            .put(path, query: parameters.asQuery)
        }

        public struct PutParameters {
            public var rating: Int
            public var ff: [Ff]?
            public var lang: String?

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(rating: Int, ff: [Ff]? = nil, lang: String? = nil) {
                self.rating = rating
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(rating, forKey: "rating")
                encoder.encode(ff, forKey: "ff", explode: false)
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths.Account.Profile {
    public var watched: Watched {
        Watched(path: path + "/watched")
    }

    public struct Watched {
        /// Path: `/account/profile/watched`
        public let path: String

        /// Get the map of watched item ids (itemId => last playhead position) under the active profile.
        public func get(ff: [Ff]? = nil, lang: String? = nil) -> Request<[String: RocketServicesAPI.Watched]> {
            .get(path, query: makeGetQuery(ff, lang))
        }

        private func makeGetQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }

        /// Remove the watched status of items under the active profile. Passing in
        /// specific `itemId`s to the `item_ids` query parameter will cause only these
        /// items to be removed. **If this list is missing all watched items will be
        /// removed**
        public func delete(parameters: DeleteParameters? = nil) -> Request<Void> {
            .delete(path, query: parameters?.asQuery)
        }

        public struct DeleteParameters {
            public var itemIDs: [String]?
            public var ff: [Ff]?
            public var lang: String?

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(itemIDs: [String]? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.itemIDs = itemIDs
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(itemIDs, forKey: "item_ids")
                encoder.encode(ff, forKey: "ff")
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths.Account.Profile.Watched {
    public var list: List {
        List(path: path + "/list")
    }

    public struct List {
        /// Path: `/account/profile/watched/list`
        public let path: String

        /// Returns the list of watched items under the active profile.
        public func get(parameters: GetParameters? = nil) -> Request<RocketServicesAPI.ItemList> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var page: Int?
            public var pageSize: Int?
            public var isCompleted: Bool?
            public var order: Order?
            public var orderBy: OrderBy?
            public var itemType: ItemType?
            public var device: String?
            public var sub: String?
            public var segments: [String]?
            public var ff: [Ff]?
            public var lang: String?

            public enum Order: String, Codable, CaseIterable {
                case asc
                case desc
            }

            public enum OrderBy: String, Codable, CaseIterable {
                case dateAdded = "date-added"
                case dateModified = "date-modified"
            }

            public enum ItemType: String, Codable, CaseIterable {
                case movie
                case show
                case season
                case episode
                case program
                case link
                case trailer
                case channel
                case customAsset
            }

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(page: Int? = nil, pageSize: Int? = nil, isCompleted: Bool? = nil, order: Order? = nil, orderBy: OrderBy? = nil, itemType: ItemType? = nil, device: String? = nil, sub: String? = nil, segments: [String]? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.page = page
                self.pageSize = pageSize
                self.isCompleted = isCompleted
                self.order = order
                self.orderBy = orderBy
                self.itemType = itemType
                self.device = device
                self.sub = sub
                self.segments = segments
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(page, forKey: "page")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(isCompleted, forKey: "completed")
                encoder.encode(order, forKey: "order")
                encoder.encode(orderBy, forKey: "order_by")
                encoder.encode(itemType, forKey: "item_type")
                encoder.encode(device, forKey: "device")
                encoder.encode(sub, forKey: "sub")
                encoder.encode(segments, forKey: "segments", explode: false)
                encoder.encode(ff, forKey: "ff", explode: false)
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths.Account.Profile.Watched {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/account/profile/watched/{itemId}`
        public let path: String

        /// Get the watched status info for an item under the active profile.
        public func get(ff: [Ff]? = nil, lang: String? = nil) -> Request<RocketServicesAPI.Watched> {
            .get(path, query: makeGetQuery(ff, lang))
        }

        private func makeGetQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }

        /// Record the watched playhead position of a video under the active profile.
        /// 
        /// Can be used later to resume a video from where it was last watched.
        /// 
        /// Creates one if it doesn't exist, overwrites one if it does.
        public func put(parameters: PutParameters) -> Request<RocketServicesAPI.Watched> {
            .put(path, query: parameters.asQuery)
        }

        public struct PutParameters {
            public var position: Int
            public var ff: [Ff]?
            public var lang: String?

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(position: Int, ff: [Ff]? = nil, lang: String? = nil) {
                self.position = position
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(position, forKey: "position")
                encoder.encode(ff, forKey: "ff", explode: false)
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths.Account {
    public var profiles: Profiles {
        Profiles(path: path + "/profiles")
    }

    public struct Profiles {
        /// Path: `/account/profiles`
        public let path: String

        /// Create a new profile under the active account.
        public func post(ff: [Ff]? = nil, lang: String? = nil, _ body: RocketServicesAPI.ProfileCreationRequest) -> Request<RocketServicesAPI.ProfileDetail> {
            .post(path, query: makePostQuery(ff, lang), body: body)
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths.Account.Profiles {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/account/profiles/{id}`
        public let path: String

        /// Get the summary of a profile with a specific id under the active account.
        public func get(ff: [Ff]? = nil, lang: String? = nil) -> Request<RocketServicesAPI.ProfileSummary> {
            .get(path, query: makeGetQuery(ff, lang))
        }

        private func makeGetQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }

        /// Update the summary of a profile with a specific id under the active account.
        /// 
        /// This supports partial updates so you can send just the properties you wish to update.
        public func patch(ff: [Ff]? = nil, lang: String? = nil, _ body: RocketServicesAPI.ProfileUpdateRequest) -> Request<Void> {
            .patch(path, query: makePatchQuery(ff, lang), body: body)
        }

        private func makePatchQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        /// Delete a profile with a specific id under the active account.
        /// 
        /// Note that you cannot delete the primary profile.
        public func delete(ff: [Ff]? = nil, lang: String? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(ff, lang))
        }

        private func makeDeleteQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Account {
    public var requestEmailVerification: RequestEmailVerification {
        RequestEmailVerification(path: path + "/request-email-verification")
    }

    public struct RequestEmailVerification {
        /// Path: `/account/request-email-verification`
        public let path: String

        /// Request that the email address tied to an account be verified.
        /// 
        /// This will send a verification email to the email address of the primary profile containing
        /// a link which, once clicked, completes the verification process via the /verify-email endpoint.
        /// 
        /// Note that when an account is created this email is sent automatically so there's no need
        /// to call this directly.
        /// 
        /// If the user doesn't click the link before it expires then this endpoint can be called
        /// to request a new verification email. In the future it may also be used if we add support
        /// for changing an account email address.
        public func post(ff: [Ff]? = nil, lang: String? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(ff, lang))
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths {
    public static var authorization: Authorization {
        Authorization(path: "/authorization")
    }

    public struct Authorization {
        /// Path: `/authorization`
        public let path: String

        /// Request one or more `Account` level authorization tokens each with a chosen scope.
        /// 
        /// Tokens are used to access restricted service endpoints. These restricted endpoints
        /// will require a specific token type (e.g Account) with a specific scope (e.g. Catalog)
        /// before access is granted.
        /// 
        /// For convenience, where a Profile level token with the same scope exists it will also be returned.
        /// 
        /// Authorization with pin is not supported on this endpoint anymore. Use `/itv/pinauthorization`
        /// endpoint instead.
        public func post(ff: [Ff]? = nil, lang: String? = nil, _ body: RocketServicesAPI.AccountTokenRequest) -> Request<[RocketServicesAPI.AccessToken]> {
            .post(path, query: makePostQuery(ff, lang), body: body)
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }

        /// When a user signs out of an application we need to clear some
        /// basic cookies we assigned them during token authorization.
        public func delete(ff: [Ff]? = nil, lang: String? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(ff, lang))
        }

        private func makeDeleteQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Authorization {
    public var device: Device {
        Device(path: path + "/device")
    }

    public struct Device {
        /// Path: `/authorization/device`
        public let path: String

        /// Get Catalog tokens for an account using a device authorization code.
        /// Where a Profile level token of Catalog scope exists it will also be returned.
        /// 
        /// This is the final step in the process of authorizing a device by pin code.
        /// 
        /// Firstly the device must request a generated authorization code via the
        /// `/authorization/device/code` endpoint.
        /// 
        /// The code is subsequently used to authorize the device to sign in to a given
        /// account via the `/account/devices/authorization` endpoint. Typically this
        /// will be from a page presented in the web app under the account section.
        /// 
        /// Once authorized, this endpoint will allow the device to sign in without
        /// needing to provide the credentials of the user.
        public func post(ff: [Ff]? = nil, lang: String? = nil, _ body: RocketServicesAPI.AccountTokenByCodeRequest) -> Request<[RocketServicesAPI.AccessToken]> {
            .post(path, query: makePostQuery(ff, lang), body: body)
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths.Authorization.Device {
    public var code: Code {
        Code(path: path + "/code")
    }

    public struct Code {
        /// Path: `/authorization/device/code`
        public let path: String

        /// Get a generated device authorization code.
        /// 
        /// This is the first step in the process of authorizing a device by pin code.
        /// The device will make a request to this endpoint providing a unique identifier
        /// for the device such as a serial number. This endpoint will then return a
        /// generated code which is tied to the given device.
        /// 
        /// The code may subsequently be used to authorize the device to sign in to an
        /// account via the `/account/devices/authorization` endpoint. Typically this
        /// will be from a page presented in the web app under the account section.
        /// 
        /// Once authorized, the device will then be able to sign in to that account
        /// via the `/authorization/device` endpoint, without needing to provide the 
        /// credentials of the user.
        public func post(ff: [Ff]? = nil, lang: String? = nil, _ body: RocketServicesAPI.DeviceRegistrationRequest) -> Request<RocketServicesAPI.DeviceAuthorizationCode> {
            .post(path, query: makePostQuery(ff, lang), body: body)
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths.Authorization {
    public var profile: Profile {
        Profile(path: path + "/profile")
    }

    public struct Profile {
        /// Path: `/authorization/profile`
        public let path: String

        /// Request one or more `Profile` level authorization tokens each with a chosen scope.
        /// 
        /// Tokens are used to access restricted service endpoints. These restriced endpoints
        /// will require a specific token type (e.g Profile) with a specific scope (e.g. Catalog)
        /// before access is granted.
        public func post(ff: [Ff]? = nil, lang: String? = nil, _ body: RocketServicesAPI.ProfileTokenRequest) -> Request<[RocketServicesAPI.AccessToken]> {
            .post(path, query: makePostQuery(ff, lang), body: body)
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths.Authorization {
    public var refresh: Refresh {
        Refresh(path: path + "/refresh")
    }

    public struct Refresh {
        /// Path: `/authorization/refresh`
        public let path: String

        /// Refresh an account or profile level authorization token which is marked as refreshable.
        public func post(ff: [Ff]? = nil, lang: String? = nil, _ body: RocketServicesAPI.TokenRefreshRequest) -> Request<RocketServicesAPI.AccessToken> {
            .post(path, query: makePostQuery(ff, lang), body: body)
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths.Authorization {
    public var sso: Sso {
        Sso(path: path + "/sso")
    }

    public struct Sso {
        /// Path: `/authorization/sso`
        public let path: String

        /// Exchange a third party single-sign-on token for our own authorization tokens.
        public func post(ff: [Ff]? = nil, lang: String? = nil, _ body: RocketServicesAPI.SingleSignOnRequest) -> Request<[RocketServicesAPI.AccessToken]> {
            .post(path, query: makePostQuery(ff, lang), body: body)
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths {
    public static var bt: Bt {
        Bt(path: "/bt")
    }

    public struct Bt {
        /// Path: `/bt`
        public let path: String
    }
}

extension Paths.Bt {
    public var plan: Plan {
        Plan(path: path + "/plan")
    }

    public struct Plan {
        /// Path: `/bt/plan`
        public let path: String
    }
}

extension Paths.Bt.Plan {
    public func token(_ token: String) -> WithToken {
        WithToken(path: "\(path)/\(token)")
    }

    public struct WithToken {
        /// Path: `/bt/plan/{token}`
        public let path: String

        /// Returns all the plans available for BT flow including additional description data.
        public func get(lang: String? = nil) -> Request<RocketServicesAPI.BtPlanListItem> {
            .get(path, query: makeGetQuery(lang))
        }

        private func makeGetQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Bt {
    public var plans: Plans {
        Plans(path: path + "/plans")
    }

    public struct Plans {
        /// Path: `/bt/plans`
        public let path: String

        /// Returns all the plans available for BT flow including additional description data.
        public func get(lang: String? = nil) -> Request<RocketServicesAPI.BtPlans> {
            .get(path, query: makeGetQuery(lang))
        }

        private func makeGetQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Bt {
    public var token: Token {
        Token(path: path + "/token")
    }

    public struct Token {
        /// Path: `/bt/token`
        public let path: String
    }
}

extension Paths.Bt.Token {
    public var assign: Assign {
        Assign(path: path + "/assign")
    }

    public struct Assign {
        /// Path: `/bt/token/assign`
        public let path: String

        /// Assigns an UserToken to a profile on the ITV side. Currently throws an exception.
        public func post(lang: String? = nil, _ body: Data) -> Request<Void> {
            .post(path, query: makePostQuery(lang), body: body)
        }

        private func makePostQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Bt.Token {
    public var validate: Validate {
        Validate(path: path + "/validate")
    }

    public struct Validate {
        /// Path: `/bt/token/validate`
        public let path: String

        /// Checks a provided token for BT eligible user.
        public func get(ff: [Ff]? = nil, lang: String? = nil) -> Request<Void> {
            .get(path, query: makeGetQuery(ff, lang))
        }

        private func makeGetQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths {
    public static var checkSubscription: CheckSubscription {
        CheckSubscription(path: "/check-subscription")
    }

    public struct CheckSubscription {
        /// Path: `/check-subscription`
        public let path: String
    }
}

extension Paths.CheckSubscription {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/check-subscription/{id}`
        public let path: String

        /// Returns the details of subscription data for a user with specified id.
        public var get: Request<RocketServicesAPI.SubscriptionDetails> {
            .get(path)
        }
    }
}

extension Paths {
    public static var config: Config {
        Config(path: "/config")
    }

    public struct Config {
        /// Path: `/config`
        public let path: String

        /// Get the global configuration for an application. Should be called during app statup.
        /// 
        /// This includes things like device and playback rules, classifications,
        /// sitemap and subscriptions.
        /// 
        /// You have the option to select specific configuration objects using the 'include'
        /// parameter, or if unspecified, getting all configuration.
        public func get(parameters: GetParameters? = nil) -> Request<RocketServicesAPI.AppConfig> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var include: [Include]?
            public var system: String?
            public var device: String?
            public var sub: String?
            public var segments: [String]?
            public var ff: [Ff]?
            public var lang: String?

            public enum Include: String, Codable, CaseIterable {
                case classification
                case playback
                case sitemap
                case navigation
                case subscription
                case general
                case display
                case i18n
                case linear
            }

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(include: [Include]? = nil, system: String? = nil, device: String? = nil, sub: String? = nil, segments: [String]? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.include = include
                self.system = system
                self.device = device
                self.sub = sub
                self.segments = segments
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(include, forKey: "include")
                encoder.encode(system, forKey: "system")
                encoder.encode(device, forKey: "device")
                encoder.encode(sub, forKey: "sub")
                encoder.encode(segments, forKey: "segments")
                encoder.encode(ff, forKey: "ff")
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var ee: Ee {
        Ee(path: "/ee")
    }

    public struct Ee {
        /// Path: `/ee`
        public let path: String
    }
}

extension Paths.Ee {
    public var msisdn: Msisdn {
        Msisdn(path: path + "/msisdn")
    }

    public struct Msisdn {
        /// Path: `/ee/msisdn`
        public let path: String

        /// Assigns a msisdn to a profile on ITV side.
        public func post(lang: String? = nil, _ body: Data) -> Request<Void> {
            .post(path, query: makePostQuery(lang), body: body)
        }

        private func makePostQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Ee {
    public var offers: Offers {
        Offers(path: path + "/offers")
    }

    public struct Offers {
        /// Path: `/ee/offers`
        public let path: String

        /// Returns eligible partner specific offers for the querying partner for an EE MSISDN.
        /// This call is supposed to be called after we have MSISDN accired.
        /// This call should be followed by POST /ee/msisdn.
        public func post(ff: [Ff]? = nil, lang: String? = nil, _ body: Data) -> Request<RocketServicesAPI.EeOffersResponse> {
            .post(path, query: makePostQuery(ff, lang), body: body)
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths.Ee {
    public var pin: Pin {
        Pin(path: path + "/pin")
    }

    public struct Pin {
        /// Path: `/ee/pin`
        public let path: String

        /// Validate PIN request created by calling POST /ee/pin This call is to validate MSISDN entered by a user not comming through EE network. This call should be called after PUT /ee/pin. This call should be followed by POST /ee/offers.
        public func post(ff: [Ff]? = nil, lang: String? = nil, _ body: Data) -> Request<RocketServicesAPI.EeValidatePinResponse> {
            .post(path, query: makePostQuery(ff, lang), body: body)
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }

        /// Creates a PIN request that will send an SMS to the given msisdn.
        /// This call is to validate MSISDN entered by a user not comming through EE network.
        /// This call should be followed by POST ee/pin.
        public func put(ff: [Ff]? = nil, lang: String? = nil, _ body: Data) -> Request<RocketServicesAPI.EeCreatePinResponse> {
            .put(path, query: makePutQuery(ff, lang), body: body)
        }

        private func makePutQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Ee {
    public var plans: Plans {
        Plans(path: path + "/plans")
    }

    public struct Plans {
        /// Path: `/ee/plans`
        public let path: String

        /// Returns all the plans available for EE flow including additional description data.
        public func get(lang: String? = nil) -> Request<RocketServicesAPI.EePlans> {
            .get(path, query: makeGetQuery(lang))
        }

        private func makeGetQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Ee.Plans {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/ee/plans/{id}`
        public let path: String

        /// Returns the plan description for EE flow including additional description data.
        public func get(lang: String? = nil) -> Request<RocketServicesAPI.EePlanListItem> {
            .get(path, query: makeGetQuery(lang))
        }

        private func makeGetQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Ee {
    public var token: Token {
        Token(path: path + "/token")
    }

    public struct Token {
        /// Path: `/ee/token`
        public let path: String
    }
}

extension Paths.Ee.Token {
    public var create: Create {
        Create(path: path + "/create")
    }

    public struct Create {
        /// Path: `/ee/token/create`
        public let path: String

        /// Returns a token for later calls to EE API. TTL is one hour. Recommended is FE refreshes this token before each call.
        public var get: Request<RocketServicesAPI.EeCreateTokenResponse> {
            .get(path)
        }
    }
}

extension Paths {
    public static var eeBt: EeBt {
        EeBt(path: "/ee-bt")
    }

    public struct EeBt {
        /// Path: `/ee-bt`
        public let path: String
    }
}

extension Paths.EeBt {
    public var eligibility: Eligibility {
        Eligibility(path: path + "/eligibility")
    }

    public struct Eligibility {
        /// Path: `/ee-bt/eligibility`
        public let path: String

        /// Check whether or not a user is eligible for switching to Bt or EE offers.
        public func get(lang: String? = nil) -> Request<RocketServicesAPI.EeBtEligibility> {
            .get(path, query: makeGetQuery(lang))
        }

        private func makeGetQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths {
    public static var items: Items {
        Items(path: "/items")
    }

    public struct Items {
        /// Path: `/items`
        public let path: String
    }
}

extension Paths.Items {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/items/{id}`
        public let path: String

        /// Returns the details of an item with the specified id.
        public func get(parameters: GetParameters? = nil) -> Request<RocketServicesAPI.ItemDetail> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxRating: String?
            public var expand: Expand?
            public var selectSeason: SelectSeason?
            public var useCustomID: Bool?
            public var device: String?
            public var sub: String?
            public var segments: [String]?
            public var ff: [Ff]?
            public var lang: String?

            public enum Expand: String, Codable, CaseIterable {
                case all
                case children
                case ancestors
                case parent
            }

            public enum SelectSeason: String, Codable, CaseIterable {
                case first
                case latest
            }

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(maxRating: String? = nil, expand: Expand? = nil, selectSeason: SelectSeason? = nil, useCustomID: Bool? = nil, device: String? = nil, sub: String? = nil, segments: [String]? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.maxRating = maxRating
                self.expand = expand
                self.selectSeason = selectSeason
                self.useCustomID = useCustomID
                self.device = device
                self.sub = sub
                self.segments = segments
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(maxRating, forKey: "max_rating")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(selectSeason, forKey: "select_season")
                encoder.encode(useCustomID, forKey: "use_custom_id")
                encoder.encode(device, forKey: "device")
                encoder.encode(sub, forKey: "sub")
                encoder.encode(segments, forKey: "segments", explode: false)
                encoder.encode(ff, forKey: "ff", explode: false)
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths.Items.WithID {
    public var children: Children {
        Children(path: path + "/children")
    }

    public struct Children {
        /// Path: `/items/{id}/children`
        public let path: String

        /// Returns the List of child summary items under an item.
        /// 
        /// If the item is a Season then the children will be episodes and ordered by episode number.
        /// 
        /// If the item is a Show then the children will be Seasons and ordered by season number.
        /// 
        /// Returns 404 if no children found.
        public func get(parameters: GetParameters? = nil) -> Request<RocketServicesAPI.ItemList> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var page: Int?
            public var pageSize: Int?
            public var maxRating: String?
            public var order: Order?
            public var device: String?
            public var sub: String?
            public var segments: [String]?
            public var ff: [Ff]?
            public var lang: String?

            public enum Order: String, Codable, CaseIterable {
                case asc
                case desc
            }

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(page: Int? = nil, pageSize: Int? = nil, maxRating: String? = nil, order: Order? = nil, device: String? = nil, sub: String? = nil, segments: [String]? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.page = page
                self.pageSize = pageSize
                self.maxRating = maxRating
                self.order = order
                self.device = device
                self.sub = sub
                self.segments = segments
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(page, forKey: "page")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(maxRating, forKey: "max_rating")
                encoder.encode(order, forKey: "order")
                encoder.encode(device, forKey: "device")
                encoder.encode(sub, forKey: "sub")
                encoder.encode(segments, forKey: "segments", explode: false)
                encoder.encode(ff, forKey: "ff", explode: false)
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths.Items.WithID {
    public var related: Related {
        Related(path: path + "/related")
    }

    public struct Related {
        /// Path: `/items/{id}/related`
        public let path: String

        /// Returns the list of items related to the parent item.
        /// 
        /// Note for now, due to the size of the list being unknown, only a single page will be returned.
        public func get(parameters: GetParameters? = nil) -> Request<RocketServicesAPI.ItemList> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var page: Int?
            public var pageSize: Int?
            public var maxRating: String?
            public var device: String?
            public var sub: String?
            public var segments: [String]?
            public var ff: [Ff]?
            public var lang: String?

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(page: Int? = nil, pageSize: Int? = nil, maxRating: String? = nil, device: String? = nil, sub: String? = nil, segments: [String]? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.page = page
                self.pageSize = pageSize
                self.maxRating = maxRating
                self.device = device
                self.sub = sub
                self.segments = segments
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(page, forKey: "page")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(maxRating, forKey: "max_rating")
                encoder.encode(device, forKey: "device")
                encoder.encode(sub, forKey: "sub")
                encoder.encode(segments, forKey: "segments")
                encoder.encode(ff, forKey: "ff")
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths.Items.WithID {
    public var videos: Videos {
        Videos(path: path + "/videos")
    }

    public struct Videos {
        /// Path: `/items/{id}/videos`
        public let path: String

        /// Get the free / public video files associated with an item given maximum resolution,
        /// device type and one or more delivery types.
        /// 
        /// Returns an array of video file objects which each include a url to a video.
        /// 
        /// The first entry in the array contains what is predicted to be the best match.
        /// The remainder of the entries, if any, may contain resolutions below what was
        /// requests. For example if you request HD-720 the response may also contain
        /// SD entries.
        /// 
        /// If you specify multiple delivery types, then the response array will insert
        /// types in the order you specify them in the query. For example `stream,progressive`
        /// would return an array with 0 or more stream files followed by 0 or more progressive files.
        /// 
        /// If no files are found a 404 is returned.
        public func get(parameters: GetParameters) -> Request<[RocketServicesAPI.MediaFile]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var delivery: [Delivery]
            public var resolution: Resolution
            public var formats: [Formats]?
            public var device: String?
            public var sub: String?
            public var segments: [String]?
            public var ff: [Ff]?
            public var lang: String?

            public enum Delivery: String, Codable, CaseIterable {
                case stream
                case progressive
                case download
            }

            public enum Resolution: String, Codable, CaseIterable {
                case hd4k = "HD-4K"
                case hd1080 = "HD-1080"
                case hd720 = "HD-720"
                case sd = "SD"
                case external = "External"
            }

            public enum Formats: String, Codable, CaseIterable {
                case mp4
                case mpd
                case hls
                case external
            }

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(delivery: [Delivery], resolution: Resolution, formats: [Formats]? = nil, device: String? = nil, sub: String? = nil, segments: [String]? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.delivery = delivery
                self.resolution = resolution
                self.formats = formats
                self.device = device
                self.sub = sub
                self.segments = segments
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(delivery, forKey: "delivery", explode: false)
                encoder.encode(resolution, forKey: "resolution")
                encoder.encode(formats, forKey: "formats", explode: false)
                encoder.encode(device, forKey: "device")
                encoder.encode(sub, forKey: "sub")
                encoder.encode(segments, forKey: "segments", explode: false)
                encoder.encode(ff, forKey: "ff", explode: false)
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths.Items {
    public func itemID(_ itemID: String) -> WithItemID {
        WithItemID(path: "\(path)/\(itemID)")
    }

    public struct WithItemID {
        /// Path: `/items/{itemId}`
        public let path: String
    }
}

extension Paths.Items.WithItemID {
    public var next: Next {
        Next(path: path + "/next")
    }

    public struct Next {
        /// Path: `/items/{itemId}/next`
        public let path: String

        /// Identical to GET /account/profile/items/{itemId}/next route but for users
        /// that are not logged in i.e. this endpoint does not require authorisation
        public func get(parameters: GetParameters? = nil) -> Request<RocketServicesAPI.NextPlaybackItem> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var maxRating: String?
            public var expand: Expand?
            public var device: String?
            public var segments: [String]?
            public var ff: [Ff]?
            public var lang: String?

            public enum Expand: String, Codable, CaseIterable {
                case parent
                case ancestors
            }

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(maxRating: String? = nil, expand: Expand? = nil, device: String? = nil, segments: [String]? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.maxRating = maxRating
                self.expand = expand
                self.device = device
                self.segments = segments
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(maxRating, forKey: "max_rating")
                encoder.encode(expand, forKey: "expand")
                encoder.encode(device, forKey: "device")
                encoder.encode(segments, forKey: "segments", explode: false)
                encoder.encode(ff, forKey: "ff", explode: false)
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var itv: Itv {
        Itv(path: "/itv")
    }

    public struct Itv {
        /// Path: `/itv`
        public let path: String
    }
}

extension Paths.Itv {
    public var billinghistory: Billinghistory {
        Billinghistory(path: path + "/billinghistory")
    }

    public struct Billinghistory {
        /// Path: `/itv/billinghistory`
        public let path: String
    }
}

extension Paths.Itv.Billinghistory {
    public func platform(_ platform: String) -> WithPlatform {
        WithPlatform(path: "\(path)/\(platform)")
    }

    public struct WithPlatform {
        /// Path: `/itv/billinghistory/{platform}`
        public let path: String

        /// Returns the list of billing records for specified payment platform.
        public func post(lang: String? = nil, _ body: Data) -> Request<RocketServicesAPI.ItvBillingHistory> {
            .post(path, query: makePostQuery(lang), body: body)
        }

        private func makePostQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv {
    public var cards: Cards {
        Cards(path: path + "/cards")
    }

    public struct Cards {
        /// Path: `/itv/cards`
        public let path: String
    }
}

extension Paths.Itv.Cards {
    public func platform(_ platform: String) -> WithPlatform {
        WithPlatform(path: "\(path)/\(platform)")
    }

    public struct WithPlatform {
        /// Path: `/itv/cards/{platform}`
        public let path: String

        /// Get payment card details.
        public func post(lang: String? = nil, _ body: Data) -> Request<RocketServicesAPI.ItvCardDetails> {
            .post(path, query: makePostQuery(lang), body: body)
        }

        private func makePostQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        /// Change payment card details.
        public func put(lang: String? = nil, _ body: Data) -> Request<Void> {
            .put(path, query: makePutQuery(lang), body: body)
        }

        private func makePutQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv {
    public var changeemail: Changeemail {
        Changeemail(path: path + "/changeemail")
    }

    public struct Changeemail {
        /// Path: `/itv/changeemail`
        public let path: String

        /// Change email address related to account/profile.
        /// 
        /// The expected token scope is Settings.
        public func post(ff: [Ff]? = nil, lang: String? = nil, _ body: Data) -> Request<Void> {
            .post(path, query: makePostQuery(ff, lang), body: body)
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths.Itv {
    public var changemarketing: Changemarketing {
        Changemarketing(path: path + "/changemarketing")
    }

    public struct Changemarketing {
        /// Path: `/itv/changemarketing`
        public let path: String

        /// Change marketing preferences related to account/profile.
        /// 
        /// The expected token scope is Settings.
        public func post(ff: [Ff]? = nil, lang: String? = nil, _ body: Data) -> Request<Void> {
            .post(path, query: makePostQuery(ff, lang), body: body)
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths.Itv {
    public var deleteaccount: Deleteaccount {
        Deleteaccount(path: path + "/deleteaccount")
    }

    public struct Deleteaccount {
        /// Path: `/itv/deleteaccount`
        public let path: String

        /// Delete account in compliance with GDPR.
        /// 
        /// The expected token scope is Settings.
        public func post(ff: [Ff]? = nil, lang: String? = nil, _ body: Data) -> Request<Void> {
            .post(path, query: makePostQuery(ff, lang), body: body)
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths.Itv {
    public var entitlements: Entitlements {
        Entitlements(path: path + "/entitlements")
    }

    public struct Entitlements {
        /// Path: `/itv/entitlements`
        public let path: String
    }
}

extension Paths.Itv.Entitlements {
    public var current: Current {
        Current(path: path + "/current")
    }

    public struct Current {
        /// Path: `/itv/entitlements/current`
        public let path: String

        /// Returns current entitlement.
        public func get(lang: String? = nil) -> Request<RocketServicesAPI.ItvEntitlementCurrent> {
            .get(path, query: makeGetQuery(lang))
        }

        private func makeGetQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv.Entitlements {
    public var history: History {
        History(path: path + "/history")
    }

    public struct History {
        /// Path: `/itv/entitlements/history`
        public let path: String

        /// Returns the state of subscription for any payment platform.
        public func get(lang: String? = nil) -> Request<RocketServicesAPI.ItvEntitlementsHistory> {
            .get(path, query: makeGetQuery(lang))
        }

        private func makeGetQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv {
    public var featureFlag: FeatureFlag {
        FeatureFlag(path: path + "/featureFlag")
    }

    public struct FeatureFlag {
        /// Path: `/itv/featureFlag`
        public let path: String
    }
}

extension Paths.Itv.FeatureFlag {
    public func feature(_ feature: String) -> WithFeature {
        WithFeature(path: "\(path)/\(feature)")
    }

    public struct WithFeature {
        /// Path: `/itv/featureFlag/{feature}`
        public let path: String

        /// Gets info whether or not a feature is enabled or disabled using a feature flag. Feature flags are set as a custom field within PM. It also supports custom feature flag data if needed. Such data can be return as well.
        public func get(lang: String? = nil) -> Request<RocketServicesAPI.ItvFeatureFlag> {
            .get(path, query: makeGetQuery(lang))
        }

        private func makeGetQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv {
    public var googlepay: Googlepay {
        Googlepay(path: path + "/googlepay")
    }

    public struct Googlepay {
        /// Path: `/itv/googlepay`
        public let path: String
    }
}

extension Paths.Itv.Googlepay {
    public var subscription: Subscription {
        Subscription(path: path + "/subscription")
    }

    public struct Subscription {
        /// Path: `/itv/googlepay/subscription`
        public let path: String

        /// Get the list of recommended items under the active profile.
        public func post(lang: String? = nil, _ body: Data) -> Request<Void> {
            .post(path, query: makePostQuery(lang), body: body)
        }

        private func makePostQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv {
    public var had: Had {
        Had(path: path + "/had")
    }

    public struct Had {
        /// Path: `/itv/had`
        public let path: String
    }
}

extension Paths.Itv.Had {
    public var entitlements: Entitlements {
        Entitlements(path: path + "/entitlements")
    }

    public struct Entitlements {
        /// Path: `/itv/had/entitlements`
        public let path: String

        /// Check whether the user has been previously entitled.
        public func get(lang: String? = nil) -> Request<RocketServicesAPI.ItvHadEntitlement> {
            .get(path, query: makeGetQuery(lang))
        }

        private func makeGetQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv {
    public var items: Items {
        Items(path: path + "/items")
    }

    public struct Items {
        /// Path: `/itv/items`
        public let path: String
    }
}

extension Paths.Itv.Items {
    public var clips: Clips {
        Clips(path: path + "/clips")
    }

    public struct Clips {
        /// Path: `/itv/items/clips`
        public let path: String

        /// Get the media clip files associated with items.
        public func post(ff: [Ff]? = nil, lang: String? = nil, _ body: Data) -> Request<RocketServicesAPI.ItemClipFilesList> {
            .post(path, query: makePostQuery(ff, lang), body: body)
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths.Itv.Items {
    public var downloadable: Downloadable {
        Downloadable(path: path + "/downloadable")
    }

    public struct Downloadable {
        /// Path: `/itv/items/downloadable`
        public let path: String

        /// Returns the details of an item with the specified id.
        public func post(ff: [Ff]? = nil, lang: String? = nil, _ body: Data) -> Request<RocketServicesAPI.ItemDownloadableList> {
            .post(path, query: makePostQuery(ff, lang), body: body)
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths.Itv {
    public var itemsummary: Itemsummary {
        Itemsummary(path: path + "/itemsummary")
    }

    public struct Itemsummary {
        /// Path: `/itv/itemsummary`
        public let path: String
    }
}

extension Paths.Itv.Itemsummary {
    public func externalID(_ externalID: String) -> WithExternalID {
        WithExternalID(path: "\(path)/\(externalID)")
    }

    public struct WithExternalID {
        /// Path: `/itv/itemsummary/{externalId}`
        public let path: String

        /// Redirects to corresponding Axis Item details page.
        public var get: Request<Void> {
            .get(path)
        }
    }
}

extension Paths.Itv {
    public var page: Page {
        Page(path: path + "/page")
    }

    public struct Page {
        /// Path: `/itv/page`
        public let path: String

        /// Returns a page with the specified id.
        /// 
        /// This is a cut down version for low memory devices.123
        /// 
        /// If targeting the search page you must url encode the search term as a parameter
        /// using the `q` key. For example if your browser path looks like `/search?q=the`
        /// then what you pass to this endpoint would look like `/itv/page?path=/search%3Fq%3Dthe`.
        public func get(parameters: GetParameters) -> Request<RocketServicesAPI.Page> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var path: String
            public var listPageSize: Int?
            public var listPageSizeLarge: Int?
            public var maxListPrefetch: Int?
            public var itemDetailExpand: ItemDetailExpand?
            public var itemDetailSelectSeason: ItemDetailSelectSeason?
            public var textEntryFormat: TextEntryFormat?
            public var maxRating: String?
            public var device: String?
            public var sub: String?
            public var segments: [String]?
            public var ff: [Ff]?
            public var lang: String?

            public enum ItemDetailExpand: String, Codable, CaseIterable {
                case all
                case children
                case ancestors
            }

            public enum ItemDetailSelectSeason: String, Codable, CaseIterable {
                case first
                case latest
            }

            public enum TextEntryFormat: String, Codable, CaseIterable {
                case markdown
                case html
            }

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(path: String, listPageSize: Int? = nil, listPageSizeLarge: Int? = nil, maxListPrefetch: Int? = nil, itemDetailExpand: ItemDetailExpand? = nil, itemDetailSelectSeason: ItemDetailSelectSeason? = nil, textEntryFormat: TextEntryFormat? = nil, maxRating: String? = nil, device: String? = nil, sub: String? = nil, segments: [String]? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.path = path
                self.listPageSize = listPageSize
                self.listPageSizeLarge = listPageSizeLarge
                self.maxListPrefetch = maxListPrefetch
                self.itemDetailExpand = itemDetailExpand
                self.itemDetailSelectSeason = itemDetailSelectSeason
                self.textEntryFormat = textEntryFormat
                self.maxRating = maxRating
                self.device = device
                self.sub = sub
                self.segments = segments
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(path, forKey: "path")
                encoder.encode(listPageSize, forKey: "list_page_size")
                encoder.encode(listPageSizeLarge, forKey: "list_page_size_large")
                encoder.encode(maxListPrefetch, forKey: "max_list_prefetch")
                encoder.encode(itemDetailExpand, forKey: "item_detail_expand")
                encoder.encode(itemDetailSelectSeason, forKey: "item_detail_select_season")
                encoder.encode(textEntryFormat, forKey: "text_entry_format")
                encoder.encode(maxRating, forKey: "max_rating")
                encoder.encode(device, forKey: "device")
                encoder.encode(sub, forKey: "sub")
                encoder.encode(segments, forKey: "segments", explode: false)
                encoder.encode(ff, forKey: "ff", explode: false)
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths.Itv {
    public var pinauthorization: Pinauthorization {
        Pinauthorization(path: path + "/pinauthorization")
    }

    public struct Pinauthorization {
        /// Path: `/itv/pinauthorization`
        public let path: String

        /// Provides authorization with parental control pin.
        /// 
        /// Returns an array containing account token with Playback scope.
        /// 
        /// Requires access token with Catalog scope.
        /// 
        /// Pin must be a 4-digit string
        public func post(ff: [Ff]? = nil, lang: String? = nil, _ body: Data) -> Request<[RocketServicesAPI.AccessToken]> {
            .post(path, query: makePostQuery(ff, lang), body: body)
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths.Itv {
    public var plan: Plan {
        Plan(path: path + "/plan")
    }

    public struct Plan {
        /// Path: `/itv/plan`
        public let path: String
    }
}

extension Paths.Itv.Plan {
    public func platform(_ platform: String) -> WithPlatform {
        WithPlatform(path: "\(path)/\(platform)")
    }

    public struct WithPlatform {
        /// Path: `/itv/plan/{platform}`
        public let path: String

        /// Upgrades the plan for the current user.
        public func post(lang: String? = nil, _ body: Data) -> Request<Void> {
            .post(path, query: makePostQuery(lang), body: body)
        }

        private func makePostQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv {
    public var plans: Plans {
        Plans(path: path + "/plans")
    }

    public struct Plans {
        /// Path: `/itv/plans`
        public let path: String
    }
}

extension Paths.Itv.Plans {
    public func platform(_ platform: String) -> WithPlatform {
        WithPlatform(path: "\(path)/\(platform)")
    }

    public struct WithPlatform {
        /// Path: `/itv/plans/{platform}`
        public let path: String

        /// Returns the plans available for specified payment platform.
        public func get(lang: String? = nil) -> Request<RocketServicesAPI.ItvPlans> {
            .get(path, query: makeGetQuery(lang))
        }

        private func makeGetQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv {
    public var profile: Profile {
        Profile(path: path + "/profile")
    }

    public struct Profile {
        /// Path: `/itv/profile`
        public let path: String

        /// Returns the ITV profile object.
        public func get(lang: String? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(lang))
        }

        private func makeGetQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        /// Update ITV profile.
        /// 
        /// The expected token scope is Settings.
        public func put(ff: [Ff]? = nil, lang: String? = nil, _ body: Data) -> Request<Void> {
            .put(path, query: makePutQuery(ff, lang), body: body)
        }

        private func makePutQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths.Itv.Profile {
    public var recommendation: Recommendation {
        Recommendation(path: path + "/recommendation")
    }

    public struct Recommendation {
        /// Path: `/itv/profile/recommendation`
        public let path: String
    }
}

extension Paths.Itv.Profile.Recommendation {
    public var list: List {
        List(path: path + "/list")
    }

    public struct List {
        /// Path: `/itv/profile/recommendation/list`
        public let path: String

        /// Get the list of recommended items under the active profile.
        public func get(parameters: GetParameters? = nil) -> Request<RocketServicesAPI.ItemList> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var itemTypes: [String]?
            public var page: Int?
            public var pageSize: Int?
            public var recID: String?
            public var device: String?
            public var sub: String?
            public var segments: [String]?
            public var ff: [Ff]?
            public var lang: String?

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(itemTypes: [String]? = nil, page: Int? = nil, pageSize: Int? = nil, recID: String? = nil, device: String? = nil, sub: String? = nil, segments: [String]? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.itemTypes = itemTypes
                self.page = page
                self.pageSize = pageSize
                self.recID = recID
                self.device = device
                self.sub = sub
                self.segments = segments
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(itemTypes, forKey: "item_types")
                encoder.encode(page, forKey: "page")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(recID, forKey: "recId")
                encoder.encode(device, forKey: "device")
                encoder.encode(sub, forKey: "sub")
                encoder.encode(segments, forKey: "segments")
                encoder.encode(ff, forKey: "ff")
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths.Itv {
    public var profiletoken: Profiletoken {
        Profiletoken(path: path + "/profiletoken")
    }

    public struct Profiletoken {
        /// Path: `/itv/profiletoken`
        public let path: String

        /// Returns the ITV profile token.
        public func post(lang: String? = nil, _ body: Data) -> Request<RocketServicesAPI.ItvProfileToken> {
            .post(path, query: makePostQuery(lang), body: body)
        }

        private func makePostQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv {
    public var purchase: Purchase {
        Purchase(path: path + "/purchase")
    }

    public struct Purchase {
        /// Path: `/itv/purchase`
        public let path: String
    }
}

extension Paths.Itv.Purchase {
    public func platform(_ platform: String) -> WithPlatform {
        WithPlatform(path: "\(path)/\(platform)")
    }

    public struct WithPlatform {
        /// Path: `/itv/purchase/{platform}`
        public let path: String

        /// Returns the details of current subscription for specified payment platform.
        public func get(lang: String? = nil) -> Request<RocketServicesAPI.ItvCurrentSubscription> {
            .get(path, query: makeGetQuery(lang))
        }

        private func makeGetQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        /// Confirms purchase and returns the details of purchased subscription for specified payment platform.
        public func post(lang: String? = nil, _ body: Data) -> Request<RocketServicesAPI.ItvPurchase> {
            .post(path, query: makePostQuery(lang), body: body)
        }

        private func makePostQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        /// Cancel a plan subscription.
        /// 
        /// A cancelled subscription will continue to be valid until the subscription
        /// expiry date or next renewal date.
        public func delete(lang: String? = nil, _ body: Data) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(lang), body: body)
        }

        private func makeDeleteQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv.Purchase.WithPlatform {
    public var strong: Strong {
        Strong(path: path + "/strong")
    }

    public struct Strong {
        /// Path: `/itv/purchase/{platform}/strong`
        public let path: String

        /// Confirms purchase and returns the details of purchased subscription for specified payment platform.
        public func post(lang: String? = nil, _ body: Data) -> Request<RocketServicesAPI.ItvPurchaseStrongResponse> {
            .post(path, query: makePostQuery(lang), body: body)
        }

        private func makePostQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv.Purchase.WithPlatform {
    public var withoffer: Withoffer {
        Withoffer(path: path + "/withoffer")
    }

    public struct Withoffer {
        /// Path: `/itv/purchase/{platform}/withoffer`
        public let path: String

        /// Confirms purchase and returns the details of purchased subscription for specified payment platform.
        public func post(lang: String? = nil, _ body: Data) -> Request<RocketServicesAPI.ItvPurchaseWithOfferResponse> {
            .post(path, query: makePostQuery(lang), body: body)
        }

        private func makePostQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv {
    public var recommendations: Recommendations {
        Recommendations(path: path + "/recommendations")
    }

    public struct Recommendations {
        /// Path: `/itv/recommendations`
        public let path: String
    }
}

extension Paths.Itv.Recommendations {
    public var config: Config {
        Config(path: path + "/config")
    }

    public struct Config {
        /// Path: `/itv/recommendations/config`
        public let path: String

        /// Get the list of reccomendation configurations.
        public func get(lang: String? = nil) -> Request<RocketServicesAPI.ItvRecsConfigList> {
            .get(path, query: makeGetQuery(lang))
        }

        private func makeGetQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv {
    public var resubscribe: Resubscribe {
        Resubscribe(path: path + "/resubscribe")
    }

    public struct Resubscribe {
        /// Path: `/itv/resubscribe`
        public let path: String
    }
}

extension Paths.Itv.Resubscribe {
    public func platform(_ platform: String) -> WithPlatform {
        WithPlatform(path: "\(path)/\(platform)")
    }

    public struct WithPlatform {
        /// Path: `/itv/resubscribe/{platform}`
        public let path: String

        /// Resubscription for a user.
        public func post(planID: String, lang: String? = nil) -> Request<[String: AnyJSON]> {
            .post(path, query: makePostQuery(planID, lang))
        }

        private func makePostQuery(_ planID: String, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(planID, forKey: "planId")
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv {
    public var roku: Roku {
        Roku(path: path + "/roku")
    }

    public struct Roku {
        /// Path: `/itv/roku`
        public let path: String
    }
}

extension Paths.Itv.Roku {
    public var plans: Plans {
        Plans(path: path + "/plans")
    }

    public struct Plans {
        /// Path: `/itv/roku/plans`
        public let path: String

        /// Gets available Roku plans.
        public func get(lang: String? = nil) -> Request<RocketServicesAPI.RokuPlans> {
            .get(path, query: makeGetQuery(lang))
        }

        private func makeGetQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv.Roku {
    public var transaction: Transaction {
        Transaction(path: path + "/transaction")
    }

    public struct Transaction {
        /// Path: `/itv/roku/transaction`
        public let path: String
    }
}

extension Paths.Itv.Roku.Transaction {
    public func transactionid(_ transactionid: String) -> WithTransactionid {
        WithTransactionid(path: "\(path)/\(transactionid)")
    }

    public struct WithTransactionid {
        /// Path: `/itv/roku/transaction/{transactionid}`
        public let path: String

        /// Sends request to execute specified transaction.
        public func post(lang: String? = nil, _ body: Data) -> Request<Void> {
            .post(path, query: makePostQuery(lang), body: body)
        }

        private func makePostQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv {
    public var saveOffer: SaveOffer {
        SaveOffer(path: path + "/save-offer")
    }

    public struct SaveOffer {
        /// Path: `/itv/save-offer`
        public let path: String

        /// Checks the provided coupon id for a user. Only Stripe platform is currently supported.
        public func get(lang: String? = nil) -> Request<RocketServicesAPI.ItvGetDiscountResponse> {
            .get(path, query: makeGetQuery(lang))
        }

        private func makeGetQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        /// Activates the discount for a user. Only Stripe platform is currently supported.
        public func post(lang: String? = nil, _ body: Data) -> Request<Void> {
            .post(path, query: makePostQuery(lang), body: body)
        }

        private func makePostQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv {
    public var subscription: Subscription {
        Subscription(path: path + "/subscription")
    }

    public struct Subscription {
        /// Path: `/itv/subscription`
        public let path: String
    }
}

extension Paths.Itv.Subscription {
    public var fullpricerenewal: Fullpricerenewal {
        Fullpricerenewal(path: path + "/fullpricerenewal")
    }

    public struct Fullpricerenewal {
        /// Path: `/itv/subscription/fullpricerenewal`
        public let path: String

        /// Returns full price renewal state and reason for specific user.
        public func get(lang: String? = nil) -> Request<RocketServicesAPI.ItvSubscriptionFullPriceRenewal> {
            .get(path, query: makeGetQuery(lang))
        }

        private func makeGetQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv.Subscription {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/itv/subscription/status`
        public let path: String
    }
}

extension Paths.Itv.Subscription.Status {
    public func platform(_ platform: String) -> WithPlatform {
        WithPlatform(path: "\(path)/\(platform)")
    }

    public struct WithPlatform {
        /// Path: `/itv/subscription/status/{platform}`
        public let path: String

        /// Returns status of latest payment intent.
        public func get(lang: String? = nil) -> Request<RocketServicesAPI.ItvSubscriptionStatusResponse> {
            .get(path, query: makeGetQuery(lang))
        }

        private func makeGetQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv {
    public var subscriptionstate: Subscriptionstate {
        Subscriptionstate(path: path + "/subscriptionstate")
    }

    public struct Subscriptionstate {
        /// Path: `/itv/subscriptionstate`
        public let path: String

        /// Returns the state of subscription for any payment platform.
        public func get(lang: String? = nil) -> Request<RocketServicesAPI.ItvSubscriptionState> {
            .get(path, query: makeGetQuery(lang))
        }

        private func makeGetQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv {
    public var upcominginvoice: Upcominginvoice {
        Upcominginvoice(path: path + "/upcominginvoice")
    }

    public struct Upcominginvoice {
        /// Path: `/itv/upcominginvoice`
        public let path: String

        /// Returns an upcoming invoice
        public func get(lang: String? = nil) -> Request<RocketServicesAPI.ItvGetDiscountResponse> {
            .get(path, query: makeGetQuery(lang))
        }

        private func makeGetQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv {
    public var updateIntent: UpdateIntent {
        UpdateIntent(path: path + "/updateIntent")
    }

    public struct UpdateIntent {
        /// Path: `/itv/updateIntent`
        public let path: String
    }
}

extension Paths.Itv.UpdateIntent {
    public var strong: Strong {
        Strong(path: path + "/strong")
    }

    public struct Strong {
        /// Path: `/itv/updateIntent/strong`
        public let path: String
    }
}

extension Paths.Itv.UpdateIntent.Strong {
    public func platform(_ platform: String) -> WithPlatform {
        WithPlatform(path: "\(path)/\(platform)")
    }

    public struct WithPlatform {
        /// Path: `/itv/updateIntent/strong/{platform}`
        public let path: String

        /// Change payment method details.
        public func put(lang: String? = nil, _ body: Data) -> Request<RocketServicesAPI.ItvUpdateIntentStrongResponse> {
            .put(path, query: makePutQuery(lang), body: body)
        }

        private func makePutQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv {
    public var updatePayment: UpdatePayment {
        UpdatePayment(path: path + "/updatePayment")
    }

    public struct UpdatePayment {
        /// Path: `/itv/updatePayment`
        public let path: String
    }
}

extension Paths.Itv.UpdatePayment {
    public var strong: Strong {
        Strong(path: path + "/strong")
    }

    public struct Strong {
        /// Path: `/itv/updatePayment/strong`
        public let path: String
    }
}

extension Paths.Itv.UpdatePayment.Strong {
    public func platform(_ platform: String) -> WithPlatform {
        WithPlatform(path: "\(path)/\(platform)")
    }

    public struct WithPlatform {
        /// Path: `/itv/updatePayment/strong/{platform}`
        public let path: String

        /// Change payment method details.
        public func put(lang: String? = nil, _ body: Data) -> Request<Void> {
            .put(path, query: makePutQuery(lang), body: body)
        }

        private func makePutQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv {
    public var voucher: Voucher {
        Voucher(path: path + "/voucher")
    }

    public struct Voucher {
        /// Path: `/itv/voucher`
        public let path: String
    }
}

extension Paths.Itv.Voucher {
    public func planID(_ planID: String) -> WithPlanID {
        WithPlanID(path: "\(path)/\(planID)")
    }

    public struct WithPlanID {
        /// Path: `/itv/voucher/{planId}`
        public let path: String
    }
}

extension Paths.Itv.Voucher.WithPlanID {
    public func voucherID(_ voucherID: String) -> WithVoucherID {
        WithVoucherID(path: "\(path)/\(voucherID)")
    }

    public struct WithVoucherID {
        /// Path: `/itv/voucher/{planId}/{voucherId}`
        public let path: String

        /// Checks the provided coupon id for a user. Only Stripe platform is currently supported.
        public func get(lang: String? = nil) -> Request<RocketServicesAPI.ItvVoucher> {
            .get(path, query: makeGetQuery(lang))
        }

        private func makeGetQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths.Itv.Voucher {
    public func platform(_ platform: String) -> WithPlatform {
        WithPlatform(path: "\(path)/\(platform)")
    }

    public struct WithPlatform {
        /// Path: `/itv/voucher/{platform}`
        public let path: String

        /// Validates the coupon/voucher for specified payment platform.
        public func post(lang: String? = nil, _ body: Data) -> Request<RocketServicesAPI.ItvVoucher> {
            .post(path, query: makePostQuery(lang), body: body)
        }

        private func makePostQuery(_ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }
    }
}

extension Paths {
    public static var lists: Lists {
        Lists(path: "/lists")
    }

    public struct Lists {
        /// Path: `/lists`
        public let path: String

        /// Returns an array of item lists with their first page of content resolved.
        public func get(parameters: GetParameters) -> Request<[RocketServicesAPI.ItemList]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var ids: [String]
            public var pageSize: Int?
            public var maxRating: String?
            public var order: Order?
            public var orderBy: OrderBy?
            public var itemType: ItemType?
            public var device: String?
            public var sub: String?
            public var segments: [String]?
            public var ff: [Ff]?
            public var lang: String?

            public enum Order: String, Codable, CaseIterable {
                case asc
                case desc
            }

            public enum OrderBy: String, Codable, CaseIterable {
                case aZ = "a-z"
                case releaseYear = "release-year"
                case dateAdded = "date-added"
            }

            public enum ItemType: String, Codable, CaseIterable {
                case movie
                case show
                case season
                case episode
                case program
                case link
                case trailer
                case channel
                case customAsset
            }

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(ids: [String], pageSize: Int? = nil, maxRating: String? = nil, order: Order? = nil, orderBy: OrderBy? = nil, itemType: ItemType? = nil, device: String? = nil, sub: String? = nil, segments: [String]? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.ids = ids
                self.pageSize = pageSize
                self.maxRating = maxRating
                self.order = order
                self.orderBy = orderBy
                self.itemType = itemType
                self.device = device
                self.sub = sub
                self.segments = segments
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(ids, forKey: "ids", explode: false)
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(maxRating, forKey: "max_rating")
                encoder.encode(order, forKey: "order")
                encoder.encode(orderBy, forKey: "order_by")
                encoder.encode(itemType, forKey: "item_type")
                encoder.encode(device, forKey: "device")
                encoder.encode(sub, forKey: "sub")
                encoder.encode(segments, forKey: "segments", explode: false)
                encoder.encode(ff, forKey: "ff", explode: false)
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths.Lists {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/lists/{id}`
        public let path: String

        /// Returns a list of items under the specified item list
        public func get(parameters: GetParameters? = nil) -> Request<RocketServicesAPI.ItemList> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var page: Int?
            public var pageSize: Int?
            public var maxRating: String?
            public var order: Order?
            public var orderBy: OrderBy?
            public var param: String?
            public var itemType: ItemType?
            public var device: String?
            public var sub: String?
            public var segments: [String]?
            public var ff: [Ff]?
            public var lang: String?

            public enum Order: String, Codable, CaseIterable {
                case asc
                case desc
            }

            public enum OrderBy: String, Codable, CaseIterable {
                case aZ = "a-z"
                case releaseYear = "release-year"
                case dateAdded = "date-added"
            }

            public enum ItemType: String, Codable, CaseIterable {
                case movie
                case show
                case season
                case episode
                case program
                case link
                case trailer
                case channel
                case customAsset
            }

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(page: Int? = nil, pageSize: Int? = nil, maxRating: String? = nil, order: Order? = nil, orderBy: OrderBy? = nil, param: String? = nil, itemType: ItemType? = nil, device: String? = nil, sub: String? = nil, segments: [String]? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.page = page
                self.pageSize = pageSize
                self.maxRating = maxRating
                self.order = order
                self.orderBy = orderBy
                self.param = param
                self.itemType = itemType
                self.device = device
                self.sub = sub
                self.segments = segments
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(page, forKey: "page")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(maxRating, forKey: "max_rating")
                encoder.encode(order, forKey: "order")
                encoder.encode(orderBy, forKey: "order_by")
                encoder.encode(param, forKey: "param")
                encoder.encode(itemType, forKey: "item_type")
                encoder.encode(device, forKey: "device")
                encoder.encode(sub, forKey: "sub")
                encoder.encode(segments, forKey: "segments", explode: false)
                encoder.encode(ff, forKey: "ff", explode: false)
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var page: Page {
        Page(path: "/page")
    }

    public struct Page {
        /// Path: `/page`
        public let path: String

        /// Returns a page with the specified id.
        /// 
        /// If targeting the search page you must url encode the search term as a parameter
        /// using the `q` key. For example if your browser path looks like `/search?q=the`
        /// then what you pass to this endpoint would look like `/page?path=/search%3Fq%3Dthe`.
        public func get(parameters: GetParameters) -> Request<RocketServicesAPI.Page> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var path: String
            public var listPageSize: Int?
            public var listPageSizeLarge: Int?
            public var maxListPrefetch: Int?
            public var itemDetailExpand: ItemDetailExpand?
            public var itemDetailSelectSeason: ItemDetailSelectSeason?
            public var textEntryFormat: TextEntryFormat?
            public var maxRating: String?
            public var device: String?
            public var sub: String?
            public var segments: [String]?
            public var ff: [Ff]?
            public var lang: String?

            public enum ItemDetailExpand: String, Codable, CaseIterable {
                case all
                case children
                case ancestors
            }

            public enum ItemDetailSelectSeason: String, Codable, CaseIterable {
                case first
                case latest
            }

            public enum TextEntryFormat: String, Codable, CaseIterable {
                case markdown
                case html
            }

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(path: String, listPageSize: Int? = nil, listPageSizeLarge: Int? = nil, maxListPrefetch: Int? = nil, itemDetailExpand: ItemDetailExpand? = nil, itemDetailSelectSeason: ItemDetailSelectSeason? = nil, textEntryFormat: TextEntryFormat? = nil, maxRating: String? = nil, device: String? = nil, sub: String? = nil, segments: [String]? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.path = path
                self.listPageSize = listPageSize
                self.listPageSizeLarge = listPageSizeLarge
                self.maxListPrefetch = maxListPrefetch
                self.itemDetailExpand = itemDetailExpand
                self.itemDetailSelectSeason = itemDetailSelectSeason
                self.textEntryFormat = textEntryFormat
                self.maxRating = maxRating
                self.device = device
                self.sub = sub
                self.segments = segments
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(path, forKey: "path")
                encoder.encode(listPageSize, forKey: "list_page_size")
                encoder.encode(listPageSizeLarge, forKey: "list_page_size_large")
                encoder.encode(maxListPrefetch, forKey: "max_list_prefetch")
                encoder.encode(itemDetailExpand, forKey: "item_detail_expand")
                encoder.encode(itemDetailSelectSeason, forKey: "item_detail_select_season")
                encoder.encode(textEntryFormat, forKey: "text_entry_format")
                encoder.encode(maxRating, forKey: "max_rating")
                encoder.encode(device, forKey: "device")
                encoder.encode(sub, forKey: "sub")
                encoder.encode(segments, forKey: "segments", explode: false)
                encoder.encode(ff, forKey: "ff", explode: false)
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var plans: Plans {
        Plans(path: "/plans")
    }

    public struct Plans {
        /// Path: `/plans`
        public let path: String
    }
}

extension Paths.Plans {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/plans/{id}`
        public let path: String

        /// Returns the details of a Plan with the specified id.
        public func get(parameters: GetParameters? = nil) -> Request<RocketServicesAPI.Plan> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var device: String?
            public var sub: String?
            public var segments: [String]?
            public var ff: [Ff]?
            public var lang: String?

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(device: String? = nil, sub: String? = nil, segments: [String]? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.device = device
                self.sub = sub
                self.segments = segments
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(device, forKey: "device")
                encoder.encode(sub, forKey: "sub")
                encoder.encode(segments, forKey: "segments")
                encoder.encode(ff, forKey: "ff")
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var register: Register {
        Register(path: "/register")
    }

    public struct Register {
        /// Path: `/register`
        public let path: String

        /// Register a new user, creating them an account.
        /// 
        /// Registration, when successful, will return an array of access tokens so the user is
        /// immediately signed in.
        /// 
        /// It returns Catalog and Commerce scoped tokens for both Account and Profile.
        /// The Commerce ones are intended to allow the purchase of a subscription plan
        /// in the step after registration, without the user being prompted to enter
        /// their username and password again.
        /// 
        /// An email will also be sent with a link they need to click to confirm their
        /// email address. This confirmation is done via the /verify-email endpoint.
        public func post(ff: [Ff]? = nil, lang: String? = nil, _ body: RocketServicesAPI.RegistrationRequest) -> Request<[RocketServicesAPI.AccessToken]> {
            .post(path, query: makePostQuery(ff, lang), body: body)
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths {
    public static var requestPasswordReset: RequestPasswordReset {
        RequestPasswordReset(path: "/request-password-reset")
    }

    public struct RequestPasswordReset {
        /// Path: `/request-password-reset`
        public let path: String

        /// Request the password of an account's primary profile be reset.
        /// 
        /// Should be called when a user has forgotten their password.
        /// 
        /// This will send an email with a password reset link to the email address of the
        /// primary profile of an account.
        /// 
        /// The link, once clicked, should take the user to the "reset-password" page of the
        /// website. Here they will enter their new password and submit to the /reset-password
        /// endpoint here, along with the password reset token provided in the original link.
        public func post(ff: [Ff]? = nil, lang: String? = nil, _ body: RocketServicesAPI.PasswordResetEmailRequest) -> Request<Void> {
            .post(path, query: makePostQuery(ff, lang), body: body)
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths {
    public static var resetPassword: ResetPassword {
        ResetPassword(path: "/reset-password")
    }

    public struct ResetPassword {
        /// Path: `/reset-password`
        public let path: String

        /// When a user requests to reset their password via the /request-password-reset endpoint, an
        /// email is sent to the email address of the primary profile of the account. This email contains a link
        /// with a reset token as query parameter. The link should take the user to the "reset-password"
        /// page of the website.
        /// 
        /// From the reset-password page a user should enter the new password they wish to use. 
        /// It should then be submitted to this endpoint,
        /// along with the reset token from the email link. 
        /// The token should be provided in the body as resetToken property.
        public func post(ff: [Ff]? = nil, lang: String? = nil, _ body: RocketServicesAPI.PasswordResetRequest) -> Request<Void> {
            .post(path, query: makePostQuery(ff, lang), body: body)
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

extension Paths {
    public static var samsungPreview: SamsungPreview {
        SamsungPreview(path: "/samsung-preview")
    }

    public struct SamsungPreview {
        /// Path: `/samsung-preview`
        public let path: String

        /// Returns public preview for Samsung based on the page '/samsung-preview' configured in PresentationManager.
        /// There is a hard limit of max 40 items to be returned. It splits evenly items count into the page rows, remaining items are added into the first row.
        public var get: Request<RocketServicesAPI.SamsungPreview> {
            .get(path)
        }
    }
}

extension Paths {
    public static var schedules: Schedules {
        Schedules(path: "/schedules")
    }

    public struct Schedules {
        /// Path: `/schedules`
        public let path: String

        /// Returns schedules for a defined set of channels over a requested period.
        /// 
        /// Schedules are requested in hour blocks and returned grouped by the channel
        /// they belong to.
        /// 
        /// For example, to load 12 hours of schedules for channels `4343` and `5234`,
        /// on 21/2/2017 starting from 08:00.
        /// 
        /// ```
        /// channels=4343,5234
        /// date=2017-02-21
        /// hour=8
        /// duration=12
        /// ```
        /// 
        /// Please remember that `date` and `hour` combined represent a normal datetime, 
        /// so they should be converted to UTC on the client - this will help to avoid 
        /// issues with EPG schedules near midnight.
        /// 
        /// If a channel id is passed which doesn't exist then this endpoint will
        /// return an empty schedule list for it. If instead we returned 404,
        /// this would invalidate all other channel schedules in the same request
        /// which would be unfriendly for clients presenting these channel schedules.
        public func get(parameters: GetParameters) -> Request<[RocketServicesAPI.ItemScheduleList]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var channels: [String]
            public var date: NaiveDate
            public var hour: Int
            public var duration: Int
            public var isIntersect: Bool?
            public var device: String?
            public var sub: String?
            public var segments: [String]?
            public var ff: [Ff]?
            public var lang: String?

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(channels: [String], date: NaiveDate, hour: Int, duration: Int, isIntersect: Bool? = nil, device: String? = nil, sub: String? = nil, segments: [String]? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.channels = channels
                self.date = date
                self.hour = hour
                self.duration = duration
                self.isIntersect = isIntersect
                self.device = device
                self.sub = sub
                self.segments = segments
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(channels, forKey: "channels")
                encoder.encode(date, forKey: "date")
                encoder.encode(hour, forKey: "hour")
                encoder.encode(duration, forKey: "duration")
                encoder.encode(isIntersect, forKey: "intersect")
                encoder.encode(device, forKey: "device")
                encoder.encode(sub, forKey: "sub")
                encoder.encode(segments, forKey: "segments")
                encoder.encode(ff, forKey: "ff")
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var search: Search {
        Search(path: "/search")
    }

    public struct Search {
        /// Path: `/search`
        public let path: String

        /// Search the catalog of items and people.
        public func get(parameters: GetParameters) -> Request<RocketServicesAPI.SearchResults> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var term: String
            public var include: [Include]?
            public var isGroup: Bool?
            public var maxResults: Int?
            public var maxRating: String?
            public var device: String?
            public var sub: String?
            public var segments: [String]?
            public var ff: [Ff]?
            public var lang: String?

            public enum Include: String, Codable, CaseIterable {
                case tv
                case movies
                case people
                case other
            }

            public enum Ff: String, Codable, CaseIterable {
                case all
                case idp
                case ldp
                case hb
                case rpt
                case cas
                case lrl
                case cd
                case sis
            }

            public init(term: String, include: [Include]? = nil, isGroup: Bool? = nil, maxResults: Int? = nil, maxRating: String? = nil, device: String? = nil, sub: String? = nil, segments: [String]? = nil, ff: [Ff]? = nil, lang: String? = nil) {
                self.term = term
                self.include = include
                self.isGroup = isGroup
                self.maxResults = maxResults
                self.maxRating = maxRating
                self.device = device
                self.sub = sub
                self.segments = segments
                self.ff = ff
                self.lang = lang
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder(explode: false)
                encoder.encode(term, forKey: "term")
                encoder.encode(include, forKey: "include")
                encoder.encode(isGroup, forKey: "group")
                encoder.encode(maxResults, forKey: "max_results")
                encoder.encode(maxRating, forKey: "max_rating")
                encoder.encode(device, forKey: "device")
                encoder.encode(sub, forKey: "sub")
                encoder.encode(segments, forKey: "segments")
                encoder.encode(ff, forKey: "ff")
                encoder.encode(lang, forKey: "lang")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var verifyEmail: VerifyEmail {
        VerifyEmail(path: "/verify-email")
    }

    public struct VerifyEmail {
        /// Path: `/verify-email`
        public let path: String

        /// When an account is created an email is sent to the email address of the new account.
        /// This contains a link, which once clicked, verifies the email address of the account is correct.
        /// 
        /// The link contains a token as a query parameter which should be passed as the authorization
        /// bearer token to this endpoint to complete email verification.
        /// 
        /// The token has en expiry, so if the link is not clicked before it expires, the account holder
        /// may need to request a new verification email be sent. This can be done via the endpoint
        /// /account/request-email-verification.
        public func post(ff: [Ff]? = nil, lang: String? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(ff, lang))
        }

        private func makePostQuery(_ ff: [Ff]?, _ lang: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ff, forKey: "ff", explode: false)
            encoder.encode(lang, forKey: "lang")
            return encoder.items
        }

        public enum Ff: String, Codable, CaseIterable {
            case all
            case idp
            case ldp
            case hb
            case rpt
            case cas
            case lrl
            case cd
            case sis
        }
    }
}

public enum Paths {}
