// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import NaiveDate

/// Event's Access Date
public struct AccessDates: Codable {
    /// Boolean flag to indicate whether or not the access end date is approximated
    ///
    /// Example: "yyyy-MM-ddThh-mm-ssZ"
    public var isEndApproximate: Bool
    /// Event's end access time
    ///
    /// Example: "yyyy-MM-ddThh-mm-ssZ"
    public var endDateTime: Date?
    /// Boolean flag to indicate whether or not the access start date is approximated
    public var isStartApproximate: Bool
    /// Event's start access time
    ///
    /// Example: "yyyy-MM-ddThh-mm-ssZ"
    public var startDateTime: Date?

    public init(isEndApproximate: Bool? = nil, endDateTime: Date? = nil, isStartApproximate: Bool? = nil, startDateTime: Date? = nil) {
        self.isEndApproximate = isEndApproximate ?? false
        self.endDateTime = endDateTime
        self.isStartApproximate = isStartApproximate ?? false
        self.startDateTime = startDateTime
    }

    private enum CodingKeys: String, CodingKey {
        case isEndApproximate = "endApproximate"
        case endDateTime
        case isStartApproximate = "startApproximate"
        case startDateTime
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isEndApproximate = try values.decodeIfPresent(Bool.self, forKey: .isEndApproximate) ?? false
        self.endDateTime = try values.decodeIfPresent(Date.self, forKey: .endDateTime)
        self.isStartApproximate = try values.decodeIfPresent(Bool.self, forKey: .isStartApproximate) ?? false
        self.startDateTime = try values.decodeIfPresent(Date.self, forKey: .startDateTime)
    }
}

/// Additional information for people who experience disabilities
public struct Accessibility: Codable {
    /// Accessibility's information
    public var info: String?

    public init(info: String? = nil) {
        self.info = info
    }
}

/// Address
public struct Address: Codable {
    /// Address first line
    public var line1: String?
    /// Address second line
    public var line2: String?
    /// Address third line
    public var line3: String?

    public init(line1: String? = nil, line2: String? = nil, line3: String? = nil) {
        self.line1 = line1
        self.line2 = line2
        self.line3 = line3
    }
}

/// Area
public struct Area: Codable {
    /// Name of the entity
    public var name: String?

    public init(name: String? = nil) {
        self.name = name
    }
}

/// Attraction
public struct Attraction: Codable {
    /// Additional information of the entity
    public var additionalInfo: String?
    /// Attraction's classifications
    public var classifications: [Classification]?
    /// Description's of the entity
    public var description: String?
    /// List of external links
    public var externalLinks: [String: [ExternalLink]]?
    /// Unique id of the entity in the discovery API
    public var id: String
    /// Images of the entity
    public var images: [Image]?
    /// Locale in which the content is returned
    public var locale: String?
    /// Name of the entity
    public var name: String?
    /// Indicate if this is a test entity, by default test entities won't appear in discovery API
    public var isTest: Bool
    /// Type of the entity
    public var type: `Type`
    /// Number of upcoming events
    public var upcomingEvents: [String: Int]?
    /// URL of a web site detail page of the entity
    public var url: String?

    /// Type of the entity
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case venue
        case attraction
    }

    public init(additionalInfo: String? = nil, classifications: [Classification]? = nil, description: String? = nil, externalLinks: [String: [ExternalLink]]? = nil, id: String, images: [Image]? = nil, locale: String? = nil, name: String? = nil, isTest: Bool? = nil, type: `Type`, upcomingEvents: [String: Int]? = nil, url: String? = nil) {
        self.additionalInfo = additionalInfo
        self.classifications = classifications
        self.description = description
        self.externalLinks = externalLinks
        self.id = id
        self.images = images
        self.locale = locale
        self.name = name
        self.isTest = isTest ?? false
        self.type = type
        self.upcomingEvents = upcomingEvents
        self.url = url
    }

    private enum CodingKeys: String, CodingKey {
        case additionalInfo
        case classifications
        case description
        case externalLinks
        case id
        case images
        case locale
        case name
        case isTest = "test"
        case type
        case upcomingEvents
        case url
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.additionalInfo = try values.decodeIfPresent(String.self, forKey: .additionalInfo)
        self.classifications = try values.decodeIfPresent([Classification].self, forKey: .classifications)
        self.description = try values.decodeIfPresent(String.self, forKey: .description)
        self.externalLinks = try values.decodeIfPresent([String: [ExternalLink]].self, forKey: .externalLinks)
        self.id = try values.decode(String.self, forKey: .id)
        self.images = try values.decodeIfPresent([Image].self, forKey: .images)
        self.locale = try values.decodeIfPresent(String.self, forKey: .locale)
        self.name = try values.decodeIfPresent(String.self, forKey: .name)
        self.isTest = try values.decodeIfPresent(Bool.self, forKey: .isTest) ?? false
        self.type = try values.decode(`Type`.self, forKey: .type)
        self.upcomingEvents = try values.decodeIfPresent([String: Int].self, forKey: .upcomingEvents)
        self.url = try values.decodeIfPresent(String.self, forKey: .url)
    }
}

/// Attribution
public struct Attribution: Codable {
    /// LicenceName
    public var licenceName: String?
    /// LicenceUrl
    public var licenceURL: String?
    /// SourceName
    public var sourceName: String?
    /// SourceUrl
    public var sourceURL: String?

    public init(licenceName: String? = nil, licenceURL: String? = nil, sourceName: String? = nil, sourceURL: String? = nil) {
        self.licenceName = licenceName
        self.licenceURL = licenceURL
        self.sourceName = sourceName
        self.sourceURL = sourceURL
    }

    private enum CodingKeys: String, CodingKey {
        case licenceName
        case licenceURL = "licenceUrl"
        case sourceName
        case sourceURL = "sourceUrl"
    }
}

/// Attributions
public struct Attributions: Codable {
    /// Attribution
    public var description: Attribution?
    /// Attribution descriptions - multi-lingual fields
    public var descriptions: [String: Attribution]?

    public init(description: Attribution? = nil, descriptions: [String: Attribution]? = nil) {
        self.description = description
        self.descriptions = descriptions
    }
}

public struct Chronology: Codable {
    public var zone: DateTimeZone?

    public init(zone: DateTimeZone? = nil) {
        self.zone = zone
    }
}

/// City
public struct City: Codable {
    /// Name of the entity
    public var name: String?

    public init(name: String? = nil) {
        self.name = name
    }
}

/// Classification
public struct Classification: Codable {
    public var genre: Level?
    /// True if this is the entity's primary classification
    public var isPrimary: Bool
    /// Segment
    public var segment: Segment?
    public var subGenre: Level?
    public var subType: Level?
    public var type: Level?

    public init(genre: Level? = nil, isPrimary: Bool? = nil, segment: Segment? = nil, subGenre: Level? = nil, subType: Level? = nil, type: Level? = nil) {
        self.genre = genre
        self.isPrimary = isPrimary ?? false
        self.segment = segment
        self.subGenre = subGenre
        self.subType = subType
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case genre
        case isPrimary = "primary"
        case segment
        case subGenre
        case subType
        case type
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.genre = try values.decodeIfPresent(Level.self, forKey: .genre)
        self.isPrimary = try values.decodeIfPresent(Bool.self, forKey: .isPrimary) ?? false
        self.segment = try values.decodeIfPresent(Segment.self, forKey: .segment)
        self.subGenre = try values.decodeIfPresent(Level.self, forKey: .subGenre)
        self.subType = try values.decodeIfPresent(Level.self, forKey: .subType)
        self.type = try values.decodeIfPresent(Level.self, forKey: .type)
    }
}

/// Country
public struct Country: Codable {
    /// Country code (ISO 3166)
    public var countryCode: String?
    /// Name of the entity
    public var name: String?

    public init(countryCode: String? = nil, name: String? = nil) {
        self.countryCode = countryCode
        self.name = name
    }
}

public struct DateTimeField: Codable {
    public var durationField: DurationField?
    public var leapDurationField: DurationField?
    public var isLenient: Bool
    public var maximumValue: Int?
    public var minimumValue: Int?
    public var name: String?
    public var rangeDurationField: DurationField?
    public var isSupported: Bool
    public var type: DateTimeFieldType?

    public init(durationField: DurationField? = nil, leapDurationField: DurationField? = nil, isLenient: Bool? = nil, maximumValue: Int? = nil, minimumValue: Int? = nil, name: String? = nil, rangeDurationField: DurationField? = nil, isSupported: Bool? = nil, type: DateTimeFieldType? = nil) {
        self.durationField = durationField
        self.leapDurationField = leapDurationField
        self.isLenient = isLenient ?? false
        self.maximumValue = maximumValue
        self.minimumValue = minimumValue
        self.name = name
        self.rangeDurationField = rangeDurationField
        self.isSupported = isSupported ?? false
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case durationField
        case leapDurationField
        case isLenient = "lenient"
        case maximumValue
        case minimumValue
        case name
        case rangeDurationField
        case isSupported = "supported"
        case type
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.durationField = try values.decodeIfPresent(DurationField.self, forKey: .durationField)
        self.leapDurationField = try values.decodeIfPresent(DurationField.self, forKey: .leapDurationField)
        self.isLenient = try values.decodeIfPresent(Bool.self, forKey: .isLenient) ?? false
        self.maximumValue = try values.decodeIfPresent(Int.self, forKey: .maximumValue)
        self.minimumValue = try values.decodeIfPresent(Int.self, forKey: .minimumValue)
        self.name = try values.decodeIfPresent(String.self, forKey: .name)
        self.rangeDurationField = try values.decodeIfPresent(DurationField.self, forKey: .rangeDurationField)
        self.isSupported = try values.decodeIfPresent(Bool.self, forKey: .isSupported) ?? false
        self.type = try values.decodeIfPresent(DateTimeFieldType.self, forKey: .type)
    }
}

public struct DateTimeFieldType: Codable {
    public var durationType: DurationFieldType?
    public var name: String?
    public var rangeDurationType: DurationFieldType?

    public init(durationType: DurationFieldType? = nil, name: String? = nil, rangeDurationType: DurationFieldType? = nil) {
        self.durationType = durationType
        self.name = name
        self.rangeDurationType = rangeDurationType
    }
}

public struct DateTimeZone: Codable {
    public var isFixed: Bool
    public var id: String?

    public init(isFixed: Bool? = nil, id: String? = nil) {
        self.isFixed = isFixed ?? false
        self.id = id
    }

    private enum CodingKeys: String, CodingKey {
        case isFixed = "fixed"
        case id
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isFixed = try values.decodeIfPresent(Bool.self, forKey: .isFixed) ?? false
        self.id = try values.decodeIfPresent(String.self, forKey: .id)
    }
}

/// Event's display settings extension
public struct DisplaySettingExtension: Codable {
    /// True the landing is Soft otherwise it's Comingled
    public var isSoftLanding: Bool

    public init(isSoftLanding: Bool? = nil) {
        self.isSoftLanding = isSoftLanding ?? false
    }

    private enum CodingKeys: String, CodingKey {
        case isSoftLanding = "softLanding"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isSoftLanding = try values.decodeIfPresent(Bool.self, forKey: .isSoftLanding) ?? false
    }
}

/// DMA (Designated Market Area)
public struct Dma: Codable {
    /// DMS's id
    public var id: Int?

    public init(id: Int? = nil) {
        self.id = id
    }
}

public struct DurationField: Codable {
    public var name: String?
    public var isPrecise: Bool
    public var isSupported: Bool
    public var type: DurationFieldType?
    public var unitMillis: Int?

    public init(name: String? = nil, isPrecise: Bool? = nil, isSupported: Bool? = nil, type: DurationFieldType? = nil, unitMillis: Int? = nil) {
        self.name = name
        self.isPrecise = isPrecise ?? false
        self.isSupported = isSupported ?? false
        self.type = type
        self.unitMillis = unitMillis
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case isPrecise = "precise"
        case isSupported = "supported"
        case type
        case unitMillis
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.name = try values.decodeIfPresent(String.self, forKey: .name)
        self.isPrecise = try values.decodeIfPresent(Bool.self, forKey: .isPrecise) ?? false
        self.isSupported = try values.decodeIfPresent(Bool.self, forKey: .isSupported) ?? false
        self.type = try values.decodeIfPresent(DurationFieldType.self, forKey: .type)
        self.unitMillis = try values.decodeIfPresent(Int.self, forKey: .unitMillis)
    }
}

public struct DurationFieldType: Codable {
    public var name: String?

    public init(name: String? = nil) {
        self.name = name
    }
}

/// Event's End Dates
public struct EndDates: Codable {
    /// Boolean flag to indicate whether or not the end date is approximated
    public var isApproximate: Bool
    /// The event end date time
    ///
    /// Example: "yyyy-MM-ddThh-mm-ssZ"
    public var dateTime: Date?
    /// The event end date in local date
    ///
    /// Example: "yyyy-MM-dd"
    public var localDate: NaiveDate?
    public var localTime: LocalTime?
    /// Boolean flag to indicate whether or not the event end time has no specific time
    public var isNoSpecificTime: Bool

    public init(isApproximate: Bool? = nil, dateTime: Date? = nil, localDate: NaiveDate? = nil, localTime: LocalTime? = nil, isNoSpecificTime: Bool? = nil) {
        self.isApproximate = isApproximate ?? false
        self.dateTime = dateTime
        self.localDate = localDate
        self.localTime = localTime
        self.isNoSpecificTime = isNoSpecificTime ?? false
    }

    private enum CodingKeys: String, CodingKey {
        case isApproximate = "approximate"
        case dateTime
        case localDate
        case localTime
        case isNoSpecificTime = "noSpecificTime"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isApproximate = try values.decodeIfPresent(Bool.self, forKey: .isApproximate) ?? false
        self.dateTime = try values.decodeIfPresent(Date.self, forKey: .dateTime)
        self.localDate = try values.decodeIfPresent(NaiveDate.self, forKey: .localDate)
        self.localTime = try values.decodeIfPresent(LocalTime.self, forKey: .localTime)
        self.isNoSpecificTime = try values.decodeIfPresent(Bool.self, forKey: .isNoSpecificTime) ?? false
    }
}

public struct EntityChanges: Codable {
    public var changes: [String]?
    public var isNewlyCreated: Bool

    public init(changes: [String]? = nil, isNewlyCreated: Bool? = nil) {
        self.changes = changes
        self.isNewlyCreated = isNewlyCreated ?? false
    }

    private enum CodingKeys: String, CodingKey {
        case changes
        case isNewlyCreated = "newlyCreated"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.changes = try values.decodeIfPresent([String].self, forKey: .changes)
        self.isNewlyCreated = try values.decodeIfPresent(Bool.self, forKey: .isNewlyCreated) ?? false
    }
}

/// Event
public struct Event: Codable {
    /// Additional information for people who experience disabilities
    public var accessibility: Accessibility?
    /// Additional information of the entity
    public var additionalInfo: String?
    /// Event's classifications
    public var classifications: [Classification]?
    /// Event's Dates
    public var dates: EventDates?
    /// Description's of the entity
    public var description: String?
    public var distance: Double?
    /// List of external links
    public var externalLinks: [String: [ExternalLink]]?
    /// Unique id of the entity in the discovery API
    public var id: String
    /// Images of the entity
    public var images: [Image]?
    /// Any information related to the event
    public var info: String?
    /// Locale in which the content is returned
    public var locale: String?
    /// Location
    public var location: Location?
    /// Name of the entity
    public var name: String?
    /// Related outlets informations
    public var outlets: [Outlet]?
    /// Place
    public var place: Place?
    /// Any notes related to the event
    public var pleaseNote: String?
    /// Price ranges of this event
    public var priceRanges: [PriceRange]?
    /// Related products informations
    public var products: [Product]?
    /// Promoter
    public var promoter: Promoter?
    /// Event's promoters
    public var promoters: [Promoter]?
    /// Event's Sales Dates
    public var sales: EventSalesDates?
    /// Seatmap
    public var seatmap: SeatMap?
    /// Indicate if this is a test entity, by default test entities won't appear in discovery API
    public var isTest: Bool
    /// Type of the entity
    public var type: `Type`
    public var units: String?
    /// URL of a web site detail page of the entity
    public var url: String?

    /// Type of the entity
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case venue
        case attraction
    }

    public init(accessibility: Accessibility? = nil, additionalInfo: String? = nil, classifications: [Classification]? = nil, dates: EventDates? = nil, description: String? = nil, distance: Double? = nil, externalLinks: [String: [ExternalLink]]? = nil, id: String, images: [Image]? = nil, info: String? = nil, locale: String? = nil, location: Location? = nil, name: String? = nil, outlets: [Outlet]? = nil, place: Place? = nil, pleaseNote: String? = nil, priceRanges: [PriceRange]? = nil, products: [Product]? = nil, promoter: Promoter? = nil, promoters: [Promoter]? = nil, sales: EventSalesDates? = nil, seatmap: SeatMap? = nil, isTest: Bool? = nil, type: `Type`, units: String? = nil, url: String? = nil) {
        self.accessibility = accessibility
        self.additionalInfo = additionalInfo
        self.classifications = classifications
        self.dates = dates
        self.description = description
        self.distance = distance
        self.externalLinks = externalLinks
        self.id = id
        self.images = images
        self.info = info
        self.locale = locale
        self.location = location
        self.name = name
        self.outlets = outlets
        self.place = place
        self.pleaseNote = pleaseNote
        self.priceRanges = priceRanges
        self.products = products
        self.promoter = promoter
        self.promoters = promoters
        self.sales = sales
        self.seatmap = seatmap
        self.isTest = isTest ?? false
        self.type = type
        self.units = units
        self.url = url
    }

    private enum CodingKeys: String, CodingKey {
        case accessibility
        case additionalInfo
        case classifications
        case dates
        case description
        case distance
        case externalLinks
        case id
        case images
        case info
        case locale
        case location
        case name
        case outlets
        case place
        case pleaseNote
        case priceRanges
        case products
        case promoter
        case promoters
        case sales
        case seatmap
        case isTest = "test"
        case type
        case units
        case url
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.accessibility = try values.decodeIfPresent(Accessibility.self, forKey: .accessibility)
        self.additionalInfo = try values.decodeIfPresent(String.self, forKey: .additionalInfo)
        self.classifications = try values.decodeIfPresent([Classification].self, forKey: .classifications)
        self.dates = try values.decodeIfPresent(EventDates.self, forKey: .dates)
        self.description = try values.decodeIfPresent(String.self, forKey: .description)
        self.distance = try values.decodeIfPresent(Double.self, forKey: .distance)
        self.externalLinks = try values.decodeIfPresent([String: [ExternalLink]].self, forKey: .externalLinks)
        self.id = try values.decode(String.self, forKey: .id)
        self.images = try values.decodeIfPresent([Image].self, forKey: .images)
        self.info = try values.decodeIfPresent(String.self, forKey: .info)
        self.locale = try values.decodeIfPresent(String.self, forKey: .locale)
        self.location = try values.decodeIfPresent(Location.self, forKey: .location)
        self.name = try values.decodeIfPresent(String.self, forKey: .name)
        self.outlets = try values.decodeIfPresent([Outlet].self, forKey: .outlets)
        self.place = try values.decodeIfPresent(Place.self, forKey: .place)
        self.pleaseNote = try values.decodeIfPresent(String.self, forKey: .pleaseNote)
        self.priceRanges = try values.decodeIfPresent([PriceRange].self, forKey: .priceRanges)
        self.products = try values.decodeIfPresent([Product].self, forKey: .products)
        self.promoter = try values.decodeIfPresent(Promoter.self, forKey: .promoter)
        self.promoters = try values.decodeIfPresent([Promoter].self, forKey: .promoters)
        self.sales = try values.decodeIfPresent(EventSalesDates.self, forKey: .sales)
        self.seatmap = try values.decodeIfPresent(SeatMap.self, forKey: .seatmap)
        self.isTest = try values.decodeIfPresent(Bool.self, forKey: .isTest) ?? false
        self.type = try values.decode(`Type`.self, forKey: .type)
        self.units = try values.decodeIfPresent(String.self, forKey: .units)
        self.url = try values.decodeIfPresent(String.self, forKey: .url)
    }
}

/// Event's Dates
public struct EventDates: Codable {
    /// Event's Access Date
    public var access: AccessDates?
    /// Event's End Dates
    public var end: EndDates?
    /// Flag indicating if date spans of multiple days
    public var isSpanMultipleDays: Bool
    /// Event's Start Dates
    public var start: StartDates?
    /// Event's Status
    public var status: EventStatus?
    /// Event's timezone
    public var timezone: String?

    public init(access: AccessDates? = nil, end: EndDates? = nil, isSpanMultipleDays: Bool? = nil, start: StartDates? = nil, status: EventStatus? = nil, timezone: String? = nil) {
        self.access = access
        self.end = end
        self.isSpanMultipleDays = isSpanMultipleDays ?? false
        self.start = start
        self.status = status
        self.timezone = timezone
    }

    private enum CodingKeys: String, CodingKey {
        case access
        case end
        case isSpanMultipleDays = "spanMultipleDays"
        case start
        case status
        case timezone
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.access = try values.decodeIfPresent(AccessDates.self, forKey: .access)
        self.end = try values.decodeIfPresent(EndDates.self, forKey: .end)
        self.isSpanMultipleDays = try values.decodeIfPresent(Bool.self, forKey: .isSpanMultipleDays) ?? false
        self.start = try values.decodeIfPresent(StartDates.self, forKey: .start)
        self.status = try values.decodeIfPresent(EventStatus.self, forKey: .status)
        self.timezone = try values.decodeIfPresent(String.self, forKey: .timezone)
    }
}

/// This class defines an Event with only images view on the Discovery API
public struct EventImages: Codable {
    /// Unique id of the entity in the discovery API
    public var id: String
    /// Images of the entity
    public var images: [Image]?
    /// Type of the entity
    public var type: `Type`

    /// Type of the entity
    public enum `Type`: String, Codable, CaseIterable {
        case event
    }

    public init(id: String, images: [Image]? = nil, type: `Type`) {
        self.id = id
        self.images = images
        self.type = type
    }
}

/// Event's Sales Dates
public struct EventSalesDates: Codable {
    /// Presale information on this event
    public var presales: [Presale]?
    /// Event's Public Onsales Dates
    public var `public`: PublicSaleDates?

    public init(presales: [Presale]? = nil, `public`: PublicSaleDates? = nil) {
        self.presales = presales
        self.public = `public`
    }

    private enum CodingKeys: String, CodingKey {
        case presales
        case `public` = "public"
    }
}

/// Event's Status
public struct EventStatus: Codable {
    /// The event's status code
    public var code: Code?

    /// The event's status code
    public enum Code: String, Codable, CaseIterable {
        case onsale
        case offsale
        case canceled
        case postponed
        case rescheduled
    }

    public init(code: Code? = nil) {
        self.code = code
    }
}

/// ExternalLink
public struct ExternalLink: Codable {
    /// An external link id is the unique identifier of a resource on a different domain or api
    public var id: String?
    /// An external link url is a url that goes to a different domain or api
    public var url: String?

    public init(id: String? = nil, url: String? = nil) {
        self.id = id
        self.url = url
    }
}

/// Secondary Genre
public struct Genre: Codable {
    /// The ID of the classification's level
    public var id: String?
    /// The Name of the classification's level
    public var name: String?

    public init(id: String? = nil, name: String? = nil) {
        self.id = id
        self.name = name
    }
}

public struct GeocodeExtension: Codable {
    public var city: String?
    public var country: String?
    public var county: String?
    public var formattedAddress: String?
    public var geometry: Geometry?
    public var postalCode: String?
    public var route: String?
    public var state: String?
    public var streetNumber: String?

    public init(city: String? = nil, country: String? = nil, county: String? = nil, formattedAddress: String? = nil, geometry: Geometry? = nil, postalCode: String? = nil, route: String? = nil, state: String? = nil, streetNumber: String? = nil) {
        self.city = city
        self.country = country
        self.county = county
        self.formattedAddress = formattedAddress
        self.geometry = geometry
        self.postalCode = postalCode
        self.route = route
        self.state = state
        self.streetNumber = streetNumber
    }
}

/// Venue's geocode extension
public struct GeolocationVenueExtensions: Codable {
    public var geocode: GeocodeExtension?

    public init(geocode: GeocodeExtension? = nil) {
        self.geocode = geocode
    }
}

public struct Geometry: Codable {
    /// Location
    public var location: Location?

    public init(location: Location? = nil) {
        self.location = location
    }
}

/// Image
public struct Image: Codable {
    /// Attribution of the image
    public var attribution: String?
    /// True if the image is not the event's image but a fallbak image
    public var isFallback: Bool
    /// Height of the image
    public var height: Int?
    /// Aspect ratio of the image
    public var ratio: Ratio?
    /// Public URL of the image
    public var url: String?
    /// Width of the image
    public var width: Int?

    /// Aspect ratio of the image
    public enum Ratio: String, Codable, CaseIterable {
        case _169 = "16_9"
        case _32 = "3_2"
        case _43 = "4_3"
    }

    public init(attribution: String? = nil, isFallback: Bool? = nil, height: Int? = nil, ratio: Ratio? = nil, url: String? = nil, width: Int? = nil) {
        self.attribution = attribution
        self.isFallback = isFallback ?? false
        self.height = height
        self.ratio = ratio
        self.url = url
        self.width = width
    }

    private enum CodingKeys: String, CodingKey {
        case attribution
        case isFallback = "fallback"
        case height
        case ratio
        case url
        case width
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.attribution = try values.decodeIfPresent(String.self, forKey: .attribution)
        self.isFallback = try values.decodeIfPresent(Bool.self, forKey: .isFallback) ?? false
        self.height = try values.decodeIfPresent(Int.self, forKey: .height)
        self.ratio = try values.decodeIfPresent(Ratio.self, forKey: .ratio)
        self.url = try values.decodeIfPresent(String.self, forKey: .url)
        self.width = try values.decodeIfPresent(Int.self, forKey: .width)
    }
}

public struct Level: Codable {
    /// The ID of the classification's level
    public var id: String?
    /// The Name of the classification's level
    public var name: String?

    public init(id: String? = nil, name: String? = nil) {
        self.id = id
        self.name = name
    }
}

public struct LocalTime: Codable {
    public var chronology: Chronology?
    public var fieldTypes: [DateTimeFieldType]?
    public var fields: [DateTimeField]?
    public var hourOfDay: Int?
    public var millisOfDay: Int?
    public var millisOfSecond: Int?
    public var minuteOfHour: Int?
    public var secondOfMinute: Int?
    public var values: [Int]?

    public init(chronology: Chronology? = nil, fieldTypes: [DateTimeFieldType]? = nil, fields: [DateTimeField]? = nil, hourOfDay: Int? = nil, millisOfDay: Int? = nil, millisOfSecond: Int? = nil, minuteOfHour: Int? = nil, secondOfMinute: Int? = nil, values: [Int]? = nil) {
        self.chronology = chronology
        self.fieldTypes = fieldTypes
        self.fields = fields
        self.hourOfDay = hourOfDay
        self.millisOfDay = millisOfDay
        self.millisOfSecond = millisOfSecond
        self.minuteOfHour = minuteOfHour
        self.secondOfMinute = secondOfMinute
        self.values = values
    }
}

public struct Locale: Codable {
    public var country: String?
    public var displayCountry: String?
    public var displayLanguage: String?
    public var displayName: String?
    public var displayScript: String?
    public var displayVariant: String?
    public var extensionKeys: [String]?
    public var iso3Country: String?
    public var iso3Language: String?
    public var language: String?
    public var script: String?
    public var unicodeLocaleAttributes: [String]?
    public var unicodeLocaleKeys: [String]?
    public var variant: String?

    public init(country: String? = nil, displayCountry: String? = nil, displayLanguage: String? = nil, displayName: String? = nil, displayScript: String? = nil, displayVariant: String? = nil, extensionKeys: [String]? = nil, iso3Country: String? = nil, iso3Language: String? = nil, language: String? = nil, script: String? = nil, unicodeLocaleAttributes: [String]? = nil, unicodeLocaleKeys: [String]? = nil, variant: String? = nil) {
        self.country = country
        self.displayCountry = displayCountry
        self.displayLanguage = displayLanguage
        self.displayName = displayName
        self.displayScript = displayScript
        self.displayVariant = displayVariant
        self.extensionKeys = extensionKeys
        self.iso3Country = iso3Country
        self.iso3Language = iso3Language
        self.language = language
        self.script = script
        self.unicodeLocaleAttributes = unicodeLocaleAttributes
        self.unicodeLocaleKeys = unicodeLocaleKeys
        self.variant = variant
    }
}

/// Location
public struct Location: Codable {
    /// Latitude
    public var latitude: Double?
    /// Longitude
    public var longitude: Double?

    public init(latitude: Double? = nil, longitude: Double? = nil) {
        self.latitude = latitude
        self.longitude = longitude
    }
}

/// Market
public struct Market: Codable {
    /// Market's id
    public var id: String?

    public init(id: String? = nil) {
        self.id = id
    }
}

/// A selling point for tickets.
public struct Outlet: Codable {
    /// Outlet's type
    public var type: String?
    /// Outlet's url
    public var url: String?

    public init(type: String? = nil, url: String? = nil) {
        self.type = type
        self.url = url
    }
}

/// Parking
public struct Parking: Codable {
    /// Name of the entity
    public var name: String?
    /// Url to the web page of the parking
    public var url: String?

    public init(name: String? = nil, url: String? = nil) {
        self.name = name
        self.url = url
    }
}

/// Place
public struct Place: Codable {
    /// Address
    public var address: Address?
    /// Area
    public var area: Area?
    /// City
    public var city: City?
    /// Country
    public var country: Country?
    /// Location
    public var location: Location?
    /// Name of the entity
    public var name: String?
    /// Postal code / zipcode of the place
    public var postalCode: String?
    /// State
    public var state: State?

    public init(address: Address? = nil, area: Area? = nil, city: City? = nil, country: Country? = nil, location: Location? = nil, name: String? = nil, postalCode: String? = nil, state: State? = nil) {
        self.address = address
        self.area = area
        self.city = city
        self.country = country
        self.location = location
        self.name = name
        self.postalCode = postalCode
        self.state = state
    }
}

/// Event's Presale Info
public struct Presale: Codable {
    /// Description of the presame
    public var description: String?
    /// Presale's end dates. The date and time when the presale will end
    public var endDateTime: Date?
    /// Name of the presale
    public var name: String?
    /// Presale's start dates. The date and time when the presale will start
    public var startDateTime: Date?
    /// Presale link URL
    public var url: String?

    public init(description: String? = nil, endDateTime: Date? = nil, name: String? = nil, startDateTime: Date? = nil, url: String? = nil) {
        self.description = description
        self.endDateTime = endDateTime
        self.name = name
        self.startDateTime = startDateTime
        self.url = url
    }
}

/// PriceRange
public struct PriceRange: Codable {
    /// Currency
    public var currency: String?
    /// Maximum price
    public var max: Double?
    /// Minimum price
    public var min: Double?
    /// Type of price
    public var type: `Type`?

    /// Type of price
    public enum `Type`: String, Codable, CaseIterable {
        case standard
    }

    public init(currency: String? = nil, max: Double? = nil, min: Double? = nil, type: `Type`? = nil) {
        self.currency = currency
        self.max = max
        self.min = min
        self.type = type
    }
}

/// Product
public struct Product: Codable {
    /// Product's primary id
    public var id: String?
    /// Name of the entity
    public var name: String?
    /// Product's type
    public var type: String?
    /// Product's url
    public var url: String?

    public init(id: String? = nil, name: String? = nil, type: String? = nil, url: String? = nil) {
        self.id = id
        self.name = name
        self.type = type
        self.url = url
    }
}

/// Promoter
public struct Promoter: Codable {
    /// Description of the promoter
    public var description: String?
    /// Id of the promoter
    public var id: String?
    /// Name of the promoter
    public var name: String?

    public init(description: String? = nil, id: String? = nil, name: String? = nil) {
        self.description = description
        self.id = id
        self.name = name
    }
}

/// Event's Public Onsales Dates
public struct PublicSaleDates: Codable {
    /// Public sale's end dates. The date and time when the public sale will end
    public var endDateTime: Date?
    /// Public sale's start dates. The date and time when the public sale will start
    public var startDateTime: Date?
    /// True if the public sale's date is to be determined
    public var isStartTBD: Bool

    public init(endDateTime: Date? = nil, startDateTime: Date? = nil, isStartTBD: Bool? = nil) {
        self.endDateTime = endDateTime
        self.startDateTime = startDateTime
        self.isStartTBD = isStartTBD ?? false
    }

    private enum CodingKeys: String, CodingKey {
        case endDateTime
        case startDateTime
        case isStartTBD = "startTBD"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.endDateTime = try values.decodeIfPresent(Date.self, forKey: .endDateTime)
        self.startDateTime = try values.decodeIfPresent(Date.self, forKey: .startDateTime)
        self.isStartTBD = try values.decodeIfPresent(Bool.self, forKey: .isStartTBD) ?? false
    }
}

/// Relationship
public struct Relationship: Codable {
    /// The ID of the related entity
    public var id: String?
    /// References of this relationship in another system. Reference is the exact same entity
    ///
    /// Example: "sourceName: id"
    public var references: [String: String]?
    /// The source name of the related entity
    public var source: String?
    /// The type of the relationship
    public var type: `Type`?

    /// The type of the relationship
    public enum `Type`: String, Codable, CaseIterable {
        case duplicate
    }

    public init(id: String? = nil, references: [String: String]? = nil, source: String? = nil, type: `Type`? = nil) {
        self.id = id
        self.references = references
        self.source = source
        self.type = type
    }
}

/// Seatmap
public struct SeatMap: Codable {
    /// Static Seatmap Url
    public var staticURL: String?

    public init(staticURL: String? = nil) {
        self.staticURL = staticURL
    }

    private enum CodingKeys: String, CodingKey {
        case staticURL = "staticUrl"
    }
}

/// Segment
public struct Segment: Codable {
    /// The ID of the classification's level
    public var id: String?
    /// The Name of the classification's level
    public var name: String?

    public init(id: String? = nil, name: String? = nil) {
        self.id = id
        self.name = name
    }
}

/// Social networks data
public struct Social: Codable {
    /// Twitter data
    public var twitter: Twitter?

    public init(twitter: Twitter? = nil) {
        self.twitter = twitter
    }
}

/// Event's Start Dates
public struct StartDates: Codable {
    /// Boolean flag to indicate whether or not the start date is TBA
    public var isDateTBA: Bool
    /// Boolean flag to indicate whether or not the start date is TBD
    public var isDateTBD: Bool
    /// The event start datetime
    ///
    /// Example: "yyyy-MM-ddThh:mm:ssZ"
    public var dateTime: Date?
    /// The event start date in local date
    ///
    /// Example: "yyyy-MM-dd"
    public var localDate: NaiveDate?
    public var localTime: LocalTime?
    /// Boolean flag to indicate whether or not the event start time has no specific time
    public var isNoSpecificTime: Bool
    /// Boolean flag to indicate whether or not the start time is TBA
    public var isTimeTBA: Bool

    public init(isDateTBA: Bool? = nil, isDateTBD: Bool? = nil, dateTime: Date? = nil, localDate: NaiveDate? = nil, localTime: LocalTime? = nil, isNoSpecificTime: Bool? = nil, isTimeTBA: Bool? = nil) {
        self.isDateTBA = isDateTBA ?? false
        self.isDateTBD = isDateTBD ?? false
        self.dateTime = dateTime
        self.localDate = localDate
        self.localTime = localTime
        self.isNoSpecificTime = isNoSpecificTime ?? false
        self.isTimeTBA = isTimeTBA ?? false
    }

    private enum CodingKeys: String, CodingKey {
        case isDateTBA = "dateTBA"
        case isDateTBD = "dateTBD"
        case dateTime
        case localDate
        case localTime
        case isNoSpecificTime = "noSpecificTime"
        case isTimeTBA = "timeTBA"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isDateTBA = try values.decodeIfPresent(Bool.self, forKey: .isDateTBA) ?? false
        self.isDateTBD = try values.decodeIfPresent(Bool.self, forKey: .isDateTBD) ?? false
        self.dateTime = try values.decodeIfPresent(Date.self, forKey: .dateTime)
        self.localDate = try values.decodeIfPresent(NaiveDate.self, forKey: .localDate)
        self.localTime = try values.decodeIfPresent(LocalTime.self, forKey: .localTime)
        self.isNoSpecificTime = try values.decodeIfPresent(Bool.self, forKey: .isNoSpecificTime) ?? false
        self.isTimeTBA = try values.decodeIfPresent(Bool.self, forKey: .isTimeTBA) ?? false
    }
}

/// State
public struct State: Codable {
    /// Name of the entity
    public var name: String?
    /// State code
    public var stateCode: String?

    public init(name: String? = nil, stateCode: String? = nil) {
        self.name = name
        self.stateCode = stateCode
    }
}

/// Event's extension (ticketmaster source)
public struct TicketmasterEventExtensions: Codable {
    /// Event's display settings extension
    public var displaySettings: DisplaySettingExtension?

    public init(displaySettings: DisplaySettingExtension? = nil) {
        self.displaySettings = displaySettings
    }
}

/// Twitter data
public struct Twitter: Codable {
    /// Twitter handle
    ///
    /// Example: "@a Twitter handle exampe"
    public var handle: Handle?
    /// Twitter hashtags
    ///
    /// Example: "#hashtag example #hashtag another example"
    public var hashtags: [String]?

    /// Twitter handle
    ///
    /// Example: "@a Twitter handle exampe"
    public enum Handle: String, Codable, CaseIterable {
        case aTwitterHandle = "@a Twitter handle"
    }

    public init(handle: Handle? = nil, hashtags: [String]? = nil) {
        self.handle = handle
        self.hashtags = hashtags
    }
}

/// Venue
public struct Venue: Codable {
    /// Venue accessible seating detail
    public var accessibleSeatingDetail: String?
    /// Additional information of the entity
    public var additionalInfo: String?
    /// Address
    public var address: Address?
    /// Venue box office information
    public var boxOfficeInfo: VenueBoxOfficeInfo?
    /// City
    public var city: City?
    /// Country
    public var country: Country?
    /// Default currency of ticket prices for events in this venue
    public var currency: String?
    /// Description's of the entity
    public var description: String?
    public var distance: Double?
    /// The list of associated DMAs (Designated Market Areas) of the venue
    public var dma: [Dma]?
    /// List of external links
    public var externalLinks: [String: [ExternalLink]]?
    /// Venue general information
    public var generalInfo: VenueGeneralInfo?
    /// Unique id of the entity in the discovery API
    public var id: String
    /// Images of the entity
    public var images: [Image]?
    /// Locale in which the content is returned
    public var locale: String?
    /// Location
    public var location: Location?
    /// Markets of the venue
    public var markets: [Market]?
    /// Name of the entity
    public var name: String?
    /// Venue parking info
    public var parkingDetail: String?
    /// Postal code / zipcode of the venue
    public var postalCode: String?
    /// Social networks data
    public var social: Social?
    /// State
    public var state: State?
    /// Indicate if this is a test entity, by default test entities won't appear in discovery API
    public var isTest: Bool
    /// Timezone of the venue
    public var timezone: String?
    /// Type of the entity
    public var type: `Type`
    public var units: String?
    /// Number of upcoming events
    public var upcomingEvents: [String: Int]?
    /// URL of a web site detail page of the entity
    public var url: String?

    /// Type of the entity
    public enum `Type`: String, Codable, CaseIterable {
        case event
        case venue
        case attraction
    }

    public init(accessibleSeatingDetail: String? = nil, additionalInfo: String? = nil, address: Address? = nil, boxOfficeInfo: VenueBoxOfficeInfo? = nil, city: City? = nil, country: Country? = nil, currency: String? = nil, description: String? = nil, distance: Double? = nil, dma: [Dma]? = nil, externalLinks: [String: [ExternalLink]]? = nil, generalInfo: VenueGeneralInfo? = nil, id: String, images: [Image]? = nil, locale: String? = nil, location: Location? = nil, markets: [Market]? = nil, name: String? = nil, parkingDetail: String? = nil, postalCode: String? = nil, social: Social? = nil, state: State? = nil, isTest: Bool? = nil, timezone: String? = nil, type: `Type`, units: String? = nil, upcomingEvents: [String: Int]? = nil, url: String? = nil) {
        self.accessibleSeatingDetail = accessibleSeatingDetail
        self.additionalInfo = additionalInfo
        self.address = address
        self.boxOfficeInfo = boxOfficeInfo
        self.city = city
        self.country = country
        self.currency = currency
        self.description = description
        self.distance = distance
        self.dma = dma
        self.externalLinks = externalLinks
        self.generalInfo = generalInfo
        self.id = id
        self.images = images
        self.locale = locale
        self.location = location
        self.markets = markets
        self.name = name
        self.parkingDetail = parkingDetail
        self.postalCode = postalCode
        self.social = social
        self.state = state
        self.isTest = isTest ?? false
        self.timezone = timezone
        self.type = type
        self.units = units
        self.upcomingEvents = upcomingEvents
        self.url = url
    }

    private enum CodingKeys: String, CodingKey {
        case accessibleSeatingDetail
        case additionalInfo
        case address
        case boxOfficeInfo
        case city
        case country
        case currency
        case description
        case distance
        case dma
        case externalLinks
        case generalInfo
        case id
        case images
        case locale
        case location
        case markets
        case name
        case parkingDetail
        case postalCode
        case social
        case state
        case isTest = "test"
        case timezone
        case type
        case units
        case upcomingEvents
        case url
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.accessibleSeatingDetail = try values.decodeIfPresent(String.self, forKey: .accessibleSeatingDetail)
        self.additionalInfo = try values.decodeIfPresent(String.self, forKey: .additionalInfo)
        self.address = try values.decodeIfPresent(Address.self, forKey: .address)
        self.boxOfficeInfo = try values.decodeIfPresent(VenueBoxOfficeInfo.self, forKey: .boxOfficeInfo)
        self.city = try values.decodeIfPresent(City.self, forKey: .city)
        self.country = try values.decodeIfPresent(Country.self, forKey: .country)
        self.currency = try values.decodeIfPresent(String.self, forKey: .currency)
        self.description = try values.decodeIfPresent(String.self, forKey: .description)
        self.distance = try values.decodeIfPresent(Double.self, forKey: .distance)
        self.dma = try values.decodeIfPresent([Dma].self, forKey: .dma)
        self.externalLinks = try values.decodeIfPresent([String: [ExternalLink]].self, forKey: .externalLinks)
        self.generalInfo = try values.decodeIfPresent(VenueGeneralInfo.self, forKey: .generalInfo)
        self.id = try values.decode(String.self, forKey: .id)
        self.images = try values.decodeIfPresent([Image].self, forKey: .images)
        self.locale = try values.decodeIfPresent(String.self, forKey: .locale)
        self.location = try values.decodeIfPresent(Location.self, forKey: .location)
        self.markets = try values.decodeIfPresent([Market].self, forKey: .markets)
        self.name = try values.decodeIfPresent(String.self, forKey: .name)
        self.parkingDetail = try values.decodeIfPresent(String.self, forKey: .parkingDetail)
        self.postalCode = try values.decodeIfPresent(String.self, forKey: .postalCode)
        self.social = try values.decodeIfPresent(Social.self, forKey: .social)
        self.state = try values.decodeIfPresent(State.self, forKey: .state)
        self.isTest = try values.decodeIfPresent(Bool.self, forKey: .isTest) ?? false
        self.timezone = try values.decodeIfPresent(String.self, forKey: .timezone)
        self.type = try values.decode(`Type`.self, forKey: .type)
        self.units = try values.decodeIfPresent(String.self, forKey: .units)
        self.upcomingEvents = try values.decodeIfPresent([String: Int].self, forKey: .upcomingEvents)
        self.url = try values.decodeIfPresent(String.self, forKey: .url)
    }
}

/// Venue box office information
public struct VenueBoxOfficeInfo: Codable {
    /// Venue box office accepted payment details
    public var acceptedPaymentDetail: String?
    /// Venue box office opening hours
    public var openHoursDetail: String?
    /// Venue box office phone number
    public var phoneNumberDetail: String?
    /// Venue box office will call details
    public var willCallDetail: String?

    public init(acceptedPaymentDetail: String? = nil, openHoursDetail: String? = nil, phoneNumberDetail: String? = nil, willCallDetail: String? = nil) {
        self.acceptedPaymentDetail = acceptedPaymentDetail
        self.openHoursDetail = openHoursDetail
        self.phoneNumberDetail = phoneNumberDetail
        self.willCallDetail = willCallDetail
    }
}

/// All Venue's extensions
public struct VenueExtensions: Codable {
    /// Venue's geocode extension
    public var geolocation: GeolocationVenueExtensions?

    public init(geolocation: GeolocationVenueExtensions? = nil) {
        self.geolocation = geolocation
    }
}

/// Venue general information
public struct VenueGeneralInfo: Codable {
    /// Venue children rule
    public var childRule: String?
    /// Venue general rules
    public var generalRule: String?

    public init(childRule: String? = nil, generalRule: String? = nil) {
        self.childRule = childRule
        self.generalRule = generalRule
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
