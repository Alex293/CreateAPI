// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get
import URLQueryEncoder

extension Paths {
    public static var analyses: Analyses {
        Analyses(path: "/analyses")
    }

    public struct Analyses {
        /// Path: `/analyses`
        public let path: String
    }
}

extension Paths.Analyses {
    public func username(_ username: String) -> WithUsername {
        WithUsername(path: "\(path)/\(username)")
    }

    public struct WithUsername {
        /// Path: `/analyses/{username}`
        public let path: String
    }
}

extension Paths.Analyses.WithUsername {
    public func projectSlug(_ projectSlug: String) -> WithProjectSlug {
        WithProjectSlug(path: "\(path)/\(projectSlug)")
    }

    public struct WithProjectSlug {
        /// Path: `/analyses/{username}/{project_slug}`
        public let path: String

        /// List all analyses for a project
        public func get(page: Int? = nil, size: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(page, size))
        }

        public struct GetResponse: Decodable {
            public var count: Int?
            public var results: [BotifyAPI.Analysis]?
            public var next: String?
            public var previous: String?
            public var page: Int?
            public var size: Int?

            public init(count: Int? = nil, results: [BotifyAPI.Analysis]? = nil, next: String? = nil, previous: String? = nil, page: Int? = nil, size: Int? = nil) {
                self.count = count
                self.results = results
                self.next = next
                self.previous = previous
                self.page = page
                self.size = size
            }
        }

        private func makeGetQuery(_ page: Int?, _ size: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(page, forKey: "page")
            encoder.encode(size, forKey: "size")
            return encoder.items
        }
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug {
    public func analysisSlug(_ analysisSlug: String) -> WithAnalysisSlug {
        WithAnalysisSlug(path: "\(path)/\(analysisSlug)")
    }

    public struct WithAnalysisSlug {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}`
        public let path: String

        /// Get an Analysis detail
        public var get: Request<BotifyAPI.AnalysisDetail> {
            .get(path)
        }
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug {
    public var crawlStatistics: CrawlStatistics {
        CrawlStatistics(path: path + "/crawl_statistics")
    }

    public struct CrawlStatistics {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/crawl_statistics`
        public let path: String

        /// Return global statistics for an analysis
        public var get: Request<BotifyAPI.CrawlStatistics> {
            .get(path)
        }
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.CrawlStatistics {
    public var time: Time {
        Time(path: path + "/time")
    }

    public struct Time {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/crawl_statistics/time`
        public let path: String

        /// Return crawl statistics grouped by time frequency (1 min, 5 mins or 60 min)
        ///
        /// Return crawl statistics grouped by time frequency (1 min, 5 mins or 60 min) for an analysis
        public func get(limit: Int? = nil, frequency: Frequency) -> Request<BotifyAPI.CrawlStatisticsTime> {
            .get(path, query: makeGetQuery(limit, frequency))
        }

        private func makeGetQuery(_ limit: Int?, _ frequency: Frequency) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(limit, forKey: "limit")
            encoder.encode(frequency, forKey: "frequency")
            return encoder.items
        }

        public enum Frequency: String, Codable, CaseIterable {
            case _1mn = "1mn"
            case _5mn = "5mn"
            case _60mn = "60mn"
        }
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.CrawlStatistics {
    public var urls: URLs {
        URLs(path: path + "/urls")
    }

    public struct URLs {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/crawl_statistics/urls`
        public let path: String
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.CrawlStatistics.URLs {
    public func listType(_ listType: String) -> WithListType {
        WithListType(path: "\(path)/\(listType)")
    }

    public struct WithListType {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/crawl_statistics/urls/{list_type}`
        public let path: String

        /// Return a list of 1000 latest URLs crawled (all crawled URLs or only URLS with HTTP errors)
        public var get: Request<[[String: AnyJSON]]> {
            .get(path)
        }
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug {
    public var features: Features {
        Features(path: path + "/features")
    }

    public struct Features {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/features`
        public let path: String
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.Features {
    public var ganalytics: Ganalytics {
        Ganalytics(path: path + "/ganalytics")
    }

    public struct Ganalytics {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/features/ganalytics`
        public let path: String
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.Features.Ganalytics {
    public var orphanURLs: OrphanURLs {
        OrphanURLs(path: path + "/orphan_urls")
    }

    public struct OrphanURLs {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/features/ganalytics/orphan_urls`
        public let path: String
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.Features.Ganalytics.OrphanURLs {
    public func medium(_ medium: String) -> WithMedium {
        WithMedium(path: "\(path)/\(medium)")
    }

    public struct WithMedium {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/features/ganalytics/orphan_urls/{medium}`
        public let path: String
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.Features.Ganalytics.OrphanURLs.WithMedium {
    public func source(_ source: String) -> WithSource {
        WithSource(path: "\(path)/\(source)")
    }

    public struct WithSource {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/features/ganalytics/orphan_urls/{medium}/{source}`
        public let path: String

        /// List of Orphan URLs
        ///
        /// List of Orphan URLs. URLs which generated visits from the selected source according to Google Analytics data, but were not crawled with by the Botify crawler (either because no links to them were found on the website, or because the crawler was not allowed to follow these links according to the project settings).   For a search engine (medium: origanic; sources: all, aol, ask, baidu, bing, google, naver, yahoo, yandex) or a social network (medium: social; sources: all, facebook, google+, linkedin, pinterest, reddit, tumblr, twitter)
        public func get(page: Int? = nil, size: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(page, size))
        }

        public struct GetResponse: Decodable {
            public var count: Int?
            public var results: [BotifyAPI.CrawlOrphanURLs]?
            public var next: String?
            public var previous: String?
            public var page: Int?
            public var size: Int?

            public init(count: Int? = nil, results: [BotifyAPI.CrawlOrphanURLs]? = nil, next: String? = nil, previous: String? = nil, page: Int? = nil, size: Int? = nil) {
                self.count = count
                self.results = results
                self.next = next
                self.previous = previous
                self.page = page
                self.size = size
            }
        }

        private func makeGetQuery(_ page: Int?, _ size: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(page, forKey: "page")
            encoder.encode(size, forKey: "size")
            return encoder.items
        }
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.Features {
    public var links: Links {
        Links(path: path + "/links")
    }

    public struct Links {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/features/links`
        public let path: String
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.Features.Links {
    public var percentiles: Percentiles {
        Percentiles(path: path + "/percentiles")
    }

    public struct Percentiles {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/features/links/percentiles`
        public let path: String

        /// Get inlinks percentiles
        public var get: Request<BotifyAPI.LinksPercentiles> {
            .get(path)
        }
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.Features {
    public var pagerank: Pagerank {
        Pagerank(path: path + "/pagerank")
    }

    public struct Pagerank {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/features/pagerank`
        public let path: String
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.Features.Pagerank {
    public var lost: Lost {
        Lost(path: path + "/lost")
    }

    public struct Lost {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/features/pagerank/lost`
        public let path: String

        /// Lost pagerank
        public var get: Request<BotifyAPI.PageRankLost> {
            .get(path)
        }
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.Features {
    public var sitemaps: Sitemaps {
        Sitemaps(path: path + "/sitemaps")
    }

    public struct Sitemaps {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/features/sitemaps`
        public let path: String
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.Features.Sitemaps {
    public var report: Report {
        Report(path: path + "/report")
    }

    public struct Report {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/features/sitemaps/report`
        public let path: String

        /// Get global information of the sitemaps found (sitemaps indexes, invalid sitemaps urls, etc
        ///
        /// Get global information of the sitemaps found (sitemaps indexes, invalid sitemaps urls, etc.)
        public var get: Request<BotifyAPI.SitemapsReport> {
            .get(path)
        }
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.Features.Sitemaps {
    public var samples: Samples {
        Samples(path: path + "/samples")
    }

    public struct Samples {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/features/sitemaps/samples`
        public let path: String
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.Features.Sitemaps.Samples {
    public var outOfConfig: OutOfConfig {
        OutOfConfig(path: path + "/out_of_config")
    }

    public struct OutOfConfig {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/features/sitemaps/samples/out_of_config`
        public let path: String

        /// Sample list of URLs which were found in your sitemaps but outside of the
        ///
        /// Sample list of URLs which were found in your sitemaps but outside of the crawl perimeter defined for the project, for instance domain/subdomain or protocol (HTTP/HTTPS) not allowed in the crawl settings.
        public func get(page: Int? = nil, size: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(page, size))
        }

        public struct GetResponse: Decodable {
            public var count: Int?
            public var results: [String]?
            public var next: String?
            public var previous: String?
            public var page: Int?
            public var size: Int?

            public init(count: Int? = nil, results: [String]? = nil, next: String? = nil, previous: String? = nil, page: Int? = nil, size: Int? = nil) {
                self.count = count
                self.results = results
                self.next = next
                self.previous = previous
                self.page = page
                self.size = size
            }
        }

        private func makeGetQuery(_ page: Int?, _ size: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(page, forKey: "page")
            encoder.encode(size, forKey: "size")
            return encoder.items
        }
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.Features.Sitemaps.Samples {
    public var sitemapOnly: SitemapOnly {
        SitemapOnly(path: path + "/sitemap_only")
    }

    public struct SitemapOnly {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/features/sitemaps/samples/sitemap_only`
        public let path: String

        /// Sample list of URLs which were found in your sitemaps, within the project
        ///
        /// Sample list of URLs which were found in your sitemaps, within the project allowed scope (allowed domains/subdomains/protocols), but not found by the Botify crawler.
        public func get(page: Int? = nil, size: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(page, size))
        }

        public struct GetResponse: Decodable {
            public var count: Int?
            public var results: [String]?
            public var next: String?
            public var previous: String?
            public var page: Int?
            public var size: Int?

            public init(count: Int? = nil, results: [String]? = nil, next: String? = nil, previous: String? = nil, page: Int? = nil, size: Int? = nil) {
                self.count = count
                self.results = results
                self.next = next
                self.previous = previous
                self.page = page
                self.size = size
            }
        }

        private func makeGetQuery(_ page: Int?, _ size: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(page, forKey: "page")
            encoder.encode(size, forKey: "size")
            return encoder.items
        }
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.Features {
    public var topDomains: TopDomains {
        TopDomains(path: path + "/top_domains")
    }

    public struct TopDomains {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/features/top_domains`
        public let path: String
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.Features.TopDomains {
    public var domains: Domains {
        Domains(path: path + "/domains")
    }

    public struct Domains {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/features/top_domains/domains`
        public let path: String

        /// Top domains
        public func get(page: Int? = nil, size: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(page, size))
        }

        public struct GetResponse: Decodable {
            public var count: Int?
            public var results: [BotifyAPI.LinksTopDomains]?
            public var next: String?
            public var previous: String?
            public var page: Int?
            public var size: Int?

            public init(count: Int? = nil, results: [BotifyAPI.LinksTopDomains]? = nil, next: String? = nil, previous: String? = nil, page: Int? = nil, size: Int? = nil) {
                self.count = count
                self.results = results
                self.next = next
                self.previous = previous
                self.page = page
                self.size = size
            }
        }

        private func makeGetQuery(_ page: Int?, _ size: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(page, forKey: "page")
            encoder.encode(size, forKey: "size")
            return encoder.items
        }
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.Features.TopDomains {
    public var subdomains: Subdomains {
        Subdomains(path: path + "/subdomains")
    }

    public struct Subdomains {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/features/top_domains/subdomains`
        public let path: String

        /// Top subddomains
        public func get(page: Int? = nil, size: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(page, size))
        }

        public struct GetResponse: Decodable {
            public var count: Int?
            public var results: [BotifyAPI.LinksTopDomains]?
            public var next: String?
            public var previous: String?
            public var page: Int?
            public var size: Int?

            public init(count: Int? = nil, results: [BotifyAPI.LinksTopDomains]? = nil, next: String? = nil, previous: String? = nil, page: Int? = nil, size: Int? = nil) {
                self.count = count
                self.results = results
                self.next = next
                self.previous = previous
                self.page = page
                self.size = size
            }
        }

        private func makeGetQuery(_ page: Int?, _ size: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(page, forKey: "page")
            encoder.encode(size, forKey: "size")
            return encoder.items
        }
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug {
    public var urls: URLs {
        URLs(path: path + "/urls")
    }

    public struct URLs {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/urls`
        public let path: String

        /// Executes a query and returns a paginated response
        public func post(parameters: PostParameters? = nil, _ body: Data? = nil) -> Request<PostResponse> {
            .post(path, query: parameters?.asQuery, body: body)
        }

        public struct PostResponse: Decodable {
            public var count: Int?
            public var results: [[String: AnyJSON]]?
            public var next: String?
            public var previous: String?
            public var page: Int?
            public var size: Int?

            public init(count: Int? = nil, results: [[String: AnyJSON]]? = nil, next: String? = nil, previous: String? = nil, page: Int? = nil, size: Int? = nil) {
                self.count = count
                self.results = results
                self.next = next
                self.previous = previous
                self.page = page
                self.size = size
            }
        }

        public struct PostParameters {
            public var area: Area?
            public var page: Int?
            public var size: Int?

            public enum Area: String, Codable, CaseIterable {
                case current
                case disappeared
                case new
                case searchEnginesOrphans = "search_engines_orphans"
            }

            public init(area: Area? = nil, page: Int? = nil, size: Int? = nil) {
                self.area = area
                self.page = page
                self.size = size
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(area, forKey: "area")
                encoder.encode(page, forKey: "page")
                encoder.encode(size, forKey: "size")
                return encoder.items
            }
        }
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.URLs {
    public var aggs: Aggs {
        Aggs(path: path + "/aggs")
    }

    public struct Aggs {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/urls/aggs`
        public let path: String

        /// Query aggregator
        ///
        /// Query aggregator. It accepts multiple queries
        public func post(area: Area? = nil, _ body: Data? = nil) -> Request<[[String: AnyJSON]]> {
            .post(path, query: makePostQuery(area), body: body)
        }

        private func makePostQuery(_ area: Area?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(area, forKey: "area")
            return encoder.items
        }

        public enum Area: String, Codable, CaseIterable {
            case current
            case disappeared
            case new
            case searchEnginesOrphans = "search_engines_orphans"
        }
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.URLs {
    public var datamodel: Datamodel {
        Datamodel(path: path + "/datamodel")
    }

    public struct Datamodel {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/urls/datamodel`
        public let path: String

        /// Gets an Analysis datamodel
        public func get(area: Area? = nil) -> Request<BotifyAPI.CrawlDatamodel> {
            .get(path, query: makeGetQuery(area))
        }

        private func makeGetQuery(_ area: Area?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(area, forKey: "area")
            return encoder.items
        }

        public enum Area: String, Codable, CaseIterable {
            case current
            case disappeared
            case new
            case searchEnginesOrphans = "search_engines_orphans"
        }
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.URLs {
    public var export: Export {
        Export(path: path + "/export")
    }

    public struct Export {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/urls/export`
        public let path: String

        /// A list of the CSV Exports requests and their current status
        public func get(page: Int? = nil, size: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(page, size))
        }

        public struct GetResponse: Decodable {
            public var count: Int?
            public var results: [BotifyAPI.CsvExportStatus]?
            public var next: String?
            public var previous: String?
            public var page: Int?
            public var size: Int?

            public init(count: Int? = nil, results: [BotifyAPI.CsvExportStatus]? = nil, next: String? = nil, previous: String? = nil, page: Int? = nil, size: Int? = nil) {
                self.count = count
                self.results = results
                self.next = next
                self.previous = previous
                self.page = page
                self.size = size
            }
        }

        private func makeGetQuery(_ page: Int?, _ size: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(page, forKey: "page")
            encoder.encode(size, forKey: "size")
            return encoder.items
        }

        /// Creates a new UrlExport object and starts a task that will export the results into a csv
        ///
        /// Creates a new UrlExport object and starts a task that will export the results into a csv. Returns the model id that manages the task
        public func post(area: Area? = nil, _ body: Data? = nil) -> Request<BotifyAPI.CsvExportStatus> {
            .post(path, query: makePostQuery(area), body: body)
        }

        private func makePostQuery(_ area: Area?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(area, forKey: "area")
            return encoder.items
        }

        public enum Area: String, Codable, CaseIterable {
            case current
            case disappeared
            case new
            case searchEnginesOrphans = "search_engines_orphans"
        }
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.URLs.Export {
    public func urlExportID(_ urlExportID: String) -> WithURLExportID {
        WithURLExportID(path: "\(path)/\(urlExportID)")
    }

    public struct WithURLExportID {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/urls/export/{url_export_id}`
        public let path: String

        /// Checks the status of an CSVUrlExportJob object
        ///
        /// Checks the status of an CSVUrlExportJob object. Returns json object with the status.
        public var get: Request<BotifyAPI.CsvExportStatus> {
            .get(path)
        }
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.URLs {
    public var suggestedFilters: SuggestedFilters {
        SuggestedFilters(path: path + "/suggested_filters")
    }

    public struct SuggestedFilters {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/urls/suggested_filters`
        public let path: String

        /// Return most frequent segments (= suggested patterns in the previous version)
        ///
        /// Return most frequent segments (= suggested patterns in the previous version) for a Botify Query.
        public func post(area: Area? = nil, _ body: Data? = nil) -> Request<BotifyAPI.URLsAggsQuery> {
            .post(path, query: makePostQuery(area), body: body)
        }

        private func makePostQuery(_ area: Area?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(area, forKey: "area")
            return encoder.items
        }

        public enum Area: String, Codable, CaseIterable {
            case current
            case new
        }
    }
}

extension Paths.Analyses.WithUsername.WithProjectSlug.WithAnalysisSlug.URLs {
    public func url(_ url: String) -> WithURL {
        WithURL(path: "\(path)/\(url)")
    }

    public struct WithURL {
        /// Path: `/analyses/{username}/{project_slug}/{analysis_slug}/urls/{url}`
        public let path: String

        /// Gets the detail of an URL for an analysis
        public func get(fields: [String]? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(fields))
        }

        private func makeGetQuery(_ fields: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fields, forKey: "fields", explode: false)
            return encoder.items
        }
    }
}

extension Paths {
    public static var projects: Projects {
        Projects(path: "/projects")
    }

    public struct Projects {
        /// Path: `/projects`
        public let path: String
    }
}

extension Paths.Projects {
    public func username(_ username: String) -> WithUsername {
        WithUsername(path: "\(path)/\(username)")
    }

    public struct WithUsername {
        /// Path: `/projects/{username}`
        public let path: String

        /// List all active projects for the user
        public func get(page: Int? = nil, size: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(page, size))
        }

        public struct GetResponse: Decodable {
            public var count: Int?
            public var results: [BotifyAPI.Project]?
            public var next: String?
            public var previous: String?
            public var page: Int?
            public var size: Int?

            public init(count: Int? = nil, results: [BotifyAPI.Project]? = nil, next: String? = nil, previous: String? = nil, page: Int? = nil, size: Int? = nil) {
                self.count = count
                self.results = results
                self.next = next
                self.previous = previous
                self.page = page
                self.size = size
            }
        }

        private func makeGetQuery(_ page: Int?, _ size: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(page, forKey: "page")
            encoder.encode(size, forKey: "size")
            return encoder.items
        }
    }
}

extension Paths.Projects.WithUsername {
    public func projectSlug(_ projectSlug: String) -> WithProjectSlug {
        WithProjectSlug(path: "\(path)/\(projectSlug)")
    }

    public struct WithProjectSlug {
        /// Path: `/projects/{username}/{project_slug}`
        public let path: String
    }
}

extension Paths.Projects.WithUsername.WithProjectSlug {
    public var features: Features {
        Features(path: path + "/features")
    }

    public struct Features {
        /// Path: `/projects/{username}/{project_slug}/features`
        public let path: String
    }
}

extension Paths.Projects.WithUsername.WithProjectSlug.Features {
    public var urlRewriting: URLRewriting {
        URLRewriting(path: path + "/url_rewriting")
    }

    public struct URLRewriting {
        /// Path: `/projects/{username}/{project_slug}/features/url_rewriting`
        public let path: String
    }
}

extension Paths.Projects.WithUsername.WithProjectSlug.Features.URLRewriting {
    public var rulesValidator: RulesValidator {
        RulesValidator(path: path + "/rules_validator")
    }

    public struct RulesValidator {
        /// Path: `/projects/{username}/{project_slug}/features/url_rewriting/rules_validator`
        public let path: String

        /// Match and replace parts of a URL based on rules passed in POST data
        ///
        /// Match and replace parts of a URL based on rules passed in POST data.
        public var post: Request<BotifyAPI.URLRewritingRulesSerializer> {
            .post(path)
        }
    }
}

extension Paths.Projects.WithUsername.WithProjectSlug {
    public var filters: Filters {
        Filters(path: path + "/filters")
    }

    public struct Filters {
        /// Path: `/projects/{username}/{project_slug}/filters`
        public let path: String

        /// List all the project's saved filters (each filter's name, ID and filter value)
        public func get(page: Int? = nil, size: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(page, size))
        }

        public struct GetResponse: Decodable {
            public var count: Int?
            public var results: [BotifyAPI.ProjectSavedFilter]?
            public var next: String?
            public var previous: String?
            public var page: Int?
            public var size: Int?

            public init(count: Int? = nil, results: [BotifyAPI.ProjectSavedFilter]? = nil, next: String? = nil, previous: String? = nil, page: Int? = nil, size: Int? = nil) {
                self.count = count
                self.results = results
                self.next = next
                self.previous = previous
                self.page = page
                self.size = size
            }
        }

        private func makeGetQuery(_ page: Int?, _ size: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(page, forKey: "page")
            encoder.encode(size, forKey: "size")
            return encoder.items
        }
    }
}

extension Paths.Projects.WithUsername.WithProjectSlug.Filters {
    public func identifier(_ identifier: String) -> WithIdentifier {
        WithIdentifier(path: "\(path)/\(identifier)")
    }

    public struct WithIdentifier {
        /// Path: `/projects/{username}/{project_slug}/filters/{identifier}`
        public let path: String

        /// Retrieves a specific saved filter's name, ID and filter value
        public var get: Request<BotifyAPI.ProjectSavedFilter> {
            .get(path)
        }
    }
}

extension Paths.Projects.WithUsername.WithProjectSlug {
    public var urls: URLs {
        URLs(path: path + "/urls")
    }

    public struct URLs {
        /// Path: `/projects/{username}/{project_slug}/urls`
        public let path: String
    }
}

extension Paths.Projects.WithUsername.WithProjectSlug.URLs {
    public var aggs: Aggs {
        Aggs(path: path + "/aggs")
    }

    public struct Aggs {
        /// Path: `/projects/{username}/{project_slug}/urls/aggs`
        public let path: String

        /// Project Query aggregator
        ///
        /// Project Query aggregator. It accepts multiple queries that will be executed on all completed analyses in the project
        public func post(parameters: PostParameters? = nil, _ body: Data? = nil) -> Request<[String: AnyJSON]> {
            .post(path, query: parameters?.asQuery, body: body)
        }

        public struct PostParameters {
            public var area: Area?
            public var lastAnalysisSlug: String?
            public var nbAnalyses: Int?

            public enum Area: String, Codable, CaseIterable {
                case current
                case disappeared
                case new
            }

            public init(area: Area? = nil, lastAnalysisSlug: String? = nil, nbAnalyses: Int? = nil) {
                self.area = area
                self.lastAnalysisSlug = lastAnalysisSlug
                self.nbAnalyses = nbAnalyses
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(area, forKey: "area")
                encoder.encode(lastAnalysisSlug, forKey: "last_analysis_slug")
                encoder.encode(nbAnalyses, forKey: "nb_analyses")
                return encoder.items
            }
        }
    }
}

public enum Paths {}
