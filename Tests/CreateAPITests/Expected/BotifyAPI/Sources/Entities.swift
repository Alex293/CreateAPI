// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

public struct SitemapsReport: Codable {
    public var count: Int
    public var sitemapOnly: SitemapsReportOnly
    public var sitemapIndexes: [SitemapsReportSitemap]
    public var sitemaps: [SitemapsReportSitemap]
    public var errors: [SitemapsReportSitemap]

    public init(count: Int, sitemapOnly: SitemapsReportOnly, sitemapIndexes: [SitemapsReportSitemap], sitemaps: [SitemapsReportSitemap], errors: [SitemapsReportSitemap]) {
        self.count = count
        self.sitemapOnly = sitemapOnly
        self.sitemapIndexes = sitemapIndexes
        self.sitemaps = sitemaps
        self.errors = errors
    }

    private enum CodingKeys: String, CodingKey {
        case count
        case sitemapOnly = "sitemap_only"
        case sitemapIndexes = "sitemap_indexes"
        case sitemaps
        case errors
    }
}

public struct SitemapsReportSitemapError: Codable {
    public var type: String
    public var message: String

    public init(type: String, message: String) {
        self.type = type
        self.message = message
    }
}

public struct URLsAggs: Codable {
    public var status: Int
    public var data: URLsAgg?
    public var error: URLsErrorAgg?

    public init(status: Int, data: URLsAgg? = nil, error: URLsErrorAgg? = nil) {
        self.status = status
        self.data = data
        self.error = error
    }
}

public struct CrawlOrphanURLs: Codable {
    public var url: String
    public var visits: Int

    public init(url: String, visits: Int) {
        self.url = url
        self.visits = visits
    }
}

public struct LinksPercentilesItem: Codable {
    public var min: Int
    public var max: Int
    public var urlTotal: Int
    public var metricTotal: Int
    public var avg: Int
    public var id: Int

    public init(min: Int, max: Int, urlTotal: Int, metricTotal: Int, avg: Int, id: Int) {
        self.min = min
        self.max = max
        self.urlTotal = urlTotal
        self.metricTotal = metricTotal
        self.avg = avg
        self.id = id
    }

    private enum CodingKeys: String, CodingKey {
        case min
        case max
        case urlTotal = "url_total"
        case metricTotal = "metric_total"
        case avg
        case id
    }
}

public struct CrawlStatistics: Codable {
    public var depthCurrent: Int
    public var pagesDonesNetworkerror: Int
    public var pagesDones3xx: Int
    public var pagesDones: Int
    public var pagesDones2xx: Int
    public var lastUpdDt: Date
    public var pagesDones5xx: Int
    public var pagesDonesXxx: Int
    public var pagesDones4xx: Int
    public var pagesKnown: Int

    public init(depthCurrent: Int, pagesDonesNetworkerror: Int, pagesDones3xx: Int, pagesDones: Int, pagesDones2xx: Int, lastUpdDt: Date, pagesDones5xx: Int, pagesDonesXxx: Int, pagesDones4xx: Int, pagesKnown: Int) {
        self.depthCurrent = depthCurrent
        self.pagesDonesNetworkerror = pagesDonesNetworkerror
        self.pagesDones3xx = pagesDones3xx
        self.pagesDones = pagesDones
        self.pagesDones2xx = pagesDones2xx
        self.lastUpdDt = lastUpdDt
        self.pagesDones5xx = pagesDones5xx
        self.pagesDonesXxx = pagesDonesXxx
        self.pagesDones4xx = pagesDones4xx
        self.pagesKnown = pagesKnown
    }

    private enum CodingKeys: String, CodingKey {
        case depthCurrent = "depth_current"
        case pagesDonesNetworkerror = "pages_dones_networkerror"
        case pagesDones3xx = "pages_dones_3xx"
        case pagesDones = "pages_dones"
        case pagesDones2xx = "pages_dones_2xx"
        case lastUpdDt = "last_upd_dt"
        case pagesDones5xx = "pages_dones_5xx"
        case pagesDonesXxx = "pages_dones_xxx"
        case pagesDones4xx = "pages_dones_4xx"
        case pagesKnown = "pages_known"
    }
}

public struct CrawlDatamodelGroup: Codable {
    public var id: String
    public var name: String

    public init(id: String, name: String) {
        self.id = id
        self.name = name
    }
}

public struct URLsQuery: Codable {
    public var fields: [String]?
    public var filters: [String: AnyJSON]?
    public var sort: [[String: AnyJSON]]?

    public init(fields: [String]? = nil, filters: [String: AnyJSON]? = nil, sort: [[String: AnyJSON]]? = nil) {
        self.fields = fields
        self.filters = filters
        self.sort = sort
    }
}

public struct PageRankLost: Codable {
    public var nonCrawled: Double
    public var external: Double
    public var robotsTxt: Double

    public init(nonCrawled: Double, external: Double, robotsTxt: Double) {
        self.nonCrawled = nonCrawled
        self.external = external
        self.robotsTxt = robotsTxt
    }

    private enum CodingKeys: String, CodingKey {
        case nonCrawled = "non_crawled"
        case external
        case robotsTxt = "robots_txt"
    }
}

public struct LinksTopDomains: Codable {
    public var followLinks: Int
    public var nofollowLinks: Int
    public var domain: String
    public var followSamples: [LinksTopDomainsSamples]
    public var nofollowSamples: [LinksTopDomainsSamples]
    public var uniqueFollowLinks: Int
    public var uniqueNofollowLinks: Int

    public init(followLinks: Int, nofollowLinks: Int, domain: String, followSamples: [LinksTopDomainsSamples], nofollowSamples: [LinksTopDomainsSamples], uniqueFollowLinks: Int, uniqueNofollowLinks: Int) {
        self.followLinks = followLinks
        self.nofollowLinks = nofollowLinks
        self.domain = domain
        self.followSamples = followSamples
        self.nofollowSamples = nofollowSamples
        self.uniqueFollowLinks = uniqueFollowLinks
        self.uniqueNofollowLinks = uniqueNofollowLinks
    }

    private enum CodingKeys: String, CodingKey {
        case followLinks = "follow_links"
        case nofollowLinks = "nofollow_links"
        case domain
        case followSamples = "follow_samples"
        case nofollowSamples = "nofollow_samples"
        case uniqueFollowLinks = "unique_follow_links"
        case uniqueNofollowLinks = "unique_nofollow_links"
    }
}

public struct LinksTopDomainsSamples: Codable {
    public var url: String
    public var sources: [String]
    public var uniqueLinks: Int

    public init(url: String, sources: [String], uniqueLinks: Int) {
        self.url = url
        self.sources = sources
        self.uniqueLinks = uniqueLinks
    }

    private enum CodingKeys: String, CodingKey {
        case url
        case sources
        case uniqueLinks = "unique_links"
    }
}

public struct User: Codable {
    public var login: String?
    public var email: String?
    public var isOrganization: String?
    public var url: String?
    public var dateJoined: Date?
    public var status: String?
    public var firstName: String?
    public var lastName: String?
    public var companyName: String?

    public init(login: String? = nil, email: String? = nil, isOrganization: String? = nil, url: String? = nil, dateJoined: Date? = nil, status: String? = nil, firstName: String? = nil, lastName: String? = nil, companyName: String? = nil) {
        self.login = login
        self.email = email
        self.isOrganization = isOrganization
        self.url = url
        self.dateJoined = dateJoined
        self.status = status
        self.firstName = firstName
        self.lastName = lastName
        self.companyName = companyName
    }

    private enum CodingKeys: String, CodingKey {
        case login
        case email
        case isOrganization = "is_organization"
        case url
        case dateJoined = "date_joined"
        case status
        case firstName = "first_name"
        case lastName = "last_name"
        case companyName = "company_name"
    }
}

public struct SitemapsReportSitemap: Codable {
    public var url: String
    public var validURLs: Int?
    public var invalidURLs: Int?
    public var fileType: String?
    public var error: SitemapsReportSitemapError?
    public var sitemapIndexes: [String]?

    public init(url: String, validURLs: Int? = nil, invalidURLs: Int? = nil, fileType: String? = nil, error: SitemapsReportSitemapError? = nil, sitemapIndexes: [String]? = nil) {
        self.url = url
        self.validURLs = validURLs
        self.invalidURLs = invalidURLs
        self.fileType = fileType
        self.error = error
        self.sitemapIndexes = sitemapIndexes
    }

    private enum CodingKeys: String, CodingKey {
        case url
        case validURLs = "valid_urls"
        case invalidURLs = "invalid_urls"
        case fileType = "file_type"
        case error
        case sitemapIndexes = "sitemap_indexes"
    }
}

public struct CsvExportStatus: Codable {
    public var jobID: String?
    public var jobURL: String?
    public var jobStatus: String?
    public var nbResults: Int?
    public var area: Int?
    public var query: URLsQuery
    public var results: String?
    public var dateCreated: Date?

    public init(jobID: String? = nil, jobURL: String? = nil, jobStatus: String? = nil, nbResults: Int? = nil, area: Int? = nil, query: URLsQuery, results: String? = nil, dateCreated: Date? = nil) {
        self.jobID = jobID
        self.jobURL = jobURL
        self.jobStatus = jobStatus
        self.nbResults = nbResults
        self.area = area
        self.query = query
        self.results = results
        self.dateCreated = dateCreated
    }

    private enum CodingKeys: String, CodingKey {
        case jobID = "job_id"
        case jobURL = "job_url"
        case jobStatus = "job_status"
        case nbResults = "nb_results"
        case area
        case query
        case results
        case dateCreated = "date_created"
    }
}

public struct SitemapsReportOnly: Codable {
    public var outOfConfiguration: Int
    public var inConfiguration: Int

    public init(outOfConfiguration: Int, inConfiguration: Int) {
        self.outOfConfiguration = outOfConfiguration
        self.inConfiguration = inConfiguration
    }

    private enum CodingKeys: String, CodingKey {
        case outOfConfiguration = "out_of_configuration"
        case inConfiguration = "in_configuration"
    }
}

public struct RewritingRuleSerializer: Codable {
    public var regex: String
    public var replace: String
    public var isIgnoreCase: Bool

    public init(regex: String, replace: String, isIgnoreCase: Bool) {
        self.regex = regex
        self.replace = replace
        self.isIgnoreCase = isIgnoreCase
    }

    private enum CodingKeys: String, CodingKey {
        case regex
        case replace
        case isIgnoreCase = "ignore_case"
    }
}

public struct LinksPercentiles: Codable {
    public var domain: String
    public var percentiles: [LinksPercentilesItem]

    public init(domain: String, percentiles: [LinksPercentilesItem]) {
        self.domain = domain
        self.percentiles = percentiles
    }
}

public struct URLsErrorAgg: Codable {
    public var message: String
    public var errorCode: String

    public init(message: String, errorCode: String) {
        self.message = message
        self.errorCode = errorCode
    }

    private enum CodingKeys: String, CodingKey {
        case message
        case errorCode = "error_code"
    }
}

public struct Analysis: Codable {
    public var id: Int?
    public var user: User
    public var slug: String?
    public var name: String?
    public var url: String?
    public var features: String?
    public var status: String?
    public var urlsDone: String?
    public var urlsInQueue: String?
    public var config: String?
    public var dateCreated: Date?
    public var dateLaunched: Date?
    public var dateFinished: Date?
    /// Date of last modified analysis
    public var dateLastModified: Date?

    public init(id: Int? = nil, user: User, slug: String? = nil, name: String? = nil, url: String? = nil, features: String? = nil, status: String? = nil, urlsDone: String? = nil, urlsInQueue: String? = nil, config: String? = nil, dateCreated: Date? = nil, dateLaunched: Date? = nil, dateFinished: Date? = nil, dateLastModified: Date? = nil) {
        self.id = id
        self.user = user
        self.slug = slug
        self.name = name
        self.url = url
        self.features = features
        self.status = status
        self.urlsDone = urlsDone
        self.urlsInQueue = urlsInQueue
        self.config = config
        self.dateCreated = dateCreated
        self.dateLaunched = dateLaunched
        self.dateFinished = dateFinished
        self.dateLastModified = dateLastModified
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case user
        case slug
        case name
        case url
        case features
        case status
        case urlsDone = "urls_done"
        case urlsInQueue = "urls_in_queue"
        case config
        case dateCreated = "date_created"
        case dateLaunched = "date_launched"
        case dateFinished = "date_finished"
        case dateLastModified = "date_last_modified"
    }
}

public struct CrawlStatisticsTimePoint: Codable {
    public var count: Int
    public var datetime: Date

    public init(count: Int, datetime: Date) {
        self.count = count
        self.datetime = datetime
    }
}

public struct CrawlStatisticsTime: Codable {
    public var avgDelay: [CrawlStatisticsTimePoint]
    public var httpCode2xx: [CrawlStatisticsTimePoint]
    public var httpCode3xx: [CrawlStatisticsTimePoint]
    public var httpCode4xx: [CrawlStatisticsTimePoint]
    public var httpCode5xx: [CrawlStatisticsTimePoint]
    public var httpCodeXxx: [CrawlStatisticsTimePoint]
    public var frequency: String
    public var lastUpdateDate: Date
    public var avgSize: [CrawlStatisticsTimePoint]
    public var newURLs: [CrawlStatisticsTimePoint]

    public init(avgDelay: [CrawlStatisticsTimePoint], httpCode2xx: [CrawlStatisticsTimePoint], httpCode3xx: [CrawlStatisticsTimePoint], httpCode4xx: [CrawlStatisticsTimePoint], httpCode5xx: [CrawlStatisticsTimePoint], httpCodeXxx: [CrawlStatisticsTimePoint], frequency: String, lastUpdateDate: Date, avgSize: [CrawlStatisticsTimePoint], newURLs: [CrawlStatisticsTimePoint]) {
        self.avgDelay = avgDelay
        self.httpCode2xx = httpCode2xx
        self.httpCode3xx = httpCode3xx
        self.httpCode4xx = httpCode4xx
        self.httpCode5xx = httpCode5xx
        self.httpCodeXxx = httpCodeXxx
        self.frequency = frequency
        self.lastUpdateDate = lastUpdateDate
        self.avgSize = avgSize
        self.newURLs = newURLs
    }

    private enum CodingKeys: String, CodingKey {
        case avgDelay = "avg_delay"
        case httpCode2xx = "http_code_2xx"
        case httpCode3xx = "http_code_3xx"
        case httpCode4xx = "http_code_4xx"
        case httpCode5xx = "http_code_5xx"
        case httpCodeXxx = "http_code_xxx"
        case frequency
        case lastUpdateDate = "last_update_date"
        case avgSize = "avg_size"
        case newURLs = "new_urls"
    }
}

public struct CrawlStatisticsURLs: Codable {
    public var http: Int
    public var url: String
    public var redirectsTo: String?
    public var delayLastByte: Int
    public var isGzip: Bool
    public var length: Int
    public var contentType: String
    public var date: String
    public var delayFirstByte: Int

    public init(http: Int, url: String, redirectsTo: String? = nil, delayLastByte: Int, isGzip: Bool, length: Int, contentType: String, date: String, delayFirstByte: Int) {
        self.http = http
        self.url = url
        self.redirectsTo = redirectsTo
        self.delayLastByte = delayLastByte
        self.isGzip = isGzip
        self.length = length
        self.contentType = contentType
        self.date = date
        self.delayFirstByte = delayFirstByte
    }

    private enum CodingKeys: String, CodingKey {
        case http
        case url
        case redirectsTo = "redirects_to"
        case delayLastByte = "delay_last_byte"
        case isGzip = "gzip"
        case length
        case contentType = "content_type"
        case date
        case delayFirstByte = "delay_first_byte"
    }
}

public struct FieldValuesResult: Codable {
    public var value: String
    public var nbURLs: Int

    public init(value: String, nbURLs: Int) {
        self.value = value
        self.nbURLs = nbURLs
    }

    private enum CodingKeys: String, CodingKey {
        case value
        case nbURLs = "nb_urls"
    }
}

public struct Project: Codable {
    public var name: String
    public var slug: String
    public var user: User
    public var currentSettings: ProjectSettingsSerializer
    public var isActive: Bool?
    public var dateCreated: String?

    public init(name: String, slug: String, user: User, currentSettings: ProjectSettingsSerializer, isActive: Bool? = nil, dateCreated: String? = nil) {
        self.name = name
        self.slug = slug
        self.user = user
        self.currentSettings = currentSettings
        self.isActive = isActive
        self.dateCreated = dateCreated
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case slug
        case user
        case currentSettings = "current_settings"
        case isActive = "active"
        case dateCreated = "date_created"
    }
}

public struct AnalysisDetail: Codable {
    public var id: Int?
    public var user: User
    public var slug: String?
    public var name: String?
    public var url: String?
    public var features: String?
    public var urlsDone: String?
    public var urlsInQueue: String?
    public var config: String?
    public var dateLaunched: Date?
    public var dateFinished: Date?
    /// Date of last modified analysis
    public var dateLastModified: Date?
    public var failures: String?
    public var redButtonDomain: String?

    public init(id: Int? = nil, user: User, slug: String? = nil, name: String? = nil, url: String? = nil, features: String? = nil, urlsDone: String? = nil, urlsInQueue: String? = nil, config: String? = nil, dateLaunched: Date? = nil, dateFinished: Date? = nil, dateLastModified: Date? = nil, failures: String? = nil, redButtonDomain: String? = nil) {
        self.id = id
        self.user = user
        self.slug = slug
        self.name = name
        self.url = url
        self.features = features
        self.urlsDone = urlsDone
        self.urlsInQueue = urlsInQueue
        self.config = config
        self.dateLaunched = dateLaunched
        self.dateFinished = dateFinished
        self.dateLastModified = dateLastModified
        self.failures = failures
        self.redButtonDomain = redButtonDomain
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case user
        case slug
        case name
        case url
        case features
        case urlsDone = "urls_done"
        case urlsInQueue = "urls_in_queue"
        case config
        case dateLaunched = "date_launched"
        case dateFinished = "date_finished"
        case dateLastModified = "date_last_modified"
        case failures
        case redButtonDomain = "red_button_domain"
    }
}

public struct ProjectSavedFilter: Codable {
    public var name: String
    public var filters: [String: AnyJSON]
    public var identifier: String?

    public init(name: String, filters: [String: AnyJSON], identifier: String? = nil) {
        self.name = name
        self.filters = filters
        self.identifier = identifier
    }
}

public struct URLsAggsQuery: Codable {
    public var filters: [String: AnyJSON]?
    public var aggs: [[String: AnyJSON]]?

    public init(filters: [String: AnyJSON]? = nil, aggs: [[String: AnyJSON]]? = nil) {
        self.filters = filters
        self.aggs = aggs
    }
}

public struct URLsAgg: Codable {
    public var count: Int
    public var aggs: [[String: AnyJSON]]?

    public init(count: Int, aggs: [[String: AnyJSON]]? = nil) {
        self.count = count
        self.aggs = aggs
    }
}

public struct URLRewritingRulesSerializer: Codable {
    public var urls: [String]
    public var rules: [RewritingRuleSerializer]

    public init(urls: [String], rules: [RewritingRuleSerializer]) {
        self.urls = urls
        self.rules = rules
    }
}

/// Default payload for object for all HTTP codes that are not covered individually
public struct DefaultPayload: Codable {
    public var error: Error?

    public struct Error: Codable {
        /// Error Message
        public var message: String?
        /// Error Code
        public var errorCode: String?
        /// If available, detailed error
        public var errorDetail: [String: AnyJSON]?

        public init(message: String? = nil, errorCode: String? = nil, errorDetail: [String: AnyJSON]? = nil) {
            self.message = message
            self.errorCode = errorCode
            self.errorDetail = errorDetail
        }

        private enum CodingKeys: String, CodingKey {
            case message
            case errorCode = "error_code"
            case errorDetail = "error_detail"
        }
    }

    public init(error: Error? = nil) {
        self.error = error
    }
}

public struct ProjectSettingsSerializer: Codable {
    public var startURLs: [String]
    public var maxNbPages: Int
    public var maxDepth: Int?
    public var isCompareCrawl: Bool?
    public var blacklistedDomains: [String]
    public var allowedDomains: [String]
    public var isRespectNofollow: Bool?
    public var isCrawlGzip: Bool?
    public var hasRobotsTxt: String?
    public var userAgent: String?
    public var maxPagesPerSec: Int?
    public var extraHeaders: String?
    public var googleSocialAuthID: Int?
    public var googleAnalyticsSiteID: Int?
    /// Keep email in case user delete his social auth connection
    public var googleAnalyticsAccountEmail: String?
    public var googleAnalyticsNbDays: Int?
    public var sitemaps: [String]
    public var headerSettings: [String]

    public init(startURLs: [String], maxNbPages: Int, maxDepth: Int? = nil, isCompareCrawl: Bool? = nil, blacklistedDomains: [String], allowedDomains: [String], isRespectNofollow: Bool? = nil, isCrawlGzip: Bool? = nil, hasRobotsTxt: String? = nil, userAgent: String? = nil, maxPagesPerSec: Int? = nil, extraHeaders: String? = nil, googleSocialAuthID: Int? = nil, googleAnalyticsSiteID: Int? = nil, googleAnalyticsAccountEmail: String? = nil, googleAnalyticsNbDays: Int? = nil, sitemaps: [String], headerSettings: [String]) {
        self.startURLs = startURLs
        self.maxNbPages = maxNbPages
        self.maxDepth = maxDepth
        self.isCompareCrawl = isCompareCrawl
        self.blacklistedDomains = blacklistedDomains
        self.allowedDomains = allowedDomains
        self.isRespectNofollow = isRespectNofollow
        self.isCrawlGzip = isCrawlGzip
        self.hasRobotsTxt = hasRobotsTxt
        self.userAgent = userAgent
        self.maxPagesPerSec = maxPagesPerSec
        self.extraHeaders = extraHeaders
        self.googleSocialAuthID = googleSocialAuthID
        self.googleAnalyticsSiteID = googleAnalyticsSiteID
        self.googleAnalyticsAccountEmail = googleAnalyticsAccountEmail
        self.googleAnalyticsNbDays = googleAnalyticsNbDays
        self.sitemaps = sitemaps
        self.headerSettings = headerSettings
    }

    private enum CodingKeys: String, CodingKey {
        case startURLs = "start_urls"
        case maxNbPages = "max_nb_pages"
        case maxDepth = "max_depth"
        case isCompareCrawl = "compare_crawl"
        case blacklistedDomains = "blacklisted_domains"
        case allowedDomains = "allowed_domains"
        case isRespectNofollow = "respect_nofollow"
        case isCrawlGzip = "crawl_gzip"
        case hasRobotsTxt = "has_robots_txt"
        case userAgent = "user_agent"
        case maxPagesPerSec = "max_pages_per_sec"
        case extraHeaders = "extra_headers"
        case googleSocialAuthID = "google_social_auth_id"
        case googleAnalyticsSiteID = "google_analytics_site_id"
        case googleAnalyticsAccountEmail = "google_analytics_account_email"
        case googleAnalyticsNbDays = "google_analytics_nb_days"
        case sitemaps
        case headerSettings = "header_settings"
    }
}

public struct CrawlDatamodelField: Codable {
    public var isMultiple: Bool
    public var name: String
    public var subtype: String
    public var group: String
    public var type: String
    public var id: String
    public var permissions: [String]

    public init(isMultiple: Bool, name: String, subtype: String, group: String, type: String, id: String, permissions: [String]) {
        self.isMultiple = isMultiple
        self.name = name
        self.subtype = subtype
        self.group = group
        self.type = type
        self.id = id
        self.permissions = permissions
    }

    private enum CodingKeys: String, CodingKey {
        case isMultiple = "multiple"
        case name
        case subtype
        case group
        case type
        case id
        case permissions
    }
}

public struct FieldValues: Codable {
    public var count: Int
    public var results: [FieldValuesResult]

    public init(count: Int, results: [FieldValuesResult]) {
        self.count = count
        self.results = results
    }
}

public struct CrawlDatamodel: Codable {
    public var fields: [CrawlDatamodelField]
    public var groups: [CrawlDatamodelGroup]

    public init(fields: [CrawlDatamodelField], groups: [CrawlDatamodelGroup]) {
        self.fields = fields
        self.groups = groups
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
