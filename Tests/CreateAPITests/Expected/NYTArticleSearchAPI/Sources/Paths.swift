// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get

extension Paths {
    public static var articlesearchJSON: ArticlesearchJSON {
        ArticlesearchJSON(path: "/articlesearch.json")
    }

    public struct ArticlesearchJSON {
        /// Path: `/articlesearch.json`
        public let path: String

        /// Article Search
        ///
        /// Article Search requests use the following URI structure:
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var response: Response?

            public struct Response: Decodable {
                public var docs: [NYTArticleSearchAPI.Doc]?
                public var meta: Meta?

                public struct Meta: Decodable {
                    public var hits: Int?
                    public var offset: Int?
                    public var time: Int?

                    public init(hits: Int? = nil, offset: Int? = nil, time: Int? = nil) {
                        self.hits = hits
                        self.offset = offset
                        self.time = time
                    }
                }

                public init(docs: [NYTArticleSearchAPI.Doc]? = nil, meta: Meta? = nil) {
                    self.docs = docs
                    self.meta = meta
                }
            }

            public init(response: Response? = nil) {
                self.response = response
            }
        }

        public struct GetParameters {
            public var q: String?
            public var fq: String?
            public var beginDate: String?
            public var endDate: String?
            public var sort: Sort?
            public var fl: String?
            public var isHl: Bool?
            public var page: Int?
            public var facetField: String?
            public var isFacetFilter: Bool?

            public enum Sort: String, Codable, CaseIterable {
                case newest
                case oldest
            }

            public init(q: String? = nil, fq: String? = nil, beginDate: String? = nil, endDate: String? = nil, sort: Sort? = nil, fl: String? = nil, isHl: Bool? = nil, page: Int? = nil, facetField: String? = nil, isFacetFilter: Bool? = nil) {
                self.q = q
                self.fq = fq
                self.beginDate = beginDate
                self.endDate = endDate
                self.sort = sort
                self.fl = fl
                self.isHl = isHl
                self.page = page
                self.facetField = facetField
                self.isFacetFilter = isFacetFilter
            }

            public var asQuery: [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("q", q)
                query.addQueryItem("fq", fq)
                query.addQueryItem("begin_date", beginDate)
                query.addQueryItem("end_date", endDate)
                query.addQueryItem("sort", sort)
                query.addQueryItem("fl", fl)
                query.addQueryItem("hl", isHl)
                query.addQueryItem("page", page)
                query.addQueryItem("facet_field", facetField)
                query.addQueryItem("facet_filter", isFacetFilter)
                return query
            }
        }
    }
}

public enum Paths {}

protocol QueryEncodable {
    var asQueryValue: String { get }
}

extension Bool: QueryEncodable {
    var asQueryValue: String {
        self ? "true" : "false"
    }
}

extension Date: QueryEncodable {
    var asQueryValue: String {
        ISO8601DateFormatter().string(from: self)
    }
}

extension Double: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int32: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension Int64: QueryEncodable {
    var asQueryValue: String {
        String(self)
    }
}

extension String: QueryEncodable {
    var asQueryValue: String {
        self
    }
}

extension URL: QueryEncodable {
    var asQueryValue: String {
        absoluteString
    }
}

extension RawRepresentable where RawValue == String {
    var asQueryValue: String {
        rawValue
    }
}

extension Array where Element == (String, String?) {
    mutating func addQueryItem<T: RawRepresentable>(_ name: String, _ value: T?) where T.RawValue == String {
        addQueryItem(name, value?.rawValue)
    }
    
    mutating func addQueryItem(_ name: String, _ value: QueryEncodable?) {
        guard let value = value?.asQueryValue, !value.isEmpty else { return }
        append((name, value))
    }
    
    mutating func addDeepObject(_ name: String, _ query: [(String, String?)]) {
        for (key, value) in query {
            addQueryItem("\(name)[\(key)]", value)
        }
    }

    var asPercentEncodedQuery: String {
        var components = URLComponents()
        components.queryItems = self.map(URLQueryItem.init)
        return components.percentEncodedQuery ?? ""
    }
    
    // [("role", "admin"), ("name": "kean)] -> "role,admin,name,kean"
    var asCompactQuery: String {
        flatMap { [$0, $1] }.compactMap { $0 }.joined(separator: ",")
    }
}
