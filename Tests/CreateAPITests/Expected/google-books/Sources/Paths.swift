// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import APIClient

extension Paths {
    public static var books: Books {
        Books(path: "/books")
    }

    public struct Books {
        /// Path: `/books`
        public let path: String
    }
}

extension Paths.Books {
    public var v1: V1 {
        V1(path: path + "/v1")
    }

    public struct V1 {
        /// Path: `/books/v1`
        public let path: String
    }
}

extension Paths.Books.V1 {
    public var cloudloading: Cloudloading {
        Cloudloading(path: path + "/cloudloading")
    }

    public struct Cloudloading {
        /// Path: `/books/v1/cloudloading`
        public let path: String
    }
}

extension Paths.Books.V1.Cloudloading {
    public var addBook: AddBook {
        AddBook(path: path + "/addBook")
    }

    public struct AddBook {
        /// Path: `/books/v1/cloudloading/addBook`
        public let path: String

        /// Add a user-upload volume and triggers processing.
        public func post(parameters: PostParameters? = nil) -> Request<google_books.BooksCloudloadingResource> {
            .post(path, query: parameters?.asQuery())
        }

        public struct PostParameters {
            public var driveDocumentID: String?
            public var mimeType: String?
            public var name: String?
            public var uploadClientToken: String?

            public init(driveDocumentID: String? = nil, mimeType: String? = nil, name: String? = nil, uploadClientToken: String? = nil) {
                self.driveDocumentID = driveDocumentID
                self.mimeType = mimeType
                self.name = name
                self.uploadClientToken = uploadClientToken
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("drive_document_id", driveDocumentID?.asQueryValue)
                query.addQueryItem("mime_type", mimeType?.asQueryValue)
                query.addQueryItem("name", name?.asQueryValue)
                query.addQueryItem("upload_client_token", uploadClientToken?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1.Cloudloading {
    public var deleteBook: DeleteBook {
        DeleteBook(path: path + "/deleteBook")
    }

    public struct DeleteBook {
        /// Path: `/books/v1/cloudloading/deleteBook`
        public let path: String

        /// Remove the book and its contents
        public func post(volumeID: String) -> Request<google_books.Empty> {
            .post(path, query: makePostQuery(volumeID))
        }

        private func makePostQuery(_ volumeID: String) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("volumeId", volumeID.asQueryValue)
            return query
        }
    }
}

extension Paths.Books.V1.Cloudloading {
    public var updateBook: UpdateBook {
        UpdateBook(path: path + "/updateBook")
    }

    public struct UpdateBook {
        /// Path: `/books/v1/cloudloading/updateBook`
        public let path: String

        /// Updates a user-upload volume.
        public func post(_ body: google_books.BooksCloudloadingResource? = nil) -> Request<google_books.BooksCloudloadingResource> {
            .post(path, body: body)
        }
    }
}

extension Paths.Books.V1 {
    public var dictionary: Dictionary {
        Dictionary(path: path + "/dictionary")
    }

    public struct Dictionary {
        /// Path: `/books/v1/dictionary`
        public let path: String
    }
}

extension Paths.Books.V1.Dictionary {
    public var listOfflineMetadata: ListOfflineMetadata {
        ListOfflineMetadata(path: path + "/listOfflineMetadata")
    }

    public struct ListOfflineMetadata {
        /// Path: `/books/v1/dictionary/listOfflineMetadata`
        public let path: String

        /// Returns a list of offline dictionary metadata available
        public func get(cpksver: String) -> Request<google_books.Metadata> {
            .get(path, query: makeGetQuery(cpksver))
        }

        private func makeGetQuery(_ cpksver: String) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("cpksver", cpksver.asQueryValue)
            return query
        }
    }
}

extension Paths.Books.V1 {
    public var familysharing: Familysharing {
        Familysharing(path: path + "/familysharing")
    }

    public struct Familysharing {
        /// Path: `/books/v1/familysharing`
        public let path: String
    }
}

extension Paths.Books.V1.Familysharing {
    public var getFamilyInfo: GetFamilyInfo {
        GetFamilyInfo(path: path + "/getFamilyInfo")
    }

    public struct GetFamilyInfo {
        /// Path: `/books/v1/familysharing/getFamilyInfo`
        public let path: String

        /// Gets information regarding the family that the user is part of.
        public func get(source: String? = nil) -> Request<google_books.FamilyInfo> {
            .get(path, query: makeGetQuery(source))
        }

        private func makeGetQuery(_ source: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("source", source?.asQueryValue)
            return query
        }
    }
}

extension Paths.Books.V1.Familysharing {
    public var share: Share {
        Share(path: path + "/share")
    }

    public struct Share {
        /// Path: `/books/v1/familysharing/share`
        public let path: String

        /// Initiates sharing of the content with the user's family. Empty response indicates success.
        public func post(parameters: PostParameters? = nil) -> Request<google_books.Empty> {
            .post(path, query: parameters?.asQuery())
        }

        public struct PostParameters {
            public var docID: String?
            public var source: String?
            public var volumeID: String?

            public init(docID: String? = nil, source: String? = nil, volumeID: String? = nil) {
                self.docID = docID
                self.source = source
                self.volumeID = volumeID
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("docId", docID?.asQueryValue)
                query.addQueryItem("source", source?.asQueryValue)
                query.addQueryItem("volumeId", volumeID?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1.Familysharing {
    public var unshare: Unshare {
        Unshare(path: path + "/unshare")
    }

    public struct Unshare {
        /// Path: `/books/v1/familysharing/unshare`
        public let path: String

        /// Initiates revoking content that has already been shared with the user's family. Empty response indicates success.
        public func post(parameters: PostParameters? = nil) -> Request<google_books.Empty> {
            .post(path, query: parameters?.asQuery())
        }

        public struct PostParameters {
            public var docID: String?
            public var source: String?
            public var volumeID: String?

            public init(docID: String? = nil, source: String? = nil, volumeID: String? = nil) {
                self.docID = docID
                self.source = source
                self.volumeID = volumeID
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("docId", docID?.asQueryValue)
                query.addQueryItem("source", source?.asQueryValue)
                query.addQueryItem("volumeId", volumeID?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1 {
    public var myconfig: Myconfig {
        Myconfig(path: path + "/myconfig")
    }

    public struct Myconfig {
        /// Path: `/books/v1/myconfig`
        public let path: String
    }
}

extension Paths.Books.V1.Myconfig {
    public var getUserSettings: GetUserSettings {
        GetUserSettings(path: path + "/getUserSettings")
    }

    public struct GetUserSettings {
        /// Path: `/books/v1/myconfig/getUserSettings`
        public let path: String

        /// Gets the current settings for the user.
        public func get(country: String? = nil) -> Request<google_books.Usersettings> {
            .get(path, query: makeGetQuery(country))
        }

        private func makeGetQuery(_ country: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("country", country?.asQueryValue)
            return query
        }
    }
}

extension Paths.Books.V1.Myconfig {
    public var releaseDownloadAccess: ReleaseDownloadAccess {
        ReleaseDownloadAccess(path: path + "/releaseDownloadAccess")
    }

    public struct ReleaseDownloadAccess {
        /// Path: `/books/v1/myconfig/releaseDownloadAccess`
        public let path: String

        /// Release downloaded content access restriction.
        public func post(parameters: PostParameters) -> Request<google_books.DownloadAccesses> {
            .post(path, query: parameters.asQuery())
        }

        public struct PostParameters {
            public var cpksver: String
            public var volumeIDs: [String]
            public var locale: String?
            public var source: String?

            public init(cpksver: String, volumeIDs: [String], locale: String? = nil, source: String? = nil) {
                self.cpksver = cpksver
                self.volumeIDs = volumeIDs
                self.locale = locale
                self.source = source
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("cpksver", cpksver.asQueryValue)
                for value in volumeIDs {
                    query.addQueryItem("volumeIds", value.asQueryValue)
                }
                query.addQueryItem("locale", locale?.asQueryValue)
                query.addQueryItem("source", source?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1.Myconfig {
    public var requestAccess: RequestAccess {
        RequestAccess(path: path + "/requestAccess")
    }

    public struct RequestAccess {
        /// Path: `/books/v1/myconfig/requestAccess`
        public let path: String

        /// Request concurrent and download access restrictions.
        public func post(parameters: PostParameters) -> Request<google_books.RequestAccessData> {
            .post(path, query: parameters.asQuery())
        }

        public struct PostParameters {
            public var cpksver: String
            public var nonce: String
            public var source: String
            public var volumeID: String
            public var licenseTypes: LicenseTypes?
            public var locale: String?

            public enum LicenseTypes: String, Codable, CaseIterable {
                case licenseTypesUndefined = "LICENSE_TYPES_UNDEFINED"
                case both = "BOTH"
                case concurrent = "CONCURRENT"
                case download = "DOWNLOAD"
            }

            public init(cpksver: String, nonce: String, source: String, volumeID: String, licenseTypes: LicenseTypes? = nil, locale: String? = nil) {
                self.cpksver = cpksver
                self.nonce = nonce
                self.source = source
                self.volumeID = volumeID
                self.licenseTypes = licenseTypes
                self.locale = locale
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("cpksver", cpksver.asQueryValue)
                query.addQueryItem("nonce", nonce.asQueryValue)
                query.addQueryItem("source", source.asQueryValue)
                query.addQueryItem("volumeId", volumeID.asQueryValue)
                query.addQueryItem("licenseTypes", licenseTypes?.asQueryValue)
                query.addQueryItem("locale", locale?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1.Myconfig {
    public var syncVolumeLicenses: SyncVolumeLicenses {
        SyncVolumeLicenses(path: path + "/syncVolumeLicenses")
    }

    public struct SyncVolumeLicenses {
        /// Path: `/books/v1/myconfig/syncVolumeLicenses`
        public let path: String

        /// Request downloaded content access for specified volumes on the My eBooks shelf.
        public func post(parameters: PostParameters) -> Request<google_books.Volumes> {
            .post(path, query: parameters.asQuery())
        }

        public struct PostParameters {
            public var cpksver: String
            public var nonce: String
            public var source: String
            public var features: [Features]?
            public var isIncludeNonComicsSeries: Bool?
            public var locale: String?
            public var isShowPreorders: Bool?
            public var volumeIDs: [String]?

            public enum Features: String, Codable, CaseIterable {
                case featuresUndefined = "FEATURES_UNDEFINED"
                case rentals = "RENTALS"
            }

            public init(cpksver: String, nonce: String, source: String, features: [Features]? = nil, isIncludeNonComicsSeries: Bool? = nil, locale: String? = nil, isShowPreorders: Bool? = nil, volumeIDs: [String]? = nil) {
                self.cpksver = cpksver
                self.nonce = nonce
                self.source = source
                self.features = features
                self.isIncludeNonComicsSeries = isIncludeNonComicsSeries
                self.locale = locale
                self.isShowPreorders = isShowPreorders
                self.volumeIDs = volumeIDs
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("cpksver", cpksver.asQueryValue)
                query.addQueryItem("nonce", nonce.asQueryValue)
                query.addQueryItem("source", source.asQueryValue)
                for value in features ?? [] {
                    query.addQueryItem("features", value.asQueryValue)
                }
                query.addQueryItem("includeNonComicsSeries", isIncludeNonComicsSeries?.asQueryValue)
                query.addQueryItem("locale", locale?.asQueryValue)
                query.addQueryItem("showPreorders", isShowPreorders?.asQueryValue)
                for value in volumeIDs ?? [] {
                    query.addQueryItem("volumeIds", value.asQueryValue)
                }
                return query
            }
        }
    }
}

extension Paths.Books.V1.Myconfig {
    public var updateUserSettings: UpdateUserSettings {
        UpdateUserSettings(path: path + "/updateUserSettings")
    }

    public struct UpdateUserSettings {
        /// Path: `/books/v1/myconfig/updateUserSettings`
        public let path: String

        /// Sets the settings for the user. If a sub-object is specified, it will overwrite the existing sub-object stored in the server. Unspecified sub-objects will retain the existing value.
        public func post(_ body: google_books.Usersettings? = nil) -> Request<google_books.Usersettings> {
            .post(path, body: body)
        }
    }
}

extension Paths.Books.V1 {
    public var mylibrary: Mylibrary {
        Mylibrary(path: path + "/mylibrary")
    }

    public struct Mylibrary {
        /// Path: `/books/v1/mylibrary`
        public let path: String
    }
}

extension Paths.Books.V1.Mylibrary {
    public var annotations: Annotations {
        Annotations(path: path + "/annotations")
    }

    public struct Annotations {
        /// Path: `/books/v1/mylibrary/annotations`
        public let path: String

        /// Retrieves a list of annotations, possibly filtered.
        public func get(parameters: GetParameters? = nil) -> Request<google_books.Annotations> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var contentVersion: String?
            public var layerID: String?
            public var layerIDs: [String]?
            public var maxResults: Int?
            public var pageToken: String?
            public var isShowDeleted: Bool?
            public var source: String?
            public var updatedMax: String?
            public var updatedMin: String?
            public var volumeID: String?

            public init(contentVersion: String? = nil, layerID: String? = nil, layerIDs: [String]? = nil, maxResults: Int? = nil, pageToken: String? = nil, isShowDeleted: Bool? = nil, source: String? = nil, updatedMax: String? = nil, updatedMin: String? = nil, volumeID: String? = nil) {
                self.contentVersion = contentVersion
                self.layerID = layerID
                self.layerIDs = layerIDs
                self.maxResults = maxResults
                self.pageToken = pageToken
                self.isShowDeleted = isShowDeleted
                self.source = source
                self.updatedMax = updatedMax
                self.updatedMin = updatedMin
                self.volumeID = volumeID
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("contentVersion", contentVersion?.asQueryValue)
                query.addQueryItem("layerId", layerID?.asQueryValue)
                for value in layerIDs ?? [] {
                    query.addQueryItem("layerIds", value.asQueryValue)
                }
                query.addQueryItem("maxResults", maxResults?.asQueryValue)
                query.addQueryItem("pageToken", pageToken?.asQueryValue)
                query.addQueryItem("showDeleted", isShowDeleted?.asQueryValue)
                query.addQueryItem("source", source?.asQueryValue)
                query.addQueryItem("updatedMax", updatedMax?.asQueryValue)
                query.addQueryItem("updatedMin", updatedMin?.asQueryValue)
                query.addQueryItem("volumeId", volumeID?.asQueryValue)
                return query
            }
        }

        /// Inserts a new annotation.
        public func post(parameters: PostParameters? = nil, _ body: google_books.Annotation? = nil) -> Request<google_books.Annotation> {
            .post(path, query: parameters?.asQuery(), body: body)
        }

        public struct PostParameters {
            public var annotationID: String?
            public var country: String?
            public var isShowOnlySummaryInResponse: Bool?
            public var source: String?

            public init(annotationID: String? = nil, country: String? = nil, isShowOnlySummaryInResponse: Bool? = nil, source: String? = nil) {
                self.annotationID = annotationID
                self.country = country
                self.isShowOnlySummaryInResponse = isShowOnlySummaryInResponse
                self.source = source
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("annotationId", annotationID?.asQueryValue)
                query.addQueryItem("country", country?.asQueryValue)
                query.addQueryItem("showOnlySummaryInResponse", isShowOnlySummaryInResponse?.asQueryValue)
                query.addQueryItem("source", source?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1.Mylibrary.Annotations {
    public var summary: Summary {
        Summary(path: path + "/summary")
    }

    public struct Summary {
        /// Path: `/books/v1/mylibrary/annotations/summary`
        public let path: String

        /// Gets the summary of specified layers.
        public func post(layerIDs: [String], volumeID: String) -> Request<google_books.AnnotationsSummary> {
            .post(path, query: makePostQuery(layerIDs, volumeID))
        }

        private func makePostQuery(_ layerIDs: [String], _ volumeID: String) -> [(String, String?)] {
            var query: [(String, String?)] = []
            for value in layerIDs {
                query.addQueryItem("layerIds", value.asQueryValue)
            }
            query.addQueryItem("volumeId", volumeID.asQueryValue)
            return query
        }
    }
}

extension Paths.Books.V1.Mylibrary.Annotations {
    public func annotationID(_ annotationID: String) -> WithAnnotationID {
        WithAnnotationID(path: "\(path)/\(annotationID)")
    }

    public struct WithAnnotationID {
        /// Path: `/books/v1/mylibrary/annotations/{annotationId}`
        public let path: String

        /// Updates an existing annotation.
        public func put(source: String? = nil, _ body: google_books.Annotation? = nil) -> Request<google_books.Annotation> {
            .put(path, query: makePutQuery(source), body: body)
        }

        private func makePutQuery(_ source: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("source", source?.asQueryValue)
            return query
        }

        /// Deletes an annotation.
        public func delete(source: String? = nil) -> Request<google_books.Empty> {
            .delete(path, query: makeDeleteQuery(source))
        }

        private func makeDeleteQuery(_ source: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("source", source?.asQueryValue)
            return query
        }
    }
}

extension Paths.Books.V1.Mylibrary {
    public var bookshelves: Bookshelves {
        Bookshelves(path: path + "/bookshelves")
    }

    public struct Bookshelves {
        /// Path: `/books/v1/mylibrary/bookshelves`
        public let path: String

        /// Retrieves a list of bookshelves belonging to the authenticated user.
        public func get(source: String? = nil) -> Request<google_books.Bookshelves> {
            .get(path, query: makeGetQuery(source))
        }

        private func makeGetQuery(_ source: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("source", source?.asQueryValue)
            return query
        }
    }
}

extension Paths.Books.V1.Mylibrary.Bookshelves {
    public func shelf(_ shelf: String) -> WithShelf {
        WithShelf(path: "\(path)/\(shelf)")
    }

    public struct WithShelf {
        /// Path: `/books/v1/mylibrary/bookshelves/{shelf}`
        public let path: String

        /// Retrieves metadata for a specific bookshelf belonging to the authenticated user.
        public func get(source: String? = nil) -> Request<google_books.Bookshelf> {
            .get(path, query: makeGetQuery(source))
        }

        private func makeGetQuery(_ source: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("source", source?.asQueryValue)
            return query
        }
    }
}

extension Paths.Books.V1.Mylibrary.Bookshelves.WithShelf {
    public var addVolume: AddVolume {
        AddVolume(path: path + "/addVolume")
    }

    public struct AddVolume {
        /// Path: `/books/v1/mylibrary/bookshelves/{shelf}/addVolume`
        public let path: String

        /// Adds a volume to a bookshelf.
        public func post(parameters: PostParameters) -> Request<google_books.Empty> {
            .post(path, query: parameters.asQuery())
        }

        public struct PostParameters {
            public var volumeID: String
            public var reason: Reason?
            public var source: String?

            public enum Reason: String, Codable, CaseIterable {
                case reasonUndefined = "REASON_UNDEFINED"
                case iosPrex = "IOS_PREX"
                case iosSearch = "IOS_SEARCH"
                case onboarding = "ONBOARDING"
            }

            public init(volumeID: String, reason: Reason? = nil, source: String? = nil) {
                self.volumeID = volumeID
                self.reason = reason
                self.source = source
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("volumeId", volumeID.asQueryValue)
                query.addQueryItem("reason", reason?.asQueryValue)
                query.addQueryItem("source", source?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1.Mylibrary.Bookshelves.WithShelf {
    public var clearVolumes: ClearVolumes {
        ClearVolumes(path: path + "/clearVolumes")
    }

    public struct ClearVolumes {
        /// Path: `/books/v1/mylibrary/bookshelves/{shelf}/clearVolumes`
        public let path: String

        /// Clears all volumes from a bookshelf.
        public func post(source: String? = nil) -> Request<google_books.Empty> {
            .post(path, query: makePostQuery(source))
        }

        private func makePostQuery(_ source: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("source", source?.asQueryValue)
            return query
        }
    }
}

extension Paths.Books.V1.Mylibrary.Bookshelves.WithShelf {
    public var moveVolume: MoveVolume {
        MoveVolume(path: path + "/moveVolume")
    }

    public struct MoveVolume {
        /// Path: `/books/v1/mylibrary/bookshelves/{shelf}/moveVolume`
        public let path: String

        /// Moves a volume within a bookshelf.
        public func post(parameters: PostParameters) -> Request<google_books.Empty> {
            .post(path, query: parameters.asQuery())
        }

        public struct PostParameters {
            public var volumeID: String
            public var volumePosition: Int
            public var source: String?

            public init(volumeID: String, volumePosition: Int, source: String? = nil) {
                self.volumeID = volumeID
                self.volumePosition = volumePosition
                self.source = source
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("volumeId", volumeID.asQueryValue)
                query.addQueryItem("volumePosition", volumePosition.asQueryValue)
                query.addQueryItem("source", source?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1.Mylibrary.Bookshelves.WithShelf {
    public var removeVolume: RemoveVolume {
        RemoveVolume(path: path + "/removeVolume")
    }

    public struct RemoveVolume {
        /// Path: `/books/v1/mylibrary/bookshelves/{shelf}/removeVolume`
        public let path: String

        /// Removes a volume from a bookshelf.
        public func post(parameters: PostParameters) -> Request<google_books.Empty> {
            .post(path, query: parameters.asQuery())
        }

        public struct PostParameters {
            public var volumeID: String
            public var reason: Reason?
            public var source: String?

            public enum Reason: String, Codable, CaseIterable {
                case reasonUndefined = "REASON_UNDEFINED"
                case onboarding = "ONBOARDING"
            }

            public init(volumeID: String, reason: Reason? = nil, source: String? = nil) {
                self.volumeID = volumeID
                self.reason = reason
                self.source = source
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("volumeId", volumeID.asQueryValue)
                query.addQueryItem("reason", reason?.asQueryValue)
                query.addQueryItem("source", source?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1.Mylibrary.Bookshelves.WithShelf {
    public var volumes: Volumes {
        Volumes(path: path + "/volumes")
    }

    public struct Volumes {
        /// Path: `/books/v1/mylibrary/bookshelves/{shelf}/volumes`
        public let path: String

        /// Gets volume information for volumes on a bookshelf.
        public func get(parameters: GetParameters? = nil) -> Request<google_books.Volumes> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var country: String?
            public var maxResults: Int?
            public var projection: Projection?
            public var q: String?
            public var isShowPreorders: Bool?
            public var source: String?
            public var startIndex: Int?

            public enum Projection: String, Codable, CaseIterable {
                case projectionUndefined = "PROJECTION_UNDEFINED"
                case full = "FULL"
                case lite = "LITE"
            }

            public init(country: String? = nil, maxResults: Int? = nil, projection: Projection? = nil, q: String? = nil, isShowPreorders: Bool? = nil, source: String? = nil, startIndex: Int? = nil) {
                self.country = country
                self.maxResults = maxResults
                self.projection = projection
                self.q = q
                self.isShowPreorders = isShowPreorders
                self.source = source
                self.startIndex = startIndex
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("country", country?.asQueryValue)
                query.addQueryItem("maxResults", maxResults?.asQueryValue)
                query.addQueryItem("projection", projection?.asQueryValue)
                query.addQueryItem("q", q?.asQueryValue)
                query.addQueryItem("showPreorders", isShowPreorders?.asQueryValue)
                query.addQueryItem("source", source?.asQueryValue)
                query.addQueryItem("startIndex", startIndex?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1.Mylibrary {
    public var readingpositions: Readingpositions {
        Readingpositions(path: path + "/readingpositions")
    }

    public struct Readingpositions {
        /// Path: `/books/v1/mylibrary/readingpositions`
        public let path: String
    }
}

extension Paths.Books.V1.Mylibrary.Readingpositions {
    public func volumeID(_ volumeID: String) -> WithVolumeID {
        WithVolumeID(path: "\(path)/\(volumeID)")
    }

    public struct WithVolumeID {
        /// Path: `/books/v1/mylibrary/readingpositions/{volumeId}`
        public let path: String

        /// Retrieves my reading position information for a volume.
        public func get(contentVersion: String? = nil, source: String? = nil) -> Request<google_books.ReadingPosition> {
            .get(path, query: makeGetQuery(contentVersion, source))
        }

        private func makeGetQuery(_ contentVersion: String?, _ source: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("contentVersion", contentVersion?.asQueryValue)
            query.addQueryItem("source", source?.asQueryValue)
            return query
        }
    }
}

extension Paths.Books.V1.Mylibrary.Readingpositions.WithVolumeID {
    public var setPosition: SetPosition {
        SetPosition(path: path + "/setPosition")
    }

    public struct SetPosition {
        /// Path: `/books/v1/mylibrary/readingpositions/{volumeId}/setPosition`
        public let path: String

        /// Sets my reading position information for a volume.
        public func post(parameters: PostParameters) -> Request<google_books.Empty> {
            .post(path, query: parameters.asQuery())
        }

        public struct PostParameters {
            public var position: String
            public var timestamp: String
            public var action: Action?
            public var contentVersion: String?
            public var deviceCookie: String?
            public var source: String?

            public enum Action: String, Codable, CaseIterable {
                case actionUndefined = "ACTION_UNDEFINED"
                case bookmark
                case chapter
                case nextPage = "next-page"
                case prevPage = "prev-page"
                case scroll
                case search
            }

            public init(position: String, timestamp: String, action: Action? = nil, contentVersion: String? = nil, deviceCookie: String? = nil, source: String? = nil) {
                self.position = position
                self.timestamp = timestamp
                self.action = action
                self.contentVersion = contentVersion
                self.deviceCookie = deviceCookie
                self.source = source
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("position", position.asQueryValue)
                query.addQueryItem("timestamp", timestamp.asQueryValue)
                query.addQueryItem("action", action?.asQueryValue)
                query.addQueryItem("contentVersion", contentVersion?.asQueryValue)
                query.addQueryItem("deviceCookie", deviceCookie?.asQueryValue)
                query.addQueryItem("source", source?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1 {
    public var notification: Notification {
        Notification(path: path + "/notification")
    }

    public struct Notification {
        /// Path: `/books/v1/notification`
        public let path: String
    }
}

extension Paths.Books.V1.Notification {
    public var get: Get {
        Get(path: path + "/get")
    }

    public struct Get {
        /// Path: `/books/v1/notification/get`
        public let path: String

        /// Returns notification details for a given notification id.
        public func get(parameters: GetParameters) -> Request<google_books.Notification> {
            .get(path, query: parameters.asQuery())
        }

        public struct GetParameters {
            public var notificationID: String
            public var locale: String?
            public var source: String?

            public init(notificationID: String, locale: String? = nil, source: String? = nil) {
                self.notificationID = notificationID
                self.locale = locale
                self.source = source
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("notification_id", notificationID.asQueryValue)
                query.addQueryItem("locale", locale?.asQueryValue)
                query.addQueryItem("source", source?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1 {
    public var onboarding: Onboarding {
        Onboarding(path: path + "/onboarding")
    }

    public struct Onboarding {
        /// Path: `/books/v1/onboarding`
        public let path: String
    }
}

extension Paths.Books.V1.Onboarding {
    public var listCategories: ListCategories {
        ListCategories(path: path + "/listCategories")
    }

    public struct ListCategories {
        /// Path: `/books/v1/onboarding/listCategories`
        public let path: String

        /// List categories for onboarding experience.
        public func get(locale: String? = nil) -> Request<google_books.Category> {
            .get(path, query: makeGetQuery(locale))
        }

        private func makeGetQuery(_ locale: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("locale", locale?.asQueryValue)
            return query
        }
    }
}

extension Paths.Books.V1.Onboarding {
    public var listCategoryVolumes: ListCategoryVolumes {
        ListCategoryVolumes(path: path + "/listCategoryVolumes")
    }

    public struct ListCategoryVolumes {
        /// Path: `/books/v1/onboarding/listCategoryVolumes`
        public let path: String

        /// List available volumes under categories for onboarding experience.
        public func get(parameters: GetParameters? = nil) -> Request<google_books.Volume2> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var categoryID: [String]?
            public var locale: String?
            public var maxAllowedMaturityRating: MaxAllowedMaturityRating?
            public var pageSize: Int?
            public var pageToken: String?

            public enum MaxAllowedMaturityRating: String, Codable, CaseIterable {
                case maxAllowedMaturityRatingUndefined = "MAX_ALLOWED_MATURITY_RATING_UNDEFINED"
                case mature = "MATURE"
                case notMature = "not-mature"
            }

            public init(categoryID: [String]? = nil, locale: String? = nil, maxAllowedMaturityRating: MaxAllowedMaturityRating? = nil, pageSize: Int? = nil, pageToken: String? = nil) {
                self.categoryID = categoryID
                self.locale = locale
                self.maxAllowedMaturityRating = maxAllowedMaturityRating
                self.pageSize = pageSize
                self.pageToken = pageToken
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                for value in categoryID ?? [] {
                    query.addQueryItem("categoryId", value.asQueryValue)
                }
                query.addQueryItem("locale", locale?.asQueryValue)
                query.addQueryItem("maxAllowedMaturityRating", maxAllowedMaturityRating?.asQueryValue)
                query.addQueryItem("pageSize", pageSize?.asQueryValue)
                query.addQueryItem("pageToken", pageToken?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1 {
    public var personalizedstream: Personalizedstream {
        Personalizedstream(path: path + "/personalizedstream")
    }

    public struct Personalizedstream {
        /// Path: `/books/v1/personalizedstream`
        public let path: String
    }
}

extension Paths.Books.V1.Personalizedstream {
    public var get: Get {
        Get(path: path + "/get")
    }

    public struct Get {
        /// Path: `/books/v1/personalizedstream/get`
        public let path: String

        /// Returns a stream of personalized book clusters
        public func get(parameters: GetParameters? = nil) -> Request<google_books.Discoveryclusters> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var locale: String?
            public var maxAllowedMaturityRating: MaxAllowedMaturityRating?
            public var source: String?

            public enum MaxAllowedMaturityRating: String, Codable, CaseIterable {
                case maxAllowedMaturityRatingUndefined = "MAX_ALLOWED_MATURITY_RATING_UNDEFINED"
                case mature = "MATURE"
                case notMature = "not-mature"
            }

            public init(locale: String? = nil, maxAllowedMaturityRating: MaxAllowedMaturityRating? = nil, source: String? = nil) {
                self.locale = locale
                self.maxAllowedMaturityRating = maxAllowedMaturityRating
                self.source = source
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("locale", locale?.asQueryValue)
                query.addQueryItem("maxAllowedMaturityRating", maxAllowedMaturityRating?.asQueryValue)
                query.addQueryItem("source", source?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1 {
    public var promooffer: Promooffer {
        Promooffer(path: path + "/promooffer")
    }

    public struct Promooffer {
        /// Path: `/books/v1/promooffer`
        public let path: String
    }
}

extension Paths.Books.V1.Promooffer {
    public var accept: Accept {
        Accept(path: path + "/accept")
    }

    public struct Accept {
        /// Path: `/books/v1/promooffer/accept`
        public let path: String

        /// Accepts the promo offer.
        public func post(parameters: PostParameters? = nil) -> Request<google_books.Empty> {
            .post(path, query: parameters?.asQuery())
        }

        public struct PostParameters {
            public var androidID: String?
            public var device: String?
            public var manufacturer: String?
            public var model: String?
            public var offerID: String?
            public var product: String?
            public var serial: String?
            public var volumeID: String?

            public init(androidID: String? = nil, device: String? = nil, manufacturer: String? = nil, model: String? = nil, offerID: String? = nil, product: String? = nil, serial: String? = nil, volumeID: String? = nil) {
                self.androidID = androidID
                self.device = device
                self.manufacturer = manufacturer
                self.model = model
                self.offerID = offerID
                self.product = product
                self.serial = serial
                self.volumeID = volumeID
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("androidId", androidID?.asQueryValue)
                query.addQueryItem("device", device?.asQueryValue)
                query.addQueryItem("manufacturer", manufacturer?.asQueryValue)
                query.addQueryItem("model", model?.asQueryValue)
                query.addQueryItem("offerId", offerID?.asQueryValue)
                query.addQueryItem("product", product?.asQueryValue)
                query.addQueryItem("serial", serial?.asQueryValue)
                query.addQueryItem("volumeId", volumeID?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1.Promooffer {
    public var dismiss: Dismiss {
        Dismiss(path: path + "/dismiss")
    }

    public struct Dismiss {
        /// Path: `/books/v1/promooffer/dismiss`
        public let path: String

        /// Marks the promo offer as dismissed.
        public func post(parameters: PostParameters? = nil) -> Request<google_books.Empty> {
            .post(path, query: parameters?.asQuery())
        }

        public struct PostParameters {
            public var androidID: String?
            public var device: String?
            public var manufacturer: String?
            public var model: String?
            public var offerID: String?
            public var product: String?
            public var serial: String?

            public init(androidID: String? = nil, device: String? = nil, manufacturer: String? = nil, model: String? = nil, offerID: String? = nil, product: String? = nil, serial: String? = nil) {
                self.androidID = androidID
                self.device = device
                self.manufacturer = manufacturer
                self.model = model
                self.offerID = offerID
                self.product = product
                self.serial = serial
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("androidId", androidID?.asQueryValue)
                query.addQueryItem("device", device?.asQueryValue)
                query.addQueryItem("manufacturer", manufacturer?.asQueryValue)
                query.addQueryItem("model", model?.asQueryValue)
                query.addQueryItem("offerId", offerID?.asQueryValue)
                query.addQueryItem("product", product?.asQueryValue)
                query.addQueryItem("serial", serial?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1.Promooffer {
    public var get: Get {
        Get(path: path + "/get")
    }

    public struct Get {
        /// Path: `/books/v1/promooffer/get`
        public let path: String

        /// Returns a list of promo offers available to the user
        public func get(parameters: GetParameters? = nil) -> Request<google_books.Offers> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var androidID: String?
            public var device: String?
            public var manufacturer: String?
            public var model: String?
            public var product: String?
            public var serial: String?

            public init(androidID: String? = nil, device: String? = nil, manufacturer: String? = nil, model: String? = nil, product: String? = nil, serial: String? = nil) {
                self.androidID = androidID
                self.device = device
                self.manufacturer = manufacturer
                self.model = model
                self.product = product
                self.serial = serial
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("androidId", androidID?.asQueryValue)
                query.addQueryItem("device", device?.asQueryValue)
                query.addQueryItem("manufacturer", manufacturer?.asQueryValue)
                query.addQueryItem("model", model?.asQueryValue)
                query.addQueryItem("product", product?.asQueryValue)
                query.addQueryItem("serial", serial?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1 {
    public var series: Series {
        Series(path: path + "/series")
    }

    public struct Series {
        /// Path: `/books/v1/series`
        public let path: String
    }
}

extension Paths.Books.V1.Series {
    public var get: Get {
        Get(path: path + "/get")
    }

    public struct Get {
        /// Path: `/books/v1/series/get`
        public let path: String

        /// Returns Series metadata for the given series ids.
        public func get(seriesID: [String]) -> Request<google_books.Series> {
            .get(path, query: makeGetQuery(seriesID))
        }

        private func makeGetQuery(_ seriesID: [String]) -> [(String, String?)] {
            var query: [(String, String?)] = []
            for value in seriesID {
                query.addQueryItem("series_id", value.asQueryValue)
            }
            return query
        }
    }
}

extension Paths.Books.V1.Series {
    public var membership: Membership {
        Membership(path: path + "/membership")
    }

    public struct Membership {
        /// Path: `/books/v1/series/membership`
        public let path: String
    }
}

extension Paths.Books.V1.Series.Membership {
    public var get: Get {
        Get(path: path + "/get")
    }

    public struct Get {
        /// Path: `/books/v1/series/membership/get`
        public let path: String

        /// Returns Series membership data given the series id.
        public func get(parameters: GetParameters) -> Request<google_books.Seriesmembership> {
            .get(path, query: parameters.asQuery())
        }

        public struct GetParameters {
            public var seriesID: String
            public var pageSize: Int?
            public var pageToken: String?

            public init(seriesID: String, pageSize: Int? = nil, pageToken: String? = nil) {
                self.seriesID = seriesID
                self.pageSize = pageSize
                self.pageToken = pageToken
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("series_id", seriesID.asQueryValue)
                query.addQueryItem("page_size", pageSize?.asQueryValue)
                query.addQueryItem("page_token", pageToken?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1 {
    public var users: Users {
        Users(path: path + "/users")
    }

    public struct Users {
        /// Path: `/books/v1/users`
        public let path: String
    }
}

extension Paths.Books.V1.Users {
    public func userID(_ userID: String) -> WithUserID {
        WithUserID(path: "\(path)/\(userID)")
    }

    public struct WithUserID {
        /// Path: `/books/v1/users/{userId}`
        public let path: String
    }
}

extension Paths.Books.V1.Users.WithUserID {
    public var bookshelves: Bookshelves {
        Bookshelves(path: path + "/bookshelves")
    }

    public struct Bookshelves {
        /// Path: `/books/v1/users/{userId}/bookshelves`
        public let path: String

        /// Retrieves a list of public bookshelves for the specified user.
        public func get(source: String? = nil) -> Request<google_books.Bookshelves> {
            .get(path, query: makeGetQuery(source))
        }

        private func makeGetQuery(_ source: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("source", source?.asQueryValue)
            return query
        }
    }
}

extension Paths.Books.V1.Users.WithUserID.Bookshelves {
    public func shelf(_ shelf: String) -> WithShelf {
        WithShelf(path: "\(path)/\(shelf)")
    }

    public struct WithShelf {
        /// Path: `/books/v1/users/{userId}/bookshelves/{shelf}`
        public let path: String

        /// Retrieves metadata for a specific bookshelf for the specified user.
        public func get(source: String? = nil) -> Request<google_books.Bookshelf> {
            .get(path, query: makeGetQuery(source))
        }

        private func makeGetQuery(_ source: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("source", source?.asQueryValue)
            return query
        }
    }
}

extension Paths.Books.V1.Users.WithUserID.Bookshelves.WithShelf {
    public var volumes: Volumes {
        Volumes(path: path + "/volumes")
    }

    public struct Volumes {
        /// Path: `/books/v1/users/{userId}/bookshelves/{shelf}/volumes`
        public let path: String

        /// Retrieves volumes in a specific bookshelf for the specified user.
        public func get(parameters: GetParameters? = nil) -> Request<google_books.Volumes> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var maxResults: Int?
            public var isShowPreorders: Bool?
            public var source: String?
            public var startIndex: Int?

            public init(maxResults: Int? = nil, isShowPreorders: Bool? = nil, source: String? = nil, startIndex: Int? = nil) {
                self.maxResults = maxResults
                self.isShowPreorders = isShowPreorders
                self.source = source
                self.startIndex = startIndex
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("maxResults", maxResults?.asQueryValue)
                query.addQueryItem("showPreorders", isShowPreorders?.asQueryValue)
                query.addQueryItem("source", source?.asQueryValue)
                query.addQueryItem("startIndex", startIndex?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1 {
    public var volumes: Volumes {
        Volumes(path: path + "/volumes")
    }

    public struct Volumes {
        /// Path: `/books/v1/volumes`
        public let path: String

        /// Performs a book search.
        public func get(parameters: GetParameters) -> Request<google_books.Volumes> {
            .get(path, query: parameters.asQuery())
        }

        public struct GetParameters {
            public var q: String
            public var download: Download?
            public var filter: Filter?
            public var langRestrict: String?
            public var libraryRestrict: LibraryRestrict?
            public var maxAllowedMaturityRating: MaxAllowedMaturityRating?
            public var maxResults: Int?
            public var orderBy: OrderBy?
            public var partner: String?
            public var printType: PrintType?
            public var projection: Projection?
            public var isShowPreorders: Bool?
            public var source: String?
            public var startIndex: Int?

            public enum Download: String, Codable, CaseIterable {
                case downloadUndefined = "DOWNLOAD_UNDEFINED"
                case epub = "EPUB"
            }

            public enum Filter: String, Codable, CaseIterable {
                case filterUndefined = "FILTER_UNDEFINED"
                case ebooks
                case freeEbooks = "free-ebooks"
                case full
                case paidEbooks = "paid-ebooks"
                case partial
            }

            public enum LibraryRestrict: String, Codable, CaseIterable {
                case libraryRestrictUndefined = "LIBRARY_RESTRICT_UNDEFINED"
                case myLibrary = "my-library"
                case noRestrict = "no-restrict"
            }

            public enum MaxAllowedMaturityRating: String, Codable, CaseIterable {
                case maxAllowedMaturityRatingUndefined = "MAX_ALLOWED_MATURITY_RATING_UNDEFINED"
                case mature = "MATURE"
                case notMature = "not-mature"
            }

            public enum OrderBy: String, Codable, CaseIterable {
                case orderByUndefined = "ORDER_BY_UNDEFINED"
                case newest
                case relevance
            }

            public enum PrintType: String, Codable, CaseIterable {
                case printTypeUndefined = "PRINT_TYPE_UNDEFINED"
                case all = "ALL"
                case books = "BOOKS"
                case magazines = "MAGAZINES"
            }

            public enum Projection: String, Codable, CaseIterable {
                case projectionUndefined = "PROJECTION_UNDEFINED"
                case full = "FULL"
                case lite = "LITE"
            }

            public init(q: String, download: Download? = nil, filter: Filter? = nil, langRestrict: String? = nil, libraryRestrict: LibraryRestrict? = nil, maxAllowedMaturityRating: MaxAllowedMaturityRating? = nil, maxResults: Int? = nil, orderBy: OrderBy? = nil, partner: String? = nil, printType: PrintType? = nil, projection: Projection? = nil, isShowPreorders: Bool? = nil, source: String? = nil, startIndex: Int? = nil) {
                self.q = q
                self.download = download
                self.filter = filter
                self.langRestrict = langRestrict
                self.libraryRestrict = libraryRestrict
                self.maxAllowedMaturityRating = maxAllowedMaturityRating
                self.maxResults = maxResults
                self.orderBy = orderBy
                self.partner = partner
                self.printType = printType
                self.projection = projection
                self.isShowPreorders = isShowPreorders
                self.source = source
                self.startIndex = startIndex
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("q", q.asQueryValue)
                query.addQueryItem("download", download?.asQueryValue)
                query.addQueryItem("filter", filter?.asQueryValue)
                query.addQueryItem("langRestrict", langRestrict?.asQueryValue)
                query.addQueryItem("libraryRestrict", libraryRestrict?.asQueryValue)
                query.addQueryItem("maxAllowedMaturityRating", maxAllowedMaturityRating?.asQueryValue)
                query.addQueryItem("maxResults", maxResults?.asQueryValue)
                query.addQueryItem("orderBy", orderBy?.asQueryValue)
                query.addQueryItem("partner", partner?.asQueryValue)
                query.addQueryItem("printType", printType?.asQueryValue)
                query.addQueryItem("projection", projection?.asQueryValue)
                query.addQueryItem("showPreorders", isShowPreorders?.asQueryValue)
                query.addQueryItem("source", source?.asQueryValue)
                query.addQueryItem("startIndex", startIndex?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1.Volumes {
    public var mybooks: Mybooks {
        Mybooks(path: path + "/mybooks")
    }

    public struct Mybooks {
        /// Path: `/books/v1/volumes/mybooks`
        public let path: String

        /// Return a list of books in My Library.
        public func get(parameters: GetParameters? = nil) -> Request<google_books.Volumes> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var acquireMethod: [AcquireMethod]?
            public var country: String?
            public var locale: String?
            public var maxResults: Int?
            public var processingState: [ProcessingState]?
            public var source: String?
            public var startIndex: Int?

            public enum AcquireMethod: String, Codable, CaseIterable {
                case acquireMethodUndefined = "ACQUIRE_METHOD_UNDEFINED"
                case familyShared = "FAMILY_SHARED"
                case preordered = "PREORDERED"
                case previouslyRented = "PREVIOUSLY_RENTED"
                case publicDomain = "PUBLIC_DOMAIN"
                case purchased = "PURCHASED"
                case rented = "RENTED"
                case sample = "SAMPLE"
                case uploaded = "UPLOADED"
            }

            public enum ProcessingState: String, Codable, CaseIterable {
                case processingStateUndefined = "PROCESSING_STATE_UNDEFINED"
                case completedFailed = "COMPLETED_FAILED"
                case completedSuccess = "COMPLETED_SUCCESS"
                case running = "RUNNING"
            }

            public init(acquireMethod: [AcquireMethod]? = nil, country: String? = nil, locale: String? = nil, maxResults: Int? = nil, processingState: [ProcessingState]? = nil, source: String? = nil, startIndex: Int? = nil) {
                self.acquireMethod = acquireMethod
                self.country = country
                self.locale = locale
                self.maxResults = maxResults
                self.processingState = processingState
                self.source = source
                self.startIndex = startIndex
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                for value in acquireMethod ?? [] {
                    query.addQueryItem("acquireMethod", value.asQueryValue)
                }
                query.addQueryItem("country", country?.asQueryValue)
                query.addQueryItem("locale", locale?.asQueryValue)
                query.addQueryItem("maxResults", maxResults?.asQueryValue)
                for value in processingState ?? [] {
                    query.addQueryItem("processingState", value.asQueryValue)
                }
                query.addQueryItem("source", source?.asQueryValue)
                query.addQueryItem("startIndex", startIndex?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1.Volumes {
    public var recommended: Recommended {
        Recommended(path: path + "/recommended")
    }

    public struct Recommended {
        /// Path: `/books/v1/volumes/recommended`
        public let path: String

        /// Return a list of recommended books for the current user.
        public func get(parameters: GetParameters? = nil) -> Request<google_books.Volumes> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var locale: String?
            public var maxAllowedMaturityRating: MaxAllowedMaturityRating?
            public var source: String?

            public enum MaxAllowedMaturityRating: String, Codable, CaseIterable {
                case maxAllowedMaturityRatingUndefined = "MAX_ALLOWED_MATURITY_RATING_UNDEFINED"
                case mature = "MATURE"
                case notMature = "not-mature"
            }

            public init(locale: String? = nil, maxAllowedMaturityRating: MaxAllowedMaturityRating? = nil, source: String? = nil) {
                self.locale = locale
                self.maxAllowedMaturityRating = maxAllowedMaturityRating
                self.source = source
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("locale", locale?.asQueryValue)
                query.addQueryItem("maxAllowedMaturityRating", maxAllowedMaturityRating?.asQueryValue)
                query.addQueryItem("source", source?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1.Volumes.Recommended {
    public var rate: Rate {
        Rate(path: path + "/rate")
    }

    public struct Rate {
        /// Path: `/books/v1/volumes/recommended/rate`
        public let path: String

        /// Rate a recommended book for the current user.
        public func post(parameters: PostParameters) -> Request<google_books.BooksVolumesRecommendedRateResponse> {
            .post(path, query: parameters.asQuery())
        }

        public struct PostParameters {
            public var rating: Rating
            public var volumeID: String
            public var locale: String?
            public var source: String?

            public enum Rating: String, Codable, CaseIterable {
                case ratingUndefined = "RATING_UNDEFINED"
                case haveIt = "HAVE_IT"
                case notInterested = "NOT_INTERESTED"
            }

            public init(rating: Rating, volumeID: String, locale: String? = nil, source: String? = nil) {
                self.rating = rating
                self.volumeID = volumeID
                self.locale = locale
                self.source = source
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("rating", rating.asQueryValue)
                query.addQueryItem("volumeId", volumeID.asQueryValue)
                query.addQueryItem("locale", locale?.asQueryValue)
                query.addQueryItem("source", source?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1.Volumes {
    public var useruploaded: Useruploaded {
        Useruploaded(path: path + "/useruploaded")
    }

    public struct Useruploaded {
        /// Path: `/books/v1/volumes/useruploaded`
        public let path: String

        /// Return a list of books uploaded by the current user.
        public func get(parameters: GetParameters? = nil) -> Request<google_books.Volumes> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var locale: String?
            public var maxResults: Int?
            public var processingState: [ProcessingState]?
            public var source: String?
            public var startIndex: Int?
            public var volumeID: [String]?

            public enum ProcessingState: String, Codable, CaseIterable {
                case processingStateUndefined = "PROCESSING_STATE_UNDEFINED"
                case completedFailed = "COMPLETED_FAILED"
                case completedSuccess = "COMPLETED_SUCCESS"
                case running = "RUNNING"
            }

            public init(locale: String? = nil, maxResults: Int? = nil, processingState: [ProcessingState]? = nil, source: String? = nil, startIndex: Int? = nil, volumeID: [String]? = nil) {
                self.locale = locale
                self.maxResults = maxResults
                self.processingState = processingState
                self.source = source
                self.startIndex = startIndex
                self.volumeID = volumeID
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("locale", locale?.asQueryValue)
                query.addQueryItem("maxResults", maxResults?.asQueryValue)
                for value in processingState ?? [] {
                    query.addQueryItem("processingState", value.asQueryValue)
                }
                query.addQueryItem("source", source?.asQueryValue)
                query.addQueryItem("startIndex", startIndex?.asQueryValue)
                for value in volumeID ?? [] {
                    query.addQueryItem("volumeId", value.asQueryValue)
                }
                return query
            }
        }
    }
}

extension Paths.Books.V1.Volumes {
    public func volumeID(_ volumeID: String) -> WithVolumeID {
        WithVolumeID(path: "\(path)/\(volumeID)")
    }

    public struct WithVolumeID {
        /// Path: `/books/v1/volumes/{volumeId}`
        public let path: String

        /// Gets volume information for a single volume.
        public func get(parameters: GetParameters? = nil) -> Request<google_books.Volume> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var country: String?
            public var isIncludeNonComicsSeries: Bool?
            public var partner: String?
            public var projection: Projection?
            public var source: String?
            public var isUserLibraryConsistentRead: Bool?

            public enum Projection: String, Codable, CaseIterable {
                case projectionUndefined = "PROJECTION_UNDEFINED"
                case full = "FULL"
                case lite = "LITE"
            }

            public init(country: String? = nil, isIncludeNonComicsSeries: Bool? = nil, partner: String? = nil, projection: Projection? = nil, source: String? = nil, isUserLibraryConsistentRead: Bool? = nil) {
                self.country = country
                self.isIncludeNonComicsSeries = isIncludeNonComicsSeries
                self.partner = partner
                self.projection = projection
                self.source = source
                self.isUserLibraryConsistentRead = isUserLibraryConsistentRead
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("country", country?.asQueryValue)
                query.addQueryItem("includeNonComicsSeries", isIncludeNonComicsSeries?.asQueryValue)
                query.addQueryItem("partner", partner?.asQueryValue)
                query.addQueryItem("projection", projection?.asQueryValue)
                query.addQueryItem("source", source?.asQueryValue)
                query.addQueryItem("user_library_consistent_read", isUserLibraryConsistentRead?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1.Volumes.WithVolumeID {
    public var associated: Associated {
        Associated(path: path + "/associated")
    }

    public struct Associated {
        /// Path: `/books/v1/volumes/{volumeId}/associated`
        public let path: String

        /// Return a list of associated books.
        public func get(parameters: GetParameters? = nil) -> Request<google_books.Volumes> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var association: Association?
            public var locale: String?
            public var maxAllowedMaturityRating: MaxAllowedMaturityRating?
            public var source: String?

            public enum Association: String, Codable, CaseIterable {
                case associationUndefined = "ASSOCIATION_UNDEFINED"
                case endOfSample = "end-of-sample"
                case endOfVolume = "end-of-volume"
                case relatedForPlay = "related-for-play"
            }

            public enum MaxAllowedMaturityRating: String, Codable, CaseIterable {
                case maxAllowedMaturityRatingUndefined = "MAX_ALLOWED_MATURITY_RATING_UNDEFINED"
                case mature = "MATURE"
                case notMature = "not-mature"
            }

            public init(association: Association? = nil, locale: String? = nil, maxAllowedMaturityRating: MaxAllowedMaturityRating? = nil, source: String? = nil) {
                self.association = association
                self.locale = locale
                self.maxAllowedMaturityRating = maxAllowedMaturityRating
                self.source = source
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("association", association?.asQueryValue)
                query.addQueryItem("locale", locale?.asQueryValue)
                query.addQueryItem("maxAllowedMaturityRating", maxAllowedMaturityRating?.asQueryValue)
                query.addQueryItem("source", source?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1.Volumes.WithVolumeID {
    public var layers: Layers {
        Layers(path: path + "/layers")
    }

    public struct Layers {
        /// Path: `/books/v1/volumes/{volumeId}/layers`
        public let path: String
    }
}

extension Paths.Books.V1.Volumes.WithVolumeID.Layers {
    public func layerID(_ layerID: String) -> WithLayerID {
        WithLayerID(path: "\(path)/\(layerID)")
    }

    public struct WithLayerID {
        /// Path: `/books/v1/volumes/{volumeId}/layers/{layerId}`
        public let path: String

        /// Gets the volume annotations for a volume and layer.
        public func get(parameters: GetParameters) -> Request<google_books.Volumeannotations> {
            .get(path, query: parameters.asQuery())
        }

        public struct GetParameters {
            public var contentVersion: String
            public var endOffset: String?
            public var endPosition: String?
            public var locale: String?
            public var maxResults: Int?
            public var pageToken: String?
            public var isShowDeleted: Bool?
            public var source: String?
            public var startOffset: String?
            public var startPosition: String?
            public var updatedMax: String?
            public var updatedMin: String?
            public var volumeAnnotationsVersion: String?

            public init(contentVersion: String, endOffset: String? = nil, endPosition: String? = nil, locale: String? = nil, maxResults: Int? = nil, pageToken: String? = nil, isShowDeleted: Bool? = nil, source: String? = nil, startOffset: String? = nil, startPosition: String? = nil, updatedMax: String? = nil, updatedMin: String? = nil, volumeAnnotationsVersion: String? = nil) {
                self.contentVersion = contentVersion
                self.endOffset = endOffset
                self.endPosition = endPosition
                self.locale = locale
                self.maxResults = maxResults
                self.pageToken = pageToken
                self.isShowDeleted = isShowDeleted
                self.source = source
                self.startOffset = startOffset
                self.startPosition = startPosition
                self.updatedMax = updatedMax
                self.updatedMin = updatedMin
                self.volumeAnnotationsVersion = volumeAnnotationsVersion
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("contentVersion", contentVersion.asQueryValue)
                query.addQueryItem("endOffset", endOffset?.asQueryValue)
                query.addQueryItem("endPosition", endPosition?.asQueryValue)
                query.addQueryItem("locale", locale?.asQueryValue)
                query.addQueryItem("maxResults", maxResults?.asQueryValue)
                query.addQueryItem("pageToken", pageToken?.asQueryValue)
                query.addQueryItem("showDeleted", isShowDeleted?.asQueryValue)
                query.addQueryItem("source", source?.asQueryValue)
                query.addQueryItem("startOffset", startOffset?.asQueryValue)
                query.addQueryItem("startPosition", startPosition?.asQueryValue)
                query.addQueryItem("updatedMax", updatedMax?.asQueryValue)
                query.addQueryItem("updatedMin", updatedMin?.asQueryValue)
                query.addQueryItem("volumeAnnotationsVersion", volumeAnnotationsVersion?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1.Volumes.WithVolumeID.Layers.WithLayerID {
    public var annotations: Annotations {
        Annotations(path: path + "/annotations")
    }

    public struct Annotations {
        /// Path: `/books/v1/volumes/{volumeId}/layers/{layerId}/annotations`
        public let path: String
    }
}

extension Paths.Books.V1.Volumes.WithVolumeID.Layers.WithLayerID.Annotations {
    public func annotationID(_ annotationID: String) -> WithAnnotationID {
        WithAnnotationID(path: "\(path)/\(annotationID)")
    }

    public struct WithAnnotationID {
        /// Path: `/books/v1/volumes/{volumeId}/layers/{layerId}/annotations/{annotationId}`
        public let path: String

        /// Gets the volume annotation.
        public func get(locale: String? = nil, source: String? = nil) -> Request<google_books.Volumeannotation> {
            .get(path, query: makeGetQuery(locale, source))
        }

        private func makeGetQuery(_ locale: String?, _ source: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("locale", locale?.asQueryValue)
            query.addQueryItem("source", source?.asQueryValue)
            return query
        }
    }
}

extension Paths.Books.V1.Volumes.WithVolumeID.Layers.WithLayerID {
    public var data: Data {
        Data(path: path + "/data")
    }

    public struct Data {
        /// Path: `/books/v1/volumes/{volumeId}/layers/{layerId}/data`
        public let path: String

        /// Gets the annotation data for a volume and layer.
        public func get(parameters: GetParameters) -> Request<google_books.Annotationsdata> {
            .get(path, query: parameters.asQuery())
        }

        public struct GetParameters {
            public var contentVersion: String
            public var annotationDataID: [String]?
            public var h: Int?
            public var locale: String?
            public var maxResults: Int?
            public var pageToken: String?
            public var scale: Int?
            public var source: String?
            public var updatedMax: String?
            public var updatedMin: String?
            public var w: Int?

            public init(contentVersion: String, annotationDataID: [String]? = nil, h: Int? = nil, locale: String? = nil, maxResults: Int? = nil, pageToken: String? = nil, scale: Int? = nil, source: String? = nil, updatedMax: String? = nil, updatedMin: String? = nil, w: Int? = nil) {
                self.contentVersion = contentVersion
                self.annotationDataID = annotationDataID
                self.h = h
                self.locale = locale
                self.maxResults = maxResults
                self.pageToken = pageToken
                self.scale = scale
                self.source = source
                self.updatedMax = updatedMax
                self.updatedMin = updatedMin
                self.w = w
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("contentVersion", contentVersion.asQueryValue)
                for value in annotationDataID ?? [] {
                    query.addQueryItem("annotationDataId", value.asQueryValue)
                }
                query.addQueryItem("h", h?.asQueryValue)
                query.addQueryItem("locale", locale?.asQueryValue)
                query.addQueryItem("maxResults", maxResults?.asQueryValue)
                query.addQueryItem("pageToken", pageToken?.asQueryValue)
                query.addQueryItem("scale", scale?.asQueryValue)
                query.addQueryItem("source", source?.asQueryValue)
                query.addQueryItem("updatedMax", updatedMax?.asQueryValue)
                query.addQueryItem("updatedMin", updatedMin?.asQueryValue)
                query.addQueryItem("w", w?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1.Volumes.WithVolumeID.Layers.WithLayerID.Data {
    public func annotationDataID(_ annotationDataID: String) -> WithAnnotationDataID {
        WithAnnotationDataID(path: "\(path)/\(annotationDataID)")
    }

    public struct WithAnnotationDataID {
        /// Path: `/books/v1/volumes/{volumeId}/layers/{layerId}/data/{annotationDataId}`
        public let path: String

        /// Gets the annotation data.
        public func get(parameters: GetParameters) -> Request<google_books.DictionaryAnnotationdata> {
            .get(path, query: parameters.asQuery())
        }

        public struct GetParameters {
            public var contentVersion: String
            public var allowWebDefinitions: Bool?
            public var h: Int?
            public var locale: String?
            public var scale: Int?
            public var source: String?
            public var w: Int?

            public init(contentVersion: String, allowWebDefinitions: Bool? = nil, h: Int? = nil, locale: String? = nil, scale: Int? = nil, source: String? = nil, w: Int? = nil) {
                self.contentVersion = contentVersion
                self.allowWebDefinitions = allowWebDefinitions
                self.h = h
                self.locale = locale
                self.scale = scale
                self.source = source
                self.w = w
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("contentVersion", contentVersion.asQueryValue)
                query.addQueryItem("allowWebDefinitions", allowWebDefinitions?.asQueryValue)
                query.addQueryItem("h", h?.asQueryValue)
                query.addQueryItem("locale", locale?.asQueryValue)
                query.addQueryItem("scale", scale?.asQueryValue)
                query.addQueryItem("source", source?.asQueryValue)
                query.addQueryItem("w", w?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1.Volumes.WithVolumeID {
    public var layersummary: Layersummary {
        Layersummary(path: path + "/layersummary")
    }

    public struct Layersummary {
        /// Path: `/books/v1/volumes/{volumeId}/layersummary`
        public let path: String

        /// List the layer summaries for a volume.
        public func get(parameters: GetParameters? = nil) -> Request<google_books.Layersummaries> {
            .get(path, query: parameters?.asQuery())
        }

        public struct GetParameters {
            public var contentVersion: String?
            public var maxResults: Int?
            public var pageToken: String?
            public var source: String?

            public init(contentVersion: String? = nil, maxResults: Int? = nil, pageToken: String? = nil, source: String? = nil) {
                self.contentVersion = contentVersion
                self.maxResults = maxResults
                self.pageToken = pageToken
                self.source = source
            }

            public func asQuery() -> [(String, String?)] {
                var query: [(String, String?)] = []
                query.addQueryItem("contentVersion", contentVersion?.asQueryValue)
                query.addQueryItem("maxResults", maxResults?.asQueryValue)
                query.addQueryItem("pageToken", pageToken?.asQueryValue)
                query.addQueryItem("source", source?.asQueryValue)
                return query
            }
        }
    }
}

extension Paths.Books.V1.Volumes.WithVolumeID.Layersummary {
    public func summaryID(_ summaryID: String) -> WithSummaryID {
        WithSummaryID(path: "\(path)/\(summaryID)")
    }

    public struct WithSummaryID {
        /// Path: `/books/v1/volumes/{volumeId}/layersummary/{summaryId}`
        public let path: String

        /// Gets the layer summary for a volume.
        public func get(contentVersion: String? = nil, source: String? = nil) -> Request<google_books.Layersummary> {
            .get(path, query: makeGetQuery(contentVersion, source))
        }

        private func makeGetQuery(_ contentVersion: String?, _ source: String?) -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("contentVersion", contentVersion?.asQueryValue)
            query.addQueryItem("source", source?.asQueryValue)
            return query
        }
    }
}

public enum Paths {}

extension Bool {
    var asQueryValue: String {
        self ? "true" : "false"
    }
}

extension Date {
    var asQueryValue: String {
        ISO8601DateFormatter().string(from: self)
    }
}

extension Double {
    var asQueryValue: String {
        String(self)
    }
}

extension Int {
    var asQueryValue: String {
        String(self)
    }
}

extension Int32 {
    var asQueryValue: String {
        String(self)
    }
}

extension Int64 {
    var asQueryValue: String {
        String(self)
    }
}

extension String {
    var asQueryValue: String {
        self
    }
}

extension URL {
    var asQueryValue: String {
        absoluteString
    }
}

extension RawRepresentable where RawValue == String {
    var asQueryValue: String {
        rawValue
    }
}

extension Array where Element == (String, String?) {
    mutating func addQueryItem(_ name: String, _ value: String?) {
        guard let value = value, !value.isEmpty else { return }
        append((name, value))
    }
}
