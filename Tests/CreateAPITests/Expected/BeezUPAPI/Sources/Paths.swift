// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension Paths {
    public static var v2: V2 {
        V2(path: "/v2")
    }

    public struct V2 {
        /// Path: `/v2`
        public let path: String
    }
}

extension Paths.V2 {
    public var `public`: Public {
        Public(path: path + "/public")
    }

    public struct Public {
        /// Path: `/v2/public`
        public let path: String
    }
}

extension Paths.V2.Public {
    public var security: Security {
        Security(path: path + "/security")
    }

    public struct Security {
        /// Path: `/v2/public/security`
        public let path: String
    }
}

extension Paths.V2.Public.Security {
    public var login: Login {
        Login(path: path + "/login")
    }

    public struct Login {
        /// Path: `/v2/public/security/login`
        public let path: String

        /// Login
        ///
        /// User Login - The login will give your tokens
        public func post(_ body: BeezUPAPI.LoginRequest) -> Request<BeezUPAPI.APICredentials> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.Public.Security {
    public var register: Register {
        Register(path: path + "/register")
    }

    public struct Register {
        /// Path: `/v2/public/security/register`
        public let path: String

        /// User Registration
        ///
        /// User Registration - Create a new user on BeezUP
        public func post(_ body: BeezUPAPI.RegisterRequest) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.Public.Security {
    public var lostpassword: Lostpassword {
        Lostpassword(path: path + "/lostpassword")
    }

    public struct Lostpassword {
        /// Path: `/v2/public/security/lostpassword`
        public let path: String

        /// Lost password
        ///
        /// Lost password - Your password will be regenerated and sent to your email
        public func post(_ body: String) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.Public {
    public var channels: Channels {
        Channels(path: path + "/channels")
    }

    public struct Channels {
        /// Path: `/v2/public/channels`
        public let path: String

        /// Get public channel index
        ///
        /// Use this operation to get the correct link to the channels and to the list of values
        public var get: Request<BeezUPAPI.PublicChannelIndex> {
            .get(path)
        }
    }
}

extension Paths.V2.Public.Channels {
    public func countryIsoCode(_ countryIsoCode: String) -> WithCountryIsoCode {
        WithCountryIsoCode(path: "\(path)/\(countryIsoCode)")
    }

    public struct WithCountryIsoCode {
        /// Path: `/v2/public/channels/{countryIsoCode}`
        public let path: String

        /// The channel list for one country
        public var get: Request<BeezUPAPI.PublicChannelInfoList> {
            .get(path)
        }
    }
}

extension Paths.V2.Public {
    public var lov: Lov {
        Lov(path: path + "/lov")
    }

    public struct Lov {
        /// Path: `/v2/public/lov`
        public let path: String

        /// Get all list names
        public var get: Request<BeezUPAPI.PublicLovIndex> {
            .get(path)
        }

        public enum GetResponseHeaders {
            /// Indicates the directive around the caching mechanisms.\
            /// For more information, please go to this link: https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9
            public static let cacheControl = HTTPHeader<[String]>(field: "Cache-Control")
            /// The ETag corresponding to the LOV Index
            public static let eTag = HTTPHeader<String>(field: "ETag")
        }
    }
}

extension Paths.V2.Public.Lov {
    public func listName(_ listName: String) -> WithListName {
        WithListName(path: "\(path)/\(listName)")
    }

    public struct WithListName {
        /// Path: `/v2/public/lov/{listName}`
        public let path: String

        /// Get the list of values related to this list name
        public var get: Request<BeezUPAPI.PublicListOfValuesResponse> {
            .get(path)
        }

        public enum GetResponseHeaders {
            /// Indicates the directive around the caching mechanisms.\
            /// For more information, please go to this link: https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9
            public static let cacheControl = HTTPHeader<[String]>(field: "Cache-Control")
            /// The ETag corresponding to the LOV Index
            public static let eTag = HTTPHeader<String>(field: "ETag")
            /// Indicates the language use in the response
            public static let contentLanguage = HTTPHeader<[String]>(field: "Content-Language")
        }
    }
}

extension Paths.V2 {
    public var user: User {
        User(path: path + "/user")
    }

    public struct User {
        /// Path: `/v2/user`
        public let path: String
    }
}

extension Paths.V2.User {
    public var lov: Lov {
        Lov(path: path + "/lov")
    }

    public struct Lov {
        /// Path: `/v2/user/lov`
        public let path: String

        /// Get all list names
        public var get: Request<BeezUPAPI.UserLovIndex> {
            .get(path)
        }

        public enum GetResponseHeaders {
            /// Indicates the directive around the caching mechanisms.\
            /// For more information, please go to this link: https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9
            public static let cacheControl = HTTPHeader<[String]>(field: "Cache-Control")
            /// The ETag corresponding to the LOV Index
            public static let eTag = HTTPHeader<String>(field: "ETag")
        }
    }
}

extension Paths.V2.User.Lov {
    public func listName(_ listName: String) -> WithListName {
        WithListName(path: "\(path)/\(listName)")
    }

    public struct WithListName {
        /// Path: `/v2/user/lov/{listName}`
        public let path: String

        /// Get the list of values related to this list name
        public var get: Request<BeezUPAPI.UserListOfValuesResponse> {
            .get(path)
        }

        public enum GetResponseHeaders {
            /// Indicates the directive around the caching mechanisms.\
            /// For more information, please go to this link: https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9
            public static let cacheControl = HTTPHeader<[String]>(field: "Cache-Control")
            /// The ETag corresponding to the LOV Index
            public static let eTag = HTTPHeader<String>(field: "ETag")
            /// Indicates the language use in the response
            public static let contentLanguage = HTTPHeader<[String]>(field: "Content-Language")
        }
    }
}

extension Paths.V2.User {
    public var customer: Customer {
        Customer(path: path + "/customer")
    }

    public struct Customer {
        /// Path: `/v2/user/customer`
        public let path: String

        /// The index of all operations and LOV
        public var get: Request<BeezUPAPI.CustomerIndex> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Customer {
    public var account: Account {
        Account(path: path + "/account")
    }

    public struct Account {
        /// Path: `/v2/user/customer/account`
        public let path: String

        /// Get user account information
        public var get: Request<BeezUPAPI.AccountInfo> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Customer.Account {
    public var resendEmailActivation: ResendEmailActivation {
        ResendEmailActivation(path: path + "/resendEmailActivation")
    }

    public struct ResendEmailActivation {
        /// Path: `/v2/user/customer/account/resendEmailActivation`
        public let path: String

        /// Resend email activation
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Customer.Account {
    public var activate: Activate {
        Activate(path: path + "/activate")
    }

    public struct Activate {
        /// Path: `/v2/user/customer/account/activate`
        public let path: String

        /// Activate the user account
        public func post(_ body: String) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Customer.Account {
    public var personalInfo: PersonalInfo {
        PersonalInfo(path: path + "/personalInfo")
    }

    public struct PersonalInfo {
        /// Path: `/v2/user/customer/account/personalInfo`
        public let path: String

        /// Save user personal information
        public func put(_ body: BeezUPAPI.PersonalInfo) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.V2.User.Customer.Account {
    public var companyInfo: CompanyInfo {
        CompanyInfo(path: path + "/companyInfo")
    }

    public struct CompanyInfo {
        /// Path: `/v2/user/customer/account/companyInfo`
        public let path: String

        /// Change company information
        public func put(_ body: BeezUPAPI.CompanyInfo) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.V2.User.Customer.Account {
    public var profilePictureInfo: ProfilePictureInfo {
        ProfilePictureInfo(path: path + "/profilePictureInfo")
    }

    public struct ProfilePictureInfo {
        /// Path: `/v2/user/customer/account/profilePictureInfo`
        public let path: String

        /// Get profile picture information
        public var get: Request<BeezUPAPI.ProfilePictureInfoResponse> {
            .get(path)
        }

        /// Change user picture information
        public func put(_ body: BeezUPAPI.ProfilePictureInfo) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.V2.User.Customer.Account {
    public var creditCardInfo: CreditCardInfo {
        CreditCardInfo(path: path + "/creditCardInfo")
    }

    public struct CreditCardInfo {
        /// Path: `/v2/user/customer/account/creditCardInfo`
        public let path: String

        /// Get credit card information
        public var get: Request<BeezUPAPI.CreditCardInfoResponse> {
            .get(path)
        }

        /// Save user credit card info
        public func put(_ body: BeezUPAPI.CreditCardInfo) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.V2.User.Customer.Account {
    public var changeEmail: ChangeEmail {
        ChangeEmail(path: path + "/changeEmail")
    }

    public struct ChangeEmail {
        /// Path: `/v2/user/customer/account/changeEmail`
        public let path: String

        /// Change user email
        public func post(_ body: BeezUPAPI.ChangeEmailRequest) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Customer.Account {
    public var changePassword: ChangePassword {
        ChangePassword(path: path + "/changePassword")
    }

    public struct ChangePassword {
        /// Path: `/v2/user/customer/account/changePassword`
        public let path: String

        /// Change user password
        public func post(_ body: BeezUPAPI.ChangePasswordRequest) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Customer {
    public var security: Security {
        Security(path: path + "/security")
    }

    public struct Security {
        /// Path: `/v2/user/customer/security`
        public let path: String
    }
}

extension Paths.V2.User.Customer.Security {
    public var logout: Logout {
        Logout(path: path + "/logout")
    }

    public struct Logout {
        /// Path: `/v2/user/customer/security/logout`
        public let path: String

        /// Log out the current user from go2
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Customer {
    public var zendeskToken: ZendeskToken {
        ZendeskToken(path: path + "/zendeskToken")
    }

    public struct ZendeskToken {
        /// Path: `/v2/user/customer/zendeskToken`
        public let path: String

        /// Zendesk token
        ///
        /// Zendesk token - Generates a JWT token to access BeezUP restricted Help Center in SSO as described here: https://support.zendesk.com/hc/en-us/articles/222874768-Using-restricted-Help-Center-content-with-the-Web-Widget
        public var get: Request<BeezUPAPI.ZendeskToken> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Customer {
    public var stores: Stores {
        Stores(path: path + "/stores")
    }

    public struct Stores {
        /// Path: `/v2/user/customer/stores`
        public let path: String

        /// Get store list
        public var get: Request<BeezUPAPI.StoreList> {
            .get(path)
        }

        /// Create a new store
        public func post(_ body: BeezUPAPI.CreateStoreRequest) -> Request<BeezUPAPI.BeezUPCommonLink3> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Customer.Stores {
    public func storeID(_ storeID: String) -> WithStoreID {
        WithStoreID(path: "\(path)/\(storeID)")
    }

    public struct WithStoreID {
        /// Path: `/v2/user/customer/stores/{storeId}`
        public let path: String

        /// Get store's information
        public var get: Request<BeezUPAPI.Store> {
            .get(path)
        }

        /// Update some store's information.
        ///
        /// Update some store's information. FYI, you cannot change the country.
        public func patch(_ body: BeezUPAPI.UpdateStoreRequest) -> Request<Void> {
            .patch(path, body: body)
        }

        /// Delete a store
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.V2.User.Customer.Stores.WithStoreID {
    public var rights: Rights {
        Rights(path: path + "/rights")
    }

    public struct Rights {
        /// Path: `/v2/user/customer/stores/{storeId}/rights`
        public let path: String

        /// Get store's rights
        public var get: Request<[BeezUPAPI.FunctionalityRightInfo]> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Customer.Stores.WithStoreID {
    public var alerts: Alerts {
        Alerts(path: path + "/alerts")
    }

    public struct Alerts {
        /// Path: `/v2/user/customer/stores/{storeId}/alerts`
        public let path: String

        /// Get store's alerts
        public var get: Request<BeezUPAPI.StoreAlerts> {
            .get(path)
        }

        /// Save store alerts
        ///
        /// You just have to send the alert you want to update, does not need all alerts. (PARTIAL UPDATE ACCEPTED)
        public func post(_ body: [String: BeezUPAPI.SaveStoreAlertRequest]) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Customer.Stores.WithStoreID {
    public var shares: Shares {
        Shares(path: path + "/shares")
    }

    public struct Shares {
        /// Path: `/v2/user/customer/stores/{storeId}/shares`
        public let path: String

        /// Get shares related to this store
        public var get: Request<BeezUPAPI.StoreShares> {
            .get(path)
        }

        /// Share a store to another user
        public func post(_ body: String) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Customer.Stores.WithStoreID.Shares {
    public func userID(_ userID: String) -> WithUserID {
        WithUserID(path: "\(path)/\(userID)")
    }

    public struct WithUserID {
        /// Path: `/v2/user/customer/stores/{storeId}/shares/{userId}`
        public let path: String

        /// Delete a share of a store to another user
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.V2.User.Customer {
    public var friends: Friends {
        Friends(path: path + "/friends")
    }

    public struct Friends {
        /// Path: `/v2/user/customer/friends`
        public let path: String
    }
}

extension Paths.V2.User.Customer.Friends {
    public func userID(_ userID: String) -> WithUserID {
        WithUserID(path: "\(path)/\(userID)")
    }

    public struct WithUserID {
        /// Path: `/v2/user/customer/friends/{userId}`
        public let path: String

        /// Get friend information
        public var get: Request<BeezUPAPI.UserFriendInfo> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Customer {
    public var billingPeriods: BillingPeriods {
        BillingPeriods(path: path + "/billingPeriods")
    }

    public struct BillingPeriods {
        /// Path: `/v2/user/customer/billingPeriods`
        public let path: String

        /// Get billing periods conditions
        public var get: Request<BeezUPAPI.BillingPeriodList> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Customer {
    public var offers: Offers {
        Offers(path: path + "/offers")
    }

    public struct Offers {
        /// Path: `/v2/user/customer/offers`
        public let path: String

        /// Get all standard offers
        public var get: Request<BeezUPAPI.StandardOffers> {
            .get(path)
        }

        /// Get offer pricing
        ///
        /// Get the offer pricing then you can create your contract with the same request parameters. /v2/user/customer/contracts
        public func post(_ body: BeezUPAPI.OfferRequest) -> Request<BeezUPAPI.Offer> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Customer {
    public var contracts: Contracts {
        Contracts(path: path + "/contracts")
    }

    public struct Contracts {
        /// Path: `/v2/user/customer/contracts`
        public let path: String

        /// Get contract list
        public var get: Request<BeezUPAPI.Contracts> {
            .get(path)
        }

        /// Create a new contract
        ///
        /// Now you are ready to create your contract. Before that, please ensure that you check the offer with the same request parameterts. /offers
        public func post(_ body: BeezUPAPI.OfferRequest) -> Request<BeezUPAPI.CreateContractResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Customer.Contracts {
    public var current: Current {
        Current(path: path + "/current")
    }

    public struct Current {
        /// Path: `/v2/user/customer/contracts/current`
        public let path: String
    }
}

extension Paths.V2.User.Customer.Contracts.Current {
    public var disableAutoRenewal: DisableAutoRenewal {
        DisableAutoRenewal(path: path + "/disableAutoRenewal")
    }

    public struct DisableAutoRenewal {
        /// Path: `/v2/user/customer/contracts/current/disableAutoRenewal`
        public let path: String

        /// Schedule termination of your current contract at the end of the commitment.
        ///
        /// By default your contract are automatically renew. By calling this operation you can disable the auto renewal.
        public func post(_ body: BeezUPAPI.TerminateContract) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Customer.Contracts.Current {
    public var reenableAutoRenewal: ReenableAutoRenewal {
        ReenableAutoRenewal(path: path + "/reenableAutoRenewal")
    }

    public struct ReenableAutoRenewal {
        /// Path: `/v2/user/customer/contracts/current/reenableAutoRenewal`
        public let path: String

        /// Reactivate your terminated contract.
        ///
        /// By calling this operation you can re-enable the auto renewal.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Customer.Contracts {
    public var next: Next {
        Next(path: path + "/next")
    }

    public struct Next {
        /// Path: `/v2/user/customer/contracts/next`
        public let path: String

        /// Delete your next contract
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.V2.User.Customer {
    public var invoices: Invoices {
        Invoices(path: path + "/invoices")
    }

    public struct Invoices {
        /// Path: `/v2/user/customer/invoices`
        public let path: String

        /// Get all your invoices
        public var get: Request<BeezUPAPI.InvoiceList> {
            .get(path)
        }
    }
}

extension Paths.V2.User {
    public var catalogs: Catalogs {
        Catalogs(path: path + "/catalogs")
    }

    public struct Catalogs {
        /// Path: `/v2/user/catalogs`
        public let path: String

        /// Get the index of the catalog API
        ///
        /// The operation will give you all the operations you will be able to do and all the LOV used in this API.
        public var get: Request<BeezUPAPI.CatalogIndex> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Catalogs {
    public var beezupColumns: BeezupColumns {
        BeezupColumns(path: path + "/beezupColumns")
    }

    public struct BeezupColumns {
        /// Path: `/v2/user/catalogs/beezupColumns`
        public let path: String

        /// Get the BeezUP columns
        ///
        /// Get the BeezUP columns, this columns are used for mapping during the manual catalog importation process.
        public var get: Request<[BeezUPAPI.BeezUPColumnConfiguration]> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Catalogs {
    public func storeID(_ storeID: String) -> WithStoreID {
        WithStoreID(path: "\(path)/\(storeID)")
    }

    public struct WithStoreID {
        /// Path: `/v2/user/catalogs/{storeId}`
        public let path: String

        /// Get the index of the catalog API for this store
        ///
        /// The operation will give you all the operations you will be able to do on this store for this API.
        public var get: Request<BeezUPAPI.CatalogStoreIndex> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID {
    public var inputConfiguration: InputConfiguration {
        InputConfiguration(path: path + "/inputConfiguration")
    }

    public struct InputConfiguration {
        /// Path: `/v2/user/catalogs/{storeId}/inputConfiguration`
        public let path: String

        /// Get the last input configuration
        public var get: Request<BeezUPAPI.LastManualImportInputConfiguration> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID {
    public var catalogColumns: CatalogColumns {
        CatalogColumns(path: path + "/catalogColumns")
    }

    public struct CatalogColumns {
        /// Path: `/v2/user/catalogs/{storeId}/catalogColumns`
        public let path: String

        /// Get catalog column list
        public var get: Request<BeezUPAPI.CatalogColumnList> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.CatalogColumns {
    public func columnID(_ columnID: String) -> WithColumnID {
        WithColumnID(path: "\(path)/\(columnID)")
    }

    public struct WithColumnID {
        /// Path: `/v2/user/catalogs/{storeId}/catalogColumns/{columnId}`
        public let path: String
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.CatalogColumns.WithColumnID {
    public var rename: Rename {
        Rename(path: path + "/rename")
    }

    public struct Rename {
        /// Path: `/v2/user/catalogs/{storeId}/catalogColumns/{columnId}/rename`
        public let path: String

        /// Change Catalog Column User Name
        public func post(_ body: BeezUPAPI.ChangeUserColumnNameRequest) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID {
    public var customColumns: CustomColumns {
        CustomColumns(path: path + "/customColumns")
    }

    public struct CustomColumns {
        /// Path: `/v2/user/catalogs/{storeId}/customColumns`
        public let path: String

        /// Get custom column list
        public var get: Request<BeezUPAPI.CustomColumnList> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.CustomColumns {
    public func columnID(_ columnID: String) -> WithColumnID {
        WithColumnID(path: "\(path)/\(columnID)")
    }

    public struct WithColumnID {
        /// Path: `/v2/user/catalogs/{storeId}/customColumns/{columnId}`
        public let path: String

        /// Create or replace a custom column
        public func put(_ body: BeezUPAPI.CreateCustomColumnRequest) -> Request<Void> {
            .put(path, body: body)
        }

        /// Delete custom column
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.CustomColumns.WithColumnID {
    public var rename: Rename {
        Rename(path: path + "/rename")
    }

    public struct Rename {
        /// Path: `/v2/user/catalogs/{storeId}/customColumns/{columnId}/rename`
        public let path: String

        /// Change Custom Column User Name
        public func post(_ body: BeezUPAPI.ChangeUserColumnNameRequest) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.CustomColumns.WithColumnID {
    public var expression: Expression {
        Expression(path: path + "/expression")
    }

    public struct Expression {
        /// Path: `/v2/user/catalogs/{storeId}/customColumns/{columnId}/expression`
        public let path: String

        /// Get the encrypted custom column expression
        public var get: Request<String> {
            .get(path)
        }

        /// Change custom column expression
        public func put(_ body: BeezUPAPI.ChangeCustomColumnExpressionRequest) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.CustomColumns {
    public var computeExpression: ComputeExpression {
        ComputeExpression(path: path + "/computeExpression")
    }

    public struct ComputeExpression {
        /// Path: `/v2/user/catalogs/{storeId}/customColumns/computeExpression`
        public let path: String

        /// Compute the expression for this catalog.
        public func post(_ body: BeezUPAPI.ComputeExpressionRequest) -> Request<String> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID {
    public var categories: Categories {
        Categories(path: path + "/categories")
    }

    public struct Categories {
        /// Path: `/v2/user/catalogs/{storeId}/categories`
        public let path: String

        /// Get category list
        public var get: Request<BeezUPAPI.CategoryList> {
            .get(path)
        }

        public enum GetResponseHeaders {
            /// Indicates the compression use in the response
            public static let contentEncoding = HTTPHeader<[String]>(field: "Content-Encoding")
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Products {
    public var list: List {
        List(path: path + "/list")
    }

    public struct List {
        /// Path: `/v2/user/catalogs/{storeId}/products/list`
        public let path: String

        /// Get product list
        public func post(_ body: BeezUPAPI.GetProductsRequest) -> Request<BeezUPAPI.ProductList> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Products {
    public var random: Random {
        Random(path: path + "/random")
    }

    public struct Random {
        /// Path: `/v2/user/catalogs/{storeId}/products/random`
        public let path: String

        /// Get random product list
        ///
        /// We will return 10 products randomly selected with all product values
        public var get: Request<BeezUPAPI.RandomProductList> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Products {
    public func productID(_ productID: String) -> WithProductID {
        WithProductID(path: "\(path)/\(productID)")
    }

    public struct WithProductID {
        /// Path: `/v2/user/catalogs/{storeId}/products/{productId}`
        public let path: String

        /// Get product by ProductId
        public var get: Request<BeezUPAPI.Product> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID {
    public var products: Products {
        Products(path: path + "/products")
    }

    public struct Products {
        /// Path: `/v2/user/catalogs/{storeId}/products`
        public let path: String

        /// Get product by Sku
        public func get(sku: String) -> Request<BeezUPAPI.Product> {
            .get(path, query: [("sku", sku)])
        }
    }
}

extension Paths.V2.User.Catalogs {
    public var importations: Importations {
        Importations(path: path + "/importations")
    }

    public struct Importations {
        /// Path: `/v2/user/catalogs/importations`
        public let path: String

        /// Get the latest catalog importation reporting for all your stores
        public var get: Request<[String: BeezUPAPI.ImportationsResponse]> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID {
    public var importations: Importations {
        Importations(path: path + "/importations")
    }

    public struct Importations {
        /// Path: `/v2/user/catalogs/{storeId}/importations`
        public let path: String

        /// Get the latest catalog importation reporting
        public var get: Request<BeezUPAPI.ImportationsResponse> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations {
    public var start: Start {
        Start(path: path + "/start")
    }

    public struct Start {
        /// Path: `/v2/user/catalogs/{storeId}/importations/start`
        public let path: String

        /// Start Manual Import
        public func post(_ body: BeezUPAPI.StartManualImportRequest) -> Request<BeezUPAPI.BeezUPCommonLink3> {
            .post(path, body: body)
        }

        public enum PostResponseHeaders {
            /// The duration in second to wait before polling this resource
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
            /// The location of the new resource to poll
            public static let location = HTTPHeader<String>(field: "Location")
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations {
    public func executionID(_ executionID: String) -> WithExecutionID {
        WithExecutionID(path: "\(path)/\(executionID)")
    }

    public struct WithExecutionID {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}`
        public let path: String

        /// Get the importation status
        public var get: Request<BeezUPAPI.ImportationMonitoring> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations.WithExecutionID {
    public var cancel: Cancel {
        Cancel(path: path + "/cancel")
    }

    public struct Cancel {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}/cancel`
        public let path: String

        /// Cancel importation
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations.WithExecutionID {
    public var technicalProgression: TechnicalProgression {
        TechnicalProgression(path: path + "/technicalProgression")
    }

    public struct TechnicalProgression {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}/technicalProgression`
        public let path: String

        /// Get technical progression
        public var get: Request<BeezUPAPI.ImportationTechnicalProgression> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations.WithExecutionID {
    public var configureRemainingCatalogColumns: ConfigureRemainingCatalogColumns {
        ConfigureRemainingCatalogColumns(path: path + "/configureRemainingCatalogColumns")
    }

    public struct ConfigureRemainingCatalogColumns {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}/configureRemainingCatalogColumns`
        public let path: String

        /// Configure remaining catalog columns
        ///
        /// This operation should be used after you have mapped the required BeezUP Columns
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations.WithExecutionID {
    public var commitColumns: CommitColumns {
        CommitColumns(path: path + "/commitColumns")
    }

    public struct CommitColumns {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}/commitColumns`
        public let path: String

        /// Commit columns
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations.WithExecutionID {
    public var commit: Commit {
        Commit(path: path + "/commit")
    }

    public struct Commit {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}/commit`
        public let path: String

        /// Commit Importation
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations.WithExecutionID {
    public var productSamples: ProductSamples {
        ProductSamples(path: path + "/productSamples")
    }

    public struct ProductSamples {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}/productSamples`
        public let path: String
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations.WithExecutionID.ProductSamples {
    public func productSampleIndex(_ productSampleIndex: Int) -> WithProductSampleIndex {
        WithProductSampleIndex(path: "\(path)/\(productSampleIndex)")
    }

    public struct WithProductSampleIndex {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}/productSamples/{productSampleIndex}`
        public let path: String

        /// Get the product sample related to this importation with all columns (catalog and custom)
        public var get: Request<BeezUPAPI.ProductSample> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations.WithExecutionID.ProductSamples.WithProductSampleIndex {
    public var customColumns: CustomColumns {
        CustomColumns(path: path + "/customColumns")
    }

    public struct CustomColumns {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}/productSamples/{productSampleIndex}/customColumns`
        public let path: String
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations.WithExecutionID.ProductSamples.WithProductSampleIndex.CustomColumns {
    public func columnID(_ columnID: String) -> WithColumnID {
        WithColumnID(path: "\(path)/\(columnID)")
    }

    public struct WithColumnID {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}/productSamples/{productSampleIndex}/customColumns/{columnId}`
        public let path: String

        /// Get product sample custom column value related to this importation.
        ///
        /// /!\ Use this operation only when you just changed the custom column expression and you want to get a precise the property value. Otherwise use the operation Importation_GetProductSample which will give you all property values
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations.WithExecutionID {
    public var catalogColumns: CatalogColumns {
        CatalogColumns(path: path + "/catalogColumns")
    }

    public struct CatalogColumns {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}/catalogColumns`
        public let path: String

        /// Get detected catalog columns during this importation.
        public var get: Request<BeezUPAPI.DetectedCatalogColumnList> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations.WithExecutionID.CatalogColumns {
    public func columnID(_ columnID: String) -> WithColumnID {
        WithColumnID(path: "\(path)/\(columnID)")
    }

    public struct WithColumnID {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}/catalogColumns/{columnId}`
        public let path: String

        /// Configure catalog column
        public func post(_ body: BeezUPAPI.ConfigureCatalogColumnCatalogRequest) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations.WithExecutionID.CatalogColumns.WithColumnID {
    public var ignore: Ignore {
        Ignore(path: path + "/ignore")
    }

    public struct Ignore {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}/catalogColumns/{columnId}/ignore`
        public let path: String

        /// Ignore Column
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations.WithExecutionID.CatalogColumns.WithColumnID {
    public var reattend: Reattend {
        Reattend(path: path + "/reattend")
    }

    public struct Reattend {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}/catalogColumns/{columnId}/reattend`
        public let path: String

        /// Reattend Column
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations.WithExecutionID.CatalogColumns.WithColumnID {
    public var map: Map {
        Map(path: path + "/map")
    }

    public struct Map {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}/catalogColumns/{columnId}/map`
        public let path: String

        /// Map catalog column to a BeezUP column
        public func post(_ body: BeezUPAPI.MapBeezUPColumnRequest) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations.WithExecutionID.CatalogColumns.WithColumnID {
    public var unmap: Unmap {
        Unmap(path: path + "/unmap")
    }

    public struct Unmap {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}/catalogColumns/{columnId}/unmap`
        public let path: String

        /// Unmap catalog column
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations.WithExecutionID {
    public var customColumns: CustomColumns {
        CustomColumns(path: path + "/customColumns")
    }

    public struct CustomColumns {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}/customColumns`
        public let path: String

        /// Get custom columns currently place in this importation
        public var get: Request<BeezUPAPI.ImportationCustomColumnList> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations.WithExecutionID.CustomColumns.WithColumnID {
    public var expression: Expression {
        Expression(path: path + "/expression")
    }

    public struct Expression {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}/customColumns/{columnId}/expression`
        public let path: String

        /// Get the encrypted custom column expression in this importation
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations.WithExecutionID.CustomColumns {
    public func columnID(_ columnID: String) -> WithColumnID {
        WithColumnID(path: "\(path)/\(columnID)")
    }

    public struct WithColumnID {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}/customColumns/{columnId}`
        public let path: String

        /// Create or replace a custom column
        public func put(_ body: BeezUPAPI.ChangeCustomColumnRequest) -> Request<Void> {
            .put(path, body: body)
        }

        /// Delete Custom Column
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations.WithExecutionID.CustomColumns.WithColumnID {
    public var map: Map {
        Map(path: path + "/map")
    }

    public struct Map {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}/customColumns/{columnId}/map`
        public let path: String

        /// Map custom column to a BeezUP column
        public func post(_ body: BeezUPAPI.MapBeezUPColumnRequest) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations.WithExecutionID.CustomColumns.WithColumnID {
    public var unmap: Unmap {
        Unmap(path: path + "/unmap")
    }

    public struct Unmap {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}/customColumns/{columnId}/unmap`
        public let path: String

        /// Unmap custom column
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations.WithExecutionID {
    public var products: Products {
        Products(path: path + "/products")
    }

    public struct Products {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}/products`
        public let path: String
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations.WithExecutionID.Products {
    public var list: List {
        List(path: path + "/list")
    }

    public struct List {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}/products/list`
        public let path: String

        /// Importation Get Products Report
        public func post(_ body: BeezUPAPI.GetImportationProductsReportRequest) -> Request<BeezUPAPI.GetImportationProductsReportResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.Importations.WithExecutionID {
    public var report: Report {
        Report(path: path + "/report")
    }

    public struct Report {
        /// Path: `/v2/user/catalogs/{storeId}/importations/{executionId}/report`
        public let path: String

        /// Importation Get Report
        public var get: Request<BeezUPAPI.GetImportationReportResponse> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.AutoImport {
    public var activate: Activate {
        Activate(path: path + "/activate")
    }

    public struct Activate {
        /// Path: `/v2/user/catalogs/{storeId}/autoImport/activate`
        public let path: String

        /// Activate the auto importation of the last successful manual catalog importation.
        ///
        /// Once you have made your fist manual catalog importation with success, you can call this operation to import it automatically. No parameter required, we know which one it is.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID {
    public var autoImport: AutoImport {
        AutoImport(path: path + "/autoImport")
    }

    public struct AutoImport {
        /// Path: `/v2/user/catalogs/{storeId}/autoImport`
        public let path: String

        /// Get the auto import configuration
        public var get: Request<BeezUPAPI.AutoImportConfiguration> {
            .get(path)
        }

        /// Delete Auto Import
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.AutoImport {
    public var start: Start {
        Start(path: path + "/start")
    }

    public struct Start {
        /// Path: `/v2/user/catalogs/{storeId}/autoImport/start`
        public let path: String

        /// Start Auto Import Manually
        public var post: Request<BeezUPAPI.BeezUPCommonLink3> {
            .post(path)
        }

        public enum PostResponseHeaders {
            /// The duration in second to wait before polling this resource
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
            /// The location of the new resource to poll
            public static let location = HTTPHeader<String>(field: "Location")
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.AutoImport {
    public var pause: Pause {
        Pause(path: path + "/pause")
    }

    public struct Pause {
        /// Path: `/v2/user/catalogs/{storeId}/autoImport/pause`
        public let path: String

        /// Pause Auto Import
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.AutoImport {
    public var resume: Resume {
        Resume(path: path + "/resume")
    }

    public struct Resume {
        /// Path: `/v2/user/catalogs/{storeId}/autoImport/resume`
        public let path: String

        /// Resume Auto Import
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.AutoImport {
    public var scheduling: Scheduling {
        Scheduling(path: path + "/scheduling")
    }

    public struct Scheduling {
        /// Path: `/v2/user/catalogs/{storeId}/autoImport/scheduling`
        public let path: String
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.AutoImport.Scheduling {
    public var interval: Interval {
        Interval(path: path + "/interval")
    }

    public struct Interval {
        /// Path: `/v2/user/catalogs/{storeId}/autoImport/scheduling/interval`
        public let path: String

        /// Configure Auto Import Interval
        public func post(_ body: BeezUPAPI.ConfigureAutoImportIntervalRequest) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Catalogs.WithStoreID.AutoImport.Scheduling {
    public var schedules: Schedules {
        Schedules(path: path + "/schedules")
    }

    public struct Schedules {
        /// Path: `/v2/user/catalogs/{storeId}/autoImport/scheduling/schedules`
        public let path: String

        /// Configure Auto Import Schedules
        public func post(_ body: BeezUPAPI.ScheduleAutoImportRequest) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User {
    public var channels: Channels {
        Channels(path: path + "/channels")
    }

    public struct Channels {
        /// Path: `/v2/user/channels`
        public let path: String

        /// List all available channel for this store
        public func get(storeID: String) -> Request<[BeezUPAPI.ChannelHeader]> {
            .get(path, query: [("storeId", storeID)])
        }
    }
}

extension Paths.V2.User.Channels {
    public func channelID(_ channelID: String) -> WithChannelID {
        WithChannelID(path: "\(path)/\(channelID)")
    }

    public struct WithChannelID {
        /// Path: `/v2/user/channels/{channelId}`
        public let path: String

        /// Get channel information
        public var get: Request<BeezUPAPI.ChannelInfo> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Channels.WithChannelID {
    public var categories: Categories {
        Categories(path: path + "/categories")
    }

    public struct Categories {
        /// Path: `/v2/user/channels/{channelId}/categories`
        public let path: String

        /// Get channel categories
        public var get: Request<BeezUPAPI.ChannelRootCategory> {
            .get(path)
        }

        public enum GetResponseHeaders {
            /// Indicates the compression use in the response
            public static let contentEncoding = HTTPHeader<[String]>(field: "Content-Encoding")
        }
    }
}

extension Paths.V2.User.Channels.WithChannelID {
    public var columns: Columns {
        Columns(path: path + "/columns")
    }

    public struct Columns {
        /// Path: `/v2/user/channels/{channelId}/columns`
        public let path: String

        /// Get channel columns
        public func post(_ body: [String]? = nil) -> Request<[BeezUPAPI.ChannelColumn]> {
            .post(path, body: body)
        }

        public enum PostResponseHeaders {
            /// Indicates the compression use in the response
            public static let contentEncoding = HTTPHeader<[String]>(field: "Content-Encoding")
        }
    }
}

extension Paths.V2.User {
    public var channelCatalogs: ChannelCatalogs {
        ChannelCatalogs(path: path + "/channelCatalogs")
    }

    public struct ChannelCatalogs {
        /// Path: `/v2/user/channelCatalogs`
        public let path: String

        /// List all your current channel catalogs
        public func get(storeID: String? = nil) -> Request<BeezUPAPI.ChannelCatalogList> {
            .get(path, query: makeGetQuery(storeID))
        }

        private func makeGetQuery(_ storeID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(storeID, forKey: "storeId")
            return encoder.items
        }

        /// Add a new channel catalog
        public func post(_ body: BeezUPAPI.AddChannelCatalogRequest) -> Request<BeezUPAPI.BeezUPCommonLink3> {
            .post(path, body: body)
        }

        public enum PostResponseHeaders {
            /// The duration in second to wait before polling this resource
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
            /// The new location
            public static let location = HTTPHeader<String>(field: "Location")
        }
    }
}

extension Paths.V2.User.ChannelCatalogs {
    public func channelCatalogID(_ channelCatalogID: String) -> WithChannelCatalogID {
        WithChannelCatalogID(path: "\(path)/\(channelCatalogID)")
    }

    public struct WithChannelCatalogID {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}`
        public let path: String

        /// Get the channel catalog information
        public var get: Request<BeezUPAPI.ChannelCatalog> {
            .get(path)
        }

        /// Delete the channel catalog
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.V2.User.ChannelCatalogs {
    public var filterOperators: FilterOperators {
        FilterOperators(path: path + "/filterOperators")
    }

    public struct FilterOperators {
        /// Path: `/v2/user/channelCatalogs/filterOperators`
        public let path: String

        /// Get channel catalog filter operators
        public var get: Request<[BeezUPAPI.FilterOperator]> {
            .get(path)
        }
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID {
    public var enable: Enable {
        Enable(path: path + "/enable")
    }

    public struct Enable {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/enable`
        public let path: String

        /// Enable a channel catalog
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID {
    public var disable: Disable {
        Disable(path: path + "/disable")
    }

    public struct Disable {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/disable`
        public let path: String

        /// Disable a channel catalog
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID {
    public var settings: Settings {
        Settings(path: path + "/settings")
    }

    public struct Settings {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/settings`
        public let path: String
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID.Settings {
    public var general: General {
        General(path: path + "/general")
    }

    public struct General {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/settings/general`
        public let path: String

        /// Configure channel catalog general settings
        public func put(_ body: BeezUPAPI.GeneralSettings) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID.Settings {
    public var cost: Cost {
        Cost(path: path + "/cost")
    }

    public struct Cost {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/settings/cost`
        public let path: String

        /// Configure channel catalog cost settings
        public func put(_ body: BeezUPAPI.CostSettings) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID {
    public var columnMappings: ColumnMappings {
        ColumnMappings(path: path + "/columnMappings")
    }

    public struct ColumnMappings {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/columnMappings`
        public let path: String

        /// Configure channel catalog column mappings
        public func put(_ body: [BeezUPAPI.ChannelCatalogColumnMapping]) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID {
    public var categories: Categories {
        Categories(path: path + "/categories")
    }

    public struct Categories {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/categories`
        public let path: String

        /// Get channel catalog categories
        public var get: Request<BeezUPAPI.ChannelCatalogCategoryConfigurationList> {
            .get(path)
        }
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID.Categories {
    public var disableMapping: DisableMapping {
        DisableMapping(path: path + "/disableMapping")
    }

    public struct DisableMapping {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/categories/disableMapping`
        public let path: String

        /// Disable a channel catalog category mapping
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID.Categories {
    public var reenableMapping: ReenableMapping {
        ReenableMapping(path: path + "/reenableMapping")
    }

    public struct ReenableMapping {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/categories/reenableMapping`
        public let path: String

        /// Reenable a channel catalog category mapping
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID.Categories {
    public var configure: Configure {
        Configure(path: path + "/configure")
    }

    public struct Configure {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/categories/configure`
        public let path: String

        /// Configure channel catalog category
        public func post(_ body: BeezUPAPI.ConfigureCategoryRequest) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID {
    public var exclusionFilters: ExclusionFilters {
        ExclusionFilters(path: path + "/exclusionFilters")
    }

    public struct ExclusionFilters {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/exclusionFilters`
        public let path: String

        /// Get channel catalog exclusion filters
        public var get: Request<BeezUPAPI.ExclusionFiltersResponse> {
            .get(path)
        }

        /// Configure channel catalog exclusion filters
        public func put(_ body: [BeezUPAPI.ExclusionFilter]) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID {
    public var products: Products {
        Products(path: path + "/products")
    }

    public struct Products {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/products`
        public let path: String

        /// Get channel catalog product information list
        public func post(_ body: BeezUPAPI.GetChannelCatalogProductInfoListRequest) -> Request<BeezUPAPI.ChannelCatalogProductInfoList> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID.Products {
    public var export: Export {
        Export(path: path + "/export")
    }

    public struct Export {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/products/export`
        public let path: String

        /// Export channel catalog product information list
        public func post(format: Format, _ body: BeezUPAPI.GetChannelCatalogProductInfoListRequest) -> Request<BeezUPAPI.BeezUPCommonLink3> {
            .post(path, query: makePostQuery(format), body: body)
        }

        public enum PostResponseHeaders {
            /// To indicate the url of the export file
            /// Example: https://beezupchannel.blob.core.windows.net/reports/exports/Excel_Products.xslx
            public static let location = HTTPHeader<String>(field: "Location")
        }

        private func makePostQuery(_ format: Format) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(format, forKey: "format")
            return encoder.items
        }

        public enum Format: String, Codable, CaseIterable {
            case xlsx
            case csv
        }
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID.Products {
    public var counters: Counters {
        Counters(path: path + "/counters")
    }

    public struct Counters {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/products/counters`
        public let path: String

        /// Get channel catalog products' counters
        public var get: Request<BeezUPAPI.ChannelCatalogProductsCounters> {
            .get(path)
        }
    }
}

extension Paths.V2.User.ChannelCatalogs {
    public var products: Products {
        Products(path: path + "/products")
    }

    public struct Products {
        /// Path: `/v2/user/channelCatalogs/products`
        public let path: String

        /// Get channel catalog products related to these channel catalogs
        public func post(_ body: BeezUPAPI.ChannelCatalogProductByChannelCatalogRequest) -> Request<BeezUPAPI.ChannelCatalogProductByChannelCatalogResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID.Products {
    public func productID(_ productID: String) -> WithProductID {
        WithProductID(path: "\(path)/\(productID)")
    }

    public struct WithProductID {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/products/{productId}`
        public let path: String

        /// Get channel catalog product information
        public var get: Request<BeezUPAPI.ChannelCatalogProductInfo> {
            .get(path)
        }
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID.Products.WithProductID {
    public var overrides: Overrides {
        Overrides(path: path + "/overrides")
    }

    public struct Overrides {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/products/{productId}/overrides`
        public let path: String

        /// Override channel catalog product values
        public func put(_ body: [String: String]) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID.Products.WithProductID.Overrides {
    public func channelColumnID(_ channelColumnID: String) -> WithChannelColumnID {
        WithChannelColumnID(path: "\(path)/\(channelColumnID)")
    }

    public struct WithChannelColumnID {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/products/{productId}/overrides/{channelColumnId}`
        public let path: String

        /// Delete a specific channel catalog product value override
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID.Products.WithProductID.Overrides {
    public var copy: Copy {
        Copy(path: path + "/copy")
    }

    public struct Copy {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/products/{productId}/overrides/copy`
        public let path: String

        /// Get channel catalog product value override compatibilities status
        public var get: Request<Void> {
            .get(path)
        }

        /// Copy channel catalog product value override
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID.Products.WithProductID {
    public var disable: Disable {
        Disable(path: path + "/disable")
    }

    public struct Disable {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/products/{productId}/disable`
        public let path: String

        /// Disable channel catalog product
        ///
        /// By default a all your catalog products are exposed to the channel.
        /// You can disable a product by using this operation.
        /// /!\ In case of massive optimisation we recommand you to use the analytics api
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID.Products.WithProductID {
    public var reenable: Reenable {
        Reenable(path: path + "/reenable")
    }

    public struct Reenable {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/products/{productId}/reenable`
        public let path: String

        /// Reenable channel catalog product
        ///
        /// By default a all your catalog products are exposed to the channel.
        /// You can reenable a product by using this operation.
        /// /!\ In case of massive optimisation we recommand you to use the analytics api
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID {
    public var exportations: Exportations {
        Exportations(path: path + "/exportations")
    }

    public struct Exportations {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/exportations`
        public let path: String
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID.Exportations {
    public var cache: Cache {
        Cache(path: path + "/cache")
    }

    public struct Cache {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/exportations/cache`
        public let path: String

        /// Get the exportation cache information
        public var get: Request<BeezUPAPI.ChannelCatalogExportCacheInfoResponse> {
            .get(path)
        }
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID.Exportations.Cache {
    public var clear: Clear {
        Clear(path: path + "/clear")
    }

    public struct Clear {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/exportations/cache/clear`
        public let path: String

        /// Clear the exportation cache
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.ChannelCatalogs.WithChannelCatalogID.Exportations {
    public var history: History {
        History(path: path + "/history")
    }

    public struct History {
        /// Path: `/v2/user/channelCatalogs/{channelCatalogId}/exportations/history`
        public let path: String

        /// Get the exportation history
        public func get(pageNumber: Int, pageSize: Int) -> Request<BeezUPAPI.ChannelCatalogExportationHistory> {
            .get(path, query: makeGetQuery(pageNumber, pageSize))
        }

        private func makeGetQuery(_ pageNumber: Int, _ pageSize: Int) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(pageNumber, forKey: "pageNumber")
            encoder.encode(pageSize, forKey: "pageSize")
            return encoder.items
        }
    }
}

extension Paths.V2.User {
    public var marketplaces: Marketplaces {
        Marketplaces(path: path + "/marketplaces")
    }

    public struct Marketplaces {
        /// Path: `/v2/user/marketplaces`
        public let path: String
    }
}

extension Paths.V2.User.Marketplaces {
    public var channelcatalogs: Channelcatalogs {
        Channelcatalogs(path: path + "/channelcatalogs")
    }

    public struct Channelcatalogs {
        /// Path: `/v2/user/marketplaces/channelcatalogs`
        public let path: String

        /// Get your marketplace channel catalog list
        public func get(storeID: String? = nil) -> Request<BeezUPAPI.MarketplaceChannelCatalogList> {
            .get(path, query: makeGetQuery(storeID))
        }

        private func makeGetQuery(_ storeID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(storeID, forKey: "storeId")
            return encoder.items
        }
    }
}

extension Paths.V2.User.Marketplaces.Channelcatalogs {
    public var publications: Publications {
        Publications(path: path + "/publications")
    }

    public struct Publications {
        /// Path: `/v2/user/marketplaces/channelcatalogs/publications`
        public let path: String
    }
}

extension Paths.V2.User.Marketplaces.Channelcatalogs.Publications {
    public func marketplaceTechnicalCode(_ marketplaceTechnicalCode: String) -> WithMarketplaceTechnicalCode {
        WithMarketplaceTechnicalCode(path: "\(path)/\(marketplaceTechnicalCode)")
    }

    public struct WithMarketplaceTechnicalCode {
        /// Path: `/v2/user/marketplaces/channelcatalogs/publications/{marketplaceTechnicalCode}`
        public let path: String
    }
}

extension Paths.V2.User.Marketplaces.Channelcatalogs.Publications.WithMarketplaceTechnicalCode {
    public func accountID(_ accountID: Int) -> WithAccountID {
        WithAccountID(path: "\(path)/\(accountID)")
    }

    public struct WithAccountID {
        /// Path: `/v2/user/marketplaces/channelcatalogs/publications/{marketplaceTechnicalCode}/{accountId}`
        public let path: String
    }
}

extension Paths.V2.User.Marketplaces.Channelcatalogs.Publications.WithMarketplaceTechnicalCode.WithAccountID {
    public var publish: Publish {
        Publish(path: path + "/publish")
    }

    public struct Publish {
        /// Path: `/v2/user/marketplaces/channelcatalogs/publications/{marketplaceTechnicalCode}/{accountId}/publish`
        public let path: String

        /// [PREVIEW] Launch a publication of the catalog to the marketplace
        public func post(_ body: BeezUPAPI.PublishCatalogToMarketplaceRequest) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Marketplaces.Channelcatalogs.Publications.WithMarketplaceTechnicalCode.WithAccountID {
    public var history: History {
        History(path: path + "/history")
    }

    public struct History {
        /// Path: `/v2/user/marketplaces/channelcatalogs/publications/{marketplaceTechnicalCode}/{accountId}/history`
        public let path: String

        /// Fetch the publication history for an account, sorted by descending start date
        public func get(parameters: GetParameters) -> Request<BeezUPAPI.AccountPublications> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var channelCatalogID: String?
            public var count: Int?
            public var publicationTypes: [PublicationTypes]

            public enum PublicationTypes: String, Codable, CaseIterable {
                case publishProducts = "PublishProducts"
                case publishOffers = "PublishOffers"
                case unpublish = "Unpublish"
            }

            public init(channelCatalogID: String? = nil, count: Int? = nil, publicationTypes: [PublicationTypes]) {
                self.channelCatalogID = channelCatalogID
                self.count = count
                self.publicationTypes = publicationTypes
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(channelCatalogID, forKey: "channelCatalogId")
                encoder.encode(count, forKey: "count")
                encoder.encode(publicationTypes, forKey: "publicationTypes", explode: false)
                return encoder.items
            }
        }
    }
}

extension Paths.V2.User.Marketplaces.Channelcatalogs {
    public func channelCatalogID(_ channelCatalogID: String) -> WithChannelCatalogID {
        WithChannelCatalogID(path: "\(path)/\(channelCatalogID)")
    }

    public struct WithChannelCatalogID {
        /// Path: `/v2/user/marketplaces/channelcatalogs/{channelCatalogId}`
        public let path: String
    }
}

extension Paths.V2.User.Marketplaces.Channelcatalogs.WithChannelCatalogID {
    public var properties: Properties {
        Properties(path: path + "/properties")
    }

    public struct Properties {
        /// Path: `/v2/user/marketplaces/channelcatalogs/{channelCatalogId}/properties`
        public let path: String

        /// Get the marketplace properties for a channel catalog
        public func get(redirectionPageURL: URL) -> Request<BeezUPAPI.ChannelCatalogMarketplaceProperties> {
            .get(path, query: makeGetQuery(redirectionPageURL))
        }

        private func makeGetQuery(_ redirectionPageURL: URL) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(redirectionPageURL, forKey: "redirectionPageUrl")
            return encoder.items
        }
    }
}

extension Paths.V2.User.Marketplaces.Channelcatalogs.WithChannelCatalogID {
    public var settings: Settings {
        Settings(path: path + "/settings")
    }

    public struct Settings {
        /// Path: `/v2/user/marketplaces/channelcatalogs/{channelCatalogId}/settings`
        public let path: String

        /// Get the marketplace settings for a channel catalog
        public var get: Request<BeezUPAPI.ChannelCatalogMarketplaceSettings> {
            .get(path)
        }

        /// Save new marketplace settings for a channel catalog
        ///
        /// Allow you to configure your marketplace settings.
        /// Partial update accepted.
        public func post(_ body: BeezUPAPI.SetChannelCatalogMarketplaceSettingsRequest) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Marketplaces {
    public var orders: Orders {
        Orders(path: path + "/orders")
    }

    public struct Orders {
        /// Path: `/v2/user/marketplaces/orders`
        public let path: String

        /// [DEPRECATED] Get all actions you can do on the order API
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<BeezUPAPI.OrderIndex> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/v2/user/marketplaces/orders/status`
        public let path: String

        /// [DEPRECATED] Get current synchronization status between your marketplaces and BeezUP accounts
        ///
        /// Use /orders/v3
        @available(*, deprecated, message: "Deprecated")
        public func get(storeID: String? = nil) -> Request<BeezUPAPI.AccountSynchronizationList> {
            .get(path, query: makeGetQuery(storeID))
        }

        private func makeGetQuery(_ storeID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(storeID, forKey: "storeId")
            return encoder.items
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders {
    public var harvest: Harvest {
        Harvest(path: path + "/harvest")
    }

    public struct Harvest {
        /// Path: `/v2/user/marketplaces/orders/harvest`
        public let path: String

        /// [DEPRECATED] Send harvest request to all your marketplaces
        @available(*, deprecated, message: "Deprecated")
        public func post(storeID: String? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(storeID))
        }

        public enum PostResponseHeaders {
            /// Indicates the duration in seconds to wait to be able to make this request again
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }

        private func makePostQuery(_ storeID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(storeID, forKey: "storeId")
            return encoder.items
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders {
    public var automaticTransitions: AutomaticTransitions {
        AutomaticTransitions(path: path + "/automaticTransitions")
    }

    public struct AutomaticTransitions {
        /// Path: `/v2/user/marketplaces/orders/automaticTransitions`
        public let path: String

        /// Get list of configured automatic Order status transitions
        public func get(storeID: String? = nil) -> Request<BeezUPAPI.AutomaticTransitionInfoList> {
            .get(path, query: makeGetQuery(storeID))
        }

        private func makeGetQuery(_ storeID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(storeID, forKey: "storeId")
            return encoder.items
        }

        /// Configure new or existing automatic Order status transition
        public func post(_ body: BeezUPAPI.ConfigureAutomaticTransitionRequest) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders {
    public var list: List {
        List(path: path + "/list")
    }

    public struct List {
        /// Path: `/v2/user/marketplaces/orders/list`
        public let path: String
    }
}

extension Paths.V2.User.Marketplaces.Orders.List {
    public var full: Full {
        Full(path: path + "/full")
    }

    public struct Full {
        /// Path: `/v2/user/marketplaces/orders/list/full`
        public let path: String

        /// [DEPRECATED] Get a paginated list of all Orders with all Order and Order Item(s) properties
        ///
        /// DEPRECATED - Use /orders/v3 instead
        /// The purpose of this operation is to reduce the amount of request to the API.\
        /// \
        /// Previous implmentation of this feature only returned a partial (light) version of the Orders. The purpose of this API is to reduce the number of incoming requests by returning the complete (full) Order and Order Item(s) properties.
        @available(*, deprecated, message: "Deprecated")
        public func post(_ body: BeezUPAPI.OrderListRequest) -> Request<BeezUPAPI.OrderListFull> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders.List {
    public var light: Light {
        Light(path: path + "/light")
    }

    public struct Light {
        /// Path: `/v2/user/marketplaces/orders/list/light`
        public let path: String

        /// [DEPRECATED] Get a paginated list of all Orders without details
        ///
        /// Use /orders/v3 instead
        @available(*, deprecated, message: "Deprecated")
        public func post(_ body: BeezUPAPI.OrderListRequest) -> Request<BeezUPAPI.OrderListLight> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders {
    public var exportations: Exportations {
        Exportations(path: path + "/exportations")
    }

    public struct Exportations {
        /// Path: `/v2/user/marketplaces/orders/exportations`
        public let path: String

        /// Get a paginated list of Order report exportations
        public func get(parameters: GetParameters) -> Request<BeezUPAPI.OrderExportations> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var pageNumber: Int
            public var pageSize: Int
            public var storeID: String

            public init(pageNumber: Int, pageSize: Int, storeID: String) {
                self.pageNumber = pageNumber
                self.pageSize = pageSize
                self.storeID = storeID
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(pageNumber, forKey: "pageNumber")
                encoder.encode(pageSize, forKey: "pageSize")
                encoder.encode(storeID, forKey: "storeId")
                return encoder.items
            }
        }

        /// Request a new Order report exportation to be generated
        ///
        /// A new file will be generated containing a summary of all the Orders matching the requested filter settings.
        public func post(_ body: BeezUPAPI.ExportOrderListRequest) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders {
    public var batches: Batches {
        Batches(path: path + "/batches")
    }

    public struct Batches {
        /// Path: `/v2/user/marketplaces/orders/batches`
        public let path: String
    }
}

extension Paths.V2.User.Marketplaces.Orders.Batches {
    public var setMerchantOrderInfos: SetMerchantOrderInfos {
        SetMerchantOrderInfos(path: path + "/setMerchantOrderInfos")
    }

    public struct SetMerchantOrderInfos {
        /// Path: `/v2/user/marketplaces/orders/batches/setMerchantOrderInfos`
        public let path: String

        /// [DEPRECATED] Send a batch of operations to set an Order's merchant information  (max 100 items per call)
        ///
        /// The purpose of this operation is to reduce the amount of request to the API.
        @available(*, deprecated, message: "Deprecated")
        public func post(_ body: BeezUPAPI.SetMerchantOrderInfoListRequest) -> Request<BeezUPAPI.BatchOrderOperationResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders.Batches {
    public var clearMerchantOrderInfos: ClearMerchantOrderInfos {
        ClearMerchantOrderInfos(path: path + "/clearMerchantOrderInfos")
    }

    public struct ClearMerchantOrderInfos {
        /// Path: `/v2/user/marketplaces/orders/batches/clearMerchantOrderInfos`
        public let path: String

        /// [DEPRECATED] Send a batch of operations to clear an Order's merchant information (max 100 items per call)
        ///
        /// The purpose of this operation is to reduce the amount of request to the API.
        @available(*, deprecated, message: "Deprecated")
        public func post(_ body: BeezUPAPI.ClearMerchantOrderInfoListRequest) -> Request<BeezUPAPI.BatchOrderOperationResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders.Batches {
    public var changeOrders: ChangeOrders {
        ChangeOrders(path: path + "/changeOrders")
    }

    public struct ChangeOrders {
        /// Path: `/v2/user/marketplaces/orders/batches/changeOrders`
        public let path: String
    }
}

extension Paths.V2.User.Marketplaces.Orders.Batches.ChangeOrders {
    public func changeOrderType(_ changeOrderType: String) -> WithChangeOrderType {
        WithChangeOrderType(path: "\(path)/\(changeOrderType)")
    }

    public struct WithChangeOrderType {
        /// Path: `/v2/user/marketplaces/orders/batches/changeOrders/{changeOrderType}`
        public let path: String

        /// [DEPRECATED] Send a batch of operations to change your marketplace Order information: accept, ship, etc.  (max 100 items per call)
        ///
        /// The purpose of this operation is to reduce the amount of request to the API. 
        /// Max 100 items per call.
        @available(*, deprecated, message: "Deprecated")
        public func post(userName: String, isTestMode: Bool? = nil, _ body: BeezUPAPI.ChangeOrderListRequest) -> Request<BeezUPAPI.BatchOrderOperationResponse> {
            .post(path, query: makePostQuery(userName, isTestMode), body: body)
        }

        private func makePostQuery(_ userName: String, _ isTestMode: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userName, forKey: "userName")
            encoder.encode(isTestMode, forKey: "testMode")
            return encoder.items
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders {
    public func marketplaceTechnicalCode(_ marketplaceTechnicalCode: String) -> WithMarketplaceTechnicalCode {
        WithMarketplaceTechnicalCode(path: "\(path)/\(marketplaceTechnicalCode)")
    }

    public struct WithMarketplaceTechnicalCode {
        /// Path: `/v2/user/marketplaces/orders/{marketplaceTechnicalCode}`
        public let path: String
    }
}

extension Paths.V2.User.Marketplaces.Orders.WithMarketplaceTechnicalCode {
    public func accountID(_ accountID: Int) -> WithAccountID {
        WithAccountID(path: "\(path)/\(accountID)")
    }

    public struct WithAccountID {
        /// Path: `/v2/user/marketplaces/orders/{marketplaceTechnicalCode}/{accountId}`
        public let path: String
    }
}

extension Paths.V2.User.Marketplaces.Orders.WithMarketplaceTechnicalCode.WithAccountID {
    public func beezUPOrderID(_ beezUPOrderID: String) -> WithBeezUPOrderID {
        WithBeezUPOrderID(path: "\(path)/\(beezUPOrderID)")
    }

    public struct WithBeezUPOrderID {
        /// Path: `/v2/user/marketplaces/orders/{marketplaceTechnicalCode}/{accountId}/{beezUPOrderId}`
        public let path: String

        /// [DEPRECATED] DEPRECATED - Get full Order and Order Item(s) properties
        ///
        /// DEPRECATED - Use /orders/v3 instead
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<BeezUPAPI.Order> {
            .get(path)
        }

        public enum GetResponseHeaders {
            /// ETag value to identify the current version of requested Order\
            /// For more details go to this link: http://tools.ietf.org/html/rfc7232#section-2.3
            public static let eTag = HTTPHeader<String>(field: "ETag")
            /// Last modification UTC date of the order\
            /// For more details go to this link: https://tools.ietf.org/html/rfc7232#section-2.2
            public static let lastModified = HTTPHeader<Date>(field: "Last-Modified")
        }

        /// [DEPRECATED] DEPRECATED - Get the meta information about the order (ETag, Last-Modified)
        ///
        /// DEPRECATED - Use /orders/v3 instead
        /// The purpose of this operation is to reduce the bandwith usage by getting just the meta information about the order (ETag, Last-Modified) with the body.
        /// This could be useful
        @available(*, deprecated, message: "Deprecated")
        public var head: Request<Void> {
            .head(path)
        }

        public enum HeadResponseHeaders {
            /// ETag value to identify the current version of requested Order\
            /// For more details go to this link: http://tools.ietf.org/html/rfc7232#section-2.3
            public static let eTag = HTTPHeader<String>(field: "ETag")
            /// Last modification UTC date of the order\
            /// For more details go to this link: https://tools.ietf.org/html/rfc7232#section-2.2
            public static let lastModified = HTTPHeader<Date>(field: "Last-Modified")
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders.WithMarketplaceTechnicalCode.WithAccountID.WithBeezUPOrderID {
    public var history: History {
        History(path: path + "/history")
    }

    public struct History {
        /// Path: `/v2/user/marketplaces/orders/{marketplaceTechnicalCode}/{accountId}/{beezUPOrderId}/history`
        public let path: String

        /// [DEPRECATED] Get an Order's harvest and change history
        @available(*, deprecated, message: "Deprecated")
        public var get: Request<BeezUPAPI.OrderHistory> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders.WithMarketplaceTechnicalCode.WithAccountID.WithBeezUPOrderID {
    public var harvest: Harvest {
        Harvest(path: path + "/harvest")
    }

    public struct Harvest {
        /// Path: `/v2/user/marketplaces/orders/{marketplaceTechnicalCode}/{accountId}/{beezUPOrderId}/harvest`
        public let path: String

        /// [DEPRECATED] Send harvest request for a single Order
        @available(*, deprecated, message: "Deprecated")
        public var post: Request<Void> {
            .post(path)
        }

        public enum PostResponseHeaders {
            /// Indicates the duration in seconds to wait to be able to make this request again
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders.WithMarketplaceTechnicalCode.WithAccountID.WithBeezUPOrderID {
    public var setMerchantOrderInfo: SetMerchantOrderInfo {
        SetMerchantOrderInfo(path: path + "/setMerchantOrderInfo")
    }

    public struct SetMerchantOrderInfo {
        /// Path: `/v2/user/marketplaces/orders/{marketplaceTechnicalCode}/{accountId}/{beezUPOrderId}/setMerchantOrderInfo`
        public let path: String

        /// [DEPRECATED] Set an Order's merchant information
        @available(*, deprecated, message: "Deprecated")
        public func post(_ body: BeezUPAPI.SetMerchantOrderInfoRequest) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders.WithMarketplaceTechnicalCode.WithAccountID.WithBeezUPOrderID {
    public var clearMerchantOrderInfo: ClearMerchantOrderInfo {
        ClearMerchantOrderInfo(path: path + "/clearMerchantOrderInfo")
    }

    public struct ClearMerchantOrderInfo {
        /// Path: `/v2/user/marketplaces/orders/{marketplaceTechnicalCode}/{accountId}/{beezUPOrderId}/clearMerchantOrderInfo`
        public let path: String

        /// [DEPRECATED] Clear an Order's merchant information
        @available(*, deprecated, message: "Deprecated")
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders.WithMarketplaceTechnicalCode.WithAccountID.WithBeezUPOrderID {
    public func changeOrderType(_ changeOrderType: String) -> WithChangeOrderType {
        WithChangeOrderType(path: "\(path)/\(changeOrderType)")
    }

    public struct WithChangeOrderType {
        /// Path: `/v2/user/marketplaces/orders/{marketplaceTechnicalCode}/{accountId}/{beezUPOrderId}/{changeOrderType}`
        public let path: String

        /// [DEPRECATED] Change your marketplace Order Information (accept, ship, etc.)
        @available(*, deprecated, message: "Deprecated")
        public func post(userName: String, isTestMode: Bool? = nil, _ body: [String: String]? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(userName, isTestMode), body: body)
        }

        private func makePostQuery(_ userName: String, _ isTestMode: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userName, forKey: "userName")
            encoder.encode(isTestMode, forKey: "testMode")
            return encoder.items
        }
    }
}

extension Paths {
    public static var orders: Orders {
        Orders(path: "/orders")
    }

    public struct Orders {
        /// Path: `/orders`
        public let path: String
    }
}

extension Paths.Orders {
    public var v3: V3 {
        V3(path: path + "/v3")
    }

    public struct V3 {
        /// Path: `/orders/v3`
        public let path: String
    }
}

extension Paths.Orders.V3 {
    public var lov: Lov {
        Lov(path: path + "/lov")
    }

    public struct Lov {
        /// Path: `/orders/v3/lov`
        public let path: String
    }
}

extension Paths.Orders.V3.Lov {
    public var orderManagementReadyMarketplaceBusinessCode: OrderManagementReadyMarketplaceBusinessCode {
        OrderManagementReadyMarketplaceBusinessCode(path: path + "/orderManagementReadyMarketplaceBusinessCode")
    }

    public struct OrderManagementReadyMarketplaceBusinessCode {
        /// Path: `/orders/v3/lov/orderManagementReadyMarketplaceBusinessCode`
        public let path: String

        /// Get the list of MarketplaceBusinessCode ready for Order Management
        public func get(storeIDs: [String]? = nil) -> Request<[BeezUPAPI.ListOfValueItem]> {
            .get(path, query: makeGetQuery(storeIDs))
        }

        private func makeGetQuery(_ storeIDs: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(storeIDs, forKey: "storeIds", explode: false)
            return encoder.items
        }
    }
}

extension Paths.Orders.V3 {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/orders/v3/status`
        public let path: String

        /// Get current synchronization status between your marketplaces and BeezUP accounts
        public func get(storeIDs: [String]? = nil) -> Request<BeezUPAPI.AccountSynchronizationList> {
            .get(path, query: makeGetQuery(storeIDs))
        }

        private func makeGetQuery(_ storeIDs: [String]?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(storeIDs, forKey: "storeIds", explode: false)
            return encoder.items
        }
    }
}

extension Paths.Orders.V3 {
    public var harvest: Harvest {
        Harvest(path: path + "/harvest")
    }

    public struct Harvest {
        /// Path: `/orders/v3/harvest`
        public let path: String

        /// Send harvest request to all your marketplaces
        public func post(storeID: String? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(storeID))
        }

        public enum PostResponseHeaders {
            /// Indicates the duration in seconds to wait to be able to make this request again
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }

        private func makePostQuery(_ storeID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(storeID, forKey: "storeId")
            return encoder.items
        }
    }
}

extension Paths.Orders.V3 {
    public var list: List {
        List(path: path + "/list")
    }

    public struct List {
        /// Path: `/orders/v3/list`
        public let path: String
    }
}

extension Paths.Orders.V3.List {
    public var full: Full {
        Full(path: path + "/full")
    }

    public struct Full {
        /// Path: `/orders/v3/list/full`
        public let path: String

        /// Get a paginated list of all Orders with all Order and Order Item(s) properties
        ///
        /// The purpose of this operation is to reduce the amount of request to the API.\
        /// \
        /// Previous implmentation of this feature only returned a partial (light) version of the Orders. The purpose of this API is to reduce the number of incoming requests by returning the complete (full) Order and Order Item(s) properties.
        public func post(_ body: BeezUPAPI.OrderListRequest) -> Request<BeezUPAPI.OrderListFullWithLinks> {
            .post(path, body: body)
        }
    }
}

extension Paths.Orders.V3.List {
    public var light: Light {
        Light(path: path + "/light")
    }

    public struct Light {
        /// Path: `/orders/v3/list/light`
        public let path: String

        /// Get a paginated list of all Orders without details
        public func post(_ body: BeezUPAPI.OrderListRequest) -> Request<BeezUPAPI.OrderListLightWithLinks> {
            .post(path, body: body)
        }
    }
}

extension Paths.Orders.V3 {
    public func marketplaceTechnicalCode(_ marketplaceTechnicalCode: String) -> WithMarketplaceTechnicalCode {
        WithMarketplaceTechnicalCode(path: "\(path)/\(marketplaceTechnicalCode)")
    }

    public struct WithMarketplaceTechnicalCode {
        /// Path: `/orders/v3/{marketplaceTechnicalCode}`
        public let path: String
    }
}

extension Paths.Orders.V3.WithMarketplaceTechnicalCode {
    public func accountID(_ accountID: Int) -> WithAccountID {
        WithAccountID(path: "\(path)/\(accountID)")
    }

    public struct WithAccountID {
        /// Path: `/orders/v3/{marketplaceTechnicalCode}/{accountId}`
        public let path: String
    }
}

extension Paths.Orders.V3.WithMarketplaceTechnicalCode.WithAccountID {
    public func beezUPOrderID(_ beezUPOrderID: String) -> WithBeezUPOrderID {
        WithBeezUPOrderID(path: "\(path)/\(beezUPOrderID)")
    }

    public struct WithBeezUPOrderID {
        /// Path: `/orders/v3/{marketplaceTechnicalCode}/{accountId}/{beezUPOrderId}`
        public let path: String

        /// Get full Order and Order Item(s) properties
        public var get: Request<BeezUPAPI.OrderWithLinks> {
            .get(path)
        }

        public enum GetResponseHeaders {
            /// ETag value to identify the current version of requested Order\
            /// For more details go to this link: http://tools.ietf.org/html/rfc7232#section-2.3
            public static let eTag = HTTPHeader<String>(field: "ETag")
            /// Last modification UTC date of the order\
            /// For more details go to this link: https://tools.ietf.org/html/rfc7232#section-2.2
            public static let lastModified = HTTPHeader<Date>(field: "Last-Modified")
        }

        /// Get the meta information about the order (ETag, Last-Modified)
        ///
        /// The purpose of this operation is to reduce the bandwith usage by getting just the meta information about the order (ETag, Last-Modified) with the body.
        /// This could be useful
        public var head: Request<Void> {
            .head(path)
        }

        public enum HeadResponseHeaders {
            /// ETag value to identify the current version of requested Order\
            /// For more details go to this link: http://tools.ietf.org/html/rfc7232#section-2.3
            public static let eTag = HTTPHeader<String>(field: "ETag")
            /// Last modification UTC date of the order\
            /// For more details go to this link: https://tools.ietf.org/html/rfc7232#section-2.2
            public static let lastModified = HTTPHeader<Date>(field: "Last-Modified")
        }
    }
}

extension Paths.Orders.V3.WithMarketplaceTechnicalCode.WithAccountID.WithBeezUPOrderID {
    public func changeOrderType(_ changeOrderType: String) -> WithChangeOrderType {
        WithChangeOrderType(path: "\(path)/\(changeOrderType)")
    }

    public struct WithChangeOrderType {
        /// Path: `/orders/v3/{marketplaceTechnicalCode}/{accountId}/{beezUPOrderId}/{changeOrderType}`
        public let path: String

        /// Change your marketplace Order Information (accept, ship, etc.)
        public func post(userName: String, isTestMode: Bool? = nil, _ body: [String: String]? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(userName, isTestMode), body: body)
        }

        public enum PostResponseHeaders {
            /// Indicate the address you should follow to know the status of your order change operation
            public static let location = HTTPHeader<String>(field: "Location")
        }

        private func makePostQuery(_ userName: String, _ isTestMode: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userName, forKey: "userName")
            encoder.encode(isTestMode, forKey: "testMode")
            return encoder.items
        }
    }
}

extension Paths.Orders.V3.WithMarketplaceTechnicalCode.WithAccountID.WithBeezUPOrderID {
    public var history: History {
        History(path: path + "/history")
    }

    public struct History {
        /// Path: `/orders/v3/{marketplaceTechnicalCode}/{accountId}/{beezUPOrderId}/history`
        public let path: String

        /// Get an Order's harvest and change history
        public var get: Request<BeezUPAPI.OrderHistory> {
            .get(path)
        }
    }
}

extension Paths.Orders.V3.WithMarketplaceTechnicalCode.WithAccountID.WithBeezUPOrderID {
    public var harvest: Harvest {
        Harvest(path: path + "/harvest")
    }

    public struct Harvest {
        /// Path: `/orders/v3/{marketplaceTechnicalCode}/{accountId}/{beezUPOrderId}/harvest`
        public let path: String

        /// Send harvest request for a single Order
        public var post: Request<Void> {
            .post(path)
        }

        public enum PostResponseHeaders {
            /// Indicates the duration in seconds to wait to be able to make this request again
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }
    }
}

extension Paths.Orders.V3.WithMarketplaceTechnicalCode.WithAccountID {
    public var harvest: Harvest {
        Harvest(path: path + "/harvest")
    }

    public struct Harvest {
        /// Path: `/orders/v3/{marketplaceTechnicalCode}/{accountId}/harvest`
        public let path: String

        /// Send harvest request for an Account
        public func post(marketplaceOrderID: String? = nil, beezUPOrderID: String? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(marketplaceOrderID, beezUPOrderID))
        }

        public enum PostResponseHeaders {
            /// Indicates the duration in seconds to wait to be able to make this request again
            public static let retryAfter = HTTPHeader<Int>(field: "Retry-After")
        }

        private func makePostQuery(_ marketplaceOrderID: String?, _ beezUPOrderID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(marketplaceOrderID, forKey: "marketplaceOrderId")
            encoder.encode(beezUPOrderID, forKey: "beezUPOrderId")
            return encoder.items
        }
    }
}

extension Paths.Orders.V3.WithMarketplaceTechnicalCode.WithAccountID.WithBeezUPOrderID.History {
    public func orderChangeExecutionUUID(_ orderChangeExecutionUUID: String) -> WithOrderChangeExecutionUUID {
        WithOrderChangeExecutionUUID(path: "\(path)/\(orderChangeExecutionUUID)")
    }

    public struct WithOrderChangeExecutionUUID {
        /// Path: `/orders/v3/{marketplaceTechnicalCode}/{accountId}/{beezUPOrderId}/history/{orderChangeExecutionUUID}`
        public let path: String

        /// Get the order change reporting
        ///
        /// This operation will help you to know the status of your order change operation
        public var get: Request<BeezUPAPI.ChangeOrderReporting> {
            .get(path)
        }
    }
}

extension Paths.Orders.V3.WithMarketplaceTechnicalCode.WithAccountID.WithBeezUPOrderID {
    public var setMerchantOrderInfo: SetMerchantOrderInfo {
        SetMerchantOrderInfo(path: path + "/setMerchantOrderInfo")
    }

    public struct SetMerchantOrderInfo {
        /// Path: `/orders/v3/{marketplaceTechnicalCode}/{accountId}/{beezUPOrderId}/setMerchantOrderInfo`
        public let path: String

        /// Set an Order's merchant information
        public func post(isTestMode: Bool? = nil, _ body: BeezUPAPI.SetMerchantOrderInfoRequest) -> Request<Void> {
            .post(path, query: makePostQuery(isTestMode), body: body)
        }

        private func makePostQuery(_ isTestMode: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isTestMode, forKey: "testMode")
            return encoder.items
        }
    }
}

extension Paths.Orders.V3.WithMarketplaceTechnicalCode.WithAccountID.WithBeezUPOrderID {
    public var clearMerchantOrderInfo: ClearMerchantOrderInfo {
        ClearMerchantOrderInfo(path: path + "/clearMerchantOrderInfo")
    }

    public struct ClearMerchantOrderInfo {
        /// Path: `/orders/v3/{marketplaceTechnicalCode}/{accountId}/{beezUPOrderId}/clearMerchantOrderInfo`
        public let path: String

        /// Clear an Order's merchant information
        public func post(isTestMode: Bool? = nil) -> Request<Void> {
            .post(path, query: makePostQuery(isTestMode))
        }

        private func makePostQuery(_ isTestMode: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isTestMode, forKey: "testMode")
            return encoder.items
        }
    }
}

extension Paths.Orders.V3 {
    public var batches: Batches {
        Batches(path: path + "/batches")
    }

    public struct Batches {
        /// Path: `/orders/v3/batches`
        public let path: String
    }
}

extension Paths.Orders.V3.Batches {
    public var setMerchantOrderInfos: SetMerchantOrderInfos {
        SetMerchantOrderInfos(path: path + "/setMerchantOrderInfos")
    }

    public struct SetMerchantOrderInfos {
        /// Path: `/orders/v3/batches/setMerchantOrderInfos`
        public let path: String

        /// Send a batch of operations to set an Order's merchant information  (max 100 items per call)
        ///
        /// The purpose of this operation is to reduce the amount of request to the API.
        public func post(isTestMode: Bool? = nil, _ body: BeezUPAPI.SetMerchantOrderInfoListRequest) -> Request<BeezUPAPI.BatchOrderOperationResponse> {
            .post(path, query: makePostQuery(isTestMode), body: body)
        }

        private func makePostQuery(_ isTestMode: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isTestMode, forKey: "testMode")
            return encoder.items
        }
    }
}

extension Paths.Orders.V3.Batches {
    public var clearMerchantOrderInfos: ClearMerchantOrderInfos {
        ClearMerchantOrderInfos(path: path + "/clearMerchantOrderInfos")
    }

    public struct ClearMerchantOrderInfos {
        /// Path: `/orders/v3/batches/clearMerchantOrderInfos`
        public let path: String

        /// Send a batch of operations to clear an Order's merchant information (max 100 items per call)
        ///
        /// The purpose of this operation is to reduce the amount of request to the API.
        public func post(isTestMode: Bool? = nil, _ body: BeezUPAPI.ClearMerchantOrderInfoListRequest) -> Request<BeezUPAPI.BatchOrderOperationResponse> {
            .post(path, query: makePostQuery(isTestMode), body: body)
        }

        private func makePostQuery(_ isTestMode: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isTestMode, forKey: "testMode")
            return encoder.items
        }
    }
}

extension Paths.Orders.V3.Batches.ChangeOrders {
    public func changeOrderType(_ changeOrderType: String) -> WithChangeOrderType {
        WithChangeOrderType(path: "\(path)/\(changeOrderType)")
    }

    public struct WithChangeOrderType {
        /// Path: `/orders/v3/batches/changeOrders/{changeOrderType}`
        public let path: String

        /// Send a batch of operations to change your marketplace Order information: accept, ship, etc.  (max 100 items per call)
        ///
        /// The purpose of this operation is to reduce the amount of request to the API. 
        /// Max 100 items per call.
        public func post(userName: String, isTestMode: Bool? = nil, _ body: BeezUPAPI.ChangeOrderListRequestV2) -> Request<BeezUPAPI.BatchOrderOperationResponse> {
            .post(path, query: makePostQuery(userName, isTestMode), body: body)
        }

        private func makePostQuery(_ userName: String, _ isTestMode: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userName, forKey: "userName")
            encoder.encode(isTestMode, forKey: "testMode")
            return encoder.items
        }
    }
}

extension Paths.Orders.V3.Batches {
    public var changeOrders: ChangeOrders {
        ChangeOrders(path: path + "/changeOrders")
    }

    public struct ChangeOrders {
        /// Path: `/orders/v3/batches/changeOrders`
        public let path: String

        /// Send a batch of operations to change your marketplace Order information: accept, ship, etc.  (max 100 items per call)
        ///
        /// The purpose of this operation is to reduce the amount of request to the API. 
        /// Max 100 items per call.
        public func post(userName: String, isTestMode: Bool? = nil, _ body: BeezUPAPI.ChangeOrderListRequest) -> Request<BeezUPAPI.BatchOrderOperationResponse> {
            .post(path, query: makePostQuery(userName, isTestMode), body: body)
        }

        private func makePostQuery(_ userName: String, _ isTestMode: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(userName, forKey: "userName")
            encoder.encode(isTestMode, forKey: "testMode")
            return encoder.items
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders {
    public var subscriptions: Subscriptions {
        Subscriptions(path: path + "/subscriptions")
    }

    public struct Subscriptions {
        /// Path: `/v2/user/marketplaces/orders/subscriptions`
        public let path: String

        /// Get the subscription list
        public var get: Request<[BeezUPAPI.SubscriptionIndex]> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders.Subscriptions {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/v2/user/marketplaces/orders/subscriptions/{id}`
        public let path: String

        /// Get a subscription to the orders
        public var get: Request<BeezUPAPI.SubscriptionIndex> {
            .get(path)
        }

        /// Creates a subscription to the orders
        ///
        /// Please take a look at this sequence diagram to understand the subscription process to follow [here](https://www.websequencediagrams.com/files/render?link=SBYbeIc8NGshk6ooCbmjoBLIMl4fIGO1xjJbPBQAglBo0n6BwEReh7NXQiPSjOTX)
        public func post(_ body: BeezUPAPI.CreateSubscriptionRequest) -> Request<Void> {
            .post(path, body: body)
        }

        /// Delete a subscription to the orders
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders.Subscriptions.WithID {
    public var reporting: Reporting {
        Reporting(path: path + "/reporting")
    }

    public struct Reporting {
        /// Path: `/v2/user/marketplaces/orders/subscriptions/{id}/reporting`
        public let path: String

        /// Get the push reporting related to this subscription
        public func get(pageNumber: Int? = nil, pageSize: Int? = nil) -> Request<[BeezUPAPI.SubscriptionPushReporting]> {
            .get(path, query: makeGetQuery(pageNumber, pageSize))
        }

        public enum GetResponseHeaders {
            /// The total item count related to this query
            public static let totalCount = HTTPHeader<Int>(field: "X-Total-Count")
            /// Based on the RFC 5988 - Web Linking, the page navigation will be indicated here with the rel=next, rel=previous, rel=first, rel=last, the pageNumber and the pageSize will be indicated in the link param
            public static let link = HTTPHeader<[String]>(field: "Link")
        }

        private func makeGetQuery(_ pageNumber: Int?, _ pageSize: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(pageNumber, forKey: "pageNumber")
            encoder.encode(pageSize, forKey: "pageSize")
            return encoder.items
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders.Subscriptions.WithID {
    public var activate: Activate {
        Activate(path: path + "/activate")
    }

    public struct Activate {
        /// Path: `/v2/user/marketplaces/orders/subscriptions/{id}/activate`
        public let path: String

        /// Activate a subscription to the orders
        ///
        /// At this moment, BeezUP will ensure that your callback url is respecting this specification: 
        /// - https://app.swaggerhub.com/apis/BeezUP/public_marketplaces_orders_subscriptions_consumer-dev/1.0#/Subscriptions/Verification
        /// 
        /// After that we will send you the orders related to your subscription, respecting this specification: 
        /// - https://app.swaggerhub.com/apis/BeezUP/public_marketplaces_orders_subscriptions_consumer-dev/1.0#/Subscriptions/PushOrders
        public func post(_ body: BeezUPAPI.ActivateSubscriptionRequest? = nil) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders.Subscriptions.WithID {
    public var deactivate: Deactivate {
        Deactivate(path: path + "/deactivate")
    }

    public struct Deactivate {
        /// Path: `/v2/user/marketplaces/orders/subscriptions/{id}/deactivate`
        public let path: String

        /// Deactivate a subscription to the orders
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders.Subscriptions.WithID {
    public var retry: Retry {
        Retry(path: path + "/retry")
    }

    public struct Retry {
        /// Path: `/v2/user/marketplaces/orders/subscriptions/{id}/retry`
        public let path: String

        /// Force retry push orders immediatly
        ///
        /// In case your subscription consumption is unavailable and your subscription is still active you can ask to retry immediatly to push orders instead of waiting the next scheduled retry date
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders {
    public var invoices: Invoices {
        Invoices(path: path + "/invoices")
    }

    public struct Invoices {
        /// Path: `/v2/user/marketplaces/orders/invoices`
        public let path: String
    }
}

extension Paths.V2.User.Marketplaces.Orders.Invoices {
    public var settings: Settings {
        Settings(path: path + "/settings")
    }

    public struct Settings {
        /// Path: `/v2/user/marketplaces/orders/invoices/settings`
        public let path: String
    }
}

extension Paths.V2.User.Marketplaces.Orders.Invoices.Settings {
    public var general: General {
        General(path: path + "/general")
    }

    public struct General {
        /// Path: `/v2/user/marketplaces/orders/invoices/settings/general`
        public let path: String

        /// Get Order Invoice general settings
        public var get: Request<BeezUPAPI.GetOrderInvoiceGeneralSettingsResponse> {
            .get(path)
        }

        /// Save Order Invoice general settings
        public func put(_ body: BeezUPAPI.OrderInvoiceGeneralSettings) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders.Invoices.Settings {
    public var design: Design {
        Design(path: path + "/design")
    }

    public struct Design {
        /// Path: `/v2/user/marketplaces/orders/invoices/settings/design`
        public let path: String

        /// Get Order Invoice design settings
        public var get: Request<BeezUPAPI.OrderInvoiceDesignSettings> {
            .get(path)
        }

        /// Save Order Invoice design settings
        public func put(_ body: BeezUPAPI.OrderInvoiceDesignSettings) -> Request<Void> {
            .put(path, body: body)
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders.Invoices.Settings.Design {
    public var preview: Preview {
        Preview(path: path + "/preview")
    }

    public struct Preview {
        /// Path: `/v2/user/marketplaces/orders/invoices/settings/design/preview`
        public let path: String

        /// View a preview an Order Invoice using custom design settings
        public func post(_ body: BeezUPAPI.OrderInvoiceDesignSettings) -> Request<BeezUPAPI.GetOrderInvoiceDesignPreviewResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders.Invoices {
    public func marketplaceTechnicalCode(_ marketplaceTechnicalCode: String) -> WithMarketplaceTechnicalCode {
        WithMarketplaceTechnicalCode(path: "\(path)/\(marketplaceTechnicalCode)")
    }

    public struct WithMarketplaceTechnicalCode {
        /// Path: `/v2/user/marketplaces/orders/invoices/{marketplaceTechnicalCode}`
        public let path: String
    }
}

extension Paths.V2.User.Marketplaces.Orders.Invoices.WithMarketplaceTechnicalCode {
    public func accountID(_ accountID: String) -> WithAccountID {
        WithAccountID(path: "\(path)/\(accountID)")
    }

    public struct WithAccountID {
        /// Path: `/v2/user/marketplaces/orders/invoices/{marketplaceTechnicalCode}/{accountId}`
        public let path: String
    }
}

extension Paths.V2.User.Marketplaces.Orders.Invoices.WithMarketplaceTechnicalCode.WithAccountID {
    public func beezUPOrderUUID(_ beezUPOrderUUID: String) -> WithBeezUPOrderUUID {
        WithBeezUPOrderUUID(path: "\(path)/\(beezUPOrderUUID)")
    }

    public struct WithBeezUPOrderUUID {
        /// Path: `/v2/user/marketplaces/orders/invoices/{marketplaceTechnicalCode}/{accountId}/{beezUPOrderUUID}`
        public let path: String
    }
}

extension Paths.V2.User.Marketplaces.Orders.Invoices.WithMarketplaceTechnicalCode.WithAccountID.WithBeezUPOrderUUID {
    public var generate: Generate {
        Generate(path: path + "/generate")
    }

    public struct Generate {
        /// Path: `/v2/user/marketplaces/orders/invoices/{marketplaceTechnicalCode}/{accountId}/{beezUPOrderUUID}/generate`
        public let path: String

        /// Generate an Order Invoice
        public func post(userName: String, _ body: BeezUPAPI.GenerateOrderInvoiceRequest) -> Request<Void> {
            .post(path, query: [("userName", userName)], body: body)
        }

        public enum PostResponseHeaders {
            /// The location of the generated invoice. Might take a few seconds to be available
            public static let location = HTTPHeader<String>(field: "Location")
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders.Invoices.WithMarketplaceTechnicalCode.WithAccountID.WithBeezUPOrderUUID {
    public var preview: Preview {
        Preview(path: path + "/preview")
    }

    public struct Preview {
        /// Path: `/v2/user/marketplaces/orders/invoices/{marketplaceTechnicalCode}/{accountId}/{beezUPOrderUUID}/preview`
        public let path: String

        /// View a preview an Order Invoice
        public func post(_ body: BeezUPAPI.PreviewOrderInvoiceRequest) -> Request<BeezUPAPI.PreviewOrderInvoiceResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Marketplaces.Orders.Invoices {
    public var getPdfInvoice: GetPdfInvoice {
        GetPdfInvoice(path: path + "/getPdfInvoice")
    }

    public struct GetPdfInvoice {
        /// Path: `/v2/user/marketplaces/orders/invoices/getPdfInvoice`
        public let path: String

        /// Returns the PDF version of the invoice
        public func post(_ body: BeezUPAPI.GetOrderInvoicePdfFromHTMLInvoiceURLRequest) -> Request<Data> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User {
    public var analytics: Analytics {
        Analytics(path: path + "/analytics")
    }

    public struct Analytics {
        /// Path: `/v2/user/analytics`
        public let path: String

        /// Get the Analytics API operation index
        public var get: Request<BeezUPAPI.AnalyticsIndex> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Analytics {
    public func storeID(_ storeID: String) -> WithStoreID {
        WithStoreID(path: "\(path)/\(storeID)")
    }

    public struct WithStoreID {
        /// Path: `/v2/user/analytics/{storeId}`
        public let path: String

        /// Get the Analytics API operation index for one store
        public var get: Request<BeezUPAPI.AnalyticsStoreIndex> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Analytics {
    public var tracking: Tracking {
        Tracking(path: path + "/tracking")
    }

    public struct Tracking {
        /// Path: `/v2/user/analytics/tracking`
        public let path: String
    }
}

extension Paths.V2.User.Analytics.Tracking {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/v2/user/analytics/tracking/status`
        public let path: String

        /// Get the global synchronization status of clicks and orders
        ///
        /// Clicks and orders are eventually consistent. \
        /// This operation gets the current global state of projections.
        public var get: Request<BeezUPAPI.TrackingStatus> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID {
    public var tracking: Tracking {
        Tracking(path: path + "/tracking")
    }

    public struct Tracking {
        /// Path: `/v2/user/analytics/{storeId}/tracking`
        public let path: String
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Tracking {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/v2/user/analytics/{storeId}/tracking/status`
        public let path: String

        /// Get the synchronization status of clicks and orders of a store
        ///
        /// Clicks and orders are eventually consistent. \
        /// This operation gets the current state of projections for a store.
        public var get: Request<BeezUPAPI.StoreTrackingStatus> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Tracking {
    public var clicks: Clicks {
        Clicks(path: path + "/clicks")
    }

    public struct Clicks {
        /// Path: `/v2/user/analytics/{storeId}/tracking/clicks`
        public let path: String

        /// Get the latest tracked clicks
        public func get(count: Int? = nil) -> Request<BeezUPAPI.TrackedClicks> {
            .get(path, query: makeGetQuery(count))
        }

        private func makeGetQuery(_ count: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(count, forKey: "count")
            return encoder.items
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Tracking {
    public var orders: Orders {
        Orders(path: path + "/orders")
    }

    public struct Orders {
        /// Path: `/v2/user/analytics/{storeId}/tracking/orders`
        public let path: String

        /// Get the latest tracked orders
        public func get(count: Int? = nil) -> Request<BeezUPAPI.TrackedOrders> {
            .get(path, query: makeGetQuery(count))
        }

        private func makeGetQuery(_ count: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(count, forKey: "count")
            return encoder.items
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Tracking {
    public var externalorders: Externalorders {
        Externalorders(path: path + "/externalorders")
    }

    public struct Externalorders {
        /// Path: `/v2/user/analytics/{storeId}/tracking/externalorders`
        public let path: String

        /// Get the latest tracked external orders
        public func get(count: Int? = nil) -> Request<BeezUPAPI.TrackedExternalOrders> {
            .get(path, query: makeGetQuery(count))
        }

        private func makeGetQuery(_ count: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(count, forKey: "count")
            return encoder.items
        }
    }
}

extension Paths.V2.User.Analytics {
    public var reports: Reports {
        Reports(path: path + "/reports")
    }

    public struct Reports {
        /// Path: `/v2/user/analytics/reports`
        public let path: String
    }
}

extension Paths.V2.User.Analytics.Reports {
    public var byday: Byday {
        Byday(path: path + "/byday")
    }

    public struct Byday {
        /// Path: `/v2/user/analytics/reports/byday`
        public let path: String

        /// Get the report by day for a StoreId
        public func post(_ body: BeezUPAPI.ReportByDayRequest) -> Request<[String: BeezUPAPI.ReportByDayResponse]> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID {
    public var reports: Reports {
        Reports(path: path + "/reports")
    }

    public struct Reports {
        /// Path: `/v2/user/analytics/{storeId}/reports`
        public let path: String
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Reports {
    public var byday: Byday {
        Byday(path: path + "/byday")
    }

    public struct Byday {
        /// Path: `/v2/user/analytics/{storeId}/reports/byday`
        public let path: String

        /// Get the report by day for a StoreId
        public func post(_ body: BeezUPAPI.ReportByDayRequest) -> Request<BeezUPAPI.ReportByDayResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Reports {
    public var bychannel: Bychannel {
        Bychannel(path: path + "/bychannel")
    }

    public struct Bychannel {
        /// Path: `/v2/user/analytics/{storeId}/reports/bychannel`
        public let path: String

        /// Get the report by channel
        public func post(_ body: BeezUPAPI.ReportByChannelRequest) -> Request<BeezUPAPI.ReportByChannelResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Reports {
    public var bycategory: Bycategory {
        Bycategory(path: path + "/bycategory")
    }

    public struct Bycategory {
        /// Path: `/v2/user/analytics/{storeId}/reports/bycategory`
        public let path: String

        /// Get the report by category
        public func post(_ body: BeezUPAPI.ReportByCategoryRequest) -> Request<BeezUPAPI.ReportByCategoryResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Reports {
    public var byproduct: Byproduct {
        Byproduct(path: path + "/byproduct")
    }

    public struct Byproduct {
        /// Path: `/v2/user/analytics/{storeId}/reports/byproduct`
        public let path: String

        /// Get the report by product
        public func post(_ body: BeezUPAPI.ReportByProductRequest) -> Request<BeezUPAPI.ReportByProductResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID {
    public var optimisations: Optimisations {
        Optimisations(path: path + "/optimisations")
    }

    public struct Optimisations {
        /// Path: `/v2/user/analytics/{storeId}/optimisations`
        public let path: String
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Optimisations {
    public var all: All {
        All(path: path + "/all")
    }

    public struct All {
        /// Path: `/v2/user/analytics/{storeId}/optimisations/all`
        public let path: String
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Optimisations.All {
    public func actionName(_ actionName: String) -> WithActionName {
        WithActionName(path: "\(path)/\(actionName)")
    }

    public struct WithActionName {
        /// Path: `/v2/user/analytics/{storeId}/optimisations/all/{actionName}`
        public let path: String

        /// Optimise all products
        ///
        /// /!\ WARNING /!\ \
        /// Apply the operation on every product related to this request. \
        /// This operation is used at the bottom of the analytics page result.
        public func post(_ body: BeezUPAPI.OptimiseAllRequest) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Optimisations {
    public func actionName(_ actionName: String) -> WithActionName {
        WithActionName(path: "\(path)/\(actionName)")
    }

    public struct WithActionName {
        /// Path: `/v2/user/analytics/{storeId}/optimisations/{actionName}`
        public let path: String

        /// Optimise products by page
        ///
        /// /!\ WARNING /!\ \
        /// Apply the operation on every product related to this request. \
        /// This operation is used at the bottom of the analytics page result.
        public func post(_ body: BeezUPAPI.OptimiseRequest) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Optimisations {
    public var bychannel: Bychannel {
        Bychannel(path: path + "/bychannel")
    }

    public struct Bychannel {
        /// Path: `/v2/user/analytics/{storeId}/optimisations/bychannel`
        public let path: String
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Optimisations.Bychannel {
    public func channelID(_ channelID: String) -> WithChannelID {
        WithChannelID(path: "\(path)/\(channelID)")
    }

    public struct WithChannelID {
        /// Path: `/v2/user/analytics/{storeId}/optimisations/bychannel/{channelId}`
        public let path: String
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Optimisations.Bychannel.WithChannelID {
    public func actionName(_ actionName: String) -> WithActionName {
        WithActionName(path: "\(path)/\(actionName)")
    }

    public struct WithActionName {
        /// Path: `/v2/user/analytics/{storeId}/optimisations/bychannel/{channelId}/{actionName}`
        public let path: String

        /// Optimise products by channel
        ///
        /// /!\ WARNING /!\ \
        /// Apply the operation on every product on this channel.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Optimisations {
    public var bycategory: Bycategory {
        Bycategory(path: path + "/bycategory")
    }

    public struct Bycategory {
        /// Path: `/v2/user/analytics/{storeId}/optimisations/bycategory`
        public let path: String
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Optimisations.Bycategory {
    public func catalogCategoryID(_ catalogCategoryID: String) -> WithCatalogCategoryID {
        WithCatalogCategoryID(path: "\(path)/\(catalogCategoryID)")
    }

    public struct WithCatalogCategoryID {
        /// Path: `/v2/user/analytics/{storeId}/optimisations/bycategory/{catalogCategoryId}`
        public let path: String
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Optimisations.Bycategory.WithCatalogCategoryID {
    public func actionName(_ actionName: String) -> WithActionName {
        WithActionName(path: "\(path)/\(actionName)")
    }

    public struct WithActionName {
        /// Path: `/v2/user/analytics/{storeId}/optimisations/bycategory/{catalogCategoryId}/{actionName}`
        public let path: String

        /// Optimise products by category
        ///
        /// /!\ WARNING /!\ \
        /// This operation will reenable or disable products's category for every channel indicated in the body.
        public func post(_ body: [String]? = nil) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Optimisations {
    public var byproduct: Byproduct {
        Byproduct(path: path + "/byproduct")
    }

    public struct Byproduct {
        /// Path: `/v2/user/analytics/{storeId}/optimisations/byproduct`
        public let path: String
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Optimisations.Byproduct {
    public func productID(_ productID: String) -> WithProductID {
        WithProductID(path: "\(path)/\(productID)")
    }

    public struct WithProductID {
        /// Path: `/v2/user/analytics/{storeId}/optimisations/byproduct/{productId}`
        public let path: String
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Optimisations.Byproduct.WithProductID {
    public func actionName(_ actionName: String) -> WithActionName {
        WithActionName(path: "\(path)/\(actionName)")
    }

    public struct WithActionName {
        /// Path: `/v2/user/analytics/{storeId}/optimisations/byproduct/{productId}/{actionName}`
        public let path: String

        /// Optimise product
        ///
        /// /!\ WARNING /!\ \
        /// This operation will reenable or disable this product for every channel indicated in the body.
        public func post(_ body: [String]? = nil) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Optimisations {
    public var copy: Copy {
        Copy(path: path + "/copy")
    }

    public struct Copy {
        /// Path: `/v2/user/analytics/{storeId}/optimisations/copy`
        public let path: String

        /// Copy product optimisations between 2 channels
        public func post(_ body: BeezUPAPI.CopyOptimisationRequest) -> Request<BeezUPAPI.CopyOptimisationResponse> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Reports {
    public var filters: Filters {
        Filters(path: path + "/filters")
    }

    public struct Filters {
        /// Path: `/v2/user/analytics/{storeId}/reports/filters`
        public let path: String

        /// Get report filter list for the given store
        public var get: Request<BeezUPAPI.ReportFilterList> {
            .get(path)
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Reports.Filters {
    public func reportFilterID(_ reportFilterID: String) -> WithReportFilterID {
        WithReportFilterID(path: "\(path)/\(reportFilterID)")
    }

    public struct WithReportFilterID {
        /// Path: `/v2/user/analytics/{storeId}/reports/filters/{reportFilterId}`
        public let path: String

        /// Get the report filter description
        public var get: Request<BeezUPAPI.ReportFilter> {
            .get(path)
        }

        /// Save the report filter
        public func put(_ body: BeezUPAPI.SaveReportFilterRequest) -> Request<Void> {
            .put(path, body: body)
        }

        /// Delete the report filter
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID {
    public var rules: Rules {
        Rules(path: path + "/rules")
    }

    public struct Rules {
        /// Path: `/v2/user/analytics/{storeId}/rules`
        public let path: String

        /// Gets the list of rules for a given store
        public var get: Request<BeezUPAPI.RuleList> {
            .get(path)
        }

        /// Rule creation
        public func post(_ body: BeezUPAPI.CreateRuleRequest) -> Request<Void> {
            .post(path, body: body)
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Rules {
    public func ruleID(_ ruleID: String) -> WithRuleID {
        WithRuleID(path: "\(path)/\(ruleID)")
    }

    public struct WithRuleID {
        /// Path: `/v2/user/analytics/{storeId}/rules/{ruleId}`
        public let path: String

        /// Gets the rule
        public var get: Request<BeezUPAPI.Rule> {
            .get(path)
        }

        /// Update Rule
        public func patch(_ body: BeezUPAPI.UpdateRuleRequest) -> Request<Void> {
            .patch(path, body: body)
        }

        /// Delete Rule
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Rules.WithRuleID {
    public var moveup: Moveup {
        Moveup(path: path + "/moveup")
    }

    public struct Moveup {
        /// Path: `/v2/user/analytics/{storeId}/rules/{ruleId}/moveup`
        public let path: String

        /// Move the rule up
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Rules.WithRuleID {
    public var movedown: Movedown {
        Movedown(path: path + "/movedown")
    }

    public struct Movedown {
        /// Path: `/v2/user/analytics/{storeId}/rules/{ruleId}/movedown`
        public let path: String

        /// Move the rule down
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Rules.WithRuleID {
    public var enable: Enable {
        Enable(path: path + "/enable")
    }

    public struct Enable {
        /// Path: `/v2/user/analytics/{storeId}/rules/{ruleId}/enable`
        public let path: String

        /// Enable rule
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Rules.WithRuleID {
    public var disable: Disable {
        Disable(path: path + "/disable")
    }

    public struct Disable {
        /// Path: `/v2/user/analytics/{storeId}/rules/{ruleId}/disable`
        public let path: String

        /// Disable rule
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Rules {
    public var run: Run {
        Run(path: path + "/run")
    }

    public struct Run {
        /// Path: `/v2/user/analytics/{storeId}/rules/run`
        public let path: String

        /// Run all rules for this store
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Rules.WithRuleID {
    public var run: Run {
        Run(path: path + "/run")
    }

    public struct Run {
        /// Path: `/v2/user/analytics/{storeId}/rules/{ruleId}/run`
        public let path: String

        /// Run rule
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.V2.User.Analytics.WithStoreID.Rules {
    public var executions: Executions {
        Executions(path: path + "/executions")
    }

    public struct Executions {
        /// Path: `/v2/user/analytics/{storeId}/rules/executions`
        public let path: String

        /// Get the rules execution history
        public func get(pageNumber: Int, pageSize: Int) -> Request<BeezUPAPI.RuleExecutionReportings> {
            .get(path, query: makeGetQuery(pageNumber, pageSize))
        }

        private func makeGetQuery(_ pageNumber: Int, _ pageSize: Int) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(pageNumber, forKey: "pageNumber")
            encoder.encode(pageSize, forKey: "pageSize")
            return encoder.items
        }
    }
}

extension Paths.V2.User {
    public var legacyTracking: LegacyTracking {
        LegacyTracking(path: path + "/legacyTracking")
    }

    public struct LegacyTracking {
        /// Path: `/v2/user/legacyTracking`
        public let path: String
    }
}

extension Paths.V2.User.LegacyTracking {
    public var channelCatalogs: ChannelCatalogs {
        ChannelCatalogs(path: path + "/channelCatalogs")
    }

    public struct ChannelCatalogs {
        /// Path: `/v2/user/legacyTracking/channelCatalogs`
        public let path: String

        /// List all your current channel catalogs configured to use legacy tracking format
        public func get(storeID: String? = nil) -> Request<BeezUPAPI.LegacyTrackingChannelCatalogList> {
            .get(path, query: makeGetQuery(storeID))
        }

        private func makeGetQuery(_ storeID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(storeID, forKey: "storeId")
            return encoder.items
        }
    }
}

extension Paths.V2.User.LegacyTracking.ChannelCatalogs {
    public func channelCatalogID(_ channelCatalogID: String) -> WithChannelCatalogID {
        WithChannelCatalogID(path: "\(path)/\(channelCatalogID)")
    }

    public struct WithChannelCatalogID {
        /// Path: `/v2/user/legacyTracking/channelCatalogs/{channelCatalogId}`
        public let path: String

        /// Get the channel catalog configured to use legacy tracking format information
        public var get: Request<BeezUPAPI.LegacyTrackingChannelCatalog> {
            .get(path)
        }
    }
}

extension Paths.V2.User.LegacyTracking.ChannelCatalogs.WithChannelCatalogID {
    public var migrate: Migrate {
        Migrate(path: path + "/migrate")
    }

    public struct Migrate {
        /// Path: `/v2/user/legacyTracking/channelCatalogs/{channelCatalogId}/migrate`
        public let path: String

        /// Migrate a channel catalog to current tracking format
        public var post: Request<Void> {
            .post(path)
        }
    }
}

public enum Paths {}
