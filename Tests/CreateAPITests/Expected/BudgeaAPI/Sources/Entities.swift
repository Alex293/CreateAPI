// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import NaiveDate

/// Example:
///
/// {
///   "email" : null,
///   "id" : 0,
///   "id_profile" : 0,
///   "id_role" : 0,
///   "id_user" : 0
/// }
public struct Access: Codable {
    public var email: String?
    public var id: Int
    public var idProfile: Int
    public var idRole: Int?
    public var idUser: Int?

    public init(email: String? = nil, id: Int, idProfile: Int, idRole: Int? = nil, idUser: Int? = nil) {
        self.email = email
        self.id = id
        self.idProfile = idProfile
        self.idRole = idRole
        self.idUser = idUser
    }

    private enum CodingKeys: String, CodingKey {
        case email
        case id
        case idProfile = "id_profile"
        case idRole = "id_role"
        case idUser = "id_user"
    }
}

/// Example:
///
/// {
///   "balance" : 0,
///   "bookmarked" : false,
///   "coming" : 0,
///   "company_name" : null,
///   "currency" : null,
///   "deleted" : "2021-08-23 10:35:44.408402",
///   "disabled" : "2021-08-23 10:35:44.408472",
///   "display" : true,
///   "error" : null,
///   "iban" : null,
///   "id" : 0,
///   "id_connection" : 0,
///   "id_parent" : 0,
///   "id_source" : 0,
///   "id_type" : 0,
///   "id_user" : 0,
///   "last_update" : "2021-08-23 10:35:44.408324",
///   "name" : null,
///   "number" : null,
///   "opening_date" : "2021-08-23",
///   "original_name" : null,
///   "ownership" : null,
///   "usage" : null,
///   "webid" : null
/// }
public struct Account: Codable {
    /// Balance of the account
    public var balance: Double
    /// This account has been bookmarked by user
    public var bookmarked: Int
    /// Amount of coming operations not yet debited
    public var coming: Double?
    /// Name of the company holding the employee savings of the account
    public var companyName: String?
    /// Account currency
    public var currency: [String: AnyJSON]?
    /// This account is not found on the website anymore
    public var deleted: Date?
    /// This account has been deleted by user and will not be synchronized anymore
    public var disabled: Date?
    /// Display this account in accounts list
    public var isDisplay: Bool
    /// If the last update has failed, the error code
    public var error: String?
    /// Account IBAN
    public var iban: String?
    /// ID of the account
    public var id: Int
    /// ID of the related connection
    public var idConnection: Int?
    /// Id of the parent account
    public var idParent: Int?
    /// ID of the related connection source
    public var idSource: Int?
    /// ID of the account type
    public var idType: Int?
    /// ID of the related user
    public var idUser: Int?
    /// Last successful update of the account
    public var lastUpdate: Date?
    /// Name of the account
    public var name: String?
    /// Account number
    public var number: String?
    /// Opening date of the account
    public var openingDate: NaiveDate?
    /// Original name of the account on the bank
    public var originalName: String
    /// Relationship between the credentials owner and the account
    public var ownership: String?
    /// Account usage (if not set by the user, displays the value of original_usage)
    public var usage: String?
    /// Account webid
    public var webid: String?

    public init(balance: Double, bookmarked: Int, coming: Double? = nil, companyName: String? = nil, currency: [String: AnyJSON]? = nil, deleted: Date? = nil, disabled: Date? = nil, isDisplay: Bool, error: String? = nil, iban: String? = nil, id: Int, idConnection: Int? = nil, idParent: Int? = nil, idSource: Int? = nil, idType: Int? = nil, idUser: Int? = nil, lastUpdate: Date? = nil, name: String? = nil, number: String? = nil, openingDate: NaiveDate? = nil, originalName: String, ownership: String? = nil, usage: String? = nil, webid: String? = nil) {
        self.balance = balance
        self.bookmarked = bookmarked
        self.coming = coming
        self.companyName = companyName
        self.currency = currency
        self.deleted = deleted
        self.disabled = disabled
        self.isDisplay = isDisplay
        self.error = error
        self.iban = iban
        self.id = id
        self.idConnection = idConnection
        self.idParent = idParent
        self.idSource = idSource
        self.idType = idType
        self.idUser = idUser
        self.lastUpdate = lastUpdate
        self.name = name
        self.number = number
        self.openingDate = openingDate
        self.originalName = originalName
        self.ownership = ownership
        self.usage = usage
        self.webid = webid
    }

    private enum CodingKeys: String, CodingKey {
        case balance
        case bookmarked
        case coming
        case companyName = "company_name"
        case currency
        case deleted
        case disabled
        case isDisplay = "display"
        case error
        case iban
        case id
        case idConnection = "id_connection"
        case idParent = "id_parent"
        case idSource = "id_source"
        case idType = "id_type"
        case idUser = "id_user"
        case lastUpdate = "last_update"
        case name
        case number
        case openingDate = "opening_date"
        case originalName = "original_name"
        case ownership
        case usage
        case webid
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.balance = try values.decode(Double.self, forKey: .balance)
        self.bookmarked = try values.decode(Int.self, forKey: .bookmarked)
        self.coming = try values.decodeIfPresent(Double.self, forKey: .coming)
        self.companyName = try values.decodeIfPresent(String.self, forKey: .companyName)
        self.currency = try values.decodeIfPresent([String: AnyJSON].self, forKey: .currency)
        self.deleted = try values.decodeIfPresent(Date.self, forKey: .deleted)
        self.disabled = try values.decodeIfPresent(Date.self, forKey: .disabled)
        self.isDisplay = try values.decode(Bool.self, forKey: .isDisplay)
        self.error = try values.decodeIfPresent(String.self, forKey: .error)
        self.iban = try values.decodeIfPresent(String.self, forKey: .iban)
        self.id = try values.decode(Int.self, forKey: .id)
        self.idConnection = try values.decodeIfPresent(Int.self, forKey: .idConnection)
        self.idParent = try values.decodeIfPresent(Int.self, forKey: .idParent)
        self.idSource = try values.decodeIfPresent(Int.self, forKey: .idSource)
        self.idType = try values.decodeIfPresent(Int.self, forKey: .idType)
        self.idUser = try values.decodeIfPresent(Int.self, forKey: .idUser)
        self.lastUpdate = try values.decodeIfPresent(Date.self, forKey: .lastUpdate)
        self.name = try values.decodeIfPresent(String.self, forKey: .name)
        self.number = try values.decodeIfPresent(String.self, forKey: .number)
        self.openingDate = try values.decodeIfPresent(NaiveDate.self, forKey: .openingDate)
        self.originalName = try values.decode(String.self, forKey: .originalName)
        self.ownership = try values.decodeIfPresent(String.self, forKey: .ownership)
        self.usage = try values.decodeIfPresent(String.self, forKey: .usage)
        self.webid = try values.decodeIfPresent(String.self, forKey: .webid)
    }
}

/// Example:
///
/// {
///   "balance" : 0,
///   "coming" : 0,
///   "error" : null,
///   "error_message" : null,
///   "id" : 0,
///   "id_account" : 0,
///   "id_connection_log" : 0,
///   "id_connector" : 0,
///   "timestamp" : "<function datetime.now at 0x7f5740ee1950>"
/// }
public struct AccountLog: Codable {
    /// Balanced recorded
    public var balance: Double
    /// Coming debit recorded
    public var coming: Double?
    /// If fail, contains the error code
    public var error: String?
    /// If fail, error message received from bank or provider
    public var errorMessage: String?
    /// ID of the log
    public var id: Int
    /// ID of the related account
    public var idAccount: Int
    /// ID of the related connection log
    public var idConnectionLog: Int?
    /// Provider id
    public var idConnector: Int?
    /// Timestamp of log
    public var timestamp: Date

    public init(balance: Double, coming: Double? = nil, error: String? = nil, errorMessage: String? = nil, id: Int, idAccount: Int, idConnectionLog: Int? = nil, idConnector: Int? = nil, timestamp: Date) {
        self.balance = balance
        self.coming = coming
        self.error = error
        self.errorMessage = errorMessage
        self.id = id
        self.idAccount = idAccount
        self.idConnectionLog = idConnectionLog
        self.idConnector = idConnector
        self.timestamp = timestamp
    }

    private enum CodingKeys: String, CodingKey {
        case balance
        case coming
        case error
        case errorMessage = "error_message"
        case id
        case idAccount = "id_account"
        case idConnectionLog = "id_connection_log"
        case idConnector = "id_connector"
        case timestamp
    }
}

/// Example:
///
/// {
///   "color" : null,
///   "display_name" : null,
///   "display_name_p" : null,
///   "id" : 0,
///   "id_parent" : 0,
///   "is_invest" : false,
///   "name" : null,
///   "product" : null,
///   "weboob_type_id" : 0
/// }
public struct AccountType: Codable {
    /// Color of the account type (hexdecimal)
    public var color: String?
    /// Name to display in singular
    public var displayName: String
    /// Name to display in plurial
    public var displayNameP: String
    /// ID of the account type
    public var id: Int
    /// Id of the parent type
    public var idParent: Int?
    /// Is it an investment account
    public var isInvest: Bool
    /// Name of the account type
    public var name: String
    /// Product associated with the account
    public var product: String?
    /// Map to the weboob_type_id
    public var weboobTypeID: Int

    public init(color: String? = nil, displayName: String, displayNameP: String, id: Int, idParent: Int? = nil, isInvest: Bool, name: String, product: String? = nil, weboobTypeID: Int) {
        self.color = color
        self.displayName = displayName
        self.displayNameP = displayNameP
        self.id = id
        self.idParent = idParent
        self.isInvest = isInvest
        self.name = name
        self.product = product
        self.weboobTypeID = weboobTypeID
    }

    private enum CodingKeys: String, CodingKey {
        case color
        case displayName = "display_name"
        case displayNameP = "display_name_p"
        case id
        case idParent = "id_parent"
        case isInvest = "is_invest"
        case name
        case product
        case weboobTypeID = "weboob_type_id"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.color = try values.decodeIfPresent(String.self, forKey: .color)
        self.displayName = try values.decode(String.self, forKey: .displayName)
        self.displayNameP = try values.decode(String.self, forKey: .displayNameP)
        self.id = try values.decode(Int.self, forKey: .id)
        self.idParent = try values.decodeIfPresent(Int.self, forKey: .idParent)
        self.isInvest = try values.decode(Bool.self, forKey: .isInvest)
        self.name = try values.decode(String.self, forKey: .name)
        self.product = try values.decodeIfPresent(String.self, forKey: .product)
        self.weboobTypeID = try values.decode(Int.self, forKey: .weboobTypeID)
    }
}

/// Example:
///
/// {
///   "id" : 0,
///   "id_account" : 0,
///   "id_investment" : 0,
///   "id_transaction" : 0,
///   "id_user" : 0,
///   "timestamp" : "<function datetime.now at 0x7f5740d7b510>",
///   "type" : null,
///   "value" : 0
/// }
public struct Alert: Codable {
    public var id: Int
    /// ID of the related account
    public var idAccount: Int?
    /// ID of the related investment
    public var idInvestment: Int?
    /// ID of the related transaction
    public var idTransaction: Int?
    /// ID of the related user
    public var idUser: Int
    /// Date of the alerts emission
    public var timestamp: Date
    /// Type of the alert
    public var type: String
    /// Amount related to the alert
    public var value: Double

    public init(id: Int, idAccount: Int? = nil, idInvestment: Int? = nil, idTransaction: Int? = nil, idUser: Int, timestamp: Date, type: String, value: Double) {
        self.id = id
        self.idAccount = idAccount
        self.idInvestment = idInvestment
        self.idTransaction = idTransaction
        self.idUser = idUser
        self.timestamp = timestamp
        self.type = type
        self.value = value
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case idAccount = "id_account"
        case idInvestment = "id_investment"
        case idTransaction = "id_transaction"
        case idUser = "id_user"
        case timestamp
        case type
        case value
    }
}

/// Example:
///
/// {
///   "id" : 0,
///   "name" : null,
///   "type" : null
/// }
public struct AuthProvider: Codable {
    public var id: Int
    /// Name to differentiate the authentication type
    public var name: String
    /// Authentication type to use when pushing the webhook
    public var type: String

    public init(id: Int, name: String, type: String) {
        self.id = id
        self.name = name
        self.type = type
    }
}

/// Example:
///
/// {
///   "color" : null,
///   "id" : 0,
///   "id_logo" : 0,
///   "id_parent_category" : 0,
///   "id_parent_category_in_menu" : 0,
///   "id_user" : 0,
///   "income" : false,
///   "name" : null,
///   "name_displayed" : null,
///   "refundable" : false
/// }
public struct Category: Codable {
    /// Color of the category
    public var color: String
    /// ID of the category
    public var id: Int
    /// ID of the logo
    public var idLogo: Int?
    /// ID of the parent category. If this is a parent category, it will be equal to its own ID
    public var idParentCategory: Int
    /// ID of the parent category to be displayed
    public var idParentCategoryInMenu: Int
    /// If not null, this category is specific to a user
    public var idUser: Int?
    /// Is an income category. If null, this is both an income and an expense category
    public var isIncome: Bool?
    /// Name of the category
    public var name: String
    /// Displayed name, with HTML tags
    public var nameDisplayed: String?
    /// This category accepts opposite sign of transactions
    public var isRefundable: Bool

    public init(color: String, id: Int, idLogo: Int? = nil, idParentCategory: Int, idParentCategoryInMenu: Int, idUser: Int? = nil, isIncome: Bool? = nil, name: String, nameDisplayed: String? = nil, isRefundable: Bool) {
        self.color = color
        self.id = id
        self.idLogo = idLogo
        self.idParentCategory = idParentCategory
        self.idParentCategoryInMenu = idParentCategoryInMenu
        self.idUser = idUser
        self.isIncome = isIncome
        self.name = name
        self.nameDisplayed = nameDisplayed
        self.isRefundable = isRefundable
    }

    private enum CodingKeys: String, CodingKey {
        case color
        case id
        case idLogo = "id_logo"
        case idParentCategory = "id_parent_category"
        case idParentCategoryInMenu = "id_parent_category_in_menu"
        case idUser = "id_user"
        case isIncome = "income"
        case name
        case nameDisplayed = "name_displayed"
        case isRefundable = "refundable"
    }
}

/// Example:
///
/// {
///   "created" : "2021-08-23 10:35:44.254863",
///   "id" : 0,
///   "id_private_key_file" : 0,
///   "id_public_key_file" : 0,
///   "type" : null
/// }
public struct Certificate: Codable {
    public var created: Date
    public var id: Int
    public var idPrivateKeyFile: Int
    public var idPublicKeyFile: Int
    public var type: String

    public init(created: Date, id: Int, idPrivateKeyFile: Int, idPublicKeyFile: Int, type: String) {
        self.created = created
        self.id = id
        self.idPrivateKeyFile = idPrivateKeyFile
        self.idPublicKeyFile = idPublicKeyFile
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case created
        case id
        case idPrivateKeyFile = "id_private_key_file"
        case idPublicKeyFile = "id_public_key_file"
        case type
    }
}

/// Example:
///
/// {
///   "id" : 0,
///   "id_logo" : 0,
///   "name" : null,
///   "private_key" : null,
///   "pro" : false,
///   "public_key" : null,
///   "redirect_uris" : null,
///   "secret" : null
/// }
public struct Client: Codable {
    /// Customizable config
    public var config: String?
    public var id: Int
    public var idLogo: Int?
    public var name: String
    public var privateKey: String?
    /// Should the client display the company manager page.
    public var isPro: Bool
    public var publicKey: String?
    public var redirectUris: String
    public var secret: String

    public init(config: String? = nil, id: Int, idLogo: Int? = nil, name: String, privateKey: String? = nil, isPro: Bool, publicKey: String? = nil, redirectUris: String, secret: String) {
        self.config = config
        self.id = id
        self.idLogo = idLogo
        self.name = name
        self.privateKey = privateKey
        self.isPro = isPro
        self.publicKey = publicKey
        self.redirectUris = redirectUris
        self.secret = secret
    }

    private enum CodingKeys: String, CodingKey {
        case config
        case id
        case idLogo = "id_logo"
        case name
        case privateKey = "private_key"
        case isPro = "pro"
        case publicKey = "public_key"
        case redirectUris = "redirect_uris"
        case secret
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.config = try values.decodeIfPresent(String.self, forKey: .config)
        self.id = try values.decode(Int.self, forKey: .id)
        self.idLogo = try values.decodeIfPresent(Int.self, forKey: .idLogo)
        self.name = try values.decode(String.self, forKey: .name)
        self.privateKey = try values.decodeIfPresent(String.self, forKey: .privateKey)
        self.isPro = try values.decode(Bool.self, forKey: .isPro)
        self.publicKey = try values.decodeIfPresent(String.self, forKey: .publicKey)
        self.redirectUris = try values.decode(String.self, forKey: .redirectUris)
        self.secret = try values.decode(String.self, forKey: .secret)
    }
}

/// Example:
///
/// {
///   "id" : 0,
///   "new_value" : null,
///   "origin" : null,
///   "previous_value" : null,
///   "timestamp" : "<function datetime.now at 0x7f5740c0d9d8>",
///   "type" : null
/// }
public struct ConfigLog: Codable {
    public var id: Int
    public var key: String
    public var newValue: String?
    /// The entity who made the config key modification
    public var origin: String?
    public var previousValue: String?
    /// Timestamp of when the configuration key was changed
    public var timestamp: Date
    /// Action done on the config: add, update or delete
    public var type: String

    public init(id: Int, key: String, newValue: String? = nil, origin: String? = nil, previousValue: String? = nil, timestamp: Date, type: String) {
        self.id = id
        self.key = key
        self.newValue = newValue
        self.origin = origin
        self.previousValue = previousValue
        self.timestamp = timestamp
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case key
        case newValue = "new_value"
        case origin
        case previousValue = "previous_value"
        case timestamp
        case type
    }
}

/// Example:
///
/// {
///   "active" : true,
///   "created" : "<function datetime.now at 0x7f5740f1ad90>",
///   "id" : 0,
///   "id_connector" : 0,
///   "id_user" : 0,
///   "last_push" : "2021-08-23 10:35:44.203796",
///   "last_update" : "2021-08-23 10:35:44.203510",
///   "next_try" : "2021-08-23 10:35:44.203907"
/// }
public struct Connection: Codable {
    /// This connection is active and will be automatically synced
    public var isActive: Bool
    /// Creation date
    public var created: Date?
    /// ID of connection
    public var id: Int
    /// ID of the related connector
    public var idConnector: Int
    /// ID of the related user
    public var idUser: Int?
    /// Last successful push
    public var lastPush: Date?
    /// Last successful update
    public var lastUpdate: Date?
    /// Date of next synchronization
    public var nextTry: Date?

    public init(isActive: Bool, created: Date? = nil, id: Int, idConnector: Int, idUser: Int? = nil, lastPush: Date? = nil, lastUpdate: Date? = nil, nextTry: Date? = nil) {
        self.isActive = isActive
        self.created = created
        self.id = id
        self.idConnector = idConnector
        self.idUser = idUser
        self.lastPush = lastPush
        self.lastUpdate = lastUpdate
        self.nextTry = nextTry
    }

    private enum CodingKeys: String, CodingKey {
        case isActive = "active"
        case created
        case id
        case idConnector = "id_connector"
        case idUser = "id_user"
        case lastPush = "last_push"
        case lastUpdate = "last_update"
        case nextTry = "next_try"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isActive = try values.decode(Bool.self, forKey: .isActive)
        self.created = try values.decodeIfPresent(Date.self, forKey: .created)
        self.id = try values.decode(Int.self, forKey: .id)
        self.idConnector = try values.decode(Int.self, forKey: .idConnector)
        self.idUser = try values.decodeIfPresent(Int.self, forKey: .idUser)
        self.lastPush = try values.decodeIfPresent(Date.self, forKey: .lastPush)
        self.lastUpdate = try values.decodeIfPresent(Date.self, forKey: .lastUpdate)
        self.nextTry = try values.decodeIfPresent(Date.self, forKey: .nextTry)
    }
}

/// Example:
///
/// {
///   "error" : null,
///   "error_message" : null,
///   "error_uid" : null,
///   "id" : 0,
///   "id_connection" : 0,
///   "id_connector" : 0,
///   "id_source" : 0,
///   "id_user" : 0,
///   "login" : null,
///   "nb_accounts" : 0,
///   "next_try" : "2021-08-23 10:35:44.219976",
///   "session_folder_id" : null,
///   "start" : "2021-08-23 10:35:44.221393",
///   "statut" : 0,
///   "timestamp" : "<function datetime.now at 0x7f5740f766a8>",
///   "worker" : null
/// }
public struct ConnectionLog: Codable {
    /// If fail, contains the error code
    public var error: String?
    /// If fail, error message received from connector
    public var errorMessage: String?
    /// MD5 hash of the exception backtrace
    public var errorUid: String?
    /// Fields for connection in additionalInformationNeeded state with background option
    public var fields: String?
    /// ID of the log
    public var id: Int
    /// ID of the connection
    public var idConnection: Int
    /// ID of the connector
    public var idConnector: Int?
    /// ID of the related connection source
    public var idSource: Int?
    /// ID of the user
    public var idUser: Int?
    /// Bcrypt hash of the login
    public var login: String?
    /// In case of bank connection, number of accounts
    public var nbAccounts: Int?
    /// If fail, the date represents the next try to connect
    public var nextTry: Date?
    /// Session folder uid
    public var sessionFolderID: String?
    /// Timestamp when the synchronization has started
    public var start: Date?
    /// Status of user (1 = charged user)
    public var statut: Int?
    /// Timestamp of log, when the synchronization has finished
    public var timestamp: Date
    /// Worker used to do synchronization
    public var worker: String?

    public init(error: String? = nil, errorMessage: String? = nil, errorUid: String? = nil, fields: String? = nil, id: Int, idConnection: Int, idConnector: Int? = nil, idSource: Int? = nil, idUser: Int? = nil, login: String? = nil, nbAccounts: Int? = nil, nextTry: Date? = nil, sessionFolderID: String? = nil, start: Date? = nil, statut: Int? = nil, timestamp: Date, worker: String? = nil) {
        self.error = error
        self.errorMessage = errorMessage
        self.errorUid = errorUid
        self.fields = fields
        self.id = id
        self.idConnection = idConnection
        self.idConnector = idConnector
        self.idSource = idSource
        self.idUser = idUser
        self.login = login
        self.nbAccounts = nbAccounts
        self.nextTry = nextTry
        self.sessionFolderID = sessionFolderID
        self.start = start
        self.statut = statut
        self.timestamp = timestamp
        self.worker = worker
    }

    private enum CodingKeys: String, CodingKey {
        case error
        case errorMessage = "error_message"
        case errorUid = "error_uid"
        case fields
        case id
        case idConnection = "id_connection"
        case idConnector = "id_connector"
        case idSource = "id_source"
        case idUser = "id_user"
        case login
        case nbAccounts = "nb_accounts"
        case nextTry = "next_try"
        case sessionFolderID = "session_folder_id"
        case start
        case statut
        case timestamp
        case worker
    }
}

/// Example:
///
/// {
///   "access_expire" : "2021-08-23 10:35:44.235793",
///   "created" : "<function datetime.now at 0x7f5740f46510>",
///   "disabled" : "2021-08-23 10:35:44.235550",
///   "expire" : "2021-08-23 10:35:44.235883",
///   "id" : 0,
///   "id_connection" : 0,
///   "id_connector_source" : 0,
///   "last_update" : "2021-08-23 10:35:44.235451",
///   "name" : null,
///   "next_try" : "2021-08-23 10:35:44.236093",
///   "state" : null
/// }
public struct ConnectionSource: Codable {
    /// Expiration date of the access
    public var accessExpire: Date?
    /// Creation date of the connection source
    public var created: Date
    /// This source is not used to synchronize the connection
    public var disabled: Date?
    /// Expiration of the connection source. Used to purge the connection in case completion was not finished
    public var expire: Date?
    /// ID of connection
    public var id: Int
    /// ID of the related connection
    public var idConnection: Int
    /// ID of the related connector source
    public var idConnectorSource: Int
    /// Last successful update
    public var lastUpdate: Date?
    /// Name of the connection source
    public var name: String
    /// Date of next synchronization
    public var nextTry: Date?
    /// If the last update has failed, the state code
    public var state: String?

    public init(accessExpire: Date? = nil, created: Date, disabled: Date? = nil, expire: Date? = nil, id: Int, idConnection: Int, idConnectorSource: Int, lastUpdate: Date? = nil, name: String, nextTry: Date? = nil, state: String? = nil) {
        self.accessExpire = accessExpire
        self.created = created
        self.disabled = disabled
        self.expire = expire
        self.id = id
        self.idConnection = idConnection
        self.idConnectorSource = idConnectorSource
        self.lastUpdate = lastUpdate
        self.name = name
        self.nextTry = nextTry
        self.state = state
    }

    private enum CodingKeys: String, CodingKey {
        case accessExpire = "access_expire"
        case created
        case disabled
        case expire
        case id
        case idConnection = "id_connection"
        case idConnectorSource = "id_connector_source"
        case lastUpdate = "last_update"
        case name
        case nextTry = "next_try"
        case state
    }
}

/// Example:
///
/// {
///   "auth_mechanism" : null,
///   "beta" : false,
///   "charged" : true,
///   "code" : null,
///   "color" : null,
///   "hidden" : false,
///   "id" : 0,
///   "months_to_fetch" : 0,
///   "name" : null,
///   "restricted" : false,
///   "siret" : null,
///   "slug" : null,
///   "sync_frequency" : 0,
///   "uuid" : null
/// }
public struct Connector: Codable {
    /// Authentication mechanism to use
    public var authMechanism: String?
    /// If true, this connector is perhaps unstable :)
    public var isBeta: Bool
    /// Usage of this connector is charged
    public var isCharged: Bool
    /// Bank code
    public var code: String?
    /// Main color of the bank or provider
    public var color: String?
    /// This connector is hidden from your users
    public var isHidden: Bool
    /// ID of the connector
    public var id: Int
    /// How many months of history to fetch
    public var monthsToFetch: Int?
    /// Name of the bank or provider
    public var name: String
    /// If true, new connections cannot be added with this connector
    public var isRestricted: Bool
    /// SIRET code for Bill modules
    public var siret: String?
    public var slug: String?
    /// How many days to wait between syncs
    public var syncFrequency: Double?
    /// Unique connector identifier
    public var uuid: String

    public init(authMechanism: String? = nil, isBeta: Bool, isCharged: Bool, code: String? = nil, color: String? = nil, isHidden: Bool? = nil, id: Int, monthsToFetch: Int? = nil, name: String, isRestricted: Bool, siret: String? = nil, slug: String? = nil, syncFrequency: Double? = nil, uuid: String) {
        self.authMechanism = authMechanism
        self.isBeta = isBeta
        self.isCharged = isCharged
        self.code = code
        self.color = color
        self.isHidden = isHidden ?? false
        self.id = id
        self.monthsToFetch = monthsToFetch
        self.name = name
        self.isRestricted = isRestricted
        self.siret = siret
        self.slug = slug
        self.syncFrequency = syncFrequency
        self.uuid = uuid
    }

    private enum CodingKeys: String, CodingKey {
        case authMechanism = "auth_mechanism"
        case isBeta = "beta"
        case isCharged = "charged"
        case code
        case color
        case isHidden = "hidden"
        case id
        case monthsToFetch = "months_to_fetch"
        case name
        case isRestricted = "restricted"
        case siret
        case slug
        case syncFrequency = "sync_frequency"
        case uuid
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.authMechanism = try values.decodeIfPresent(String.self, forKey: .authMechanism)
        self.isBeta = try values.decode(Bool.self, forKey: .isBeta)
        self.isCharged = try values.decode(Bool.self, forKey: .isCharged)
        self.code = try values.decodeIfPresent(String.self, forKey: .code)
        self.color = try values.decodeIfPresent(String.self, forKey: .color)
        self.isHidden = try values.decodeIfPresent(Bool.self, forKey: .isHidden) ?? false
        self.id = try values.decode(Int.self, forKey: .id)
        self.monthsToFetch = try values.decodeIfPresent(Int.self, forKey: .monthsToFetch)
        self.name = try values.decode(String.self, forKey: .name)
        self.isRestricted = try values.decode(Bool.self, forKey: .isRestricted)
        self.siret = try values.decodeIfPresent(String.self, forKey: .siret)
        self.slug = try values.decodeIfPresent(String.self, forKey: .slug)
        self.syncFrequency = try values.decodeIfPresent(Double.self, forKey: .syncFrequency)
        self.uuid = try values.decode(String.self, forKey: .uuid)
    }
}

/// Example:
///
/// {
///   "id" : 0,
///   "name" : false
/// }
public struct ConnectorCategory: Codable {
    /// ID of the bank category
    public var id: Int
    /// Name of the category
    public var name: String

    public init(id: Int, name: String) {
        self.id = id
        self.name = name
    }
}

/// Example:
///
/// {
///   "id" : 0,
///   "id_connector" : 0,
///   "id_file" : 0,
///   "type" : null
/// }
public struct ConnectorLogo: Codable {
    public var id: Int
    /// ID of the connector
    public var idConnector: Int
    /// Id of the Bank/Provider Logo
    public var idFile: Int
    /// Logo's type
    public var type: String?

    public init(id: Int, idConnector: Int, idFile: Int, type: String? = nil) {
        self.id = id
        self.idConnector = idConnector
        self.idFile = idFile
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case idConnector = "id_connector"
        case idFile = "id_file"
        case type
    }
}

/// Example:
///
/// {
///   "auth_mechanism" : null,
///   "disabled" : "2021-08-23 10:35:44.205371",
///   "disabled_capabilities" : null,
///   "fallback" : null,
///   "id" : 0,
///   "id_connector" : 0,
///   "id_weboob" : null,
///   "name" : null,
///   "priority" : 0
/// }
public struct ConnectorSource: Codable {
    /// Authentication mechanism to use
    public var authMechanism: String?
    /// This source is not used to synchronize the connection
    public var disabled: Date?
    /// Comma separated list of capabilities disabled on this connector source
    public var disabledCapabilities: String?
    /// Name of the source this fallback is for
    public var fallback: String?
    /// ID of the connector source
    public var id: Int
    /// ID of the connector
    public var idConnector: Int
    public var idWeboob: String
    /// Name of the source
    public var name: String
    /// The source priority order for the synchronization
    public var priority: Int?
    /// Last known stability
    public var stability: String?

    public init(authMechanism: String? = nil, disabled: Date? = nil, disabledCapabilities: String? = nil, fallback: String? = nil, id: Int, idConnector: Int, idWeboob: String, name: String, priority: Int? = nil, stability: String? = nil) {
        self.authMechanism = authMechanism
        self.disabled = disabled
        self.disabledCapabilities = disabledCapabilities
        self.fallback = fallback
        self.id = id
        self.idConnector = idConnector
        self.idWeboob = idWeboob
        self.name = name
        self.priority = priority
        self.stability = stability
    }

    private enum CodingKeys: String, CodingKey {
        case authMechanism = "auth_mechanism"
        case disabled
        case disabledCapabilities = "disabled_capabilities"
        case fallback
        case id
        case idConnector = "id_connector"
        case idWeboob = "id_weboob"
        case name
        case priority
        case stability
    }
}

/// Example:
///
/// {
///   "id_connector_source" : 0,
///   "label" : null,
///   "name" : null,
///   "regex" : null,
///   "required" : true,
///   "secret" : true,
///   "type" : "text"
/// }
public struct ConnectorSourceField: Codable {
    /// ID of the related connector source
    public var idConnectorSource: Int
    /// Label to display to user
    public var label: String
    /// Name of the config
    public var name: String
    /// If set, the value must match this regexp
    public var regex: String?
    /// If true, config has to be set to use this source
    public var isRequired: Bool
    /// If true, value must be hidden on fronts
    public var isSecret: Bool
    /// Type of config
    public var type: String?

    public init(idConnectorSource: Int, label: String, name: String, regex: String? = nil, isRequired: Bool? = nil, isSecret: Bool? = nil, type: String? = nil) {
        self.idConnectorSource = idConnectorSource
        self.label = label
        self.name = name
        self.regex = regex
        self.isRequired = isRequired ?? true
        self.isSecret = isSecret ?? true
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case idConnectorSource = "id_connector_source"
        case label
        case name
        case regex
        case isRequired = "required"
        case isSecret = "secret"
        case type
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.idConnectorSource = try values.decode(Int.self, forKey: .idConnectorSource)
        self.label = try values.decode(String.self, forKey: .label)
        self.name = try values.decode(String.self, forKey: .name)
        self.regex = try values.decodeIfPresent(String.self, forKey: .regex)
        self.isRequired = try values.decodeIfPresent(Bool.self, forKey: .isRequired) ?? true
        self.isSecret = try values.decodeIfPresent(Bool.self, forKey: .isSecret) ?? true
        self.type = try values.decodeIfPresent(String.self, forKey: .type)
    }
}

/// Example:
///
/// {
///   "crypto" : false,
///   "datetime" : "2021-08-23 10:35:44.274832",
///   "id" : null,
///   "marketcap" : 0,
///   "precision" : 2,
///   "prefix" : false,
///   "symbol" : null
/// }
public struct Currency: Codable {
    /// It is a crypto currency or not
    public var isCrypto: Bool
    /// Time and date of Market Cap (for cryptos)
    public var datetime: Date?
    /// ISO 4217 code used as ID
    public var id: String
    /// Market Capitalization in EUR
    public var marketcap: Double?
    /// Numbers of significant digits
    public var precision: Int?
    /// Amount is prefixed or not by the currency
    public var isPrefix: Bool
    /// Symbol representing the currency
    public var symbol: String

    public init(isCrypto: Bool? = nil, datetime: Date? = nil, id: String, marketcap: Double? = nil, precision: Int? = nil, isPrefix: Bool, symbol: String) {
        self.isCrypto = isCrypto ?? false
        self.datetime = datetime
        self.id = id
        self.marketcap = marketcap
        self.precision = precision
        self.isPrefix = isPrefix
        self.symbol = symbol
    }

    private enum CodingKeys: String, CodingKey {
        case isCrypto = "crypto"
        case datetime
        case id
        case marketcap
        case precision
        case isPrefix = "prefix"
        case symbol
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isCrypto = try values.decodeIfPresent(Bool.self, forKey: .isCrypto) ?? false
        self.datetime = try values.decodeIfPresent(Date.self, forKey: .datetime)
        self.id = try values.decode(String.self, forKey: .id)
        self.marketcap = try values.decodeIfPresent(Double.self, forKey: .marketcap)
        self.precision = try values.decodeIfPresent(Int.self, forKey: .precision)
        self.isPrefix = try values.decode(Bool.self, forKey: .isPrefix)
        self.symbol = try values.decode(String.self, forKey: .symbol)
    }
}

/// Example:
///
/// {
///   "debug" : false,
///   "id" : 0,
///   "id_token" : 0,
///   "last_update" : "<function datetime.now at 0x7f5740d2bd90>",
///   "notification_token" : null,
///   "type" : null,
///   "version" : null
/// }
public struct Device: Codable {
    public var isDebug: Bool
    public var id: Int
    public var idToken: Int
    public var lastUpdate: Date
    public var notificationToken: String
    public var type: String
    public var version: String

    public init(isDebug: Bool, id: Int, idToken: Int, lastUpdate: Date, notificationToken: String, type: String, version: String) {
        self.isDebug = isDebug
        self.id = id
        self.idToken = idToken
        self.lastUpdate = lastUpdate
        self.notificationToken = notificationToken
        self.type = type
        self.version = version
    }

    private enum CodingKeys: String, CodingKey {
        case isDebug = "debug"
        case id
        case idToken = "id_token"
        case lastUpdate = "last_update"
        case notificationToken = "notification_token"
        case type
        case version
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isDebug = try values.decode(Bool.self, forKey: .isDebug)
        self.id = try values.decode(Int.self, forKey: .id)
        self.idToken = try values.decode(Int.self, forKey: .idToken)
        self.lastUpdate = try values.decode(Date.self, forKey: .lastUpdate)
        self.notificationToken = try values.decode(String.self, forKey: .notificationToken)
        self.type = try values.decode(String.self, forKey: .type)
        self.version = try values.decode(String.self, forKey: .version)
    }
}

/// Example:
///
/// {
///   "currency" : null,
///   "date" : "2021-08-23 10:35:44.287914",
///   "duedate" : "2021-08-23",
///   "has_file_on_website" : true,
///   "id" : 0,
///   "id_category" : 0,
///   "id_file" : 0,
///   "id_subscription" : 0,
///   "id_thumbnail" : 0,
///   "id_type" : 0,
///   "id_user" : 0,
///   "income" : true,
///   "issuer" : null,
///   "last_update" : "2021-08-23 10:35:44.289188",
///   "name" : null,
///   "number" : null,
///   "readonly" : true,
///   "timestamp" : "<function datetime.now at 0x7f5740bab6a8>",
///   "total_amount" : 0,
///   "untaxed_amount" : 0,
///   "vat" : 0,
///   "webid" : null
/// }
public struct Document: Codable {
    /// Document currency
    public var currency: [String: AnyJSON]?
    public var date: Date?
    public var duedate: NaiveDate?
    /// Boolean to set if file is available on website
    public var hasFileOnWebsite: Bool
    public var id: Int
    public var idCategory: Int?
    public var idFile: Int?
    public var idSubscription: Int?
    public var idThumbnail: Int?
    public var idType: Int?
    public var idUser: Int
    public var isIncome: Bool
    public var issuer: String?
    /// Last successful update of the document
    public var lastUpdate: Date?
    public var name: String?
    public var number: String?
    public var isReadonly: Bool
    public var timestamp: Date
    public var totalAmount: Double?
    public var untaxedAmount: Double?
    public var vat: Double?
    public var webid: String?

    public init(currency: [String: AnyJSON]? = nil, date: Date? = nil, duedate: NaiveDate? = nil, hasFileOnWebsite: Bool, id: Int, idCategory: Int? = nil, idFile: Int? = nil, idSubscription: Int? = nil, idThumbnail: Int? = nil, idType: Int? = nil, idUser: Int, isIncome: Bool? = nil, issuer: String? = nil, lastUpdate: Date? = nil, name: String? = nil, number: String? = nil, isReadonly: Bool, timestamp: Date, totalAmount: Double? = nil, untaxedAmount: Double? = nil, vat: Double? = nil, webid: String? = nil) {
        self.currency = currency
        self.date = date
        self.duedate = duedate
        self.hasFileOnWebsite = hasFileOnWebsite
        self.id = id
        self.idCategory = idCategory
        self.idFile = idFile
        self.idSubscription = idSubscription
        self.idThumbnail = idThumbnail
        self.idType = idType
        self.idUser = idUser
        self.isIncome = isIncome ?? true
        self.issuer = issuer
        self.lastUpdate = lastUpdate
        self.name = name
        self.number = number
        self.isReadonly = isReadonly
        self.timestamp = timestamp
        self.totalAmount = totalAmount
        self.untaxedAmount = untaxedAmount
        self.vat = vat
        self.webid = webid
    }

    private enum CodingKeys: String, CodingKey {
        case currency
        case date
        case duedate
        case hasFileOnWebsite = "has_file_on_website"
        case id
        case idCategory = "id_category"
        case idFile = "id_file"
        case idSubscription = "id_subscription"
        case idThumbnail = "id_thumbnail"
        case idType = "id_type"
        case idUser = "id_user"
        case isIncome = "income"
        case issuer
        case lastUpdate = "last_update"
        case name
        case number
        case isReadonly = "readonly"
        case timestamp
        case totalAmount = "total_amount"
        case untaxedAmount = "untaxed_amount"
        case vat
        case webid
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.currency = try values.decodeIfPresent([String: AnyJSON].self, forKey: .currency)
        self.date = try values.decodeIfPresent(Date.self, forKey: .date)
        self.duedate = try values.decodeIfPresent(NaiveDate.self, forKey: .duedate)
        self.hasFileOnWebsite = try values.decode(Bool.self, forKey: .hasFileOnWebsite)
        self.id = try values.decode(Int.self, forKey: .id)
        self.idCategory = try values.decodeIfPresent(Int.self, forKey: .idCategory)
        self.idFile = try values.decodeIfPresent(Int.self, forKey: .idFile)
        self.idSubscription = try values.decodeIfPresent(Int.self, forKey: .idSubscription)
        self.idThumbnail = try values.decodeIfPresent(Int.self, forKey: .idThumbnail)
        self.idType = try values.decodeIfPresent(Int.self, forKey: .idType)
        self.idUser = try values.decode(Int.self, forKey: .idUser)
        self.isIncome = try values.decodeIfPresent(Bool.self, forKey: .isIncome) ?? true
        self.issuer = try values.decodeIfPresent(String.self, forKey: .issuer)
        self.lastUpdate = try values.decodeIfPresent(Date.self, forKey: .lastUpdate)
        self.name = try values.decodeIfPresent(String.self, forKey: .name)
        self.number = try values.decodeIfPresent(String.self, forKey: .number)
        self.isReadonly = try values.decode(Bool.self, forKey: .isReadonly)
        self.timestamp = try values.decode(Date.self, forKey: .timestamp)
        self.totalAmount = try values.decodeIfPresent(Double.self, forKey: .totalAmount)
        self.untaxedAmount = try values.decodeIfPresent(Double.self, forKey: .untaxedAmount)
        self.vat = try values.decodeIfPresent(Double.self, forKey: .vat)
        self.webid = try values.decodeIfPresent(String.self, forKey: .webid)
    }
}

/// Example:
///
/// {
///   "attacheable" : true,
///   "id" : 0,
///   "name" : null
/// }
public struct DocumentType: Codable {
    public var isAttacheable: Bool
    public var id: Int
    public var name: String

    public init(isAttacheable: Bool, id: Int, name: String) {
        self.isAttacheable = isAttacheable
        self.id = id
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case isAttacheable = "attacheable"
        case id
        case name
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isAttacheable = try values.decode(Bool.self, forKey: .isAttacheable)
        self.id = try values.decode(Int.self, forKey: .id)
        self.name = try values.decode(String.self, forKey: .name)
    }
}

/// Example:
///
/// {
///   "auth_mechanisms" : null,
///   "connector_sources" : null,
///   "ephemeral" : false,
///   "id" : 0,
///   "id_connector" : 0,
///   "label" : null,
///   "name" : null,
///   "regex" : null,
///   "required" : true,
///   "type" : "text",
///   "value" : null
/// }
public struct Field: Codable {
    /// Authentication mechanisms this field is used for
    public var authMechanisms: String?
    /// Sources this field is used for
    public var connectorSources: String?
    /// This field will not be saved in database
    public var isEphemeral: Bool
    /// ID of the field
    public var id: Int
    /// ID of the related connector
    public var idConnector: Int
    /// Label to display to user
    public var label: String
    /// Name of the field
    public var name: String
    /// If set, the value must match this regexp
    public var regex: String?
    /// If true, field has to be set to synchronize the connection
    public var isRequired: Bool
    /// Type of field (text, password, list, hidden)
    public var type: String?
    /// Default value of the field
    public var value: String?

    public init(authMechanisms: String? = nil, connectorSources: String? = nil, isEphemeral: Bool? = nil, id: Int, idConnector: Int, label: String, name: String, regex: String? = nil, isRequired: Bool, type: String? = nil, value: String? = nil) {
        self.authMechanisms = authMechanisms
        self.connectorSources = connectorSources
        self.isEphemeral = isEphemeral ?? false
        self.id = id
        self.idConnector = idConnector
        self.label = label
        self.name = name
        self.regex = regex
        self.isRequired = isRequired
        self.type = type
        self.value = value
    }

    private enum CodingKeys: String, CodingKey {
        case authMechanisms = "auth_mechanisms"
        case connectorSources = "connector_sources"
        case isEphemeral = "ephemeral"
        case id
        case idConnector = "id_connector"
        case label
        case name
        case regex
        case isRequired = "required"
        case type
        case value
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.authMechanisms = try values.decodeIfPresent(String.self, forKey: .authMechanisms)
        self.connectorSources = try values.decodeIfPresent(String.self, forKey: .connectorSources)
        self.isEphemeral = try values.decodeIfPresent(Bool.self, forKey: .isEphemeral) ?? false
        self.id = try values.decode(Int.self, forKey: .id)
        self.idConnector = try values.decode(Int.self, forKey: .idConnector)
        self.label = try values.decode(String.self, forKey: .label)
        self.name = try values.decode(String.self, forKey: .name)
        self.regex = try values.decodeIfPresent(String.self, forKey: .regex)
        self.isRequired = try values.decode(Bool.self, forKey: .isRequired)
        self.type = try values.decodeIfPresent(String.self, forKey: .type)
        self.value = try values.decodeIfPresent(String.self, forKey: .value)
    }
}

/// Example:
///
/// {
///   "content_type" : null,
///   "file_size" : 0,
///   "filename" : null,
///   "id" : 0
/// }
public struct File: Codable {
    public var contentType: String
    public var fileSize: Int
    public var filename: String
    public var id: Int

    public init(contentType: String, fileSize: Int, filename: String, id: Int) {
        self.contentType = contentType
        self.fileSize = fileSize
        self.filename = filename
        self.id = id
    }

    private enum CodingKeys: String, CodingKey {
        case contentType = "content_type"
        case fileSize = "file_size"
        case filename
        case id
    }
}

/// Example:
///
/// {
///   "color" : null,
///   "conf" : null,
///   "email" : null,
///   "id" : 0,
///   "id_logo" : 0,
///   "id_parent_group" : 0,
///   "name" : null,
///   "url" : null
/// }
public struct Group: Codable {
    public var color: String?
    public var conf: String?
    public var email: String?
    public var id: Int
    public var idLogo: Int?
    public var idParentGroup: Int?
    public var name: String?
    public var url: String?

    public init(color: String? = nil, conf: String? = nil, email: String? = nil, id: Int, idLogo: Int? = nil, idParentGroup: Int? = nil, name: String? = nil, url: String? = nil) {
        self.color = color
        self.conf = conf
        self.email = email
        self.id = id
        self.idLogo = idLogo
        self.idParentGroup = idParentGroup
        self.name = name
        self.url = url
    }

    private enum CodingKeys: String, CodingKey {
        case color
        case conf
        case email
        case id
        case idLogo = "id_logo"
        case idParentGroup = "id_parent_group"
        case name
        case url
    }
}

/// Example:
///
/// {
///   "display" : true,
///   "income" : false,
///   "nature" : null,
///   "wording" : null
/// }
public struct HashTable: Codable {
    public var isDisplay: Bool
    public var isIncome: Bool
    public var nature: String
    public var wording: String

    public init(isDisplay: Bool, isIncome: Bool, nature: String, wording: String) {
        self.isDisplay = isDisplay
        self.isIncome = isIncome
        self.nature = nature
        self.wording = wording
    }

    private enum CodingKeys: String, CodingKey {
        case isDisplay = "display"
        case isIncome = "income"
        case nature
        case wording
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isDisplay = try values.decode(Bool.self, forKey: .isDisplay)
        self.isIncome = try values.decode(Bool.self, forKey: .isIncome)
        self.nature = try values.decode(String.self, forKey: .nature)
        self.wording = try values.decode(String.self, forKey: .wording)
    }
}

/// Example:
///
/// {
///   "external_ref" : null,
///   "id" : 0,
///   "id_user" : 0,
///   "identification" : null,
///   "issuer" : null,
///   "kind" : null,
///   "scheme_name" : null
/// }
public struct IdentityInfo: Codable {
    /// Label associated with the beneficiary account
    public var externalRef: String?
    public var id: Int
    /// ID of a related user
    public var idUser: Int?
    /// Identification number
    public var identification: String?
    /// Issuer of the identification
    public var issuer: String?
    /// Kind of the entity
    public var kind: String?
    /// Identification number type
    public var schemeName: String?

    public init(externalRef: String? = nil, id: Int, idUser: Int? = nil, identification: String? = nil, issuer: String? = nil, kind: String? = nil, schemeName: String? = nil) {
        self.externalRef = externalRef
        self.id = id
        self.idUser = idUser
        self.identification = identification
        self.issuer = issuer
        self.kind = kind
        self.schemeName = schemeName
    }

    private enum CodingKeys: String, CodingKey {
        case externalRef = "external_ref"
        case id
        case idUser = "id_user"
        case identification
        case issuer
        case kind
        case schemeName = "scheme_name"
    }
}

/// Example:
///
/// {
///   "code" : null,
///   "code_type" : null,
///   "deleted" : "2021-08-23 10:35:44.377160",
///   "description" : null,
///   "diff" : 0,
///   "diff_percent" : 0,
///   "id" : 0,
///   "id_account" : 0,
///   "id_security" : 0,
///   "label" : null,
///   "last_update" : "2021-08-23 10:35:44.377092",
///   "original_currency" : null,
///   "original_diff" : 0,
///   "original_unitprice" : 0,
///   "original_unitvalue" : 0,
///   "original_valuation" : 0,
///   "portfolio_share" : 0,
///   "prev_diff" : 0,
///   "prev_vdate" : "2021-08-23",
///   "quantity" : 0,
///   "source" : null,
///   "unitprice" : 0,
///   "unitvalue" : 0,
///   "valuation" : 0,
///   "vdate" : "2021-08-23"
/// }
public struct Investment: Codable {
    /// Investment code
    public var code: String
    /// Code type (ISIN of AMF)
    public var codeType: String?
    /// If set, this investment has been removed from the website
    public var deleted: Date?
    /// Description of the investment
    public var description: String?
    /// Capital gain
    public var diff: Double?
    /// Capital gain in percent (between 0 and 1)
    public var diffPercent: Double?
    /// ID of the investment
    public var id: Int
    /// ID of the related account
    public var idAccount: Int
    /// ID of the related security
    public var idSecurity: Int?
    /// Label of the investment
    public var label: String
    /// Last update of the investment
    public var lastUpdate: Date?
    /// Original currency
    public var originalCurrency: [String: AnyJSON]?
    /// Capital gain in the original currency
    public var originalDiff: Double?
    /// Current unit value in the original currency
    public var originalUnitprice: Double?
    /// Average buy price in the original currency
    public var originalUnitvalue: Double?
    /// Valuation in original currency
    public var originalValuation: Double?
    /// Percent of the portfolio
    public var portfolioShare: Double?
    /// Capital gain from previous value
    public var prevDiff: Double?
    /// Value date of the previous value (prev_diff)
    public var prevVdate: NaiveDate?
    /// Quantity
    public var quantity: Double?
    /// Source of the ISIN code (website, notFound)
    public var source: String?
    /// Average buy price
    public var unitprice: Double?
    /// Current unit value
    public var unitvalue: Double?
    /// Current valuation
    public var valuation: Double?
    /// Value date
    public var vdate: NaiveDate?

    public init(code: String, codeType: String? = nil, deleted: Date? = nil, description: String? = nil, diff: Double? = nil, diffPercent: Double? = nil, id: Int, idAccount: Int, idSecurity: Int? = nil, label: String, lastUpdate: Date? = nil, originalCurrency: [String: AnyJSON]? = nil, originalDiff: Double? = nil, originalUnitprice: Double? = nil, originalUnitvalue: Double? = nil, originalValuation: Double? = nil, portfolioShare: Double? = nil, prevDiff: Double? = nil, prevVdate: NaiveDate? = nil, quantity: Double? = nil, source: String? = nil, unitprice: Double? = nil, unitvalue: Double? = nil, valuation: Double? = nil, vdate: NaiveDate? = nil) {
        self.code = code
        self.codeType = codeType
        self.deleted = deleted
        self.description = description
        self.diff = diff
        self.diffPercent = diffPercent
        self.id = id
        self.idAccount = idAccount
        self.idSecurity = idSecurity
        self.label = label
        self.lastUpdate = lastUpdate
        self.originalCurrency = originalCurrency
        self.originalDiff = originalDiff
        self.originalUnitprice = originalUnitprice
        self.originalUnitvalue = originalUnitvalue
        self.originalValuation = originalValuation
        self.portfolioShare = portfolioShare
        self.prevDiff = prevDiff
        self.prevVdate = prevVdate
        self.quantity = quantity
        self.source = source
        self.unitprice = unitprice
        self.unitvalue = unitvalue
        self.valuation = valuation
        self.vdate = vdate
    }

    private enum CodingKeys: String, CodingKey {
        case code
        case codeType = "code_type"
        case deleted
        case description
        case diff
        case diffPercent = "diff_percent"
        case id
        case idAccount = "id_account"
        case idSecurity = "id_security"
        case label
        case lastUpdate = "last_update"
        case originalCurrency = "original_currency"
        case originalDiff = "original_diff"
        case originalUnitprice = "original_unitprice"
        case originalUnitvalue = "original_unitvalue"
        case originalValuation = "original_valuation"
        case portfolioShare = "portfolio_share"
        case prevDiff = "prev_diff"
        case prevVdate = "prev_vdate"
        case quantity
        case source
        case unitprice
        case unitvalue
        case valuation
        case vdate
    }
}

/// Example:
///
/// {
///   "id" : 0,
///   "id_investment" : 0,
///   "original_currency" : null,
///   "original_unitvalue" : 0,
///   "unitvalue" : 0,
///   "vdate" : "2021-08-23"
/// }
public struct InvestmentValue: Codable {
    /// ID of the value
    public var id: Int
    /// ID of the related investment
    public var idInvestment: Int
    /// Original currency
    public var originalCurrency: [String: AnyJSON]?
    /// Value on this date, in the original currency
    public var originalUnitvalue: Double?
    /// Value on this date
    public var unitvalue: Double
    /// Date of this value
    public var vdate: NaiveDate

    public init(id: Int, idInvestment: Int, originalCurrency: [String: AnyJSON]? = nil, originalUnitvalue: Double? = nil, unitvalue: Double, vdate: NaiveDate) {
        self.id = id
        self.idInvestment = idInvestment
        self.originalCurrency = originalCurrency
        self.originalUnitvalue = originalUnitvalue
        self.unitvalue = unitvalue
        self.vdate = vdate
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case idInvestment = "id_investment"
        case originalCurrency = "original_currency"
        case originalUnitvalue = "original_unitvalue"
        case unitvalue
        case vdate
    }
}

/// Example:
///
/// {
///   "id" : 0,
///   "id_category" : 0,
///   "income" : false,
///   "keyword" : null,
///   "priority" : 0
/// }
public struct Keyword: Codable {
    public var id: Int
    public var idCategory: Int
    public var isIncome: Bool
    public var keyword: String
    public var priority: Int

    public init(id: Int, idCategory: Int, isIncome: Bool, keyword: String, priority: Int) {
        self.id = id
        self.idCategory = idCategory
        self.isIncome = isIncome
        self.keyword = keyword
        self.priority = priority
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case idCategory = "id_category"
        case isIncome = "income"
        case keyword
        case priority
    }
}

/// Example:
///
/// {
///   "id_user" : 0,
///   "timestamp" : "<function datetime.now at 0x7f5740d00c80>",
///   "worker" : null
/// }
public struct LockedUser: Codable {
    public var idUser: Int
    public var timestamp: Date
    public var worker: String?

    public init(idUser: Int, timestamp: Date, worker: String? = nil) {
        self.idUser = idUser
        self.timestamp = timestamp
        self.worker = worker
    }

    private enum CodingKeys: String, CodingKey {
        case idUser = "id_user"
        case timestamp
        case worker
    }
}

/// Example:
///
/// {
///   "amount" : 0,
///   "code" : null,
///   "created" : "2021-08-23 10:35:44.372113",
///   "date" : "2021-08-23",
///   "deleted" : "2021-08-23 10:35:44.372183",
///   "execution_date" : "2021-08-23",
///   "id" : 0,
///   "id_account" : 0,
///   "label" : null,
///   "last_update" : "2021-08-23 10:35:44.372022",
///   "ordervalue" : 0,
///   "payment_method" : null,
///   "quantity" : 0,
///   "state" : null,
///   "stock_market" : null,
///   "unitprice" : 0,
///   "unitvalue" : 0,
///   "validity_date" : "2021-08-23",
///   "webid" : null
/// }
public struct MarketOrder: Codable {
    /// Total amount of the market order
    public var amount: Double?
    /// ISIN code of the investment associated with the market order
    public var code: String?
    /// Insertion date of the market order in bi_market_order
    public var created: Date
    /// Creation date of the market order
    public var date: NaiveDate?
    /// If set, this market order has been removed from the website
    public var deleted: Date?
    /// Execution date of the market order
    public var executionDate: NaiveDate?
    /// ID of the market order
    public var id: Int
    /// ID of the related account
    public var idAccount: Int
    /// Label of the investment associated with the market order
    public var label: String
    /// Last update of the market order
    public var lastUpdate: Date?
    /// Limit value or trigger value, only relevant if the order type is LIMIT or TRIGGER
    public var ordervalue: Double?
    /// Payment method for the market order (usually 'SRD' or 'Comptant')
    public var paymentMethod: String?
    /// Quantity of stock shares in the market order
    public var quantity: Double?
    /// Current state of the market order
    public var state: String?
    /// Stock market on which the order was executed
    public var stockMarket: String?
    /// Value of the stock at the moment of the market order
    public var unitprice: Double?
    /// Current value of the stock associated with the market order
    public var unitvalue: Double?
    /// Validity date of the market order
    public var validityDate: NaiveDate?
    /// Weboob ID of the market order
    public var webid: String?

    public init(amount: Double? = nil, code: String? = nil, created: Date, date: NaiveDate? = nil, deleted: Date? = nil, executionDate: NaiveDate? = nil, id: Int, idAccount: Int, label: String, lastUpdate: Date? = nil, ordervalue: Double? = nil, paymentMethod: String? = nil, quantity: Double? = nil, state: String? = nil, stockMarket: String? = nil, unitprice: Double? = nil, unitvalue: Double? = nil, validityDate: NaiveDate? = nil, webid: String? = nil) {
        self.amount = amount
        self.code = code
        self.created = created
        self.date = date
        self.deleted = deleted
        self.executionDate = executionDate
        self.id = id
        self.idAccount = idAccount
        self.label = label
        self.lastUpdate = lastUpdate
        self.ordervalue = ordervalue
        self.paymentMethod = paymentMethod
        self.quantity = quantity
        self.state = state
        self.stockMarket = stockMarket
        self.unitprice = unitprice
        self.unitvalue = unitvalue
        self.validityDate = validityDate
        self.webid = webid
    }

    private enum CodingKeys: String, CodingKey {
        case amount
        case code
        case created
        case date
        case deleted
        case executionDate = "execution_date"
        case id
        case idAccount = "id_account"
        case label
        case lastUpdate = "last_update"
        case ordervalue
        case paymentMethod = "payment_method"
        case quantity
        case state
        case stockMarket = "stock_market"
        case unitprice
        case unitvalue
        case validityDate = "validity_date"
        case webid
    }
}

/// Example:
///
/// {
///   "id" : 0,
///   "redirect_uri" : null
/// }
public struct OidcWhitelist: Codable {
    public var id: Int
    /// Authorized redirect uri
    public var redirectUri: String

    public init(id: Int, redirectUri: String) {
        self.id = id
        self.redirectUri = redirectUri
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case redirectUri = "redirect_uri"
    }
}

/// Example:
///
/// {
///   "client_redirect_uri" : null,
///   "error_code" : null,
///   "error_description" : null,
///   "id" : 0,
///   "register_date" : "2021-08-23 10:35:44.188272",
///   "state" : null,
///   "validate_uri" : null
/// }
public struct Payment: Codable {
    /// URL to redirecting to client
    public var clientRedirectUri: String?
    /// In case of error, the error code
    public var errorCode: String?
    /// Error message
    public var errorDescription: String?
    public var id: Int
    /// Date of payment registration
    public var registerDate: Date?
    /// State of the payment
    public var state: String?
    /// URL to validate payment
    public var validateUri: String?

    public init(clientRedirectUri: String? = nil, errorCode: String? = nil, errorDescription: String? = nil, id: Int, registerDate: Date? = nil, state: String? = nil, validateUri: String? = nil) {
        self.clientRedirectUri = clientRedirectUri
        self.errorCode = errorCode
        self.errorDescription = errorDescription
        self.id = id
        self.registerDate = registerDate
        self.state = state
        self.validateUri = validateUri
    }

    private enum CodingKeys: String, CodingKey {
        case clientRedirectUri = "client_redirect_uri"
        case errorCode = "error_code"
        case errorDescription = "error_description"
        case id
        case registerDate = "register_date"
        case state
        case validateUri = "validate_uri"
    }
}

/// Example:
///
/// {
///   "disabled_date" : "2021-08-23 10:35:44.173688",
///   "id" : 0,
///   "id_account" : 0,
///   "identification" : null,
///   "issuer" : null,
///   "label" : null,
///   "scheme_name" : null
/// }
public struct PaymentAccount: Codable {
    /// Date at which the entry was disabled
    public var disabledDate: Date?
    public var id: Int
    /// ID of a related account
    public var idAccount: Int?
    /// Account identification number
    public var identification: String?
    /// Issuer or bic associated with the account
    public var issuer: String?
    /// Label associated with the beneficiary account
    public var label: String?
    /// Account number type
    public var schemeName: String?

    public init(disabledDate: Date? = nil, id: Int, idAccount: Int? = nil, identification: String? = nil, issuer: String? = nil, label: String? = nil, schemeName: String? = nil) {
        self.disabledDate = disabledDate
        self.id = id
        self.idAccount = idAccount
        self.identification = identification
        self.issuer = issuer
        self.label = label
        self.schemeName = schemeName
    }

    private enum CodingKeys: String, CodingKey {
        case disabledDate = "disabled_date"
        case id
        case idAccount = "id_account"
        case identification
        case issuer
        case label
        case schemeName = "scheme_name"
    }
}

/// Example:
///
/// {
///   "error_code" : null,
///   "error_description" : null,
///   "id" : 0,
///   "id_file" : 0,
///   "id_payment" : 0,
///   "state" : null,
///   "timestamp" : "<function datetime.now at 0x7f5740047f28>"
/// }
public struct PaymentLog: Codable {
    /// In case of error, the error code
    public var errorCode: String?
    /// Error message
    public var errorDescription: String?
    public var id: Int
    /// ID of the related payment file
    public var idFile: Int?
    /// ID of the related payment
    public var idPayment: Int?
    /// State of the payment
    public var state: String?
    /// Timestamp of the log
    public var timestamp: Date

    public init(errorCode: String? = nil, errorDescription: String? = nil, id: Int, idFile: Int? = nil, idPayment: Int? = nil, state: String? = nil, timestamp: Date) {
        self.errorCode = errorCode
        self.errorDescription = errorDescription
        self.id = id
        self.idFile = idFile
        self.idPayment = idPayment
        self.state = state
        self.timestamp = timestamp
    }

    private enum CodingKeys: String, CodingKey {
        case errorCode = "error_code"
        case errorDescription = "error_description"
        case id
        case idFile = "id_file"
        case idPayment = "id_payment"
        case state
        case timestamp
    }
}

/// Example:
///
/// {
///   "availability_date" : "2021-08-23",
///   "condition" : "inconnu",
///   "deleted" : "2021-08-23 10:35:44.318086",
///   "id" : 0,
///   "id_account" : 0,
///   "id_investment" : 0,
///   "label" : null,
///   "last_update" : "2021-08-23 10:35:44.318015",
///   "quantity" : 0,
///   "value" : 0
/// }
public struct Pocket: Codable {
    /// Availability date of the pocket
    public var availabilityDate: NaiveDate?
    /// Withdrawal condition of the pocket
    public var condition: String
    /// If set, this pocket has been removed from the website
    public var deleted: Date?
    /// ID of the pocket
    public var id: Int
    /// ID of the related account
    public var idAccount: Int
    /// ID of the related investment
    public var idInvestment: Int
    /// Label of the pocket
    public var label: String?
    /// Last update of the pocket
    public var lastUpdate: Date?
    /// Quantity of stocks
    public var quantity: Double?
    /// Value of the pocket
    public var value: Double

    public init(availabilityDate: NaiveDate? = nil, condition: String, deleted: Date? = nil, id: Int, idAccount: Int, idInvestment: Int, label: String? = nil, lastUpdate: Date? = nil, quantity: Double? = nil, value: Double) {
        self.availabilityDate = availabilityDate
        self.condition = condition
        self.deleted = deleted
        self.id = id
        self.idAccount = idAccount
        self.idInvestment = idInvestment
        self.label = label
        self.lastUpdate = lastUpdate
        self.quantity = quantity
        self.value = value
    }

    private enum CodingKeys: String, CodingKey {
        case availabilityDate = "availability_date"
        case condition
        case deleted
        case id
        case idAccount = "id_account"
        case idInvestment = "id_investment"
        case label
        case lastUpdate = "last_update"
        case quantity
        case value
    }
}

/// Example:
///
/// {
///   "admin" : false,
///   "conf" : null,
///   "id" : 0,
///   "id_user" : 0,
///   "lang" : null,
///   "role" : "admin",
///   "statut" : 0
/// }
public struct Profile: Codable {
    public var isAdmin: Bool
    public var conf: String?
    public var email: String
    public var id: Int
    public var idUser: Int
    public var lang: String?
    public var role: Role
    public var statut: Int

    public enum Role: String, Codable, CaseIterable {
        case admin
        case ser
    }

    public init(isAdmin: Bool, conf: String? = nil, email: String, id: Int, idUser: Int, lang: String? = nil, role: Role, statut: Int) {
        self.isAdmin = isAdmin
        self.conf = conf
        self.email = email
        self.id = id
        self.idUser = idUser
        self.lang = lang
        self.role = role
        self.statut = statut
    }

    private enum CodingKeys: String, CodingKey {
        case isAdmin = "admin"
        case conf
        case email
        case id
        case idUser = "id_user"
        case lang
        case role
        case statut
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isAdmin = try values.decode(Bool.self, forKey: .isAdmin)
        self.conf = try values.decodeIfPresent(String.self, forKey: .conf)
        self.email = try values.decode(String.self, forKey: .email)
        self.id = try values.decode(Int.self, forKey: .id)
        self.idUser = try values.decode(Int.self, forKey: .idUser)
        self.lang = try values.decodeIfPresent(String.self, forKey: .lang)
        self.role = try values.decode(Role.self, forKey: .role)
        self.statut = try values.decode(Int.self, forKey: .statut)
    }
}

/// Example:
///
/// {
///   "id" : 0,
///   "id_connector_source" : 0,
///   "status" : null
/// }
public struct Psd2Registration: Codable {
    public var id: Int
    /// ID of the connector source
    public var idConnectorSource: Int?
    /// Current status: created/updated/error
    public var status: String

    public init(id: Int, idConnectorSource: Int? = nil, status: String) {
        self.id = id
        self.idConnectorSource = idConnectorSource
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case idConnectorSource = "id_connector_source"
        case status
    }
}

/// Keep traces of PSD2 registration calls.
///     The table is used by the plugin `psd2registration` to know:
///      - whether it must call `update` or `create` routes on the PSD2 APIs when the config is updated
///      - the list of PSD2 API to create (needed when a new connector is added)
///      - the list of broken connectors
///
/// Example:
///
/// {
///   "created_at" : "2021-08-23 10:35:44.620718",
///   "error_message" : null,
///   "id" : 0,
///   "id_psd2registration" : 0,
///   "type" : null
/// }
public struct Psd2RegistrationLog: Codable {
    /// When this row was created
    public var createdAt: Date
    /// If fail, error message received from connector
    public var errorMessage: String?
    public var id: Int
    /// ID of the psd2 registration
    public var idPsd2registration: Int?
    /// Action done: create, update, delete
    public var type: String

    public init(createdAt: Date, errorMessage: String? = nil, id: Int, idPsd2registration: Int? = nil, type: String) {
        self.createdAt = createdAt
        self.errorMessage = errorMessage
        self.id = id
        self.idPsd2registration = idPsd2registration
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case errorMessage = "error_message"
        case id
        case idPsd2registration = "id_psd2registration"
        case type
    }
}

/// Example:
///
/// {
///   "add_verified" : false,
///   "bank_name" : null,
///   "category" : null,
///   "currency" : null,
///   "deleted" : "2021-08-23 10:35:44.378670",
///   "enabled_at" : "2021-08-23 10:35:44.378801",
///   "error" : null,
///   "expire" : "2021-08-23 10:35:44.378737",
///   "iban" : null,
///   "id" : 0,
///   "id_account" : 0,
///   "id_target_account" : 0,
///   "label" : null,
///   "last_update" : "2021-08-23 10:35:44.378535",
///   "state" : null,
///   "time_scraped" : "2021-08-23 10:35:44.378602",
///   "webid" : null
/// }
public struct Recipient: Codable {
    /// Was the recipient adding authorized
    public var isAddVerified: Bool?
    /// Bank of the recipient
    public var bankName: String?
    /// Category in which the recipient is
    public var category: String
    /// Currency of the object
    public var currency: [String: AnyJSON]?
    /// The recipient isn't found anymore on the bank
    public var deleted: Date?
    /// It will be possible to do transfers to this recipient at this date
    public var enabledAt: Date?
    /// Error message
    public var error: String?
    public var expire: Date?
    /// Fields for recipient with additionalInformationNeeded state
    public var fields: String?
    /// IBAN of the recipient
    public var iban: String?
    /// ID of the recipient
    public var id: Int
    /// ID of the related account
    public var idAccount: Int
    /// ID of the target account, in case of internal recipient
    public var idTargetAccount: Int?
    /// Label of the recipient
    public var label: String
    /// Last time we have fetched this recipient
    public var lastUpdate: Date
    /// State of recipient
    public var state: String?
    /// First time we've seen this recipient
    public var timeScraped: Date?
    /// Webid of the recipient
    public var webid: String?

    public init(isAddVerified: Bool? = nil, bankName: String? = nil, category: String, currency: [String: AnyJSON]? = nil, deleted: Date? = nil, enabledAt: Date? = nil, error: String? = nil, expire: Date? = nil, fields: String? = nil, iban: String? = nil, id: Int, idAccount: Int, idTargetAccount: Int? = nil, label: String, lastUpdate: Date, state: String? = nil, timeScraped: Date? = nil, webid: String? = nil) {
        self.isAddVerified = isAddVerified
        self.bankName = bankName
        self.category = category
        self.currency = currency
        self.deleted = deleted
        self.enabledAt = enabledAt
        self.error = error
        self.expire = expire
        self.fields = fields
        self.iban = iban
        self.id = id
        self.idAccount = idAccount
        self.idTargetAccount = idTargetAccount
        self.label = label
        self.lastUpdate = lastUpdate
        self.state = state
        self.timeScraped = timeScraped
        self.webid = webid
    }

    private enum CodingKeys: String, CodingKey {
        case isAddVerified = "add_verified"
        case bankName = "bank_name"
        case category
        case currency
        case deleted
        case enabledAt = "enabled_at"
        case error
        case expire
        case fields
        case iban
        case id
        case idAccount = "id_account"
        case idTargetAccount = "id_target_account"
        case label
        case lastUpdate = "last_update"
        case state
        case timeScraped = "time_scraped"
        case webid
    }
}

/// Example:
///
/// {
///   "error" : null,
///   "id" : 0,
///   "id_file" : 0,
///   "id_recipient" : 0,
///   "request_data" : null,
///   "step" : null,
///   "timestamp" : "<function datetime.now at 0x7f5740ef61e0>"
/// }
public struct RecipientLog: Codable {
    /// Error message during recipient addition, if any
    public var error: String?
    /// Fields for recipient in additionalInformationNeeded state with background option
    public var fields: String?
    /// ID of the transfer log entry
    public var id: Int
    /// ID of the related file
    public var idFile: Int?
    /// ID of the related recipient
    public var idRecipient: Int?
    /// Data stored related to user who has requested the recipient addition
    public var requestData: String?
    /// Step of recipient addition, (add_recipient, asking_field, recipient addition validated, creation, storing_files)
    public var step: String?
    /// Timestamp of the log
    public var timestamp: Date

    public init(error: String? = nil, fields: String? = nil, id: Int, idFile: Int? = nil, idRecipient: Int? = nil, requestData: String? = nil, step: String? = nil, timestamp: Date) {
        self.error = error
        self.fields = fields
        self.id = id
        self.idFile = idFile
        self.idRecipient = idRecipient
        self.requestData = requestData
        self.step = step
        self.timestamp = timestamp
    }

    private enum CodingKeys: String, CodingKey {
        case error
        case fields
        case id
        case idFile = "id_file"
        case idRecipient = "id_recipient"
        case requestData = "request_data"
        case step
        case timestamp
    }
}

/// Example:
///
/// {
///   "code" : null,
///   "id" : 0,
///   "id_type" : 0,
///   "last_update" : "2021-08-23 10:35:44.162155",
///   "name" : null
/// }
public struct Security: Codable {
    /// ISIN code of the security
    public var code: String?
    /// ID of the security
    public var id: Int
    /// ID of the security type
    public var idType: Int?
    /// Last update of the security
    public var lastUpdate: Date?
    /// Name of the security
    public var name: String

    public init(code: String? = nil, id: Int, idType: Int? = nil, lastUpdate: Date? = nil, name: String) {
        self.code = code
        self.id = id
        self.idType = idType
        self.lastUpdate = lastUpdate
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case code
        case id
        case idType = "id_type"
        case lastUpdate = "last_update"
        case name
    }
}

/// Example:
///
/// {
///   "deleted" : "2021-08-23 10:35:44.400732",
///   "disabled" : "2021-08-23 10:35:44.400809",
///   "error" : null,
///   "id" : 0,
///   "id_connection" : 0,
///   "id_source" : 0,
///   "id_user" : 0,
///   "label" : null,
///   "last_update" : "2021-08-23 10:35:44.400663",
///   "number" : null,
///   "renewdate" : "2021-08-23",
///   "subscriber" : null,
///   "validity" : "2021-08-23"
/// }
public struct Subscription: Codable {
    /// This subscription is not found on the website anymore
    public var deleted: Date?
    /// This subscription has been deleted by user and will not be synchronized anymore
    public var disabled: Date?
    /// If the last update has failed, the error code
    public var error: String?
    /// ID of subscription
    public var id: Int
    /// ID of related connection
    public var idConnection: Int?
    /// ID of the related connection source
    public var idSource: Int?
    /// ID of related user
    public var idUser: Int?
    /// Label of the subscription
    public var label: String
    /// Last successful update of the subscription
    public var lastUpdate: Date?
    /// Subscription's number
    public var number: String
    /// Next renew date, if any
    public var renewdate: NaiveDate?
    /// Name of the subscriber
    public var subscriber: String?
    /// The subscription is valid until this date, if any
    public var validity: NaiveDate?

    public init(deleted: Date? = nil, disabled: Date? = nil, error: String? = nil, id: Int, idConnection: Int? = nil, idSource: Int? = nil, idUser: Int? = nil, label: String, lastUpdate: Date? = nil, number: String, renewdate: NaiveDate? = nil, subscriber: String? = nil, validity: NaiveDate? = nil) {
        self.deleted = deleted
        self.disabled = disabled
        self.error = error
        self.id = id
        self.idConnection = idConnection
        self.idSource = idSource
        self.idUser = idUser
        self.label = label
        self.lastUpdate = lastUpdate
        self.number = number
        self.renewdate = renewdate
        self.subscriber = subscriber
        self.validity = validity
    }

    private enum CodingKeys: String, CodingKey {
        case deleted
        case disabled
        case error
        case id
        case idConnection = "id_connection"
        case idSource = "id_source"
        case idUser = "id_user"
        case label
        case lastUpdate = "last_update"
        case number
        case renewdate
        case subscriber
        case validity
    }
}

/// Example:
///
/// {
///   "error" : null,
///   "error_message" : null,
///   "id" : 0,
///   "id_connection_log" : 0,
///   "id_source" : 0,
///   "id_subscription" : 0,
///   "nb_docs" : 0,
///   "timestamp" : "<function datetime.now at 0x7f5740bab400>"
/// }
public struct SubscriptionLog: Codable {
    /// If fail, contains the error code
    public var error: String?
    /// If fail, error message received from provider
    public var errorMessage: String?
    /// ID of the log
    public var id: Int
    /// ID of the related connection log
    public var idConnectionLog: Int?
    /// ID of the related connection source
    public var idSource: Int?
    /// ID of the related subscription
    public var idSubscription: Int
    /// Number of docs on the subscription
    public var nbDocs: Int?
    /// Timestamp of log
    public var timestamp: Date

    public init(error: String? = nil, errorMessage: String? = nil, id: Int, idConnectionLog: Int? = nil, idSource: Int? = nil, idSubscription: Int, nbDocs: Int? = nil, timestamp: Date) {
        self.error = error
        self.errorMessage = errorMessage
        self.id = id
        self.idConnectionLog = idConnectionLog
        self.idSource = idSource
        self.idSubscription = idSubscription
        self.nbDocs = nbDocs
        self.timestamp = timestamp
    }

    private enum CodingKeys: String, CodingKey {
        case error
        case errorMessage = "error_message"
        case id
        case idConnectionLog = "id_connection_log"
        case idSource = "id_source"
        case idSubscription = "id_subscription"
        case nbDocs = "nb_docs"
        case timestamp
    }
}

/// Example:
///
/// {
///   "created" : "2021-08-23 10:35:44.452486",
///   "deleted" : "2021-08-23 10:35:44.452561",
///   "id" : 0,
///   "version" : null
/// }
public struct TermsOfService: Codable {
    public var created: Date
    public var deleted: Date?
    public var id: Int
    public var version: String

    public init(created: Date, deleted: Date? = nil, id: Int, version: String) {
        self.created = created
        self.deleted = deleted
        self.id = id
        self.version = version
    }
}

/// Example:
///
/// {
///   "active" : true,
///   "application_date" : "2021-08-23",
///   "bdate" : "2021-08-23",
///   "bdatetime" : "2021-08-23 10:35:44.313780",
///   "card" : null,
///   "coming" : false,
///   "comment" : null,
///   "commission" : 0,
///   "commission_currency" : null,
///   "counterparty" : null,
///   "country" : null,
///   "date" : "2021-08-23",
///   "date_scraped" : "2021-08-23 10:35:44.312472",
///   "datetime" : "2021-08-23 10:35:44.311470",
///   "deleted" : "2021-08-23 10:35:44.314252",
///   "gross_value" : 0,
///   "id" : 0,
///   "id_account" : 0,
///   "id_category" : 0,
///   "id_cluster" : 0,
///   "last_update" : "2021-08-23 10:35:44.314171",
///   "nature" : "inconnu",
///   "original_currency" : null,
///   "original_gross_value" : 0,
///   "original_value" : 0,
///   "rdate" : "2021-08-23",
///   "rdatetime" : "2021-08-23 10:35:44.312932",
///   "state" : "new",
///   "value" : 0,
///   "vdate" : "2021-08-23",
///   "vdatetime" : "2021-08-23 10:35:44.313366",
///   "webid" : null,
///   "wording" : null
/// }
public struct Transaction: Codable {
    /// If false, PFM services will ignore this transaction
    public var isActive: Bool
    /// Date considered by PFM services. It is used to change the month of a transaction, for example.
    public var applicationDate: NaiveDate?
    /// Date used by the bank for the transaction
    public var bdate: NaiveDate?
    /// Datetime used by the bank
    public var bdatetime: Date?
    /// Card number associated to the transaction
    public var card: String?
    /// If true, this transaction hasn't been yet debited
    public var isComing: Bool
    /// User comment
    public var comment: String?
    /// Commission taken on the transaction
    public var commission: Double?
    /// Commission currency
    public var commissionCurrency: [String: AnyJSON]?
    /// Counterparty
    public var counterparty: String?
    /// Original country
    public var country: String?
    /// Debit date
    public var date: NaiveDate
    /// Date when the transaction has been seen
    public var dateScraped: Date
    /// Datetime of the debit of the transaction
    public var datetime: Date?
    /// If set, this transaction has been removed from the bank
    public var deleted: Date?
    /// Gross value of the transaction
    public var grossValue: Double?
    /// ID of the transaction
    public var id: Int
    /// ID of the related account
    public var idAccount: Int
    /// ID of the related category
    public var idCategory: Int?
    /// If the transaction is part of a cluster
    public var idCluster: Int?
    /// Last update of the transaction
    public var lastUpdate: Date?
    /// Type of transaction
    public var nature: String
    /// Original currency
    public var originalCurrency: [String: AnyJSON]?
    /// Gross value in the original currency
    public var originalGrossValue: Double?
    /// Value in the original currency
    public var originalValue: Double?
    /// Full label of the transaction
    public var originalWording: String
    /// Realization of the transaction
    public var rdate: NaiveDate
    /// Datetime of the realization of the transaction
    public var rdatetime: Date?
    /// Simplified label of the transaction
    public var simplifiedWording: String
    /// Internal state of the transaction
    public var state: String
    /// Do not use it
    public var stemmedWording: String
    /// Value of the transaction
    public var value: Double?
    /// Value date of the transaction
    public var vdate: NaiveDate?
    /// Datetime of the Value of the transaction
    public var vdatetime: Date?
    /// Webid of the transaction
    public var webid: String?
    /// Label set by the user
    public var wording: String?

    public init(isActive: Bool, applicationDate: NaiveDate? = nil, bdate: NaiveDate? = nil, bdatetime: Date? = nil, card: String? = nil, isComing: Bool, comment: String? = nil, commission: Double? = nil, commissionCurrency: [String: AnyJSON]? = nil, counterparty: String? = nil, country: String? = nil, date: NaiveDate, dateScraped: Date, datetime: Date? = nil, deleted: Date? = nil, grossValue: Double? = nil, id: Int, idAccount: Int, idCategory: Int? = nil, idCluster: Int? = nil, lastUpdate: Date? = nil, nature: String, originalCurrency: [String: AnyJSON]? = nil, originalGrossValue: Double? = nil, originalValue: Double? = nil, originalWording: String, rdate: NaiveDate, rdatetime: Date? = nil, simplifiedWording: String, state: String, stemmedWording: String, value: Double? = nil, vdate: NaiveDate? = nil, vdatetime: Date? = nil, webid: String? = nil, wording: String? = nil) {
        self.isActive = isActive
        self.applicationDate = applicationDate
        self.bdate = bdate
        self.bdatetime = bdatetime
        self.card = card
        self.isComing = isComing
        self.comment = comment
        self.commission = commission
        self.commissionCurrency = commissionCurrency
        self.counterparty = counterparty
        self.country = country
        self.date = date
        self.dateScraped = dateScraped
        self.datetime = datetime
        self.deleted = deleted
        self.grossValue = grossValue
        self.id = id
        self.idAccount = idAccount
        self.idCategory = idCategory
        self.idCluster = idCluster
        self.lastUpdate = lastUpdate
        self.nature = nature
        self.originalCurrency = originalCurrency
        self.originalGrossValue = originalGrossValue
        self.originalValue = originalValue
        self.originalWording = originalWording
        self.rdate = rdate
        self.rdatetime = rdatetime
        self.simplifiedWording = simplifiedWording
        self.state = state
        self.stemmedWording = stemmedWording
        self.value = value
        self.vdate = vdate
        self.vdatetime = vdatetime
        self.webid = webid
        self.wording = wording
    }

    private enum CodingKeys: String, CodingKey {
        case isActive = "active"
        case applicationDate = "application_date"
        case bdate
        case bdatetime
        case card
        case isComing = "coming"
        case comment
        case commission
        case commissionCurrency = "commission_currency"
        case counterparty
        case country
        case date
        case dateScraped = "date_scraped"
        case datetime
        case deleted
        case grossValue = "gross_value"
        case id
        case idAccount = "id_account"
        case idCategory = "id_category"
        case idCluster = "id_cluster"
        case lastUpdate = "last_update"
        case nature
        case originalCurrency = "original_currency"
        case originalGrossValue = "original_gross_value"
        case originalValue = "original_value"
        case originalWording = "original_wording"
        case rdate
        case rdatetime
        case simplifiedWording = "simplified_wording"
        case state
        case stemmedWording = "stemmed_wording"
        case value
        case vdate
        case vdatetime
        case webid
        case wording
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isActive = try values.decode(Bool.self, forKey: .isActive)
        self.applicationDate = try values.decodeIfPresent(NaiveDate.self, forKey: .applicationDate)
        self.bdate = try values.decodeIfPresent(NaiveDate.self, forKey: .bdate)
        self.bdatetime = try values.decodeIfPresent(Date.self, forKey: .bdatetime)
        self.card = try values.decodeIfPresent(String.self, forKey: .card)
        self.isComing = try values.decode(Bool.self, forKey: .isComing)
        self.comment = try values.decodeIfPresent(String.self, forKey: .comment)
        self.commission = try values.decodeIfPresent(Double.self, forKey: .commission)
        self.commissionCurrency = try values.decodeIfPresent([String: AnyJSON].self, forKey: .commissionCurrency)
        self.counterparty = try values.decodeIfPresent(String.self, forKey: .counterparty)
        self.country = try values.decodeIfPresent(String.self, forKey: .country)
        self.date = try values.decode(NaiveDate.self, forKey: .date)
        self.dateScraped = try values.decode(Date.self, forKey: .dateScraped)
        self.datetime = try values.decodeIfPresent(Date.self, forKey: .datetime)
        self.deleted = try values.decodeIfPresent(Date.self, forKey: .deleted)
        self.grossValue = try values.decodeIfPresent(Double.self, forKey: .grossValue)
        self.id = try values.decode(Int.self, forKey: .id)
        self.idAccount = try values.decode(Int.self, forKey: .idAccount)
        self.idCategory = try values.decodeIfPresent(Int.self, forKey: .idCategory)
        self.idCluster = try values.decodeIfPresent(Int.self, forKey: .idCluster)
        self.lastUpdate = try values.decodeIfPresent(Date.self, forKey: .lastUpdate)
        self.nature = try values.decode(String.self, forKey: .nature)
        self.originalCurrency = try values.decodeIfPresent([String: AnyJSON].self, forKey: .originalCurrency)
        self.originalGrossValue = try values.decodeIfPresent(Double.self, forKey: .originalGrossValue)
        self.originalValue = try values.decodeIfPresent(Double.self, forKey: .originalValue)
        self.originalWording = try values.decode(String.self, forKey: .originalWording)
        self.rdate = try values.decode(NaiveDate.self, forKey: .rdate)
        self.rdatetime = try values.decodeIfPresent(Date.self, forKey: .rdatetime)
        self.simplifiedWording = try values.decode(String.self, forKey: .simplifiedWording)
        self.state = try values.decode(String.self, forKey: .state)
        self.stemmedWording = try values.decode(String.self, forKey: .stemmedWording)
        self.value = try values.decodeIfPresent(Double.self, forKey: .value)
        self.vdate = try values.decodeIfPresent(NaiveDate.self, forKey: .vdate)
        self.vdatetime = try values.decodeIfPresent(Date.self, forKey: .vdatetime)
        self.webid = try values.decodeIfPresent(String.self, forKey: .webid)
        self.wording = try values.decodeIfPresent(String.self, forKey: .wording)
    }
}

/// Example:
///
/// {
///   "id" : 0,
///   "id_transaction" : 0,
///   "key" : null,
///   "value" : null
/// }
public struct TransactionInformation: Codable {
    /// ID of this transaction information
    public var id: Int
    /// ID of the related transaction
    public var idTransaction: Int
    /// Key of the transaction information
    public var key: String
    /// Value of the transaction information
    public var value: String?

    public init(id: Int, idTransaction: Int, key: String, value: String? = nil) {
        self.id = id
        self.idTransaction = idTransaction
        self.key = key
        self.value = value
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case idTransaction = "id_transaction"
        case key
        case value
    }
}

/// Example:
///
/// {
///   "created_by" : null,
///   "enabled" : true,
///   "id" : 0,
///   "id_account" : 0,
///   "id_category" : 0,
///   "mean_amount" : 0,
///   "median_increment" : 0,
///   "next_date" : "2021-08-23",
///   "wording" : null
/// }
public struct TransactionsCluster: Codable {
    public var createdBy: String?
    public var isEnabled: Bool
    public var id: Int
    public var idAccount: Int
    public var idCategory: Int?
    public var meanAmount: Double
    public var medianIncrement: Int?
    public var nextDate: NaiveDate?
    public var wording: String

    public init(createdBy: String? = nil, isEnabled: Bool, id: Int, idAccount: Int, idCategory: Int? = nil, meanAmount: Double, medianIncrement: Int? = nil, nextDate: NaiveDate? = nil, wording: String) {
        self.createdBy = createdBy
        self.isEnabled = isEnabled
        self.id = id
        self.idAccount = idAccount
        self.idCategory = idCategory
        self.meanAmount = meanAmount
        self.medianIncrement = medianIncrement
        self.nextDate = nextDate
        self.wording = wording
    }

    private enum CodingKeys: String, CodingKey {
        case createdBy = "created_by"
        case isEnabled = "enabled"
        case id
        case idAccount = "id_account"
        case idCategory = "id_category"
        case meanAmount = "mean_amount"
        case medianIncrement = "median_increment"
        case nextDate = "next_date"
        case wording
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.createdBy = try values.decodeIfPresent(String.self, forKey: .createdBy)
        self.isEnabled = try values.decode(Bool.self, forKey: .isEnabled)
        self.id = try values.decode(Int.self, forKey: .id)
        self.idAccount = try values.decode(Int.self, forKey: .idAccount)
        self.idCategory = try values.decodeIfPresent(Int.self, forKey: .idCategory)
        self.meanAmount = try values.decode(Double.self, forKey: .meanAmount)
        self.medianIncrement = try values.decodeIfPresent(Int.self, forKey: .medianIncrement)
        self.nextDate = try values.decodeIfPresent(NaiveDate.self, forKey: .nextDate)
        self.wording = try values.decode(String.self, forKey: .wording)
    }
}

/// This is a representation of a transfer.
///
/// Example:
///
/// {
///   "account_balance" : 0,
///   "account_iban" : null,
///   "amount" : 0,
///   "beneficiary_label" : null,
///   "beneficiary_number" : null,
///   "beneficiary_type" : "recipient",
///   "currency" : null,
///   "error" : null,
///   "exec_date" : "2021-08-23",
///   "fees" : 0,
///   "id" : 0,
///   "id_account" : 0,
///   "id_recipient" : 0,
///   "id_transaction" : 0,
///   "id_user" : 0,
///   "label" : null,
///   "recipient_iban" : null,
///   "register_date" : "2021-08-23 10:35:44.320560",
///   "state" : null,
///   "validate_mechanism" : null,
///   "webid" : null
/// }
public struct Transfer: Codable {
    /// Balance of the account just before the transfer
    public var accountBalance: Double?
    /// IBAN of the debited account
    public var accountIban: String?
    /// Amount of the transfer
    public var amount: Double
    /// Label of the beneficiary (needed for transfer to other beneficiary type than 'recipient')
    public var beneficiaryLabel: String?
    /// Beneficiary bank identifier value like recipient webid, iban: EX6713281847025300290000062 or phone_number: 06XXXXXX
    public var beneficiaryNumber: String?
    /// Type of beneficiary number, for example: 'recipient' (in bank recipient list), 'iban' or 'phone_number'
    public var beneficiaryType: String
    /// Currency of the object
    public var currency: [String: AnyJSON]?
    /// Error message during transfer, if any
    public var error: String?
    /// Date when the transfer will be operated by the bank
    public var execDate: NaiveDate
    /// Fees taken by the bank
    public var fees: Double?
    /// ID of transfer
    public var id: Int
    /// ID of the debited account
    public var idAccount: Int?
    /// ID of the recipient
    public var idRecipient: Int?
    /// If found, ID of the related transaction
    public var idTransaction: Int?
    /// ID of the related user
    public var idUser: Int?
    /// Label of the transfer
    public var label: String?
    /// IBAN of the recipient in bank recipient list
    public var recipientIban: String?
    /// Date when the transfer has been registered
    public var registerDate: Date
    /// State of the transfer (created, scheduled, validating, pending, coming, done, canceled, transactionNotFound, deleted, error, bug)
    public var state: String
    /// Authentication method used to validate transfer (credentials or webauth)
    public var validateMechanism: String?
    /// WebID of the transfer
    public var webid: String?

    public init(accountBalance: Double? = nil, accountIban: String? = nil, amount: Double, beneficiaryLabel: String? = nil, beneficiaryNumber: String? = nil, beneficiaryType: String, currency: [String: AnyJSON]? = nil, error: String? = nil, execDate: NaiveDate, fees: Double? = nil, id: Int, idAccount: Int? = nil, idRecipient: Int? = nil, idTransaction: Int? = nil, idUser: Int? = nil, label: String? = nil, recipientIban: String? = nil, registerDate: Date, state: String, validateMechanism: String? = nil, webid: String? = nil) {
        self.accountBalance = accountBalance
        self.accountIban = accountIban
        self.amount = amount
        self.beneficiaryLabel = beneficiaryLabel
        self.beneficiaryNumber = beneficiaryNumber
        self.beneficiaryType = beneficiaryType
        self.currency = currency
        self.error = error
        self.execDate = execDate
        self.fees = fees
        self.id = id
        self.idAccount = idAccount
        self.idRecipient = idRecipient
        self.idTransaction = idTransaction
        self.idUser = idUser
        self.label = label
        self.recipientIban = recipientIban
        self.registerDate = registerDate
        self.state = state
        self.validateMechanism = validateMechanism
        self.webid = webid
    }

    private enum CodingKeys: String, CodingKey {
        case accountBalance = "account_balance"
        case accountIban = "account_iban"
        case amount
        case beneficiaryLabel = "beneficiary_label"
        case beneficiaryNumber = "beneficiary_number"
        case beneficiaryType = "beneficiary_type"
        case currency
        case error
        case execDate = "exec_date"
        case fees
        case id
        case idAccount = "id_account"
        case idRecipient = "id_recipient"
        case idTransaction = "id_transaction"
        case idUser = "id_user"
        case label
        case recipientIban = "recipient_iban"
        case registerDate = "register_date"
        case state
        case validateMechanism = "validate_mechanism"
        case webid
    }
}

/// Example:
///
/// {
///   "error" : null,
///   "id" : 0,
///   "id_file" : 0,
///   "id_transfer" : 0,
///   "request_data" : null,
///   "state" : null,
///   "timestamp" : "<function datetime.now at 0x7f5740ef6510>"
/// }
public struct TransferLog: Codable {
    /// Error message during transfer, if any
    public var error: String?
    /// Fields for transfer in additionalInformationNeeded state with background option
    public var fields: String?
    /// ID of the transfer log entry
    public var id: Int
    /// ID of the related file
    public var idFile: Int?
    /// ID of the related transfer
    public var idTransfer: Int?
    /// Data stored related to user who has requested the transfer
    public var requestData: String?
    /// State of the transfer (created, scheduled, validating, pending, done, canceled, error, bug)
    public var state: String?
    /// Timestamp of the log
    public var timestamp: Date

    public init(error: String? = nil, fields: String? = nil, id: Int, idFile: Int? = nil, idTransfer: Int? = nil, requestData: String? = nil, state: String? = nil, timestamp: Date) {
        self.error = error
        self.fields = fields
        self.id = id
        self.idFile = idFile
        self.idTransfer = idTransfer
        self.requestData = requestData
        self.state = state
        self.timestamp = timestamp
    }

    private enum CodingKeys: String, CodingKey {
        case error
        case fields
        case id
        case idFile = "id_file"
        case idTransfer = "id_transfer"
        case requestData = "request_data"
        case state
        case timestamp
    }
}

/// Example:
///
/// {
///   "id" : 0,
///   "platform" : null,
///   "signin" : "<function datetime.now at 0x7f5740c71620>"
/// }
public struct User: Codable {
    public var id: Int
    public var platform: Platform
    public var signin: Date

    public enum Platform: String, Codable, CaseIterable {
        case web
        case iPad
        case iPhone
        case android = "Android"
        case cAstore = "CAstore"
        case requestAccess
        case sharedAccess
        case singleAccess
        case transfer
        case refreshToken = "refresh_token"
    }

    public init(id: Int, platform: Platform, signin: Date) {
        self.id = id
        self.platform = platform
        self.signin = signin
    }
}

/// /!\ Careful we use default value from database if present
/// 
///     For more information see AlertsPlugin.init
///
/// Example:
///
/// {
///   "apply" : null,
///   "balance_max" : 10000,
///   "balance_min1" : 500,
///   "balance_min2" : 0,
///   "date_range" : 0,
///   "enabled" : true,
///   "expense_max" : 500,
///   "id" : 0,
///   "income_max" : 500,
///   "resume_enabled" : true,
///   "resume_frequency" : 7,
///   "transaction_types" : null,
///   "type" : "transactions",
///   "value_type" : "flat"
/// }
public struct UserAlert: Codable {
    public var apply: String?
    public var balanceMax: Double?
    public var balanceMin1: Double?
    public var balanceMin2: Double?
    public var dateRange: Int?
    public var isEnabled: Bool
    public var expenseMax: Double?
    public var id: Int
    public var incomeMax: Double?
    public var isResumeEnabled: Bool
    public var resumeFrequency: Int
    public var transactionTypes: String?
    public var type: String
    public var valueType: String

    public init(apply: String? = nil, balanceMax: Double? = nil, balanceMin1: Double? = nil, balanceMin2: Double? = nil, dateRange: Int? = nil, isEnabled: Bool? = nil, expenseMax: Double? = nil, id: Int, incomeMax: Double? = nil, isResumeEnabled: Bool? = nil, resumeFrequency: Int, transactionTypes: String? = nil, type: String, valueType: String) {
        self.apply = apply
        self.balanceMax = balanceMax
        self.balanceMin1 = balanceMin1
        self.balanceMin2 = balanceMin2
        self.dateRange = dateRange
        self.isEnabled = isEnabled ?? true
        self.expenseMax = expenseMax
        self.id = id
        self.incomeMax = incomeMax
        self.isResumeEnabled = isResumeEnabled ?? true
        self.resumeFrequency = resumeFrequency
        self.transactionTypes = transactionTypes
        self.type = type
        self.valueType = valueType
    }

    private enum CodingKeys: String, CodingKey {
        case apply
        case balanceMax = "balance_max"
        case balanceMin1 = "balance_min1"
        case balanceMin2 = "balance_min2"
        case dateRange = "date_range"
        case isEnabled = "enabled"
        case expenseMax = "expense_max"
        case id
        case incomeMax = "income_max"
        case isResumeEnabled = "resume_enabled"
        case resumeFrequency = "resume_frequency"
        case transactionTypes = "transaction_types"
        case type
        case valueType = "value_type"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.apply = try values.decodeIfPresent(String.self, forKey: .apply)
        self.balanceMax = try values.decodeIfPresent(Double.self, forKey: .balanceMax)
        self.balanceMin1 = try values.decodeIfPresent(Double.self, forKey: .balanceMin1)
        self.balanceMin2 = try values.decodeIfPresent(Double.self, forKey: .balanceMin2)
        self.dateRange = try values.decodeIfPresent(Int.self, forKey: .dateRange)
        self.isEnabled = try values.decodeIfPresent(Bool.self, forKey: .isEnabled) ?? true
        self.expenseMax = try values.decodeIfPresent(Double.self, forKey: .expenseMax)
        self.id = try values.decode(Int.self, forKey: .id)
        self.incomeMax = try values.decodeIfPresent(Double.self, forKey: .incomeMax)
        self.isResumeEnabled = try values.decodeIfPresent(Bool.self, forKey: .isResumeEnabled) ?? true
        self.resumeFrequency = try values.decode(Int.self, forKey: .resumeFrequency)
        self.transactionTypes = try values.decodeIfPresent(String.self, forKey: .transactionTypes)
        self.type = try values.decode(String.self, forKey: .type)
        self.valueType = try values.decode(String.self, forKey: .valueType)
    }
}

/// Example:
///
/// {
///   "created" : "2021-08-23 10:35:44.609103",
///   "deleted" : "2021-08-23 10:35:44.609425",
///   "id" : 0,
///   "id_auth" : 0,
///   "id_event" : 0,
///   "id_service" : 0,
///   "id_user" : 0,
///   "updated" : "2021-08-23 10:35:44.609274",
///   "url" : null
/// }
public struct Webhook: Codable {
    /// Json value to describe data to add
    public var addToData: String?
    /// Date of the webhook creation
    public var created: Date
    /// Date of the webhook deletion
    public var deleted: Date?
    /// Json value to store last related webhook data flushing fail
    public var flushFail: String?
    /// ID of the webhook
    public var id: Int
    /// ID of the authentication process
    public var idAuth: Int?
    /// ID of the webhook event
    public var idEvent: Int?
    /// ID of the service
    public var idService: Int?
    /// ID of the emitter user
    public var idUser: Int?
    /// Date of the webhook last update
    public var updated: Date
    /// URL of the webhook
    public var url: String?

    public init(addToData: String? = nil, created: Date, deleted: Date? = nil, flushFail: String? = nil, id: Int, idAuth: Int? = nil, idEvent: Int? = nil, idService: Int? = nil, idUser: Int? = nil, updated: Date, url: String? = nil) {
        self.addToData = addToData
        self.created = created
        self.deleted = deleted
        self.flushFail = flushFail
        self.id = id
        self.idAuth = idAuth
        self.idEvent = idEvent
        self.idService = idService
        self.idUser = idUser
        self.updated = updated
        self.url = url
    }

    private enum CodingKeys: String, CodingKey {
        case addToData = "add_to_data"
        case created
        case deleted
        case flushFail = "flush_fail"
        case id
        case idAuth = "id_auth"
        case idEvent = "id_event"
        case idService = "id_service"
        case idUser = "id_user"
        case updated
        case url
    }
}

/// Example:
///
/// {
///   "created" : "2021-08-23 10:35:44.613621",
///   "id" : 0,
///   "id_resource" : 0,
///   "id_service" : 0,
///   "id_user" : 0,
///   "id_webhook" : 0,
///   "mimetype" : null,
///   "success" : "2021-08-23 10:35:44.613701"
/// }
public struct WebhookData: Codable {
    /// Timestamp when the hook data was generated
    public var created: Date
    /// Data emitted
    public var data: String?
    /// ID of the webhook data
    public var id: Int
    /// A changing ID used to filter webhookdata depending on the event triggered
    public var idResource: Int?
    /// ID of the recipient service
    public var idService: Int?
    /// ID of the emitter user
    public var idUser: Int?
    /// ID of the webhook
    public var idWebhook: Int?
    /// Mimetype of the data
    public var mimetype: String?
    /// Timestamp when the hook has been successfully called
    public var success: Date?

    public init(created: Date, data: String? = nil, id: Int, idResource: Int? = nil, idService: Int? = nil, idUser: Int? = nil, idWebhook: Int? = nil, mimetype: String? = nil, success: Date? = nil) {
        self.created = created
        self.data = data
        self.id = id
        self.idResource = idResource
        self.idService = idService
        self.idUser = idUser
        self.idWebhook = idWebhook
        self.mimetype = mimetype
        self.success = success
    }

    private enum CodingKeys: String, CodingKey {
        case created
        case data
        case id
        case idResource = "id_resource"
        case idService = "id_service"
        case idUser = "id_user"
        case idWebhook = "id_webhook"
        case mimetype
        case success
    }
}

/// Example:
///
/// {
///   "id" : 0,
///   "id_service" : 0,
///   "id_user" : 0,
///   "id_webhook_data" : 0,
///   "next_try" : "2021-08-23 10:35:44.614914",
///   "response_code" : 0,
///   "response_date" : "2021-08-23 10:35:44.614448",
///   "timestamp" : "2021-08-23 10:35:44.614374"
/// }
public struct WebhookLog: Codable {
    /// ID of the log
    public var id: Int
    /// ID of the service
    public var idService: Int?
    /// ID of the user
    public var idUser: Int?
    /// ID of the webhook data
    public var idWebhookData: Int?
    /// If the log is an error, do not retry to push before this timestamp
    public var nextTry: Date?
    /// Return code of the reply to the hook
    public var responseCode: Int?
    /// Timestamp of the reply to the hook
    public var responseDate: Date?
    /// Timestamp when the hook was sent
    public var timestamp: Date

    public init(id: Int, idService: Int? = nil, idUser: Int? = nil, idWebhookData: Int? = nil, nextTry: Date? = nil, responseCode: Int? = nil, responseDate: Date? = nil, timestamp: Date) {
        self.id = id
        self.idService = idService
        self.idUser = idUser
        self.idWebhookData = idWebhookData
        self.nextTry = nextTry
        self.responseCode = responseCode
        self.responseDate = responseDate
        self.timestamp = timestamp
    }

    private enum CodingKeys: String, CodingKey {
        case id
        case idService = "id_service"
        case idUser = "id_user"
        case idWebhookData = "id_webhook_data"
        case nextTry = "next_try"
        case responseCode = "response_code"
        case responseDate = "response_date"
        case timestamp
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
