// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import NaiveDate
import Get
import URLQueryEncoder

extension Paths {
    public static var accountTypes: AccountTypes {
        AccountTypes(path: "/account_types")
    }

    public struct AccountTypes {
        /// Path: `/account_types`
        public let path: String

        /// Get account types
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var accounttypes: [BudgeaAPI.AccountType]
            /// Total number of results
            public var total: Double?

            public init(accounttypes: [BudgeaAPI.AccountType], total: Double? = nil) {
                self.accounttypes = accounttypes
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.AccountTypes {
    public func idAccountType(_ idAccountType: Int) -> WithIDAccountType {
        WithIDAccountType(path: "\(path)/\(idAccountType)")
    }

    public struct WithIDAccountType {
        /// Path: `/account_types/{id_account_type}`
        public let path: String

        /// Get an account type
        public func get(expand: String? = nil) -> Request<BudgeaAPI.AccountType> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths {
    public static var admin: Admin {
        Admin(path: "/admin")
    }

    public struct Admin {
        /// Path: `/admin`
        public let path: String
    }
}

extension Paths.Admin {
    public var jwt: Jwt {
        Jwt(path: path + "/jwt")
    }

    public struct Jwt {
        /// Path: `/admin/jwt`
        public let path: String

        /// Generate a jwt manage token
        ///
        /// This endpoint generates a new jwt manage token. It requires an admin manage token to be used<br><br>
        public func post(_ body: Data? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            public var jwtToken: AnyJSON
            public var payload: AnyJSON

            public init(jwtToken: AnyJSON, payload: AnyJSON) {
                self.jwtToken = jwtToken
                self.payload = payload
            }

            private enum CodingKeys: String, CodingKey {
                case jwtToken = "jwt_token"
                case payload
            }
        }
    }
}

extension Paths {
    public static var auth: Auth {
        Auth(path: "/auth")
    }

    public struct Auth {
        /// Path: `/auth`
        public let path: String
    }
}

extension Paths.Auth {
    public var `init`: Init {
        Init(path: path + "/init")
    }

    public struct Init {
        /// Path: `/auth/init`
        public let path: String

        /// Create a new anonymous user
        ///
        /// This endpoint creates a new temporary token related to a new anonymous user.<br><br>It will expire 30 minutes after.<br><br>Note: if you supply client_id and client_secret, or if you call this endpoint with the manage_token, the token will be permanent.<br><br>
        public func post(_ body: Data? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            /// New token created for the new anonymous user
            public var authToken: String
            /// Duration in seconds of the token validity
            public var expiresIn: Int?
            /// Type of the token
            public var type: String

            public init(authToken: String, expiresIn: Int? = nil, type: String) {
                self.authToken = authToken
                self.expiresIn = expiresIn
                self.type = type
            }

            private enum CodingKeys: String, CodingKey {
                case authToken = "auth_token"
                case expiresIn = "expires_in"
                case type
            }
        }
    }
}

extension Paths.Auth {
    public var jwt: Jwt {
        Jwt(path: path + "/jwt")
    }

    public struct Jwt {
        /// Path: `/auth/jwt`
        public let path: String

        /// Generate a user jwt token
        ///
        /// This endpoint generates a new jwt token for the user. This token will last the time in minutes given by the config key auth.default_token_expire (permanent if this the parameter expire=False is given)<br><br>
        public func post(_ body: Data? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            /// The jwt token
            public var jwtToken: String
            /// The payload contained in the jwt token
            public var payload: [String: AnyJSON]

            public init(jwtToken: String, payload: [String: AnyJSON]) {
                self.jwtToken = jwtToken
                self.payload = payload
            }

            private enum CodingKeys: String, CodingKey {
                case jwtToken = "jwt_token"
                case payload
            }
        }
    }
}

extension Paths.Auth {
    public var renew: Renew {
        Renew(path: path + "/renew")
    }

    public struct Renew {
        /// Path: `/auth/renew`
        public let path: String

        /// Get a new access token given an user id and client credentials
        public func post(_ body: Data? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            /// The access token transformed from the temporary one
            public var accessToken: String
            /// The access token type
            public var tokenType: String

            public init(accessToken: String, tokenType: String) {
                self.accessToken = accessToken
                self.tokenType = tokenType
            }

            private enum CodingKeys: String, CodingKey {
                case accessToken = "access_token"
                case tokenType = "token_type"
            }
        }
    }
}

extension Paths.Auth {
    public var token: Token {
        Token(path: path + "/token")
    }

    public struct Token {
        /// Path: `/auth/token`
        public let path: String

        /// Login to API with credentials
        ///
        /// Request a new user token by giving an username and a password. Or a manage payment token by giving a client<br><br><br><br>
        public func post(_ body: Data? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            /// Duration in seconds of the token validity
            public var expiresIn: Int?
            /// The token scope
            public var scope: String
            /// The requested token
            public var token: String

            public init(expiresIn: Int? = nil, scope: String, token: String) {
                self.expiresIn = expiresIn
                self.scope = scope
                self.token = token
            }

            private enum CodingKeys: String, CodingKey {
                case expiresIn = "expires_in"
                case scope
                case token
            }
        }

        /// Remove user access
        ///
        /// This endpoint removes the token in use.<br><br>
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Auth.Token {
    public var access: Access {
        Access(path: path + "/access")
    }

    public struct Access {
        /// Path: `/auth/token/access`
        public let path: String

        /// Transform a temporary code to a access_token
        ///
        /// In order to register a new user with the OAuth 2 process, the client has to call this endpoint to request a granted access_token with the received temporary code.<br><br>
        public func post(_ body: Data? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            /// The access token transformed from the temporary one
            public var accessToken: String
            /// The access token type
            public var tokenType: String

            public init(accessToken: String, tokenType: String) {
                self.accessToken = accessToken
                self.tokenType = tokenType
            }

            private enum CodingKeys: String, CodingKey {
                case accessToken = "access_token"
                case tokenType = "token_type"
            }
        }
    }
}

extension Paths.Auth.Token {
    public var code: Code {
        Code(path: path + "/code")
    }

    public struct Code {
        /// Path: `/auth/token/code`
        public let path: String

        /// Generate a user temporary token
        ///
        /// This endpoint generates a new temporary token for the user.<br><br>In case the access_token is used by a trusted device, and you want to let another one (for example a web browser) access to user resources, use this service to create a token which will expire in 30 minutes.<br><br>Additionally, you can also generate a temporary single-use token by specifying 'type=singleAccess' as query parameter. A single-use token can only be used once no matter the endpoint being accessed.<br><br>
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// The reusability of a token (standard or single use)
            public var access: String
            /// The temporary token
            public var code: String
            /// Duration in seconds of the token validity
            public var expiresIn: Int
            /// The token type
            public var type: [String: AnyJSON]

            public init(access: String, code: String, expiresIn: Int, type: [String: AnyJSON]) {
                self.access = access
                self.code = code
                self.expiresIn = expiresIn
                self.type = type
            }

            private enum CodingKeys: String, CodingKey {
                case access
                case code
                case expiresIn = "expires_in"
                case type
            }
        }
    }
}

extension Paths {
    public static var banks: Banks {
        Banks(path: "/banks")
    }

    public struct Banks {
        /// Path: `/banks`
        public let path: String

        /// Get list of connectors
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var banks: [BudgeaAPI.Connector]
            /// Total number of results
            public var total: Double?

            public init(banks: [BudgeaAPI.Connector], total: Double? = nil) {
                self.banks = banks
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Banks {
    public var categories: Categories {
        Categories(path: path + "/categories")
    }

    public struct Categories {
        /// Path: `/banks/categories`
        public let path: String

        /// Create bank categories
        ///
        /// It requires the name of the category to be created<br><br>
        public func post(expand: String? = nil, _ body: Data) -> Request<BudgeaAPI.ConnectorCategory> {
            .post(path, query: makePostQuery(expand), body: body)
        }

        private func makePostQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Banks.Categories {
    public func idCategory(_ idCategory: Int) -> WithIDCategory {
        WithIDCategory(path: "\(path)/\(idCategory)")
    }

    public struct WithIDCategory {
        /// Path: `/banks/categories/{id_category}`
        public let path: String

        /// Edit a bank categories
        ///
        /// Edit the name for the supplied category.<br><br>
        public func post(expand: String? = nil, _ body: Data) -> Request<BudgeaAPI.ConnectorCategory> {
            .post(path, query: makePostQuery(expand), body: body)
        }

        private func makePostQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Delete the supplied category
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.ConnectorCategory> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Banks {
    public func idBank(_ idBank: Int) -> WithIDBank {
        WithIDBank(path: "\(path)/\(idBank)")
    }

    public struct WithIDBank {
        /// Path: `/banks/{id_bank}`
        public let path: String

        /// Get a connector
        public func get(expand: String? = nil) -> Request<BudgeaAPI.Connector> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Banks {
    public func idConnector(_ idConnector: Int) -> WithIDConnector {
        WithIDConnector(path: "\(path)/\(idConnector)")
    }

    public struct WithIDConnector {
        /// Path: `/banks/{id_connector}`
        public let path: String
    }
}

extension Paths.Banks.WithIDConnector {
    public var connections: Connections {
        Connections(path: path + "/connections")
    }

    public struct Connections {
        /// Path: `/banks/{id_connector}/connections`
        public let path: String

        /// Get a subset of id_connection for a given bank. Different selection methode are possible
        ///
        /// By default, it selects a set of 3 connections with the 'diversity' method<br><br>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var connections: [BudgeaAPI.Connection]
            /// Total number of results
            public var total: Double?

            public init(connections: [BudgeaAPI.Connection], total: Double? = nil) {
                self.connections = connections
                self.total = total
            }
        }

        public struct GetParameters {
            public var method: String?
            public var n: Int?
            public var type: Int?
            public var occurences: Int?
            public var source: String?
            public var minutesWithoutSync: Int?
            public var expand: String?

            public init(method: String? = nil, n: Int? = nil, type: Int? = nil, occurences: Int? = nil, source: String? = nil, minutesWithoutSync: Int? = nil, expand: String? = nil) {
                self.method = method
                self.n = n
                self.type = type
                self.occurences = occurences
                self.source = source
                self.minutesWithoutSync = minutesWithoutSync
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(method, forKey: "method")
                encoder.encode(n, forKey: "n")
                encoder.encode(type, forKey: "type")
                encoder.encode(occurences, forKey: "occurences")
                encoder.encode(source, forKey: "source")
                encoder.encode(minutesWithoutSync, forKey: "minutes_without_sync")
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.Banks.WithIDConnector {
    public var logos: Logos {
        Logos(path: path + "/logos")
    }

    public struct Logos {
        /// Path: `/banks/{id_connector}/logos`
        public let path: String

        /// Get all links to the files associated with this connector.
        ///
        /// This endpoint returns all links to files associated with this connector.<br><br>
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var connectorlogos: [BudgeaAPI.ConnectorLogo]
            /// Total number of results
            public var total: Double?

            public init(connectorlogos: [BudgeaAPI.ConnectorLogo], total: Double? = nil) {
                self.connectorlogos = connectorlogos
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Banks.WithIDConnector.Logos {
    public var main: Main {
        Main(path: path + "/main")
    }

    public struct Main {
        /// Path: `/banks/{id_connector}/logos/main`
        public let path: String

        /// Get all links to the files associated with this connector.
        ///
        /// This endpoint returns all links to files associated with this connector.<br><br>
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var connectorlogos: [BudgeaAPI.ConnectorLogo]
            /// Total number of results
            public var total: Double?

            public init(connectorlogos: [BudgeaAPI.ConnectorLogo], total: Double? = nil) {
                self.connectorlogos = connectorlogos
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Banks.WithIDConnector.Logos {
    public var thumbnail: Thumbnail {
        Thumbnail(path: path + "/thumbnail")
    }

    public struct Thumbnail {
        /// Path: `/banks/{id_connector}/logos/thumbnail`
        public let path: String

        /// Get all links to the files associated with this connector.
        ///
        /// This endpoint returns all links to files associated with this connector.<br><br>
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var connectorlogos: [BudgeaAPI.ConnectorLogo]
            /// Total number of results
            public var total: Double?

            public init(connectorlogos: [BudgeaAPI.ConnectorLogo], total: Double? = nil) {
                self.connectorlogos = connectorlogos
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Banks.WithIDConnector {
    public var sources: Sources {
        Sources(path: path + "/sources")
    }

    public struct Sources {
        /// Path: `/banks/{id_connector}/sources`
        public let path: String

        /// Get list of connector sources
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var sources: [BudgeaAPI.ConnectorSource]
            /// Total number of results
            public var total: Double?

            public init(sources: [BudgeaAPI.ConnectorSource], total: Double? = nil) {
                self.sources = sources
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Banks.WithIDConnector.Sources {
    public func idConnectorSource(_ idConnectorSource: Int) -> WithIDConnectorSource {
        WithIDConnectorSource(path: "\(path)/\(idConnectorSource)")
    }

    public struct WithIDConnectorSource {
        /// Path: `/banks/{id_connector}/sources/{id_connector_source}`
        public let path: String
    }
}

extension Paths.Banks.WithIDConnector.Sources.WithIDConnectorSource {
    public var fields: Fields {
        Fields(path: path + "/fields")
    }

    public struct Fields {
        /// Path: `/banks/{id_connector}/sources/{id_connector_source}/fields`
        public let path: String

        /// Get fields specific to a domain and a source
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var sourceFields: [BudgeaAPI.ConnectorSourceField]
            /// Total number of results
            public var total: Double?

            public init(sourceFields: [BudgeaAPI.ConnectorSourceField], total: Double? = nil) {
                self.sourceFields = sourceFields
                self.total = total
            }

            private enum CodingKeys: String, CodingKey {
                case sourceFields = "source_fields"
                case total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Banks.WithIDConnector.Sources {
    public func idSource(_ idSource: Int) -> WithIDSource {
        WithIDSource(path: "\(path)/\(idSource)")
    }

    public struct WithIDSource {
        /// Path: `/banks/{id_connector}/sources/{id_source}`
        public let path: String

        /// Get the connector source
        public func get(expand: String? = nil) -> Request<BudgeaAPI.ConnectorSource> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths {
    public static var categories: Categories {
        Categories(path: "/categories")
    }

    public struct Categories {
        /// Path: `/categories`
        public let path: String

        /// Get all categories
        ///
        /// Ressource to get all existing categories<br><br>
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var categories: [BudgeaAPI.Category]
            /// Total number of results
            public var total: Double?

            public init(categories: [BudgeaAPI.Category], total: Double? = nil) {
                self.categories = categories
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Categories {
    public var keywords: Keywords {
        Keywords(path: path + "/keywords")
    }

    public struct Keywords {
        /// Path: `/categories/keywords`
        public let path: String

        /// Add a new keyword associated with a category in the database.
        ///
        /// If the keyword already exists the keyword is not added. Used for the categorization of transactions.<br><br>Form params: - id_category (integer): a reference towards the category associated with the keyword - keyword (string): the searched keyword - income (bool): 1 if the associated category represents an income else 0 - priority (integer): sets the priority for the keyword, used when categorizing<br><br>
        public func post(expand: String? = nil) -> Request<BudgeaAPI.Keyword> {
            .post(path, query: makePostQuery(expand))
        }

        private func makePostQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Categories.Keywords {
    public func idKeyword(_ idKeyword: Int) -> WithIDKeyword {
        WithIDKeyword(path: "\(path)/\(idKeyword)")
    }

    public struct WithIDKeyword {
        /// Path: `/categories/keywords/{id_keyword}`
        public let path: String

        /// Delete a particular key-value pair on a transaction.
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.Keyword> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths {
    public static var categorize: Categorize {
        Categorize(path: "/categorize")
    }

    public struct Categorize {
        /// Path: `/categorize`
        public let path: String

        /// Categorize transactions without storing them
        ///
        /// It requires an array of transaction dictionaries. Any fields of transactions that are not required will be kept in the response. The response contains the list of transactions with two more fields: id_category and state (it indicates how the transaction has been categorized)<br><br>
        public func post(_ body: Data) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            public var failed: AnyJSON
            public var total: AnyJSON
            public var transactions: AnyJSON

            public init(failed: AnyJSON, total: AnyJSON, transactions: AnyJSON) {
                self.failed = failed
                self.total = total
                self.transactions = transactions
            }
        }
    }
}

extension Paths {
    public static var certificate: Certificate {
        Certificate(path: "/certificate")
    }

    public struct Certificate {
        /// Path: `/certificate`
        public let path: String
    }
}

extension Paths.Certificate {
    public func type(_ type: String) -> WithType {
        WithType(path: "\(path)/\(type)")
    }

    public struct WithType {
        /// Path: `/certificate/{type}`
        public let path: String

        /// Get the latest certificate of a type
        public func get(expand: String? = nil) -> Request<BudgeaAPI.Certificate> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths {
    public static var clients: Clients {
        Clients(path: "/clients")
    }

    public struct Clients {
        /// Path: `/clients`
        public let path: String

        /// List clients
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var clients: [BudgeaAPI.Client]
            /// Total number of results
            public var total: Double?

            public init(clients: [BudgeaAPI.Client], total: Double? = nil) {
                self.clients = clients
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Create a client
        public func post(expand: String? = nil, _ body: Data? = nil) -> Request<BudgeaAPI.Client> {
            .post(path, query: makePostQuery(expand), body: body)
        }

        private func makePostQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Clients {
    public func idClient(_ idClient: Int) -> WithIDClient {
        WithIDClient(path: "\(path)/\(idClient)")
    }

    public struct WithIDClient {
        /// Path: `/clients/{id_client}`
        public let path: String

        /// Get information about a client
        ///
        /// If you use the manage_token or a configuration token, you will get also the client secret.<br><br>
        public func get(expand: String? = nil) -> Request<BudgeaAPI.Client> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Update a client
        public func put(expand: String? = nil, _ body: Data? = nil) -> Request<BudgeaAPI.Client> {
            .put(path, query: makePutQuery(expand), body: body)
        }

        private func makePutQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Delete a client
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.Client> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Clients.WithIDClient {
    public var logo: Logo {
        Logo(path: path + "/logo")
    }

    public struct Logo {
        /// Path: `/clients/{id_client}/logo`
        public let path: String

        /// Update the client logo
        public func post(expand: String? = nil) -> Request<BudgeaAPI.File> {
            .post(path, query: makePostQuery(expand))
        }

        private func makePostQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Delete the client logo
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.File> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths {
    public static var config: Config {
        Config(path: "/config")
    }

    public struct Config {
        /// Path: `/config`
        public let path: String

        /// Get configuration of the API.
        ///
        /// <br><br>
        public func get(search: String? = nil) -> Request<Void> {
            .get(path, query: makeGetQuery(search))
        }

        private func makeGetQuery(_ search: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(search, forKey: "search")
            return encoder.items
        }

        /// Insert/update configuration key(s)/value(s) on the API.
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Config {
    public var logs: Logs {
        Logs(path: path + "/logs")
    }

    public struct Logs {
        /// Path: `/config/logs`
        public let path: String

        /// Get configuration change history of the API.
        ///
        /// <br><br>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var configlogs: [BudgeaAPI.ConfigLog]
            /// Total number of results
            public var total: Double?

            public init(configlogs: [BudgeaAPI.ConfigLog], total: Double? = nil) {
                self.configlogs = configlogs
                self.total = total
            }
        }

        public struct GetParameters {
            public var search: String?
            public var type: String?
            public var minDate: NaiveDate?
            public var maxDate: NaiveDate?
            public var expand: String?

            public init(search: String? = nil, type: String? = nil, minDate: NaiveDate? = nil, maxDate: NaiveDate? = nil, expand: String? = nil) {
                self.search = search
                self.type = type
                self.minDate = minDate
                self.maxDate = maxDate
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(search, forKey: "search")
                encoder.encode(type, forKey: "type")
                encoder.encode(minDate, forKey: "min_date")
                encoder.encode(maxDate, forKey: "max_date")
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var connections: Connections {
        Connections(path: "/connections")
    }

    public struct Connections {
        /// Path: `/connections`
        public let path: String

        /// Get connections without a user
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var connections: [BudgeaAPI.Connection]
            /// Total number of results
            public var total: Double?

            public init(connections: [BudgeaAPI.Connection], total: Double? = nil) {
                self.connections = connections
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Connections {
    public func idConnection(_ idConnection: Int) -> WithIDConnection {
        WithIDConnection(path: "\(path)/\(idConnection)")
    }

    public struct WithIDConnection {
        /// Path: `/connections/{id_connection}`
        public let path: String
    }
}

extension Paths.Connections.WithIDConnection {
    public var logs: Logs {
        Logs(path: path + "/logs")
    }

    public struct Logs {
        /// Path: `/connections/{id_connection}/logs`
        public let path: String

        /// Get connection logs
        ///
        /// Get logs about connections.<br><br>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var connectionlogs: [BudgeaAPI.ConnectionLog]
            /// Total number of results
            public var total: Double?

            public init(connectionlogs: [BudgeaAPI.ConnectionLog], total: Double? = nil) {
                self.connectionlogs = connectionlogs
                self.total = total
            }
        }

        public struct GetParameters {
            public var limit: Int?
            public var offset: Int?
            public var minDate: NaiveDate?
            public var maxDate: NaiveDate?
            public var period: String?
            public var idUser: Int?
            public var idConnection: Int?
            public var idConnector: Int?
            public var connectorUUID: String?
            public var error: String?
            public var idSource: Int?
            public var idMax: Int?
            public var expand: String?

            public init(limit: Int? = nil, offset: Int? = nil, minDate: NaiveDate? = nil, maxDate: NaiveDate? = nil, period: String? = nil, idUser: Int? = nil, idConnection: Int? = nil, idConnector: Int? = nil, connectorUUID: String? = nil, error: String? = nil, idSource: Int? = nil, idMax: Int? = nil, expand: String? = nil) {
                self.limit = limit
                self.offset = offset
                self.minDate = minDate
                self.maxDate = maxDate
                self.period = period
                self.idUser = idUser
                self.idConnection = idConnection
                self.idConnector = idConnector
                self.connectorUUID = connectorUUID
                self.error = error
                self.idSource = idSource
                self.idMax = idMax
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(minDate, forKey: "min_date")
                encoder.encode(maxDate, forKey: "max_date")
                encoder.encode(period, forKey: "period")
                encoder.encode(idUser, forKey: "id_user")
                encoder.encode(idConnection, forKey: "id_connection")
                encoder.encode(idConnector, forKey: "id_connector")
                encoder.encode(connectorUUID, forKey: "connector_uuid")
                encoder.encode(error, forKey: "error")
                encoder.encode(idSource, forKey: "id_source")
                encoder.encode(idMax, forKey: "id_max")
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.Connections.WithIDConnection {
    public var sources: Sources {
        Sources(path: path + "/sources")
    }

    public struct Sources {
        /// Path: `/connections/{id_connection}/sources`
        public let path: String

        /// Get connection sources
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var sources: [BudgeaAPI.ConnectionSource]
            /// Total number of results
            public var total: Double?

            public init(sources: [BudgeaAPI.ConnectionSource], total: Double? = nil) {
                self.sources = sources
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Connections.WithIDConnection.Sources {
    public func idSource(_ idSource: Int) -> WithIDSource {
        WithIDSource(path: "\(path)/\(idSource)")
    }

    public struct WithIDSource {
        /// Path: `/connections/{id_connection}/sources/{id_source}`
        public let path: String

        /// "
        ///
        /// This endpoint is used to enable a source or force a synchronization on it.<br><br>
        public func post(isBackground: Bool? = nil, expand: String? = nil, _ body: Data) -> Request<BudgeaAPI.ConnectionSource> {
            .post(path, query: makePostQuery(isBackground, expand), body: body)
        }

        private func makePostQuery(_ isBackground: Bool?, _ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isBackground, forKey: "background")
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Update connection source
        ///
        /// This endpoint is used to enable a source or force a synchronization on it.<br><br>
        public func put(isBackground: Bool? = nil, expand: String? = nil, _ body: Data) -> Request<BudgeaAPI.ConnectionSource> {
            .put(path, query: makePutQuery(isBackground, expand), body: body)
        }

        private func makePutQuery(_ isBackground: Bool?, _ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isBackground, forKey: "background")
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Disable a connection source
        ///
        /// This will make it so the specified source will not be synchronized anymore.<br><br>
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.ConnectionSource> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths {
    public static var connectors: Connectors {
        Connectors(path: "/connectors")
    }

    public struct Connectors {
        /// Path: `/connectors`
        public let path: String

        /// Get list of connectors
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var connectors: [BudgeaAPI.Connector]
            /// Total number of results
            public var total: Double?

            public init(connectors: [BudgeaAPI.Connector], total: Double? = nil) {
                self.connectors = connectors
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Request a new connector
        ///
        /// Send a request to add a new connector<br><br>
        public func post(expand: String? = nil, _ body: Data) -> Request<BudgeaAPI.Connector> {
            .post(path, query: makePostQuery(expand), body: body)
        }

        private func makePostQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Enable/disable several connectors
        public func put(expand: String? = nil, _ body: Data? = nil) -> Request<BudgeaAPI.Connector> {
            .put(path, query: makePutQuery(expand), body: body)
        }

        private func makePutQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Connectors {
    public func idConnector(_ idConnector: Int) -> WithIDConnector {
        WithIDConnector(path: "\(path)/\(idConnector)")
    }

    public struct WithIDConnector {
        /// Path: `/connectors/{id_connector}`
        public let path: String

        /// Get a connector
        public func get(expand: String? = nil) -> Request<BudgeaAPI.Connector> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Edit the provided connector
        ///
        /// <br><br>
        public func put(expand: String? = nil, _ body: Data? = nil) -> Request<BudgeaAPI.Connector> {
            .put(path, query: makePutQuery(expand), body: body)
        }

        private func makePutQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Connectors.WithIDConnector {
    public var logos: Logos {
        Logos(path: path + "/logos")
    }

    public struct Logos {
        /// Path: `/connectors/{id_connector}/logos`
        public let path: String

        /// Get all links to the files associated with this connector.
        ///
        /// This endpoint returns all links to files associated with this connector.<br><br>
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var connectorlogos: [BudgeaAPI.ConnectorLogo]
            /// Total number of results
            public var total: Double?

            public init(connectorlogos: [BudgeaAPI.ConnectorLogo], total: Double? = nil) {
                self.connectorlogos = connectorlogos
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Create a connector Logo
        ///
        /// This endpoint creates a connector logo. You can either pass a file to as a parameter to insert and link it with the connector or pass an id_file to link a connector with an existing file. Will fail if the file is already linked with that connector.<br><br>Form params: - id_file (integer): The id of the file to link with that connector. - img (string): Path to the image to link with that connector.<br><br>
        public func post(expand: String? = nil) -> Request<BudgeaAPI.ConnectorLogo> {
            .post(path, query: makePostQuery(expand))
        }

        private func makePostQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Create or Update a connector Logo
        ///
        /// This endpoint creates or update a connector logo. This logo is a mapping between a file (/file route) and a connector (/connectors route) or a provider (/providers route).<br><br>Form params: - id_file (integer): The id of the file to link with that connector.<br><br>
        public func put(expand: String? = nil) -> Request<BudgeaAPI.ConnectorLogo> {
            .put(path, query: makePutQuery(expand))
        }

        private func makePutQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Connectors.WithIDConnector.Logos {
    public var main: Main {
        Main(path: path + "/main")
    }

    public struct Main {
        /// Path: `/connectors/{id_connector}/logos/main`
        public let path: String

        /// Get all links to the files associated with this connector.
        ///
        /// This endpoint returns all links to files associated with this connector.<br><br>
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var connectorlogos: [BudgeaAPI.ConnectorLogo]
            /// Total number of results
            public var total: Double?

            public init(connectorlogos: [BudgeaAPI.ConnectorLogo], total: Double? = nil) {
                self.connectorlogos = connectorlogos
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Connectors.WithIDConnector.Logos {
    public var thumbnail: Thumbnail {
        Thumbnail(path: path + "/thumbnail")
    }

    public struct Thumbnail {
        /// Path: `/connectors/{id_connector}/logos/thumbnail`
        public let path: String

        /// Get all links to the files associated with this connector.
        ///
        /// This endpoint returns all links to files associated with this connector.<br><br>
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var connectorlogos: [BudgeaAPI.ConnectorLogo]
            /// Total number of results
            public var total: Double?

            public init(connectorlogos: [BudgeaAPI.ConnectorLogo], total: Double? = nil) {
                self.connectorlogos = connectorlogos
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Connectors.WithIDConnector.Logos {
    public func idLogo(_ idLogo: Int) -> WithIDLogo {
        WithIDLogo(path: "\(path)/\(idLogo)")
    }

    public struct WithIDLogo {
        /// Path: `/connectors/{id_connector}/logos/{id_logo}`
        public let path: String

        /// Create or Update a connector Logo.
        ///
        /// This endpoint creates or update a connector logo. This logo is a mapping between a file (/file route) and a connector (/connectors route) or a provider (/providers route).<br><br>Form params: - id_file (integer): The id of the file to link with that connector.<br><br>
        public func put(expand: String? = nil) -> Request<BudgeaAPI.ConnectorLogo> {
            .put(path, query: makePutQuery(expand))
        }

        private func makePutQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Delete a single Logo object.
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.ConnectorLogo> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Connectors.WithIDConnector {
    public var sources: Sources {
        Sources(path: path + "/sources")
    }

    public struct Sources {
        /// Path: `/connectors/{id_connector}/sources`
        public let path: String

        /// Get list of connector sources
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var sources: [BudgeaAPI.ConnectorSource]
            /// Total number of results
            public var total: Double?

            public init(sources: [BudgeaAPI.ConnectorSource], total: Double? = nil) {
                self.sources = sources
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Edit several connector sources
        public func put(expand: String? = nil, _ body: Data? = nil) -> Request<BudgeaAPI.ConnectorSource> {
            .put(path, query: makePutQuery(expand), body: body)
        }

        private func makePutQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Connectors.WithIDConnector.Sources {
    public func idConnectorSource(_ idConnectorSource: Int) -> WithIDConnectorSource {
        WithIDConnectorSource(path: "\(path)/\(idConnectorSource)")
    }

    public struct WithIDConnectorSource {
        /// Path: `/connectors/{id_connector}/sources/{id_connector_source}`
        public let path: String
    }
}

extension Paths.Connectors.WithIDConnector.Sources.WithIDConnectorSource {
    public var fields: Fields {
        Fields(path: path + "/fields")
    }

    public struct Fields {
        /// Path: `/connectors/{id_connector}/sources/{id_connector_source}/fields`
        public let path: String

        /// Get fields specific to a domain and a source
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var sourceFields: [BudgeaAPI.ConnectorSourceField]
            /// Total number of results
            public var total: Double?

            public init(sourceFields: [BudgeaAPI.ConnectorSourceField], total: Double? = nil) {
                self.sourceFields = sourceFields
                self.total = total
            }

            private enum CodingKeys: String, CodingKey {
                case sourceFields = "source_fields"
                case total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Connectors.WithIDConnector.Sources {
    public func idSource(_ idSource: Int) -> WithIDSource {
        WithIDSource(path: "\(path)/\(idSource)")
    }

    public struct WithIDSource {
        /// Path: `/connectors/{id_connector}/sources/{id_source}`
        public let path: String

        /// Get the connector source
        public func get(expand: String? = nil) -> Request<BudgeaAPI.ConnectorSource> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Edit the provided connector source
        public func put(expand: String? = nil, _ body: Data? = nil) -> Request<BudgeaAPI.ConnectorSource> {
            .put(path, query: makePutQuery(expand), body: body)
        }

        private func makePutQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths {
    public static var incidents: Incidents {
        Incidents(path: "/incidents")
    }

    public struct Incidents {
        /// Path: `/incidents`
        public let path: String

        /// Get incidents logs.
        ///
        /// By default, provide all incidents. Results are paginated. Some filters can be set via query parameters.<br><br>
        public func get(parameters: GetParameters? = nil) -> Request<Void> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var state: String?
            public var id: Int?
            public var weboobID: String?
            public var startDate: String?
            public var endDate: String?
            public var page: Int?
            public var size: Int?

            public init(state: String? = nil, id: Int? = nil, weboobID: String? = nil, startDate: String? = nil, endDate: String? = nil, page: Int? = nil, size: Int? = nil) {
                self.state = state
                self.id = id
                self.weboobID = weboobID
                self.startDate = startDate
                self.endDate = endDate
                self.page = page
                self.size = size
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(state, forKey: "state")
                encoder.encode(id, forKey: "id")
                encoder.encode(weboobID, forKey: "weboob_id")
                encoder.encode(startDate, forKey: "start_date")
                encoder.encode(endDate, forKey: "end_date")
                encoder.encode(page, forKey: "page")
                encoder.encode(size, forKey: "size")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var invoicing: Invoicing {
        Invoicing(path: "/invoicing")
    }

    public struct Invoicing {
        /// Path: `/invoicing`
        public let path: String

        /// Get invoicing data for a given period (default is the current month).
        ///
        /// You can get all the invoicing data or just specific ones by using the available parameters.<br><br>If no parameters are specified, no invoicing data is returned.<br><br>
        public func get(parameters: GetParameters? = nil) -> Request<Void> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var minDate: NaiveDate?
            public var maxDate: NaiveDate?
            public var usersSynced: String?
            public var usersBank: String?
            public var usersBill: String?
            public var accountsSynced: String?
            public var subscriptionsSynced: String?
            public var connectionsSynced: String?
            public var connectionsAccount: String?
            public var transfersSynced: String?
            public var paymentsSynced: String?
            public var all: String?
            public var detail: String?

            public init(minDate: NaiveDate? = nil, maxDate: NaiveDate? = nil, usersSynced: String? = nil, usersBank: String? = nil, usersBill: String? = nil, accountsSynced: String? = nil, subscriptionsSynced: String? = nil, connectionsSynced: String? = nil, connectionsAccount: String? = nil, transfersSynced: String? = nil, paymentsSynced: String? = nil, all: String? = nil, detail: String? = nil) {
                self.minDate = minDate
                self.maxDate = maxDate
                self.usersSynced = usersSynced
                self.usersBank = usersBank
                self.usersBill = usersBill
                self.accountsSynced = accountsSynced
                self.subscriptionsSynced = subscriptionsSynced
                self.connectionsSynced = connectionsSynced
                self.connectionsAccount = connectionsAccount
                self.transfersSynced = transfersSynced
                self.paymentsSynced = paymentsSynced
                self.all = all
                self.detail = detail
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(minDate, forKey: "min_date")
                encoder.encode(maxDate, forKey: "max_date")
                encoder.encode(usersSynced, forKey: "users_synced")
                encoder.encode(usersBank, forKey: "users_bank")
                encoder.encode(usersBill, forKey: "users_bill")
                encoder.encode(accountsSynced, forKey: "accounts_synced")
                encoder.encode(subscriptionsSynced, forKey: "subscriptions_synced")
                encoder.encode(connectionsSynced, forKey: "connections_synced")
                encoder.encode(connectionsAccount, forKey: "connections_account")
                encoder.encode(transfersSynced, forKey: "transfers_synced")
                encoder.encode(paymentsSynced, forKey: "payments_synced")
                encoder.encode(all, forKey: "all")
                encoder.encode(detail, forKey: "detail")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var logs: Logs {
        Logs(path: "/logs")
    }

    public struct Logs {
        /// Path: `/logs`
        public let path: String

        /// Get connection logs
        ///
        /// Get logs about connections.<br><br>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var connectionlogs: [BudgeaAPI.ConnectionLog]
            /// Total number of results
            public var total: Double?

            public init(connectionlogs: [BudgeaAPI.ConnectionLog], total: Double? = nil) {
                self.connectionlogs = connectionlogs
                self.total = total
            }
        }

        public struct GetParameters {
            public var limit: Int?
            public var offset: Int?
            public var minDate: NaiveDate?
            public var maxDate: NaiveDate?
            public var period: String?
            public var idUser: Int?
            public var idConnection: Int?
            public var idConnector: Int?
            public var connectorUUID: String?
            public var error: String?
            public var idSource: Int?
            public var idMax: Int?
            public var expand: String?

            public init(limit: Int? = nil, offset: Int? = nil, minDate: NaiveDate? = nil, maxDate: NaiveDate? = nil, period: String? = nil, idUser: Int? = nil, idConnection: Int? = nil, idConnector: Int? = nil, connectorUUID: String? = nil, error: String? = nil, idSource: Int? = nil, idMax: Int? = nil, expand: String? = nil) {
                self.limit = limit
                self.offset = offset
                self.minDate = minDate
                self.maxDate = maxDate
                self.period = period
                self.idUser = idUser
                self.idConnection = idConnection
                self.idConnector = idConnector
                self.connectorUUID = connectorUUID
                self.error = error
                self.idSource = idSource
                self.idMax = idMax
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(minDate, forKey: "min_date")
                encoder.encode(maxDate, forKey: "max_date")
                encoder.encode(period, forKey: "period")
                encoder.encode(idUser, forKey: "id_user")
                encoder.encode(idConnection, forKey: "id_connection")
                encoder.encode(idConnector, forKey: "id_connector")
                encoder.encode(connectorUUID, forKey: "connector_uuid")
                encoder.encode(error, forKey: "error")
                encoder.encode(idSource, forKey: "id_source")
                encoder.encode(idMax, forKey: "id_max")
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var monitoring: Monitoring {
        Monitoring(path: "/monitoring")
    }

    public struct Monitoring {
        /// Path: `/monitoring`
        public let path: String

        /// Get performances stats on this instance
        public func get(period: Int? = nil) -> Request<Void> {
            .get(path, query: makeGetQuery(period))
        }

        private func makeGetQuery(_ period: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(period, forKey: "period")
            return encoder.items
        }
    }
}

extension Paths {
    public static var providers: Providers {
        Providers(path: "/providers")
    }

    public struct Providers {
        /// Path: `/providers`
        public let path: String

        /// Get list of connectors
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var providers: [BudgeaAPI.Connector]
            /// Total number of results
            public var total: Double?

            public init(providers: [BudgeaAPI.Connector], total: Double? = nil) {
                self.providers = providers
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Providers {
    public func idConnector(_ idConnector: Int) -> WithIDConnector {
        WithIDConnector(path: "\(path)/\(idConnector)")
    }

    public struct WithIDConnector {
        /// Path: `/providers/{id_connector}`
        public let path: String
    }
}

extension Paths.Providers.WithIDConnector {
    public var connections: Connections {
        Connections(path: path + "/connections")
    }

    public struct Connections {
        /// Path: `/providers/{id_connector}/connections`
        public let path: String

        /// Get a random subset of provider's id_connection
        ///
        /// By default, it selects a set of 3 connections.<br><br>
        public func get(range: Int? = nil, expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(range, expand))
        }

        public struct GetResponse: Decodable {
            public var connections: [BudgeaAPI.Connection]
            /// Total number of results
            public var total: Double?

            public init(connections: [BudgeaAPI.Connection], total: Double? = nil) {
                self.connections = connections
                self.total = total
            }
        }

        private func makeGetQuery(_ range: Int?, _ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(range, forKey: "range")
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Providers.WithIDConnector {
    public var logos: Logos {
        Logos(path: path + "/logos")
    }

    public struct Logos {
        /// Path: `/providers/{id_connector}/logos`
        public let path: String

        /// Get all links to the files associated with this connector.
        ///
        /// This endpoint returns all links to files associated with this connector.<br><br>
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var connectorlogos: [BudgeaAPI.ConnectorLogo]
            /// Total number of results
            public var total: Double?

            public init(connectorlogos: [BudgeaAPI.ConnectorLogo], total: Double? = nil) {
                self.connectorlogos = connectorlogos
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Providers.WithIDConnector.Logos {
    public var main: Main {
        Main(path: path + "/main")
    }

    public struct Main {
        /// Path: `/providers/{id_connector}/logos/main`
        public let path: String

        /// Get all links to the files associated with this connector.
        ///
        /// This endpoint returns all links to files associated with this connector.<br><br>
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var connectorlogos: [BudgeaAPI.ConnectorLogo]
            /// Total number of results
            public var total: Double?

            public init(connectorlogos: [BudgeaAPI.ConnectorLogo], total: Double? = nil) {
                self.connectorlogos = connectorlogos
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Providers.WithIDConnector.Logos {
    public var thumbnail: Thumbnail {
        Thumbnail(path: path + "/thumbnail")
    }

    public struct Thumbnail {
        /// Path: `/providers/{id_connector}/logos/thumbnail`
        public let path: String

        /// Get all links to the files associated with this connector.
        ///
        /// This endpoint returns all links to files associated with this connector.<br><br>
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var connectorlogos: [BudgeaAPI.ConnectorLogo]
            /// Total number of results
            public var total: Double?

            public init(connectorlogos: [BudgeaAPI.ConnectorLogo], total: Double? = nil) {
                self.connectorlogos = connectorlogos
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Providers.WithIDConnector {
    public var sources: Sources {
        Sources(path: path + "/sources")
    }

    public struct Sources {
        /// Path: `/providers/{id_connector}/sources`
        public let path: String

        /// Get list of connector sources
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var sources: [BudgeaAPI.ConnectorSource]
            /// Total number of results
            public var total: Double?

            public init(sources: [BudgeaAPI.ConnectorSource], total: Double? = nil) {
                self.sources = sources
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Providers.WithIDConnector.Sources {
    public func idConnectorSource(_ idConnectorSource: Int) -> WithIDConnectorSource {
        WithIDConnectorSource(path: "\(path)/\(idConnectorSource)")
    }

    public struct WithIDConnectorSource {
        /// Path: `/providers/{id_connector}/sources/{id_connector_source}`
        public let path: String
    }
}

extension Paths.Providers.WithIDConnector.Sources.WithIDConnectorSource {
    public var fields: Fields {
        Fields(path: path + "/fields")
    }

    public struct Fields {
        /// Path: `/providers/{id_connector}/sources/{id_connector_source}/fields`
        public let path: String

        /// Get fields specific to a domain and a source
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var sourceFields: [BudgeaAPI.ConnectorSourceField]
            /// Total number of results
            public var total: Double?

            public init(sourceFields: [BudgeaAPI.ConnectorSourceField], total: Double? = nil) {
                self.sourceFields = sourceFields
                self.total = total
            }

            private enum CodingKeys: String, CodingKey {
                case sourceFields = "source_fields"
                case total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Providers.WithIDConnector.Sources {
    public func idSource(_ idSource: Int) -> WithIDSource {
        WithIDSource(path: "\(path)/\(idSource)")
    }

    public struct WithIDSource {
        /// Path: `/providers/{id_connector}/sources/{id_source}`
        public let path: String

        /// Get the connector source
        public func get(expand: String? = nil) -> Request<BudgeaAPI.ConnectorSource> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Providers {
    public func idProvider(_ idProvider: Int) -> WithIDProvider {
        WithIDProvider(path: "\(path)/\(idProvider)")
    }

    public struct WithIDProvider {
        /// Path: `/providers/{id_provider}`
        public let path: String

        /// Get a connector
        public func get(expand: String? = nil) -> Request<BudgeaAPI.Connector> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths {
    public static var psd2Registrations: Psd2Registrations {
        Psd2Registrations(path: "/psd2-registrations")
    }

    public struct Psd2Registrations {
        /// Path: `/psd2-registrations`
        public let path: String

        /// Get details on all psd2 registrations
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var psd2registrations: [BudgeaAPI.Psd2Registration]
            /// Total number of results
            public var total: Double?

            public init(psd2registrations: [BudgeaAPI.Psd2Registration], total: Double? = nil) {
                self.psd2registrations = psd2registrations
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Psd2Registrations {
    public func idPsd2Registration(_ idPsd2Registration: Int) -> WithIDPsd2Registration {
        WithIDPsd2Registration(path: "\(path)/\(idPsd2Registration)")
    }

    public struct WithIDPsd2Registration {
        /// Path: `/psd2-registrations/{id_psd2-registration}`
        public let path: String

        /// Get details for a given psd2 registration
        public func get(expand: String? = nil) -> Request<BudgeaAPI.Psd2Registration> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Psd2Registrations {
    public func idPsd2registration(_ idPsd2registration: Int) -> WithIDPsd2registration {
        WithIDPsd2registration(path: "\(path)/\(idPsd2registration)")
    }

    public struct WithIDPsd2registration {
        /// Path: `/psd2-registrations/{id_psd2registration}`
        public let path: String
    }
}

extension Paths.Psd2Registrations.WithIDPsd2registration {
    public var logs: Logs {
        Logs(path: path + "/logs")
    }

    public struct Logs {
        /// Path: `/psd2-registrations/{id_psd2registration}/logs`
        public let path: String

        /// Get psd2 registration logs.
        ///
        /// Get logs of psd2 registration. By default, it selects logs for the last month. You can use "min_date" and "max_date" to change boundary dates.<br><br>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var psd2registrationlogs: [BudgeaAPI.Psd2RegistrationLog]
            /// Total number of results
            public var total: Double?

            public init(psd2registrationlogs: [BudgeaAPI.Psd2RegistrationLog], total: Double? = nil) {
                self.psd2registrationlogs = psd2registrationlogs
                self.total = total
            }
        }

        public struct GetParameters {
            public var limit: Int?
            public var offset: Int?
            public var minDate: NaiveDate?
            public var maxDate: NaiveDate?
            public var expand: String?

            public init(limit: Int? = nil, offset: Int? = nil, minDate: NaiveDate? = nil, maxDate: NaiveDate? = nil, expand: String? = nil) {
                self.limit = limit
                self.offset = offset
                self.minDate = minDate
                self.maxDate = maxDate
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(minDate, forKey: "min_date")
                encoder.encode(maxDate, forKey: "max_date")
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var publickey: Publickey {
        Publickey(path: "/publickey")
    }

    public struct Publickey {
        /// Path: `/publickey`
        public let path: String

        /// Get public encryption key of the API.
        public var get: Request<Void> {
            .get(path)
        }
    }
}

extension Paths {
    public static var test: Test {
        Test(path: "/test")
    }

    public struct Test {
        /// Path: `/test`
        public let path: String
    }
}

extension Paths.Test {
    public var sync: Sync {
        Sync(path: path + "/sync")
    }

    public struct Sync {
        /// Path: `/test/sync`
        public let path: String

        /// Test synchronization on a random connection.
        ///
        /// It can be used to test receiving data on your webhooks.<br><br>
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths.Test {
    public var webhooks: Webhooks {
        Webhooks(path: path + "/webhooks")
    }

    public struct Webhooks {
        /// Path: `/test/webhooks`
        public let path: String

        /// Test synchronization on a random connection.
        ///
        /// It can be used to test receiving data on your webhooks.<br><br>
        public var post: Request<Void> {
            .post(path)
        }
    }
}

extension Paths {
    public static var users: Users {
        Users(path: "/users")
    }

    public struct Users {
        /// Path: `/users`
        public let path: String

        /// Get users
        public func get(search: String? = nil, expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(search, expand))
        }

        public struct GetResponse: Decodable {
            /// Total number of results
            public var total: Double?
            public var users: [BudgeaAPI.User]

            public init(total: Double? = nil, users: [BudgeaAPI.User]) {
                self.total = total
                self.users = users
            }
        }

        private func makeGetQuery(_ search: String?, _ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(search, forKey: "search")
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users {
    public func idUser(_ idUser: String) -> WithIDUser {
        WithIDUser(path: "\(path)/\(idUser)")
    }

    public struct WithIDUser {
        /// Path: `/users/{id_user}`
        public let path: String

        /// Get a user
        public func get(expand: String? = nil) -> Request<BudgeaAPI.User> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Delete the user
        ///
        /// This endpoint deletes the user.<br><br>
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.User> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser {
    public var accountTypes: AccountTypes {
        AccountTypes(path: path + "/account_types")
    }

    public struct AccountTypes {
        /// Path: `/users/{id_user}/account_types`
        public let path: String

        /// Get account types
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var accounttypes: [BudgeaAPI.AccountType]
            /// Total number of results
            public var total: Double?

            public init(accounttypes: [BudgeaAPI.AccountType], total: Double? = nil) {
                self.accounttypes = accounttypes
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser.AccountTypes {
    public func idAccountType(_ idAccountType: Int) -> WithIDAccountType {
        WithIDAccountType(path: "\(path)/\(idAccountType)")
    }

    public struct WithIDAccountType {
        /// Path: `/users/{id_user}/account_types/{id_account_type}`
        public let path: String

        /// Get an account type
        public func get(expand: String? = nil) -> Request<BudgeaAPI.AccountType> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser {
    public var accounts: Accounts {
        Accounts(path: path + "/accounts")
    }

    public struct Accounts {
        /// Path: `/users/{id_user}/accounts`
        public let path: String
    }
}

extension Paths.Users.WithIDUser.Accounts {
    public func idAccount(_ idAccount: Int) -> WithIDAccount {
        WithIDAccount(path: "\(path)/\(idAccount)")
    }

    public struct WithIDAccount {
        /// Path: `/users/{id_user}/accounts/{id_account}`
        public let path: String
    }
}

extension Paths.Users.WithIDUser.Accounts.WithIDAccount {
    public var categories: Categories {
        Categories(path: path + "/categories")
    }

    public struct Categories {
        /// Path: `/users/{id_user}/accounts/{id_account}/categories`
        public let path: String

        /// Get the category
        ///
        /// Ressource to get categories for the user's transactions<br><br>
        public var get: Request<Void> {
            .get(path)
        }
    }
}

extension Paths.Users.WithIDUser.Accounts.WithIDAccount {
    public var transactionsclusters: Transactionsclusters {
        Transactionsclusters(path: path + "/transactionsclusters")
    }

    public struct Transactionsclusters {
        /// Path: `/users/{id_user}/accounts/{id_account}/transactionsclusters`
        public let path: String

        /// Get clustered transactions
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            /// Total number of results
            public var total: Double?
            public var transactionsclusters: [BudgeaAPI.TransactionsCluster]

            public init(total: Double? = nil, transactionsclusters: [BudgeaAPI.TransactionsCluster]) {
                self.total = total
                self.transactionsclusters = transactionsclusters
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Create clustered transaction
        ///
        /// Form params : - next_date (date) required: Date of transaction - mean_amount (decimal) required: Mean Amount - wording (string) required: name of transaction - id_account (id) required: related account<br><br>
        public func post(expand: String? = nil) -> Request<BudgeaAPI.TransactionsCluster> {
            .post(path, query: makePostQuery(expand))
        }

        private func makePostQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser.Accounts.WithIDAccount.Transactionsclusters {
    public func idTransactionscluster(_ idTransactionscluster: Int) -> WithIDTransactionscluster {
        WithIDTransactionscluster(path: "\(path)/\(idTransactionscluster)")
    }

    public struct WithIDTransactionscluster {
        /// Path: `/users/{id_user}/accounts/{id_account}/transactionsclusters/{id_transactionscluster}`
        public let path: String

        /// Edit a clustered transaction
        ///
        /// Form params : - next_date (date): Date of transaction - mean_amount (decimal): Mean Amount - wording (string): name of transaction - id_account (id): related account - id_category (id): related category - enabled (bool): is enabled<br><br>
        public func put(expand: String? = nil) -> Request<BudgeaAPI.TransactionsCluster> {
            .put(path, query: makePutQuery(expand))
        }

        private func makePutQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Delete a clustered transaction
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.TransactionsCluster> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser {
    public var alerts: Alerts {
        Alerts(path: path + "/alerts")
    }

    public struct Alerts {
        /// Path: `/users/{id_user}/alerts`
        public let path: String

        /// Get alerts
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var alerts: [BudgeaAPI.Alert]
            /// Total number of results
            public var total: Double?

            public init(alerts: [BudgeaAPI.Alert], total: Double? = nil) {
                self.alerts = alerts
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser {
    public var categories: Categories {
        Categories(path: path + "/categories")
    }

    public struct Categories {
        /// Path: `/users/{id_user}/categories`
        public let path: String

        /// Get the category
        ///
        /// Ressource to get categories for the user's transactions<br><br>
        public var get: Request<Void> {
            .get(path)
        }
    }
}

extension Paths.Users.WithIDUser.Categories {
    public var full: Full {
        Full(path: path + "/full")
    }

    public struct Full {
        /// Path: `/users/{id_user}/categories/full`
        public let path: String

        /// Get the category
        ///
        /// Ressource to get categories<br><br>
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var categorys: [BudgeaAPI.Category]
            /// Total number of results
            public var total: Double?

            public init(categorys: [BudgeaAPI.Category], total: Double? = nil) {
                self.categorys = categorys
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Create a new transaction category
        public func post(expand: String? = nil, _ body: Data? = nil) -> Request<BudgeaAPI.Category> {
            .post(path, query: makePostQuery(expand), body: body)
        }

        private func makePostQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser.Categories.Full {
    public func idFull(_ idFull: Int) -> WithIDFull {
        WithIDFull(path: "\(path)/\(idFull)")
    }

    public struct WithIDFull {
        /// Path: `/users/{id_user}/categories/full/{id_full}`
        public let path: String

        /// Modify a user-created category
        public func put(expand: String? = nil, _ body: Data? = nil) -> Request<BudgeaAPI.Category> {
            .put(path, query: makePutQuery(expand), body: body)
        }

        private func makePutQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Delete a user-created transaction category
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.Category> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser {
    public var config: Config {
        Config(path: path + "/config")
    }

    public struct Config {
        /// Path: `/users/{id_user}/config`
        public let path: String

        /// Get configuration of a user.
        ///
        /// <br><br>
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var biapiLastPush: AnyJSON

            public init(biapiLastPush: AnyJSON) {
                self.biapiLastPush = biapiLastPush
            }

            private enum CodingKeys: String, CodingKey {
                case biapiLastPush = "biapi.last_push"
            }
        }

        /// Change configuration of a user. modifications on keys prefixed by 'biapi.' (except callback_url) are ignored
        public var post: Request<Void> {
            .post(path)
        }

        /// Delete the given user configurations. deletions on keys prefixed by 'biapi.' (except callback_url) are ignored
        ///
        /// - keys (string): list of coma separated keys to be deleted.<br><br>
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithIDUser {
    public var connections: Connections {
        Connections(path: path + "/connections")
    }

    public struct Connections {
        /// Path: `/users/{id_user}/connections`
        public let path: String

        /// Get connections
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var connections: [BudgeaAPI.Connection]
            /// Total number of results
            public var total: Double?

            public init(connections: [BudgeaAPI.Connection], total: Double? = nil) {
                self.connections = connections
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Add a new connection.
        ///
        /// Create a new connection to a given bank or provider. You have to give all needed parameters (use /banks/ID/fields or /providers/ID/fields to get them).<br><br>
        public func post(source: String? = nil, expand: String? = nil, _ body: Data? = nil) -> Request<BudgeaAPI.Connection> {
            .post(path, query: makePostQuery(source, expand), body: body)
        }

        private func makePostQuery(_ source: String?, _ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(source, forKey: "source")
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Delete all connections
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.Connection> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser.Connections {
    public func idConnection(_ idConnection: Int) -> WithIDConnection {
        WithIDConnection(path: "\(path)/\(idConnection)")
    }

    public struct WithIDConnection {
        /// Path: `/users/{id_user}/connections/{id_connection}`
        public let path: String

        /// Update a connection.
        ///
        /// Give new parameters to change on the configuration of this connection (for example "password").<br><br>It tests connection to website, and if it fails, a 400 response is given with the error code "wrongpass" or "websiteUnavailable".<br><br>You can also supply meta-parameters on connection, like 'active' or 'expire'.<br><br>It's possible to execute the update/synchronization in the background with a query parameter. If done in background this endpoint will respond with data that is not yet updated. To obtain updated data, polling is required as the the data will be filled in the background.<br><br>
        public func post(parameters: PostParameters? = nil, _ body: Data? = nil) -> Request<BudgeaAPI.Connection> {
            .post(path, query: parameters?.asQuery, body: body)
        }

        public struct PostParameters {
            public var isBackground: Bool?
            public var isPsuRequested: Bool?
            public var isRefreshPsd2Auth: Bool?
            public var expand: String?

            public init(isBackground: Bool? = nil, isPsuRequested: Bool? = nil, isRefreshPsd2Auth: Bool? = nil, expand: String? = nil) {
                self.isBackground = isBackground
                self.isPsuRequested = isPsuRequested
                self.isRefreshPsd2Auth = isRefreshPsd2Auth
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(isBackground, forKey: "background")
                encoder.encode(isPsuRequested, forKey: "psu_requested")
                encoder.encode(isRefreshPsd2Auth, forKey: "refresh_psd2_auth")
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }

        /// Force synchronisation of a connection.
        ///
        /// We suggest to pass parameter expand=accounts[transactions] to get all *new* and *updated* transactions.<br><br>
        public func put(parameters: PutParameters? = nil) -> Request<BudgeaAPI.Connection> {
            .put(path, query: parameters?.asQuery)
        }

        public struct PutParameters {
            public var lastUpdate: Date?
            public var isBackground: Bool?
            public var isPsuRequested: Bool?
            public var expand: String?

            public init(lastUpdate: Date? = nil, isBackground: Bool? = nil, isPsuRequested: Bool? = nil, expand: String? = nil) {
                self.lastUpdate = lastUpdate
                self.isBackground = isBackground
                self.isPsuRequested = isPsuRequested
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(lastUpdate, forKey: "last_update")
                encoder.encode(isBackground, forKey: "background")
                encoder.encode(isPsuRequested, forKey: "psu_requested")
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }

        /// Delete a connection.
        ///
        /// This endpoint deletes a connection and all related accounts and transactions.<br><br>
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.Connection> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser.Connections.WithIDConnection {
    public var accounts: Accounts {
        Accounts(path: path + "/accounts")
    }

    public struct Accounts {
        /// Path: `/users/{id_user}/connections/{id_connection}/accounts`
        public let path: String

        /// Get accounts list.
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var accounts: [BudgeaAPI.Account]
            /// Total number of results
            public var total: Double?

            public init(accounts: [BudgeaAPI.Account], total: Double? = nil) {
                self.accounts = accounts
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Create an account
        ///
        /// This endpoint creates an account related to a connection or not.<br><br>
        public func post(expand: String? = nil, _ body: Data) -> Request<BudgeaAPI.Account> {
            .post(path, query: makePostQuery(expand), body: body)
        }

        private func makePostQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Update many accounts at once
        public func put(expand: String? = nil) -> Request<BudgeaAPI.Account> {
            .put(path, query: makePutQuery(expand))
        }

        private func makePutQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Delete all accounts
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.Account> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser.Connections.WithIDConnection.Accounts {
    public func idAccount(_ idAccount: Int) -> WithIDAccount {
        WithIDAccount(path: "\(path)/\(idAccount)")
    }

    public struct WithIDAccount {
        /// Path: `/users/{id_user}/connections/{id_connection}/accounts/{id_account}`
        public let path: String

        /// Update an account
        ///
        /// It updates a specific account<br><br>
        public func put(expand: String? = nil, _ body: Data? = nil) -> Request<BudgeaAPI.Account> {
            .put(path, query: makePutQuery(expand), body: body)
        }

        private func makePutQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Delete an account.
        ///
        /// It deletes a specific account.<br><br>
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.Account> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser.Connections.WithIDConnection.Accounts.WithIDAccount {
    public var categories: Categories {
        Categories(path: path + "/categories")
    }

    public struct Categories {
        /// Path: `/users/{id_user}/connections/{id_connection}/accounts/{id_account}/categories`
        public let path: String

        /// Get the category
        ///
        /// Ressource to get categories for the user's transactions<br><br>
        public var get: Request<Void> {
            .get(path)
        }
    }
}

extension Paths.Users.WithIDUser.Connections.WithIDConnection.Accounts.WithIDAccount {
    public var delta: Delta {
        Delta(path: path + "/delta")
    }

    public struct Delta {
        /// Path: `/users/{id_user}/connections/{id_connection}/accounts/{id_account}/delta`
        public let path: String

        /// Get deltas of accounts
        ///
        /// Get account delta between sums of transactions and difference of account balance for the given period.<br><br>
        public func get(parameters: GetParameters? = nil) -> Request<Void> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var minDate: NaiveDate?
            public var maxDate: NaiveDate?
            public var period: String?

            public init(minDate: NaiveDate? = nil, maxDate: NaiveDate? = nil, period: String? = nil) {
                self.minDate = minDate
                self.maxDate = maxDate
                self.period = period
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(minDate, forKey: "min_date")
                encoder.encode(maxDate, forKey: "max_date")
                encoder.encode(period, forKey: "period")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.WithIDUser.Connections.WithIDConnection.Accounts.WithIDAccount {
    public var logs: Logs {
        Logs(path: path + "/logs")
    }

    public struct Logs {
        /// Path: `/users/{id_user}/connections/{id_connection}/accounts/{id_account}/logs`
        public let path: String

        /// Get accounts logs.
        ///
        /// Get logs of account. By default, it selects logs for the last month. You can use "min_date" and "max_date" to change boundary dates.<br><br>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var accountlogs: [BudgeaAPI.AccountLog]
            /// Total number of results
            public var total: Double?

            public init(accountlogs: [BudgeaAPI.AccountLog], total: Double? = nil) {
                self.accountlogs = accountlogs
                self.total = total
            }
        }

        public struct GetParameters {
            public var limit: Int?
            public var offset: Int?
            public var minDate: NaiveDate?
            public var maxDate: NaiveDate?
            public var expand: String?

            public init(limit: Int? = nil, offset: Int? = nil, minDate: NaiveDate? = nil, maxDate: NaiveDate? = nil, expand: String? = nil) {
                self.limit = limit
                self.offset = offset
                self.minDate = minDate
                self.maxDate = maxDate
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(minDate, forKey: "min_date")
                encoder.encode(maxDate, forKey: "max_date")
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.WithIDUser.Connections.WithIDConnection.Accounts.WithIDAccount {
    public var sources: Sources {
        Sources(path: path + "/sources")
    }

    public struct Sources {
        /// Path: `/users/{id_user}/connections/{id_connection}/accounts/{id_account}/sources`
        public let path: String

        /// Get account sources
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var sources: [BudgeaAPI.ConnectionSource]
            /// Total number of results
            public var total: Double?

            public init(sources: [BudgeaAPI.ConnectionSource], total: Double? = nil) {
                self.sources = sources
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser.Connections.WithIDConnection.Accounts.WithIDAccount {
    public var transactions: Transactions {
        Transactions(path: path + "/transactions")
    }

    public struct Transactions {
        /// Path: `/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions`
        public let path: String

        /// Get transactions
        ///
        /// Get list of transactions.<br><br>By default, it selects transactions for the last month. You can use "min_date" and "max_date" to change boundary dates.<br><br>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            /// Total number of results
            public var total: Double?
            public var transactions: [BudgeaAPI.Transaction]

            public init(total: Double? = nil, transactions: [BudgeaAPI.Transaction]) {
                self.total = total
                self.transactions = transactions
            }
        }

        public struct GetParameters {
            public var limit: Int?
            public var offset: Int?
            public var minDate: NaiveDate?
            public var maxDate: NaiveDate?
            public var isIncome: Bool?
            public var isDeleted: Bool?
            public var isAll: Bool?
            public var lastUpdate: Date?
            public var wording: String?
            public var minValue: Double?
            public var maxValue: Double?
            public var search: String?
            public var value: String?
            public var idCategory: Int?
            public var expand: String?

            public init(limit: Int? = nil, offset: Int? = nil, minDate: NaiveDate? = nil, maxDate: NaiveDate? = nil, isIncome: Bool? = nil, isDeleted: Bool? = nil, isAll: Bool? = nil, lastUpdate: Date? = nil, wording: String? = nil, minValue: Double? = nil, maxValue: Double? = nil, search: String? = nil, value: String? = nil, idCategory: Int? = nil, expand: String? = nil) {
                self.limit = limit
                self.offset = offset
                self.minDate = minDate
                self.maxDate = maxDate
                self.isIncome = isIncome
                self.isDeleted = isDeleted
                self.isAll = isAll
                self.lastUpdate = lastUpdate
                self.wording = wording
                self.minValue = minValue
                self.maxValue = maxValue
                self.search = search
                self.value = value
                self.idCategory = idCategory
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(minDate, forKey: "min_date")
                encoder.encode(maxDate, forKey: "max_date")
                encoder.encode(isIncome, forKey: "income")
                encoder.encode(isDeleted, forKey: "deleted")
                encoder.encode(isAll, forKey: "all")
                encoder.encode(lastUpdate, forKey: "last_update")
                encoder.encode(wording, forKey: "wording")
                encoder.encode(minValue, forKey: "min_value")
                encoder.encode(maxValue, forKey: "max_value")
                encoder.encode(search, forKey: "search")
                encoder.encode(value, forKey: "value")
                encoder.encode(idCategory, forKey: "id_category")
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }

        /// Create transactions
        ///
        /// Create transactions for the supplied account or the account whose id is given with form parameters. It requires an array of transaction dictionaries.<br><br><br><br>
        public func post(expand: String? = nil, _ body: Data) -> Request<BudgeaAPI.Transaction> {
            .post(path, query: makePostQuery(expand), body: body)
        }

        private func makePostQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Delete transactions
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.Transaction> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser.Connections.WithIDConnection.Accounts.WithIDAccount.Transactions {
    public func idTransaction(_ idTransaction: Int) -> WithIDTransaction {
        WithIDTransaction(path: "\(path)/\(idTransaction)")
    }

    public struct WithIDTransaction {
        /// Path: `/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions/{id_transaction}`
        public let path: String

        /// Edit a transaction meta-data
        public func put(expand: String? = nil, _ body: Data? = nil) -> Request<BudgeaAPI.Transaction> {
            .put(path, query: makePutQuery(expand), body: body)
        }

        private func makePutQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser.Connections.WithIDConnection.Accounts.WithIDAccount.Transactions.WithIDTransaction {
    public var informations: Informations {
        Informations(path: path + "/informations")
    }

    public struct Informations {
        /// Path: `/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions/{id_transaction}/informations`
        public let path: String

        /// List all arbitrary key-value pairs on a transaction
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            /// Total number of results
            public var total: Double?
            public var transactioninformations: [BudgeaAPI.TransactionInformation]

            public init(total: Double? = nil, transactioninformations: [BudgeaAPI.TransactionInformation]) {
                self.total = total
                self.transactioninformations = transactioninformations
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Add or edit transaction arbitrary key-value pairs
        public func put(expand: String? = nil) -> Request<BudgeaAPI.TransactionInformation> {
            .put(path, query: makePutQuery(expand))
        }

        private func makePutQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Delete all arbitrary key-value pairs of a transaction
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.TransactionInformation> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser.Connections.WithIDConnection.Accounts.WithIDAccount.Transactions.WithIDTransaction.Informations {
    public func idInformation(_ idInformation: Int) -> WithIDInformation {
        WithIDInformation(path: "\(path)/\(idInformation)")
    }

    public struct WithIDInformation {
        /// Path: `/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions/{id_transaction}/informations/{id_information}`
        public let path: String

        /// Get a particular arbitrary key-value pair on a transaction
        public func get(expand: String? = nil) -> Request<BudgeaAPI.TransactionInformation> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Delete a particular key-value pair on a transaction.
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.TransactionInformation> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser.Connections.WithIDConnection.Accounts.WithIDAccount {
    public var transactionsclusters: Transactionsclusters {
        Transactionsclusters(path: path + "/transactionsclusters")
    }

    public struct Transactionsclusters {
        /// Path: `/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactionsclusters`
        public let path: String

        /// Get clustered transactions
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            /// Total number of results
            public var total: Double?
            public var transactionsclusters: [BudgeaAPI.TransactionsCluster]

            public init(total: Double? = nil, transactionsclusters: [BudgeaAPI.TransactionsCluster]) {
                self.total = total
                self.transactionsclusters = transactionsclusters
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Create clustered transaction
        ///
        /// Form params : - next_date (date) required: Date of transaction - mean_amount (decimal) required: Mean Amount - wording (string) required: name of transaction - id_account (id) required: related account<br><br>
        public func post(expand: String? = nil) -> Request<BudgeaAPI.TransactionsCluster> {
            .post(path, query: makePostQuery(expand))
        }

        private func makePostQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser.Connections.WithIDConnection.Accounts.WithIDAccount.Transactionsclusters {
    public func idTransactionscluster(_ idTransactionscluster: Int) -> WithIDTransactionscluster {
        WithIDTransactionscluster(path: "\(path)/\(idTransactionscluster)")
    }

    public struct WithIDTransactionscluster {
        /// Path: `/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactionsclusters/{id_transactionscluster}`
        public let path: String

        /// Edit a clustered transaction
        ///
        /// Form params : - next_date (date): Date of transaction - mean_amount (decimal): Mean Amount - wording (string): name of transaction - id_account (id): related account - id_category (id): related category - enabled (bool): is enabled<br><br>
        public func put(expand: String? = nil) -> Request<BudgeaAPI.TransactionsCluster> {
            .put(path, query: makePutQuery(expand))
        }

        private func makePutQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Delete a clustered transaction
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.TransactionsCluster> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser.Connections.WithIDConnection {
    public var informations: Informations {
        Informations(path: path + "/informations")
    }

    public struct Informations {
        /// Path: `/users/{id_user}/connections/{id_connection}/informations`
        public let path: String

        /// Get connection additionnal informations
        ///
        /// <br><br>
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var connections: [BudgeaAPI.Connection]
            /// Total number of results
            public var total: Double?

            public init(connections: [BudgeaAPI.Connection], total: Double? = nil) {
                self.connections = connections
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser.Connections.WithIDConnection {
    public var logs: Logs {
        Logs(path: path + "/logs")
    }

    public struct Logs {
        /// Path: `/users/{id_user}/connections/{id_connection}/logs`
        public let path: String

        /// Get connection logs
        ///
        /// Get logs about connections.<br><br>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var connectionlogs: [BudgeaAPI.ConnectionLog]
            /// Total number of results
            public var total: Double?

            public init(connectionlogs: [BudgeaAPI.ConnectionLog], total: Double? = nil) {
                self.connectionlogs = connectionlogs
                self.total = total
            }
        }

        public struct GetParameters {
            public var limit: Int?
            public var offset: Int?
            public var minDate: NaiveDate?
            public var maxDate: NaiveDate?
            public var period: String?
            public var idUser: Int?
            public var idConnection: Int?
            public var idConnector: Int?
            public var connectorUUID: String?
            public var error: String?
            public var idSource: Int?
            public var idMax: Int?
            public var expand: String?

            public init(limit: Int? = nil, offset: Int? = nil, minDate: NaiveDate? = nil, maxDate: NaiveDate? = nil, period: String? = nil, idUser: Int? = nil, idConnection: Int? = nil, idConnector: Int? = nil, connectorUUID: String? = nil, error: String? = nil, idSource: Int? = nil, idMax: Int? = nil, expand: String? = nil) {
                self.limit = limit
                self.offset = offset
                self.minDate = minDate
                self.maxDate = maxDate
                self.period = period
                self.idUser = idUser
                self.idConnection = idConnection
                self.idConnector = idConnector
                self.connectorUUID = connectorUUID
                self.error = error
                self.idSource = idSource
                self.idMax = idMax
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(minDate, forKey: "min_date")
                encoder.encode(maxDate, forKey: "max_date")
                encoder.encode(period, forKey: "period")
                encoder.encode(idUser, forKey: "id_user")
                encoder.encode(idConnection, forKey: "id_connection")
                encoder.encode(idConnector, forKey: "id_connector")
                encoder.encode(connectorUUID, forKey: "connector_uuid")
                encoder.encode(error, forKey: "error")
                encoder.encode(idSource, forKey: "id_source")
                encoder.encode(idMax, forKey: "id_max")
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.WithIDUser.Connections.WithIDConnection {
    public var sources: Sources {
        Sources(path: path + "/sources")
    }

    public struct Sources {
        /// Path: `/users/{id_user}/connections/{id_connection}/sources`
        public let path: String

        /// Get connection sources
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var sources: [BudgeaAPI.ConnectionSource]
            /// Total number of results
            public var total: Double?

            public init(sources: [BudgeaAPI.ConnectionSource], total: Double? = nil) {
                self.sources = sources
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser.Connections.WithIDConnection.Sources {
    public func idSource(_ idSource: Int) -> WithIDSource {
        WithIDSource(path: "\(path)/\(idSource)")
    }

    public struct WithIDSource {
        /// Path: `/users/{id_user}/connections/{id_connection}/sources/{id_source}`
        public let path: String

        /// "
        ///
        /// This endpoint is used to enable a source or force a synchronization on it.<br><br>
        public func post(isBackground: Bool? = nil, expand: String? = nil, _ body: Data) -> Request<BudgeaAPI.ConnectionSource> {
            .post(path, query: makePostQuery(isBackground, expand), body: body)
        }

        private func makePostQuery(_ isBackground: Bool?, _ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isBackground, forKey: "background")
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Update connection source
        ///
        /// This endpoint is used to enable a source or force a synchronization on it.<br><br>
        public func put(isBackground: Bool? = nil, expand: String? = nil, _ body: Data) -> Request<BudgeaAPI.ConnectionSource> {
            .put(path, query: makePutQuery(isBackground, expand), body: body)
        }

        private func makePutQuery(_ isBackground: Bool?, _ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isBackground, forKey: "background")
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Disable a connection source
        ///
        /// This will make it so the specified source will not be synchronized anymore.<br><br>
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.ConnectionSource> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser.Connections.WithIDConnection {
    public var transactionsclusters: Transactionsclusters {
        Transactionsclusters(path: path + "/transactionsclusters")
    }

    public struct Transactionsclusters {
        /// Path: `/users/{id_user}/connections/{id_connection}/transactionsclusters`
        public let path: String

        /// Get clustered transactions
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            /// Total number of results
            public var total: Double?
            public var transactionsclusters: [BudgeaAPI.TransactionsCluster]

            public init(total: Double? = nil, transactionsclusters: [BudgeaAPI.TransactionsCluster]) {
                self.total = total
                self.transactionsclusters = transactionsclusters
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Create clustered transaction
        ///
        /// Form params : - next_date (date) required: Date of transaction - mean_amount (decimal) required: Mean Amount - wording (string) required: name of transaction - id_account (id) required: related account<br><br>
        public func post(expand: String? = nil) -> Request<BudgeaAPI.TransactionsCluster> {
            .post(path, query: makePostQuery(expand))
        }

        private func makePostQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser.Connections.WithIDConnection.Transactionsclusters {
    public func idTransactionscluster(_ idTransactionscluster: Int) -> WithIDTransactionscluster {
        WithIDTransactionscluster(path: "\(path)/\(idTransactionscluster)")
    }

    public struct WithIDTransactionscluster {
        /// Path: `/users/{id_user}/connections/{id_connection}/transactionsclusters/{id_transactionscluster}`
        public let path: String

        /// Edit a clustered transaction
        ///
        /// Form params : - next_date (date): Date of transaction - mean_amount (decimal): Mean Amount - wording (string): name of transaction - id_account (id): related account - id_category (id): related category - enabled (bool): is enabled<br><br>
        public func put(expand: String? = nil) -> Request<BudgeaAPI.TransactionsCluster> {
            .put(path, query: makePutQuery(expand))
        }

        private func makePutQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Delete a clustered transaction
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.TransactionsCluster> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser {
    public var forecast: Forecast {
        Forecast(path: path + "/forecast")
    }

    public struct Forecast {
        /// Path: `/users/{id_user}/forecast`
        public let path: String

        /// Get forecast
        public var get: Request<Void> {
            .get(path)
        }
    }
}

extension Paths.Users.WithIDUser {
    public var logs: Logs {
        Logs(path: path + "/logs")
    }

    public struct Logs {
        /// Path: `/users/{id_user}/logs`
        public let path: String

        /// Get connection logs
        ///
        /// Get logs about connections.<br><br>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var connectionlogs: [BudgeaAPI.ConnectionLog]
            /// Total number of results
            public var total: Double?

            public init(connectionlogs: [BudgeaAPI.ConnectionLog], total: Double? = nil) {
                self.connectionlogs = connectionlogs
                self.total = total
            }
        }

        public struct GetParameters {
            public var limit: Int?
            public var offset: Int?
            public var minDate: NaiveDate?
            public var maxDate: NaiveDate?
            public var period: String?
            public var idUser: Int?
            public var idConnection: Int?
            public var idConnector: Int?
            public var connectorUUID: String?
            public var error: String?
            public var idSource: Int?
            public var idMax: Int?
            public var expand: String?

            public init(limit: Int? = nil, offset: Int? = nil, minDate: NaiveDate? = nil, maxDate: NaiveDate? = nil, period: String? = nil, idUser: Int? = nil, idConnection: Int? = nil, idConnector: Int? = nil, connectorUUID: String? = nil, error: String? = nil, idSource: Int? = nil, idMax: Int? = nil, expand: String? = nil) {
                self.limit = limit
                self.offset = offset
                self.minDate = minDate
                self.maxDate = maxDate
                self.period = period
                self.idUser = idUser
                self.idConnection = idConnection
                self.idConnector = idConnector
                self.connectorUUID = connectorUUID
                self.error = error
                self.idSource = idSource
                self.idMax = idMax
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(minDate, forKey: "min_date")
                encoder.encode(maxDate, forKey: "max_date")
                encoder.encode(period, forKey: "period")
                encoder.encode(idUser, forKey: "id_user")
                encoder.encode(idConnection, forKey: "id_connection")
                encoder.encode(idConnector, forKey: "id_connector")
                encoder.encode(connectorUUID, forKey: "connector_uuid")
                encoder.encode(error, forKey: "error")
                encoder.encode(idSource, forKey: "id_source")
                encoder.encode(idMax, forKey: "id_max")
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

extension Paths.Users.WithIDUser {
    public var profiles: Profiles {
        Profiles(path: path + "/profiles")
    }

    public struct Profiles {
        /// Path: `/users/{id_user}/profiles`
        public let path: String

        /// Get profiles
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var profiles: [BudgeaAPI.Profile]
            /// Total number of results
            public var total: Double?

            public init(profiles: [BudgeaAPI.Profile], total: Double? = nil) {
                self.profiles = profiles
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser.Profiles {
    public var main: Main {
        Main(path: path + "/main")
    }

    public struct Main {
        /// Path: `/users/{id_user}/profiles/main`
        public let path: String

        /// Get the main profile
        public func get(expand: String? = nil) -> Request<BudgeaAPI.Profile> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser.Profiles {
    public func idProfile(_ idProfile: Int) -> WithIDProfile {
        WithIDProfile(path: "\(path)/\(idProfile)")
    }

    public struct WithIDProfile {
        /// Path: `/users/{id_user}/profiles/{id_profile}`
        public let path: String

        /// Get a profile
        public func get(expand: String? = nil) -> Request<BudgeaAPI.Profile> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser {
    public var token: Token {
        Token(path: path + "/token")
    }

    public struct Token {
        /// Path: `/users/{id_user}/token`
        public let path: String

        /// Create a token
        ///
        /// Create an access_token for this user and get it.<br><br>
        public func post(_ body: Data) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            public var token: AnyJSON

            public init(token: AnyJSON) {
                self.token = token
            }
        }
    }
}

extension Paths.Users.WithIDUser {
    public var transactionsclusters: Transactionsclusters {
        Transactionsclusters(path: path + "/transactionsclusters")
    }

    public struct Transactionsclusters {
        /// Path: `/users/{id_user}/transactionsclusters`
        public let path: String

        /// Get clustered transactions
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            /// Total number of results
            public var total: Double?
            public var transactionsclusters: [BudgeaAPI.TransactionsCluster]

            public init(total: Double? = nil, transactionsclusters: [BudgeaAPI.TransactionsCluster]) {
                self.total = total
                self.transactionsclusters = transactionsclusters
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Create clustered transaction
        ///
        /// Form params : - next_date (date) required: Date of transaction - mean_amount (decimal) required: Mean Amount - wording (string) required: name of transaction - id_account (id) required: related account<br><br>
        public func post(expand: String? = nil) -> Request<BudgeaAPI.TransactionsCluster> {
            .post(path, query: makePostQuery(expand))
        }

        private func makePostQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Users.WithIDUser.Transactionsclusters {
    public func idTransactionscluster(_ idTransactionscluster: Int) -> WithIDTransactionscluster {
        WithIDTransactionscluster(path: "\(path)/\(idTransactionscluster)")
    }

    public struct WithIDTransactionscluster {
        /// Path: `/users/{id_user}/transactionsclusters/{id_transactionscluster}`
        public let path: String

        /// Edit a clustered transaction
        ///
        /// Form params : - next_date (date): Date of transaction - mean_amount (decimal): Mean Amount - wording (string): name of transaction - id_account (id): related account - id_category (id): related category - enabled (bool): is enabled<br><br>
        public func put(expand: String? = nil) -> Request<BudgeaAPI.TransactionsCluster> {
            .put(path, query: makePutQuery(expand))
        }

        private func makePutQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Delete a clustered transaction
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.TransactionsCluster> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths {
    public static var webauth: Webauth {
        Webauth(path: "/webauth")
    }

    public struct Webauth {
        /// Path: `/webauth`
        public let path: String

        /// First step to establish an oAuth2 connection.
        ///
        /// The route encapsulate 2 functionalities: 1. Create or update a connection through oAuth2 session.<br><br>2. Execute a transfer through OAuth2 session.
        public var get: Request<Void> {
            .get(path)
        }
    }
}

extension Paths {
    public static var webhooks: Webhooks {
        Webhooks(path: "/webhooks")
    }

    public struct Webhooks {
        /// Path: `/webhooks`
        public let path: String

        /// Get webhooks
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            /// Total number of results
            public var total: Double?
            public var webhooks: [BudgeaAPI.Webhook]

            public init(total: Double? = nil, webhooks: [BudgeaAPI.Webhook]) {
                self.total = total
                self.webhooks = webhooks
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Adds a new webhook
        public func post(expand: String? = nil, _ body: Data? = nil) -> Request<BudgeaAPI.Webhook> {
            .post(path, query: makePostQuery(expand), body: body)
        }

        private func makePostQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Deletes all webhooks
        ///
        /// Updates the deleted field with the date of the deletion<br><br>
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.Webhook> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Webhooks {
    public var auth: Auth {
        Auth(path: path + "/auth")
    }

    public struct Auth {
        /// Path: `/webhooks/auth`
        public let path: String

        /// Get webhooks authentication types
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            public var authproviders: [BudgeaAPI.AuthProvider]
            /// Total number of results
            public var total: Double?

            public init(authproviders: [BudgeaAPI.AuthProvider], total: Double? = nil) {
                self.authproviders = authproviders
                self.total = total
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Adds a new webhook authentication type
        public func post(expand: String? = nil, _ body: Data) -> Request<BudgeaAPI.AuthProvider> {
            .post(path, query: makePostQuery(expand), body: body)
        }

        private func makePostQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Deletes all webhook authentication types
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.AuthProvider> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Webhooks.Auth {
    public func idAuth(_ idAuth: Int) -> WithIDAuth {
        WithIDAuth(path: "\(path)/\(idAuth)")
    }

    public struct WithIDAuth {
        /// Path: `/webhooks/auth/{id_auth}`
        public let path: String

        /// Updates the webhook authentication type
        public func post(expand: String? = nil, _ body: Data) -> Request<BudgeaAPI.AuthProvider> {
            .post(path, query: makePostQuery(expand), body: body)
        }

        private func makePostQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Updates the webhook authentication type
        public func put(expand: String? = nil, _ body: Data) -> Request<BudgeaAPI.AuthProvider> {
            .put(path, query: makePutQuery(expand), body: body)
        }

        private func makePutQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Deletes the webhook authentication type
        ///
        /// Updates the deleted field with the date of the deletion<br><br>
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.AuthProvider> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Webhooks {
    public func idWebhook(_ idWebhook: Int) -> WithIDWebhook {
        WithIDWebhook(path: "\(path)/\(idWebhook)")
    }

    public struct WithIDWebhook {
        /// Path: `/webhooks/{id_webhook}`
        public let path: String

        /// Updates a webhook
        public func post(expand: String? = nil, _ body: Data) -> Request<BudgeaAPI.Webhook> {
            .post(path, query: makePostQuery(expand), body: body)
        }

        private func makePostQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Updates a webhook
        public func put(expand: String? = nil, _ body: Data) -> Request<BudgeaAPI.Webhook> {
            .put(path, query: makePutQuery(expand), body: body)
        }

        private func makePutQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Deletes a webhook
        ///
        /// Updates the deleted field with the date of the deletion<br><br>
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.Webhook> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Webhooks.WithIDWebhook {
    public var addToData: AddToData {
        AddToData(path: path + "/add_to_data")
    }

    public struct AddToData {
        /// Path: `/webhooks/{id_webhook}/add_to_data`
        public let path: String

        /// Retrieve the list of the value to add in webhooks when sending the requested webhook
        public func get(expand: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(expand))
        }

        public struct GetResponse: Decodable {
            /// Total number of results
            public var total: Double?
            public var webhooks: [BudgeaAPI.Webhook]

            public init(total: Double? = nil, webhooks: [BudgeaAPI.Webhook]) {
                self.total = total
                self.webhooks = webhooks
            }
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Setup a field to store in user config when calling the endpoint
        ///
        /// For each parameter, a value will be added in the webhook data. Use the key to set the name of the field. The values that can be added are to be found in the user configuration.<br><br>
        public func post(expand: String? = nil) -> Request<BudgeaAPI.Webhook> {
            .post(path, query: makePostQuery(expand))
        }

        private func makePostQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Delete all entries
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.Webhook> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Webhooks.WithIDWebhook.AddToData {
    public func key(_ key: String) -> WithKey {
        WithKey(path: "\(path)/\(key)")
    }

    public struct WithKey {
        /// Path: `/webhooks/{id_webhook}/add_to_data/{key}`
        public let path: String

        /// Retrieve the value to add in the requested webhook for the requested name
        public func get(expand: String? = nil) -> Request<BudgeaAPI.Webhook> {
            .get(path, query: makeGetQuery(expand))
        }

        private func makeGetQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Upate the requested field to store in user config when calling the endpoint
        ///
        /// For each parameter, a value will be added in the webhook data. Use the key to set the name of the field. The values that can be added are to be found in the user configuration.<br><br>
        public func post(expand: String? = nil) -> Request<BudgeaAPI.Webhook> {
            .post(path, query: makePostQuery(expand))
        }

        private func makePostQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }

        /// Delete the requested entry
        public func delete(expand: String? = nil) -> Request<BudgeaAPI.Webhook> {
            .delete(path, query: makeDeleteQuery(expand))
        }

        private func makeDeleteQuery(_ expand: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(expand, forKey: "expand")
            return encoder.items
        }
    }
}

extension Paths.Webhooks.WithIDWebhook {
    public var logs: Logs {
        Logs(path: path + "/logs")
    }

    public struct Logs {
        /// Path: `/webhooks/{id_webhook}/logs`
        public let path: String

        /// Get webhooks logs.
        ///
        /// Get logs of the webhooks.<br><br>By default, it selects logs for the last month. You can use "min_date" and "max_date" to change boundary dates.<br><br>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            /// Total number of results
            public var total: Double?
            public var webhooklogs: [BudgeaAPI.WebhookLog]

            public init(total: Double? = nil, webhooklogs: [BudgeaAPI.WebhookLog]) {
                self.total = total
                self.webhooklogs = webhooklogs
            }
        }

        public struct GetParameters {
            public var idUser: Int?
            public var limit: Int?
            public var offset: Int?
            public var minDate: NaiveDate?
            public var maxDate: NaiveDate?
            public var expand: String?

            public init(idUser: Int? = nil, limit: Int? = nil, offset: Int? = nil, minDate: NaiveDate? = nil, maxDate: NaiveDate? = nil, expand: String? = nil) {
                self.idUser = idUser
                self.limit = limit
                self.offset = offset
                self.minDate = minDate
                self.maxDate = maxDate
                self.expand = expand
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(idUser, forKey: "id_user")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(offset, forKey: "offset")
                encoder.encode(minDate, forKey: "min_date")
                encoder.encode(maxDate, forKey: "max_date")
                encoder.encode(expand, forKey: "expand")
                return encoder.items
            }
        }
    }
}

public enum Paths {}
