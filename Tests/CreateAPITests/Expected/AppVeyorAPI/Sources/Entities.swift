// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

/// Schema of object returned in 4XX and 5XX responses.
/// Note:  The name is unfortunate, since it conflicts with `java.lang.Error`
/// and other generic error classes.  It is the name used in XML responses,
/// so it is used for consistency and possible future XML deserialization
/// support.
public struct Error: Codable {
    public var message: String
    /// When present, this property is a map of property names in the format
    /// `request.<capitalized name>` to an `Array` of validation error
    /// message strings for the property.
    public var modelState: [String: [String]]?

    public init(message: String, modelState: [String: [String]]? = nil) {
        self.message = message
        self.modelState = modelState
    }
}

public struct Timestamped: Codable {
    public var created: Date?
    public var updated: Date?

    public init(created: Date? = nil, updated: Date? = nil) {
        self.created = created
        self.updated = updated
    }
}

/// A schema for values which have an undocumented/unknown type.
/// 
/// Although the type of such values could be left unspecified according to
/// JSON Schema (and by extension OpenAPI 2.0), such unspecified types cause
/// tool failures (e.g. swagger-codegen).  So this type can be used as a
/// placeholder to prevent errors and document the behavior.
public enum UnknownType: String, Codable, CaseIterable {
    case unknown
}

public enum BuildNotificationFrequency: String, Codable, CaseIterable {
    case all
    case myCommits
    case `none`
}

public enum DeploymentNotificationFrequency: String, Codable, CaseIterable {
    case all
    case `none`
}

/// Technically `roleId` has default value 0 and is not required, but
/// since role 0 never exists it would always cause a 404 response.
///
/// Example:
///
/// {
///   "email" : "john@smith.com",
///   "roleId" : 3040
/// }
public struct CollaboratorAddition: Codable {
    public var email: String
    public var roleID: Int

    public init(email: String, roleID: Int) {
        self.email = email
        self.roleID = roleID
    }

    private enum CodingKeys: String, CodingKey {
        case email
        case roleID = "roleId"
    }
}

/// Technically `userId` and `roleId` have default value 0 and are not
/// required, but since user 0 and role 0 never exist it would always cause
/// a 404 response.
///
/// Example:
///
/// {
///   "roleId" : 3040,
///   "userId" : 2018
/// }
public struct CollaboratorUpdate: Codable {
    public var userID: Int
    public var roleID: Int

    public init(userID: Int, roleID: Int) {
        self.userID = userID
        self.roleID = roleID
    }

    private enum CodingKeys: String, CodingKey {
        case userID = "userId"
        case roleID = "roleId"
    }
}

/// Available permission names.  The names correspond to the following groups:
/// #### AccountPermission
/// - ManageApplicationAuthorizations
/// - UpdateAccountDetails
/// - UpdateBillingDetails
/// #### BuildEnvironmentPermission
/// - ConfigureBuildEnvironment
/// #### DenyPermission
/// - DenyAllProjectsEnvironments
/// #### EnvironmentsPermission
/// - DeployToEnvironment
/// - ManageEnvironments
/// - UpdateEnvironmentSettings
/// #### ProjectsPermission
/// - ManageProjects
/// - RunProjectBuild
/// - UpdateProjectSettings
/// #### RolesPermission
/// - AddRole
/// - DeleteRole
/// - UpdateRoleDetails
/// #### UserPermission
/// - ConfigureApiKeys
/// #### UsersPermission
/// - AddUser
/// - DeleteUser
/// - UpdateUserDetails
public enum PermissionName: String, Codable, CaseIterable {
    case manageApplicationAuthorizations = "ManageApplicationAuthorizations"
    case updateAccountDetails = "UpdateAccountDetails"
    case updateBillingDetails = "UpdateBillingDetails"
    case configureBuildEnvironment = "ConfigureBuildEnvironment"
    case denyAllProjectsEnvironments = "DenyAllProjectsEnvironments"
    case deployToEnvironment = "DeployToEnvironment"
    case manageEnvironments = "ManageEnvironments"
    case updateEnvironmentSettings = "UpdateEnvironmentSettings"
    case manageProjects = "ManageProjects"
    case runProjectBuild = "RunProjectBuild"
    case updateProjectSettings = "UpdateProjectSettings"
    case addRole = "AddRole"
    case deleteRole = "DeleteRole"
    case updateRoleDetails = "UpdateRoleDetails"
    case configureAPIKeys = "ConfigureApiKeys"
    case addUser = "AddUser"
    case deleteUser = "DeleteUser"
    case updateUserDetails = "UpdateUserDetails"
}

public struct PermissionState: Codable {
    /// Available permission names.  The names correspond to the following groups:
    /// #### AccountPermission
    /// - ManageApplicationAuthorizations
    /// - UpdateAccountDetails
    /// - UpdateBillingDetails
    /// #### BuildEnvironmentPermission
    /// - ConfigureBuildEnvironment
    /// #### DenyPermission
    /// - DenyAllProjectsEnvironments
    /// #### EnvironmentsPermission
    /// - DeployToEnvironment
    /// - ManageEnvironments
    /// - UpdateEnvironmentSettings
    /// #### ProjectsPermission
    /// - ManageProjects
    /// - RunProjectBuild
    /// - UpdateProjectSettings
    /// #### RolesPermission
    /// - AddRole
    /// - DeleteRole
    /// - UpdateRoleDetails
    /// #### UserPermission
    /// - ConfigureApiKeys
    /// #### UsersPermission
    /// - AddUser
    /// - DeleteUser
    /// - UpdateUserDetails
    public var name: PermissionName
    public var description: String?
    /// State of the named permission.  `true` to allow, `false` to deny,
    /// missing to inherit.
    public var isAllowed: Bool?

    public init(name: PermissionName, description: String? = nil, isAllowed: Bool? = nil) {
        self.name = name
        self.description = description
        self.isAllowed = isAllowed
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case description
        case isAllowed = "allowed"
    }
}

public enum GroupName: String, Codable, CaseIterable {
    case account = "Account"
    case buildEnvironment = "BuildEnvironment"
    case deny = "Deny"
    case environments = "Environments"
    case projects = "Projects"
    case roles = "Roles"
    case user = "User"
    case users = "Users"
}

public struct GroupPermissions: Codable {
    public var name: GroupName
    public var permissions: [PermissionState]

    public init(name: GroupName, permissions: [PermissionState]) {
        self.name = name
        self.permissions = permissions
    }
}

/// Example:
///
/// {
///   "name" : "My Role"
/// }
public struct RoleAddition: Codable {
    public var name: String

    public init(name: String) {
        self.name = name
    }
}

/// Technically `roleId` has default value 0 and is not required, but
/// since role 0 never exists it would always cause a 404 response.
public struct Role: Codable {
    public var timestamped: Timestamped
    public var roleID: Int
    public var name: String
    public var isSystem: Bool?

    public init(timestamped: Timestamped, roleID: Int, name: String, isSystem: Bool? = nil) {
        self.timestamped = timestamped
        self.roleID = roleID
        self.name = name
        self.isSystem = isSystem
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.timestamped = try Timestamped(from: decoder)
        self.roleID = try values.decode(Int.self, forKey: "roleId")
        self.name = try values.decode(String.self, forKey: "name")
        self.isSystem = try values.decodeIfPresent(Bool.self, forKey: "isSystem")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(timestamped, forKey: "timestamped")
        try values.encode(roleID, forKey: "roleId")
        try values.encode(name, forKey: "name")
        try values.encodeIfPresent(isSystem, forKey: "isSystem")
    }
}

public struct RoleWithGroups: Codable {
    /// Technically `roleId` has default value 0 and is not required, but
    /// since role 0 never exists it would always cause a 404 response.
    public var role: Role
    public var groups: [GroupPermissions]?

    public init(role: Role, groups: [GroupPermissions]? = nil) {
        self.role = role
        self.groups = groups
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.role = try Role(from: decoder)
        self.groups = try values.decodeIfPresent([GroupPermissions].self, forKey: "groups")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(role, forKey: "role")
        try values.encodeIfPresent(groups, forKey: "groups")
    }
}

/// Example:
///
/// {
///   "confirmPassword" : "password",
///   "email" : "john@smith.com",
///   "fullName" : "John Smith",
///   "generatePassword" : false,
///   "password" : "password",
///   "roleId" : 4
/// }
public struct UserAddition: Codable {
    public var fullName: String
    public var email: String
    /// Technically `roleId` has default value 0 and is not required, but
    /// since role 0 never exists it would always cause a 404 response.
    public var roleID: Int
    public var isGeneratePassword: Bool?
    public var password: String?
    public var confirmPassword: String?

    public init(fullName: String, email: String, roleID: Int, isGeneratePassword: Bool? = nil, password: String? = nil, confirmPassword: String? = nil) {
        self.fullName = fullName
        self.email = email
        self.roleID = roleID
        self.isGeneratePassword = isGeneratePassword
        self.password = password
        self.confirmPassword = confirmPassword
    }

    private enum CodingKeys: String, CodingKey {
        case fullName
        case email
        case roleID = "roleId"
        case isGeneratePassword = "generatePassword"
        case password
        case confirmPassword
    }
}

public struct UserAccountSettings: Codable {
    public var successfulBuildNotification: BuildNotificationFrequency
    public var failedBuildNotification: BuildNotificationFrequency
    /// Note that this value is `true` on user creation, but behaves as
    /// `false` when not specified on update.
    public var isNotifyWhenBuildStatusChangedOnly: Bool
    public var successfulDeploymentNotification: DeploymentNotificationFrequency
    public var failedDeploymentNotification: DeploymentNotificationFrequency
    /// Note that this value is `true` on user creation, but behaves as
    /// `false` when not specified on update.
    public var isNotifyWhenDeploymentStatusChangedOnly: Bool

    public init(successfulBuildNotification: BuildNotificationFrequency, failedBuildNotification: BuildNotificationFrequency, isNotifyWhenBuildStatusChangedOnly: Bool? = nil, successfulDeploymentNotification: DeploymentNotificationFrequency, failedDeploymentNotification: DeploymentNotificationFrequency, isNotifyWhenDeploymentStatusChangedOnly: Bool? = nil) {
        self.successfulBuildNotification = successfulBuildNotification
        self.failedBuildNotification = failedBuildNotification
        self.isNotifyWhenBuildStatusChangedOnly = isNotifyWhenBuildStatusChangedOnly ?? false
        self.successfulDeploymentNotification = successfulDeploymentNotification
        self.failedDeploymentNotification = failedDeploymentNotification
        self.isNotifyWhenDeploymentStatusChangedOnly = isNotifyWhenDeploymentStatusChangedOnly ?? false
    }

    private enum CodingKeys: String, CodingKey {
        case successfulBuildNotification
        case failedBuildNotification
        case isNotifyWhenBuildStatusChangedOnly = "notifyWhenBuildStatusChangedOnly"
        case successfulDeploymentNotification
        case failedDeploymentNotification
        case isNotifyWhenDeploymentStatusChangedOnly = "notifyWhenDeploymentStatusChangedOnly"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.successfulBuildNotification = try values.decode(BuildNotificationFrequency.self, forKey: .successfulBuildNotification)
        self.failedBuildNotification = try values.decode(BuildNotificationFrequency.self, forKey: .failedBuildNotification)
        self.isNotifyWhenBuildStatusChangedOnly = try values.decodeIfPresent(Bool.self, forKey: .isNotifyWhenBuildStatusChangedOnly) ?? false
        self.successfulDeploymentNotification = try values.decode(DeploymentNotificationFrequency.self, forKey: .successfulDeploymentNotification)
        self.failedDeploymentNotification = try values.decode(DeploymentNotificationFrequency.self, forKey: .failedDeploymentNotification)
        self.isNotifyWhenDeploymentStatusChangedOnly = try values.decodeIfPresent(Bool.self, forKey: .isNotifyWhenDeploymentStatusChangedOnly) ?? false
    }
}

public struct UserAccount: Codable {
    public var timestamped: Timestamped
    public var accountID: Int?
    public var accountName: String?
    public var isOwner: Bool?
    public var isCollaborator: Bool?
    public var userID: Int?
    public var fullName: String
    public var email: String
    public var password: String?
    public var roleID: Int?
    public var roleName: String?
    public var isTwoFactorAuthEnabled: Bool?
    public var pageSize: Int?

    public init(timestamped: Timestamped, accountID: Int? = nil, accountName: String? = nil, isOwner: Bool? = nil, isCollaborator: Bool? = nil, userID: Int? = nil, fullName: String, email: String, password: String? = nil, roleID: Int? = nil, roleName: String? = nil, isTwoFactorAuthEnabled: Bool? = nil, pageSize: Int? = nil) {
        self.timestamped = timestamped
        self.accountID = accountID
        self.accountName = accountName
        self.isOwner = isOwner
        self.isCollaborator = isCollaborator
        self.userID = userID
        self.fullName = fullName
        self.email = email
        self.password = password
        self.roleID = roleID
        self.roleName = roleName
        self.isTwoFactorAuthEnabled = isTwoFactorAuthEnabled
        self.pageSize = pageSize
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.timestamped = try Timestamped(from: decoder)
        self.accountID = try values.decodeIfPresent(Int.self, forKey: "accountId")
        self.accountName = try values.decodeIfPresent(String.self, forKey: "accountName")
        self.isOwner = try values.decodeIfPresent(Bool.self, forKey: "isOwner")
        self.isCollaborator = try values.decodeIfPresent(Bool.self, forKey: "isCollaborator")
        self.userID = try values.decodeIfPresent(Int.self, forKey: "userId")
        self.fullName = try values.decode(String.self, forKey: "fullName")
        self.email = try values.decode(String.self, forKey: "email")
        self.password = try values.decodeIfPresent(String.self, forKey: "password")
        self.roleID = try values.decodeIfPresent(Int.self, forKey: "roleId")
        self.roleName = try values.decodeIfPresent(String.self, forKey: "roleName")
        self.isTwoFactorAuthEnabled = try values.decodeIfPresent(Bool.self, forKey: "twoFactorAuthEnabled")
        self.pageSize = try values.decodeIfPresent(Int.self, forKey: "pageSize")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(timestamped, forKey: "timestamped")
        try values.encodeIfPresent(accountID, forKey: "accountId")
        try values.encodeIfPresent(accountName, forKey: "accountName")
        try values.encodeIfPresent(isOwner, forKey: "isOwner")
        try values.encodeIfPresent(isCollaborator, forKey: "isCollaborator")
        try values.encodeIfPresent(userID, forKey: "userId")
        try values.encode(fullName, forKey: "fullName")
        try values.encode(email, forKey: "email")
        try values.encodeIfPresent(password, forKey: "password")
        try values.encodeIfPresent(roleID, forKey: "roleId")
        try values.encodeIfPresent(roleName, forKey: "roleName")
        try values.encodeIfPresent(isTwoFactorAuthEnabled, forKey: "twoFactorAuthEnabled")
        try values.encodeIfPresent(pageSize, forKey: "pageSize")
    }
}

/// The roles property contains all roles, not only the role for which the user is a member.
public struct UserAccountRolesResults: Codable {
    public var user: UserAccount?
    public var roles: [Role]?

    public init(user: UserAccount? = nil, roles: [Role]? = nil) {
        self.user = user
        self.roles = roles
    }
}

public struct StringValueObject: Codable {
    public var value: String?

    public init(value: String? = nil) {
        self.value = value
    }
}

public enum Status: String, Codable, CaseIterable {
    case cancelled
    case cancelling
    case failed
    case queued
    case running
    case starting
    case success
}

public struct Job: Codable {
    public var timestamped: Timestamped
    public var jobID: String?
    public var name: String?
    public var status: Status?
    public var started: Date?
    public var finished: Date?

    public init(timestamped: Timestamped, jobID: String? = nil, name: String? = nil, status: Status? = nil, started: Date? = nil, finished: Date? = nil) {
        self.timestamped = timestamped
        self.jobID = jobID
        self.name = name
        self.status = status
        self.started = started
        self.finished = finished
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.timestamped = try Timestamped(from: decoder)
        self.jobID = try values.decodeIfPresent(String.self, forKey: "jobId")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.status = try Status(from: decoder)
        self.started = try values.decodeIfPresent(Date.self, forKey: "started")
        self.finished = try values.decodeIfPresent(Date.self, forKey: "finished")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(timestamped, forKey: "timestamped")
        try values.encodeIfPresent(jobID, forKey: "jobId")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(status, forKey: "status")
        try values.encodeIfPresent(started, forKey: "started")
        try values.encodeIfPresent(finished, forKey: "finished")
    }
}

public enum OSType: String, Codable, CaseIterable {
    case ubuntu = "Ubuntu"
    case windows = "Windows"
}

public struct BuildJob: Codable {
    public var job: Job
    public var osType: OSType?
    public var allowFailure: Bool?
    public var messagesCount: Int?
    public var compilationMessagesCount: Int?
    public var compilationErrorsCount: Int?
    public var compilationWarningsCount: Int?
    public var testsCount: Int?
    public var passedTestsCount: Int?
    public var failedTestsCount: Int?
    public var artifactsCount: Int?

    public init(job: Job, osType: OSType? = nil, allowFailure: Bool? = nil, messagesCount: Int? = nil, compilationMessagesCount: Int? = nil, compilationErrorsCount: Int? = nil, compilationWarningsCount: Int? = nil, testsCount: Int? = nil, passedTestsCount: Int? = nil, failedTestsCount: Int? = nil, artifactsCount: Int? = nil) {
        self.job = job
        self.osType = osType
        self.allowFailure = allowFailure
        self.messagesCount = messagesCount
        self.compilationMessagesCount = compilationMessagesCount
        self.compilationErrorsCount = compilationErrorsCount
        self.compilationWarningsCount = compilationWarningsCount
        self.testsCount = testsCount
        self.passedTestsCount = passedTestsCount
        self.failedTestsCount = failedTestsCount
        self.artifactsCount = artifactsCount
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.job = try Job(from: decoder)
        self.osType = try OSType(from: decoder)
        self.allowFailure = try values.decodeIfPresent(Bool.self, forKey: "allowFailure")
        self.messagesCount = try values.decodeIfPresent(Int.self, forKey: "messagesCount")
        self.compilationMessagesCount = try values.decodeIfPresent(Int.self, forKey: "compilationMessagesCount")
        self.compilationErrorsCount = try values.decodeIfPresent(Int.self, forKey: "compilationErrorsCount")
        self.compilationWarningsCount = try values.decodeIfPresent(Int.self, forKey: "compilationWarningsCount")
        self.testsCount = try values.decodeIfPresent(Int.self, forKey: "testsCount")
        self.passedTestsCount = try values.decodeIfPresent(Int.self, forKey: "passedTestsCount")
        self.failedTestsCount = try values.decodeIfPresent(Int.self, forKey: "failedTestsCount")
        self.artifactsCount = try values.decodeIfPresent(Int.self, forKey: "artifactsCount")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(job, forKey: "job")
        try values.encodeIfPresent(osType, forKey: "osType")
        try values.encodeIfPresent(allowFailure, forKey: "allowFailure")
        try values.encodeIfPresent(messagesCount, forKey: "messagesCount")
        try values.encodeIfPresent(compilationMessagesCount, forKey: "compilationMessagesCount")
        try values.encodeIfPresent(compilationErrorsCount, forKey: "compilationErrorsCount")
        try values.encodeIfPresent(compilationWarningsCount, forKey: "compilationWarningsCount")
        try values.encodeIfPresent(testsCount, forKey: "testsCount")
        try values.encodeIfPresent(passedTestsCount, forKey: "passedTestsCount")
        try values.encodeIfPresent(failedTestsCount, forKey: "failedTestsCount")
        try values.encodeIfPresent(artifactsCount, forKey: "artifactsCount")
    }
}

/// Example:
///
/// {
///   "accountName" : "your-account-name",
///   "branch" : "master",
///   "environmentVariables" : {
///     "another_var" : "another value",
///     "my_var" : "value"
///   },
///   "projectSlug" : "project-slug-from-url"
/// }
public struct BuildStartRequest: Codable {
    public var accountName: String
    public var projectSlug: String
    public var branch: String?
    public var commitID: String?
    /// Can not be used with `branch` or `commitId`
    public var pullRequestID: Int?
    public var environmentVariables: [String: String]?

    public init(accountName: String, projectSlug: String, branch: String? = nil, commitID: String? = nil, pullRequestID: Int? = nil, environmentVariables: [String: String]? = nil) {
        self.accountName = accountName
        self.projectSlug = projectSlug
        self.branch = branch
        self.commitID = commitID
        self.pullRequestID = pullRequestID
        self.environmentVariables = environmentVariables
    }

    private enum CodingKeys: String, CodingKey {
        case accountName
        case projectSlug
        case branch
        case commitID = "commitId"
        case pullRequestID = "pullRequestId"
        case environmentVariables
    }
}

/// Example:
///
/// {
///   "buildId" : 23864,
///   "reRunIncomplete" : true
/// }
public struct ReRunBuildRequest: Codable {
    public var buildID: Int
    /// Set `reRunIncomplete` set to `false` (default value) for full build re-run. Set it set to `true` to rerun only failed or cancelled jobs in multijob build.
    public var isReRunIncomplete: Bool?

    public init(buildID: Int, isReRunIncomplete: Bool? = nil) {
        self.buildID = buildID
        self.isReRunIncomplete = isReRunIncomplete
    }

    private enum CodingKeys: String, CodingKey {
        case buildID = "buildId"
        case isReRunIncomplete = "reRunIncomplete"
    }
}

public enum BuildMessageCategory: String, Codable, CaseIterable {
    case information
    case warning
}

public struct BuildMessage: Codable {
    public var category: BuildMessageCategory?
    public var message: String?
    public var created: Date?

    public init(category: BuildMessageCategory? = nil, message: String? = nil, created: Date? = nil) {
        self.category = category
        self.message = message
        self.created = created
    }
}

public struct BuildLookupModel: Codable {
    public var branch: String?
    public var buildID: Int?
    public var message: String?
    public var version: String?

    public init(branch: String? = nil, buildID: Int? = nil, message: String? = nil, version: String? = nil) {
        self.branch = branch
        self.buildID = buildID
        self.message = message
        self.version = version
    }

    private enum CodingKeys: String, CodingKey {
        case branch
        case buildID = "buildId"
        case message
        case version
    }
}

public struct Build: Codable {
    public var buildLookupModel: BuildLookupModel
    public var timestamped: Timestamped
    public var projectID: Int?
    /// Always empty in getProjectHistory and startDeployment responses.
    public var jobs: [BuildJob]?
    public var buildNumber: Int?
    public var messageExtended: String?
    public var isTag: Bool?
    public var commitID: String?
    public var authorName: String?
    public var authorUsername: String?
    public var committerName: String?
    public var committerUsername: String?
    public var committed: Date?
    public var pullRequestID: Int?
    public var pullRequestName: String?
    public var messages: [BuildMessage]?
    public var status: Status?
    public var started: Date?
    public var finished: Date?

    public init(buildLookupModel: BuildLookupModel, timestamped: Timestamped, projectID: Int? = nil, jobs: [BuildJob]? = nil, buildNumber: Int? = nil, messageExtended: String? = nil, isTag: Bool? = nil, commitID: String? = nil, authorName: String? = nil, authorUsername: String? = nil, committerName: String? = nil, committerUsername: String? = nil, committed: Date? = nil, pullRequestID: Int? = nil, pullRequestName: String? = nil, messages: [BuildMessage]? = nil, status: Status? = nil, started: Date? = nil, finished: Date? = nil) {
        self.buildLookupModel = buildLookupModel
        self.timestamped = timestamped
        self.projectID = projectID
        self.jobs = jobs
        self.buildNumber = buildNumber
        self.messageExtended = messageExtended
        self.isTag = isTag
        self.commitID = commitID
        self.authorName = authorName
        self.authorUsername = authorUsername
        self.committerName = committerName
        self.committerUsername = committerUsername
        self.committed = committed
        self.pullRequestID = pullRequestID
        self.pullRequestName = pullRequestName
        self.messages = messages
        self.status = status
        self.started = started
        self.finished = finished
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.buildLookupModel = try BuildLookupModel(from: decoder)
        self.timestamped = try Timestamped(from: decoder)
        self.projectID = try values.decodeIfPresent(Int.self, forKey: "projectId")
        self.jobs = try values.decodeIfPresent([BuildJob].self, forKey: "jobs")
        self.buildNumber = try values.decodeIfPresent(Int.self, forKey: "buildNumber")
        self.messageExtended = try values.decodeIfPresent(String.self, forKey: "messageExtended")
        self.isTag = try values.decodeIfPresent(Bool.self, forKey: "isTag")
        self.commitID = try values.decodeIfPresent(String.self, forKey: "commitId")
        self.authorName = try values.decodeIfPresent(String.self, forKey: "authorName")
        self.authorUsername = try values.decodeIfPresent(String.self, forKey: "authorUsername")
        self.committerName = try values.decodeIfPresent(String.self, forKey: "committerName")
        self.committerUsername = try values.decodeIfPresent(String.self, forKey: "committerUsername")
        self.committed = try values.decodeIfPresent(Date.self, forKey: "committed")
        self.pullRequestID = try values.decodeIfPresent(Int.self, forKey: "pullRequestId")
        self.pullRequestName = try values.decodeIfPresent(String.self, forKey: "pullRequestName")
        self.messages = try values.decodeIfPresent([BuildMessage].self, forKey: "messages")
        self.status = try Status(from: decoder)
        self.started = try values.decodeIfPresent(Date.self, forKey: "started")
        self.finished = try values.decodeIfPresent(Date.self, forKey: "finished")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(buildLookupModel, forKey: "buildLookupModel")
        try values.encode(timestamped, forKey: "timestamped")
        try values.encodeIfPresent(projectID, forKey: "projectId")
        try values.encodeIfPresent(jobs, forKey: "jobs")
        try values.encodeIfPresent(buildNumber, forKey: "buildNumber")
        try values.encodeIfPresent(messageExtended, forKey: "messageExtended")
        try values.encodeIfPresent(isTag, forKey: "isTag")
        try values.encodeIfPresent(commitID, forKey: "commitId")
        try values.encodeIfPresent(authorName, forKey: "authorName")
        try values.encodeIfPresent(authorUsername, forKey: "authorUsername")
        try values.encodeIfPresent(committerName, forKey: "committerName")
        try values.encodeIfPresent(committerUsername, forKey: "committerUsername")
        try values.encodeIfPresent(committed, forKey: "committed")
        try values.encodeIfPresent(pullRequestID, forKey: "pullRequestId")
        try values.encodeIfPresent(pullRequestName, forKey: "pullRequestName")
        try values.encodeIfPresent(messages, forKey: "messages")
        try values.encodeIfPresent(status, forKey: "status")
        try values.encodeIfPresent(started, forKey: "started")
        try values.encodeIfPresent(finished, forKey: "finished")
    }
}

public enum RepositoryAuthenticationType: String, Codable, CaseIterable {
    case credentials
    case ssh
}

public enum RepositoryProvider: String, Codable, CaseIterable {
    case bitBucket
    case git
    case gitHub
    case gitLab
    case kiln
    case mercurial
    case stash
    case subversion
    case vso
}

public enum RepositoryScm: String, Codable, CaseIterable {
    case git
    case mercurial
    case subversion
}

public enum AccessRightName: String, Codable, CaseIterable {
    case delete = "Delete"
    case deploy = "Deploy"
    case runBuild = "RunBuild"
    case update = "Update"
    case view = "View"
}

public struct AceAccessRightDefinition: Codable {
    public var name: AccessRightName
    public var description: String?

    public init(name: AccessRightName, description: String? = nil) {
        self.name = name
        self.description = description
    }
}

public struct AceAccessRight: Codable {
    public var name: AccessRightName
    public var isAllowed: Bool?

    public init(name: AccessRightName, isAllowed: Bool? = nil) {
        self.name = name
        self.isAllowed = isAllowed
    }

    private enum CodingKeys: String, CodingKey {
        case name
        case isAllowed = "allowed"
    }
}

public struct RoleAce: Codable {
    public var roleID: Int?
    public var name: String?
    public var isAdmin: Bool?
    public var accessRights: [AceAccessRight]?

    public init(roleID: Int? = nil, name: String? = nil, isAdmin: Bool? = nil, accessRights: [AceAccessRight]? = nil) {
        self.roleID = roleID
        self.name = name
        self.isAdmin = isAdmin
        self.accessRights = accessRights
    }

    private enum CodingKeys: String, CodingKey {
        case roleID = "roleId"
        case name
        case isAdmin
        case accessRights
    }
}

public struct SecurityDescriptor: Codable {
    public var accessRightDefinitions: [AceAccessRightDefinition]?
    public var roleAces: [RoleAce]?

    public init(accessRightDefinitions: [AceAccessRightDefinition]? = nil, roleAces: [RoleAce]? = nil) {
        self.accessRightDefinitions = accessRightDefinitions
        self.roleAces = roleAces
    }
}

public struct NuGetFeed: Codable {
    public var timestamped: Timestamped
    public var nuGetFeedID: Int?
    public var id: String?
    public var name: String?
    public var accountID: Int?
    public var projectID: Int?
    public var isPrivateProject: Bool?
    public var isPublishingEnabled: Bool?

    public init(timestamped: Timestamped, nuGetFeedID: Int? = nil, id: String? = nil, name: String? = nil, accountID: Int? = nil, projectID: Int? = nil, isPrivateProject: Bool? = nil, isPublishingEnabled: Bool? = nil) {
        self.timestamped = timestamped
        self.nuGetFeedID = nuGetFeedID
        self.id = id
        self.name = name
        self.accountID = accountID
        self.projectID = projectID
        self.isPrivateProject = isPrivateProject
        self.isPublishingEnabled = isPublishingEnabled
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.timestamped = try Timestamped(from: decoder)
        self.nuGetFeedID = try values.decodeIfPresent(Int.self, forKey: "nuGetFeedId")
        self.id = try values.decodeIfPresent(String.self, forKey: "id")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.accountID = try values.decodeIfPresent(Int.self, forKey: "accountId")
        self.projectID = try values.decodeIfPresent(Int.self, forKey: "projectId")
        self.isPrivateProject = try values.decodeIfPresent(Bool.self, forKey: "isPrivateProject")
        self.isPublishingEnabled = try values.decodeIfPresent(Bool.self, forKey: "publishingEnabled")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(timestamped, forKey: "timestamped")
        try values.encodeIfPresent(nuGetFeedID, forKey: "nuGetFeedId")
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(accountID, forKey: "accountId")
        try values.encodeIfPresent(projectID, forKey: "projectId")
        try values.encodeIfPresent(isPrivateProject, forKey: "isPrivateProject")
        try values.encodeIfPresent(isPublishingEnabled, forKey: "publishingEnabled")
    }
}

/// `repositoryAuthentication` is only used for git, mercurial, subversion `repositoryProvider`.
///
/// Example:
///
/// {
///   "repositoryName" : "FeodorFitsner\/demo-app",
///   "repositoryProvider" : "gitHub"
/// }
public struct ProjectAddition: Codable {
    public var repositoryProvider: RepositoryProvider
    /// URL when repositoryProvider is git, mercurial, subversion username/project when repositoryProvider is gitHub
    public var repositoryName: String
    public var repositoryAuthentication: RepositoryAuthenticationType?
    /// Required if repositoryAuthentication is credentials
    public var repositoryUsername: String?
    /// Required if repositoryAuthentication is credentials
    public var repositoryPassword: String?

    public init(repositoryProvider: RepositoryProvider, repositoryName: String, repositoryAuthentication: RepositoryAuthenticationType? = nil, repositoryUsername: String? = nil, repositoryPassword: String? = nil) {
        self.repositoryProvider = repositoryProvider
        self.repositoryName = repositoryName
        self.repositoryAuthentication = repositoryAuthentication
        self.repositoryUsername = repositoryUsername
        self.repositoryPassword = repositoryPassword
    }
}

public struct ProjectLookupModel: Codable {
    public var projectID: Int
    public var accountName: String?
    public var name: String?
    public var slug: String?

    public init(projectID: Int, accountName: String? = nil, name: String? = nil, slug: String? = nil) {
        self.projectID = projectID
        self.accountName = accountName
        self.name = name
        self.slug = slug
    }

    private enum CodingKeys: String, CodingKey {
        case projectID = "projectId"
        case accountName
        case name
        case slug
    }
}

public struct Project: Codable {
    public var projectLookupModel: ProjectLookupModel
    public var timestamped: Timestamped
    public var accountID: Int?
    /// Only non-empty for response from getProjects.
    public var builds: [Build]?
    public var currentBuildID: Int?
    public var repositoryType: RepositoryProvider?
    public var repositoryScm: RepositoryScm?
    public var repositoryName: String
    /// Not present in response from addProject.
    public var repositoryBranch: String?
    public var isPrivate: Bool?
    public var isGitHubApp: Bool?
    public var isSkipBranchesWithoutAppveyorYml: Bool?
    public var enableSecureVariablesInPullRequests: Bool?
    public var enableSecureVariablesInPullRequestsFromSameRepo: Bool?
    public var enableDeploymentInPullRequests: Bool?
    public var isSaveBuildCacheInPullRequests: Bool?
    public var isRollingBuilds: Bool?
    public var isRollingBuildsDoNotCancelRunningBuilds: Bool?
    public var isRollingBuildsOnlyForPullRequests: Bool?
    public var isAlwaysBuildClosedPullRequests: Bool?
    /// Comma-separated list of project tags for dynamic grouping.
    /// Appears that any input is accepted.  The returned value only
    /// contains case-preserving but insensitive unique values where
    /// spaces around "," are removed but otherwise preserved.  Empty
    /// values and items are allowed.
    public var tags: String?
    public var nuGetFeed: NuGetFeed?
    public var securityDescriptor: SecurityDescriptor?
    public var isDisablePushWebhooks: Bool?
    public var isDisablePullRequestWebhooks: Bool?

    public init(projectLookupModel: ProjectLookupModel, timestamped: Timestamped, accountID: Int? = nil, builds: [Build]? = nil, currentBuildID: Int? = nil, repositoryType: RepositoryProvider? = nil, repositoryScm: RepositoryScm? = nil, repositoryName: String, repositoryBranch: String? = nil, isPrivate: Bool? = nil, isGitHubApp: Bool? = nil, isSkipBranchesWithoutAppveyorYml: Bool? = nil, enableSecureVariablesInPullRequests: Bool? = nil, enableSecureVariablesInPullRequestsFromSameRepo: Bool? = nil, enableDeploymentInPullRequests: Bool? = nil, isSaveBuildCacheInPullRequests: Bool? = nil, isRollingBuilds: Bool? = nil, isRollingBuildsDoNotCancelRunningBuilds: Bool? = nil, isRollingBuildsOnlyForPullRequests: Bool? = nil, isAlwaysBuildClosedPullRequests: Bool? = nil, tags: String? = nil, nuGetFeed: NuGetFeed? = nil, securityDescriptor: SecurityDescriptor? = nil, isDisablePushWebhooks: Bool? = nil, isDisablePullRequestWebhooks: Bool? = nil) {
        self.projectLookupModel = projectLookupModel
        self.timestamped = timestamped
        self.accountID = accountID
        self.builds = builds
        self.currentBuildID = currentBuildID
        self.repositoryType = repositoryType
        self.repositoryScm = repositoryScm
        self.repositoryName = repositoryName
        self.repositoryBranch = repositoryBranch
        self.isPrivate = isPrivate
        self.isGitHubApp = isGitHubApp
        self.isSkipBranchesWithoutAppveyorYml = isSkipBranchesWithoutAppveyorYml
        self.enableSecureVariablesInPullRequests = enableSecureVariablesInPullRequests
        self.enableSecureVariablesInPullRequestsFromSameRepo = enableSecureVariablesInPullRequestsFromSameRepo
        self.enableDeploymentInPullRequests = enableDeploymentInPullRequests
        self.isSaveBuildCacheInPullRequests = isSaveBuildCacheInPullRequests
        self.isRollingBuilds = isRollingBuilds
        self.isRollingBuildsDoNotCancelRunningBuilds = isRollingBuildsDoNotCancelRunningBuilds
        self.isRollingBuildsOnlyForPullRequests = isRollingBuildsOnlyForPullRequests
        self.isAlwaysBuildClosedPullRequests = isAlwaysBuildClosedPullRequests
        self.tags = tags
        self.nuGetFeed = nuGetFeed
        self.securityDescriptor = securityDescriptor
        self.isDisablePushWebhooks = isDisablePushWebhooks
        self.isDisablePullRequestWebhooks = isDisablePullRequestWebhooks
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.projectLookupModel = try ProjectLookupModel(from: decoder)
        self.timestamped = try Timestamped(from: decoder)
        self.accountID = try values.decodeIfPresent(Int.self, forKey: "accountId")
        self.builds = try values.decodeIfPresent([Build].self, forKey: "builds")
        self.currentBuildID = try values.decodeIfPresent(Int.self, forKey: "currentBuildId")
        self.repositoryType = try RepositoryProvider(from: decoder)
        self.repositoryScm = try RepositoryScm(from: decoder)
        self.repositoryName = try values.decode(String.self, forKey: "repositoryName")
        self.repositoryBranch = try values.decodeIfPresent(String.self, forKey: "repositoryBranch")
        self.isPrivate = try values.decodeIfPresent(Bool.self, forKey: "isPrivate")
        self.isGitHubApp = try values.decodeIfPresent(Bool.self, forKey: "isGitHubApp")
        self.isSkipBranchesWithoutAppveyorYml = try values.decodeIfPresent(Bool.self, forKey: "skipBranchesWithoutAppveyorYml")
        self.enableSecureVariablesInPullRequests = try values.decodeIfPresent(Bool.self, forKey: "enableSecureVariablesInPullRequests")
        self.enableSecureVariablesInPullRequestsFromSameRepo = try values.decodeIfPresent(Bool.self, forKey: "enableSecureVariablesInPullRequestsFromSameRepo")
        self.enableDeploymentInPullRequests = try values.decodeIfPresent(Bool.self, forKey: "enableDeploymentInPullRequests")
        self.isSaveBuildCacheInPullRequests = try values.decodeIfPresent(Bool.self, forKey: "saveBuildCacheInPullRequests")
        self.isRollingBuilds = try values.decodeIfPresent(Bool.self, forKey: "rollingBuilds")
        self.isRollingBuildsDoNotCancelRunningBuilds = try values.decodeIfPresent(Bool.self, forKey: "rollingBuildsDoNotCancelRunningBuilds")
        self.isRollingBuildsOnlyForPullRequests = try values.decodeIfPresent(Bool.self, forKey: "rollingBuildsOnlyForPullRequests")
        self.isAlwaysBuildClosedPullRequests = try values.decodeIfPresent(Bool.self, forKey: "alwaysBuildClosedPullRequests")
        self.tags = try values.decodeIfPresent(String.self, forKey: "tags")
        self.nuGetFeed = try NuGetFeed(from: decoder)
        self.securityDescriptor = try SecurityDescriptor(from: decoder)
        self.isDisablePushWebhooks = try values.decodeIfPresent(Bool.self, forKey: "disablePushWebhooks")
        self.isDisablePullRequestWebhooks = try values.decodeIfPresent(Bool.self, forKey: "disablePullRequestWebhooks")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(projectLookupModel, forKey: "projectLookupModel")
        try values.encode(timestamped, forKey: "timestamped")
        try values.encodeIfPresent(accountID, forKey: "accountId")
        try values.encodeIfPresent(builds, forKey: "builds")
        try values.encodeIfPresent(currentBuildID, forKey: "currentBuildId")
        try values.encodeIfPresent(repositoryType, forKey: "repositoryType")
        try values.encodeIfPresent(repositoryScm, forKey: "repositoryScm")
        try values.encode(repositoryName, forKey: "repositoryName")
        try values.encodeIfPresent(repositoryBranch, forKey: "repositoryBranch")
        try values.encodeIfPresent(isPrivate, forKey: "isPrivate")
        try values.encodeIfPresent(isGitHubApp, forKey: "isGitHubApp")
        try values.encodeIfPresent(isSkipBranchesWithoutAppveyorYml, forKey: "skipBranchesWithoutAppveyorYml")
        try values.encodeIfPresent(enableSecureVariablesInPullRequests, forKey: "enableSecureVariablesInPullRequests")
        try values.encodeIfPresent(enableSecureVariablesInPullRequestsFromSameRepo, forKey: "enableSecureVariablesInPullRequestsFromSameRepo")
        try values.encodeIfPresent(enableDeploymentInPullRequests, forKey: "enableDeploymentInPullRequests")
        try values.encodeIfPresent(isSaveBuildCacheInPullRequests, forKey: "saveBuildCacheInPullRequests")
        try values.encodeIfPresent(isRollingBuilds, forKey: "rollingBuilds")
        try values.encodeIfPresent(isRollingBuildsDoNotCancelRunningBuilds, forKey: "rollingBuildsDoNotCancelRunningBuilds")
        try values.encodeIfPresent(isRollingBuildsOnlyForPullRequests, forKey: "rollingBuildsOnlyForPullRequests")
        try values.encodeIfPresent(isAlwaysBuildClosedPullRequests, forKey: "alwaysBuildClosedPullRequests")
        try values.encodeIfPresent(tags, forKey: "tags")
        try values.encodeIfPresent(nuGetFeed, forKey: "nuGetFeed")
        try values.encodeIfPresent(securityDescriptor, forKey: "securityDescriptor")
        try values.encodeIfPresent(isDisablePushWebhooks, forKey: "disablePushWebhooks")
        try values.encodeIfPresent(isDisablePullRequestWebhooks, forKey: "disablePullRequestWebhooks")
    }
}

/// Example:
///
/// {
///   "nextBuildNumber" : 35
/// }
public struct ProjectBuildNumberUpdate: Codable {
    public var nextBuildNumber: Int

    public init(nextBuildNumber: Int) {
        self.nextBuildNumber = nextBuildNumber
    }
}

public struct ProjectBuildResults: Codable {
    public var project: Project?
    public var build: Build?

    public init(project: Project? = nil, build: Build? = nil) {
        self.project = project
        self.build = build
    }
}

public struct ProjectHistory: Codable {
    public var project: Project?
    public var builds: [Build]?

    public init(project: Project? = nil, builds: [Build]? = nil) {
        self.project = project
        self.builds = builds
    }
}

public enum BuildCloudName: String, Codable, CaseIterable {
    case azureWestus = "azure-westus"
    case gce
    case proUbuntu = "pro-ubuntu"
    case proUbuntu18 = "pro-ubuntu18"
    case proVs2013 = "pro-vs2013"
    case proWin2016 = "pro-win2016"
    case proVs2017 = "pro-vs2017"
    case ubuntu
}

/// Defines the available build worker image templates used to provision a virtual machine for a build.  Images are updated regularly.  "Previous" selects the previous version of an image, for use as a temporary workaround for regressions.
/// `Ubuntu` is the same as `Ubuntu1604`. `Previous Ubuntu` is the same as `Previous Ubuntu1604`.
/// See https://www.appveyor.com/docs/build-environment/#build-worker-images for details.
public enum BuildWorkerImageName: String, Codable, CaseIterable {
    case previousUbuntu = "Previous Ubuntu"
    case previousUbuntu1604 = "Previous Ubuntu1604"
    case previousUbuntu1804 = "Previous Ubuntu1804"
    case previousVisualStudio2013 = "Previous Visual Studio 2013"
    case previousVisualStudio2015 = "Previous Visual Studio 2015"
    case previousVisualStudio2017 = "Previous Visual Studio 2017"
    case ubuntu = "Ubuntu"
    case ubuntu1604 = "Ubuntu1604"
    case ubuntu1804 = "Ubuntu1804"
    case visualStudio2013 = "Visual Studio 2013"
    case visualStudio2015 = "Visual Studio 2015"
    case visualStudio20152 = "Visual Studio 2015 2"
    case visualStudio2017 = "Visual Studio 2017"
    case visualStudio2017Preview = "Visual Studio 2017 Preview"
    case visualStudio2019Preview = "Visual Studio 2019 Preview"
    case wmf5 = "WMF 5"
    case windowsServer2019 = "Windows Server 2019"
}

public struct BuildWorkerImage: Codable {
    public var buildWorkerImageID: Int
    /// Defines the available build worker image templates used to provision a virtual machine for a build.  Images are updated regularly.  "Previous" selects the previous version of an image, for use as a temporary workaround for regressions.
    /// `Ubuntu` is the same as `Ubuntu1604`. `Previous Ubuntu` is the same as `Previous Ubuntu1604`.
    /// See https://www.appveyor.com/docs/build-environment/#build-worker-images for details.
    public var name: BuildWorkerImageName
    public var buildCloudName: BuildCloudName?
    public var osType: OSType?

    public init(buildWorkerImageID: Int, name: BuildWorkerImageName, buildCloudName: BuildCloudName? = nil, osType: OSType? = nil) {
        self.buildWorkerImageID = buildWorkerImageID
        self.name = name
        self.buildCloudName = buildCloudName
        self.osType = osType
    }

    private enum CodingKeys: String, CodingKey {
        case buildWorkerImageID = "buildWorkerImageId"
        case name
        case buildCloudName
        case osType
    }
}

public enum ScriptLanguage: String, Codable, CaseIterable {
    case cmd
    case ps
    case pwsh
    case sh
}

public struct Script: Codable {
    public var language: ScriptLanguage?
    public var script: String

    public init(language: ScriptLanguage? = nil, script: String) {
        self.language = language
        self.script = script
    }
}

/// Possible values from `Push-AppveyorArtifact` cmdlet `-Type` parameter.
/// 
/// The web UI only allows selection of `Auto`, `WebDeployPackage`, and
/// unspecified (which it sends as the empty string but functions like
/// omitting the property) for `updateProject`.
/// 
/// Any string can be sent and will be saved/returned, but only these
/// values have a function (as far as I am aware).
public enum ArtifactType: String, Codable, CaseIterable {
    case auto = "Auto"
    case azureCloudService = "AzureCloudService"
    case azureCloudServiceConfig = "AzureCloudServiceConfig"
    case elasticBeanstalkPackage = "ElasticBeanstalkPackage"
    case file = "File"
    case nuGetPackage = "NuGetPackage"
    case octopusPackage = "OctopusPackage"
    case ssdtPackage = "SsdtPackage"
    case webDeployPackage = "WebDeployPackage"
    case zip = "Zip"
}

public struct Artifact: Codable {
    /// Path glob of artifact files.
    /// Note that updateProject does not require path, but omitting path
    /// results in post-build error "Collecting artifacts... Value cannot
    /// be null.  Parameter name: input"
    public var path: String
    /// Deployment name
    public var name: String?
    /// Possible values from `Push-AppveyorArtifact` cmdlet `-Type` parameter.
    /// 
    /// The web UI only allows selection of `Auto`, `WebDeployPackage`, and
    /// unspecified (which it sends as the empty string but functions like
    /// omitting the property) for `updateProject`.
    /// 
    /// Any string can be sent and will be saved/returned, but only these
    /// values have a function (as far as I am aware).
    public var type: ArtifactType?

    public init(path: String, name: String? = nil, type: ArtifactType? = nil) {
        self.path = path
        self.name = name
        self.type = type
    }
}

public struct ArtifactModel: Codable {
    public var fileName: String?
    /// Deployment name
    public var name: String?
    /// Possible values from `Push-AppveyorArtifact` cmdlet `-Type` parameter.
    /// 
    /// The web UI only allows selection of `Auto`, `WebDeployPackage`, and
    /// unspecified (which it sends as the empty string but functions like
    /// omitting the property) for `updateProject`.
    /// 
    /// Any string can be sent and will be saved/returned, but only these
    /// values have a function (as far as I am aware).
    public var type: ArtifactType?
    public var size: Int?
    public var created: Date?
    /// This property has not been observed in JSON responses, but is
    /// present and nil in XML responses.
    public var url: String?

    public init(fileName: String? = nil, name: String? = nil, type: ArtifactType? = nil, size: Int? = nil, created: Date? = nil, url: String? = nil) {
        self.fileName = fileName
        self.name = name
        self.type = type
        self.size = size
        self.created = created
        self.url = url
    }
}

public enum BuildMode: String, Codable, CaseIterable {
    case msbuild
    case `none`
    case script
}

public enum DeployMode: String, Codable, CaseIterable {
    case providers
    case `none`
    case script
}

public enum MSBuildVerbosity: String, Codable, CaseIterable {
    case quiet
    case minimal
    case normal
    case detailed
}

public enum OSServiceName: String, Codable, CaseIterable {
    case iis
    case mongodb
    case msmq
    case mssql2008r2sp2
    case mssql2008r2sp2rs
    case mssql2012sp1
    case mssql2012sp1rs
    case mssql2014
    case mssql2014rs
    case mssql2016
    case mysql
    case postgresql
}

public enum PlatformName: String, Codable, CaseIterable {
    case arm = "ARM"
    case anyCPU = "Any CPU"
    case x64
    case x86
}

public enum TestMode: String, Codable, CaseIterable {
    case auto
    case `none`
    case script
}

public struct StoredValue: Codable {
    public var isEncrypted: Bool?
    /// Encrypted values can be created using the encryptValue operation.
    /// 
    /// Empty environment variables are represented by missing (null) value
    /// rather than an empty string.
    public var value: String?

    public init(isEncrypted: Bool? = nil, value: String? = nil) {
        self.isEncrypted = isEncrypted
        self.value = value
    }
}

public struct StoredNameValue: Codable {
    public var name: String
    public var value: StoredValue

    public init(name: String, value: StoredValue) {
        self.name = name
        self.value = value
    }
}

public struct StoredNameValueMatrix: Codable {
    public var variables: StoredNameValue?

    public init(variables: StoredNameValue? = nil) {
        self.variables = variables
    }
}

public struct HostEntry: Codable {
    public var host: String
    public var ip: String

    public init(host: String, ip: String) {
        self.host = host
        self.ip = ip
    }
}

/// Example:
///
/// {
///   "plainValue" : "encryptme"
/// }
public struct EncryptRequest: Codable {
    public var plainValue: String?

    public init(plainValue: String? = nil) {
        self.plainValue = plainValue
    }
}

public enum ProjectBranchesMode: String, Codable, CaseIterable {
    case exclude
    case include
}

public struct ProjectConfiguration: Codable {
    public var isDoNotIncrementBuildNumberOnPullRequests: Bool?
    public var hotFixScripts: [Script]?
    public var initScripts: [Script]?
    public var branchesMode: ProjectBranchesMode?
    public var includeBranches: [StringValueObject]?
    public var excludeBranches: [StringValueObject]?
    public var isSkipTags: Bool?
    public var isSkipNonTags: Bool?
    public var isSkipBranchWithPullRequests: Bool?
    public var skipCommitsFiles: [StringValueObject]?
    public var onlyCommitsFiles: [StringValueObject]?
    public var cloneScripts: [Script]?
    public var onBuildSuccessScripts: [Script]?
    public var onBuildErrorScripts: [Script]?
    public var onBuildFinishScripts: [Script]?
    public var isPatchAssemblyInfo: Bool?
    public var assemblyInfoFile: String?
    public var assemblyVersionFormat: String?
    public var assemblyFileVersionFormat: String?
    public var assemblyInformationalVersionFormat: String?
    public var isPatchDotnetCsproj: Bool?
    public var dotnetCsprojFile: String?
    public var dotnetCsprojVersionFormat: String?
    public var dotnetCsprojAssemblyVersionFormat: String?
    public var dotnetCsprojFileVersionFormat: String?
    public var dotnetCsprojInformationalVersionFormat: String?
    public var dotnetCsprojPackageVersionFormat: String?
    public var maxJobs: Int?
    public var buildCloud: [StringValueObject]?
    /// Build worker image
    public var operatingSystem: [OperatingSystemItem]?
    /// OS services to start during the build process
    public var services: [Service]?
    public var stacks: [UnknownType]?
    public var cloneFolder: String?
    public var isShallowClone: Bool?
    public var isForceHTTPSClone: Bool?
    public var cloneDepth: Int?
    public var environmentVariables: [StoredNameValue]?
    public var environmentVariablesMatrix: [StoredNameValueMatrix]?
    public var installScripts: [Script]?
    public var hostsEntries: [HostEntry]?
    public var cacheEntries: [StringValueObject]?
    public var isConfigureNuGetProjectSource: Bool?
    public var isConfigureNuGetAccountSource: Bool?
    public var isDisableNuGetPublishOnPullRequests: Bool?
    public var isDisableNuGetPublishForOctopusPackages: Bool?
    public var buildMode: BuildMode?
    public var platform: [PlatformItem]?
    public var configuration: [StringValueObject]?
    public var msBuildProjectFileName: String?
    public var isPackageWebApplicationProjects: Bool?
    public var isPackageWebApplicationProjectsXCopy: Bool?
    public var isPackageWebApplicationProjectsBeanstalk: Bool?
    public var isPackageWebApplicationProjectsOctopus: Bool?
    public var isPackageAzureCloudServiceProjects: Bool?
    public var isPackageNuGetProjects: Bool?
    public var isPackageNuGetSymbols: Bool?
    public var isPackageAspNetCoreProjects: Bool?
    public var isPackageDotnetConsoleProjects: Bool?
    public var isIncludeNuGetReferences: Bool?
    public var isMsBuildInParallel: Bool?
    public var msBuildVerbosity: MSBuildVerbosity?
    /// Only set/used when `buildMode` is `script`.
    public var buildScripts: [Script]?
    public var beforeBuildScripts: [Script]?
    public var beforePackageScripts: [Script]?
    public var afterBuildScripts: [Script]?
    public var testMode: TestMode?
    public var testAssemblies: [StringValueObject]?
    public var testCategoriesMode: TestCategoriesMode?
    public var testCategories: [StringValueObject]?
    public var testCategoriesMatrix: [TestCategoriesMatrixItem]?
    /// Only set/used when `testMode` is `script`.
    public var testScripts: [Script]?
    public var beforeTestScripts: [Script]?
    public var afterTestScripts: [Script]?
    public var deployMode: DeployMode?
    public var deployments: [DeploymentProvider]?
    public var deployScripts: [Script]?
    public var beforeDeployScripts: [Script]?
    public var afterDeployScripts: [Script]?
    public var isXamarinRegisterAndroidProduct: Bool?
    public var isXamarinRegisterIosProduct: Bool?
    public var isMatrixFastFinish: Bool?
    /// Although the names and values are not enforced, the combinations which are meaningful are documented at https://www.appveyor.com/docs/build-configuration/#allow-failing-jobs
    public var matrixAllowFailures: [StoredNameValueMatrix]?
    public var matrixExclude: [StoredNameValueMatrix]?
    public var matrixOnly: [StoredNameValueMatrix]?
    public var matrixExcept: [StoredNameValueMatrix]?
    public var artifacts: [Artifact]?
    public var notifications: [NotificationProviderSettings]?

    public struct OperatingSystemItem: Codable {
        /// Defines the available build worker image templates used to provision a virtual machine for a build.  Images are updated regularly.  "Previous" selects the previous version of an image, for use as a temporary workaround for regressions.
        /// `Ubuntu` is the same as `Ubuntu1604`. `Previous Ubuntu` is the same as `Previous Ubuntu1604`.
        /// See https://www.appveyor.com/docs/build-environment/#build-worker-images for details.
        public var value: BuildWorkerImageName

        public init(value: BuildWorkerImageName) {
            self.value = value
        }
    }

    public struct Service: Codable {
        public var value: OSServiceName

        public init(value: OSServiceName) {
            self.value = value
        }
    }

    public struct PlatformItem: Codable {
        public var value: PlatformName

        public init(value: PlatformName) {
            self.value = value
        }
    }

    public enum TestCategoriesMode: String, Codable, CaseIterable {
        case exclude
        case include
    }

    public struct TestCategoriesMatrixItem: Codable {
        public var categories: [StringValueObject]?

        public init(categories: [StringValueObject]? = nil) {
            self.categories = categories
        }
    }

    public init(isDoNotIncrementBuildNumberOnPullRequests: Bool? = nil, hotFixScripts: [Script]? = nil, initScripts: [Script]? = nil, branchesMode: ProjectBranchesMode? = nil, includeBranches: [StringValueObject]? = nil, excludeBranches: [StringValueObject]? = nil, isSkipTags: Bool? = nil, isSkipNonTags: Bool? = nil, isSkipBranchWithPullRequests: Bool? = nil, skipCommitsFiles: [StringValueObject]? = nil, onlyCommitsFiles: [StringValueObject]? = nil, cloneScripts: [Script]? = nil, onBuildSuccessScripts: [Script]? = nil, onBuildErrorScripts: [Script]? = nil, onBuildFinishScripts: [Script]? = nil, isPatchAssemblyInfo: Bool? = nil, assemblyInfoFile: String? = nil, assemblyVersionFormat: String? = nil, assemblyFileVersionFormat: String? = nil, assemblyInformationalVersionFormat: String? = nil, isPatchDotnetCsproj: Bool? = nil, dotnetCsprojFile: String? = nil, dotnetCsprojVersionFormat: String? = nil, dotnetCsprojAssemblyVersionFormat: String? = nil, dotnetCsprojFileVersionFormat: String? = nil, dotnetCsprojInformationalVersionFormat: String? = nil, dotnetCsprojPackageVersionFormat: String? = nil, maxJobs: Int? = nil, buildCloud: [StringValueObject]? = nil, operatingSystem: [OperatingSystemItem]? = nil, services: [Service]? = nil, stacks: [UnknownType]? = nil, cloneFolder: String? = nil, isShallowClone: Bool? = nil, isForceHTTPSClone: Bool? = nil, cloneDepth: Int? = nil, environmentVariables: [StoredNameValue]? = nil, environmentVariablesMatrix: [StoredNameValueMatrix]? = nil, installScripts: [Script]? = nil, hostsEntries: [HostEntry]? = nil, cacheEntries: [StringValueObject]? = nil, isConfigureNuGetProjectSource: Bool? = nil, isConfigureNuGetAccountSource: Bool? = nil, isDisableNuGetPublishOnPullRequests: Bool? = nil, isDisableNuGetPublishForOctopusPackages: Bool? = nil, buildMode: BuildMode? = nil, platform: [PlatformItem]? = nil, configuration: [StringValueObject]? = nil, msBuildProjectFileName: String? = nil, isPackageWebApplicationProjects: Bool? = nil, isPackageWebApplicationProjectsXCopy: Bool? = nil, isPackageWebApplicationProjectsBeanstalk: Bool? = nil, isPackageWebApplicationProjectsOctopus: Bool? = nil, isPackageAzureCloudServiceProjects: Bool? = nil, isPackageNuGetProjects: Bool? = nil, isPackageNuGetSymbols: Bool? = nil, isPackageAspNetCoreProjects: Bool? = nil, isPackageDotnetConsoleProjects: Bool? = nil, isIncludeNuGetReferences: Bool? = nil, isMsBuildInParallel: Bool? = nil, msBuildVerbosity: MSBuildVerbosity? = nil, buildScripts: [Script]? = nil, beforeBuildScripts: [Script]? = nil, beforePackageScripts: [Script]? = nil, afterBuildScripts: [Script]? = nil, testMode: TestMode? = nil, testAssemblies: [StringValueObject]? = nil, testCategoriesMode: TestCategoriesMode? = nil, testCategories: [StringValueObject]? = nil, testCategoriesMatrix: [TestCategoriesMatrixItem]? = nil, testScripts: [Script]? = nil, beforeTestScripts: [Script]? = nil, afterTestScripts: [Script]? = nil, deployMode: DeployMode? = nil, deployments: [DeploymentProvider]? = nil, deployScripts: [Script]? = nil, beforeDeployScripts: [Script]? = nil, afterDeployScripts: [Script]? = nil, isXamarinRegisterAndroidProduct: Bool? = nil, isXamarinRegisterIosProduct: Bool? = nil, isMatrixFastFinish: Bool? = nil, matrixAllowFailures: [StoredNameValueMatrix]? = nil, matrixExclude: [StoredNameValueMatrix]? = nil, matrixOnly: [StoredNameValueMatrix]? = nil, matrixExcept: [StoredNameValueMatrix]? = nil, artifacts: [Artifact]? = nil, notifications: [NotificationProviderSettings]? = nil) {
        self.isDoNotIncrementBuildNumberOnPullRequests = isDoNotIncrementBuildNumberOnPullRequests
        self.hotFixScripts = hotFixScripts
        self.initScripts = initScripts
        self.branchesMode = branchesMode
        self.includeBranches = includeBranches
        self.excludeBranches = excludeBranches
        self.isSkipTags = isSkipTags
        self.isSkipNonTags = isSkipNonTags
        self.isSkipBranchWithPullRequests = isSkipBranchWithPullRequests
        self.skipCommitsFiles = skipCommitsFiles
        self.onlyCommitsFiles = onlyCommitsFiles
        self.cloneScripts = cloneScripts
        self.onBuildSuccessScripts = onBuildSuccessScripts
        self.onBuildErrorScripts = onBuildErrorScripts
        self.onBuildFinishScripts = onBuildFinishScripts
        self.isPatchAssemblyInfo = isPatchAssemblyInfo
        self.assemblyInfoFile = assemblyInfoFile
        self.assemblyVersionFormat = assemblyVersionFormat
        self.assemblyFileVersionFormat = assemblyFileVersionFormat
        self.assemblyInformationalVersionFormat = assemblyInformationalVersionFormat
        self.isPatchDotnetCsproj = isPatchDotnetCsproj
        self.dotnetCsprojFile = dotnetCsprojFile
        self.dotnetCsprojVersionFormat = dotnetCsprojVersionFormat
        self.dotnetCsprojAssemblyVersionFormat = dotnetCsprojAssemblyVersionFormat
        self.dotnetCsprojFileVersionFormat = dotnetCsprojFileVersionFormat
        self.dotnetCsprojInformationalVersionFormat = dotnetCsprojInformationalVersionFormat
        self.dotnetCsprojPackageVersionFormat = dotnetCsprojPackageVersionFormat
        self.maxJobs = maxJobs
        self.buildCloud = buildCloud
        self.operatingSystem = operatingSystem
        self.services = services
        self.stacks = stacks
        self.cloneFolder = cloneFolder
        self.isShallowClone = isShallowClone
        self.isForceHTTPSClone = isForceHTTPSClone
        self.cloneDepth = cloneDepth
        self.environmentVariables = environmentVariables
        self.environmentVariablesMatrix = environmentVariablesMatrix
        self.installScripts = installScripts
        self.hostsEntries = hostsEntries
        self.cacheEntries = cacheEntries
        self.isConfigureNuGetProjectSource = isConfigureNuGetProjectSource
        self.isConfigureNuGetAccountSource = isConfigureNuGetAccountSource
        self.isDisableNuGetPublishOnPullRequests = isDisableNuGetPublishOnPullRequests
        self.isDisableNuGetPublishForOctopusPackages = isDisableNuGetPublishForOctopusPackages
        self.buildMode = buildMode
        self.platform = platform
        self.configuration = configuration
        self.msBuildProjectFileName = msBuildProjectFileName
        self.isPackageWebApplicationProjects = isPackageWebApplicationProjects
        self.isPackageWebApplicationProjectsXCopy = isPackageWebApplicationProjectsXCopy
        self.isPackageWebApplicationProjectsBeanstalk = isPackageWebApplicationProjectsBeanstalk
        self.isPackageWebApplicationProjectsOctopus = isPackageWebApplicationProjectsOctopus
        self.isPackageAzureCloudServiceProjects = isPackageAzureCloudServiceProjects
        self.isPackageNuGetProjects = isPackageNuGetProjects
        self.isPackageNuGetSymbols = isPackageNuGetSymbols
        self.isPackageAspNetCoreProjects = isPackageAspNetCoreProjects
        self.isPackageDotnetConsoleProjects = isPackageDotnetConsoleProjects
        self.isIncludeNuGetReferences = isIncludeNuGetReferences
        self.isMsBuildInParallel = isMsBuildInParallel
        self.msBuildVerbosity = msBuildVerbosity
        self.buildScripts = buildScripts
        self.beforeBuildScripts = beforeBuildScripts
        self.beforePackageScripts = beforePackageScripts
        self.afterBuildScripts = afterBuildScripts
        self.testMode = testMode
        self.testAssemblies = testAssemblies
        self.testCategoriesMode = testCategoriesMode
        self.testCategories = testCategories
        self.testCategoriesMatrix = testCategoriesMatrix
        self.testScripts = testScripts
        self.beforeTestScripts = beforeTestScripts
        self.afterTestScripts = afterTestScripts
        self.deployMode = deployMode
        self.deployments = deployments
        self.deployScripts = deployScripts
        self.beforeDeployScripts = beforeDeployScripts
        self.afterDeployScripts = afterDeployScripts
        self.isXamarinRegisterAndroidProduct = isXamarinRegisterAndroidProduct
        self.isXamarinRegisterIosProduct = isXamarinRegisterIosProduct
        self.isMatrixFastFinish = isMatrixFastFinish
        self.matrixAllowFailures = matrixAllowFailures
        self.matrixExclude = matrixExclude
        self.matrixOnly = matrixOnly
        self.matrixExcept = matrixExcept
        self.artifacts = artifacts
        self.notifications = notifications
    }

    private enum CodingKeys: String, CodingKey {
        case isDoNotIncrementBuildNumberOnPullRequests = "doNotIncrementBuildNumberOnPullRequests"
        case hotFixScripts
        case initScripts
        case branchesMode
        case includeBranches
        case excludeBranches
        case isSkipTags = "skipTags"
        case isSkipNonTags = "skipNonTags"
        case isSkipBranchWithPullRequests = "skipBranchWithPullRequests"
        case skipCommitsFiles
        case onlyCommitsFiles
        case cloneScripts
        case onBuildSuccessScripts
        case onBuildErrorScripts
        case onBuildFinishScripts
        case isPatchAssemblyInfo = "patchAssemblyInfo"
        case assemblyInfoFile
        case assemblyVersionFormat
        case assemblyFileVersionFormat
        case assemblyInformationalVersionFormat
        case isPatchDotnetCsproj = "patchDotnetCsproj"
        case dotnetCsprojFile
        case dotnetCsprojVersionFormat
        case dotnetCsprojAssemblyVersionFormat
        case dotnetCsprojFileVersionFormat
        case dotnetCsprojInformationalVersionFormat
        case dotnetCsprojPackageVersionFormat
        case maxJobs
        case buildCloud
        case operatingSystem
        case services
        case stacks
        case cloneFolder
        case isShallowClone = "shallowClone"
        case isForceHTTPSClone = "forceHttpsClone"
        case cloneDepth
        case environmentVariables
        case environmentVariablesMatrix
        case installScripts
        case hostsEntries
        case cacheEntries
        case isConfigureNuGetProjectSource = "configureNuGetProjectSource"
        case isConfigureNuGetAccountSource = "configureNuGetAccountSource"
        case isDisableNuGetPublishOnPullRequests = "disableNuGetPublishOnPullRequests"
        case isDisableNuGetPublishForOctopusPackages = "disableNuGetPublishForOctopusPackages"
        case buildMode
        case platform
        case configuration
        case msBuildProjectFileName
        case isPackageWebApplicationProjects = "packageWebApplicationProjects"
        case isPackageWebApplicationProjectsXCopy = "packageWebApplicationProjectsXCopy"
        case isPackageWebApplicationProjectsBeanstalk = "packageWebApplicationProjectsBeanstalk"
        case isPackageWebApplicationProjectsOctopus = "packageWebApplicationProjectsOctopus"
        case isPackageAzureCloudServiceProjects = "packageAzureCloudServiceProjects"
        case isPackageNuGetProjects = "packageNuGetProjects"
        case isPackageNuGetSymbols = "packageNuGetSymbols"
        case isPackageAspNetCoreProjects = "packageAspNetCoreProjects"
        case isPackageDotnetConsoleProjects = "packageDotnetConsoleProjects"
        case isIncludeNuGetReferences = "includeNuGetReferences"
        case isMsBuildInParallel = "msBuildInParallel"
        case msBuildVerbosity
        case buildScripts
        case beforeBuildScripts
        case beforePackageScripts
        case afterBuildScripts
        case testMode
        case testAssemblies
        case testCategoriesMode
        case testCategories
        case testCategoriesMatrix
        case testScripts
        case beforeTestScripts
        case afterTestScripts
        case deployMode
        case deployments
        case deployScripts
        case beforeDeployScripts
        case afterDeployScripts
        case isXamarinRegisterAndroidProduct = "xamarinRegisterAndroidProduct"
        case isXamarinRegisterIosProduct = "xamarinRegisterIosProduct"
        case isMatrixFastFinish = "matrixFastFinish"
        case matrixAllowFailures
        case matrixExclude
        case matrixOnly
        case matrixExcept
        case artifacts
        case notifications
    }
}

public struct ProjectWithConfiguration: Codable {
    public var project: Project
    public var versionFormat: String
    public var nextBuildNumber: Int?
    /// Build schedule as an NCrontab Expression.  See https://github.com/atifaziz/NCrontab/wiki/Crontab-Expression
    public var scheduleCrontabExpression: String?
    public var repositoryAuthentication: RepositoryAuthenticationType?
    public var repositoryUsername: String?
    public var sshPublicKey: String?
    public var webhookID: String?
    public var webhookURL: URL?
    public var statusBadgeID: String?
    public var buildPriority: Int?
    public var isIgnoreAppveyorYml: Bool?
    public var customYmlName: String?
    public var configuration: ProjectConfiguration

    public init(project: Project, versionFormat: String, nextBuildNumber: Int? = nil, scheduleCrontabExpression: String? = nil, repositoryAuthentication: RepositoryAuthenticationType? = nil, repositoryUsername: String? = nil, sshPublicKey: String? = nil, webhookID: String? = nil, webhookURL: URL? = nil, statusBadgeID: String? = nil, buildPriority: Int? = nil, isIgnoreAppveyorYml: Bool? = nil, customYmlName: String? = nil, configuration: ProjectConfiguration) {
        self.project = project
        self.versionFormat = versionFormat
        self.nextBuildNumber = nextBuildNumber
        self.scheduleCrontabExpression = scheduleCrontabExpression
        self.repositoryAuthentication = repositoryAuthentication
        self.repositoryUsername = repositoryUsername
        self.sshPublicKey = sshPublicKey
        self.webhookID = webhookID
        self.webhookURL = webhookURL
        self.statusBadgeID = statusBadgeID
        self.buildPriority = buildPriority
        self.isIgnoreAppveyorYml = isIgnoreAppveyorYml
        self.customYmlName = customYmlName
        self.configuration = configuration
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.project = try Project(from: decoder)
        self.versionFormat = try values.decode(String.self, forKey: "versionFormat")
        self.nextBuildNumber = try values.decodeIfPresent(Int.self, forKey: "nextBuildNumber")
        self.scheduleCrontabExpression = try values.decodeIfPresent(String.self, forKey: "scheduleCrontabExpression")
        self.repositoryAuthentication = try RepositoryAuthenticationType(from: decoder)
        self.repositoryUsername = try values.decodeIfPresent(String.self, forKey: "repositoryUsername")
        self.sshPublicKey = try values.decodeIfPresent(String.self, forKey: "sshPublicKey")
        self.webhookID = try values.decodeIfPresent(String.self, forKey: "webhookId")
        self.webhookURL = try values.decodeIfPresent(URL.self, forKey: "webhookUrl")
        self.statusBadgeID = try values.decodeIfPresent(String.self, forKey: "statusBadgeId")
        self.buildPriority = try values.decodeIfPresent(Int.self, forKey: "buildPriority")
        self.isIgnoreAppveyorYml = try values.decodeIfPresent(Bool.self, forKey: "ignoreAppveyorYml")
        self.customYmlName = try values.decodeIfPresent(String.self, forKey: "customYmlName")
        self.configuration = try ProjectConfiguration(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(project, forKey: "project")
        try values.encode(versionFormat, forKey: "versionFormat")
        try values.encodeIfPresent(nextBuildNumber, forKey: "nextBuildNumber")
        try values.encodeIfPresent(scheduleCrontabExpression, forKey: "scheduleCrontabExpression")
        try values.encodeIfPresent(repositoryAuthentication, forKey: "repositoryAuthentication")
        try values.encodeIfPresent(repositoryUsername, forKey: "repositoryUsername")
        try values.encodeIfPresent(sshPublicKey, forKey: "sshPublicKey")
        try values.encodeIfPresent(webhookID, forKey: "webhookId")
        try values.encodeIfPresent(webhookURL, forKey: "webhookUrl")
        try values.encodeIfPresent(statusBadgeID, forKey: "statusBadgeId")
        try values.encodeIfPresent(buildPriority, forKey: "buildPriority")
        try values.encodeIfPresent(isIgnoreAppveyorYml, forKey: "ignoreAppveyorYml")
        try values.encodeIfPresent(customYmlName, forKey: "customYmlName")
        try values.encode(configuration, forKey: "configuration")
    }
}

/// Example:
///
/// {
///   "build" : {
///     "project" : "MySolution.sln",
///     "publish_wap" : true,
///     "verbosity" : "minimal"
///   },
///   "version" : "1.0.{build}"
/// }
public struct ProjectSettingsResults: Codable {
    public var project: Project?
    public var settings: ProjectWithConfiguration?
    public var images: [BuildWorkerImage]?
    public var buildClouds: [StringValueObject]?
    public var defaultImageName: String?

    public init(project: Project? = nil, settings: ProjectWithConfiguration? = nil, images: [BuildWorkerImage]? = nil, buildClouds: [StringValueObject]? = nil, defaultImageName: String? = nil) {
        self.project = project
        self.settings = settings
        self.images = images
        self.buildClouds = buildClouds
        self.defaultImageName = defaultImageName
    }
}

public enum HTTPMethodRestricted: String, Codable, CaseIterable {
    case get = "GET"
    case post = "POST"
}

public enum DeploymentProviderType: String, Codable, CaseIterable {
    case agent = "Agent"
    case azureBlob = "AzureBlob"
    case azureCS = "AzureCS"
    case azureWebJob = "AzureWebJob"
    case binTray = "BinTray"
    case ftp = "FTP"
    case gitHub = "GitHub"
    case nuGet = "NuGet"
    case s3 = "S3"
    case sqlDatabase = "SqlDatabase"
    case webDeploy = "WebDeploy"
    case webhook = "Webhook"
}

public struct DeploymentProvider: Codable {
    public var provider: DeploymentProviderType
    public var providerSettings: [StoredNameValue]?
    public var onBranch: [StringValueObject]?
    public var onEnvironmentVariables: [StoredNameValue]?

    public init(provider: DeploymentProviderType, providerSettings: [StoredNameValue]? = nil, onBranch: [StringValueObject]? = nil, onEnvironmentVariables: [StoredNameValue]? = nil) {
        self.provider = provider
        self.providerSettings = providerSettings
        self.onBranch = onBranch
        self.onEnvironmentVariables = onEnvironmentVariables
    }
}

public struct DeploymentEnvironmentSettings: Codable {
    public var providerSettings: [StoredNameValue]?
    public var environmentVariables: [StoredNameValue]?
    public var notifications: [NotificationProviderSettings]?

    public init(providerSettings: [StoredNameValue]? = nil, environmentVariables: [StoredNameValue]? = nil, notifications: [NotificationProviderSettings]? = nil) {
        self.providerSettings = providerSettings
        self.environmentVariables = environmentVariables
        self.notifications = notifications
    }
}

/// Example:
///
/// {
///   "name" : "production",
///   "provider" : "FTP",
///   "settings" : {
///     "environmentVariables" : [
///       {
///         "name" : "my-var",
///         "value" : {
///           "isEncrypted" : false,
///           "value" : "123"
///         }
///       }
///     ],
///     "providerSettings" : [
///       {
///         "name" : "server",
///         "value" : {
///           "isEncrypted" : false,
///           "value" : "ftp.myserver.com"
///         }
///       },
///       {
///         "name" : "username",
///         "value" : {
///           "isEncrypted" : false,
///           "value" : "ftp-user"
///         }
///       },
///       {
///         "name" : "password",
///         "value" : {
///           "isEncrypted" : true,
///           "value" : "password"
///         }
///       }
///     ]
///   }
/// }
public struct DeploymentEnvironmentAddition: Codable {
    public var name: String
    public var provider: DeploymentProviderType
    public var settings: DeploymentEnvironmentSettings

    public init(name: String, provider: DeploymentProviderType, settings: DeploymentEnvironmentSettings) {
        self.name = name
        self.provider = provider
        self.settings = settings
    }
}

public struct DeploymentEnvironmentLookupModel: Codable {
    public var deploymentEnvironmentID: Int?
    public var name: String?
    public var provider: DeploymentProviderType?

    public init(deploymentEnvironmentID: Int? = nil, name: String? = nil, provider: DeploymentProviderType? = nil) {
        self.deploymentEnvironmentID = deploymentEnvironmentID
        self.name = name
        self.provider = provider
    }

    private enum CodingKeys: String, CodingKey {
        case deploymentEnvironmentID = "deploymentEnvironmentId"
        case name
        case provider
    }
}

public struct DeploymentEnvironment: Codable {
    public var deploymentEnvironmentLookupModel: DeploymentEnvironmentLookupModel
    public var timestamped: Timestamped
    public var accountID: Int?
    /// 0 is "Any project can be deployed to the environment"
    /// 1 is "Only selected projects can be deployed to the environment"
    /// 2 is "All except selected projects can be deployed to the environment"
    public var projectsMode: Int?
    public var securityDescriptor: SecurityDescriptor?
    /// Comma-separated list of environment tags for dynamic grouping.
    /// Appears that any input is accepted.  The returned value only
    /// contains case-preserving but insensitive unique values where
    /// spaces around "," are removed but otherwise preserved.  Empty
    /// values and items are allowed.
    public var tags: String?

    public init(deploymentEnvironmentLookupModel: DeploymentEnvironmentLookupModel, timestamped: Timestamped, accountID: Int? = nil, projectsMode: Int? = nil, securityDescriptor: SecurityDescriptor? = nil, tags: String? = nil) {
        self.deploymentEnvironmentLookupModel = deploymentEnvironmentLookupModel
        self.timestamped = timestamped
        self.accountID = accountID
        self.projectsMode = projectsMode
        self.securityDescriptor = securityDescriptor
        self.tags = tags
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.deploymentEnvironmentLookupModel = try DeploymentEnvironmentLookupModel(from: decoder)
        self.timestamped = try Timestamped(from: decoder)
        self.accountID = try values.decodeIfPresent(Int.self, forKey: "accountId")
        self.projectsMode = try values.decodeIfPresent(Int.self, forKey: "projectsMode")
        self.securityDescriptor = try SecurityDescriptor(from: decoder)
        self.tags = try values.decodeIfPresent(String.self, forKey: "tags")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(deploymentEnvironmentLookupModel, forKey: "deploymentEnvironmentLookupModel")
        try values.encode(timestamped, forKey: "timestamped")
        try values.encodeIfPresent(accountID, forKey: "accountId")
        try values.encodeIfPresent(projectsMode, forKey: "projectsMode")
        try values.encodeIfPresent(securityDescriptor, forKey: "securityDescriptor")
        try values.encodeIfPresent(tags, forKey: "tags")
    }
}

public struct DeploymentEnvironmentProject: Codable {
    public var projectID: Int
    public var name: String
    public var isSelected: Bool

    public init(projectID: Int, name: String, isSelected: Bool) {
        self.projectID = projectID
        self.name = name
        self.isSelected = isSelected
    }

    private enum CodingKeys: String, CodingKey {
        case projectID = "projectId"
        case name
        case isSelected
    }
}

public struct DeploymentEnvironmentWithSettings: Codable {
    public var deploymentEnvironment: DeploymentEnvironment
    public var environmentAccessKey: String?
    public var settings: DeploymentEnvironmentSettings?
    /// Project IDs of selected projects
    public var selectedProjects: [Int]?
    /// Projects available for selection in UI.
    /// Only present in response from getEnvironmentSettings.
    public var projects: [DeploymentEnvironmentProject]?

    public init(deploymentEnvironment: DeploymentEnvironment, environmentAccessKey: String? = nil, settings: DeploymentEnvironmentSettings? = nil, selectedProjects: [Int]? = nil, projects: [DeploymentEnvironmentProject]? = nil) {
        self.deploymentEnvironment = deploymentEnvironment
        self.environmentAccessKey = environmentAccessKey
        self.settings = settings
        self.selectedProjects = selectedProjects
        self.projects = projects
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.deploymentEnvironment = try DeploymentEnvironment(from: decoder)
        self.environmentAccessKey = try values.decodeIfPresent(String.self, forKey: "environmentAccessKey")
        self.settings = try DeploymentEnvironmentSettings(from: decoder)
        self.selectedProjects = try values.decodeIfPresent([Int].self, forKey: "selectedProjects")
        self.projects = try values.decodeIfPresent([DeploymentEnvironmentProject].self, forKey: "projects")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(deploymentEnvironment, forKey: "deploymentEnvironment")
        try values.encodeIfPresent(environmentAccessKey, forKey: "environmentAccessKey")
        try values.encodeIfPresent(settings, forKey: "settings")
        try values.encodeIfPresent(selectedProjects, forKey: "selectedProjects")
        try values.encodeIfPresent(projects, forKey: "projects")
    }
}

public struct DeploymentEnvironmentSettingsResults: Codable {
    public var environment: DeploymentEnvironmentWithSettings?

    public init(environment: DeploymentEnvironmentWithSettings? = nil) {
        self.environment = environment
    }
}

/// Example:
///
/// {
///   "accountName" : "your-account-name",
///   "buildJobId" : "sfke9239ydzf",
///   "buildVersion" : "1.2.0",
///   "environmentName" : "environment-to-deploy",
///   "environmentVariables" : {
///     "another_var" : "another value",
///     "server" : "myserver.com"
///   },
///   "projectSlug" : "project-slug-from-url"
/// }
public struct DeploymentStartRequest: Codable {
    public var environmentName: String
    public var accountName: String
    public var projectSlug: String
    /// Build to deploy
    public var buildVersion: String
    /// Optional job id with artifacts if build contains multiple jobs.
    public var buildJobID: String?
    public var environmentVariables: [String: String]?

    public init(environmentName: String, accountName: String, projectSlug: String, buildVersion: String, buildJobID: String? = nil, environmentVariables: [String: String]? = nil) {
        self.environmentName = environmentName
        self.accountName = accountName
        self.projectSlug = projectSlug
        self.buildVersion = buildVersion
        self.buildJobID = buildJobID
        self.environmentVariables = environmentVariables
    }

    private enum CodingKeys: String, CodingKey {
        case environmentName
        case accountName
        case projectSlug
        case buildVersion
        case buildJobID = "buildJobId"
        case environmentVariables
    }
}

public struct DeploymentJob: Codable {
    public var job: Job
    public var messagesCount: Int?

    public init(job: Job, messagesCount: Int? = nil) {
        self.job = job
        self.messagesCount = messagesCount
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.job = try Job(from: decoder)
        self.messagesCount = try values.decodeIfPresent(Int.self, forKey: "messagesCount")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(job, forKey: "job")
        try values.encodeIfPresent(messagesCount, forKey: "messagesCount")
    }
}

public struct DeploymentLookupModel: Codable {
    public var deploymentID: Int?
    public var build: BuildLookupModel?
    public var status: Status?
    public var started: Date?
    public var finished: Date?

    public init(deploymentID: Int? = nil, build: BuildLookupModel? = nil, status: Status? = nil, started: Date? = nil, finished: Date? = nil) {
        self.deploymentID = deploymentID
        self.build = build
        self.status = status
        self.started = started
        self.finished = finished
    }

    private enum CodingKeys: String, CodingKey {
        case deploymentID = "deploymentId"
        case build
        case status
        case started
        case finished
    }
}

public struct Deployment: Codable {
    public var deploymentLookupModel: DeploymentLookupModel
    public var timestamped: Timestamped
    public var build: Build?
    public var environment: DeploymentEnvironment?
    public var jobs: [DeploymentJob]?

    public init(deploymentLookupModel: DeploymentLookupModel, timestamped: Timestamped, build: Build? = nil, environment: DeploymentEnvironment? = nil, jobs: [DeploymentJob]? = nil) {
        self.deploymentLookupModel = deploymentLookupModel
        self.timestamped = timestamped
        self.build = build
        self.environment = environment
        self.jobs = jobs
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.deploymentLookupModel = try DeploymentLookupModel(from: decoder)
        self.timestamped = try Timestamped(from: decoder)
        self.build = try Build(from: decoder)
        self.environment = try DeploymentEnvironment(from: decoder)
        self.jobs = try values.decodeIfPresent([DeploymentJob].self, forKey: "jobs")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(deploymentLookupModel, forKey: "deploymentLookupModel")
        try values.encode(timestamped, forKey: "timestamped")
        try values.encodeIfPresent(build, forKey: "build")
        try values.encodeIfPresent(environment, forKey: "environment")
        try values.encodeIfPresent(jobs, forKey: "jobs")
    }
}

/// Example:
///
/// {
///   "deploymentId" : 123
/// }
public struct DeploymentCancellation: Codable {
    public var deploymentID: Int

    public init(deploymentID: Int) {
        self.deploymentID = deploymentID
    }

    private enum CodingKeys: String, CodingKey {
        case deploymentID = "deploymentId"
    }
}

public struct ProjectDeployment: Codable {
    public var project: Project
    public var deployment: Deployment

    public init(project: Project, deployment: Deployment) {
        self.project = project
        self.deployment = deployment
    }
}

public struct ProjectDeploymentModel: Codable {
    public var deploymentLookupModel: DeploymentLookupModel
    public var environment: DeploymentEnvironmentLookupModel?

    public init(deploymentLookupModel: DeploymentLookupModel, environment: DeploymentEnvironmentLookupModel? = nil) {
        self.deploymentLookupModel = deploymentLookupModel
        self.environment = environment
    }

    public init(from decoder: Decoder) throws {
        self.deploymentLookupModel = try DeploymentLookupModel(from: decoder)
        self.environment = try DeploymentEnvironmentLookupModel(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(deploymentLookupModel, forKey: "deploymentLookupModel")
        try values.encodeIfPresent(environment, forKey: "environment")
    }
}

public struct ProjectDeploymentsResults: Codable {
    public var project: Project?
    public var deployments: [ProjectDeploymentModel]?

    public init(project: Project? = nil, deployments: [ProjectDeploymentModel]? = nil) {
        self.project = project
        self.deployments = deployments
    }
}

public struct EnvironmentDeploymentModel: Codable {
    public var deploymentLookupModel: DeploymentLookupModel
    public var project: ProjectLookupModel?

    public init(deploymentLookupModel: DeploymentLookupModel, project: ProjectLookupModel? = nil) {
        self.deploymentLookupModel = deploymentLookupModel
        self.project = project
    }

    public init(from decoder: Decoder) throws {
        self.deploymentLookupModel = try DeploymentLookupModel(from: decoder)
        self.project = try ProjectLookupModel(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(deploymentLookupModel, forKey: "deploymentLookupModel")
        try values.encodeIfPresent(project, forKey: "project")
    }
}

public struct DeploymentEnvironmentDeploymentsResults: Codable {
    public var environment: DeploymentEnvironment
    public var deployments: [EnvironmentDeploymentModel]

    public init(environment: DeploymentEnvironment, deployments: [EnvironmentDeploymentModel]) {
        self.environment = environment
        self.deployments = deployments
    }
}

public enum NotificationProviderType: String, Codable, CaseIterable {
    case campfire = "Campfire"
    case email = "Email"
    case gitHubPullRequest = "GitHubPullRequest"
    case hipChat = "HipChat"
    case slack = "Slack"
    case webhook = "Webhook"
    case vSOTeamRoom = "VSOTeamRoom"
}

public enum NotificationSettingsType: String, Codable, CaseIterable {
    case appveyorModelsCampfireNotificationSettingsAppveyorModels = "Appveyor.Models.CampfireNotificationSettings, Appveyor.Models"
    case appveyorModelsEmailNotificationSettingsAppveyorModels = "Appveyor.Models.EmailNotificationSettings, Appveyor.Models"
    case appveyorModelsGitHubPullRequestNotificationSettingsAppveyorModels = "Appveyor.Models.GitHubPullRequestNotificationSettings, Appveyor.Models"
    case appveyorModelsHipChatNotificationSettingsAppveyorModels = "Appveyor.Models.HipChatNotificationSettings, Appveyor.Models"
    case appveyorModelsSlackNotificationSettingsAppveyorModels = "Appveyor.Models.SlackNotificationSettings, Appveyor.Models"
    case appveyorModelsWebhookNotificationSettingsAppveyorModels = "Appveyor.Models.WebhookNotificationSettings, Appveyor.Models"
    case appveyorModelsVSOTeamRoomNotificationSettingsAppveyorModels = "Appveyor.Models.VSOTeamRoomNotificationSettings, Appveyor.Models"
}

/// This type is the union of the settings types for each of the various
/// notification types supported by the API.  The properties correspond to
/// the following notification types:
/// 
/// #### All Types
/// - onBuildSuccess
/// - onBuildFailure
/// - onBuildStatusChanged
/// 
/// #### Campfire
/// - account
/// - authToken
/// - room
/// - template
/// 
/// #### Email
/// - subjectTemplate
/// - bodyTemplate
/// - recipients
/// - recipientsValue
/// 
/// #### GitHubPullRequest
/// - authToken
/// - template
/// 
/// #### HipChat
/// - authToken
/// - from
/// - room
/// - template
/// - serverUrl
/// 
/// #### Slack
/// - incomingWebhookUrl
/// - authToken
/// - channel
/// - template
/// 
/// #### Webhook
/// - method
/// - url
/// - headers
/// - headersValue
/// - addCustomRequestBody
/// - customRequestBodyContentType
/// - customRequestBody
/// 
/// #### VSOTeamRoom
/// - vsoAccount
/// - username
/// - password
/// - room
/// - template
public struct NotificationSettings: Codable {
    public var type: NotificationSettingsType?
    public var isOnBuildSuccess: Bool?
    public var isOnBuildFailure: Bool?
    public var isOnBuildStatusChanged: Bool?
    public var account: String?
    public var authToken: StoredValue?
    public var room: String?
    public var template: String?
    public var subjectTemplate: String?
    public var bodyTemplate: String?
    public var recipients: [StringValueObject]?
    public var recipientsValue: String?
    public var from: String?
    public var serverURL: URL?
    public var incomingWebhookURL: URL?
    public var channel: String?
    public var method: HTTPMethodRestricted?
    public var url: URL?
    public var headers: [StoredNameValue]?
    public var headersValue: String?
    public var isAddCustomRequestBody: Bool?
    public var customRequestBodyContentType: String?
    public var customRequestBody: String?
    public var vsoAccount: String?
    public var username: String?
    public var password: StoredValue?

    public init(type: NotificationSettingsType? = nil, isOnBuildSuccess: Bool? = nil, isOnBuildFailure: Bool? = nil, isOnBuildStatusChanged: Bool? = nil, account: String? = nil, authToken: StoredValue? = nil, room: String? = nil, template: String? = nil, subjectTemplate: String? = nil, bodyTemplate: String? = nil, recipients: [StringValueObject]? = nil, recipientsValue: String? = nil, from: String? = nil, serverURL: URL? = nil, incomingWebhookURL: URL? = nil, channel: String? = nil, method: HTTPMethodRestricted? = nil, url: URL? = nil, headers: [StoredNameValue]? = nil, headersValue: String? = nil, isAddCustomRequestBody: Bool? = nil, customRequestBodyContentType: String? = nil, customRequestBody: String? = nil, vsoAccount: String? = nil, username: String? = nil, password: StoredValue? = nil) {
        self.type = type
        self.isOnBuildSuccess = isOnBuildSuccess
        self.isOnBuildFailure = isOnBuildFailure
        self.isOnBuildStatusChanged = isOnBuildStatusChanged
        self.account = account
        self.authToken = authToken
        self.room = room
        self.template = template
        self.subjectTemplate = subjectTemplate
        self.bodyTemplate = bodyTemplate
        self.recipients = recipients
        self.recipientsValue = recipientsValue
        self.from = from
        self.serverURL = serverURL
        self.incomingWebhookURL = incomingWebhookURL
        self.channel = channel
        self.method = method
        self.url = url
        self.headers = headers
        self.headersValue = headersValue
        self.isAddCustomRequestBody = isAddCustomRequestBody
        self.customRequestBodyContentType = customRequestBodyContentType
        self.customRequestBody = customRequestBody
        self.vsoAccount = vsoAccount
        self.username = username
        self.password = password
    }

    private enum CodingKeys: String, CodingKey {
        case type = "$type"
        case isOnBuildSuccess = "onBuildSuccess"
        case isOnBuildFailure = "onBuildFailure"
        case isOnBuildStatusChanged = "onBuildStatusChanged"
        case account
        case authToken
        case room
        case template
        case subjectTemplate
        case bodyTemplate
        case recipients
        case recipientsValue
        case from
        case serverURL = "serverUrl"
        case incomingWebhookURL = "incomingWebhookUrl"
        case channel
        case method
        case url
        case headers
        case headersValue
        case isAddCustomRequestBody = "addCustomRequestBody"
        case customRequestBodyContentType
        case customRequestBody
        case vsoAccount
        case username
        case password
    }
}

public struct NotificationProviderSettings: Codable {
    public var provider: NotificationProviderType
    /// This type is the union of the settings types for each of the various
    /// notification types supported by the API.  The properties correspond to
    /// the following notification types:
    /// 
    /// #### All Types
    /// - onBuildSuccess
    /// - onBuildFailure
    /// - onBuildStatusChanged
    /// 
    /// #### Campfire
    /// - account
    /// - authToken
    /// - room
    /// - template
    /// 
    /// #### Email
    /// - subjectTemplate
    /// - bodyTemplate
    /// - recipients
    /// - recipientsValue
    /// 
    /// #### GitHubPullRequest
    /// - authToken
    /// - template
    /// 
    /// #### HipChat
    /// - authToken
    /// - from
    /// - room
    /// - template
    /// - serverUrl
    /// 
    /// #### Slack
    /// - incomingWebhookUrl
    /// - authToken
    /// - channel
    /// - template
    /// 
    /// #### Webhook
    /// - method
    /// - url
    /// - headers
    /// - headersValue
    /// - addCustomRequestBody
    /// - customRequestBodyContentType
    /// - customRequestBody
    /// 
    /// #### VSOTeamRoom
    /// - vsoAccount
    /// - username
    /// - password
    /// - room
    /// - template
    public var settings: NotificationSettings

    public init(provider: NotificationProviderType, settings: NotificationSettings) {
        self.provider = provider
        self.settings = settings
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
