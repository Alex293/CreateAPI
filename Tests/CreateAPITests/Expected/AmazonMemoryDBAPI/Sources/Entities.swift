// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

public struct BatchUpdateClusterResponse: Codable {
    public var processedClusters: ProcessedClusters?
    public var unprocessedClusters: UnprocessedClusters?

    public struct ProcessedClusters: Codable {
        public var clusters: [Cluster]
        /// The list of clusters that have been updated.
        public var anyJSON: AnyJSON

        public init(clusters: [Cluster], anyJSON: AnyJSON) {
            self.clusters = clusters
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.clusters = try values.decode([Cluster].self, forKey: "clusters")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(clusters, forKey: "clusters")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct UnprocessedClusters: Codable {
        public var unprocessedClusters: [UnprocessedCluster]
        /// The list of clusters where updates have not been applied.
        public var anyJSON: AnyJSON

        public init(unprocessedClusters: [UnprocessedCluster], anyJSON: AnyJSON) {
            self.unprocessedClusters = unprocessedClusters
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.unprocessedClusters = try values.decode([UnprocessedCluster].self, forKey: "unprocessedClusters")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(unprocessedClusters, forKey: "unprocessedClusters")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(processedClusters: ProcessedClusters? = nil, unprocessedClusters: UnprocessedClusters? = nil) {
        self.processedClusters = processedClusters
        self.unprocessedClusters = unprocessedClusters
    }

    private enum CodingKeys: String, CodingKey {
        case processedClusters = "ProcessedClusters"
        case unprocessedClusters = "UnprocessedClusters"
    }
}

public struct BatchUpdateClusterRequest: Codable {
    public var clusterNames: ClusterNames
    public var serviceUpdate: ServiceUpdate?

    public struct ClusterNames: Codable {
        public var strings: [String]
        /// The cluster names to apply the updates.
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ServiceUpdate: Codable {
        /// A request to apply a service update
        public var serviceUpdateRequest: ServiceUpdateRequest
        /// The unique ID of the service update
        public var anyJSON: AnyJSON

        public init(serviceUpdateRequest: ServiceUpdateRequest, anyJSON: AnyJSON) {
            self.serviceUpdateRequest = serviceUpdateRequest
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.serviceUpdateRequest = try ServiceUpdateRequest(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(serviceUpdateRequest, forKey: "serviceUpdateRequest")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(clusterNames: ClusterNames, serviceUpdate: ServiceUpdate? = nil) {
        self.clusterNames = clusterNames
        self.serviceUpdate = serviceUpdate
    }

    private enum CodingKeys: String, CodingKey {
        case clusterNames = "ClusterNames"
        case serviceUpdate = "ServiceUpdate"
    }
}

public struct CopySnapshotResponse: Codable {
    public var snapshot: Snapshot?

    public final class Snapshot: Codable {
        /// Represents a copy of an entire cluster as of the time when the snapshot was taken.
        public var snapshot: AmazonMemoryDBAPI.Snapshot
        /// Represents a copy of an entire cluster as of the time when the snapshot was taken.
        public var anyJSON: AnyJSON

        public init(snapshot: AmazonMemoryDBAPI.Snapshot, anyJSON: AnyJSON) {
            self.snapshot = snapshot
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.snapshot = try values.decode(AmazonMemoryDBAPI.Snapshot.self, forKey: "snapshot")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(snapshot, forKey: "snapshot")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(snapshot: Snapshot? = nil) {
        self.snapshot = snapshot
    }

    private enum CodingKeys: String, CodingKey {
        case snapshot = "Snapshot"
    }
}

public struct CopySnapshotRequest: Codable {
    public var sourceSnapshotName: SourceSnapshotName
    public var targetSnapshotName: TargetSnapshotName
    public var targetBucket: TargetBucket?
    public var kmsKeyID: KmsKeyID?
    public var tags: Tags?

    public struct SourceSnapshotName: Codable {
        public var string: String
        /// The name of an existing snapshot from which to make a copy.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct TargetSnapshotName: Codable {
        public var string: String
        /// A name for the snapshot copy. MemoryDB does not permit overwriting a snapshot, therefore this name must be unique within its context - MemoryDB or an Amazon S3 bucket if exporting.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct TargetBucket: Codable {
        public var string: String
        /// The Amazon S3 bucket to which the snapshot is exported. This parameter is used only when exporting a snapshot for external access. When using this parameter to export a snapshot, be sure MemoryDB has the needed permissions to this S3 bucket. For more information, see <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/snapshots-exporting.html">Step 2: Grant MemoryDB Access to Your Amazon S3 Bucket</a>.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct KmsKeyID: Codable {
        public var string: String
        /// The ID of the KMS key used to encrypt the target snapshot.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Tags: Codable {
        public var tags: [Tag]
        /// A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
        public var anyJSON: AnyJSON

        public init(tags: [Tag], anyJSON: AnyJSON) {
            self.tags = tags
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.tags = try values.decode([Tag].self, forKey: "tags")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(tags, forKey: "tags")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(sourceSnapshotName: SourceSnapshotName, targetSnapshotName: TargetSnapshotName, targetBucket: TargetBucket? = nil, kmsKeyID: KmsKeyID? = nil, tags: Tags? = nil) {
        self.sourceSnapshotName = sourceSnapshotName
        self.targetSnapshotName = targetSnapshotName
        self.targetBucket = targetBucket
        self.kmsKeyID = kmsKeyID
        self.tags = tags
    }

    private enum CodingKeys: String, CodingKey {
        case sourceSnapshotName = "SourceSnapshotName"
        case targetSnapshotName = "TargetSnapshotName"
        case targetBucket = "TargetBucket"
        case kmsKeyID = "KmsKeyId"
        case tags = "Tags"
    }
}

public struct CreateACLResponse: Codable {
    public var acl: Acl?

    public final class Acl: Codable {
        /// An Access Control List. You can authenticate users with Access Contol Lists. ACLs enable you to control cluster access by grouping users. These Access control lists are designed as a way to organize access to clusters.
        public var acl: AmazonMemoryDBAPI.Acl
        /// The newly-created Access Control List.
        public var anyJSON: AnyJSON

        public init(acl: AmazonMemoryDBAPI.Acl, anyJSON: AnyJSON) {
            self.acl = acl
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.acl = try values.decode(AmazonMemoryDBAPI.Acl.self, forKey: "acl")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(acl, forKey: "acl")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(acl: Acl? = nil) {
        self.acl = acl
    }

    private enum CodingKeys: String, CodingKey {
        case acl = "ACL"
    }
}

public struct CreateACLRequest: Codable {
    public var aCLName: ACLName
    public var userNames: UserNames?
    public var tags: Tags?

    public struct ACLName: Codable {
        public var string: String
        /// The name of the Access Control List.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct UserNames: Codable {
        public var strings: [String]
        /// The list of users that belong to the Access Control List.
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Tags: Codable {
        public var tags: [Tag]
        /// A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
        public var anyJSON: AnyJSON

        public init(tags: [Tag], anyJSON: AnyJSON) {
            self.tags = tags
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.tags = try values.decode([Tag].self, forKey: "tags")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(tags, forKey: "tags")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(aCLName: ACLName, userNames: UserNames? = nil, tags: Tags? = nil) {
        self.aCLName = aCLName
        self.userNames = userNames
        self.tags = tags
    }

    private enum CodingKeys: String, CodingKey {
        case aCLName = "ACLName"
        case userNames = "UserNames"
        case tags = "Tags"
    }
}

public struct CreateClusterResponse: Codable {
    public var cluster: Cluster?

    public final class Cluster: Codable {
        /// Contains all of the attributes of a specific cluster.
        public var cluster: AmazonMemoryDBAPI.Cluster
        /// The newly-created cluster.
        public var anyJSON: AnyJSON

        public init(cluster: AmazonMemoryDBAPI.Cluster, anyJSON: AnyJSON) {
            self.cluster = cluster
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.cluster = try values.decode(AmazonMemoryDBAPI.Cluster.self, forKey: "cluster")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(cluster, forKey: "cluster")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(cluster: Cluster? = nil) {
        self.cluster = cluster
    }

    private enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }
}

public struct CreateClusterRequest: Codable {
    public var clusterName: ClusterName
    public var nodeType: NodeType
    public var parameterGroupName: ParameterGroupName?
    public var description: Description?
    public var numShards: NumShards?
    public var numReplicasPerShard: NumReplicasPerShard?
    public var subnetGroupName: SubnetGroupName?
    public var securityGroupIDs: SecurityGroupIDs?
    public var maintenanceWindow: MaintenanceWindow?
    public var port: Port?
    public var snsTopicArn: SnsTopicArn?
    public var tlsEnabled: TLSEnabled?
    public var kmsKeyID: KmsKeyID?
    public var snapshotArns: SnapshotArns?
    public var snapshotName: SnapshotName?
    public var snapshotRetentionLimit: SnapshotRetentionLimit?
    public var tags: Tags?
    public var snapshotWindow: SnapshotWindow?
    public var aCLName: ACLName
    public var engineVersion: EngineVersion?
    public var autoMinorVersionUpgrade: AutoMinorVersionUpgrade?

    public struct ClusterName: Codable {
        public var string: String
        /// The name of the cluster. This value must be unique as it also serves as the cluster identifier.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NodeType: Codable {
        public var string: String
        /// The compute and memory capacity of the nodes in the cluster.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ParameterGroupName: Codable {
        public var string: String
        /// The name of the parameter group associated with the cluster.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Description: Codable {
        public var string: String
        /// An optional description of the cluster.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NumShards: Codable {
        public var int: Int
        /// The number of shards the cluster will contain. The default value is 1.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NumReplicasPerShard: Codable {
        public var int: Int
        /// The number of replicas to apply to each shard. The default value is 1. The maximum is 5.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SubnetGroupName: Codable {
        public var string: String
        /// The name of the subnet group to be used for the cluster.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SecurityGroupIDs: Codable {
        public var strings: [String]
        /// A list of security group names to associate with this cluster.
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct MaintenanceWindow: Codable {
        public var string: String
        /// Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format <code>ddd:hh24:mi-ddd:hh24:mi</code> (24H Clock UTC). The minimum maintenance window is a 60 minute period.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Port: Codable {
        public var int: Int
        /// The port number on which each of the nodes accepts connections.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SnsTopicArn: Codable {
        public var string: String
        /// The Amazon Resource Name (ARN) of the Amazon Simple Notification Service (SNS) topic to which notifications are sent.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct TLSEnabled: Codable {
        public var isBool: Bool
        /// A flag to enable in-transit encryption on the cluster.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct KmsKeyID: Codable {
        public var string: String
        /// The ID of the KMS key used to encrypt the cluster.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SnapshotArns: Codable {
        public var strings: [String]
        /// A list of Amazon Resource Names (ARN) that uniquely identify the RDB snapshot files stored in Amazon S3. The snapshot files are used to populate the new cluster. The Amazon S3 object name in the ARN cannot contain any commas.
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SnapshotName: Codable {
        public var string: String
        /// The name of a snapshot from which to restore data into the new cluster. The snapshot status changes to restoring while the new cluster is being created.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SnapshotRetentionLimit: Codable {
        public var int: Int
        /// The number of days for which MemoryDB retains automatic snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot that was taken today is retained for 5 days before being deleted.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Tags: Codable {
        public var tags: [Tag]
        /// A list of tags to be added to this resource. Tags are comma-separated key,value pairs (e.g. Key=myKey, Value=myKeyValue. You can include multiple tags as shown following: Key=myKey, Value=myKeyValue Key=mySecondKey, Value=mySecondKeyValue.
        public var anyJSON: AnyJSON

        public init(tags: [Tag], anyJSON: AnyJSON) {
            self.tags = tags
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.tags = try values.decode([Tag].self, forKey: "tags")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(tags, forKey: "tags")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SnapshotWindow: Codable {
        public var string: String
        /// <p>The daily time range (in UTC) during which MemoryDB begins taking a daily snapshot of your shard.</p> <p> Example: 05:00-09:00</p> <p> If you do not specify this parameter, MemoryDB automatically chooses an appropriate time range.</p>
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ACLName: Codable {
        public var string: String
        /// The name of the Access Control List to associate with the cluster.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct EngineVersion: Codable {
        public var string: String
        /// The version number of the Redis engine to be used for the cluster.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AutoMinorVersionUpgrade: Codable {
        public var isBool: Bool
        /// When set to true, the cluster will automatically receive minor engine version upgrades after launch.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(clusterName: ClusterName, nodeType: NodeType, parameterGroupName: ParameterGroupName? = nil, description: Description? = nil, numShards: NumShards? = nil, numReplicasPerShard: NumReplicasPerShard? = nil, subnetGroupName: SubnetGroupName? = nil, securityGroupIDs: SecurityGroupIDs? = nil, maintenanceWindow: MaintenanceWindow? = nil, port: Port? = nil, snsTopicArn: SnsTopicArn? = nil, tlsEnabled: TLSEnabled? = nil, kmsKeyID: KmsKeyID? = nil, snapshotArns: SnapshotArns? = nil, snapshotName: SnapshotName? = nil, snapshotRetentionLimit: SnapshotRetentionLimit? = nil, tags: Tags? = nil, snapshotWindow: SnapshotWindow? = nil, aCLName: ACLName, engineVersion: EngineVersion? = nil, autoMinorVersionUpgrade: AutoMinorVersionUpgrade? = nil) {
        self.clusterName = clusterName
        self.nodeType = nodeType
        self.parameterGroupName = parameterGroupName
        self.description = description
        self.numShards = numShards
        self.numReplicasPerShard = numReplicasPerShard
        self.subnetGroupName = subnetGroupName
        self.securityGroupIDs = securityGroupIDs
        self.maintenanceWindow = maintenanceWindow
        self.port = port
        self.snsTopicArn = snsTopicArn
        self.tlsEnabled = tlsEnabled
        self.kmsKeyID = kmsKeyID
        self.snapshotArns = snapshotArns
        self.snapshotName = snapshotName
        self.snapshotRetentionLimit = snapshotRetentionLimit
        self.tags = tags
        self.snapshotWindow = snapshotWindow
        self.aCLName = aCLName
        self.engineVersion = engineVersion
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
    }

    private enum CodingKeys: String, CodingKey {
        case clusterName = "ClusterName"
        case nodeType = "NodeType"
        case parameterGroupName = "ParameterGroupName"
        case description = "Description"
        case numShards = "NumShards"
        case numReplicasPerShard = "NumReplicasPerShard"
        case subnetGroupName = "SubnetGroupName"
        case securityGroupIDs = "SecurityGroupIds"
        case maintenanceWindow = "MaintenanceWindow"
        case port = "Port"
        case snsTopicArn = "SnsTopicArn"
        case tlsEnabled = "TLSEnabled"
        case kmsKeyID = "KmsKeyId"
        case snapshotArns = "SnapshotArns"
        case snapshotName = "SnapshotName"
        case snapshotRetentionLimit = "SnapshotRetentionLimit"
        case tags = "Tags"
        case snapshotWindow = "SnapshotWindow"
        case aCLName = "ACLName"
        case engineVersion = "EngineVersion"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
    }
}

public struct CreateParameterGroupResponse: Codable {
    public var parameterGroup: ParameterGroup?

    public final class ParameterGroup: Codable {
        /// Represents the output of a CreateParameterGroup operation. A parameter group represents a combination of specific values for the parameters that are passed to the engine software during startup.
        public var parameterGroup: AmazonMemoryDBAPI.ParameterGroup
        /// The newly-created parameter group.
        public var anyJSON: AnyJSON

        public init(parameterGroup: AmazonMemoryDBAPI.ParameterGroup, anyJSON: AnyJSON) {
            self.parameterGroup = parameterGroup
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.parameterGroup = try values.decode(AmazonMemoryDBAPI.ParameterGroup.self, forKey: "parameterGroup")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(parameterGroup, forKey: "parameterGroup")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(parameterGroup: ParameterGroup? = nil) {
        self.parameterGroup = parameterGroup
    }

    private enum CodingKeys: String, CodingKey {
        case parameterGroup = "ParameterGroup"
    }
}

public struct CreateParameterGroupRequest: Codable {
    public var parameterGroupName: ParameterGroupName
    public var family: Family
    public var description: Description?
    public var tags: Tags?

    public struct ParameterGroupName: Codable {
        public var string: String
        /// The name of the parameter group.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Family: Codable {
        public var string: String
        /// The name of the parameter group family that the parameter group can be used with.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Description: Codable {
        public var string: String
        /// An optional description of the parameter group.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Tags: Codable {
        public var tags: [Tag]
        /// A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
        public var anyJSON: AnyJSON

        public init(tags: [Tag], anyJSON: AnyJSON) {
            self.tags = tags
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.tags = try values.decode([Tag].self, forKey: "tags")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(tags, forKey: "tags")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(parameterGroupName: ParameterGroupName, family: Family, description: Description? = nil, tags: Tags? = nil) {
        self.parameterGroupName = parameterGroupName
        self.family = family
        self.description = description
        self.tags = tags
    }

    private enum CodingKeys: String, CodingKey {
        case parameterGroupName = "ParameterGroupName"
        case family = "Family"
        case description = "Description"
        case tags = "Tags"
    }
}

public struct CreateSnapshotResponse: Codable {
    public var snapshot: Snapshot?

    public final class Snapshot: Codable {
        /// Represents a copy of an entire cluster as of the time when the snapshot was taken.
        public var snapshot: AmazonMemoryDBAPI.Snapshot
        /// The newly-created snapshot.
        public var anyJSON: AnyJSON

        public init(snapshot: AmazonMemoryDBAPI.Snapshot, anyJSON: AnyJSON) {
            self.snapshot = snapshot
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.snapshot = try values.decode(AmazonMemoryDBAPI.Snapshot.self, forKey: "snapshot")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(snapshot, forKey: "snapshot")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(snapshot: Snapshot? = nil) {
        self.snapshot = snapshot
    }

    private enum CodingKeys: String, CodingKey {
        case snapshot = "Snapshot"
    }
}

public struct CreateSnapshotRequest: Codable {
    public var clusterName: ClusterName
    public var snapshotName: SnapshotName
    public var kmsKeyID: KmsKeyID?
    public var tags: Tags?

    public struct ClusterName: Codable {
        public var string: String
        /// The snapshot is created from this cluster.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SnapshotName: Codable {
        public var string: String
        /// A name for the snapshot being created.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct KmsKeyID: Codable {
        public var string: String
        /// The ID of the KMS key used to encrypt the snapshot.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Tags: Codable {
        public var tags: [Tag]
        /// A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
        public var anyJSON: AnyJSON

        public init(tags: [Tag], anyJSON: AnyJSON) {
            self.tags = tags
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.tags = try values.decode([Tag].self, forKey: "tags")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(tags, forKey: "tags")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(clusterName: ClusterName, snapshotName: SnapshotName, kmsKeyID: KmsKeyID? = nil, tags: Tags? = nil) {
        self.clusterName = clusterName
        self.snapshotName = snapshotName
        self.kmsKeyID = kmsKeyID
        self.tags = tags
    }

    private enum CodingKeys: String, CodingKey {
        case clusterName = "ClusterName"
        case snapshotName = "SnapshotName"
        case kmsKeyID = "KmsKeyId"
        case tags = "Tags"
    }
}

public struct CreateSubnetGroupResponse: Codable {
    public var subnetGroup: SubnetGroup?

    public final class SubnetGroup: Codable {
        /// <p>Represents the output of one of the following operations:</p> <ul> <li> <p>CreateSubnetGroup</p> </li> <li> <p>UpdateSubnetGroup</p> </li> </ul> <p>A subnet group is a collection of subnets (typically private) that you can designate for your clusters running in an Amazon Virtual Private Cloud (VPC) environment.</p>
        public var subnetGroup: AmazonMemoryDBAPI.SubnetGroup
        /// The newly-created subnet group
        public var anyJSON: AnyJSON

        public init(subnetGroup: AmazonMemoryDBAPI.SubnetGroup, anyJSON: AnyJSON) {
            self.subnetGroup = subnetGroup
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.subnetGroup = try values.decode(AmazonMemoryDBAPI.SubnetGroup.self, forKey: "subnetGroup")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(subnetGroup, forKey: "subnetGroup")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(subnetGroup: SubnetGroup? = nil) {
        self.subnetGroup = subnetGroup
    }

    private enum CodingKeys: String, CodingKey {
        case subnetGroup = "SubnetGroup"
    }
}

public struct CreateSubnetGroupRequest: Codable {
    public var subnetGroupName: SubnetGroupName
    public var description: Description?
    public var subnetIDs: SubnetIDs
    public var tags: Tags?

    public struct SubnetGroupName: Codable {
        public var string: String
        /// The name of the subnet group.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Description: Codable {
        public var string: String
        /// A description for the subnet group.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SubnetIDs: Codable {
        public var strings: [String]
        /// A list of VPC subnet IDs for the subnet group.
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Tags: Codable {
        public var tags: [Tag]
        /// A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
        public var anyJSON: AnyJSON

        public init(tags: [Tag], anyJSON: AnyJSON) {
            self.tags = tags
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.tags = try values.decode([Tag].self, forKey: "tags")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(tags, forKey: "tags")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(subnetGroupName: SubnetGroupName, description: Description? = nil, subnetIDs: SubnetIDs, tags: Tags? = nil) {
        self.subnetGroupName = subnetGroupName
        self.description = description
        self.subnetIDs = subnetIDs
        self.tags = tags
    }

    private enum CodingKeys: String, CodingKey {
        case subnetGroupName = "SubnetGroupName"
        case description = "Description"
        case subnetIDs = "SubnetIds"
        case tags = "Tags"
    }
}

public struct CreateUserResponse: Codable {
    public var user: User?

    public final class User: Codable {
        /// You create users and assign them specific permissions by using an access string. You assign the users to Access Control Lists aligned with a specific role (administrators, human resources) that are then deployed to one or more MemoryDB clusters.
        public var user: AmazonMemoryDBAPI.User
        /// The newly-created user.
        public var anyJSON: AnyJSON

        public init(user: AmazonMemoryDBAPI.User, anyJSON: AnyJSON) {
            self.user = user
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.user = try values.decode(AmazonMemoryDBAPI.User.self, forKey: "user")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(user, forKey: "user")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(user: User? = nil) {
        self.user = user
    }

    private enum CodingKeys: String, CodingKey {
        case user = "User"
    }
}

public struct CreateUserRequest: Codable {
    public var userName: UserName
    public var authenticationMode: AuthenticationMode
    public var accessString: AccessString
    public var tags: Tags?

    public struct UserName: Codable {
        public var string: String
        /// The name of the user. This value must be unique as it also serves as the user identifier.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class AuthenticationMode: Codable {
        /// Denotes the user's authentication properties, such as whether it requires a password to authenticate. Used in output responses.
        public var authenticationMode: AmazonMemoryDBAPI.AuthenticationMode
        /// Denotes the user's authentication properties, such as whether it requires a password to authenticate.
        public var anyJSON: AnyJSON

        public init(authenticationMode: AmazonMemoryDBAPI.AuthenticationMode, anyJSON: AnyJSON) {
            self.authenticationMode = authenticationMode
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.authenticationMode = try values.decode(AmazonMemoryDBAPI.AuthenticationMode.self, forKey: "authenticationMode")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(authenticationMode, forKey: "authenticationMode")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AccessString: Codable {
        public var string: String
        /// Access permissions string used for this user.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Tags: Codable {
        public var tags: [Tag]
        /// A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
        public var anyJSON: AnyJSON

        public init(tags: [Tag], anyJSON: AnyJSON) {
            self.tags = tags
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.tags = try values.decode([Tag].self, forKey: "tags")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(tags, forKey: "tags")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(userName: UserName, authenticationMode: AuthenticationMode, accessString: AccessString, tags: Tags? = nil) {
        self.userName = userName
        self.authenticationMode = authenticationMode
        self.accessString = accessString
        self.tags = tags
    }

    private enum CodingKeys: String, CodingKey {
        case userName = "UserName"
        case authenticationMode = "AuthenticationMode"
        case accessString = "AccessString"
        case tags = "Tags"
    }
}

public struct DeleteACLResponse: Codable {
    public var acl: Acl?

    public final class Acl: Codable {
        /// An Access Control List. You can authenticate users with Access Contol Lists. ACLs enable you to control cluster access by grouping users. These Access control lists are designed as a way to organize access to clusters.
        public var acl: AmazonMemoryDBAPI.Acl
        /// The Access Control List object that has been deleted.
        public var anyJSON: AnyJSON

        public init(acl: AmazonMemoryDBAPI.Acl, anyJSON: AnyJSON) {
            self.acl = acl
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.acl = try values.decode(AmazonMemoryDBAPI.Acl.self, forKey: "acl")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(acl, forKey: "acl")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(acl: Acl? = nil) {
        self.acl = acl
    }

    private enum CodingKeys: String, CodingKey {
        case acl = "ACL"
    }
}

public struct DeleteACLRequest: Codable {
    public var aCLName: ACLName

    public struct ACLName: Codable {
        public var string: String
        /// The name of the Access Control List to delete
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(aCLName: ACLName) {
        self.aCLName = aCLName
    }

    private enum CodingKeys: String, CodingKey {
        case aCLName = "ACLName"
    }
}

public struct DeleteClusterResponse: Codable {
    public var cluster: Cluster?

    public final class Cluster: Codable {
        /// Contains all of the attributes of a specific cluster.
        public var cluster: AmazonMemoryDBAPI.Cluster
        /// The cluster object that has been deleted
        public var anyJSON: AnyJSON

        public init(cluster: AmazonMemoryDBAPI.Cluster, anyJSON: AnyJSON) {
            self.cluster = cluster
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.cluster = try values.decode(AmazonMemoryDBAPI.Cluster.self, forKey: "cluster")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(cluster, forKey: "cluster")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(cluster: Cluster? = nil) {
        self.cluster = cluster
    }

    private enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }
}

public struct DeleteClusterRequest: Codable {
    public var clusterName: ClusterName
    public var finalSnapshotName: FinalSnapshotName?

    public struct ClusterName: Codable {
        public var string: String
        /// The name of the cluster to be deleted
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct FinalSnapshotName: Codable {
        public var string: String
        /// The user-supplied name of a final cluster snapshot. This is the unique name that identifies the snapshot. MemoryDB creates the snapshot, and then deletes the cluster immediately afterward.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(clusterName: ClusterName, finalSnapshotName: FinalSnapshotName? = nil) {
        self.clusterName = clusterName
        self.finalSnapshotName = finalSnapshotName
    }

    private enum CodingKeys: String, CodingKey {
        case clusterName = "ClusterName"
        case finalSnapshotName = "FinalSnapshotName"
    }
}

public struct DeleteParameterGroupResponse: Codable {
    public var parameterGroup: ParameterGroup?

    public final class ParameterGroup: Codable {
        /// Represents the output of a CreateParameterGroup operation. A parameter group represents a combination of specific values for the parameters that are passed to the engine software during startup.
        public var parameterGroup: AmazonMemoryDBAPI.ParameterGroup
        /// The parameter group that has been deleted.
        public var anyJSON: AnyJSON

        public init(parameterGroup: AmazonMemoryDBAPI.ParameterGroup, anyJSON: AnyJSON) {
            self.parameterGroup = parameterGroup
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.parameterGroup = try values.decode(AmazonMemoryDBAPI.ParameterGroup.self, forKey: "parameterGroup")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(parameterGroup, forKey: "parameterGroup")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(parameterGroup: ParameterGroup? = nil) {
        self.parameterGroup = parameterGroup
    }

    private enum CodingKeys: String, CodingKey {
        case parameterGroup = "ParameterGroup"
    }
}

public struct DeleteParameterGroupRequest: Codable {
    public var parameterGroupName: ParameterGroupName

    public struct ParameterGroupName: Codable {
        public var string: String
        /// The name of the parameter group to delete.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(parameterGroupName: ParameterGroupName) {
        self.parameterGroupName = parameterGroupName
    }

    private enum CodingKeys: String, CodingKey {
        case parameterGroupName = "ParameterGroupName"
    }
}

public struct DeleteSnapshotResponse: Codable {
    public var snapshot: Snapshot?

    public final class Snapshot: Codable {
        /// Represents a copy of an entire cluster as of the time when the snapshot was taken.
        public var snapshot: AmazonMemoryDBAPI.Snapshot
        /// The snapshot object that has been deleted.
        public var anyJSON: AnyJSON

        public init(snapshot: AmazonMemoryDBAPI.Snapshot, anyJSON: AnyJSON) {
            self.snapshot = snapshot
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.snapshot = try values.decode(AmazonMemoryDBAPI.Snapshot.self, forKey: "snapshot")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(snapshot, forKey: "snapshot")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(snapshot: Snapshot? = nil) {
        self.snapshot = snapshot
    }

    private enum CodingKeys: String, CodingKey {
        case snapshot = "Snapshot"
    }
}

public struct DeleteSnapshotRequest: Codable {
    public var snapshotName: SnapshotName

    public struct SnapshotName: Codable {
        public var string: String
        /// The name of the snapshot to delete
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(snapshotName: SnapshotName) {
        self.snapshotName = snapshotName
    }

    private enum CodingKeys: String, CodingKey {
        case snapshotName = "SnapshotName"
    }
}

public struct DeleteSubnetGroupResponse: Codable {
    public var subnetGroup: SubnetGroup?

    public final class SubnetGroup: Codable {
        /// <p>Represents the output of one of the following operations:</p> <ul> <li> <p>CreateSubnetGroup</p> </li> <li> <p>UpdateSubnetGroup</p> </li> </ul> <p>A subnet group is a collection of subnets (typically private) that you can designate for your clusters running in an Amazon Virtual Private Cloud (VPC) environment.</p>
        public var subnetGroup: AmazonMemoryDBAPI.SubnetGroup
        /// The subnet group object that has been deleted.
        public var anyJSON: AnyJSON

        public init(subnetGroup: AmazonMemoryDBAPI.SubnetGroup, anyJSON: AnyJSON) {
            self.subnetGroup = subnetGroup
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.subnetGroup = try values.decode(AmazonMemoryDBAPI.SubnetGroup.self, forKey: "subnetGroup")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(subnetGroup, forKey: "subnetGroup")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(subnetGroup: SubnetGroup? = nil) {
        self.subnetGroup = subnetGroup
    }

    private enum CodingKeys: String, CodingKey {
        case subnetGroup = "SubnetGroup"
    }
}

public struct DeleteSubnetGroupRequest: Codable {
    public var subnetGroupName: SubnetGroupName

    public struct SubnetGroupName: Codable {
        public var string: String
        /// The name of the subnet group to delete
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(subnetGroupName: SubnetGroupName) {
        self.subnetGroupName = subnetGroupName
    }

    private enum CodingKeys: String, CodingKey {
        case subnetGroupName = "SubnetGroupName"
    }
}

public struct DeleteUserResponse: Codable {
    public var user: User?

    public final class User: Codable {
        /// You create users and assign them specific permissions by using an access string. You assign the users to Access Control Lists aligned with a specific role (administrators, human resources) that are then deployed to one or more MemoryDB clusters.
        public var user: AmazonMemoryDBAPI.User
        /// The user object that has been deleted.
        public var anyJSON: AnyJSON

        public init(user: AmazonMemoryDBAPI.User, anyJSON: AnyJSON) {
            self.user = user
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.user = try values.decode(AmazonMemoryDBAPI.User.self, forKey: "user")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(user, forKey: "user")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(user: User? = nil) {
        self.user = user
    }

    private enum CodingKeys: String, CodingKey {
        case user = "User"
    }
}

public struct DeleteUserRequest: Codable {
    public var userName: UserName

    public struct UserName: Codable {
        public var string: String
        /// The name of the user to delete
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(userName: UserName) {
        self.userName = userName
    }

    private enum CodingKeys: String, CodingKey {
        case userName = "UserName"
    }
}

public struct DescribeACLsResponse: Codable {
    public var aCLs: ACLs?
    public var nextToken: NextToken?

    public struct ACLs: Codable {
        public var acls: [Acl]
        /// The list of ACLs
        public var anyJSON: AnyJSON

        public init(acls: [Acl], anyJSON: AnyJSON) {
            self.acls = acls
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.acls = try values.decode([Acl].self, forKey: "acls")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(acls, forKey: "acls")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NextToken: Codable {
        public var string: String
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(aCLs: ACLs? = nil, nextToken: NextToken? = nil) {
        self.aCLs = aCLs
        self.nextToken = nextToken
    }

    private enum CodingKeys: String, CodingKey {
        case aCLs = "ACLs"
        case nextToken = "NextToken"
    }
}

public struct DescribeACLsRequest: Codable {
    public var aCLName: ACLName?
    public var maxResults: MaxResults?
    public var nextToken: NextToken?

    public struct ACLName: Codable {
        public var string: String
        /// The name of the ACL
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct MaxResults: Codable {
        public var int: Int
        /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NextToken: Codable {
        public var string: String
        /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(aCLName: ACLName? = nil, maxResults: MaxResults? = nil, nextToken: NextToken? = nil) {
        self.aCLName = aCLName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    private enum CodingKeys: String, CodingKey {
        case aCLName = "ACLName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }
}

public struct DescribeClustersResponse: Codable {
    public var nextToken: NextToken?
    public var clusters: Clusters?

    public struct NextToken: Codable {
        public var string: String
        /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Clusters: Codable {
        public var clusters: [Cluster]
        /// A list of clusters
        public var anyJSON: AnyJSON

        public init(clusters: [Cluster], anyJSON: AnyJSON) {
            self.clusters = clusters
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.clusters = try values.decode([Cluster].self, forKey: "clusters")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(clusters, forKey: "clusters")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(nextToken: NextToken? = nil, clusters: Clusters? = nil) {
        self.nextToken = nextToken
        self.clusters = clusters
    }

    private enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case clusters = "Clusters"
    }
}

public struct DescribeClustersRequest: Codable {
    public var clusterName: ClusterName?
    public var maxResults: MaxResults?
    public var nextToken: NextToken?
    public var showShardDetails: ShowShardDetails?

    public struct ClusterName: Codable {
        public var string: String
        /// The name of the cluster
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct MaxResults: Codable {
        public var int: Int
        /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NextToken: Codable {
        public var string: String
        /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ShowShardDetails: Codable {
        public var isBool: Bool
        /// An optional flag that can be included in the request to retrieve information about the individual shard(s).
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(clusterName: ClusterName? = nil, maxResults: MaxResults? = nil, nextToken: NextToken? = nil, showShardDetails: ShowShardDetails? = nil) {
        self.clusterName = clusterName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.showShardDetails = showShardDetails
    }

    private enum CodingKeys: String, CodingKey {
        case clusterName = "ClusterName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case showShardDetails = "ShowShardDetails"
    }
}

public struct DescribeEngineVersionsResponse: Codable {
    public var nextToken: NextToken?
    public var engineVersions: EngineVersions?

    public struct NextToken: Codable {
        public var string: String
        /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct EngineVersions: Codable {
        public var engineVersionInfos: [EngineVersionInfo]
        /// A list of engine version details. Each element in the list contains detailed information about one engine version.
        public var anyJSON: AnyJSON

        public init(engineVersionInfos: [EngineVersionInfo], anyJSON: AnyJSON) {
            self.engineVersionInfos = engineVersionInfos
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.engineVersionInfos = try values.decode([EngineVersionInfo].self, forKey: "engineVersionInfos")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(engineVersionInfos, forKey: "engineVersionInfos")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(nextToken: NextToken? = nil, engineVersions: EngineVersions? = nil) {
        self.nextToken = nextToken
        self.engineVersions = engineVersions
    }

    private enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case engineVersions = "EngineVersions"
    }
}

public struct DescribeEngineVersionsRequest: Codable {
    public var engineVersion: EngineVersion?
    public var parameterGroupFamily: ParameterGroupFamily?
    public var maxResults: MaxResults?
    public var nextToken: NextToken?
    public var defaultOnly: DefaultOnly?

    public struct EngineVersion: Codable {
        public var string: String
        /// The Redis engine version
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ParameterGroupFamily: Codable {
        public var string: String
        /// The name of a specific parameter group family to return details for.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct MaxResults: Codable {
        public var int: Int
        /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NextToken: Codable {
        public var string: String
        /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct DefaultOnly: Codable {
        public var isBool: Bool
        /// If true, specifies that only the default version of the specified engine or engine and major version combination is to be returned.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(engineVersion: EngineVersion? = nil, parameterGroupFamily: ParameterGroupFamily? = nil, maxResults: MaxResults? = nil, nextToken: NextToken? = nil, defaultOnly: DefaultOnly? = nil) {
        self.engineVersion = engineVersion
        self.parameterGroupFamily = parameterGroupFamily
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.defaultOnly = defaultOnly
    }

    private enum CodingKeys: String, CodingKey {
        case engineVersion = "EngineVersion"
        case parameterGroupFamily = "ParameterGroupFamily"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case defaultOnly = "DefaultOnly"
    }
}

public struct DescribeEventsResponse: Codable {
    public var nextToken: NextToken?
    public var events: Events?

    public struct NextToken: Codable {
        public var string: String
        /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Events: Codable {
        public var events: [Event]
        /// A list of events. Each element in the list contains detailed information about one event.
        public var anyJSON: AnyJSON

        public init(events: [Event], anyJSON: AnyJSON) {
            self.events = events
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.events = try values.decode([Event].self, forKey: "events")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(events, forKey: "events")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(nextToken: NextToken? = nil, events: Events? = nil) {
        self.nextToken = nextToken
        self.events = events
    }

    private enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case events = "Events"
    }
}

public struct DescribeEventsRequest: Codable {
    public var sourceName: SourceName?
    public var sourceType: SourceType?
    public var startTime: StartTime?
    public var endTime: EndTime?
    public var duration: Duration?
    public var maxResults: MaxResults?
    public var nextToken: NextToken?

    public struct SourceName: Codable {
        public var string: String
        /// The identifier of the event source for which events are returned. If not specified, all sources are included in the response.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class SourceType: Codable {
        public var sourceType: AmazonMemoryDBAPI.SourceType
        /// The event source to retrieve events for. If no value is specified, all events are returned.
        public var anyJSON: AnyJSON

        public init(sourceType: AmazonMemoryDBAPI.SourceType, anyJSON: AnyJSON) {
            self.sourceType = sourceType
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.sourceType = try values.decode(AmazonMemoryDBAPI.SourceType.self, forKey: "sourceType")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(sourceType, forKey: "sourceType")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct StartTime: Codable {
        public var date: Date
        /// The beginning of the time interval to retrieve events for, specified in ISO 8601 format. Example: 2017-03-30T07:03:49.555Z
        public var anyJSON: AnyJSON

        public init(date: Date, anyJSON: AnyJSON) {
            self.date = date
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.date = try values.decode(Date.self, forKey: "date")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(date, forKey: "date")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct EndTime: Codable {
        public var date: Date
        /// The end of the time interval for which to retrieve events, specified in ISO 8601 format. Example: 2017-03-30T07:03:49.555Z
        public var anyJSON: AnyJSON

        public init(date: Date, anyJSON: AnyJSON) {
            self.date = date
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.date = try values.decode(Date.self, forKey: "date")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(date, forKey: "date")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Duration: Codable {
        public var int: Int
        /// The number of minutes worth of events to retrieve.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct MaxResults: Codable {
        public var int: Int
        /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NextToken: Codable {
        public var string: String
        /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(sourceName: SourceName? = nil, sourceType: SourceType? = nil, startTime: StartTime? = nil, endTime: EndTime? = nil, duration: Duration? = nil, maxResults: MaxResults? = nil, nextToken: NextToken? = nil) {
        self.sourceName = sourceName
        self.sourceType = sourceType
        self.startTime = startTime
        self.endTime = endTime
        self.duration = duration
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    private enum CodingKeys: String, CodingKey {
        case sourceName = "SourceName"
        case sourceType = "SourceType"
        case startTime = "StartTime"
        case endTime = "EndTime"
        case duration = "Duration"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }
}

public struct DescribeParameterGroupsResponse: Codable {
    public var nextToken: NextToken?
    public var parameterGroups: ParameterGroups?

    public struct NextToken: Codable {
        public var string: String
        /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ParameterGroups: Codable {
        public var parameterGroups: [ParameterGroup]
        /// A list of parameter groups. Each element in the list contains detailed information about one parameter group.
        public var anyJSON: AnyJSON

        public init(parameterGroups: [ParameterGroup], anyJSON: AnyJSON) {
            self.parameterGroups = parameterGroups
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.parameterGroups = try values.decode([ParameterGroup].self, forKey: "parameterGroups")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(parameterGroups, forKey: "parameterGroups")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(nextToken: NextToken? = nil, parameterGroups: ParameterGroups? = nil) {
        self.nextToken = nextToken
        self.parameterGroups = parameterGroups
    }

    private enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case parameterGroups = "ParameterGroups"
    }
}

public struct DescribeParameterGroupsRequest: Codable {
    public var parameterGroupName: ParameterGroupName?
    public var maxResults: MaxResults?
    public var nextToken: NextToken?

    public struct ParameterGroupName: Codable {
        public var string: String
        /// The name of a specific parameter group to return details for.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct MaxResults: Codable {
        public var int: Int
        /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NextToken: Codable {
        public var string: String
        /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(parameterGroupName: ParameterGroupName? = nil, maxResults: MaxResults? = nil, nextToken: NextToken? = nil) {
        self.parameterGroupName = parameterGroupName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    private enum CodingKeys: String, CodingKey {
        case parameterGroupName = "ParameterGroupName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }
}

public struct DescribeParametersResponse: Codable {
    public var nextToken: NextToken?
    public var parameters: Parameters?

    public struct NextToken: Codable {
        public var string: String
        /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Parameters: Codable {
        public var parameters: [Parameter]
        /// A list of parameters specific to a particular parameter group. Each element in the list contains detailed information about one parameter.
        public var anyJSON: AnyJSON

        public init(parameters: [Parameter], anyJSON: AnyJSON) {
            self.parameters = parameters
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.parameters = try values.decode([Parameter].self, forKey: "parameters")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(parameters, forKey: "parameters")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(nextToken: NextToken? = nil, parameters: Parameters? = nil) {
        self.nextToken = nextToken
        self.parameters = parameters
    }

    private enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case parameters = "Parameters"
    }
}

public struct DescribeParametersRequest: Codable {
    public var parameterGroupName: ParameterGroupName
    public var maxResults: MaxResults?
    public var nextToken: NextToken?

    public struct ParameterGroupName: Codable {
        public var string: String
        /// He name of a specific parameter group to return details for.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct MaxResults: Codable {
        public var int: Int
        /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NextToken: Codable {
        public var string: String
        /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(parameterGroupName: ParameterGroupName, maxResults: MaxResults? = nil, nextToken: NextToken? = nil) {
        self.parameterGroupName = parameterGroupName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    private enum CodingKeys: String, CodingKey {
        case parameterGroupName = "ParameterGroupName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }
}

public struct DescribeServiceUpdatesResponse: Codable {
    public var nextToken: NextToken?
    public var serviceUpdates: ServiceUpdates?

    public struct NextToken: Codable {
        public var string: String
        /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ServiceUpdates: Codable {
        public var serviceUpdates: [ServiceUpdate]
        /// A list of service updates
        public var anyJSON: AnyJSON

        public init(serviceUpdates: [ServiceUpdate], anyJSON: AnyJSON) {
            self.serviceUpdates = serviceUpdates
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.serviceUpdates = try values.decode([ServiceUpdate].self, forKey: "serviceUpdates")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(serviceUpdates, forKey: "serviceUpdates")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(nextToken: NextToken? = nil, serviceUpdates: ServiceUpdates? = nil) {
        self.nextToken = nextToken
        self.serviceUpdates = serviceUpdates
    }

    private enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case serviceUpdates = "ServiceUpdates"
    }
}

public struct DescribeServiceUpdatesRequest: Codable {
    public var serviceUpdateName: ServiceUpdateName?
    public var clusterNames: ClusterNames?
    public var status: Status?
    public var maxResults: MaxResults?
    public var nextToken: NextToken?

    public struct ServiceUpdateName: Codable {
        public var string: String
        /// The unique ID of the service update to describe.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ClusterNames: Codable {
        public var strings: [String]
        /// The list of cluster names to identify service updates to apply
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        public var serviceUpdateStatuses: [ServiceUpdateStatus]
        /// The status(es) of the service updates to filter on
        public var anyJSON: AnyJSON

        public init(serviceUpdateStatuses: [ServiceUpdateStatus], anyJSON: AnyJSON) {
            self.serviceUpdateStatuses = serviceUpdateStatuses
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.serviceUpdateStatuses = try values.decode([ServiceUpdateStatus].self, forKey: "serviceUpdateStatuses")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(serviceUpdateStatuses, forKey: "serviceUpdateStatuses")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct MaxResults: Codable {
        public var int: Int
        /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NextToken: Codable {
        public var string: String
        /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(serviceUpdateName: ServiceUpdateName? = nil, clusterNames: ClusterNames? = nil, status: Status? = nil, maxResults: MaxResults? = nil, nextToken: NextToken? = nil) {
        self.serviceUpdateName = serviceUpdateName
        self.clusterNames = clusterNames
        self.status = status
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    private enum CodingKeys: String, CodingKey {
        case serviceUpdateName = "ServiceUpdateName"
        case clusterNames = "ClusterNames"
        case status = "Status"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }
}

public struct DescribeSnapshotsResponse: Codable {
    public var nextToken: NextToken?
    public var snapshots: Snapshots?

    public struct NextToken: Codable {
        public var string: String
        /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Snapshots: Codable {
        public var snapshots: [Snapshot]
        /// A list of snapshots. Each item in the list contains detailed information about one snapshot.
        public var anyJSON: AnyJSON

        public init(snapshots: [Snapshot], anyJSON: AnyJSON) {
            self.snapshots = snapshots
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.snapshots = try values.decode([Snapshot].self, forKey: "snapshots")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(snapshots, forKey: "snapshots")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(nextToken: NextToken? = nil, snapshots: Snapshots? = nil) {
        self.nextToken = nextToken
        self.snapshots = snapshots
    }

    private enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case snapshots = "Snapshots"
    }
}

public struct DescribeSnapshotsRequest: Codable {
    public var clusterName: ClusterName?
    public var snapshotName: SnapshotName?
    public var source: Source?
    public var nextToken: NextToken?
    public var maxResults: MaxResults?
    public var showDetail: ShowDetail?

    public struct ClusterName: Codable {
        public var string: String
        /// A user-supplied cluster identifier. If this parameter is specified, only snapshots associated with that specific cluster are described.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SnapshotName: Codable {
        public var string: String
        /// A user-supplied name of the snapshot. If this parameter is specified, only this named snapshot is described.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Source: Codable {
        public var string: String
        /// If set to system, the output shows snapshots that were automatically created by MemoryDB. If set to user the output shows snapshots that were manually created. If omitted, the output shows both automatically and manually created snapshots.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NextToken: Codable {
        public var string: String
        /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct MaxResults: Codable {
        public var int: Int
        /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ShowDetail: Codable {
        public var isBool: Bool
        /// A Boolean value which if true, the shard configuration is included in the snapshot description.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(clusterName: ClusterName? = nil, snapshotName: SnapshotName? = nil, source: Source? = nil, nextToken: NextToken? = nil, maxResults: MaxResults? = nil, showDetail: ShowDetail? = nil) {
        self.clusterName = clusterName
        self.snapshotName = snapshotName
        self.source = source
        self.nextToken = nextToken
        self.maxResults = maxResults
        self.showDetail = showDetail
    }

    private enum CodingKeys: String, CodingKey {
        case clusterName = "ClusterName"
        case snapshotName = "SnapshotName"
        case source = "Source"
        case nextToken = "NextToken"
        case maxResults = "MaxResults"
        case showDetail = "ShowDetail"
    }
}

public struct DescribeSubnetGroupsResponse: Codable {
    public var nextToken: NextToken?
    public var subnetGroups: SubnetGroups?

    public struct NextToken: Codable {
        public var string: String
        /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SubnetGroups: Codable {
        public var subnetGroups: [SubnetGroup]
        /// A list of subnet groups. Each element in the list contains detailed information about one group.
        public var anyJSON: AnyJSON

        public init(subnetGroups: [SubnetGroup], anyJSON: AnyJSON) {
            self.subnetGroups = subnetGroups
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.subnetGroups = try values.decode([SubnetGroup].self, forKey: "subnetGroups")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(subnetGroups, forKey: "subnetGroups")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(nextToken: NextToken? = nil, subnetGroups: SubnetGroups? = nil) {
        self.nextToken = nextToken
        self.subnetGroups = subnetGroups
    }

    private enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case subnetGroups = "SubnetGroups"
    }
}

public struct DescribeSubnetGroupsRequest: Codable {
    public var subnetGroupName: SubnetGroupName?
    public var maxResults: MaxResults?
    public var nextToken: NextToken?

    public struct SubnetGroupName: Codable {
        public var string: String
        /// The name of the subnet group to return details for.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct MaxResults: Codable {
        public var int: Int
        /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NextToken: Codable {
        public var string: String
        /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(subnetGroupName: SubnetGroupName? = nil, maxResults: MaxResults? = nil, nextToken: NextToken? = nil) {
        self.subnetGroupName = subnetGroupName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    private enum CodingKeys: String, CodingKey {
        case subnetGroupName = "SubnetGroupName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }
}

public struct DescribeUsersResponse: Codable {
    public var users: Users?
    public var nextToken: NextToken?

    public struct Users: Codable {
        public var users: [User]
        /// A list of users.
        public var anyJSON: AnyJSON

        public init(users: [User], anyJSON: AnyJSON) {
            self.users = users
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.users = try values.decode([User].self, forKey: "users")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(users, forKey: "users")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NextToken: Codable {
        public var string: String
        /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(users: Users? = nil, nextToken: NextToken? = nil) {
        self.users = users
        self.nextToken = nextToken
    }

    private enum CodingKeys: String, CodingKey {
        case users = "Users"
        case nextToken = "NextToken"
    }
}

public struct DescribeUsersRequest: Codable {
    public var userName: UserName?
    public var filters: Filters?
    public var maxResults: MaxResults?
    public var nextToken: NextToken?

    public struct UserName: Codable {
        public var string: String
        /// The name of the user
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Filters: Codable {
        public var filters: [Filter]
        /// Filter to determine the list of users to return.
        public var anyJSON: AnyJSON

        public init(filters: [Filter], anyJSON: AnyJSON) {
            self.filters = filters
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.filters = try values.decode([Filter].self, forKey: "filters")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(filters, forKey: "filters")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct MaxResults: Codable {
        public var int: Int
        /// The maximum number of records to include in the response. If more records exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NextToken: Codable {
        public var string: String
        /// An optional argument to pass in case the total number of records exceeds the value of MaxResults. If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(userName: UserName? = nil, filters: Filters? = nil, maxResults: MaxResults? = nil, nextToken: NextToken? = nil) {
        self.userName = userName
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }

    private enum CodingKeys: String, CodingKey {
        case userName = "UserName"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }
}

public struct FailoverShardResponse: Codable {
    public var cluster: Cluster?

    public final class Cluster: Codable {
        /// Contains all of the attributes of a specific cluster.
        public var cluster: AmazonMemoryDBAPI.Cluster
        /// The cluster being failed over
        public var anyJSON: AnyJSON

        public init(cluster: AmazonMemoryDBAPI.Cluster, anyJSON: AnyJSON) {
            self.cluster = cluster
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.cluster = try values.decode(AmazonMemoryDBAPI.Cluster.self, forKey: "cluster")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(cluster, forKey: "cluster")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(cluster: Cluster? = nil) {
        self.cluster = cluster
    }

    private enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }
}

public struct FailoverShardRequest: Codable {
    public var clusterName: ClusterName
    public var shardName: ShardName

    public struct ClusterName: Codable {
        public var string: String
        /// The cluster being failed over
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ShardName: Codable {
        public var string: String
        /// The name of the shard
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(clusterName: ClusterName, shardName: ShardName) {
        self.clusterName = clusterName
        self.shardName = shardName
    }

    private enum CodingKeys: String, CodingKey {
        case clusterName = "ClusterName"
        case shardName = "ShardName"
    }
}

public struct ListAllowedNodeTypeUpdatesResponse: Codable {
    public var scaleUpNodeTypes: ScaleUpNodeTypes?
    public var scaleDownNodeTypes: ScaleDownNodeTypes?

    public struct ScaleUpNodeTypes: Codable {
        public var strings: [String]
        /// A list node types which you can use to scale up your cluster.
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ScaleDownNodeTypes: Codable {
        public var strings: [String]
        /// A list node types which you can use to scale down your cluster.
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(scaleUpNodeTypes: ScaleUpNodeTypes? = nil, scaleDownNodeTypes: ScaleDownNodeTypes? = nil) {
        self.scaleUpNodeTypes = scaleUpNodeTypes
        self.scaleDownNodeTypes = scaleDownNodeTypes
    }

    private enum CodingKeys: String, CodingKey {
        case scaleUpNodeTypes = "ScaleUpNodeTypes"
        case scaleDownNodeTypes = "ScaleDownNodeTypes"
    }
}

public struct ListAllowedNodeTypeUpdatesRequest: Codable {
    public var clusterName: ClusterName

    public struct ClusterName: Codable {
        public var string: String
        /// The name of the cluster you want to scale. MemoryDB uses the cluster name to identify the current node type being used by this cluster, and from that to create a list of node types you can scale up to.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(clusterName: ClusterName) {
        self.clusterName = clusterName
    }

    private enum CodingKeys: String, CodingKey {
        case clusterName = "ClusterName"
    }
}

public struct ListTagsResponse: Codable {
    public var tagList: TagList?

    public struct TagList: Codable {
        public var tags: [Tag]
        /// A list of tags as key-value pairs.
        public var anyJSON: AnyJSON

        public init(tags: [Tag], anyJSON: AnyJSON) {
            self.tags = tags
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.tags = try values.decode([Tag].self, forKey: "tags")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(tags, forKey: "tags")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(tagList: TagList? = nil) {
        self.tagList = tagList
    }

    private enum CodingKeys: String, CodingKey {
        case tagList = "TagList"
    }
}

public struct ListTagsRequest: Codable {
    public var resourceArn: ResourceArn

    public struct ResourceArn: Codable {
        public var string: String
        /// The Amazon Resource Name (ARN) of the resource for which you want the list of tags
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(resourceArn: ResourceArn) {
        self.resourceArn = resourceArn
    }

    private enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }
}

public struct ResetParameterGroupResponse: Codable {
    public var parameterGroup: ParameterGroup?

    public final class ParameterGroup: Codable {
        /// Represents the output of a CreateParameterGroup operation. A parameter group represents a combination of specific values for the parameters that are passed to the engine software during startup.
        public var parameterGroup: AmazonMemoryDBAPI.ParameterGroup
        /// The parameter group being reset.
        public var anyJSON: AnyJSON

        public init(parameterGroup: AmazonMemoryDBAPI.ParameterGroup, anyJSON: AnyJSON) {
            self.parameterGroup = parameterGroup
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.parameterGroup = try values.decode(AmazonMemoryDBAPI.ParameterGroup.self, forKey: "parameterGroup")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(parameterGroup, forKey: "parameterGroup")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(parameterGroup: ParameterGroup? = nil) {
        self.parameterGroup = parameterGroup
    }

    private enum CodingKeys: String, CodingKey {
        case parameterGroup = "ParameterGroup"
    }
}

public struct ResetParameterGroupRequest: Codable {
    public var parameterGroupName: ParameterGroupName
    public var allParameters: AllParameters?
    public var parameterNames: ParameterNames?

    public struct ParameterGroupName: Codable {
        public var string: String
        /// The name of the parameter group to reset.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AllParameters: Codable {
        public var isBool: Bool
        /// If true, all parameters in the parameter group are reset to their default values. If false, only the parameters listed by ParameterNames are reset to their default values.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ParameterNames: Codable {
        public var strings: [String]
        /// An array of parameter names to reset to their default values. If AllParameters is true, do not use ParameterNames. If AllParameters is false, you must specify the name of at least one parameter to reset.
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(parameterGroupName: ParameterGroupName, allParameters: AllParameters? = nil, parameterNames: ParameterNames? = nil) {
        self.parameterGroupName = parameterGroupName
        self.allParameters = allParameters
        self.parameterNames = parameterNames
    }

    private enum CodingKeys: String, CodingKey {
        case parameterGroupName = "ParameterGroupName"
        case allParameters = "AllParameters"
        case parameterNames = "ParameterNames"
    }
}

public struct TagResourceResponse: Codable {
    public var tagList: TagList?

    public struct TagList: Codable {
        public var tags: [Tag]
        /// A list of tags as key-value pairs.
        public var anyJSON: AnyJSON

        public init(tags: [Tag], anyJSON: AnyJSON) {
            self.tags = tags
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.tags = try values.decode([Tag].self, forKey: "tags")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(tags, forKey: "tags")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(tagList: TagList? = nil) {
        self.tagList = tagList
    }

    private enum CodingKeys: String, CodingKey {
        case tagList = "TagList"
    }
}

public struct TagResourceRequest: Codable {
    public var resourceArn: ResourceArn
    public var tags: Tags

    public struct ResourceArn: Codable {
        public var string: String
        /// The Amazon Resource Name (ARN) of the resource to which the tags are to be added
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Tags: Codable {
        public var tags: [Tag]
        /// A list of tags to be added to this resource. A tag is a key-value pair. A tag key must be accompanied by a tag value, although null is accepted.
        public var anyJSON: AnyJSON

        public init(tags: [Tag], anyJSON: AnyJSON) {
            self.tags = tags
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.tags = try values.decode([Tag].self, forKey: "tags")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(tags, forKey: "tags")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(resourceArn: ResourceArn, tags: Tags) {
        self.resourceArn = resourceArn
        self.tags = tags
    }

    private enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }
}

public struct UntagResourceResponse: Codable {
    public var tagList: TagList?

    public struct TagList: Codable {
        public var tags: [Tag]
        /// The list of tags removed
        public var anyJSON: AnyJSON

        public init(tags: [Tag], anyJSON: AnyJSON) {
            self.tags = tags
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.tags = try values.decode([Tag].self, forKey: "tags")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(tags, forKey: "tags")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(tagList: TagList? = nil) {
        self.tagList = tagList
    }

    private enum CodingKeys: String, CodingKey {
        case tagList = "TagList"
    }
}

public struct UntagResourceRequest: Codable {
    public var resourceArn: ResourceArn
    public var tagKeys: TagKeys

    public struct ResourceArn: Codable {
        public var string: String
        /// The Amazon Resource Name (ARN) of the resource to which the tags are to be removed
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct TagKeys: Codable {
        public var strings: [String]
        /// The list of keys of the tags that are to be removed
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(resourceArn: ResourceArn, tagKeys: TagKeys) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }

    private enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }
}

public struct UpdateACLResponse: Codable {
    public var acl: Acl?

    public final class Acl: Codable {
        /// An Access Control List. You can authenticate users with Access Contol Lists. ACLs enable you to control cluster access by grouping users. These Access control lists are designed as a way to organize access to clusters.
        public var acl: AmazonMemoryDBAPI.Acl
        /// The updated Access Control List
        public var anyJSON: AnyJSON

        public init(acl: AmazonMemoryDBAPI.Acl, anyJSON: AnyJSON) {
            self.acl = acl
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.acl = try values.decode(AmazonMemoryDBAPI.Acl.self, forKey: "acl")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(acl, forKey: "acl")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(acl: Acl? = nil) {
        self.acl = acl
    }

    private enum CodingKeys: String, CodingKey {
        case acl = "ACL"
    }
}

public struct UpdateACLRequest: Codable {
    public var aCLName: ACLName
    public var userNamesToAdd: UserNamesToAdd?
    public var userNamesToRemove: UserNamesToRemove?

    public struct ACLName: Codable {
        public var string: String
        /// The name of the Access Control List
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct UserNamesToAdd: Codable {
        public var strings: [String]
        /// The list of users to add to the Access Control List
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct UserNamesToRemove: Codable {
        public var strings: [String]
        /// The list of users to remove from the Access Control List
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(aCLName: ACLName, userNamesToAdd: UserNamesToAdd? = nil, userNamesToRemove: UserNamesToRemove? = nil) {
        self.aCLName = aCLName
        self.userNamesToAdd = userNamesToAdd
        self.userNamesToRemove = userNamesToRemove
    }

    private enum CodingKeys: String, CodingKey {
        case aCLName = "ACLName"
        case userNamesToAdd = "UserNamesToAdd"
        case userNamesToRemove = "UserNamesToRemove"
    }
}

public struct UpdateClusterResponse: Codable {
    public var cluster: Cluster?

    public final class Cluster: Codable {
        /// Contains all of the attributes of a specific cluster.
        public var cluster: AmazonMemoryDBAPI.Cluster
        /// The updated cluster
        public var anyJSON: AnyJSON

        public init(cluster: AmazonMemoryDBAPI.Cluster, anyJSON: AnyJSON) {
            self.cluster = cluster
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.cluster = try values.decode(AmazonMemoryDBAPI.Cluster.self, forKey: "cluster")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(cluster, forKey: "cluster")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(cluster: Cluster? = nil) {
        self.cluster = cluster
    }

    private enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }
}

public struct UpdateClusterRequest: Codable {
    public var clusterName: ClusterName
    public var description: Description?
    public var securityGroupIDs: SecurityGroupIDs?
    public var maintenanceWindow: MaintenanceWindow?
    public var snsTopicArn: SnsTopicArn?
    public var snsTopicStatus: SnsTopicStatus?
    public var parameterGroupName: ParameterGroupName?
    public var snapshotWindow: SnapshotWindow?
    public var snapshotRetentionLimit: SnapshotRetentionLimit?
    public var nodeType: NodeType?
    public var engineVersion: EngineVersion?
    public var replicaConfiguration: ReplicaConfiguration?
    public var shardConfiguration: ShardConfiguration?
    public var aCLName: ACLName?

    public struct ClusterName: Codable {
        public var string: String
        /// The name of the cluster to update
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Description: Codable {
        public var string: String
        /// The description of the cluster to update
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SecurityGroupIDs: Codable {
        public var strings: [String]
        /// The SecurityGroupIds to update
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct MaintenanceWindow: Codable {
        public var string: String
        /// The maintenance window to update
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SnsTopicArn: Codable {
        public var string: String
        /// The SNS topic ARN to update
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SnsTopicStatus: Codable {
        public var string: String
        /// The status of the Amazon SNS notification topic. Notifications are sent only if the status is active.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ParameterGroupName: Codable {
        public var string: String
        /// The name of the parameter group to update
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SnapshotWindow: Codable {
        public var string: String
        /// The daily time range (in UTC) during which MemoryDB begins taking a daily snapshot of your cluster.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SnapshotRetentionLimit: Codable {
        public var int: Int
        /// The number of days for which MemoryDB retains automatic cluster snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot that was taken today is retained for 5 days before being deleted.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NodeType: Codable {
        public var string: String
        /// A valid node type that you want to scale this cluster up or down to.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct EngineVersion: Codable {
        public var string: String
        /// The upgraded version of the engine to be run on the nodes. You can upgrade to a newer engine version, but you cannot downgrade to an earlier engine version. If you want to use an earlier engine version, you must delete the existing cluster and create it anew with the earlier engine version.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ReplicaConfiguration: Codable {
        /// A request to configure the number of replicas in a shard
        public var replicaConfigurationRequest: ReplicaConfigurationRequest
        /// The number of replicas that will reside in each shard
        public var anyJSON: AnyJSON

        public init(replicaConfigurationRequest: ReplicaConfigurationRequest, anyJSON: AnyJSON) {
            self.replicaConfigurationRequest = replicaConfigurationRequest
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.replicaConfigurationRequest = try ReplicaConfigurationRequest(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(replicaConfigurationRequest, forKey: "replicaConfigurationRequest")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ShardConfiguration: Codable {
        /// A request to configure the sharding properties of a cluster
        public var shardConfigurationRequest: ShardConfigurationRequest
        /// The number of shards in the cluster
        public var anyJSON: AnyJSON

        public init(shardConfigurationRequest: ShardConfigurationRequest, anyJSON: AnyJSON) {
            self.shardConfigurationRequest = shardConfigurationRequest
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.shardConfigurationRequest = try ShardConfigurationRequest(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(shardConfigurationRequest, forKey: "shardConfigurationRequest")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ACLName: Codable {
        public var string: String
        /// The Access Control List that is associated with the cluster
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(clusterName: ClusterName, description: Description? = nil, securityGroupIDs: SecurityGroupIDs? = nil, maintenanceWindow: MaintenanceWindow? = nil, snsTopicArn: SnsTopicArn? = nil, snsTopicStatus: SnsTopicStatus? = nil, parameterGroupName: ParameterGroupName? = nil, snapshotWindow: SnapshotWindow? = nil, snapshotRetentionLimit: SnapshotRetentionLimit? = nil, nodeType: NodeType? = nil, engineVersion: EngineVersion? = nil, replicaConfiguration: ReplicaConfiguration? = nil, shardConfiguration: ShardConfiguration? = nil, aCLName: ACLName? = nil) {
        self.clusterName = clusterName
        self.description = description
        self.securityGroupIDs = securityGroupIDs
        self.maintenanceWindow = maintenanceWindow
        self.snsTopicArn = snsTopicArn
        self.snsTopicStatus = snsTopicStatus
        self.parameterGroupName = parameterGroupName
        self.snapshotWindow = snapshotWindow
        self.snapshotRetentionLimit = snapshotRetentionLimit
        self.nodeType = nodeType
        self.engineVersion = engineVersion
        self.replicaConfiguration = replicaConfiguration
        self.shardConfiguration = shardConfiguration
        self.aCLName = aCLName
    }

    private enum CodingKeys: String, CodingKey {
        case clusterName = "ClusterName"
        case description = "Description"
        case securityGroupIDs = "SecurityGroupIds"
        case maintenanceWindow = "MaintenanceWindow"
        case snsTopicArn = "SnsTopicArn"
        case snsTopicStatus = "SnsTopicStatus"
        case parameterGroupName = "ParameterGroupName"
        case snapshotWindow = "SnapshotWindow"
        case snapshotRetentionLimit = "SnapshotRetentionLimit"
        case nodeType = "NodeType"
        case engineVersion = "EngineVersion"
        case replicaConfiguration = "ReplicaConfiguration"
        case shardConfiguration = "ShardConfiguration"
        case aCLName = "ACLName"
    }
}

public struct UpdateParameterGroupResponse: Codable {
    public var parameterGroup: ParameterGroup?

    public final class ParameterGroup: Codable {
        /// Represents the output of a CreateParameterGroup operation. A parameter group represents a combination of specific values for the parameters that are passed to the engine software during startup.
        public var parameterGroup: AmazonMemoryDBAPI.ParameterGroup
        /// The updated parameter group
        public var anyJSON: AnyJSON

        public init(parameterGroup: AmazonMemoryDBAPI.ParameterGroup, anyJSON: AnyJSON) {
            self.parameterGroup = parameterGroup
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.parameterGroup = try values.decode(AmazonMemoryDBAPI.ParameterGroup.self, forKey: "parameterGroup")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(parameterGroup, forKey: "parameterGroup")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(parameterGroup: ParameterGroup? = nil) {
        self.parameterGroup = parameterGroup
    }

    private enum CodingKeys: String, CodingKey {
        case parameterGroup = "ParameterGroup"
    }
}

public struct UpdateParameterGroupRequest: Codable {
    public var parameterGroupName: ParameterGroupName
    public var parameterNameValues: ParameterNameValues

    public struct ParameterGroupName: Codable {
        public var string: String
        /// The name of the parameter group to update.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ParameterNameValues: Codable {
        public var parameterNameValues: [ParameterNameValue]
        /// An array of parameter names and values for the parameter update. You must supply at least one parameter name and value; subsequent arguments are optional. A maximum of 20 parameters may be updated per request.
        public var anyJSON: AnyJSON

        public init(parameterNameValues: [ParameterNameValue], anyJSON: AnyJSON) {
            self.parameterNameValues = parameterNameValues
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.parameterNameValues = try values.decode([ParameterNameValue].self, forKey: "parameterNameValues")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(parameterNameValues, forKey: "parameterNameValues")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(parameterGroupName: ParameterGroupName, parameterNameValues: ParameterNameValues) {
        self.parameterGroupName = parameterGroupName
        self.parameterNameValues = parameterNameValues
    }

    private enum CodingKeys: String, CodingKey {
        case parameterGroupName = "ParameterGroupName"
        case parameterNameValues = "ParameterNameValues"
    }
}

public struct UpdateSubnetGroupResponse: Codable {
    public var subnetGroup: SubnetGroup?

    public final class SubnetGroup: Codable {
        /// <p>Represents the output of one of the following operations:</p> <ul> <li> <p>CreateSubnetGroup</p> </li> <li> <p>UpdateSubnetGroup</p> </li> </ul> <p>A subnet group is a collection of subnets (typically private) that you can designate for your clusters running in an Amazon Virtual Private Cloud (VPC) environment.</p>
        public var subnetGroup: AmazonMemoryDBAPI.SubnetGroup
        /// The updated subnet group
        public var anyJSON: AnyJSON

        public init(subnetGroup: AmazonMemoryDBAPI.SubnetGroup, anyJSON: AnyJSON) {
            self.subnetGroup = subnetGroup
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.subnetGroup = try values.decode(AmazonMemoryDBAPI.SubnetGroup.self, forKey: "subnetGroup")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(subnetGroup, forKey: "subnetGroup")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(subnetGroup: SubnetGroup? = nil) {
        self.subnetGroup = subnetGroup
    }

    private enum CodingKeys: String, CodingKey {
        case subnetGroup = "SubnetGroup"
    }
}

public struct UpdateSubnetGroupRequest: Codable {
    public var subnetGroupName: SubnetGroupName
    public var description: Description?
    public var subnetIDs: SubnetIDs?

    public struct SubnetGroupName: Codable {
        public var string: String
        /// The name of the subnet group
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Description: Codable {
        public var string: String
        /// A description of the subnet group
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SubnetIDs: Codable {
        public var strings: [String]
        /// The EC2 subnet IDs for the subnet group.
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(subnetGroupName: SubnetGroupName, description: Description? = nil, subnetIDs: SubnetIDs? = nil) {
        self.subnetGroupName = subnetGroupName
        self.description = description
        self.subnetIDs = subnetIDs
    }

    private enum CodingKeys: String, CodingKey {
        case subnetGroupName = "SubnetGroupName"
        case description = "Description"
        case subnetIDs = "SubnetIds"
    }
}

public struct UpdateUserResponse: Codable {
    public var user: User?

    public final class User: Codable {
        /// You create users and assign them specific permissions by using an access string. You assign the users to Access Control Lists aligned with a specific role (administrators, human resources) that are then deployed to one or more MemoryDB clusters.
        public var user: AmazonMemoryDBAPI.User
        /// The updated user
        public var anyJSON: AnyJSON

        public init(user: AmazonMemoryDBAPI.User, anyJSON: AnyJSON) {
            self.user = user
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.user = try values.decode(AmazonMemoryDBAPI.User.self, forKey: "user")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(user, forKey: "user")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(user: User? = nil) {
        self.user = user
    }

    private enum CodingKeys: String, CodingKey {
        case user = "User"
    }
}

public struct UpdateUserRequest: Codable {
    public var userName: UserName
    public var authenticationMode: AuthenticationMode?
    public var accessString: AccessString?

    public struct UserName: Codable {
        public var string: String
        /// The name of the user
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class AuthenticationMode: Codable {
        /// Denotes the user's authentication properties, such as whether it requires a password to authenticate. Used in output responses.
        public var authenticationMode: AmazonMemoryDBAPI.AuthenticationMode
        /// Denotes the user's authentication properties, such as whether it requires a password to authenticate.
        public var anyJSON: AnyJSON

        public init(authenticationMode: AmazonMemoryDBAPI.AuthenticationMode, anyJSON: AnyJSON) {
            self.authenticationMode = authenticationMode
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.authenticationMode = try values.decode(AmazonMemoryDBAPI.AuthenticationMode.self, forKey: "authenticationMode")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(authenticationMode, forKey: "authenticationMode")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AccessString: Codable {
        public var string: String
        /// Access permissions string used for this user.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(userName: UserName, authenticationMode: AuthenticationMode? = nil, accessString: AccessString? = nil) {
        self.userName = userName
        self.authenticationMode = authenticationMode
        self.accessString = accessString
    }

    private enum CodingKeys: String, CodingKey {
        case userName = "UserName"
        case authenticationMode = "AuthenticationMode"
        case accessString = "AccessString"
    }
}

/// Returns the updates being applied to the ACL.
public struct ACLPendingChanges: Codable {
    public var userNamesToRemove: UserNamesToRemove?
    public var userNamesToAdd: UserNamesToAdd?

    public struct UserNamesToRemove: Codable {
        public var strings: [String]
        /// A list of user names being removed from the ACL
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct UserNamesToAdd: Codable {
        public var strings: [String]
        /// A list of users being added to the ACL
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(userNamesToRemove: UserNamesToRemove? = nil, userNamesToAdd: UserNamesToAdd? = nil) {
        self.userNamesToRemove = userNamesToRemove
        self.userNamesToAdd = userNamesToAdd
    }

    private enum CodingKeys: String, CodingKey {
        case userNamesToRemove = "UserNamesToRemove"
        case userNamesToAdd = "UserNamesToAdd"
    }
}

/// An Access Control List. You can authenticate users with Access Contol Lists. ACLs enable you to control cluster access by grouping users. These Access control lists are designed as a way to organize access to clusters.
public struct Acl: Codable {
    public var name: Name?
    public var status: Status?
    public var userNames: UserNames?
    public var minimumEngineVersion: MinimumEngineVersion?
    public var pendingChanges: PendingChanges?
    public var clusters: Clusters?
    public var arn: Arn?

    public struct Name: Codable {
        public var string: String
        /// The name of the Access Control List
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        public var string: String
        /// Indicates ACL status. Can be "creating", "active", "modifying", "deleting".
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct UserNames: Codable {
        public var strings: [String]
        /// The list of user names that belong to the ACL.
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct MinimumEngineVersion: Codable {
        public var string: String
        /// The minimum engine version supported for the ACL
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct PendingChanges: Codable {
        /// Returns the updates being applied to the ACL.
        public var aCLPendingChanges: ACLPendingChanges
        /// A list of updates being applied to the ACL.
        public var anyJSON: AnyJSON

        public init(aCLPendingChanges: ACLPendingChanges, anyJSON: AnyJSON) {
            self.aCLPendingChanges = aCLPendingChanges
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.aCLPendingChanges = try ACLPendingChanges(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(aCLPendingChanges, forKey: "aCLPendingChanges")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Clusters: Codable {
        public var strings: [String]
        /// A list of clusters associated with the ACL.
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Arn: Codable {
        public var string: String
        /// The Amazon Resource Name (ARN) of the ACL
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(name: Name? = nil, status: Status? = nil, userNames: UserNames? = nil, minimumEngineVersion: MinimumEngineVersion? = nil, pendingChanges: PendingChanges? = nil, clusters: Clusters? = nil, arn: Arn? = nil) {
        self.name = name
        self.status = status
        self.userNames = userNames
        self.minimumEngineVersion = minimumEngineVersion
        self.pendingChanges = pendingChanges
        self.clusters = clusters
        self.arn = arn
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case status = "Status"
        case userNames = "UserNames"
        case minimumEngineVersion = "MinimumEngineVersion"
        case pendingChanges = "PendingChanges"
        case clusters = "Clusters"
        case arn = "ARN"
    }
}

/// The status of the ACL update
public struct ACLsUpdateStatus: Codable {
    public var aCLToApply: ACLToApply?

    public struct ACLToApply: Codable {
        public var string: String
        /// A list of ACLs pending to be applied.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(aCLToApply: ACLToApply? = nil) {
        self.aCLToApply = aCLToApply
    }

    private enum CodingKeys: String, CodingKey {
        case aCLToApply = "ACLToApply"
    }
}

public enum AZStatus: String, Codable, CaseIterable {
    case singleaz
    case multiaz
}

public enum AuthenticationType: String, Codable, CaseIterable {
    case password
    case noPassword = "no-password"
}

/// Denotes the user's authentication properties, such as whether it requires a password to authenticate. Used in output responses.
public struct Authentication: Codable {
    public var type: `Type`?
    public var passwordCount: PasswordCount?

    public struct `Type`: Codable {
        public var authenticationType: AuthenticationType
        /// Indicates whether the user requires a password to authenticate.
        public var anyJSON: AnyJSON

        public init(authenticationType: AuthenticationType, anyJSON: AnyJSON) {
            self.authenticationType = authenticationType
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.authenticationType = try AuthenticationType(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(authenticationType, forKey: "authenticationType")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct PasswordCount: Codable {
        public var int: Int
        /// The number of passwords belonging to the user. The maximum is two.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(type: `Type`? = nil, passwordCount: PasswordCount? = nil) {
        self.type = type
        self.passwordCount = passwordCount
    }

    private enum CodingKeys: String, CodingKey {
        case type = "Type"
        case passwordCount = "PasswordCount"
    }
}

public enum InputAuthenticationType: String, Codable, CaseIterable {
    case password
}

/// Denotes the user's authentication properties, such as whether it requires a password to authenticate. Used in output responses.
public struct AuthenticationMode: Codable {
    public var type: `Type`?
    public var passwords: Passwords?

    public struct `Type`: Codable {
        public var inputAuthenticationType: InputAuthenticationType
        /// Indicates whether the user requires a password to authenticate. All newly-created users require a password.
        public var anyJSON: AnyJSON

        public init(inputAuthenticationType: InputAuthenticationType, anyJSON: AnyJSON) {
            self.inputAuthenticationType = inputAuthenticationType
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.inputAuthenticationType = try InputAuthenticationType(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(inputAuthenticationType, forKey: "inputAuthenticationType")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Passwords: Codable {
        public var strings: [String]
        /// The password(s) used for authentication
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(type: `Type`? = nil, passwords: Passwords? = nil) {
        self.type = type
        self.passwords = passwords
    }

    private enum CodingKeys: String, CodingKey {
        case type = "Type"
        case passwords = "Passwords"
    }
}

/// Indicates if the cluster has a Multi-AZ configuration (multiaz) or not (singleaz).
public struct AvailabilityZone: Codable {
    public var name: Name?

    public struct Name: Codable {
        public var string: String
        /// The name of the Availability Zone.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(name: Name? = nil) {
        self.name = name
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
    }
}

/// A request to apply a service update
public struct ServiceUpdateRequest: Codable {
    public var serviceUpdateNameToApply: ServiceUpdateNameToApply?

    public struct ServiceUpdateNameToApply: Codable {
        public var string: String
        /// The unique ID of the service update
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(serviceUpdateNameToApply: ServiceUpdateNameToApply? = nil) {
        self.serviceUpdateNameToApply = serviceUpdateNameToApply
    }

    private enum CodingKeys: String, CodingKey {
        case serviceUpdateNameToApply = "ServiceUpdateNameToApply"
    }
}

/// A list of updates being applied to the cluster
public struct ClusterPendingUpdates: Codable {
    public var resharding: Resharding?
    public var aCLs: ACLs?
    public var serviceUpdates: ServiceUpdates?

    public struct Resharding: Codable {
        /// The status of the online resharding
        public var reshardingStatus: ReshardingStatus
        /// The status of an online resharding operation.
        public var anyJSON: AnyJSON

        public init(reshardingStatus: ReshardingStatus, anyJSON: AnyJSON) {
            self.reshardingStatus = reshardingStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.reshardingStatus = try ReshardingStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(reshardingStatus, forKey: "reshardingStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ACLs: Codable {
        /// The status of the ACL update
        public var aCLsUpdateStatus: ACLsUpdateStatus
        /// A list of ACLs associated with the cluster that are being updated
        public var anyJSON: AnyJSON

        public init(aCLsUpdateStatus: ACLsUpdateStatus, anyJSON: AnyJSON) {
            self.aCLsUpdateStatus = aCLsUpdateStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.aCLsUpdateStatus = try ACLsUpdateStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(aCLsUpdateStatus, forKey: "aCLsUpdateStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ServiceUpdates: Codable {
        public var pendingModifiedServiceUpdates: [PendingModifiedServiceUpdate]
        /// A list of service updates being applied to the cluster
        public var anyJSON: AnyJSON

        public init(pendingModifiedServiceUpdates: [PendingModifiedServiceUpdate], anyJSON: AnyJSON) {
            self.pendingModifiedServiceUpdates = pendingModifiedServiceUpdates
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.pendingModifiedServiceUpdates = try values.decode([PendingModifiedServiceUpdate].self, forKey: "pendingModifiedServiceUpdates")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(pendingModifiedServiceUpdates, forKey: "pendingModifiedServiceUpdates")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(resharding: Resharding? = nil, aCLs: ACLs? = nil, serviceUpdates: ServiceUpdates? = nil) {
        self.resharding = resharding
        self.aCLs = aCLs
        self.serviceUpdates = serviceUpdates
    }

    private enum CodingKeys: String, CodingKey {
        case resharding = "Resharding"
        case aCLs = "ACLs"
        case serviceUpdates = "ServiceUpdates"
    }
}

/// Represents the information required for client programs to connect to the cluster and its nodes.
public struct Endpoint: Codable {
    public var address: Address?
    public var port: Port?

    public struct Address: Codable {
        public var string: String
        /// The DNS hostname of the node.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Port: Codable {
        public var int: Int
        /// The port number that the engine is listening on.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(address: Address? = nil, port: Port? = nil) {
        self.address = address
        self.port = port
    }

    private enum CodingKeys: String, CodingKey {
        case address = "Address"
        case port = "Port"
    }
}

/// Contains all of the attributes of a specific cluster.
public struct Cluster: Codable {
    public var name: Name?
    public var description: Description?
    public var status: Status?
    public var pendingUpdates: PendingUpdates?
    public var numberOfShards: NumberOfShards?
    public var shards: Shards?
    public var availabilityMode: AvailabilityMode?
    public var clusterEndpoint: ClusterEndpoint?
    public var nodeType: NodeType?
    public var engineVersion: EngineVersion?
    public var enginePatchVersion: EnginePatchVersion?
    public var parameterGroupName: ParameterGroupName?
    public var parameterGroupStatus: ParameterGroupStatus?
    public var securityGroups: SecurityGroups?
    public var subnetGroupName: SubnetGroupName?
    public var tlsEnabled: TLSEnabled?
    public var kmsKeyID: KmsKeyID?
    public var arn: Arn?
    public var snsTopicArn: SnsTopicArn?
    public var snsTopicStatus: SnsTopicStatus?
    public var snapshotRetentionLimit: SnapshotRetentionLimit?
    public var maintenanceWindow: MaintenanceWindow?
    public var snapshotWindow: SnapshotWindow?
    public var aCLName: ACLName?
    public var autoMinorVersionUpgrade: AutoMinorVersionUpgrade?

    public struct Name: Codable {
        public var string: String
        /// The user-supplied name of the cluster. This identifier is a unique key that identifies a cluster.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Description: Codable {
        public var string: String
        /// A description of the cluster
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        public var string: String
        /// The status of the cluster. For example, Available, Updating, Creating.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct PendingUpdates: Codable {
        /// A list of updates being applied to the cluster
        public var clusterPendingUpdates: ClusterPendingUpdates
        /// A group of settings that are currently being applied.
        public var anyJSON: AnyJSON

        public init(clusterPendingUpdates: ClusterPendingUpdates, anyJSON: AnyJSON) {
            self.clusterPendingUpdates = clusterPendingUpdates
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.clusterPendingUpdates = try ClusterPendingUpdates(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(clusterPendingUpdates, forKey: "clusterPendingUpdates")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NumberOfShards: Codable {
        public var int: Int
        /// The number of shards in the cluster
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Shards: Codable {
        public var shards: [Shard]
        /// A list of shards that are members of the cluster.
        public var anyJSON: AnyJSON

        public init(shards: [Shard], anyJSON: AnyJSON) {
            self.shards = shards
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.shards = try values.decode([Shard].self, forKey: "shards")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(shards, forKey: "shards")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AvailabilityMode: Codable {
        public var aZStatus: AZStatus
        /// Indicates if the cluster has a Multi-AZ configuration (multiaz) or not (singleaz).
        public var anyJSON: AnyJSON

        public init(aZStatus: AZStatus, anyJSON: AnyJSON) {
            self.aZStatus = aZStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.aZStatus = try AZStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(aZStatus, forKey: "aZStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ClusterEndpoint: Codable {
        /// Represents the information required for client programs to connect to the cluster and its nodes.
        public var endpoint: Endpoint
        /// The cluster's configuration endpoint
        public var anyJSON: AnyJSON

        public init(endpoint: Endpoint, anyJSON: AnyJSON) {
            self.endpoint = endpoint
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.endpoint = try Endpoint(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(endpoint, forKey: "endpoint")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NodeType: Codable {
        public var string: String
        /// The cluster's node type
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct EngineVersion: Codable {
        public var string: String
        /// The Redis engine version used by the cluster
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct EnginePatchVersion: Codable {
        public var string: String
        /// The Redis engine patch version used by the cluster
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ParameterGroupName: Codable {
        public var string: String
        /// The name of the parameter group used by the cluster
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ParameterGroupStatus: Codable {
        public var string: String
        /// The status of the parameter group used by the cluster, for example 'active' or 'applying'.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SecurityGroups: Codable {
        public var securityGroupMemberships: [SecurityGroupMembership]
        /// A list of security groups used by the cluster
        public var anyJSON: AnyJSON

        public init(securityGroupMemberships: [SecurityGroupMembership], anyJSON: AnyJSON) {
            self.securityGroupMemberships = securityGroupMemberships
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.securityGroupMemberships = try values.decode([SecurityGroupMembership].self, forKey: "securityGroupMemberships")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(securityGroupMemberships, forKey: "securityGroupMemberships")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SubnetGroupName: Codable {
        public var string: String
        /// The name of the subnet group used by the cluster
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct TLSEnabled: Codable {
        public var isBool: Bool
        /// A flag to indicate if In-transit encryption is enabled
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct KmsKeyID: Codable {
        public var string: String
        /// The ID of the KMS key used to encrypt the cluster
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Arn: Codable {
        public var string: String
        /// The Amazon Resource Name (ARN) of the cluster.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SnsTopicArn: Codable {
        public var string: String
        /// The Amazon Resource Name (ARN) of the SNS notification topic
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SnsTopicStatus: Codable {
        public var string: String
        /// The SNS topic must be in Active status to receive notifications
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SnapshotRetentionLimit: Codable {
        public var int: Int
        /// The number of days for which MemoryDB retains automatic snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, a snapshot that was taken today is retained for 5 days before being deleted.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct MaintenanceWindow: Codable {
        public var string: String
        /// Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SnapshotWindow: Codable {
        public var string: String
        /// The daily time range (in UTC) during which MemoryDB begins taking a daily snapshot of your shard. Example: 05:00-09:00 If you do not specify this parameter, MemoryDB automatically chooses an appropriate time range.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ACLName: Codable {
        public var string: String
        /// The name of the Access Control List associated with this cluster.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AutoMinorVersionUpgrade: Codable {
        public var isBool: Bool
        /// When set to true, the cluster will automatically receive minor engine version upgrades after launch.
        public var anyJSON: AnyJSON

        public init(isBool: Bool, anyJSON: AnyJSON) {
            self.isBool = isBool
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.isBool = try values.decode(Bool.self, forKey: "bool")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(isBool, forKey: "bool")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(name: Name? = nil, description: Description? = nil, status: Status? = nil, pendingUpdates: PendingUpdates? = nil, numberOfShards: NumberOfShards? = nil, shards: Shards? = nil, availabilityMode: AvailabilityMode? = nil, clusterEndpoint: ClusterEndpoint? = nil, nodeType: NodeType? = nil, engineVersion: EngineVersion? = nil, enginePatchVersion: EnginePatchVersion? = nil, parameterGroupName: ParameterGroupName? = nil, parameterGroupStatus: ParameterGroupStatus? = nil, securityGroups: SecurityGroups? = nil, subnetGroupName: SubnetGroupName? = nil, tlsEnabled: TLSEnabled? = nil, kmsKeyID: KmsKeyID? = nil, arn: Arn? = nil, snsTopicArn: SnsTopicArn? = nil, snsTopicStatus: SnsTopicStatus? = nil, snapshotRetentionLimit: SnapshotRetentionLimit? = nil, maintenanceWindow: MaintenanceWindow? = nil, snapshotWindow: SnapshotWindow? = nil, aCLName: ACLName? = nil, autoMinorVersionUpgrade: AutoMinorVersionUpgrade? = nil) {
        self.name = name
        self.description = description
        self.status = status
        self.pendingUpdates = pendingUpdates
        self.numberOfShards = numberOfShards
        self.shards = shards
        self.availabilityMode = availabilityMode
        self.clusterEndpoint = clusterEndpoint
        self.nodeType = nodeType
        self.engineVersion = engineVersion
        self.enginePatchVersion = enginePatchVersion
        self.parameterGroupName = parameterGroupName
        self.parameterGroupStatus = parameterGroupStatus
        self.securityGroups = securityGroups
        self.subnetGroupName = subnetGroupName
        self.tlsEnabled = tlsEnabled
        self.kmsKeyID = kmsKeyID
        self.arn = arn
        self.snsTopicArn = snsTopicArn
        self.snsTopicStatus = snsTopicStatus
        self.snapshotRetentionLimit = snapshotRetentionLimit
        self.maintenanceWindow = maintenanceWindow
        self.snapshotWindow = snapshotWindow
        self.aCLName = aCLName
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case description = "Description"
        case status = "Status"
        case pendingUpdates = "PendingUpdates"
        case numberOfShards = "NumberOfShards"
        case shards = "Shards"
        case availabilityMode = "AvailabilityMode"
        case clusterEndpoint = "ClusterEndpoint"
        case nodeType = "NodeType"
        case engineVersion = "EngineVersion"
        case enginePatchVersion = "EnginePatchVersion"
        case parameterGroupName = "ParameterGroupName"
        case parameterGroupStatus = "ParameterGroupStatus"
        case securityGroups = "SecurityGroups"
        case subnetGroupName = "SubnetGroupName"
        case tlsEnabled = "TLSEnabled"
        case kmsKeyID = "KmsKeyId"
        case arn = "ARN"
        case snsTopicArn = "SnsTopicArn"
        case snsTopicStatus = "SnsTopicStatus"
        case snapshotRetentionLimit = "SnapshotRetentionLimit"
        case maintenanceWindow = "MaintenanceWindow"
        case snapshotWindow = "SnapshotWindow"
        case aCLName = "ACLName"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
    }
}

/// A list of cluster configuration options.
public struct ClusterConfiguration: Codable {
    public var name: Name?
    public var description: Description?
    public var nodeType: NodeType?
    public var engineVersion: EngineVersion?
    public var maintenanceWindow: MaintenanceWindow?
    public var topicArn: TopicArn?
    public var port: Port?
    public var parameterGroupName: ParameterGroupName?
    public var subnetGroupName: SubnetGroupName?
    public var vpcID: VpcID?
    public var snapshotRetentionLimit: SnapshotRetentionLimit?
    public var snapshotWindow: SnapshotWindow?
    public var numShards: NumShards?
    public var shards: Shards?

    public struct Name: Codable {
        public var string: String
        /// The name of the cluster
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Description: Codable {
        public var string: String
        /// The description of the cluster configuration
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NodeType: Codable {
        public var string: String
        /// The node type used for the cluster
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct EngineVersion: Codable {
        public var string: String
        /// The Redis engine version used by the cluster
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct MaintenanceWindow: Codable {
        public var string: String
        /// The specified maintenance window for the cluster
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct TopicArn: Codable {
        public var string: String
        /// The Amazon Resource Name (ARN) of the SNS notification topic for the cluster
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Port: Codable {
        public var int: Int
        /// The port used by the cluster
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ParameterGroupName: Codable {
        public var string: String
        /// The name of parameter group used by the cluster
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SubnetGroupName: Codable {
        public var string: String
        /// The name of the subnet group used by the cluster
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct VpcID: Codable {
        public var string: String
        /// The ID of the VPC the cluster belongs to
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SnapshotRetentionLimit: Codable {
        public var int: Int
        /// The snapshot retention limit set by the cluster
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SnapshotWindow: Codable {
        public var string: String
        /// The snapshot window set by the cluster
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NumShards: Codable {
        public var int: Int
        /// The number of shards in the cluster
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Shards: Codable {
        public var shardDetails: [ShardDetail]
        /// The list of shards in the cluster
        public var anyJSON: AnyJSON

        public init(shardDetails: [ShardDetail], anyJSON: AnyJSON) {
            self.shardDetails = shardDetails
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.shardDetails = try values.decode([ShardDetail].self, forKey: "shardDetails")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(shardDetails, forKey: "shardDetails")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(name: Name? = nil, description: Description? = nil, nodeType: NodeType? = nil, engineVersion: EngineVersion? = nil, maintenanceWindow: MaintenanceWindow? = nil, topicArn: TopicArn? = nil, port: Port? = nil, parameterGroupName: ParameterGroupName? = nil, subnetGroupName: SubnetGroupName? = nil, vpcID: VpcID? = nil, snapshotRetentionLimit: SnapshotRetentionLimit? = nil, snapshotWindow: SnapshotWindow? = nil, numShards: NumShards? = nil, shards: Shards? = nil) {
        self.name = name
        self.description = description
        self.nodeType = nodeType
        self.engineVersion = engineVersion
        self.maintenanceWindow = maintenanceWindow
        self.topicArn = topicArn
        self.port = port
        self.parameterGroupName = parameterGroupName
        self.subnetGroupName = subnetGroupName
        self.vpcID = vpcID
        self.snapshotRetentionLimit = snapshotRetentionLimit
        self.snapshotWindow = snapshotWindow
        self.numShards = numShards
        self.shards = shards
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case description = "Description"
        case nodeType = "NodeType"
        case engineVersion = "EngineVersion"
        case maintenanceWindow = "MaintenanceWindow"
        case topicArn = "TopicArn"
        case port = "Port"
        case parameterGroupName = "ParameterGroupName"
        case subnetGroupName = "SubnetGroupName"
        case vpcID = "VpcId"
        case snapshotRetentionLimit = "SnapshotRetentionLimit"
        case snapshotWindow = "SnapshotWindow"
        case numShards = "NumShards"
        case shards = "Shards"
    }
}

/// The status of the online resharding
public struct ReshardingStatus: Codable {
    public var slotMigration: SlotMigration?

    public final class SlotMigration: Codable {
        /// Represents the progress of an online resharding operation.
        public var slotMigration: AmazonMemoryDBAPI.SlotMigration
        /// The status of the online resharding slot migration
        public var anyJSON: AnyJSON

        public init(slotMigration: AmazonMemoryDBAPI.SlotMigration, anyJSON: AnyJSON) {
            self.slotMigration = slotMigration
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.slotMigration = try values.decode(AmazonMemoryDBAPI.SlotMigration.self, forKey: "slotMigration")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(slotMigration, forKey: "slotMigration")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(slotMigration: SlotMigration? = nil) {
        self.slotMigration = slotMigration
    }

    private enum CodingKeys: String, CodingKey {
        case slotMigration = "SlotMigration"
    }
}

/// Represents a copy of an entire cluster as of the time when the snapshot was taken.
public struct Snapshot: Codable {
    public var name: Name?
    public var status: Status?
    public var source: Source?
    public var kmsKeyID: KmsKeyID?
    public var arn: Arn?
    public var clusterConfiguration: ClusterConfiguration?

    public struct Name: Codable {
        public var string: String
        /// The name of the snapshot
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        public var string: String
        /// The status of the snapshot. Valid values: creating | available | restoring | copying | deleting.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Source: Codable {
        public var string: String
        /// Indicates whether the snapshot is from an automatic backup (automated) or was created manually (manual).
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct KmsKeyID: Codable {
        public var string: String
        /// The ID of the KMS key used to encrypt the snapshot.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Arn: Codable {
        public var string: String
        /// The ARN (Amazon Resource Name) of the snapshot.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class ClusterConfiguration: Codable {
        /// A list of cluster configuration options.
        public var clusterConfiguration: AmazonMemoryDBAPI.ClusterConfiguration
        /// The configuration of the cluster from which the snapshot was taken
        public var anyJSON: AnyJSON

        public init(clusterConfiguration: AmazonMemoryDBAPI.ClusterConfiguration, anyJSON: AnyJSON) {
            self.clusterConfiguration = clusterConfiguration
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.clusterConfiguration = try values.decode(AmazonMemoryDBAPI.ClusterConfiguration.self, forKey: "clusterConfiguration")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(clusterConfiguration, forKey: "clusterConfiguration")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(name: Name? = nil, status: Status? = nil, source: Source? = nil, kmsKeyID: KmsKeyID? = nil, arn: Arn? = nil, clusterConfiguration: ClusterConfiguration? = nil) {
        self.name = name
        self.status = status
        self.source = source
        self.kmsKeyID = kmsKeyID
        self.arn = arn
        self.clusterConfiguration = clusterConfiguration
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case status = "Status"
        case source = "Source"
        case kmsKeyID = "KmsKeyId"
        case arn = "ARN"
        case clusterConfiguration = "ClusterConfiguration"
    }
}

/// Represents the output of a CreateParameterGroup operation. A parameter group represents a combination of specific values for the parameters that are passed to the engine software during startup.
public struct ParameterGroup: Codable {
    public var name: Name?
    public var family: Family?
    public var description: Description?
    public var arn: Arn?

    public struct Name: Codable {
        public var string: String
        /// The name of the parameter group
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Family: Codable {
        public var string: String
        /// The name of the parameter group family that this parameter group is compatible with.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Description: Codable {
        public var string: String
        /// A description of the parameter group
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Arn: Codable {
        public var string: String
        /// The Amazon Resource Name (ARN) of the parameter group
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(name: Name? = nil, family: Family? = nil, description: Description? = nil, arn: Arn? = nil) {
        self.name = name
        self.family = family
        self.description = description
        self.arn = arn
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case family = "Family"
        case description = "Description"
        case arn = "ARN"
    }
}

/// <p>Represents the output of one of the following operations:</p> <ul> <li> <p>CreateSubnetGroup</p> </li> <li> <p>UpdateSubnetGroup</p> </li> </ul> <p>A subnet group is a collection of subnets (typically private) that you can designate for your clusters running in an Amazon Virtual Private Cloud (VPC) environment.</p>
public struct SubnetGroup: Codable {
    public var name: Name?
    public var description: Description?
    public var vpcID: VpcID?
    public var subnets: Subnets?
    public var arn: Arn?

    public struct Name: Codable {
        public var string: String
        /// The name of the subnet group
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Description: Codable {
        public var string: String
        /// A description of the subnet group
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct VpcID: Codable {
        public var string: String
        /// The Amazon Virtual Private Cloud identifier (VPC ID) of the subnet group.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Subnets: Codable {
        public var subnets: [Subnet]
        /// A list of subnets associated with the subnet group.
        public var anyJSON: AnyJSON

        public init(subnets: [Subnet], anyJSON: AnyJSON) {
            self.subnets = subnets
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.subnets = try values.decode([Subnet].self, forKey: "subnets")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(subnets, forKey: "subnets")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Arn: Codable {
        public var string: String
        /// The ARN (Amazon Resource Name) of the subnet group.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(name: Name? = nil, description: Description? = nil, vpcID: VpcID? = nil, subnets: Subnets? = nil, arn: Arn? = nil) {
        self.name = name
        self.description = description
        self.vpcID = vpcID
        self.subnets = subnets
        self.arn = arn
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case description = "Description"
        case vpcID = "VpcId"
        case subnets = "Subnets"
        case arn = "ARN"
    }
}

/// You create users and assign them specific permissions by using an access string. You assign the users to Access Control Lists aligned with a specific role (administrators, human resources) that are then deployed to one or more MemoryDB clusters.
public struct User: Codable {
    public var name: Name?
    public var status: Status?
    public var accessString: AccessString?
    public var aCLNames: ACLNames?
    public var minimumEngineVersion: MinimumEngineVersion?
    public var authentication: Authentication?
    public var arn: Arn?

    public struct Name: Codable {
        public var string: String
        /// The name of the user
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        public var string: String
        /// Indicates the user status. Can be "active", "modifying" or "deleting".
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AccessString: Codable {
        public var string: String
        /// Access permissions string used for this user.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ACLNames: Codable {
        public var strings: [String]
        /// The names of the Access Control Lists to which the user belongs
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct MinimumEngineVersion: Codable {
        public var string: String
        /// The minimum engine version supported for the user
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class Authentication: Codable {
        /// Denotes the user's authentication properties, such as whether it requires a password to authenticate. Used in output responses.
        public var authentication: AmazonMemoryDBAPI.Authentication
        /// Denotes whether the user requires a password to authenticate.
        public var anyJSON: AnyJSON

        public init(authentication: AmazonMemoryDBAPI.Authentication, anyJSON: AnyJSON) {
            self.authentication = authentication
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.authentication = try values.decode(AmazonMemoryDBAPI.Authentication.self, forKey: "authentication")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(authentication, forKey: "authentication")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Arn: Codable {
        public var string: String
        /// The Amazon Resource Name (ARN) of the user.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(name: Name? = nil, status: Status? = nil, accessString: AccessString? = nil, aCLNames: ACLNames? = nil, minimumEngineVersion: MinimumEngineVersion? = nil, authentication: Authentication? = nil, arn: Arn? = nil) {
        self.name = name
        self.status = status
        self.accessString = accessString
        self.aCLNames = aCLNames
        self.minimumEngineVersion = minimumEngineVersion
        self.authentication = authentication
        self.arn = arn
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case status = "Status"
        case accessString = "AccessString"
        case aCLNames = "ACLNames"
        case minimumEngineVersion = "MinimumEngineVersion"
        case authentication = "Authentication"
        case arn = "ARN"
    }
}

public enum SourceType: String, Codable, CaseIterable {
    case node
    case parameterGroup = "parameter-group"
    case subnetGroup = "subnet-group"
    case cluster
    case user
    case acl
}

/// Provides details of the Redis engine version
public struct EngineVersionInfo: Codable {
    public var engineVersion: EngineVersion?
    public var enginePatchVersion: EnginePatchVersion?
    public var parameterGroupFamily: ParameterGroupFamily?

    public struct EngineVersion: Codable {
        public var string: String
        /// The engine version
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct EnginePatchVersion: Codable {
        public var string: String
        /// The patched engine version
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ParameterGroupFamily: Codable {
        public var string: String
        /// Specifies the name of the parameter group family to which the engine default parameters apply.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(engineVersion: EngineVersion? = nil, enginePatchVersion: EnginePatchVersion? = nil, parameterGroupFamily: ParameterGroupFamily? = nil) {
        self.engineVersion = engineVersion
        self.enginePatchVersion = enginePatchVersion
        self.parameterGroupFamily = parameterGroupFamily
    }

    private enum CodingKeys: String, CodingKey {
        case engineVersion = "EngineVersion"
        case enginePatchVersion = "EnginePatchVersion"
        case parameterGroupFamily = "ParameterGroupFamily"
    }
}

/// Represents a single occurrence of something interesting within the system. Some examples of events are creating a cluster or adding or removing a node.
public struct Event: Codable {
    public var sourceName: SourceName?
    public var sourceType: SourceType?
    public var message: Message?
    public var date: Date?

    public struct SourceName: Codable {
        public var string: String
        /// The name for the source of the event. For example, if the event occurred at the cluster level, the identifier would be the name of the cluster.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class SourceType: Codable {
        public var sourceType: AmazonMemoryDBAPI.SourceType
        /// Specifies the origin of this event - a cluster, a parameter group, a security group, etc.
        public var anyJSON: AnyJSON

        public init(sourceType: AmazonMemoryDBAPI.SourceType, anyJSON: AnyJSON) {
            self.sourceType = sourceType
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.sourceType = try values.decode(AmazonMemoryDBAPI.SourceType.self, forKey: "sourceType")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(sourceType, forKey: "sourceType")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Message: Codable {
        public var string: String
        /// The text of the event.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Date: Codable {
        public var date: Date
        /// The date and time when the event occurred.
        public var anyJSON: AnyJSON

        public init(date: Date, anyJSON: AnyJSON) {
            self.date = date
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.date = try values.decode(Date.self, forKey: "date")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(date, forKey: "date")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(sourceName: SourceName? = nil, sourceType: SourceType? = nil, message: Message? = nil, date: Date? = nil) {
        self.sourceName = sourceName
        self.sourceType = sourceType
        self.message = message
        self.date = date
    }

    private enum CodingKeys: String, CodingKey {
        case sourceName = "SourceName"
        case sourceType = "SourceType"
        case message = "Message"
        case date = "Date"
    }
}

/// Used to streamline results of a search based on the property being filtered.
public struct Filter: Codable {
    public var name: Name
    public var values: Values

    public struct Name: Codable {
        public var string: String
        /// The property being filtered. For example, UserName.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Values: Codable {
        public var strings: [String]
        /// The property values to filter on. For example, "user-123".
        public var anyJSON: AnyJSON

        public init(strings: [String], anyJSON: AnyJSON) {
            self.strings = strings
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.strings = try values.decode([String].self, forKey: "strings")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(strings, forKey: "strings")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(name: Name, values: Values) {
        self.name = name
        self.values = values
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case values = "Values"
    }
}

/// Represents an individual node within a cluster. Each node runs its own instance of the cluster's protocol-compliant caching software.
public struct Node: Codable {
    public var name: Name?
    public var status: Status?
    public var availabilityZone: AvailabilityZone?
    public var createTime: CreateTime?
    public var endpoint: Endpoint?

    public struct Name: Codable {
        public var string: String
        /// The node identifier. A node name is a numeric identifier (0001, 0002, etc.). The combination of cluster name, shard name and node name uniquely identifies every node used in a customer's Amazon account.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        public var string: String
        /// The status of the service update on the node
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AvailabilityZone: Codable {
        public var string: String
        /// The Availability Zone in which the node resides
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct CreateTime: Codable {
        public var date: Date
        /// The date and time when the node was created.
        public var anyJSON: AnyJSON

        public init(date: Date, anyJSON: AnyJSON) {
            self.date = date
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.date = try values.decode(Date.self, forKey: "date")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(date, forKey: "date")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class Endpoint: Codable {
        /// Represents the information required for client programs to connect to the cluster and its nodes.
        public var endpoint: AmazonMemoryDBAPI.Endpoint
        /// The hostname for connecting to this node.
        public var anyJSON: AnyJSON

        public init(endpoint: AmazonMemoryDBAPI.Endpoint, anyJSON: AnyJSON) {
            self.endpoint = endpoint
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.endpoint = try values.decode(AmazonMemoryDBAPI.Endpoint.self, forKey: "endpoint")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(endpoint, forKey: "endpoint")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(name: Name? = nil, status: Status? = nil, availabilityZone: AvailabilityZone? = nil, createTime: CreateTime? = nil, endpoint: Endpoint? = nil) {
        self.name = name
        self.status = status
        self.availabilityZone = availabilityZone
        self.createTime = createTime
        self.endpoint = endpoint
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case status = "Status"
        case availabilityZone = "AvailabilityZone"
        case createTime = "CreateTime"
        case endpoint = "Endpoint"
    }
}

/// Describes an individual setting that controls some aspect of MemoryDB behavior.
public struct Parameter: Codable {
    public var name: Name?
    public var value: Value?
    public var description: Description?
    public var dataType: DataType?
    public var allowedValues: AllowedValues?
    public var minimumEngineVersion: MinimumEngineVersion?

    public struct Name: Codable {
        public var string: String
        /// The name of the parameter
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Value: Codable {
        public var string: String
        /// The value of the parameter
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Description: Codable {
        public var string: String
        /// A description of the parameter
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct DataType: Codable {
        public var string: String
        /// The parameter's data type
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AllowedValues: Codable {
        public var string: String
        /// The valid range of values for the parameter.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct MinimumEngineVersion: Codable {
        public var string: String
        /// The earliest engine version to which the parameter can apply.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(name: Name? = nil, value: Value? = nil, description: Description? = nil, dataType: DataType? = nil, allowedValues: AllowedValues? = nil, minimumEngineVersion: MinimumEngineVersion? = nil) {
        self.name = name
        self.value = value
        self.description = description
        self.dataType = dataType
        self.allowedValues = allowedValues
        self.minimumEngineVersion = minimumEngineVersion
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
        case description = "Description"
        case dataType = "DataType"
        case allowedValues = "AllowedValues"
        case minimumEngineVersion = "MinimumEngineVersion"
    }
}

/// Describes a name-value pair that is used to update the value of a parameter.
public struct ParameterNameValue: Codable {
    public var parameterName: ParameterName?
    public var parameterValue: ParameterValue?

    public struct ParameterName: Codable {
        public var string: String
        /// The name of the parameter
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ParameterValue: Codable {
        public var string: String
        /// The value of the parameter
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(parameterName: ParameterName? = nil, parameterValue: ParameterValue? = nil) {
        self.parameterName = parameterName
        self.parameterValue = parameterValue
    }

    private enum CodingKeys: String, CodingKey {
        case parameterName = "ParameterName"
        case parameterValue = "ParameterValue"
    }
}

public enum ServiceUpdateStatus: String, Codable, CaseIterable {
    case available
    case inProgress = "in-progress"
    case complete
    case scheduled
}

/// Update action that has yet to be processed for the corresponding apply/stop request
public struct PendingModifiedServiceUpdate: Codable {
    public var serviceUpdateName: ServiceUpdateName?
    public var status: Status?

    public struct ServiceUpdateName: Codable {
        public var string: String
        /// The unique ID of the service update
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        public var serviceUpdateStatus: ServiceUpdateStatus
        /// The status of the service update
        public var anyJSON: AnyJSON

        public init(serviceUpdateStatus: ServiceUpdateStatus, anyJSON: AnyJSON) {
            self.serviceUpdateStatus = serviceUpdateStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.serviceUpdateStatus = try ServiceUpdateStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(serviceUpdateStatus, forKey: "serviceUpdateStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(serviceUpdateName: ServiceUpdateName? = nil, status: Status? = nil) {
        self.serviceUpdateName = serviceUpdateName
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case serviceUpdateName = "ServiceUpdateName"
        case status = "Status"
    }
}

/// A request to configure the number of replicas in a shard
public struct ReplicaConfigurationRequest: Codable {
    public var replicaCount: ReplicaCount?

    public struct ReplicaCount: Codable {
        public var int: Int
        /// The number of replicas to scale up or down to
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(replicaCount: ReplicaCount? = nil) {
        self.replicaCount = replicaCount
    }

    private enum CodingKeys: String, CodingKey {
        case replicaCount = "ReplicaCount"
    }
}

/// Represents the progress of an online resharding operation.
public struct SlotMigration: Codable {
    public var progressPercentage: ProgressPercentage?

    public struct ProgressPercentage: Codable {
        public var double: Double
        /// The percentage of the slot migration that is complete.
        public var anyJSON: AnyJSON

        public init(double: Double, anyJSON: AnyJSON) {
            self.double = double
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.double = try values.decode(Double.self, forKey: "double")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(double, forKey: "double")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(progressPercentage: ProgressPercentage? = nil) {
        self.progressPercentage = progressPercentage
    }

    private enum CodingKeys: String, CodingKey {
        case progressPercentage = "ProgressPercentage"
    }
}

/// Represents a single security group and its status.
public struct SecurityGroupMembership: Codable {
    public var securityGroupID: SecurityGroupID?
    public var status: Status?

    public struct SecurityGroupID: Codable {
        public var string: String
        /// The identifier of the security group.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        public var string: String
        /// The status of the security group membership. The status changes whenever a security group is modified, or when the security groups assigned to a cluster are modified.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(securityGroupID: SecurityGroupID? = nil, status: Status? = nil) {
        self.securityGroupID = securityGroupID
        self.status = status
    }

    private enum CodingKeys: String, CodingKey {
        case securityGroupID = "SecurityGroupId"
        case status = "Status"
    }
}

public enum ServiceUpdateType: String, Codable, CaseIterable {
    case securityUpdate = "security-update"
}

/// An update that you can apply to your MemoryDB clusters.
public struct ServiceUpdate: Codable {
    public var clusterName: ClusterName?
    public var serviceUpdateName: ServiceUpdateName?
    public var releaseDate: ReleaseDate?
    public var description: Description?
    public var status: Status?
    public var type: `Type`?
    public var nodesUpdated: NodesUpdated?
    public var autoUpdateStartDate: AutoUpdateStartDate?

    public struct ClusterName: Codable {
        public var string: String
        /// The name of the cluster to which the service update applies
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ServiceUpdateName: Codable {
        public var string: String
        /// The unique ID of the service update
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ReleaseDate: Codable {
        public var date: Date
        /// The date when the service update is initially available
        public var anyJSON: AnyJSON

        public init(date: Date, anyJSON: AnyJSON) {
            self.date = date
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.date = try values.decode(Date.self, forKey: "date")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(date, forKey: "date")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Description: Codable {
        public var string: String
        /// Provides details of the service update
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        public var serviceUpdateStatus: ServiceUpdateStatus
        /// The status of the service update
        public var anyJSON: AnyJSON

        public init(serviceUpdateStatus: ServiceUpdateStatus, anyJSON: AnyJSON) {
            self.serviceUpdateStatus = serviceUpdateStatus
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.serviceUpdateStatus = try ServiceUpdateStatus(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(serviceUpdateStatus, forKey: "serviceUpdateStatus")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct `Type`: Codable {
        public var serviceUpdateType: ServiceUpdateType
        /// Reflects the nature of the service update
        public var anyJSON: AnyJSON

        public init(serviceUpdateType: ServiceUpdateType, anyJSON: AnyJSON) {
            self.serviceUpdateType = serviceUpdateType
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.serviceUpdateType = try ServiceUpdateType(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(serviceUpdateType, forKey: "serviceUpdateType")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NodesUpdated: Codable {
        public var string: String
        /// A list of nodes updated by the service update
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct AutoUpdateStartDate: Codable {
        public var date: Date
        /// The date at which the service update will be automatically applied
        public var anyJSON: AnyJSON

        public init(date: Date, anyJSON: AnyJSON) {
            self.date = date
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.date = try values.decode(Date.self, forKey: "date")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(date, forKey: "date")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(clusterName: ClusterName? = nil, serviceUpdateName: ServiceUpdateName? = nil, releaseDate: ReleaseDate? = nil, description: Description? = nil, status: Status? = nil, type: `Type`? = nil, nodesUpdated: NodesUpdated? = nil, autoUpdateStartDate: AutoUpdateStartDate? = nil) {
        self.clusterName = clusterName
        self.serviceUpdateName = serviceUpdateName
        self.releaseDate = releaseDate
        self.description = description
        self.status = status
        self.type = type
        self.nodesUpdated = nodesUpdated
        self.autoUpdateStartDate = autoUpdateStartDate
    }

    private enum CodingKeys: String, CodingKey {
        case clusterName = "ClusterName"
        case serviceUpdateName = "ServiceUpdateName"
        case releaseDate = "ReleaseDate"
        case description = "Description"
        case status = "Status"
        case type = "Type"
        case nodesUpdated = "NodesUpdated"
        case autoUpdateStartDate = "AutoUpdateStartDate"
    }
}

/// Represents a collection of nodes in a cluster. One node in the node group is the read/write primary node. All the other nodes are read-only Replica nodes.
public struct Shard: Codable {
    public var name: Name?
    public var status: Status?
    public var slots: Slots?
    public var nodes: Nodes?
    public var numberOfNodes: NumberOfNodes?

    public struct Name: Codable {
        public var string: String
        /// The name of the shard
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Status: Codable {
        public var string: String
        /// The current state of this replication group - creating, available, modifying, deleting.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Slots: Codable {
        public var string: String
        /// The keyspace for this shard.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Nodes: Codable {
        public var nodes: [Node]
        /// A list containing information about individual nodes within the shard
        public var anyJSON: AnyJSON

        public init(nodes: [Node], anyJSON: AnyJSON) {
            self.nodes = nodes
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.nodes = try values.decode([Node].self, forKey: "nodes")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(nodes, forKey: "nodes")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct NumberOfNodes: Codable {
        public var int: Int
        /// The number of nodes in the shard
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(name: Name? = nil, status: Status? = nil, slots: Slots? = nil, nodes: Nodes? = nil, numberOfNodes: NumberOfNodes? = nil) {
        self.name = name
        self.status = status
        self.slots = slots
        self.nodes = nodes
        self.numberOfNodes = numberOfNodes
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case status = "Status"
        case slots = "Slots"
        case nodes = "Nodes"
        case numberOfNodes = "NumberOfNodes"
    }
}

/// Shard configuration options. Each shard configuration has the following: Slots and ReplicaCount.
public struct ShardConfiguration: Codable {
    public var slots: Slots?
    public var replicaCount: ReplicaCount?

    public struct Slots: Codable {
        public var string: String
        /// A string that specifies the keyspace for a particular node group. Keyspaces range from 0 to 16,383. The string is in the format startkey-endkey.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ReplicaCount: Codable {
        public var int: Int
        /// The number of read replica nodes in this shard.
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(slots: Slots? = nil, replicaCount: ReplicaCount? = nil) {
        self.slots = slots
        self.replicaCount = replicaCount
    }

    private enum CodingKeys: String, CodingKey {
        case slots = "Slots"
        case replicaCount = "ReplicaCount"
    }
}

/// A request to configure the sharding properties of a cluster
public struct ShardConfigurationRequest: Codable {
    public var shardCount: ShardCount?

    public struct ShardCount: Codable {
        public var int: Int
        /// The number of shards in the cluster
        public var anyJSON: AnyJSON

        public init(int: Int, anyJSON: AnyJSON) {
            self.int = int
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.int = try values.decode(Int.self, forKey: "int")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(int, forKey: "int")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(shardCount: ShardCount? = nil) {
        self.shardCount = shardCount
    }

    private enum CodingKeys: String, CodingKey {
        case shardCount = "ShardCount"
    }
}

/// Provides details of a shard in a snapshot
public struct ShardDetail: Codable {
    public var name: Name?
    public var configuration: Configuration?
    public var size: Size?
    public var snapshotCreationTime: SnapshotCreationTime?

    public struct Name: Codable {
        public var string: String
        /// The name of the shard
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Configuration: Codable {
        /// Shard configuration options. Each shard configuration has the following: Slots and ReplicaCount.
        public var shardConfiguration: ShardConfiguration
        /// The configuration details of the shard
        public var anyJSON: AnyJSON

        public init(shardConfiguration: ShardConfiguration, anyJSON: AnyJSON) {
            self.shardConfiguration = shardConfiguration
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            self.shardConfiguration = try ShardConfiguration(from: decoder)
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(shardConfiguration, forKey: "shardConfiguration")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Size: Codable {
        public var string: String
        /// The size of the shard's snapshot
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct SnapshotCreationTime: Codable {
        public var date: Date
        /// The date and time that the shard's snapshot was created
        public var anyJSON: AnyJSON

        public init(date: Date, anyJSON: AnyJSON) {
            self.date = date
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.date = try values.decode(Date.self, forKey: "date")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(date, forKey: "date")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(name: Name? = nil, configuration: Configuration? = nil, size: Size? = nil, snapshotCreationTime: SnapshotCreationTime? = nil) {
        self.name = name
        self.configuration = configuration
        self.size = size
        self.snapshotCreationTime = snapshotCreationTime
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case configuration = "Configuration"
        case size = "Size"
        case snapshotCreationTime = "SnapshotCreationTime"
    }
}

/// Represents the subnet associated with a cluster. This parameter refers to subnets defined in Amazon Virtual Private Cloud (Amazon VPC) and used with MemoryDB.
public struct Subnet: Codable {
    public var identifier: Identifier?
    public var availabilityZone: AvailabilityZone?

    public struct Identifier: Codable {
        public var string: String
        /// The unique identifier for the subnet.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public final class AvailabilityZone: Codable {
        /// Indicates if the cluster has a Multi-AZ configuration (multiaz) or not (singleaz).
        public var availabilityZone: AmazonMemoryDBAPI.AvailabilityZone
        /// The Availability Zone where the subnet resides
        public var anyJSON: AnyJSON

        public init(availabilityZone: AmazonMemoryDBAPI.AvailabilityZone, anyJSON: AnyJSON) {
            self.availabilityZone = availabilityZone
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.availabilityZone = try values.decode(AmazonMemoryDBAPI.AvailabilityZone.self, forKey: "availabilityZone")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(availabilityZone, forKey: "availabilityZone")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(identifier: Identifier? = nil, availabilityZone: AvailabilityZone? = nil) {
        self.identifier = identifier
        self.availabilityZone = availabilityZone
    }

    private enum CodingKeys: String, CodingKey {
        case identifier = "Identifier"
        case availabilityZone = "AvailabilityZone"
    }
}

/// A tag that can be added to an MemoryDB resource. Tags are composed of a Key/Value pair. You can use tags to categorize and track all your MemoryDB resources. When you add or remove tags on clusters, those actions will be replicated to all nodes in the cluster. A tag with a null Value is permitted. For more information, see <a href="https://docs.aws.amazon.com/MemoryDB/latest/devguide/tagging-resources.html">Tagging your MemoryDB resources</a>
public struct Tag: Codable {
    public var key: Key?
    public var value: Value?

    public struct Key: Codable {
        public var string: String
        /// The key for the tag. May not be null.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct Value: Codable {
        public var string: String
        /// The tag's value. May be null.
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(key: Key? = nil, value: Value? = nil) {
        self.key = key
        self.value = value
    }

    private enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }
}

/// A cluster whose updates have failed
public struct UnprocessedCluster: Codable {
    public var clusterName: ClusterName?
    public var errorType: ErrorType?
    public var errorMessage: ErrorMessage?

    public struct ClusterName: Codable {
        public var string: String
        /// The name of the cluster
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ErrorType: Codable {
        public var string: String
        /// The error type associated with the update failure
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public struct ErrorMessage: Codable {
        public var string: String
        /// The error message associated with the update failure
        public var anyJSON: AnyJSON

        public init(string: String, anyJSON: AnyJSON) {
            self.string = string
            self.anyJSON = anyJSON
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.string = try values.decode(String.self, forKey: "string")
            self.anyJSON = try AnyJSON(from: decoder)
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(string, forKey: "string")
            try values.encode(anyJSON, forKey: "anyJSON")
        }
    }

    public init(clusterName: ClusterName? = nil, errorType: ErrorType? = nil, errorMessage: ErrorMessage? = nil) {
        self.clusterName = clusterName
        self.errorType = errorType
        self.errorMessage = errorMessage
    }

    private enum CodingKeys: String, CodingKey {
        case clusterName = "ClusterName"
        case errorType = "ErrorType"
        case errorMessage = "ErrorMessage"
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
